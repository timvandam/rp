{"input":"<s> /**<EOL> * Immutable array splice<EOL> */<EOL>export function removeItemFromArray(array: ReadonlyArray<any>, index: number) {<EOL>    return {<EOL>        item: array[index],<EOL>","gt":"array: ["}
{"input":"<s> /**<EOL> * Return Vega Expression for a particular date time.<EOL> * @param d<EOL> * @param normalize whether to normalize quarter, month, day.<EOL> */<EOL>export function dateTimeExpr(d: DateTime | DateTimeExpr, normalize = false) {<EOL>    const units: (string | number)[] = [];<EOL>    if (normalize && d.day !== undefined) {<EOL>","gt":"if (keys(d).length > <NUM_LIT>) {"}
{"input":"<s> /**<EOL> * Return Vega Expression for a particular date time.<EOL> * @param d<EOL> * @param normalize whether to normalize quarter, month, day.<EOL> */<EOL>export function dateTimeExpr(d: DateTime | DateTimeExpr, normalize = false) {<EOL>    const units: (string | number)[] = [];<EOL>    if (normalize && d.day !== undefined) {<EOL>        if (keys(d).length > <NUM_LIT>) {<EOL>            log.warn(log.message.droppedDay(d));<EOL>            d =","gt":"duplicate(d);"}
{"input":"<s> /**<EOL> * Return Vega Expression for a particular date time.<EOL> * @param d<EOL> * @param normalize whether to normalize quarter, month, day.<EOL> */<EOL>export function dateTimeExpr(d: DateTime | DateTimeExpr, normalize = false) {<EOL>    const units: (string | number)[] = [];<EOL>    if (normalize && d.day !== undefined) {<EOL>        if (keys(d).length > <NUM_LIT>) {<EOL>            log.warn(log.message.droppedDay(d));<EOL>            d = duplicate(d);<EOL>            delete d.day;<EOL>        }<EOL>    }<EOL>    if (d.year !== undefined) {<EOL>        units.push(d.year);<EOL>    }<EOL>    else","gt":"if (d.day !== undefined) {"}
{"input":"<s> /**<EOL> * Return Vega Expression for a particular date time.<EOL> * @param d<EOL> * @param normalize whether to normalize quarter, month, day.<EOL> */<EOL>export function dateTimeExpr(d: DateTime | DateTimeExpr, normalize = false) {<EOL>    const units: (string | number)[] = [];<EOL>    if (normalize && d.day !== undefined) {<EOL>        if (keys(d).length > <NUM_LIT>) {<EOL>            log.warn(log.message.droppedDay(d));<EOL>            d = duplicate(d);<EOL>            delete d.day;<EOL>        }<EOL>    }<EOL>    if (d.year !== undefined) {<EOL>        units.push(d.year);<EOL>    }<EOL>    else if (d.day !== undefined) {<EOL>        <EOL>        units.push(SUNDAY_YEAR);<EOL>    }<EOL>    else {<EOL>        units.push(<NUM_LIT>);<EOL>    }<EOL>    if (d.month !== undefined) {<EOL>        const month = normalize ? normalizeMonth(d.month) : d.month;<EOL>        units.push(month);<EOL>    }<EOL>    else if (d.quarter !== undefined) {<EOL>        const quarter = normalize ? normalizeQuarter(d.","gt":"quarter) : d.quarter;"}
{"input":"<s> /**<EOL> * Return Vega Expression for a particular date time.<EOL> * @param d<EOL> * @param normalize whether to normalize quarter, month, day.<EOL> */<EOL>export function dateTimeExpr(d: DateTime | DateTimeExpr, normalize = false) {<EOL>    const units: (string | number)[] = [];<EOL>    if (normalize && d.day !== undefined) {<EOL>        if (keys(d).length > <NUM_LIT>) {<EOL>            log.warn(log.message.droppedDay(d));<EOL>            d = duplicate(d);<EOL>            delete d.day;<EOL>        }<EOL>    }<EOL>    if (d.year !== undefined) {<EOL>        units.push(d.year);<EOL>    }<EOL>    else if (d.day !== undefined) {<EOL>        <EOL>        units.push(SUNDAY_YEAR);<EOL>    }<EOL>    else {<EOL>        units.push(<NUM_LIT>);<EOL>    }<EOL>    if (d.month !== undefined) {<EOL>        const month = normalize ? normalizeMonth(d.month) : d.month;<EOL>        units.push(month);<EOL>    }<EOL>    else if (d.quarter !== undefined) {<EOL>        const quarter = normalize ? normalizeQuarter(d.quarter) : d.quarter;<EOL>        units.push(quarter + '<STR_LIT>');<EOL>    }<EOL>    else {<EOL>        units.push(<NUM_LIT>); <EOL>    }<EOL>    if (d.date !== undefined) {<EOL>        units.","gt":"push(d.date);"}
{"input":"<s> /**<EOL> * Return Vega Expression for a particular date time.<EOL> * @param d<EOL> * @param normalize whether to normalize quarter, month, day.<EOL> */<EOL>export function dateTimeExpr(d: DateTime | DateTimeExpr, normalize = false) {<EOL>    const units: (string | number)[] = [];<EOL>    if (normalize && d.day !== undefined) {<EOL>        if (keys(d).length > <NUM_LIT>) {<EOL>            log.warn(log.message.droppedDay(d));<EOL>            d = duplicate(d);<EOL>            delete d.day;<EOL>        }<EOL>    }<EOL>    if (d.year !== undefined) {<EOL>        units.push(d.year);<EOL>    }<EOL>    else if (d.day !== undefined) {<EOL>        <EOL>        units.push(SUNDAY_YEAR);<EOL>    }<EOL>    else {<EOL>        units.push(<NUM_LIT>);<EOL>    }<EOL>    if (d.month !== undefined) {<EOL>        const month = normalize ? normalizeMonth(d.month) : d.month;<EOL>        units.push(month);<EOL>    }<EOL>    else if (d.quarter !== undefined) {<EOL>        const quarter = normalize ? normalizeQuarter(d.quarter) : d.quarter;<EOL>        units.push(quarter + '<STR_LIT>');<EOL>    }<EOL>    else {<EOL>        units.push(<NUM_LIT>); <EOL>    }<EOL>    if (d.date !== undefined) {<EOL>        units.push(d.date);<EOL>    }<EOL>    else if (d.day !== undefined) {<EOL>        <EOL>        <EOL>        const day = normalize ? normalizeDay(d.day) : d.day;<EOL>        units.push(day + '<STR_LIT>');<EOL>    }<EOL>    else {<EOL>        units.push(<NUM_LIT>); <EOL>    }<EOL>    <EOL>    <EOL>    for (const timeUnit of ['<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>']) {<EOL>        if (d[timeUnit] !== undefined) {<EOL>            units.push(d[timeUnit]);<EOL>        }<EOL>","gt":"else {"}
{"input":"<s> export async function handler(context: Context) {<EOL>    const { schemaPath } = await context.getProjectConfig();<EOL>    if (!schemaPath) {<EOL>        throw new Error('<STR_LIT>');<EOL>    }<EOL>    const relativeSchemaPath = relative(","gt":"process.cwd(), schemaPath);"}
{"input":"<s> export async function handler(context: Context) {<EOL>    const { schemaPath } = await context.getProjectConfig();<EOL>    if (!schemaPath) {<EOL>        throw new Error('<STR_LIT>');<EOL>    }<EOL>    const relativeSchemaPath = relative(process.cwd(), schemaPath);<EOL>    if (!existsSync(schemaPath)) {<EOL>        console.log(chalk.yellow(\"<STR_LIT>\") +<EOL>            chalk.","gt":"blue(relativeSchemaPath));"}
{"input":"<s> export async function handler(context: Context) {<EOL>    const { schemaPath } = await context.getProjectConfig();<EOL>    if (!schemaPath) {<EOL>        throw new Error('<STR_LIT>');<EOL>    }<EOL>    const relativeSchemaPath = relative(process.cwd(), schemaPath);<EOL>    if (!existsSync(schemaPath)) {<EOL>        console.log(chalk.yellow(\"<STR_LIT>\") +<EOL>            chalk.blue(relativeSchemaPath));<EOL>        return;<EOL>    }<EOL>","gt":"const extensions = {"}
{"input":"<s> export async function handler(context: Context) {<EOL>    const { schemaPath } = await context.getProjectConfig();<EOL>    if (!schemaPath) {<EOL>        throw new Error('<STR_LIT>');<EOL>    }<EOL>    const relativeSchemaPath = relative(process.cwd(), schemaPath);<EOL>    if (!existsSync(schemaPath)) {<EOL>        console.log(chalk.yellow(\"<STR_LIT>\") +<EOL>            chalk.blue(relativeSchemaPath));<EOL>        return;<EOL>    }<EOL>    const extensions = {<EOL>        schemaPath: relativeSchemaPath,<EOL>        ...getSchemaExtensions(schemaPath),<EOL>    };<EOL>    const maxLength = _(extensions)<EOL>        .keys()<EOL>        .map('<STR_LIT>')<EOL>        .max();<EOL>","gt":"for (let name in extensions) {"}
{"input":"<s> function carouselHide(slides: NodeListOf<any>, indicators: NodeListOf<any>, links: NodeListOf<any>, active: number) {<EOL>    indicators[active].setAttribute('<STR_LIT>', '<STR_LIT>');<EOL>    links[active].setAttribute('<STR_LIT>', '<STR_LIT>');<EOL>    slides[active].setAttribute('<STR_LIT>',","gt":"'<STR_LIT>');"}
{"input":"<s> export function constructLogString(inputLogs: Array<{<EOL>    action: {<EOL>        type: string;<EOL>        payload: any;<EOL>    };<EOL>    timestamp: number;<EOL>}>): Array<{<EOL>    type: string;<EOL>    timestamp: number;<EOL>    ISOString: string;<EOL>    payload: string;<EOL>}> {<EOL>    const outputLogs = [];<EOL>    for (const inputLog of inputLogs) {<EOL>        const type = inputLog.action.type;<EOL>        let payload: any = inputLog.action.payload;<EOL>        if (type === DATASET_RECEIVE && isInlineData(payload.data)) {<EOL>            <EOL>            payload = {<EOL>                ...payload,<EOL>                data: { name: '<STR_LIT>' }<EOL>            };<EOL>        }<EOL>        outputLogs.push({<EOL>            timestamp: inputLog.timestamp,<EOL>            ISOString: new Date(inputLog.timestamp).toISOString(),<EOL>","gt":"type,"}
{"input":"<s> /**<EOL> * @license<EOL> * Copyright 2017 Google Inc. All Rights Reserved.<EOL> * Licensed under the Apache License, Version 2.0 (the \"License\");<EOL> * you may not use this file except in compliance with the License.<EOL> * You may obtain a copy of the License at<EOL> *<EOL> * http://www.apache.org/licenses/LICENSE-2.0<EOL> *<EOL> * Unless required by applicable law or agreed to in writing, software<EOL> * distributed under the License is distributed on an \"AS IS\" BASIS,<EOL> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.<EOL> * See the License for the specific language governing permissions and<EOL> * limitations under the License.<EOL> * =============================================================================<EOL> */<EOL>export function topK(values: Float32Array, k: number): {<EOL>    values: Float32Array;<EOL>    indices: Int32Array;<EOL>} {<EOL>    const valuesAndIndices: Array<{<EOL>        value: number;<EOL>        index: number;<EOL>    }> = [];<EOL>    for (let i = <NUM_LIT>; i < values.length; i++) {<EOL>        valuesAndIndices.push({ value: values[i], index:","gt":"i });"}
{"input":"<s> /**<EOL> * @license<EOL> * Copyright 2017 Google Inc. All Rights Reserved.<EOL> * Licensed under the Apache License, Version 2.0 (the \"License\");<EOL> * you may not use this file except in compliance with the License.<EOL> * You may obtain a copy of the License at<EOL> *<EOL> * http://www.apache.org/licenses/LICENSE-2.0<EOL> *<EOL> * Unless required by applicable law or agreed to in writing, software<EOL> * distributed under the License is distributed on an \"AS IS\" BASIS,<EOL> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.<EOL> * See the License for the specific language governing permissions and<EOL> * limitations under the License.<EOL> * =============================================================================<EOL> */<EOL>export function topK(values: Float32Array, k: number): {<EOL>    values: Float32Array;<EOL>    indices: Int32Array;<EOL>} {<EOL>    const valuesAndIndices: Array<{<EOL>        value: number;<EOL>        index: number;<EOL>    }> = [];<EOL>    for (let i = <NUM_LIT>; i < values.length; i++) {<EOL>        valuesAndIndices.push({ value: values[i], index: i });<EOL>    }<EOL>    valuesAndIndices.sort((a, b) => {<EOL>        return b.value - a.value;<EOL>    });<EOL>    const topkValues = new Float32Array(k);<EOL>    const topkIndices = new Int32Array(k);<EOL>    for (let i = <NUM_LIT>; i <","gt":"k; i++) {"}
{"input":"<s> export function watchDigests($rootScope: IRootScopeService) {<EOL>    $rootScope.$watch(function () {","gt":"trace.approximateDigests++; });"}
{"input":"<s> function logout(reducer: ActionReducer<AppState>): ActionReducer<AppState> {<EOL>    return function (state: AppState, action: any): AppState {<EOL>        if (","gt":"action.type === '<STR_LIT>') {"}
{"input":"<s> <EOL>export function UnderscoreCase(str: string): string {<EOL>    var STRING_UNDERSCORE_REGEXP_1 = (","gt":"/([a-z\\d])([A-Z]+)/g);"}
{"input":"<s> function excludeUndefined(fn: string) {<EOL>    if (!isShelfFunction) {<EOL>        console.","gt":"warn(`<STR_LIT>`);"}
{"input":"<s> export function configReducer(state: Readonly<VoyagerConfig> = DEFAULT_VOYAGER_CONFIG, action: Action): VoyagerConfig {<EOL>    switch (action.type) {<EOL>        case SET_CONFIG:<EOL>            const { config } = action.payload;<EOL>","gt":"const res = {"}
{"input":"<s> export function configReducer(state: Readonly<VoyagerConfig> = DEFAULT_VOYAGER_CONFIG, action: Action): VoyagerConfig {<EOL>    switch (action.type) {<EOL>        case SET_CONFIG:<EOL>            const { config } = action.payload;<EOL>            const res = {<EOL>                ...state,<EOL>                ...config,<EOL>            };<EOL>","gt":"return res;"}
{"input":"<s> function createCollections(db: Database) {<EOL>    let vertexCollectionNames = range(<NUM_LIT>).map(i => `<STR_LIT>`);<EOL>","gt":"let edgeCollectionNames = range(<NUM_LIT>).map(i => `<STR_LIT>`);"}
{"input":"<s> function getSerializeFnForType(type: any): Serializer {<EOL>    if (type === String) {<EOL>        return serializeString;<EOL>    }<EOL>    else if (","gt":"type === Number) {"}
{"input":"<s> function getSerializeFnForType(type: any): Serializer {<EOL>    if (type === String) {<EOL>        return serializeString;<EOL>    }<EOL>    else if (type === Number) {<EOL>        return serializeNumber;<EOL>    }<EOL>    else if (type === Boolean) {<EOL>        return serializeBoolean;<EOL>    }<EOL>","gt":"else {"}
{"input":"<s> <EOL>function getTypeAndKeyName(keyNameOrType: string | Function | ISerializable, keyName: string): {<EOL>    type: Function;<EOL>    key: string;<EOL>} {<EOL>    var type: Function = null;<EOL>    var key: string = null;<EOL>    if (typeof keyNameOrType === \"<STR_LIT>\") {<EOL>        key = <string>","gt":"keyNameOrType;"}
{"input":"<s> <EOL>function getTypeAndKeyName(keyNameOrType: string | Function | ISerializable, keyName: string): {<EOL>    type: Function;<EOL>    key: string;<EOL>} {<EOL>    var type: Function = null;<EOL>    var key: string = null;<EOL>    if (typeof keyNameOrType === \"<STR_LIT>\") {<EOL>        key = <string>keyNameOrType;<EOL>    }<EOL>    else if (keyNameOrType && typeof keyNameOrType === \"<STR_LIT>\" || typeof keyNameOrType === \"<STR_LIT>\") {<EOL>        type = <Function>keyNameOrType;<EOL>","gt":"key = keyName;"}
{"input":"<s> export function makeRelatedViewQueries(store: Store<State>, query: Query) {<EOL>    const { hasOpenPosition, hasStyleChannel, hasOpenFacet, isSpecAggregate } = getFeaturesForRelatedViewRules(query.spec);<EOL>    if (!isSpecAggregate) {<EOL>        store.dispatch(relatedViewResultRequest(summaries, query));<EOL>    }<EOL>    if (hasOpenPosition ||","gt":"hasStyleChannel) {"}
{"input":"<s> export function makeRelatedViewQueries(store: Store<State>, query: Query) {<EOL>    const { hasOpenPosition, hasStyleChannel, hasOpenFacet, isSpecAggregate } = getFeaturesForRelatedViewRules(query.spec);<EOL>    if (!isSpecAggregate) {<EOL>        store.dispatch(relatedViewResultRequest(summaries, query));<EOL>    }<EOL>    if (hasOpenPosition || hasStyleChannel) {<EOL>        store.dispatch(relatedViewResultRequest(addQuantitativeField, query));<EOL>    }<EOL>    if (hasOpenPosition || hasStyleChannel || hasOpenFacet) {<EOL>        store.dispatch(relatedViewResultRequest(addCategoricalField, query));<EOL>    }<EOL>","gt":"if (hasOpenPosition) {"}
{"input":"<s> export function autoAddFieldQuery(shelf: ShelfUnitSpec, fieldDef: ShelfFieldDef): Query {<EOL>    const spec = toSpecQuery(shelf);<EOL>    spec.encodings.push(toFieldQuery(fieldDef, '<STR_LIT>'));<EOL>","gt":"return {"}
{"input":"<s> function populateContainerWithColor(container: HTMLElement, r: number, g: number, b: number) {<EOL>    const originalColorString = '<STR_LIT>' + [r, g, b].join('<STR_LIT>') + '<STR_LIT>';<EOL>    container.","gt":"textContent = originalColorString;"}
{"input":"<s> export async function checkMethod({ method }: Request) {<EOL>    if ([\"<STR_LIT>\", \"<STR_LIT>\", \"<STR_LIT>\", \"<STR_LIT>\"].indexOf(method) === -<NUM_LIT>) {<EOL>","gt":"const detail = `<STR_LIT>` +"}
{"input":"<s> function getCurrent() {<EOL>    return [<EOL>        {<EOL>            id: <NUM_LIT>,<EOL>            name: \"<STR_LIT>\",<EOL>            deleted:","gt":"true,"}
{"input":"<s> function getCurrent() {<EOL>    return [<EOL>        {<EOL>            id: <NUM_LIT>,<EOL>            name: \"<STR_LIT>\",<EOL>            deleted: true,<EOL>            busy: true<EOL>        },<EOL>        {<EOL>            id: <NUM_LIT>,<EOL>            name: \"<STR_LIT>\",<EOL>","gt":"deleted: true,"}
{"input":"<s> /**<EOL> * Returns whether it's argument has no enumerable, own properties.<EOL> */<EOL>export function objectIsEmpty(obj: object) {<EOL>    for (const key in obj) {<EOL>        if (Object.prototype.hasOwnProperty.","gt":"call(obj, key)) {"}
{"input":"<s> function getCurrent() {<EOL>    return {<EOL>        <NUM_LIT>: {<EOL>            id: <NUM_LIT>,<EOL>            name:","gt":"\"<STR_LIT>\""}
{"input":"<s> function getCurrent() {<EOL>    return {<EOL>        <NUM_LIT>: {<EOL>            id: <NUM_LIT>,<EOL>            name: \"<STR_LIT>\"<EOL>        },<EOL>        <NUM_LIT>: {<EOL>            id: \"<STR_LIT>\",<EOL>            name:","gt":"\"<STR_LIT>\""}
{"input":"<s> /**<EOL> * Perform a pseudo-topological sort on the provided graph. Pseudo because it<EOL> * assumes that each node only has 0 or 1 incoming edges, as is the case with<EOL> * graphs for parent-child inheritance hierarchies (w/o multiple inheritance).<EOL> * Uses https://en.wikipedia.org/wiki/Topological_sorting#Kahn.27s_algorithm<EOL> *<EOL> * @param  {string[]} nodes A list of nodes, where each node is just a string.<EOL> *<EOL> * @param {string[]} roots The subset of nodes that have no incoming edges.<EOL> *<EOL> * @param  {object} edges The edges, expressed such that each key is a starting<EOL> * node A, and the value is a set of nodes (as an object literal like<EOL> * {nodeName: true}) for each of which there is an edge from A to that node.<EOL> *<EOL> * @return {string[]} The nodes, sorted.<EOL> */<EOL>export function pseudoTopSort(nodes: string[], edges: {<EOL>    [from: string]: {<EOL>        [to: string]: true;<EOL>    };<EOL>}, roots: string[]) {<EOL>    <EOL>    roots = roots.slice();<EOL>    nodes = nodes.slice();<EOL>    edges = { ...edges };<EOL>    Object.keys(edges).forEach(key => { edges[key] = { ...","gt":"edges[key] }; });"}
{"input":"<s> /**<EOL> * Perform a pseudo-topological sort on the provided graph. Pseudo because it<EOL> * assumes that each node only has 0 or 1 incoming edges, as is the case with<EOL> * graphs for parent-child inheritance hierarchies (w/o multiple inheritance).<EOL> * Uses https://en.wikipedia.org/wiki/Topological_sorting#Kahn.27s_algorithm<EOL> *<EOL> * @param  {string[]} nodes A list of nodes, where each node is just a string.<EOL> *<EOL> * @param {string[]} roots The subset of nodes that have no incoming edges.<EOL> *<EOL> * @param  {object} edges The edges, expressed such that each key is a starting<EOL> * node A, and the value is a set of nodes (as an object literal like<EOL> * {nodeName: true}) for each of which there is an edge from A to that node.<EOL> *<EOL> * @return {string[]} The nodes, sorted.<EOL> */<EOL>export function pseudoTopSort(nodes: string[], edges: {<EOL>    [from: string]: {<EOL>        [to: string]: true;<EOL>    };<EOL>}, roots: string[]) {<EOL>    <EOL>    roots = roots.slice();<EOL>    nodes = nodes.slice();<EOL>    edges = { ...edges };<EOL>    Object.keys(edges).forEach(key => { edges[key] = { ...edges[key] }; });<EOL>    <EOL>    const sortResult: string[] = [];<EOL>    <EOL>    while (","gt":"roots.length) {"}
{"input":"<s> function buildFakePlatform(flush) {<EOL>    platform = buildPlatform(flush);<EOL>    platform.","gt":"flushSync = function () {"}
{"input":"<s> export function match(loc1: SourceLocation, loc2: SourceLocation) {<EOL>","gt":"return loc1.scriptUrl === loc2.scriptUrl"}
{"input":"<s> export function shelfSpecFieldAutoAddReducer(shelfSpec: Readonly<ShelfUnitSpec>, action: SpecFieldAutoAdd, schema: Schema): ShelfUnitSpec {<EOL>    const { fieldDef } = action.payload;<EOL>    if (shelfSpec.anyEncodings.length > <NUM_LIT> || isWildcard(fieldDef.field)) {<EOL>        <EOL>        return {<EOL>            ...","gt":"shelfSpec,"}
{"input":"<s> export function shelfSpecFieldAutoAddReducer(shelfSpec: Readonly<ShelfUnitSpec>, action: SpecFieldAutoAdd, schema: Schema): ShelfUnitSpec {<EOL>    const { fieldDef } = action.payload;<EOL>    if (shelfSpec.anyEncodings.length > <NUM_LIT> || isWildcard(fieldDef.field)) {<EOL>        <EOL>        return {<EOL>            ...shelfSpec,<EOL>            anyEncodings: [<EOL>                ...shelfSpec.anyEncodings,<EOL>                {<EOL>                    channel: SHORT_WILDCARD,<EOL>                    ...fieldDef<EOL>                }<EOL>            ]<EOL>        };<EOL>    }<EOL>    else {<EOL>        <EOL>        const query = autoAddFieldQuery(shelfSpec, fieldDef);<EOL>        const rec = recommend(query, schema);<EOL>        const topSpecQuery =","gt":"getTopSpecQueryItem(rec.result).specQuery;"}
{"input":"<s> function listenToRecordStoreAddMessage(recordStoreAddMessageHandler: (message: RecordStoreAddMessage) => void) {<EOL>    window.","gt":"addEventListener(RECORD_STORE_ADD, (event: CustomEvent) => {"}
{"input":"<s> function patchCallbacks(target: any, targetName: string, method: string, callbacks: string[]) {<EOL>    const symbol = Zone.__symbol__(method);<EOL>    if (target[symbol]) {<EOL>        return;<EOL>    }<EOL>    const nativeDelegate = target[symbol] = target[method];<EOL>    target[","gt":"method] = function (name: any, opts: any, options?: any) {"}
{"input":"<s> function patchCallbacks(target: any, targetName: string, method: string, callbacks: string[]) {<EOL>    const symbol = Zone.__symbol__(method);<EOL>    if (target[symbol]) {<EOL>        return;<EOL>    }<EOL>    const nativeDelegate = target[symbol] = target[method];<EOL>    target[method] = function (name: any, opts: any, options?: any) {<EOL>        if (opts && opts.prototype) {<EOL>            callbacks.forEach(function (callback) {<EOL>                const source = `<STR_LIT>` +","gt":"callback;"}
{"input":"<s> function patchCallbacks(target: any, targetName: string, method: string, callbacks: string[]) {<EOL>    const symbol = Zone.__symbol__(method);<EOL>    if (target[symbol]) {<EOL>        return;<EOL>    }<EOL>    const nativeDelegate = target[symbol] = target[method];<EOL>    target[method] = function (name: any, opts: any, options?: any) {<EOL>        if (opts && opts.prototype) {<EOL>            callbacks.forEach(function (callback) {<EOL>                const source = `<STR_LIT>` + callback;<EOL>                const prototype = opts.prototype;<EOL>                if (prototype.hasOwnProperty(callback)) {<EOL>                    const descriptor = ObjectGetOwnPropertyDescriptor(prototype,","gt":"callback);"}
{"input":"<s> function patchCallbacks(target: any, targetName: string, method: string, callbacks: string[]) {<EOL>    const symbol = Zone.__symbol__(method);<EOL>    if (target[symbol]) {<EOL>        return;<EOL>    }<EOL>    const nativeDelegate = target[symbol] = target[method];<EOL>    target[method] = function (name: any, opts: any, options?: any) {<EOL>        if (opts && opts.prototype) {<EOL>            callbacks.forEach(function (callback) {<EOL>                const source = `<STR_LIT>` + callback;<EOL>                const prototype = opts.prototype;<EOL>                if (prototype.hasOwnProperty(callback)) {<EOL>                    const descriptor = ObjectGetOwnPropertyDescriptor(prototype, callback);<EOL>                    if (descriptor && descriptor.value) {<EOL>                        descriptor.value = wrapWithCurrentZone(descriptor.value, source);<EOL>                        _redefineProperty(","gt":"opts.prototype, callback, descriptor);"}
{"input":"<s> function patchCallbacks(target: any, targetName: string, method: string, callbacks: string[]) {<EOL>    const symbol = Zone.__symbol__(method);<EOL>    if (target[symbol]) {<EOL>        return;<EOL>    }<EOL>    const nativeDelegate = target[symbol] = target[method];<EOL>    target[method] = function (name: any, opts: any, options?: any) {<EOL>        if (opts && opts.prototype) {<EOL>            callbacks.forEach(function (callback) {<EOL>                const source = `<STR_LIT>` + callback;<EOL>                const prototype = opts.prototype;<EOL>                if (prototype.hasOwnProperty(callback)) {<EOL>                    const descriptor = ObjectGetOwnPropertyDescriptor(prototype, callback);<EOL>                    if (descriptor && descriptor.value) {<EOL>                        descriptor.value = wrapWithCurrentZone(descriptor.value, source);<EOL>                        _redefineProperty(opts.prototype, callback, descriptor);<EOL>                    }<EOL>                    else if (prototype[callback]) {<EOL>                        prototype[callback] = wrapWithCurrentZone(prototype[callback], source);<EOL>                    }<EOL>                }<EOL>                else if (prototype[callback]) {<EOL>","gt":"prototype[callback] = wrapWithCurrentZone(prototype[callback], source);"}
{"input":"<s> export async function withCustomDB(store: IStore, customMap: IModelMap, cb: (db: DB) => Promise<void>) {<EOL>    while (!isEmpty(dbsToClose)) {<EOL>        dbsToClose.shift().close();<EOL>    }<EOL>    const db = new DB(customMap);<EOL>","gt":"try {"}
{"input":"<s> export async function withCustomDB(store: IStore, customMap: IModelMap, cb: (db: DB) => Promise<void>) {<EOL>    while (!isEmpty(dbsToClose)) {<EOL>        dbsToClose.shift().close();<EOL>    }<EOL>    const db = new DB(customMap);<EOL>    try {<EOL>        db.load(store, \"<STR_LIT>\");<EOL>        const q = db.getQuerier();<EOL>        fixSchema(q, checkSchema(q, customMap));<EOL>        await cb(","gt":"db);"}
{"input":"<s> function setupWindow(): void {<EOL>","gt":"setupNonElementTarget(window, '<STR_LIT>');"}
{"input":"<s> export async function warmupAndBenchmarkGPU(benchmark: () => dl.Tensor): Promise<number> {<EOL>    <EOL>    const","gt":"out = benchmark();"}
{"input":"<s> export function isWildcardChannelId(shelfId: ShelfId): shelfId is ShelfWildcardChannelId {<EOL>    return isWildcard(shelfId.","gt":"channel);"}
{"input":"<s> export function html5Compat(html5mode) {<EOL>    return (angular.isObject(html5mode) && html5mode.","gt":"hasOwnProperty(\"<STR_LIT>\") ? html5mode.enabled : html5mode);"}
{"input":"<s> function trackGeneralCases() {<EOL>    const trackedApis = ['<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>'];<EOL>    <EOL>    trackedApis.map((","gt":"api) => {"}
{"input":"<s> export default function (devtools: typeof chrome.devtools, renderSidebar: (container: Element, props: ISidebarRootProps) => void): DevtoolHelpers {<EOL>    const sidebarController = new SidebarController(devtools.panels, renderSidebar);<EOL>    const updateSelection = makeUpdateSelection(devtools.inspectedWindow);<EOL>    const helpers: DevtoolHelpers = {<EOL>        backgroundMessageHandler:","gt":"makeBackgroundMessageHandler(sidebarController),"}
{"input":"<s> export default function (devtools: typeof chrome.devtools, renderSidebar: (container: Element, props: ISidebarRootProps) => void): DevtoolHelpers {<EOL>    const sidebarController = new SidebarController(devtools.panels, renderSidebar);<EOL>    const updateSelection = makeUpdateSelection(devtools.inspectedWindow);<EOL>    const helpers: DevtoolHelpers = {<EOL>        backgroundMessageHandler: makeBackgroundMessageHandler(sidebarController),<EOL>        selectionChangedHandler: () => updateSelection(),<EOL>        sidebarInitHandler: sidebarController.init,<EOL>    };<EOL>    if (isTestEnv()) {<EOL>        Object.","gt":"assign(helpers, { sidebarController });"}
{"input":"<s> /**<EOL> * Creates a bufferset<EOL> * @param numVtx Number of vertices<EOL> * @param numId Number of indices<EOL> * @param b Types of buffers to create (bitflags)<EOL> */<EOL>export function create(numVtx: number, numId: number, b?: number): BufferSet {<EOL>    b = (typeof b === '<STR_LIT>') ? b & ALL : ALL;<EOL>    return {<EOL>        position: (b & POSITION) ? new Float32Array(numVtx * <NUM_LIT>) : undefined,<EOL>","gt":"normal: (b & NORMAL) ? new Float32Array(numVtx * <NUM_LIT>) : undefined,"}
{"input":"<s> /**<EOL> * Creates a bufferset<EOL> * @param numVtx Number of vertices<EOL> * @param numId Number of indices<EOL> * @param b Types of buffers to create (bitflags)<EOL> */<EOL>export function create(numVtx: number, numId: number, b?: number): BufferSet {<EOL>    b = (typeof b === '<STR_LIT>') ? b & ALL : ALL;<EOL>    return {<EOL>        position: (b & POSITION) ? new Float32Array(numVtx * <NUM_LIT>) : undefined,<EOL>        normal: (b & NORMAL) ? new Float32Array(numVtx * <NUM_LIT>) : undefined,<EOL>        color: (b & COLOR) ? new Float32Array(numVtx * <NUM_LIT>) : undefined,<EOL>        uv: (b & UV) ? new Float32Array(numVtx * <NUM_LIT>) : undefined,<EOL>        index: new Uint16Array(numId),<EOL>        vertexCount:","gt":"<NUM_LIT>,"}
{"input":"<s> function flattenUnsubscriptionErrors(errors: any[]) {<EOL>    return errors.reduce((","gt":"errs, err) => errs.concat((err instanceof UnsubscriptionError) ? err.errors : err), []);"}
{"input":"<s> export function convertToTimestamp(dateTime: DateTime): number {<EOL>    const date = new Date(dateTime.","gt":"year, Number(dateTime.month) - <NUM_LIT>,"}
{"input":"<s> export function isTraining() {<EOL>    statusElement.innerText =","gt":"'<STR_LIT>';"}
{"input":"<s> export function filterIndexOf(filters: Array<RangeFilter | OneOfFilter>, field: string) {<EOL>    for (let i = <NUM_LIT>; i < filters.length; i++) {<EOL>        const filter = filters[i];<EOL>        if (","gt":"filter.field === field) {"}
{"input":"<s> export function setSelections(selections: Selection[]): void {<EOL>    if (!window.activeTextEditor) {<EOL>        throw new","gt":"Error('<STR_LIT>');"}
{"input":"<s> export function filterHasField(filters: Array<RangeFilter | OneOfFilter>, field: string) {<EOL>    return","gt":"filterIndexOf(filters, field) >= <NUM_LIT>;"}
{"input":"<s> function disableConditioning() {<EOL>    conditioned = false;<EOL>    conditioningOffElem.","gt":"checked = true;"}
{"input":"<s> export default function doesEventMeanBackground(e: MouseEvent<any>) {<EOL>    if (!e) {<EOL>        return","gt":"false;"}
{"input":"<s> function getStacktraceWithUncaughtError(): Error {<EOL>    return","gt":"new Error(ERROR_TAG);"}
{"input":"<s> <EOL>/**<EOL> * Returns an Observable that emits all items emitted by the source Observable that are distinct by comparison from the previous item.<EOL> *<EOL> * If a comparator function is provided, then it will be called for each item to test for whether or not that value should be emitted.<EOL> *<EOL> * If a comparator function is not provided, an equality check is used by default.<EOL> *<EOL> * @example <caption>A simple example with numbers</caption><EOL> * Observable.of(1, 1, 2, 2, 2, 1, 1, 2, 3, 3, 4)<EOL> *   .distinctUntilChanged()<EOL> *   .subscribe(x => console.log(x)); // 1, 2, 1, 2, 3, 4<EOL> *<EOL> * @example <caption>An example using a compare function</caption><EOL> * interface Person {<EOL> *    age: number,<EOL> *    name: string<EOL> * }<EOL> *<EOL> * Observable.of<Person>(<EOL> *     { age: 4, name: 'Foo'},<EOL> *     { age: 7, name: 'Bar'},<EOL> *     { age: 5, name: 'Foo'})<EOL> *     { age: 6, name: 'Foo'})<EOL> *     .distinctUntilChanged((p: Person, q: Person) => p.name === q.name)<EOL> *     .subscribe(x => console.log(x));<EOL> *<EOL> * // displays:<EOL> * // { age: 4, name: 'Foo' }<EOL> * // { age: 7, name: 'Bar' }<EOL> * // { age: 5, name: 'Foo' }<EOL> *<EOL> * @see {@link distinct}<EOL> * @see {@link distinctUntilKeyChanged}<EOL> *<EOL> * @param {function} [compare] Optional comparison function called to test if an item is distinct from the previous item in the source.<EOL> * @return {Observable} An Observable that emits items from the source Observable with distinct values.<EOL> * @method distinctUntilChanged<EOL> * @owner Observable<EOL> */<EOL>export function distinctUntilChanged<T, K>(this: Observable<T>, compare?: (x: K, y: K) => boolean, keySelector?: (x: T) => K): Observable<T> {<EOL>    return this.lift(new DistinctUntilChangedOperator<T, K>(compare,","gt":"keySelector));"}
{"input":"<s> function decodeParam(params: {<EOL>    [key: string]: string;<EOL>}, name: string, value?: string) {<EOL>","gt":"params[decodeURIComponent(name)] = decodeURIComponent(value || '<STR_LIT>');"}
{"input":"<s> export function customValidatorFactory(type: Function): IValidationProvider {<EOL>    return {<EOL>","gt":"provide: NG_VALIDATORS,"}
{"input":"<s> export function flattenNameArrayMap(nameArrayMap: Tensor | NamedTensorMap, keys?: string[]): Tensor[] {<EOL>    const xs: Tensor[] = [];<EOL>    if (nameArrayMap instanceof Tensor) {<EOL>        xs.push(nameArrayMap);<EOL>    }<EOL>    else {<EOL>        const xMap = nameArrayMap as {<EOL>            [xName: string]: Tensor;<EOL>        };<EOL>        for (let i = <NUM_LIT>; i < keys.length; i++) {<EOL>            xs.","gt":"push(xMap[keys[i]]);"}
{"input":"<s> export function isTypedArray(a: TypedArray | number | boolean | RegularArray<number> | RegularArray<boolean>): boolean {<EOL>    return a instanceof Float32Array ||","gt":"a instanceof Int32Array ||"}
{"input":"<s> /**<EOL> * Create a Heightfield using the given options.<EOL> * Use either an image OR xCount, yCount and a heights array.<EOL> */<EOL>export function create(info: Options): Heightfield {<EOL>    const hf: Heightfield = {<EOL>        cellSize: (info.cellSize && info.cellSize > <NUM_LIT>) ? info.cellSize : <NUM_LIT>,<EOL>        minHeight: (typeof info.minHeight === '<STR_LIT>') ? info.minHeight : <NUM_LIT>,<EOL>        maxHeight: (typeof info.maxHeight === '<STR_LIT>') ? info.maxHeight : <NUM_LIT>,<EOL>        xCount:","gt":"<NUM_LIT>,"}
{"input":"<s> /**<EOL> * Create a Heightfield using the given options.<EOL> * Use either an image OR xCount, yCount and a heights array.<EOL> */<EOL>export function create(info: Options): Heightfield {<EOL>    const hf: Heightfield = {<EOL>        cellSize: (info.cellSize && info.cellSize > <NUM_LIT>) ? info.cellSize : <NUM_LIT>,<EOL>        minHeight: (typeof info.minHeight === '<STR_LIT>') ? info.minHeight : <NUM_LIT>,<EOL>        maxHeight: (typeof info.maxHeight === '<STR_LIT>') ? info.maxHeight : <NUM_LIT>,<EOL>        xCount: <NUM_LIT>,<EOL>        yCount: <NUM_LIT>,<EOL>        xSize: <NUM_LIT>,<EOL>        ySize: <NUM_LIT>,<EOL>","gt":"heights: new Float32Array(<NUM_LIT>),"}
{"input":"<s> /**<EOL> * Create a Heightfield using the given options.<EOL> * Use either an image OR xCount, yCount and a heights array.<EOL> */<EOL>export function create(info: Options): Heightfield {<EOL>    const hf: Heightfield = {<EOL>        cellSize: (info.cellSize && info.cellSize > <NUM_LIT>) ? info.cellSize : <NUM_LIT>,<EOL>        minHeight: (typeof info.minHeight === '<STR_LIT>') ? info.minHeight : <NUM_LIT>,<EOL>        maxHeight: (typeof info.maxHeight === '<STR_LIT>') ? info.maxHeight : <NUM_LIT>,<EOL>        xCount: <NUM_LIT>,<EOL>        yCount: <NUM_LIT>,<EOL>        xSize: <NUM_LIT>,<EOL>        ySize: <NUM_LIT>,<EOL>        heights: new Float32Array(<NUM_LIT>),<EOL>        faceNormals: new Float32Array(<NUM_LIT>),<EOL>        vtxNormals: new Float32Array(<NUM_LIT>)<EOL>    };<EOL>    if (info.image) {<EOL>        genFromImg(info.image, hf);<EOL>    }<EOL>    else {<EOL>        hf.xCount = info.xCount && info.xCount > <NUM_LIT> ? Math.floor(info.xCount) : <NUM_LIT>;<EOL>        hf.yCount = info.yCount && info.yCount > <NUM_LIT> ? Math.floor(info.yCount) : <NUM_LIT>;<EOL>        hf.xSize = hf.xCount * hf.cellSize;<EOL>        hf.ySize = info.yCount! * hf.cellSize;<EOL>","gt":"hf.heights = info.heights || new Float32Array((hf.xCount + <NUM_LIT>) * (hf.yCount + <NUM_LIT>));"}
{"input":"<s> function isNonFacetUnitSpecWithPrimitiveMark(spec: GenericUnitSpec<Encoding<Field>, AnyMark>): spec is GenericUnitSpec<Encoding<Field>, Mark> {<EOL>","gt":"return isPrimitiveMark(spec.mark);"}
{"input":"<s> export default function quizReducer(state: QuizState = defaultQuizState, action: Action): QuizState {<EOL>    switch (action.type) {<EOL>        case '<STR_LIT>':<EOL>            return {<EOL>                ...state,<EOL>","gt":"rememberSkipped: action.payload,"}
{"input":"<s> export default function quizReducer(state: QuizState = defaultQuizState, action: Action): QuizState {<EOL>    switch (action.type) {<EOL>        case '<STR_LIT>':<EOL>            return {<EOL>                ...state,<EOL>                rememberSkipped: action.payload,<EOL>            };<EOL>        case","gt":"'<STR_LIT>':"}
{"input":"<s> export default function quizReducer(state: QuizState = defaultQuizState, action: Action): QuizState {<EOL>    switch (action.type) {<EOL>        case '<STR_LIT>':<EOL>            return {<EOL>                ...state,<EOL>                rememberSkipped: action.payload,<EOL>            };<EOL>        case '<STR_LIT>':<EOL>            return updateReaction(state, action.path, { answeredCorrectly: true });<EOL>        case '<STR_LIT>':<EOL>            const currentReaction = action.path<EOL>                ? state.quizReactions[action.path] || defaultReaction<EOL>                :","gt":"defaultReaction;"}
{"input":"<s> export default function quizReducer(state: QuizState = defaultQuizState, action: Action): QuizState {<EOL>    switch (action.type) {<EOL>        case '<STR_LIT>':<EOL>            return {<EOL>                ...state,<EOL>                rememberSkipped: action.payload,<EOL>            };<EOL>        case '<STR_LIT>':<EOL>            return updateReaction(state, action.path, { answeredCorrectly: true });<EOL>        case '<STR_LIT>':<EOL>            const currentReaction = action.path<EOL>                ? state.quizReactions[action.path] || defaultReaction<EOL>                : defaultReaction;<EOL>            return updateReaction(state, action.path, {<EOL>                answerIndeces: (currentReaction.answerIndeces || [])<EOL>                    .concat(action.payload),<EOL>            });<EOL>","gt":"case '<STR_LIT>':"}
{"input":"<s> export function enableExperimentalFragmentVariables() {<EOL>","gt":"experimentalFragmentVariables = true;"}
{"input":"<s> /**<EOL> * Groups pairs of consecutive emissions together and emits them as an array of<EOL> * two values.<EOL> *<EOL> * <span class=\"informal\">Puts the current value and previous value together as<EOL> * an array, and emits that.</span><EOL> *<EOL> * <img src=\"./img/pairwise.png\" width=\"100%\"><EOL> *<EOL> * The Nth emission from the source Observable will cause the output Observable<EOL> * to emit an array [(N-1)th, Nth] of the previous and the current value, as a<EOL> * pair. For this reason, `pairwise` emits on the second and subsequent<EOL> * emissions from the source Observable, but not on the first emission, because<EOL> * there is no previous value in that case.<EOL> *<EOL> * @example <caption>On every click (starting from the second), emit the relative distance to the previous click</caption><EOL> * var clicks = Rx.Observable.fromEvent(document, 'click');<EOL> * var pairs = clicks.pairwise();<EOL> * var distance = pairs.map(pair => {<EOL> *   var x0 = pair[0].clientX;<EOL> *   var y0 = pair[0].clientY;<EOL> *   var x1 = pair[1].clientX;<EOL> *   var y1 = pair[1].clientY;<EOL> *   return Math.sqrt(Math.pow(x0 - x1, 2) + Math.pow(y0 - y1, 2));<EOL> * });<EOL> * distance.subscribe(x => console.log(x));<EOL> *<EOL> * @see {@link buffer}<EOL> * @see {@link bufferCount}<EOL> *<EOL> * @return {Observable<Array<T>>} An Observable of pairs (as arrays) of<EOL> * consecutive values from the source Observable.<EOL> * @method pairwise<EOL> * @owner Observable<EOL> */<EOL>export function pairwise<T>(this: Observable<T>): Observable<[<EOL>    T,<EOL>    T<EOL>]> {<EOL>    return this.lift(new","gt":"PairwiseOperator());"}
{"input":"<s> export function getAssign(root: any) {<EOL>    return root.Object.","gt":"assign || assignImpl;"}
{"input":"<s> <EOL><EOL>function seed(seed: number) {<EOL>    if (seed > <NUM_LIT> && seed < <NUM_LIT>) {<EOL>        <EOL>        seed *= <NUM_LIT>;<EOL>    }<EOL>    seed = Math.floor(seed);<EOL>    if (seed <","gt":"<NUM_LIT>) {"}
{"input":"<s> <EOL><EOL>function seed(seed: number) {<EOL>    if (seed > <NUM_LIT> && seed < <NUM_LIT>) {<EOL>        <EOL>        seed *= <NUM_LIT>;<EOL>    }<EOL>    seed = Math.floor(seed);<EOL>    if (seed < <NUM_LIT>) {<EOL>        seed |= seed << <NUM_LIT>;<EOL>    }<EOL>    for (let i = <NUM_LIT>; i < <NUM_LIT>; i++) {<EOL>        let v: number;<EOL>        if (","gt":"i & <NUM_LIT>) {"}
{"input":"<s> <EOL><EOL>function seed(seed: number) {<EOL>    if (seed > <NUM_LIT> && seed < <NUM_LIT>) {<EOL>        <EOL>        seed *= <NUM_LIT>;<EOL>    }<EOL>    seed = Math.floor(seed);<EOL>    if (seed < <NUM_LIT>) {<EOL>        seed |= seed << <NUM_LIT>;<EOL>    }<EOL>    for (let i = <NUM_LIT>; i < <NUM_LIT>; i++) {<EOL>        let v: number;<EOL>        if (i & <NUM_LIT>) {<EOL>            v = p[i] ^ (seed & <NUM_LIT>);<EOL>        }<EOL>        else {<EOL>            v =","gt":"p[i] ^ ((seed >> <NUM_LIT>) & <NUM_LIT>);"}
{"input":"<s> <EOL><EOL>export default function mutex(fn) {<EOL>    let running = false;<EOL>    return async function (...args: any[]) {<EOL>        if (running) {<EOL>","gt":"return;"}
{"input":"<s> <EOL><EOL>export default function mutex(fn) {<EOL>    let running = false;<EOL>    return async function (...args: any[]) {<EOL>        if (running) {<EOL>            return;<EOL>        }<EOL>        running = true;<EOL>        const onUncaught =","gt":"function (e) {"}
{"input":"<s> <EOL><EOL>export default function mutex(fn) {<EOL>    let running = false;<EOL>    return async function (...args: any[]) {<EOL>        if (running) {<EOL>            return;<EOL>        }<EOL>        running = true;<EOL>        const onUncaught = function (e) {<EOL>            console.error(\"<STR_LIT>\", e.stack);<EOL>            running = false;<EOL>        };<EOL>        process.on(\"<STR_LIT>\", onUncaught);<EOL>","gt":"try {"}
{"input":"<s> /**<EOL> * Reducer used to set the _entire_ application state tree.<EOL> *<EOL> * @export<EOL> * @param {Readonly<State>} state<EOL> * @param {Action} action<EOL> * @returns {Readonly<State>}<EOL> */<EOL>export function stateReducer(state: Readonly<State> = DEFAULT_STATE, action: Action): Readonly<State> {<EOL>    switch (action.type) {<EOL>        case","gt":"SET_APPLICATION_STATE:"}
{"input":"<s> function openDashboardWindow(sessionid) {<EOL>    sessionid = sessionid || '<STR_LIT>';<EOL>    var cfg = config.getConfig(userDataPath);<EOL>    var dashboardTarget = '<STR_LIT>' + cfg.port + '<STR_LIT>' +","gt":"sessionid;"}
{"input":"<s> function openDashboardWindow(sessionid) {<EOL>    sessionid = sessionid || '<STR_LIT>';<EOL>    var cfg = config.getConfig(userDataPath);<EOL>    var dashboardTarget = '<STR_LIT>' + cfg.port + '<STR_LIT>' + sessionid;<EOL>    var existing = dashboardWindows[sessionid];<EOL>    if (existing) {<EOL>        console.log(\"<STR_LIT>\" +","gt":"dashboardTarget);"}
{"input":"<s> function openDashboardWindow(sessionid) {<EOL>    sessionid = sessionid || '<STR_LIT>';<EOL>    var cfg = config.getConfig(userDataPath);<EOL>    var dashboardTarget = '<STR_LIT>' + cfg.port + '<STR_LIT>' + sessionid;<EOL>    var existing = dashboardWindows[sessionid];<EOL>    if (existing) {<EOL>        console.log(\"<STR_LIT>\" + dashboardTarget);<EOL>        existing.show();<EOL>        existing.loadUrl(dashboardTarget);<EOL>        return;<EOL>    }<EOL>    var dashboardwdw = new BrowserWindow({<EOL>        x: mainWindowState.x,<EOL>        y: mainWindowState.y,<EOL>        width: mainWindowState.","gt":"width,"}
{"input":"<s> function openDashboardWindow(sessionid) {<EOL>    sessionid = sessionid || '<STR_LIT>';<EOL>    var cfg = config.getConfig(userDataPath);<EOL>    var dashboardTarget = '<STR_LIT>' + cfg.port + '<STR_LIT>' + sessionid;<EOL>    var existing = dashboardWindows[sessionid];<EOL>    if (existing) {<EOL>        console.log(\"<STR_LIT>\" + dashboardTarget);<EOL>        existing.show();<EOL>        existing.loadUrl(dashboardTarget);<EOL>        return;<EOL>    }<EOL>    var dashboardwdw = new BrowserWindow({<EOL>        x: mainWindowState.x,<EOL>        y: mainWindowState.y,<EOL>        width: mainWindowState.width,<EOL>        height: mainWindowState.height,<EOL>        \"<STR_LIT>\": false<EOL>    });<EOL>    <EOL>    console.log(\"<STR_LIT>\" + dashboardTarget);<EOL>    <EOL>    dashboardwdw.loadUrl('<STR_LIT>' + __dirname + '<STR_LIT>');<EOL>    setTimeout(function () {<EOL>        dashboardwdw.webContents.on('<STR_LIT>', function (event, errorCode, errorDescription, validateUrl) {<EOL>            console.log(\"<STR_LIT>\" + validateUrl + \"<STR_LIT>\" + errorCode + \"<STR_LIT>\" + errorDescription);<EOL>            dashboardwdw.","gt":"loadUrl('<STR_LIT>' + __dirname + '<STR_LIT>');"}
{"input":"<s> function getModel(xscale?: ScaleType, yscale?: ScaleType) {<EOL>    const model = parseUnitModel({<EOL>        \"<STR_LIT>\": \"<STR_LIT>\",<EOL>        \"<STR_LIT>\": {<EOL>","gt":"\"<STR_LIT>\": { \"<STR_LIT>\": \"<STR_LIT>\", \"<STR_LIT>\": \"<STR_LIT>\", \"<STR_LIT>\": { \"<STR_LIT>\": xscale || \"<STR_LIT>\" } },"}
{"input":"<s> function getModel(xscale?: ScaleType, yscale?: ScaleType) {<EOL>    const model = parseUnitModel({<EOL>        \"<STR_LIT>\": \"<STR_LIT>\",<EOL>        \"<STR_LIT>\": {<EOL>            \"<STR_LIT>\": { \"<STR_LIT>\": \"<STR_LIT>\", \"<STR_LIT>\": \"<STR_LIT>\", \"<STR_LIT>\": { \"<STR_LIT>\": xscale || \"<STR_LIT>\" } },<EOL>            \"<STR_LIT>\": { \"<STR_LIT>\": \"<STR_LIT>\", \"<STR_LIT>\": \"<STR_LIT>\",","gt":"\"<STR_LIT>\": { \"<STR_LIT>\": yscale || \"<STR_LIT>\" } },"}
{"input":"<s> function getModel(xscale?: ScaleType, yscale?: ScaleType) {<EOL>    const model = parseUnitModel({<EOL>        \"<STR_LIT>\": \"<STR_LIT>\",<EOL>        \"<STR_LIT>\": {<EOL>            \"<STR_LIT>\": { \"<STR_LIT>\": \"<STR_LIT>\", \"<STR_LIT>\": \"<STR_LIT>\", \"<STR_LIT>\": { \"<STR_LIT>\": xscale || \"<STR_LIT>\" } },<EOL>            \"<STR_LIT>\": { \"<STR_LIT>\": \"<STR_LIT>\", \"<STR_LIT>\": \"<STR_LIT>\", \"<STR_LIT>\": { \"<STR_LIT>\": yscale || \"<STR_LIT>\" } },<EOL>            \"<STR_LIT>\": { \"<STR_LIT>\": \"<STR_LIT>\", \"<STR_LIT>\": \"<STR_LIT>\" }<EOL>        }<EOL>    });<EOL>    model.parseScale();<EOL>    const selCmpts = selection.parseUnitSelection(model, {<EOL>        \"<STR_LIT>\": {<EOL>","gt":"\"<STR_LIT>\": \"<STR_LIT>\""}
{"input":"<s> function getModel(xscale?: ScaleType, yscale?: ScaleType) {<EOL>    const model = parseUnitModel({<EOL>        \"<STR_LIT>\": \"<STR_LIT>\",<EOL>        \"<STR_LIT>\": {<EOL>            \"<STR_LIT>\": { \"<STR_LIT>\": \"<STR_LIT>\", \"<STR_LIT>\": \"<STR_LIT>\", \"<STR_LIT>\": { \"<STR_LIT>\": xscale || \"<STR_LIT>\" } },<EOL>            \"<STR_LIT>\": { \"<STR_LIT>\": \"<STR_LIT>\", \"<STR_LIT>\": \"<STR_LIT>\", \"<STR_LIT>\": { \"<STR_LIT>\": yscale || \"<STR_LIT>\" } },<EOL>            \"<STR_LIT>\": { \"<STR_LIT>\": \"<STR_LIT>\", \"<STR_LIT>\": \"<STR_LIT>\" }<EOL>        }<EOL>    });<EOL>    model.parseScale();<EOL>    const selCmpts = selection.parseUnitSelection(model, {<EOL>        \"<STR_LIT>\": {<EOL>            \"<STR_LIT>\": \"<STR_LIT>\"<EOL>        },<EOL>        \"<STR_LIT>\": {<EOL>            \"<STR_LIT>\":","gt":"\"<STR_LIT>\""}
{"input":"<s> function getModel(xscale?: ScaleType, yscale?: ScaleType) {<EOL>    const model = parseUnitModel({<EOL>        \"<STR_LIT>\": \"<STR_LIT>\",<EOL>        \"<STR_LIT>\": {<EOL>            \"<STR_LIT>\": { \"<STR_LIT>\": \"<STR_LIT>\", \"<STR_LIT>\": \"<STR_LIT>\", \"<STR_LIT>\": { \"<STR_LIT>\": xscale || \"<STR_LIT>\" } },<EOL>            \"<STR_LIT>\": { \"<STR_LIT>\": \"<STR_LIT>\", \"<STR_LIT>\": \"<STR_LIT>\", \"<STR_LIT>\": { \"<STR_LIT>\": yscale || \"<STR_LIT>\" } },<EOL>            \"<STR_LIT>\": { \"<STR_LIT>\": \"<STR_LIT>\", \"<STR_LIT>\": \"<STR_LIT>\" }<EOL>        }<EOL>    });<EOL>    model.parseScale();<EOL>    const selCmpts = selection.parseUnitSelection(model, {<EOL>        \"<STR_LIT>\": {<EOL>            \"<STR_LIT>\": \"<STR_LIT>\"<EOL>        },<EOL>        \"<STR_LIT>\": {<EOL>            \"<STR_LIT>\": \"<STR_LIT>\"<EOL>        },<EOL>        \"<STR_LIT>\": {<EOL>            \"<STR_LIT>\": \"<STR_LIT>\",<EOL>            \"<STR_LIT>\":","gt":"false"}
{"input":"<s> export function patchEvent(global: any, api: _ZonePrivate) {<EOL>","gt":"patchEventPrototype(global, api);"}
{"input":"<s> export function ajaxGet(url: string, headers: Object = null) {<EOL>    return","gt":"new AjaxObservable<AjaxResponse>({ method: '<STR_LIT>', url, headers });"}
{"input":"<s> export function transformInterface(schema: GraphQLSchema, gqlInterface: GraphQLInterfaceType): Interface {<EOL>    debugLog(`<STR_LIT>`);<EOL>    const resolvedFields = resolveFields(schema, gqlInterface.getFields());<EOL>    const directives = getDirectives(schema, gqlInterface);<EOL>","gt":"return {"}
{"input":"<s> export function transformInterface(schema: GraphQLSchema, gqlInterface: GraphQLInterfaceType): Interface {<EOL>    debugLog(`<STR_LIT>`);<EOL>    const resolvedFields = resolveFields(schema, gqlInterface.getFields());<EOL>    const directives = getDirectives(schema, gqlInterface);<EOL>    return {<EOL>        name: gqlInterface.name,<EOL>        description: gqlInterface.description || '<STR_LIT>',<EOL>        fields: resolvedFields,<EOL>        hasFields: resolvedFields.length > <NUM_LIT>,<EOL>","gt":"directives,"}
{"input":"<s> export function nbAuthServiceFactory(config: any, tokenService: NbTokenService, injector: Injector) {<EOL>    const providers = config.providers || {};<EOL>    for (const key in providers) {<EOL>","gt":"if (providers.hasOwnProperty(key)) {"}
{"input":"<s> export function transformDirectives(schema: GraphQLSchema, directives: GraphQLDirective[]): Directive[] {<EOL>    return directives.map<Directive>((directive: GraphQLDirective): Directive => {<EOL>        const args = resolveArguments(schema, directive.args);<EOL>        const locations = directive.locations || [];<EOL>        return {<EOL>            name: directive.name,<EOL>            description:","gt":"directive.description || '<STR_LIT>',"}
{"input":"<s> export function transformDirectives(schema: GraphQLSchema, directives: GraphQLDirective[]): Directive[] {<EOL>    return directives.map<Directive>((directive: GraphQLDirective): Directive => {<EOL>        const args = resolveArguments(schema, directive.args);<EOL>        const locations = directive.locations || [];<EOL>        return {<EOL>            name: directive.name,<EOL>            description: directive.description || '<STR_LIT>',<EOL>            hasArguments: args.length > <NUM_LIT>,<EOL>            arguments: args,<EOL>","gt":"locations,"}
{"input":"<s> export function transformDirectives(schema: GraphQLSchema, directives: GraphQLDirective[]): Directive[] {<EOL>    return directives.map<Directive>((directive: GraphQLDirective): Directive => {<EOL>        const args = resolveArguments(schema, directive.args);<EOL>        const locations = directive.locations || [];<EOL>        return {<EOL>            name: directive.name,<EOL>            description: directive.description || '<STR_LIT>',<EOL>            hasArguments: args.length > <NUM_LIT>,<EOL>            arguments: args,<EOL>            locations,<EOL>            onFragmentSpread: locations.includes(DirectiveLocation.FRAGMENT_SPREAD),<EOL>            onInlineFragment: locations.includes(DirectiveLocation.INLINE_FRAGMENT),<EOL>","gt":"onQuery: locations.includes(DirectiveLocation.QUERY),"}
{"input":"<s> export function transformDirectives(schema: GraphQLSchema, directives: GraphQLDirective[]): Directive[] {<EOL>    return directives.map<Directive>((directive: GraphQLDirective): Directive => {<EOL>        const args = resolveArguments(schema, directive.args);<EOL>        const locations = directive.locations || [];<EOL>        return {<EOL>            name: directive.name,<EOL>            description: directive.description || '<STR_LIT>',<EOL>            hasArguments: args.length > <NUM_LIT>,<EOL>            arguments: args,<EOL>            locations,<EOL>            onFragmentSpread: locations.includes(DirectiveLocation.FRAGMENT_SPREAD),<EOL>            onInlineFragment: locations.includes(DirectiveLocation.INLINE_FRAGMENT),<EOL>            onQuery: locations.includes(DirectiveLocation.QUERY),<EOL>            onMutation: locations.includes(DirectiveLocation.MUTATION),<EOL>            onSubscription: locations.includes(DirectiveLocation.SUBSCRIPTION),<EOL>            onFragment: locations.includes(DirectiveLocation.FRAGMENT_SPREAD),<EOL>            onField:","gt":"locations.includes(DirectiveLocation.FIELD),"}
{"input":"<s> export function transformDirectives(schema: GraphQLSchema, directives: GraphQLDirective[]): Directive[] {<EOL>    return directives.map<Directive>((directive: GraphQLDirective): Directive => {<EOL>        const args = resolveArguments(schema, directive.args);<EOL>        const locations = directive.locations || [];<EOL>        return {<EOL>            name: directive.name,<EOL>            description: directive.description || '<STR_LIT>',<EOL>            hasArguments: args.length > <NUM_LIT>,<EOL>            arguments: args,<EOL>            locations,<EOL>            onFragmentSpread: locations.includes(DirectiveLocation.FRAGMENT_SPREAD),<EOL>            onInlineFragment: locations.includes(DirectiveLocation.INLINE_FRAGMENT),<EOL>            onQuery: locations.includes(DirectiveLocation.QUERY),<EOL>            onMutation: locations.includes(DirectiveLocation.MUTATION),<EOL>            onSubscription: locations.includes(DirectiveLocation.SUBSCRIPTION),<EOL>            onFragment: locations.includes(DirectiveLocation.FRAGMENT_SPREAD),<EOL>            onField: locations.includes(DirectiveLocation.FIELD),<EOL>            onSchema: locations.includes(DirectiveLocation.SCHEMA),<EOL>            onScalar: locations.includes(DirectiveLocation.SCALAR),<EOL>            onFieldDefinition: locations.includes(DirectiveLocation.FIELD_DEFINITION),<EOL>            onEnum: locations.includes(DirectiveLocation.ENUM),<EOL>            onEnumValue: locations.includes(DirectiveLocation.ENUM_VALUE),<EOL>            onObject: locations.","gt":"includes(DirectiveLocation.OBJECT),"}
{"input":"<s> <EOL>/**<EOL> * @param due<EOL> * @param withObservable<EOL> * @param scheduler<EOL> * @return {Observable<R>|WebSocketSubject<T>|Observable<T>}<EOL> * @method timeoutWith<EOL> * @owner Observable<EOL> */<EOL>export function timeoutWith<T, R>(this: Observable<T>, due: number | Date, withObservable: ObservableInput<R>, scheduler: IScheduler = async): Observable<T | R> {<EOL>    let absoluteTimeout = isDate(","gt":"due);"}
{"input":"<s> export function renderComponent(component: RenderComponentType<any>, props = {}, children = null) {<EOL>    let isReactComponent = (component[\"<STR_LIT>\"] instanceof React.Component ||<EOL>        (component[\"<STR_LIT>\"] && component[\"<STR_LIT>\"].isReactComponent) ||<EOL>        typeof component === '<STR_LIT>');<EOL>    if (","gt":"isReactComponent) {"}
{"input":"<s> function getFeaturesFromURL(): Features {<EOL>    const features: Features = {};<EOL>    if (typeof window === '<STR_LIT>') {<EOL>        return features;<EOL>    }<EOL>    const urlParams =","gt":"util.getQueryParams(window.location.search);"}
{"input":"<s> function getFeaturesFromURL(): Features {<EOL>    const features: Features = {};<EOL>    if (typeof window === '<STR_LIT>') {<EOL>        return features;<EOL>    }<EOL>    const urlParams = util.getQueryParams(window.location.search);<EOL>    if (DEEPLEARNJS_FLAGS_PREFIX in urlParams) {<EOL>        const","gt":"urlFlags: {"}
{"input":"<s> function getFeaturesFromURL(): Features {<EOL>    const features: Features = {};<EOL>    if (typeof window === '<STR_LIT>') {<EOL>        return features;<EOL>    }<EOL>    const urlParams = util.getQueryParams(window.location.search);<EOL>    if (DEEPLEARNJS_FLAGS_PREFIX in urlParams) {<EOL>        const urlFlags: {<EOL>            [key: string]: string;<EOL>        } = {};<EOL>        const keyValues = urlParams[DEEPLEARNJS_FLAGS_PREFIX].split('<STR_LIT>');<EOL>        keyValues.forEach(keyValue => {<EOL>            const [key,","gt":"value] = keyValue.split('<STR_LIT>') as ["}
{"input":"<s> function getFeaturesFromURL(): Features {<EOL>    const features: Features = {};<EOL>    if (typeof window === '<STR_LIT>') {<EOL>        return features;<EOL>    }<EOL>    const urlParams = util.getQueryParams(window.location.search);<EOL>    if (DEEPLEARNJS_FLAGS_PREFIX in urlParams) {<EOL>        const urlFlags: {<EOL>            [key: string]: string;<EOL>        } = {};<EOL>        const keyValues = urlParams[DEEPLEARNJS_FLAGS_PREFIX].split('<STR_LIT>');<EOL>        keyValues.forEach(keyValue => {<EOL>            const [key, value] = keyValue.split('<STR_LIT>') as [<EOL>                string,<EOL>                string<EOL>            ];<EOL>            urlFlags[","gt":"key] = value;"}
{"input":"<s> function getFeaturesFromURL(): Features {<EOL>    const features: Features = {};<EOL>    if (typeof window === '<STR_LIT>') {<EOL>        return features;<EOL>    }<EOL>    const urlParams = util.getQueryParams(window.location.search);<EOL>    if (DEEPLEARNJS_FLAGS_PREFIX in urlParams) {<EOL>        const urlFlags: {<EOL>            [key: string]: string;<EOL>        } = {};<EOL>        const keyValues = urlParams[DEEPLEARNJS_FLAGS_PREFIX].split('<STR_LIT>');<EOL>        keyValues.forEach(keyValue => {<EOL>            const [key, value] = keyValue.split('<STR_LIT>') as [<EOL>                string,<EOL>                string<EOL>            ];<EOL>            urlFlags[key] = value;<EOL>        });<EOL>        URL_PROPERTIES.forEach(urlProperty => {<EOL>            if (urlProperty.name in urlFlags) {<EOL>                console.log(`<STR_LIT>` +<EOL>","gt":"urlFlags[urlProperty.name]}`<STR_LIT>;"}
{"input":"<s> export function isFieldRangePredicate(predicate: any): predicate is FieldRangePredicate {<EOL>    if (predicate && predicate.field) {<EOL>        if (isArray(","gt":"predicate.range) && predicate.range.length === <NUM_LIT>) {"}
{"input":"<s> /**<EOL> * Check that the DB schema matches our expectations.<EOL> * If tables or columns are missing<EOL> */<EOL>export function checkSchema(q: Querier, modelMap: IModelMap): ICheckSchemaResult {<EOL>    const result: ICheckSchemaResult = {<EOL>        toCreate: [],<EOL>        toSync: [],<EOL>    };<EOL>    for (const table of Object.keys(modelMap)) {<EOL>","gt":"const model = modelMap[table];"}
{"input":"<s> /**<EOL> * Check that the DB schema matches our expectations.<EOL> * If tables or columns are missing<EOL> */<EOL>export function checkSchema(q: Querier, modelMap: IModelMap): ICheckSchemaResult {<EOL>    const result: ICheckSchemaResult = {<EOL>        toCreate: [],<EOL>        toSync: [],<EOL>    };<EOL>    for (const table of Object.keys(modelMap)) {<EOL>        const model = modelMap[table];<EOL>        if (table !== model.table) {<EOL>            throw new Error(`<STR_LIT>`);<EOL>        }<EOL>        const exists = hasDbTable(q, model.table);<EOL>        if (!exists) {<EOL>            result.toCreate.push({ model: model });<EOL>            continue;<EOL>        }<EOL>        const dbColumns = listDbColumns(q, model.","gt":"table);"}
{"input":"<s> /**<EOL> * Check that the DB schema matches our expectations.<EOL> * If tables or columns are missing<EOL> */<EOL>export function checkSchema(q: Querier, modelMap: IModelMap): ICheckSchemaResult {<EOL>    const result: ICheckSchemaResult = {<EOL>        toCreate: [],<EOL>        toSync: [],<EOL>    };<EOL>    for (const table of Object.keys(modelMap)) {<EOL>        const model = modelMap[table];<EOL>        if (table !== model.table) {<EOL>            throw new Error(`<STR_LIT>`);<EOL>        }<EOL>        const exists = hasDbTable(q, model.table);<EOL>        if (!exists) {<EOL>            result.toCreate.push({ model: model });<EOL>            continue;<EOL>        }<EOL>        const dbColumns = listDbColumns(q, model.table);<EOL>        const byName = indexBy(dbColumns, \"<STR_LIT>\");<EOL>        let hadIncorrectColumns = false;<EOL>        const { columns } = model;<EOL>        for (const column of Object.keys(columns)) {<EOL>            const columnType = columns[","gt":"column];"}
{"input":"<s> /**<EOL> * Check that the DB schema matches our expectations.<EOL> * If tables or columns are missing<EOL> */<EOL>export function checkSchema(q: Querier, modelMap: IModelMap): ICheckSchemaResult {<EOL>    const result: ICheckSchemaResult = {<EOL>        toCreate: [],<EOL>        toSync: [],<EOL>    };<EOL>    for (const table of Object.keys(modelMap)) {<EOL>        const model = modelMap[table];<EOL>        if (table !== model.table) {<EOL>            throw new Error(`<STR_LIT>`);<EOL>        }<EOL>        const exists = hasDbTable(q, model.table);<EOL>        if (!exists) {<EOL>            result.toCreate.push({ model: model });<EOL>            continue;<EOL>        }<EOL>        const dbColumns = listDbColumns(q, model.table);<EOL>        const byName = indexBy(dbColumns, \"<STR_LIT>\");<EOL>        let hadIncorrectColumns = false;<EOL>        const { columns } = model;<EOL>        for (const column of Object.keys(columns)) {<EOL>            const columnType = columns[column];<EOL>            const dbColumn = byName[column];<EOL>            if (!dbColumn) {<EOL>                hadIncorrectColumns = true;<EOL>                continue;<EOL>            }<EOL>            const dbType = dbColumn.","gt":"type.toLowerCase();"}
{"input":"<s> export function normalizeLogicalOperand<T>(op: LogicalOperand<T>, normalizer: (o: T) => T): LogicalOperand<T> {<EOL>    if (isLogicalNot(op)) {<EOL>        return { not: normalizeLogicalOperand(op.not, normalizer) };<EOL>    }<EOL>    else if (","gt":"isLogicalAnd(op)) {"}
{"input":"<s> export function normalizeLogicalOperand<T>(op: LogicalOperand<T>, normalizer: (o: T) => T): LogicalOperand<T> {<EOL>    if (isLogicalNot(op)) {<EOL>        return { not: normalizeLogicalOperand(op.not, normalizer) };<EOL>    }<EOL>    else if (isLogicalAnd(op)) {<EOL>        return { and: op.and.map(o => normalizeLogicalOperand(o, normalizer)) };<EOL>    }<EOL>    else if (isLogicalOr(op)) {<EOL>        return { or: op.or.map(o => normalizeLogicalOperand(o, normalizer)) };<EOL>    }<EOL>","gt":"else {"}
{"input":"<s> /**<EOL> * Create a `Dataset` from an array of elements.<EOL> */<EOL>export function datasetFromElements(items: DatasetElement[]): Dataset {<EOL>","gt":"return datasetFromStreamFn(async () => {"}
{"input":"<s> function handleScalar(compiledTemplate: Function, schemaContext: SchemaTemplateContext, documents: Document, extraConfig: ExtraConfig, fileExtension: string, prefixAndPath: string = '<STR_LIT>'): FileOutput[] {<EOL>    debugLog(`<STR_LIT>`);<EOL>    return schemaContext.scalars.map((scalar: Scalar) => ({<EOL>        filename: prefixAndPath + sanitizeFilename(scalar.name, '<STR_LIT>') + '<STR_LIT>' + (fileExtension ||","gt":"'<STR_LIT>'),"}
{"input":"<s> function isJQueryStyleEventEmitter(sourceObj: any): sourceObj is JQueryStyleEventEmitter {<EOL>    return !!sourceObj && typeof sourceObj.on === '<STR_LIT>' && typeof","gt":"sourceObj.off === '<STR_LIT>';"}
{"input":"<s> function handleFragment(compiledTemplate: Function, schemaContext: SchemaTemplateContext, documents: Document, extraConfig: ExtraConfig, fileExtension: string, prefixAndPath: string = '<STR_LIT>'): FileOutput[] {<EOL>    debugLog(`<STR_LIT>`);<EOL>    return documents.fragments.map((fragment: Fragment) => ({<EOL>        filename: prefixAndPath + sanitizeFilename(","gt":"fragment.name, '<STR_LIT>') + '<STR_LIT>' + (fileExtension || '<STR_LIT>'),"}
{"input":"<s> export function BoolMustNot(val: any) {<EOL>    return boolHelper(val,","gt":"\"<STR_LIT>\");"}
{"input":"<s> export default function getGameStatus(rs: IRootState, game: Game, cave?: ICaveSummary): IGameStatus {<EOL>    const { commons, session, tasks, downloads } = rs;<EOL>    const { credentials } = session;<EOL>    let downloadKeys = getByIds(commons.downloadKeys, commons.downloadKeyIdsByGameId[game.id]);<EOL>    if (!cave) {<EOL>        let caves = getByIds(commons.caves, commons.caveIdsByGameId[game.","gt":"id]);"}
{"input":"<s> export default function getGameStatus(rs: IRootState, game: Game, cave?: ICaveSummary): IGameStatus {<EOL>    const { commons, session, tasks, downloads } = rs;<EOL>    const { credentials } = session;<EOL>    let downloadKeys = getByIds(commons.downloadKeys, commons.downloadKeyIdsByGameId[game.id]);<EOL>    if (!cave) {<EOL>        let caves = getByIds(commons.caves, commons.caveIdsByGameId[game.id]);<EOL>        cave = first(caves);<EOL>    }<EOL>    const downloadKey =","gt":"first(downloadKeys);"}
{"input":"<s> export default function getGameStatus(rs: IRootState, game: Game, cave?: ICaveSummary): IGameStatus {<EOL>    const { commons, session, tasks, downloads } = rs;<EOL>    const { credentials } = session;<EOL>    let downloadKeys = getByIds(commons.downloadKeys, commons.downloadKeyIdsByGameId[game.id]);<EOL>    if (!cave) {<EOL>        let caves = getByIds(commons.caves, commons.caveIdsByGameId[game.id]);<EOL>        cave = first(caves);<EOL>    }<EOL>    const downloadKey = first(downloadKeys);<EOL>    const pressUser = credentials.me.pressUser;<EOL>    const task = first(tasks.tasksByGameId[game.id]);<EOL>    const download = first(getPendingForGame(downloads, game.id));<EOL>    let isActiveDownload = false;<EOL>","gt":"let areDownloadsPaused = false;"}
{"input":"<s> /**<EOL> * Splits the source Observable into two, one with values that satisfy a<EOL> * predicate, and another with values that don't satisfy the predicate.<EOL> *<EOL> * <span class=\"informal\">It's like {@link filter}, but returns two Observables:<EOL> * one like the output of {@link filter}, and the other with values that did not<EOL> * pass the condition.</span><EOL> *<EOL> * <img src=\"./img/partition.png\" width=\"100%\"><EOL> *<EOL> * `partition` outputs an array with two Observables that partition the values<EOL> * from the source Observable through the given `predicate` function. The first<EOL> * Observable in that array emits source values for which the predicate argument<EOL> * returns true. The second Observable emits source values for which the<EOL> * predicate returns false. The first behaves like {@link filter} and the second<EOL> * behaves like {@link filter} with the predicate negated.<EOL> *<EOL> * @example <caption>Partition click events into those on DIV elements and those elsewhere</caption><EOL> * var clicks = Rx.Observable.fromEvent(document, 'click');<EOL> * var parts = clicks.partition(ev => ev.target.tagName === 'DIV');<EOL> * var clicksOnDivs = parts[0];<EOL> * var clicksElsewhere = parts[1];<EOL> * clicksOnDivs.subscribe(x => console.log('DIV clicked: ', x));<EOL> * clicksElsewhere.subscribe(x => console.log('Other clicked: ', x));<EOL> *<EOL> * @see {@link filter}<EOL> *<EOL> * @param {function(value: T, index: number): boolean} predicate A function that<EOL> * evaluates each value emitted by the source Observable. If it returns `true`,<EOL> * the value is emitted on the first Observable in the returned array, if<EOL> * `false` the value is emitted on the second Observable in the array. The<EOL> * `index` parameter is the number `i` for the i-th source emission that has<EOL> * happened since the subscription, starting from the number `0`.<EOL> * @param {any} [thisArg] An optional argument to determine the value of `this`<EOL> * in the `predicate` function.<EOL> * @return {[Observable<T>, Observable<T>]} An array with two Observables: one<EOL> * with values that passed the predicate, and another with values that did not<EOL> * pass the predicate.<EOL> * @method partition<EOL> * @owner Observable<EOL> */<EOL>export function partition<T>(this: Observable<T>, predicate: (value: T) => boolean, thisArg?: any): [<EOL>    Observable<T>,<EOL>    Observable<T><EOL>] {<EOL>    return [<EOL>        filter.","gt":"call(this, predicate, thisArg),"}
{"input":"<s> /**<EOL> * Buffers the source Observable values until the size hits the maximum<EOL> * `bufferSize` given.<EOL> *<EOL> * <span class=\"informal\">Collects values from the past as an array, and emits<EOL> * that array only when its size reaches `bufferSize`.</span><EOL> *<EOL> * <img src=\"./img/bufferCount.png\" width=\"100%\"><EOL> *<EOL> * Buffers a number of values from the source Observable by `bufferSize` then<EOL> * emits the buffer and clears it, and starts a new buffer each<EOL> * `startBufferEvery` values. If `startBufferEvery` is not provided or is<EOL> * `null`, then new buffers are started immediately at the start of the source<EOL> * and when each buffer closes and is emitted.<EOL> *<EOL> * @example <caption>Emit the last two click events as an array</caption><EOL> * var clicks = Rx.Observable.fromEvent(document, 'click');<EOL> * var buffered = clicks.bufferCount(2);<EOL> * buffered.subscribe(x => console.log(x));<EOL> *<EOL> * @example <caption>On every click, emit the last two click events as an array</caption><EOL> * var clicks = Rx.Observable.fromEvent(document, 'click');<EOL> * var buffered = clicks.bufferCount(2, 1);<EOL> * buffered.subscribe(x => console.log(x));<EOL> *<EOL> * @see {@link buffer}<EOL> * @see {@link bufferTime}<EOL> * @see {@link bufferToggle}<EOL> * @see {@link bufferWhen}<EOL> * @see {@link pairwise}<EOL> * @see {@link windowCount}<EOL> *<EOL> * @param {number} bufferSize The maximum size of the buffer emitted.<EOL> * @param {number} [startBufferEvery] Interval at which to start a new buffer.<EOL> * For example if `startBufferEvery` is `2`, then a new buffer will be started<EOL> * on every other value from the source. A new buffer is started at the<EOL> * beginning of the source by default.<EOL> * @return {Observable<T[]>} An Observable of arrays of buffered values.<EOL> * @method bufferCount<EOL> * @owner Observable<EOL> */<EOL>export function bufferCount<T>(this: Observable<T>, bufferSize: number, startBufferEvery: number = null): Observable<T[]> {<EOL>    return higherOrder(","gt":"bufferSize, startBufferEvery)(this) as Observable<T[]>;"}
{"input":"<s> export function combineAll<T, R>(project?: (...values: Array<any>) => R): OperatorFunction<T, R> {<EOL>    return (source: Observable<T>) => source.","gt":"lift(new CombineLatestOperator(project));"}
{"input":"<s> export function gradient(fieldDef: FieldDef<string>, gradientSpec: any, model: UnitModel, channel: Channel, type: LegendType) {<EOL>    let out: any = {};<EOL>    if (type === '<STR_LIT>') {<EOL>        const opacity = getOpacityValue(model.encoding.opacity) || model.","gt":"markDef.opacity;"}
{"input":"<s> function getOpacityValue(opacityDef: FieldDefWithCondition<MarkPropFieldDef<string>> | ValueDefWithCondition<MarkPropFieldDef<string>>): number {<EOL>    if (isValueDef(opacityDef)) {<EOL>        if (hasConditionalValueDef(opacityDef)) {<EOL>            const values = isArray(opacityDef.condition) ? opacityDef.condition.map(c => c.value) : [opacityDef.condition.value];<EOL>            return Math.max.apply(null, [opacityDef.value].concat(","gt":"values));"}
{"input":"<s> function dispatchWindowTimeSpanOnly<T>(this: Action<TimeSpanOnlyState<T>>, state: TimeSpanOnlyState<T>): void {<EOL>    const { subscriber, windowTimeSpan, window } = state;<EOL>","gt":"if (window) {"}
{"input":"<s> export function applyBaseOptionsToArgs(options: IBaseOptions, args: string[]) {<EOL>    if (options.flatten && options.background) {<EOL>        args.push(\"<STR_LIT>\", \"<STR_LIT>\", options.background);<EOL>    }<EOL>    else if (options.background) {<EOL>        args.push(\"<STR_LIT>\", options.background, \"<STR_LIT>\");<EOL>    }<EOL>    if (options.autoOrient) {<EOL>        args.push(\"<STR_LIT>\");<EOL>    }<EOL>    if (options.","gt":"coalesce) {"}
{"input":"<s> export function applyBaseOptionsToArgs(options: IBaseOptions, args: string[]) {<EOL>    if (options.flatten && options.background) {<EOL>        args.push(\"<STR_LIT>\", \"<STR_LIT>\", options.background);<EOL>    }<EOL>    else if (options.background) {<EOL>        args.push(\"<STR_LIT>\", options.background, \"<STR_LIT>\");<EOL>    }<EOL>    if (options.autoOrient) {<EOL>        args.push(\"<STR_LIT>\");<EOL>    }<EOL>    if (options.coalesce) {<EOL>        args.push(\"<STR_LIT>\");<EOL>    }<EOL>    if (options.quality) {<EOL>        args.push(","gt":"\"<STR_LIT>\", options.quality.toString());"}
{"input":"<s> export function formatBuildVersion(build: Build): string {<EOL>    if (build) {<EOL>        if (build.userVersion) {<EOL>","gt":"return `<STR_LIT>`;"}
{"input":"<s> function updateDownloadKeys(store: IStore, db: DB): IDownloadKeySummary[] {<EOL>    const { credentials } = store.getState().session;<EOL>    const hasMeId = credentials.me && credentials.me.id;<EOL>    if (!hasMeId) {<EOL>        return emptyArr;<EOL>    }<EOL>    const downloadKeys = db.downloadKeys.all(k => k<EOL>        .fields([\"<STR_LIT>\", \"<STR_LIT>\", \"<STR_LIT>\"])<EOL>        .where(\"<STR_LIT>\", credentials.me.id));<EOL>    push(store, {<EOL>        downloadKeys: indexBy(downloadKeys, \"<STR_LIT>\"),<EOL>","gt":"downloadKeyIdsByGameId: groupIdBy(downloadKeys, \"<STR_LIT>\"),"}
{"input":"<s> /**<EOL> * Replaces repeated value and returns if the repeated value is valid.<EOL> */<EOL>function replaceRepeat<T extends {<EOL>    field?: Field;<EOL>}>(o: T, repeater: RepeaterValue): T {<EOL>    if (isRepeatRef(o.field)) {<EOL>        if (o.field.repeat in repeater) {<EOL>            <EOL>            return { ...o as any, field: repeater[","gt":"o.field.repeat] };"}
{"input":"<s> async function applyDefaultsToThumbnailOptions(options: IThumbnailOptions) {<EOL>    if (!options.x) {<EOL>        options.x = <NUM_LIT>;<EOL>    }<EOL>    if (!options.y) {<EOL>        options.y = <NUM_LIT>;<EOL>    }<EOL>    if (!options.interpolate) {<EOL>        const availableVersion = await getImageMagickVersion();<EOL>        switch (availableVersion) {<EOL>            case","gt":"<NUM_LIT>:"}
{"input":"<s> async function applyDefaultsToThumbnailOptions(options: IThumbnailOptions) {<EOL>    if (!options.x) {<EOL>        options.x = <NUM_LIT>;<EOL>    }<EOL>    if (!options.y) {<EOL>        options.y = <NUM_LIT>;<EOL>    }<EOL>    if (!options.interpolate) {<EOL>        const availableVersion = await getImageMagickVersion();<EOL>        switch (availableVersion) {<EOL>            case <NUM_LIT>:<EOL>                options.interpolate = \"<STR_LIT>\";<EOL>                break;<EOL>            case","gt":"<NUM_LIT>:"}
{"input":"<s> function parseNonUnitLegend(model: Model) {<EOL>    const { legends, resolve } = model.component;<EOL>    for (const child of model.children) {<EOL>        parseLegend(","gt":"child);"}
{"input":"<s> function parseNonUnitLegend(model: Model) {<EOL>    const { legends, resolve } = model.component;<EOL>    for (const child of model.children) {<EOL>        parseLegend(child);<EOL>        keys(child.component.legends).forEach((channel: NonPositionScaleChannel) => {<EOL>            resolve.legend[channel] = parseGuideResolve(model.component.resolve, channel);<EOL>            if (resolve.","gt":"legend[channel] === '<STR_LIT>') {"}
{"input":"<s> function parseNonUnitLegend(model: Model) {<EOL>    const { legends, resolve } = model.component;<EOL>    for (const child of model.children) {<EOL>        parseLegend(child);<EOL>        keys(child.component.legends).forEach((channel: NonPositionScaleChannel) => {<EOL>            resolve.legend[channel] = parseGuideResolve(model.component.resolve, channel);<EOL>            if (resolve.legend[channel] === '<STR_LIT>') {<EOL>                <EOL>                <EOL>                legends[channel] = mergeLegendComponent(legends[channel], child.component.legends[channel]);<EOL>","gt":"if (!legends[channel]) {"}
{"input":"<s> function parseNonUnitLegend(model: Model) {<EOL>    const { legends, resolve } = model.component;<EOL>    for (const child of model.children) {<EOL>        parseLegend(child);<EOL>        keys(child.component.legends).forEach((channel: NonPositionScaleChannel) => {<EOL>            resolve.legend[channel] = parseGuideResolve(model.component.resolve, channel);<EOL>            if (resolve.legend[channel] === '<STR_LIT>') {<EOL>                <EOL>                <EOL>                legends[channel] = mergeLegendComponent(legends[channel], child.component.legends[channel]);<EOL>                if (!legends[channel]) {<EOL>                    <EOL>                    <EOL>                    resolve.","gt":"legend[channel] = '<STR_LIT>';"}
{"input":"<s> function parseNonUnitLegend(model: Model) {<EOL>    const { legends, resolve } = model.component;<EOL>    for (const child of model.children) {<EOL>        parseLegend(child);<EOL>        keys(child.component.legends).forEach((channel: NonPositionScaleChannel) => {<EOL>            resolve.legend[channel] = parseGuideResolve(model.component.resolve, channel);<EOL>            if (resolve.legend[channel] === '<STR_LIT>') {<EOL>                <EOL>                <EOL>                legends[channel] = mergeLegendComponent(legends[channel], child.component.legends[channel]);<EOL>                if (!legends[channel]) {<EOL>                    <EOL>                    <EOL>                    resolve.legend[channel] = '<STR_LIT>';<EOL>                    delete legends[channel];<EOL>                }<EOL>            }<EOL>        });<EOL>    }<EOL>    keys(legends).forEach((channel: NonPositionScaleChannel) => {<EOL>        for (const child of model.children) {<EOL>            if (!child.component.legends[channel]) {<EOL>                <EOL>","gt":"continue;"}
{"input":"<s> export function isLookup(t: Transform): t is LookupTransform {<EOL>","gt":"return t['<STR_LIT>'] !== undefined;"}
{"input":"<s> /**<EOL> * Converts a higher-order Observable into a first-order Observable by<EOL> * subscribing to only the most recently emitted of those inner Observables.<EOL> *<EOL> * <span class=\"informal\">Flattens an Observable-of-Observables by dropping the<EOL> * previous inner Observable once a new one appears.</span><EOL> *<EOL> * <img src=\"./img/switch.png\" width=\"100%\"><EOL> *<EOL> * `switch` subscribes to an Observable that emits Observables, also known as a<EOL> * higher-order Observable. Each time it observes one of these emitted inner<EOL> * Observables, the output Observable subscribes to the inner Observable and<EOL> * begins emitting the items emitted by that. So far, it behaves<EOL> * like {@link mergeAll}. However, when a new inner Observable is emitted,<EOL> * `switch` unsubscribes from the earlier-emitted inner Observable and<EOL> * subscribes to the new inner Observable and begins emitting items from it. It<EOL> * continues to behave like this for subsequent inner Observables.<EOL> *<EOL> * @example <caption>Rerun an interval Observable on every click event</caption><EOL> * var clicks = Rx.Observable.fromEvent(document, 'click');<EOL> * // Each click event is mapped to an Observable that ticks every second<EOL> * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000));<EOL> * var switched = higherOrder.switch();<EOL> * // The outcome is that `switched` is essentially a timer that restarts<EOL> * // on every click. The interval Observables from older clicks do not merge<EOL> * // with the current interval Observable.<EOL> * switched.subscribe(x => console.log(x));<EOL> *<EOL> * @see {@link combineAll}<EOL> * @see {@link concatAll}<EOL> * @see {@link exhaust}<EOL> * @see {@link mergeAll}<EOL> * @see {@link switchMap}<EOL> * @see {@link switchMapTo}<EOL> * @see {@link zipAll}<EOL> *<EOL> * @return {Observable<T>} An Observable that emits the items emitted by the<EOL> * Observable most recently emitted by the source Observable.<EOL> * @method switch<EOL> * @name switch<EOL> * @owner Observable<EOL> */<EOL>export function _switch<T>(this: Observable<Observable<T>>): Observable<T> {<EOL>    return higherOrder()(","gt":"this) as Observable<T>;"}
{"input":"<s> export function isPromise<T>(value: any | Promise<T>): value is Promise<T> {<EOL>    return value &&","gt":"typeof (<any>value).subscribe !== '<STR_LIT>' && typeof (value as any).then === '<STR_LIT>';"}
{"input":"<s> export function isBin(t: Transform): t is BinTransform {<EOL>    return !!t[","gt":"'<STR_LIT>'];"}
{"input":"<s> <EOL>export function onErrorResumeNextStatic<T, R>(...nextSources: Array<ObservableInput<any> | Array<ObservableInput<any>> | ((...values: Array<any>) => R)>): Observable<R> {<EOL>    let source: ObservableInput<any> = null;<EOL>    if (nextSources.length ===","gt":"<NUM_LIT> && isArray(nextSources[<NUM_LIT>])) {"}
{"input":"<s> export function isTimeUnit(t: Transform): t is TimeUnitTransform {<EOL>    return t['<STR_LIT>'] !==","gt":"undefined;"}
{"input":"<s> function plucker(props: string[], length: number): (x: string) => any {<EOL>    const mapper = (x: string) => {<EOL>        let currentProp = x;<EOL>        for (let i = <NUM_LIT>; i < length; i++) {<EOL>            const p = currentProp[props[i]];<EOL>","gt":"if (typeof p !== '<STR_LIT>') {"}
{"input":"<s> export function publishLast<T>(): UnaryFunction<Observable<T>, ConnectableObservable<T>> {<EOL>    return (source: Observable<T>) => multicast(","gt":"new AsyncSubject<T>())(source);"}
{"input":"<s> /**<EOL> * @param value<EOL> * @return {ConnectableObservable<T>}<EOL> * @method publishBehavior<EOL> * @owner Observable<EOL> */<EOL>export function publishBehavior<T>(this: Observable<T>, value: T): ConnectableObservable<T> {<EOL>    return multicast.call(this, new BehaviorSubject<T>(","gt":"value));"}
{"input":"<s> /**<EOL> * Converts an Observable of {@link Notification} objects into the emissions<EOL> * that they represent.<EOL> *<EOL> * <span class=\"informal\">Unwraps {@link Notification} objects as actual `next`,<EOL> * `error` and `complete` emissions. The opposite of {@link materialize}.</span><EOL> *<EOL> * <img src=\"./img/dematerialize.png\" width=\"100%\"><EOL> *<EOL> * `dematerialize` is assumed to operate an Observable that only emits<EOL> * {@link Notification} objects as `next` emissions, and does not emit any<EOL> * `error`. Such Observable is the output of a `materialize` operation. Those<EOL> * notifications are then unwrapped using the metadata they contain, and emitted<EOL> * as `next`, `error`, and `complete` on the output Observable.<EOL> *<EOL> * Use this operator in conjunction with {@link materialize}.<EOL> *<EOL> * @example <caption>Convert an Observable of Notifications to an actual Observable</caption><EOL> * var notifA = new Rx.Notification('N', 'A');<EOL> * var notifB = new Rx.Notification('N', 'B');<EOL> * var notifE = new Rx.Notification('E', void 0,<EOL> *   new TypeError('x.toUpperCase is not a function')<EOL> * );<EOL> * var materialized = Rx.Observable.of(notifA, notifB, notifE);<EOL> * var upperCase = materialized.dematerialize();<EOL> * upperCase.subscribe(x => console.log(x), e => console.error(e));<EOL> *<EOL> * // Results in:<EOL> * // A<EOL> * // B<EOL> * // TypeError: x.toUpperCase is not a function<EOL> *<EOL> * @see {@link Notification}<EOL> * @see {@link materialize}<EOL> *<EOL> * @return {Observable} An Observable that emits items and notifications<EOL> * embedded in Notification objects emitted by the source Observable.<EOL> * @method dematerialize<EOL> * @owner Observable<EOL> */<EOL>export function dematerialize<T>(this: Observable<T>): Observable<any> {<EOL>    return this.","gt":"lift(new DeMaterializeOperator());"}
{"input":"<s> export async function deployContract(contractName: string): Promise<ContractInstance> {<EOL>    return new Promise<ContractInstance>((resolve, reject) => {<EOL>        const dirPath = join(__dirname, \"<STR_LIT>\");<EOL>        const fileName = `<STR_LIT>`;<EOL>        const abi = JSON.parse(readFileSync(join(dirPath, fileName + \"<STR_LIT>\"), \"<STR_LIT>\"));<EOL>        const bin = readFileSync(join(dirPath, fileName + \"<STR_LIT>\"), \"<STR_LIT>\");<EOL>        const code =","gt":"\"<STR_LIT>\" + bin;"}
{"input":"<s> export async function deployContract(contractName: string): Promise<ContractInstance> {<EOL>    return new Promise<ContractInstance>((resolve, reject) => {<EOL>        const dirPath = join(__dirname, \"<STR_LIT>\");<EOL>        const fileName = `<STR_LIT>`;<EOL>        const abi = JSON.parse(readFileSync(join(dirPath, fileName + \"<STR_LIT>\"), \"<STR_LIT>\"));<EOL>        const bin = readFileSync(join(dirPath, fileName + \"<STR_LIT>\"), \"<STR_LIT>\");<EOL>        const code = \"<STR_LIT>\" + bin;<EOL>        const contract = web3.eth.contract(abi);<EOL>        (contract as any).new({ from: accounts[<NUM_LIT>], data: code, gas: GAS_LIMIT_STANDARD }, (err: Error, contract: any) => {<EOL>            <EOL>            <EOL>            if (err) {<EOL>                reject(err);<EOL>            }<EOL>            else if (contract.","gt":"address) {"}
{"input":"<s> export function blessDefinition(definition: Definition): Definition {<EOL>    return {<EOL>        identifier:","gt":"definition.identifier,"}
{"input":"<s> export function parseEvmType(rawType: string): EvmType {<EOL>    const lastChar = rawType[rawType.length - <NUM_LIT>];<EOL>    if (lastChar === \"<STR_LIT>\") {<EOL>        <EOL>","gt":"let finishArrayTypeIndex = rawType.length - <NUM_LIT>;"}
{"input":"<s> export function parseEvmType(rawType: string): EvmType {<EOL>    const lastChar = rawType[rawType.length - <NUM_LIT>];<EOL>    if (lastChar === \"<STR_LIT>\") {<EOL>        <EOL>        let finishArrayTypeIndex = rawType.length - <NUM_LIT>;<EOL>        while (rawType[finishArrayTypeIndex] !==","gt":"\"<STR_LIT>\") {"}
{"input":"<s> export function parseEvmType(rawType: string): EvmType {<EOL>    const lastChar = rawType[rawType.length - <NUM_LIT>];<EOL>    if (lastChar === \"<STR_LIT>\") {<EOL>        <EOL>        let finishArrayTypeIndex = rawType.length - <NUM_LIT>;<EOL>        while (rawType[finishArrayTypeIndex] !== \"<STR_LIT>\") {<EOL>            finishArrayTypeIndex--;<EOL>        }<EOL>        const","gt":"arraySizeRaw = rawType.slice(finishArrayTypeIndex + <NUM_LIT>, rawType.length - <NUM_LIT>);"}
{"input":"<s> export function parseEvmType(rawType: string): EvmType {<EOL>    const lastChar = rawType[rawType.length - <NUM_LIT>];<EOL>    if (lastChar === \"<STR_LIT>\") {<EOL>        <EOL>        let finishArrayTypeIndex = rawType.length - <NUM_LIT>;<EOL>        while (rawType[finishArrayTypeIndex] !== \"<STR_LIT>\") {<EOL>            finishArrayTypeIndex--;<EOL>        }<EOL>        const arraySizeRaw = rawType.slice(finishArrayTypeIndex + <NUM_LIT>, rawType.length - <NUM_LIT>);<EOL>        const arraySize = arraySizeRaw !== \"<STR_LIT>\" ? parseInt(arraySizeRaw) : undefined;<EOL>        const restOfTheType = rawType.slice(<NUM_LIT>, finishArrayTypeIndex);<EOL>        return new ArrayType(parseEvmType(restOfTheType), arraySize);<EOL>    }<EOL>    <EOL>    <EOL>    switch (rawType) {<EOL>        case \"<STR_LIT>\":<EOL>","gt":"return new BooleanType();"}
{"input":"<s> export function parseEvmType(rawType: string): EvmType {<EOL>    const lastChar = rawType[rawType.length - <NUM_LIT>];<EOL>    if (lastChar === \"<STR_LIT>\") {<EOL>        <EOL>        let finishArrayTypeIndex = rawType.length - <NUM_LIT>;<EOL>        while (rawType[finishArrayTypeIndex] !== \"<STR_LIT>\") {<EOL>            finishArrayTypeIndex--;<EOL>        }<EOL>        const arraySizeRaw = rawType.slice(finishArrayTypeIndex + <NUM_LIT>, rawType.length - <NUM_LIT>);<EOL>        const arraySize = arraySizeRaw !== \"<STR_LIT>\" ? parseInt(arraySizeRaw) : undefined;<EOL>        const restOfTheType = rawType.slice(<NUM_LIT>, finishArrayTypeIndex);<EOL>        return new ArrayType(parseEvmType(restOfTheType), arraySize);<EOL>    }<EOL>    <EOL>    <EOL>    switch (rawType) {<EOL>        case \"<STR_LIT>\":<EOL>            return new BooleanType();<EOL>        case \"<STR_LIT>\":<EOL>            return new AddressType();<EOL>        case","gt":"\"<STR_LIT>\":"}
{"input":"<s> export function parseEvmType(rawType: string): EvmType {<EOL>    const lastChar = rawType[rawType.length - <NUM_LIT>];<EOL>    if (lastChar === \"<STR_LIT>\") {<EOL>        <EOL>        let finishArrayTypeIndex = rawType.length - <NUM_LIT>;<EOL>        while (rawType[finishArrayTypeIndex] !== \"<STR_LIT>\") {<EOL>            finishArrayTypeIndex--;<EOL>        }<EOL>        const arraySizeRaw = rawType.slice(finishArrayTypeIndex + <NUM_LIT>, rawType.length - <NUM_LIT>);<EOL>        const arraySize = arraySizeRaw !== \"<STR_LIT>\" ? parseInt(arraySizeRaw) : undefined;<EOL>        const restOfTheType = rawType.slice(<NUM_LIT>, finishArrayTypeIndex);<EOL>        return new ArrayType(parseEvmType(restOfTheType), arraySize);<EOL>    }<EOL>    <EOL>    <EOL>    switch (rawType) {<EOL>        case \"<STR_LIT>\":<EOL>            return new BooleanType();<EOL>        case \"<STR_LIT>\":<EOL>            return new AddressType();<EOL>        case \"<STR_LIT>\":<EOL>            return new StringType();<EOL>        case \"<STR_LIT>\":<EOL>            return new BytesType(<NUM_LIT>);<EOL>        case \"<STR_LIT>\":<EOL>            return new ArrayType(new BytesType(<NUM_LIT>));<EOL>    }<EOL>    if (isUIntTypeRegex.test(rawType)) {<EOL>        const match = isUIntTypeRegex.exec(rawType);<EOL>        return new UnsignedIntegerType(parseInt(match![<NUM_LIT>] ||","gt":"\"<STR_LIT>\"));"}
{"input":"<s> function getTargetNamesForConstructor(constructor: Function) {<EOL>    const ancestors = getAncestorsForConstructor(constructor);<EOL>    return Array.","gt":"from(ancestors.reduce((targetNames, constructor) => {"}
{"input":"<s> function capitalize(name: string) {<EOL>","gt":"return name.charAt(<NUM_LIT>).toUpperCase() + name.slice(<NUM_LIT>);"}
{"input":"<s> <EOL>/**<EOL> *<EOL> * Errors if Observable does not emit a value in given time span, in case of which<EOL> * subscribes to the second Observable.<EOL> *<EOL> * <span class=\"informal\">It's a version of `timeout` operator that let's you specify fallback Observable.</span><EOL> *<EOL> * <img src=\"./img/timeoutWith.png\" width=\"100%\"><EOL> *<EOL> * `timeoutWith` is a variation of `timeout` operator. It behaves exactly the same,<EOL> * still accepting as a first argument either a number or a Date, which control - respectively -<EOL> * when values of source Observable should be emitted or when it should complete.<EOL> *<EOL> * The only difference is that it accepts a second, required parameter. This parameter<EOL> * should be an Observable which will be subscribed when source Observable fails any timeout check.<EOL> * So whenever regular `timeout` would emit an error, `timeoutWith` will instead start re-emitting<EOL> * values from second Observable. Note that this fallback Observable is not checked for timeouts<EOL> * itself, so it can emit values and complete at arbitrary points in time. From the moment of a second<EOL> * subscription, Observable returned from `timeoutWith` simply mirrors fallback stream. When that<EOL> * stream completes, it completes as well.<EOL> *<EOL> * Scheduler, which in case of `timeout` is provided as as second argument, can be still provided<EOL> * here - as a third, optional parameter. It still is used to schedule timeout checks and -<EOL> * as a consequence - when second Observable will be subscribed, since subscription happens<EOL> * immediately after failing check.<EOL> *<EOL> * @example <caption>Add fallback observable</caption><EOL> * const seconds = Rx.Observable.interval(1000);<EOL> * const minutes = Rx.Observable.interval(60 * 1000);<EOL> *<EOL> * seconds.timeoutWith(900, minutes)<EOL> *     .subscribe(<EOL> *         value => console.log(value), // After 900ms, will start emitting `minutes`,<EOL> *                                      // since first value of `seconds` will not arrive fast enough.<EOL> *         err => console.log(err) // Would be called after 900ms in case of `timeout`,<EOL> *                                 // but here will never be called.<EOL> *     );<EOL> *<EOL> * @param {number|Date} due Number specifying period within which Observable must emit values<EOL> *                          or Date specifying before when Observable should complete<EOL> * @param {Observable<T>} withObservable Observable which will be subscribed if source fails timeout check.<EOL> * @param {Scheduler} [scheduler] Scheduler controlling when timeout checks occur.<EOL> * @return {Observable<T>} Observable that mirrors behaviour of source or, when timeout check fails, of an Observable<EOL> *                          passed as a second parameter.<EOL> * @method timeoutWith<EOL> * @owner Observable<EOL> */<EOL>export function timeoutWith<T, R>(this: Observable<T>, due: number | Date, withObservable: ObservableInput<R>, scheduler: IScheduler = async): Observable<T | R> {<EOL>    return","gt":"higherOrder(due, withObservable, scheduler)(this as any);"}
{"input":"<s> <EOL>export function getDefaultValue(property: keyof Scale, channel: Channel, fieldDef: FieldDef<string>, sort: SortOrder | SortField<string>, scaleType: ScaleType, scalePadding: number, scalePaddingInner: number, specifiedDomain: Scale['<STR_LIT>'], markDef: MarkDef, config: Config) {<EOL>    const scaleConfig = config.scale;<EOL>    <EOL>    switch (property) {<EOL>        case '<STR_LIT>':<EOL>            return nice(scaleType, channel, fieldDef);<EOL>","gt":"case '<STR_LIT>':"}
{"input":"<s> <EOL>export function getDefaultValue(property: keyof Scale, channel: Channel, fieldDef: FieldDef<string>, sort: SortOrder | SortField<string>, scaleType: ScaleType, scalePadding: number, scalePaddingInner: number, specifiedDomain: Scale['<STR_LIT>'], markDef: MarkDef, config: Config) {<EOL>    const scaleConfig = config.scale;<EOL>    <EOL>    switch (property) {<EOL>        case '<STR_LIT>':<EOL>            return nice(scaleType, channel, fieldDef);<EOL>        case '<STR_LIT>':<EOL>            return padding(channel, scaleType, scaleConfig, fieldDef, markDef, config.bar);<EOL>        case '<STR_LIT>':<EOL>            return paddingInner(scalePadding, channel, scaleConfig);<EOL>        case","gt":"'<STR_LIT>':"}
{"input":"<s> <EOL>export function getDefaultValue(property: keyof Scale, channel: Channel, fieldDef: FieldDef<string>, sort: SortOrder | SortField<string>, scaleType: ScaleType, scalePadding: number, scalePaddingInner: number, specifiedDomain: Scale['<STR_LIT>'], markDef: MarkDef, config: Config) {<EOL>    const scaleConfig = config.scale;<EOL>    <EOL>    switch (property) {<EOL>        case '<STR_LIT>':<EOL>            return nice(scaleType, channel, fieldDef);<EOL>        case '<STR_LIT>':<EOL>            return padding(channel, scaleType, scaleConfig, fieldDef, markDef, config.bar);<EOL>        case '<STR_LIT>':<EOL>            return paddingInner(scalePadding, channel, scaleConfig);<EOL>        case '<STR_LIT>':<EOL>            return paddingOuter(scalePadding, channel, scaleType, scalePaddingInner, scaleConfig);<EOL>        case '<STR_LIT>':<EOL>            return reverse(scaleType, sort);<EOL>","gt":"case '<STR_LIT>':"}
{"input":"<s> function shareSubjectFactory() {<EOL>    return new","gt":"Subject();"}
{"input":"<s> /**<EOL> * Returns an Observable that mirrors the source Observable with the exception of a `complete`. If the source<EOL> * Observable calls `complete`, this method will emit to the Observable returned from `notifier`. If that Observable<EOL> * calls `complete` or `error`, then this method will call `complete` or `error` on the child subscription. Otherwise<EOL> * this method will resubscribe to the source Observable.<EOL> *<EOL> * <img src=\"./img/repeatWhen.png\" width=\"100%\"><EOL> *<EOL> * @param {function(notifications: Observable): Observable} notifier - Receives an Observable of notifications with<EOL> * which a user can `complete` or `error`, aborting the repetition.<EOL> * @return {Observable} The source Observable modified with repeat logic.<EOL> * @method repeatWhen<EOL> * @owner Observable<EOL> */<EOL>export function repeatWhen<T>(this: Observable<T>, notifier: (notifications: Observable<any>) => Observable<any>): Observable<T> {<EOL>    return this.lift(new","gt":"RepeatWhenOperator(notifier));"}
{"input":"<s> export function easeOutQuart(x: number) {<EOL>    return <NUM_LIT> - pow(<NUM_LIT> -","gt":"x, <NUM_LIT>);"}
{"input":"<s> /**<EOL> * Splits the source Observable into two, one with values that satisfy a<EOL> * predicate, and another with values that don't satisfy the predicate.<EOL> *<EOL> * <span class=\"informal\">It's like {@link filter}, but returns two Observables:<EOL> * one like the output of {@link filter}, and the other with values that did not<EOL> * pass the condition.</span><EOL> *<EOL> * <img src=\"./img/partition.png\" width=\"100%\"><EOL> *<EOL> * `partition` outputs an array with two Observables that partition the values<EOL> * from the source Observable through the given `predicate` function. The first<EOL> * Observable in that array emits source values for which the predicate argument<EOL> * returns true. The second Observable emits source values for which the<EOL> * predicate returns false. The first behaves like {@link filter} and the second<EOL> * behaves like {@link filter} with the predicate negated.<EOL> *<EOL> * @example <caption>Partition click events into those on DIV elements and those elsewhere</caption><EOL> * var clicks = Rx.Observable.fromEvent(document, 'click');<EOL> * var parts = clicks.partition(ev => ev.target.tagName === 'DIV');<EOL> * var clicksOnDivs = parts[0];<EOL> * var clicksElsewhere = parts[1];<EOL> * clicksOnDivs.subscribe(x => console.log('DIV clicked: ', x));<EOL> * clicksElsewhere.subscribe(x => console.log('Other clicked: ', x));<EOL> *<EOL> * @see {@link filter}<EOL> *<EOL> * @param {function(value: T, index: number): boolean} predicate A function that<EOL> * evaluates each value emitted by the source Observable. If it returns `true`,<EOL> * the value is emitted on the first Observable in the returned array, if<EOL> * `false` the value is emitted on the second Observable in the array. The<EOL> * `index` parameter is the number `i` for the i-th source emission that has<EOL> * happened since the subscription, starting from the number `0`.<EOL> * @param {any} [thisArg] An optional argument to determine the value of `this`<EOL> * in the `predicate` function.<EOL> * @return {[Observable<T>, Observable<T>]} An array with two Observables: one<EOL> * with values that passed the predicate, and another with values that did not<EOL> * pass the predicate.<EOL> * @method partition<EOL> * @owner Observable<EOL> */<EOL>export function partition<T>(predicate: (value: T, index: number) => boolean, thisArg?: any): UnaryFunction<Observable<T>, [<EOL>    Observable<T>,<EOL>    Observable<T><EOL>]> {<EOL>    return (source: Observable<T>) => [<EOL>        filter(predicate, thisArg)(source),<EOL>        filter(not(predicate,","gt":"thisArg) as any)(source)"}
{"input":"<s> /**<EOL> * Splits the source Observable into two, one with values that satisfy a<EOL> * predicate, and another with values that don't satisfy the predicate.<EOL> *<EOL> * <span class=\"informal\">It's like {@link filter}, but returns two Observables:<EOL> * one like the output of {@link filter}, and the other with values that did not<EOL> * pass the condition.</span><EOL> *<EOL> * <img src=\"./img/partition.png\" width=\"100%\"><EOL> *<EOL> * `partition` outputs an array with two Observables that partition the values<EOL> * from the source Observable through the given `predicate` function. The first<EOL> * Observable in that array emits source values for which the predicate argument<EOL> * returns true. The second Observable emits source values for which the<EOL> * predicate returns false. The first behaves like {@link filter} and the second<EOL> * behaves like {@link filter} with the predicate negated.<EOL> *<EOL> * @example <caption>Partition click events into those on DIV elements and those elsewhere</caption><EOL> * var clicks = Rx.Observable.fromEvent(document, 'click');<EOL> * var parts = clicks.partition(ev => ev.target.tagName === 'DIV');<EOL> * var clicksOnDivs = parts[0];<EOL> * var clicksElsewhere = parts[1];<EOL> * clicksOnDivs.subscribe(x => console.log('DIV clicked: ', x));<EOL> * clicksElsewhere.subscribe(x => console.log('Other clicked: ', x));<EOL> *<EOL> * @see {@link filter}<EOL> *<EOL> * @param {function(value: T, index: number): boolean} predicate A function that<EOL> * evaluates each value emitted by the source Observable. If it returns `true`,<EOL> * the value is emitted on the first Observable in the returned array, if<EOL> * `false` the value is emitted on the second Observable in the array. The<EOL> * `index` parameter is the number `i` for the i-th source emission that has<EOL> * happened since the subscription, starting from the number `0`.<EOL> * @param {any} [thisArg] An optional argument to determine the value of `this`<EOL> * in the `predicate` function.<EOL> * @return {[Observable<T>, Observable<T>]} An array with two Observables: one<EOL> * with values that passed the predicate, and another with values that did not<EOL> * pass the predicate.<EOL> * @method partition<EOL> * @owner Observable<EOL> */<EOL>export function partition<T>(this: Observable<T>, predicate: (value: T, index: number) => boolean, thisArg?: any): [<EOL>    Observable<T>,<EOL>    Observable<T><EOL>] {<EOL>    return higherOrder(","gt":"predicate, thisArg)(this);"}
{"input":"<s> <EOL>/**<EOL> * Projects each source value to an Observable which is merged in the output<EOL> * Observable, in a serialized fashion waiting for each one to complete before<EOL> * merging the next.<EOL> *<EOL> * <span class=\"informal\">Maps each value to an Observable, then flattens all of<EOL> * these inner Observables using {@link concatAll}.</span><EOL> *<EOL> * <img src=\"./img/concatMap.png\" width=\"100%\"><EOL> *<EOL> * Returns an Observable that emits items based on applying a function that you<EOL> * supply to each item emitted by the source Observable, where that function<EOL> * returns an (so-called \"inner\") Observable. Each new inner Observable is<EOL> * concatenated with the previous inner Observable.<EOL> *<EOL> * __Warning:__ if source values arrive endlessly and faster than their<EOL> * corresponding inner Observables can complete, it will result in memory issues<EOL> * as inner Observables amass in an unbounded buffer waiting for their turn to<EOL> * be subscribed to.<EOL> *<EOL> * Note: `concatMap` is equivalent to `mergeMap` with concurrency parameter set<EOL> * to `1`.<EOL> *<EOL> * @example <caption>For each click event, tick every second from 0 to 3, with no concurrency</caption><EOL> * var clicks = Rx.Observable.fromEvent(document, 'click');<EOL> * var result = clicks.concatMap(ev => Rx.Observable.interval(1000).take(4));<EOL> * result.subscribe(x => console.log(x));<EOL> *<EOL> * // Results in the following:<EOL> * // (results are not concurrent)<EOL> * // For every click on the \"document\" it will emit values 0 to 3 spaced<EOL> * // on a 1000ms interval<EOL> * // one click = 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3<EOL> *<EOL> * @see {@link concat}<EOL> * @see {@link concatAll}<EOL> * @see {@link concatMapTo}<EOL> * @see {@link exhaustMap}<EOL> * @see {@link mergeMap}<EOL> * @see {@link switchMap}<EOL> *<EOL> * @param {function(value: T, ?index: number): ObservableInput} project A function<EOL> * that, when applied to an item emitted by the source Observable, returns an<EOL> * Observable.<EOL> * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]<EOL> * A function to produce the value on the output Observable based on the values<EOL> * and the indices of the source (outer) emission and the inner Observable<EOL> * emission. The arguments passed to this function are:<EOL> * - `outerValue`: the value that came from the source<EOL> * - `innerValue`: the value that came from the projected Observable<EOL> * - `outerIndex`: the \"index\" of the value that came from the source<EOL> * - `innerIndex`: the \"index\" of the value from the projected Observable<EOL> * @return {Observable} An Observable that emits the result of applying the<EOL> * projection function (and the optional `resultSelector`) to each item emitted<EOL> * by the source Observable and taking values from each projected inner<EOL> * Observable sequentially.<EOL> * @method concatMap<EOL> * @owner Observable<EOL> */<EOL>export function concatMap<T, I, R>(this: Observable<T>, project: (value: T, index: number) => ObservableInput<I>, resultSelector?: (outerValue: T, innerValue: I, outerIndex: number, innerIndex: number) => R) {<EOL>    return higherOrderConcatMap(project,","gt":"resultSelector)(this);"}
{"input":"<s> export function instrument(source: string, fileName: string) {<EOL>    const sourceFile = ts.createSourceFile(fileName, source, ts.ScriptTarget.Latest, true);<EOL>    const replacements = [] as Replacement[];<EOL>    visit(sourceFile, replacements,","gt":"fileName);"}
{"input":"<s> function determineLinux64(): boolean {<EOL>    try {<EOL>        <EOL>        const arch = String(execSync(\"<STR_LIT>\")).trim();<EOL>        return","gt":"arch === \"<STR_LIT>\";"}
{"input":"<s> function determineLinux64(): boolean {<EOL>    try {<EOL>        <EOL>        const arch = String(execSync(\"<STR_LIT>\")).trim();<EOL>        return arch === \"<STR_LIT>\";<EOL>    }<EOL>    catch (e) {<EOL>","gt":"logger.warn(`<STR_LIT>`);"}
{"input":"<s> function determineLinux64(): boolean {<EOL>    try {<EOL>        <EOL>        const arch = String(execSync(\"<STR_LIT>\")).trim();<EOL>        return arch === \"<STR_LIT>\";<EOL>    }<EOL>    catch (e) {<EOL>        logger.warn(`<STR_LIT>`);<EOL>    }<EOL>    try {<EOL>        <EOL>        const arch = String(execSync(\"<STR_LIT>\")).trim();<EOL>        return arch ===","gt":"\"<STR_LIT>\";"}
{"input":"<s> /**<EOL> * Returns an Observable that emits whether or not every item of the source satisfies the condition specified.<EOL> *<EOL> * @example <caption>A simple example emitting true if all elements are less than 5, false otherwise</caption><EOL> *  Observable.of(1, 2, 3, 4, 5, 6)<EOL> *     .every(x => x < 5)<EOL> *     .subscribe(x => console.log(x)); // -> false<EOL> *<EOL> * @param {function} predicate A function for determining if an item meets a specified condition.<EOL> * @param {any} [thisArg] Optional object to use for `this` in the callback.<EOL> * @return {Observable} An Observable of booleans that determines if all items of the source Observable meet the condition specified.<EOL> * @method every<EOL> * @owner Observable<EOL> */<EOL>export function every<T>(this: Observable<T>, predicate: (value: T, index: number, source: Observable<T>) => boolean, thisArg?: any): Observable<boolean> {<EOL>","gt":"return higherOrder(predicate, thisArg)(this);"}
{"input":"<s> <EOL>async function apply(opts: IApplyOpts) {<EOL>    const { patchPath, outPath, signaturePath } = opts;<EOL>    let args = [patchPath, \"<STR_LIT>\",","gt":"outPath, \"<STR_LIT>\", signaturePath];"}
{"input":"<s> /**<EOL> * Move facet nodes down to the next fork or output node. Also pull the main output with the facet node.<EOL> * After moving down the facet node, make a copy of the subtree and make it a child of the main output.<EOL> */<EOL>function moveFacetDown(node: DataFlowNode) {<EOL>    if (node instanceof FacetNode) {<EOL>        if (node.numChildren() === <NUM_LIT> && !(node.children[<NUM_LIT>] instanceof OutputNode)) {<EOL>            <EOL>            const child = node.children[","gt":"<NUM_LIT>];"}
{"input":"<s> /**<EOL> * Move facet nodes down to the next fork or output node. Also pull the main output with the facet node.<EOL> * After moving down the facet node, make a copy of the subtree and make it a child of the main output.<EOL> */<EOL>function moveFacetDown(node: DataFlowNode) {<EOL>    if (node instanceof FacetNode) {<EOL>        if (node.numChildren() === <NUM_LIT> && !(node.children[<NUM_LIT>] instanceof OutputNode)) {<EOL>            <EOL>            const child = node.children[<NUM_LIT>];<EOL>            if (child instanceof AggregateNode || child instanceof StackNode) {<EOL>                child.addDimensions(node.fields);<EOL>            }<EOL>            child.swapWithParent();<EOL>            moveFacetDown(node);<EOL>        }<EOL>        else {<EOL>            <EOL>            moveMainDownToFacet(node.model.component.data.main);<EOL>            <EOL>            const copy: DataFlowNode[] = flatten(node.children.map(cloneSubtree(node)));<EOL>            copy.forEach(c => c.parent = node.","gt":"model.component.data.main);"}
{"input":"<s> export function extractTensorsFromScopeResult(result: ScopeResult): Tensor[] {<EOL>    if (result == null) {<EOL>        return [];<EOL>    }<EOL>    if (result instanceof Tensor) {<EOL>        return [result];<EOL>    }<EOL>    const list: Tensor[] = [];<EOL>    const resultObj = result as {<EOL>        [key: string]: Tensor;<EOL>    };<EOL>","gt":"if (!isIterable(resultObj)) {"}
{"input":"<s> export function extractTensorsFromScopeResult(result: ScopeResult): Tensor[] {<EOL>    if (result == null) {<EOL>        return [];<EOL>    }<EOL>    if (result instanceof Tensor) {<EOL>        return [result];<EOL>    }<EOL>    const list: Tensor[] = [];<EOL>    const resultObj = result as {<EOL>        [key: string]: Tensor;<EOL>    };<EOL>    if (!isIterable(resultObj)) {<EOL>        return [];<EOL>    }<EOL>    <EOL>    for (const k","gt":"in resultObj) {"}
{"input":"<s> <EOL>/**<EOL> * When any of the provided Observable emits an complete or error notification, it immediately subscribes to the next one<EOL> * that was passed.<EOL> *<EOL> * <span class=\"informal\">Execute series of Observables no matter what, even if it means swallowing errors.</span><EOL> *<EOL> * <img src=\"./img/onErrorResumeNext.png\" width=\"100%\"><EOL> *<EOL> * `onErrorResumeNext` is an operator that accepts a series of Observables, provided either directly as<EOL> * arguments or as an array. If no single Observable is provided, returned Observable will simply behave the same<EOL> * as the source.<EOL> *<EOL> * `onErrorResumeNext` returns an Observable that starts by subscribing and re-emitting values from the source Observable.<EOL> * When its stream of values ends - no matter if Observable completed or emitted an error - `onErrorResumeNext`<EOL> * will subscribe to the first Observable that was passed as an argument to the method. It will start re-emitting<EOL> * its values as well and - again - when that stream ends, `onErrorResumeNext` will proceed to subscribing yet another<EOL> * Observable in provided series, no matter if previous Observable completed or ended with an error. This will<EOL> * be happening until there is no more Observables left in the series, at which point returned Observable will<EOL> * complete - even if the last subscribed stream ended with an error.<EOL> *<EOL> * `onErrorResumeNext` can be therefore thought of as version of {@link concat} operator, which is more permissive<EOL> * when it comes to the errors emitted by its input Observables. While `concat` subscribes to the next Observable<EOL> * in series only if previous one successfully completed, `onErrorResumeNext` subscribes even if it ended with<EOL> * an error.<EOL> *<EOL> * Note that you do not get any access to errors emitted by the Observables. In particular do not<EOL> * expect these errors to appear in error callback passed to {@link subscribe}. If you want to take<EOL> * specific actions based on what error was emitted by an Observable, you should try out {@link catch} instead.<EOL> *<EOL> *<EOL> * @example <caption>Subscribe to the next Observable after map fails</caption><EOL> * Rx.Observable.of(1, 2, 3, 0)<EOL> *   .map(x => {<EOL> *       if (x === 0) { throw Error(); }<EOL>         return 10 / x;<EOL> *   })<EOL> *   .onErrorResumeNext(Rx.Observable.of(1, 2, 3))<EOL> *   .subscribe(<EOL> *     val => console.log(val),<EOL> *     err => console.log(err),          // Will never be called.<EOL> *     () => console.log('that\\'s it!')<EOL> *   );<EOL> *<EOL> * // Logs:<EOL> * // 10<EOL> * // 5<EOL> * // 3.3333333333333335<EOL> * // 1<EOL> * // 2<EOL> * // 3<EOL> * // \"that's it!\"<EOL> *<EOL> * @see {@link concat}<EOL> * @see {@link catch}<EOL> *<EOL> * @param {...ObservableInput} observables Observables passed either directly or as an array.<EOL> * @return {Observable} An Observable that emits values from source Observable, but - if it errors - subscribes<EOL> * to the next passed Observable and so on, until it completes or runs out of Observables.<EOL> * @method onErrorResumeNext<EOL> * @owner Observable<EOL> */<EOL>export function onErrorResumeNext<T, R>(this: Observable<T>, ...nextSources: Array<ObservableInput<any> | Array<ObservableInput<any>> | ((...values: Array<any>) => R)>): Observable<R> {<EOL>","gt":"return higherOrder(...nextSources)(this);"}
{"input":"<s> export function bandPosition(fieldDef: FieldDef<string>, channel: '<STR_LIT>' | '<STR_LIT>', model: UnitModel) {<EOL>    const scaleName = model.scaleName(channel);<EOL>    const sizeChannel = channel === '<STR_LIT>' ? '<STR_LIT>' : '<STR_LIT>';<EOL>    if (model.encoding.","gt":"size) {"}
{"input":"<s> export function bandPosition(fieldDef: FieldDef<string>, channel: '<STR_LIT>' | '<STR_LIT>', model: UnitModel) {<EOL>    const scaleName = model.scaleName(channel);<EOL>    const sizeChannel = channel === '<STR_LIT>' ? '<STR_LIT>' : '<STR_LIT>';<EOL>    if (model.encoding.size) {<EOL>        const orient = model.markDef.orient;<EOL>        if (orient) {<EOL>            const centeredBandPositionMixins = {<EOL>                <EOL>                <EOL>                [channel + '<STR_LIT>']: ref.fieldRef(fieldDef, scaleName, {}, { band: <NUM_LIT> })<EOL>            };<EOL>            if (","gt":"getFieldDef(model.encoding.size)) {"}
{"input":"<s> /**<EOL> * Return mixins for x2, y2.<EOL> * If channel is not specified, return one channel based on orientation.<EOL> */<EOL>export function pointPosition2(model: UnitModel, defaultRef: '<STR_LIT>' | '<STR_LIT>', channel?: '<STR_LIT>' | '<STR_LIT>') {<EOL>    const { encoding, markDef, stack } = model;<EOL>    channel = channel || (markDef.orient === '<STR_LIT>' ?","gt":"'<STR_LIT>' : '<STR_LIT>');"}
{"input":"<s> <EOL>/**<EOL> * Returns an Observable that emits the items you specify as arguments before it begins to emit<EOL> * items emitted by the source Observable.<EOL> *<EOL> * <img src=\"./img/startWith.png\" width=\"100%\"><EOL> *<EOL> * @param {...T} values - Items you want the modified Observable to emit first.<EOL> * @param {Scheduler} [scheduler] - A {@link IScheduler} to use for scheduling<EOL> * the emissions of the `next` notifications.<EOL> * @return {Observable} An Observable that emits the items in the specified Iterable and then emits the items<EOL> * emitted by the source Observable.<EOL> * @method startWith<EOL> * @owner Observable<EOL> */<EOL>export function startWith<T>(...array: Array<T | IScheduler>): MonoTypeOperatorFunction<T> {<EOL>    return (source: Observable<T>) => {<EOL>        let scheduler = <IScheduler>array[array.length - <NUM_LIT>];<EOL>        if (isScheduler(scheduler)) {<EOL>            array.pop();<EOL>        }<EOL>","gt":"else {"}
{"input":"<s> <EOL>/**<EOL> * Returns an Observable that emits the items you specify as arguments before it begins to emit<EOL> * items emitted by the source Observable.<EOL> *<EOL> * <img src=\"./img/startWith.png\" width=\"100%\"><EOL> *<EOL> * @param {...T} values - Items you want the modified Observable to emit first.<EOL> * @param {Scheduler} [scheduler] - A {@link IScheduler} to use for scheduling<EOL> * the emissions of the `next` notifications.<EOL> * @return {Observable} An Observable that emits the items in the specified Iterable and then emits the items<EOL> * emitted by the source Observable.<EOL> * @method startWith<EOL> * @owner Observable<EOL> */<EOL>export function startWith<T>(...array: Array<T | IScheduler>): MonoTypeOperatorFunction<T> {<EOL>    return (source: Observable<T>) => {<EOL>        let scheduler = <IScheduler>array[array.length - <NUM_LIT>];<EOL>        if (isScheduler(scheduler)) {<EOL>            array.pop();<EOL>        }<EOL>        else {<EOL>            scheduler = null;<EOL>        }<EOL>        const len = array.length;<EOL>        if (len === <NUM_LIT>) {<EOL>            return concatStatic(new ScalarObservable<T>(<T>array[<NUM_LIT>], scheduler),","gt":"source);"}
{"input":"<s> function mergeMeasures(parentMeasures: Dict<Dict<string>>, childMeasures: Dict<Dict<string>>) {<EOL>    for (const f in childMeasures) {<EOL>        if (childMeasures.hasOwnProperty(f)) {<EOL>            <EOL>            const ops = childMeasures[f];<EOL>            for (const op in ops) {<EOL>                if (ops.","gt":"hasOwnProperty(op)) {"}
{"input":"<s> /**<EOL> *<EOL> * Errors if Observable does not emit a value in given time span.<EOL> *<EOL> * <span class=\"informal\">Timeouts on Observable that doesn't emit values fast enough.</span><EOL> *<EOL> * <img src=\"./img/timeout.png\" width=\"100%\"><EOL> *<EOL> * `timeout` operator accepts as an argument either a number or a Date.<EOL> *<EOL> * If number was provided, it returns an Observable that behaves like a source<EOL> * Observable, unless there is a period of time where there is no value emitted.<EOL> * So if you provide `100` as argument and first value comes after 50ms from<EOL> * the moment of subscription, this value will be simply re-emitted by the resulting<EOL> * Observable. If however after that 100ms passes without a second value being emitted,<EOL> * stream will end with an error and source Observable will be unsubscribed.<EOL> * These checks are performed throughout whole lifecycle of Observable - from the moment<EOL> * it was subscribed to, until it completes or errors itself. Thus every value must be<EOL> * emitted within specified period since previous value.<EOL> *<EOL> * If provided argument was Date, returned Observable behaves differently. It throws<EOL> * if Observable did not complete before provided Date. This means that periods between<EOL> * emission of particular values do not matter in this case. If Observable did not complete<EOL> * before provided Date, source Observable will be unsubscribed. Other than that, resulting<EOL> * stream behaves just as source Observable.<EOL> *<EOL> * `timeout` accepts also a Scheduler as a second parameter. It is used to schedule moment (or moments)<EOL> * when returned Observable will check if source stream emitted value or completed.<EOL> *<EOL> * @example <caption>Check if ticks are emitted within certain timespan</caption><EOL> * const seconds = Rx.Observable.interval(1000);<EOL> *<EOL> * seconds.timeout(1100) // Let's use bigger timespan to be safe,<EOL> *                       // since `interval` might fire a bit later then scheduled.<EOL> * .subscribe(<EOL> *     value => console.log(value), // Will emit numbers just as regular `interval` would.<EOL> *     err => console.log(err) // Will never be called.<EOL> * );<EOL> *<EOL> * seconds.timeout(900).subscribe(<EOL> *     value => console.log(value), // Will never be called.<EOL> *     err => console.log(err) // Will emit error before even first value is emitted,<EOL> *                             // since it did not arrive within 900ms period.<EOL> * );<EOL> *<EOL> * @example <caption>Use Date to check if Observable completed</caption><EOL> * const seconds = Rx.Observable.interval(1000);<EOL> *<EOL> * seconds.timeout(new Date(\"December 17, 2020 03:24:00\"))<EOL> * .subscribe(<EOL> *     value => console.log(value), // Will emit values as regular `interval` would<EOL> *                                  // until December 17, 2020 at 03:24:00.<EOL> *     err => console.log(err) // On December 17, 2020 at 03:24:00 it will emit an error,<EOL> *                             // since Observable did not complete by then.<EOL> * );<EOL> *<EOL> * @see {@link timeoutWith}<EOL> *<EOL> * @param {number|Date} due Number specifying period within which Observable must emit values<EOL> *                          or Date specifying before when Observable should complete<EOL> * @param {Scheduler} [scheduler] Scheduler controlling when timeout checks occur.<EOL> * @return {Observable<T>} Observable that mirrors behaviour of source, unless timeout checks fail.<EOL> * @method timeout<EOL> * @owner Observable<EOL> */<EOL>export function timeout<T>(due: number | Date, scheduler: IScheduler = async): MonoTypeOperatorFunction<T> {<EOL>","gt":"const absoluteTimeout = isDate(due);"}
{"input":"<s> /**<EOL> * Formats a platform for humans to read.<EOL> */<EOL>export function formatItchPlatform(p: ItchPlatform): string {<EOL>    return","gt":"itchPlatforms[p] || p;"}
{"input":"<s> export function main(): any {<EOL>","gt":"return platformBrowserDynamic()"}
{"input":"<s> export function computeOptimalWindowSize(inSize: number): number {<EOL>    if (inSize <= PARALLELIZE_THRESHOLD) {<EOL>","gt":"return inSize;"}
{"input":"<s> function getSamplerFlat(inputInfo: InputInfo): string {<EOL>    const texName = inputInfo.name;<EOL>    const texShape = inputInfo.shapeInfo.texShape;<EOL>    const funcName = '<STR_LIT>' + texName.charAt(<NUM_LIT>).toUpperCase() + texName.slice(<NUM_LIT>) + '<STR_LIT>';<EOL>    const tNumR = texShape[<NUM_LIT>];<EOL>    const","gt":"tNumC = texShape[<NUM_LIT>];"}
{"input":"<s> function getSamplerFlat(inputInfo: InputInfo): string {<EOL>    const texName = inputInfo.name;<EOL>    const texShape = inputInfo.shapeInfo.texShape;<EOL>    const funcName = '<STR_LIT>' + texName.charAt(<NUM_LIT>).toUpperCase() + texName.slice(<NUM_LIT>) + '<STR_LIT>';<EOL>    const tNumR = texShape[<NUM_LIT>];<EOL>    const tNumC = texShape[<NUM_LIT>];<EOL>    if (tNumC === <NUM_LIT> && tNumR === <NUM_LIT>) {<EOL>        return `<STR_LIT>`;<EOL>    }<EOL>    if (tNumC ===","gt":"<NUM_LIT>) {"}
{"input":"<s> function getSamplerFlat(inputInfo: InputInfo): string {<EOL>    const texName = inputInfo.name;<EOL>    const texShape = inputInfo.shapeInfo.texShape;<EOL>    const funcName = '<STR_LIT>' + texName.charAt(<NUM_LIT>).toUpperCase() + texName.slice(<NUM_LIT>) + '<STR_LIT>';<EOL>    const tNumR = texShape[<NUM_LIT>];<EOL>    const tNumC = texShape[<NUM_LIT>];<EOL>    if (tNumC === <NUM_LIT> && tNumR === <NUM_LIT>) {<EOL>        return `<STR_LIT>`;<EOL>    }<EOL>    if (tNumC === <NUM_LIT>) {<EOL>        return `<STR_LIT>`;<EOL>    }<EOL>    if (tNumR ===","gt":"<NUM_LIT>) {"}
{"input":"<s> export function expectArrayInMeanStdRange(actual: Tensor | TypedArray | number[], expectedMean: number, expectedStdDev: number, epsilon = TEST_EPSILON) {<EOL>    let actualValues: TypedArray | number[];<EOL>    if (actual instanceof Tensor) {<EOL>        actualValues = actual.dataSync();<EOL>    }<EOL>    else {<EOL>        actualValues = actual;<EOL>    }<EOL>    const actualMean = mean(","gt":"actualValues);"}
{"input":"<s> /**<EOL> * Creates an array of graph nodes that stop traversal, based on the contents<EOL> * of the provided FeedDictionary. This is a simple 1:1 extraction of nodes from<EOL> * the FeedDictionary.<EOL> *<EOL> * @hidden<EOL> * @param feedDictionary The FeedDictionary to scan for termination nodes.<EOL> * @return an array of Nodes which halt traversal when visited.<EOL> */<EOL>export function getTerminatingNodesFromFeedDictionary(feedDictionary: FeedDictionary): Node[] {<EOL>    return Object.","gt":"keys(feedDictionary.dict)"}
{"input":"<s> /**<EOL> * @hidden<EOL> */<EOL>export function getVariableNodesFromEvaluationSet(evaluationSet: Node[]): VariableNode[] {<EOL>    const nodes: VariableNode[] = [];<EOL>    evaluationSet.forEach(node => {<EOL>        if (","gt":"node instanceof VariableNode) {"}
{"input":"<s> export function _redefineProperty(obj, prop, desc) {<EOL>","gt":"const originalConfigurableFlag = desc.configurable;"}
{"input":"<s> /**<EOL> * Disposes any NDArrays on the tensorArrayMap from derivatives of operation<EOL> * inputs and sets the value to null.<EOL> *<EOL> * @hidden<EOL> * @param evaluationSet The set of nodes to be evaluated.<EOL> * @param gradients The gradient map to dispose and initialize.<EOL> */<EOL>export function disposeAndInitializeOperationInputGradients(evaluationSet: Node[], gradients: SummedTensorArrayMap) {<EOL>    evaluationSet.forEach(node => {<EOL>        Object.keys(node.inputs).forEach(inputName => {<EOL>","gt":"const input = node.inputs[inputName];"}
{"input":"<s> /**<EOL> * Returns the axes permutation to be used with `dl.transpose`, if such<EOL> * permutation is neccesary. Otherwise it returns null. This method is used by<EOL> * operations that operate only on inner-most axes.<EOL> */<EOL>export function getAxesPermutation(axes: number[], rank: number): number[] | null {<EOL>    if (axesAreInnerMostDims(axes, rank)) {<EOL>        return null;<EOL>    }<EOL>    const result:","gt":"number[] = [];"}
{"input":"<s> function getKeyFromTextureShape(shapeRowsCol: [<EOL>    number,<EOL>    number<EOL>], texType: TextureType): string {<EOL>    return","gt":"texType}`<STR_LIT>;"}
{"input":"<s> export function propertyDescriptorPatch(_global) {<EOL>    if (isNode) {<EOL>        return;<EOL>    }<EOL>    const supportsWebSocket = typeof WebSocket !== '<STR_LIT>';<EOL>    if (canPatchViaPropertyDescriptor()) {<EOL>        <EOL>        if (isBrowser) {<EOL>            patchOnProperties(HTMLElement.prototype, eventNames);<EOL>        }<EOL>        patchOnProperties(XMLHttpRequest.prototype,","gt":"null);"}
{"input":"<s> export function propertyDescriptorPatch(_global) {<EOL>    if (isNode) {<EOL>        return;<EOL>    }<EOL>    const supportsWebSocket = typeof WebSocket !== '<STR_LIT>';<EOL>    if (canPatchViaPropertyDescriptor()) {<EOL>        <EOL>        if (isBrowser) {<EOL>            patchOnProperties(HTMLElement.prototype, eventNames);<EOL>        }<EOL>        patchOnProperties(XMLHttpRequest.prototype, null);<EOL>        if (typeof IDBIndex !== '<STR_LIT>') {<EOL>            patchOnProperties(IDBIndex.prototype, null);<EOL>","gt":"patchOnProperties(IDBRequest.prototype, null);"}
{"input":"<s> export function propertyDescriptorPatch(_global) {<EOL>    if (isNode) {<EOL>        return;<EOL>    }<EOL>    const supportsWebSocket = typeof WebSocket !== '<STR_LIT>';<EOL>    if (canPatchViaPropertyDescriptor()) {<EOL>        <EOL>        if (isBrowser) {<EOL>            patchOnProperties(HTMLElement.prototype, eventNames);<EOL>        }<EOL>        patchOnProperties(XMLHttpRequest.prototype, null);<EOL>        if (typeof IDBIndex !== '<STR_LIT>') {<EOL>            patchOnProperties(IDBIndex.prototype, null);<EOL>            patchOnProperties(IDBRequest.prototype, null);<EOL>            patchOnProperties(IDBOpenDBRequest.prototype, null);<EOL>            patchOnProperties(IDBDatabase.prototype, null);<EOL>            patchOnProperties(IDBTransaction.prototype, null);<EOL>","gt":"patchOnProperties(IDBCursor.prototype, null);"}
{"input":"<s> export function propertyDescriptorPatch(_global) {<EOL>    if (isNode) {<EOL>        return;<EOL>    }<EOL>    const supportsWebSocket = typeof WebSocket !== '<STR_LIT>';<EOL>    if (canPatchViaPropertyDescriptor()) {<EOL>        <EOL>        if (isBrowser) {<EOL>            patchOnProperties(HTMLElement.prototype, eventNames);<EOL>        }<EOL>        patchOnProperties(XMLHttpRequest.prototype, null);<EOL>        if (typeof IDBIndex !== '<STR_LIT>') {<EOL>            patchOnProperties(IDBIndex.prototype, null);<EOL>            patchOnProperties(IDBRequest.prototype, null);<EOL>            patchOnProperties(IDBOpenDBRequest.prototype, null);<EOL>            patchOnProperties(IDBDatabase.prototype, null);<EOL>            patchOnProperties(IDBTransaction.prototype, null);<EOL>            patchOnProperties(IDBCursor.prototype, null);<EOL>        }<EOL>        if (supportsWebSocket) {<EOL>            patchOnProperties(WebSocket.prototype, null);<EOL>        }<EOL>    }<EOL>","gt":"else {"}
{"input":"<s> <EOL>/**<EOL> * Combines multiple Observables to create an Observable whose values are<EOL> * calculated from the latest values of each of its input Observables.<EOL> *<EOL> * <span class=\"informal\">Whenever any input Observable emits a value, it<EOL> * computes a formula using the latest values from all the inputs, then emits<EOL> * the output of that formula.</span><EOL> *<EOL> * <img src=\"./img/combineLatest.png\" width=\"100%\"><EOL> *<EOL> * `combineLatest` combines the values from all the Observables passed as<EOL> * arguments. This is done by subscribing to each Observable in order and,<EOL> * whenever any Observable emits, collecting an array of the most recent<EOL> * values from each Observable. So if you pass `n` Observables to operator,<EOL> * returned Observable will always emit an array of `n` values, in order<EOL> * corresponding to order of passed Observables (value from the first Observable<EOL> * on the first place and so on).<EOL> *<EOL> * Static version of `combineLatest` accepts either an array of Observables<EOL> * or each Observable can be put directly as an argument. Note that array of<EOL> * Observables is good choice, if you don't know beforehand how many Observables<EOL> * you will combine. Passing empty array will result in Observable that<EOL> * completes immediately.<EOL> *<EOL> * To ensure output array has always the same length, `combineLatest` will<EOL> * actually wait for all input Observables to emit at least once,<EOL> * before it starts emitting results. This means if some Observable emits<EOL> * values before other Observables started emitting, all that values but last<EOL> * will be lost. On the other hand, is some Observable does not emit value but<EOL> * completes, resulting Observable will complete at the same moment without<EOL> * emitting anything, since it will be now impossible to include value from<EOL> * completed Observable in resulting array. Also, if some input Observable does<EOL> * not emit any value and never completes, `combineLatest` will also never emit<EOL> * and never complete, since, again, it will wait for all streams to emit some<EOL> * value.<EOL> *<EOL> * If at least one Observable was passed to `combineLatest` and all passed Observables<EOL> * emitted something, resulting Observable will complete when all combined<EOL> * streams complete. So even if some Observable completes, result of<EOL> * `combineLatest` will still emit values when other Observables do. In case<EOL> * of completed Observable, its value from now on will always be the last<EOL> * emitted value. On the other hand, if any Observable errors, `combineLatest`<EOL> * will error immediately as well, and all other Observables will be unsubscribed.<EOL> *<EOL> * `combineLatest` accepts as optional parameter `project` function, which takes<EOL> * as arguments all values that would normally be emitted by resulting Observable.<EOL> * `project` can return any kind of value, which will be then emitted by Observable<EOL> * instead of default array. Note that `project` does not take as argument that array<EOL> * of values, but values themselves. That means default `project` can be imagined<EOL> * as function that takes all its arguments and puts them into an array.<EOL> *<EOL> *<EOL> * @example <caption>Combine two timer Observables</caption><EOL> * const firstTimer = Rx.Observable.timer(0, 1000); // emit 0, 1, 2... after every second, starting from now<EOL> * const secondTimer = Rx.Observable.timer(500, 1000); // emit 0, 1, 2... after every second, starting 0,5s from now<EOL> * const combinedTimers = Rx.Observable.combineLatest(firstTimer, secondTimer);<EOL> * combinedTimers.subscribe(value => console.log(value));<EOL> * // Logs<EOL> * // [0, 0] after 0.5s<EOL> * // [1, 0] after 1s<EOL> * // [1, 1] after 1.5s<EOL> * // [2, 1] after 2s<EOL> *<EOL> *<EOL> * @example <caption>Combine an array of Observables</caption><EOL> * const observables = [1, 5, 10].map(<EOL> *   n => Rx.Observable.of(n).delay(n * 1000).startWith(0) // emit 0 and then emit n after n seconds<EOL> * );<EOL> * const combined = Rx.Observable.combineLatest(observables);<EOL> * combined.subscribe(value => console.log(value));<EOL> * // Logs<EOL> * // [0, 0, 0] immediately<EOL> * // [1, 0, 0] after 1s<EOL> * // [1, 5, 0] after 5s<EOL> * // [1, 5, 10] after 10s<EOL> *<EOL> *<EOL> * @example <caption>Use project function to dynamically calculate the Body-Mass Index</caption><EOL> * var weight = Rx.Observable.of(70, 72, 76, 79, 75);<EOL> * var height = Rx.Observable.of(1.76, 1.77, 1.78);<EOL> * var bmi = Rx.Observable.combineLatest(weight, height, (w, h) => w / (h * h));<EOL> * bmi.subscribe(x => console.log('BMI is ' + x));<EOL> *<EOL> * // With output to console:<EOL> * // BMI is 24.212293388429753<EOL> * // BMI is 23.93948099205209<EOL> * // BMI is 23.671253629592222<EOL> *<EOL> *<EOL> * @see {@link combineAll}<EOL> * @see {@link merge}<EOL> * @see {@link withLatestFrom}<EOL> *<EOL> * @param {ObservableInput} observable1 An input Observable to combine with other Observables.<EOL> * @param {ObservableInput} observable2 An input Observable to combine with other Observables.<EOL> * More than one input Observables may be given as arguments<EOL> * or an array of Observables may be given as the first argument.<EOL> * @param {function} [project] An optional function to project the values from<EOL> * the combined latest values into a new value on the output Observable.<EOL> * @param {Scheduler} [scheduler=null] The IScheduler to use for subscribing to<EOL> * each input Observable.<EOL> * @return {Observable} An Observable of projected values from the most recent<EOL> * values from each input Observable, or an array of the most recent values from<EOL> * each input Observable.<EOL> * @static true<EOL> * @name combineLatest<EOL> * @owner Observable<EOL> */<EOL>export function combineLatest<T, R>(...observables: Array<any | ObservableInput<any> | Array<ObservableInput<any>> | (((...values: Array<any>) => R)) | IScheduler>): Observable<R> {<EOL>    let project: (...values: Array<any>) => R = null;<EOL>    let scheduler: IScheduler = null;<EOL>    if (isScheduler(observables[observables.length - <NUM_LIT>])) {<EOL>        scheduler = <IScheduler>observables.pop();<EOL>    }<EOL>    if (typeof observables[observables.length - <NUM_LIT>] === '<STR_LIT>') {<EOL>        project = <(...values: Array<any>) => R>observables.pop();<EOL>    }<EOL>    <EOL>    <EOL>    if (observables.","gt":"length === <NUM_LIT> && isArray(observables[<NUM_LIT>])) {"}
{"input":"<s> export default function (watcher: Watcher, db: DB) {<EOL>    watcher.on(actions.boot, async (store, action) => {<EOL>        await doSetup(","gt":"store, db);"}
{"input":"<s> async function extract(opts: ITarGzOpts) {<EOL>    const { archivePath, destPath } = opts;<EOL>    const untar =","gt":"tar.Extract(destPath);"}
{"input":"<s> export function isPromise<T>(value: any | Promise<T>): value is Promise<T> {<EOL>    return value && typeof (<any>value).","gt":"subscribe !== '<STR_LIT>' && typeof (value as any).then === '<STR_LIT>';"}
{"input":"<s> export function bindTextureToProgramUniformSampler(gl: WebGLRenderingContext, program: WebGLProgram, texture: WebGLTexture, uniformSamplerLocation: WebGLUniformLocation, textureUnit: number) {<EOL>    callAndCheck(gl, () => bindTextureUnit(gl, texture,","gt":"textureUnit));"}
{"input":"<s> export function validateFramebuffer(gl: WebGLRenderingContext) {<EOL>    const status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);<EOL>    if (status !==","gt":"gl.FRAMEBUFFER_COMPLETE) {"}
{"input":"<s> export function getTextureShapeFromLogicalShape(gl: WebGLRenderingContext, logShape: number[]): [<EOL>    number,<EOL>    number<EOL>] {<EOL>    <EOL>    if (logShape.length !== <NUM_LIT>) {<EOL>        const squeezeResult = util.squeezeShape(logShape);<EOL>        logShape = squeezeResult.newShape;<EOL>    }<EOL>    const maxTexSize =","gt":"queryMaxTextureSize(gl);"}
{"input":"<s> export function getTextureShapeFromLogicalShape(gl: WebGLRenderingContext, logShape: number[]): [<EOL>    number,<EOL>    number<EOL>] {<EOL>    <EOL>    if (logShape.length !== <NUM_LIT>) {<EOL>        const squeezeResult = util.squeezeShape(logShape);<EOL>        logShape = squeezeResult.newShape;<EOL>    }<EOL>    const maxTexSize = queryMaxTextureSize(gl);<EOL>    const size = util.sizeFromShape(logShape);<EOL>    if (logShape.length <= <NUM_LIT> && size <= maxTexSize) {<EOL>        return [size,","gt":"<NUM_LIT>];"}
{"input":"<s> export function getTextureShapeFromLogicalShape(gl: WebGLRenderingContext, logShape: number[]): [<EOL>    number,<EOL>    number<EOL>] {<EOL>    <EOL>    if (logShape.length !== <NUM_LIT>) {<EOL>        const squeezeResult = util.squeezeShape(logShape);<EOL>        logShape = squeezeResult.newShape;<EOL>    }<EOL>    const maxTexSize = queryMaxTextureSize(gl);<EOL>    const size = util.sizeFromShape(logShape);<EOL>    if (logShape.length <= <NUM_LIT> && size <= maxTexSize) {<EOL>        return [size, <NUM_LIT>];<EOL>    }<EOL>    else if (logShape.length === <NUM_LIT> && logShape[<NUM_LIT>] <= maxTexSize &&<EOL>        logShape[","gt":"<NUM_LIT>] <= maxTexSize) {"}
{"input":"<s> export function getTextureShapeFromLogicalShape(gl: WebGLRenderingContext, logShape: number[]): [<EOL>    number,<EOL>    number<EOL>] {<EOL>    <EOL>    if (logShape.length !== <NUM_LIT>) {<EOL>        const squeezeResult = util.squeezeShape(logShape);<EOL>        logShape = squeezeResult.newShape;<EOL>    }<EOL>    const maxTexSize = queryMaxTextureSize(gl);<EOL>    const size = util.sizeFromShape(logShape);<EOL>    if (logShape.length <= <NUM_LIT> && size <= maxTexSize) {<EOL>        return [size, <NUM_LIT>];<EOL>    }<EOL>    else if (logShape.length === <NUM_LIT> && logShape[<NUM_LIT>] <= maxTexSize &&<EOL>        logShape[<NUM_LIT>] <= maxTexSize) {<EOL>        return logShape as [<EOL>            number,<EOL>            number<EOL>        ];<EOL>    }<EOL>    else if (logShape.length === <NUM_LIT> && logShape[<NUM_LIT>] <= maxTexSize &&<EOL>        logShape[<NUM_LIT>] * logShape[<NUM_LIT>] <= maxTexSize) {<EOL>        return [logShape[<NUM_LIT>], logShape[<NUM_LIT>] * logShape[<NUM_LIT>]];<EOL>    }<EOL>","gt":"else if (logShape.length === <NUM_LIT> && logShape[<NUM_LIT>] <= maxTexSize &&"}
{"input":"<s> export function createPackedMatrixTexture(gl: WebGLRenderingContext, rows: number, columns: number): WebGLTexture {<EOL>    const [width, height] = tex_util.","gt":"getPackedMatrixTextureShapeWidthHeight(rows, columns);"}
{"input":"<s> export function getTokenPath(userId: string) {<EOL>    return ospath.join(usersPath(),","gt":"userId, TOKEN_FILE_NAME);"}
{"input":"<s> export function isString(obj: any): obj is string {<EOL>    return typeof","gt":"obj === \"<STR_LIT>\";"}
{"input":"<s> function buildComments<T>(typeInformation: T, soFar: ObjC.Comment[], plugin: ObjCGenerationPlugIn<T>): ObjC.Comment[] {<EOL>    return soFar.concat(plugin.comments(","gt":"typeInformation));"}
{"input":"<s> function writeAndLogSequence(parsedArgs: CommandLine.Arguments, evaluatedSequence: LazySequence.Sequence<Promise.Future<Logging.Context<Either.Either<Error.Error[], ObjectGenerationSuccess>>>>): Promise.Future<ConsoleOutputResults> {<EOL>    const outputResults: Promise.Future<Promise.Future<Logging.Context<ConsoleOutputResults>>> = LazySequence.foldl(trackConsoleOutput, Promise.resolved(Logging.munit<ConsoleOutputResults>({ errorCount: <NUM_LIT>, successCount: <NUM_LIT> })).getFuture(), evaluatedSequence);<EOL>    const resultingLoggingContext: Promise.Future<ConsoleOutputResults> = Promise.mbind(function (future: Promise.Future<Logging.Context<ConsoleOutputResults>>) {<EOL>        return Promise.map(function (","gt":"lcResults: Logging.Context<ConsoleOutputResults>) {"}
{"input":"<s> /**<EOL> * setup watchers for children component/directives provided by @Query decorators<EOL> * - setup @ContentChild/@ContentChildren/@ViewChild/@ViewChildren<EOL> * @param scope<EOL> * @param element<EOL> * @param ctrl<EOL> * @param queries<EOL> * @private<EOL> */<EOL>export function _setupQuery(scope: ng.IScope, element: ng.IAugmentedJQuery, ctrl: DirectiveCtrl, queries: {<EOL>    [key: string]: QueryMetadata | ViewQueryMetadata;<EOL>}) {<EOL>    const SEMAPHORE_PROP_NAMES = Object.freeze({<EOL>        view: '<STR_LIT>',<EOL>        content: '<STR_LIT>'<EOL>    });<EOL>    const DOM_RESOLVER_TYPES = Object.freeze({<EOL>        view: '<STR_LIT>',<EOL>","gt":"content: '<STR_LIT>'"}
{"input":"<s> /**<EOL> * setup watchers for children component/directives provided by @Query decorators<EOL> * - setup @ContentChild/@ContentChildren/@ViewChild/@ViewChildren<EOL> * @param scope<EOL> * @param element<EOL> * @param ctrl<EOL> * @param queries<EOL> * @private<EOL> */<EOL>export function _setupQuery(scope: ng.IScope, element: ng.IAugmentedJQuery, ctrl: DirectiveCtrl, queries: {<EOL>    [key: string]: QueryMetadata | ViewQueryMetadata;<EOL>}) {<EOL>    const SEMAPHORE_PROP_NAMES = Object.freeze({<EOL>        view: '<STR_LIT>',<EOL>        content: '<STR_LIT>'<EOL>    });<EOL>    const DOM_RESOLVER_TYPES = Object.freeze({<EOL>        view: '<STR_LIT>',<EOL>        content: '<STR_LIT>'<EOL>    });<EOL>    if (StringMapWrapper.size(queries) === <NUM_LIT>) {<EOL>        return;<EOL>    }<EOL>    const onChildrenChangedCb = _getOnChildrenResolvers(element, ctrl, queries);<EOL>    ctrl.__readContentChildrenOrderScheduled = false;<EOL>    ctrl.__readViewChildrenOrderScheduled = false;<EOL>    <EOL>    const _ngOnChildrenChanged = function (type: ChildrenChangeHook, onFirstChangeDoneCb:","gt":"Function[] = [], domResolverCb = onChildrenChangedCb) {"}
{"input":"<s> /**<EOL> * setup watchers for children component/directives provided by @Query decorators<EOL> * - setup @ContentChild/@ContentChildren/@ViewChild/@ViewChildren<EOL> * @param scope<EOL> * @param element<EOL> * @param ctrl<EOL> * @param queries<EOL> * @private<EOL> */<EOL>export function _setupQuery(scope: ng.IScope, element: ng.IAugmentedJQuery, ctrl: DirectiveCtrl, queries: {<EOL>    [key: string]: QueryMetadata | ViewQueryMetadata;<EOL>}) {<EOL>    const SEMAPHORE_PROP_NAMES = Object.freeze({<EOL>        view: '<STR_LIT>',<EOL>        content: '<STR_LIT>'<EOL>    });<EOL>    const DOM_RESOLVER_TYPES = Object.freeze({<EOL>        view: '<STR_LIT>',<EOL>        content: '<STR_LIT>'<EOL>    });<EOL>    if (StringMapWrapper.size(queries) === <NUM_LIT>) {<EOL>        return;<EOL>    }<EOL>    const onChildrenChangedCb = _getOnChildrenResolvers(element, ctrl, queries);<EOL>    ctrl.__readContentChildrenOrderScheduled = false;<EOL>    ctrl.__readViewChildrenOrderScheduled = false;<EOL>    <EOL>    const _ngOnChildrenChanged = function (type: ChildrenChangeHook, onFirstChangeDoneCb: Function[] = [], domResolverCb = onChildrenChangedCb) {<EOL>        let orderScheduledSemaphorePropName =","gt":"'<STR_LIT>';"}
{"input":"<s> /**<EOL> * setup watchers for children component/directives provided by @Query decorators<EOL> * - setup @ContentChild/@ContentChildren/@ViewChild/@ViewChildren<EOL> * @param scope<EOL> * @param element<EOL> * @param ctrl<EOL> * @param queries<EOL> * @private<EOL> */<EOL>export function _setupQuery(scope: ng.IScope, element: ng.IAugmentedJQuery, ctrl: DirectiveCtrl, queries: {<EOL>    [key: string]: QueryMetadata | ViewQueryMetadata;<EOL>}) {<EOL>    const SEMAPHORE_PROP_NAMES = Object.freeze({<EOL>        view: '<STR_LIT>',<EOL>        content: '<STR_LIT>'<EOL>    });<EOL>    const DOM_RESOLVER_TYPES = Object.freeze({<EOL>        view: '<STR_LIT>',<EOL>        content: '<STR_LIT>'<EOL>    });<EOL>    if (StringMapWrapper.size(queries) === <NUM_LIT>) {<EOL>        return;<EOL>    }<EOL>    const onChildrenChangedCb = _getOnChildrenResolvers(element, ctrl, queries);<EOL>    ctrl.__readContentChildrenOrderScheduled = false;<EOL>    ctrl.__readViewChildrenOrderScheduled = false;<EOL>    <EOL>    const _ngOnChildrenChanged = function (type: ChildrenChangeHook, onFirstChangeDoneCb: Function[] = [], domResolverCb = onChildrenChangedCb) {<EOL>        let orderScheduledSemaphorePropName = '<STR_LIT>';<EOL>        let domResolverCbType = '<STR_LIT>';<EOL>        if (type === ChildrenChangeHook.FromView) {<EOL>            orderScheduledSemaphorePropName = SEMAPHORE_PROP_NAMES.view;<EOL>            domResolverCbType = DOM_RESOLVER_TYPES.view;<EOL>        }<EOL>        else if (type === ChildrenChangeHook.FromContent) {<EOL>            domResolverCbType = DOM_RESOLVER_TYPES.content;<EOL>            orderScheduledSemaphorePropName = SEMAPHORE_PROP_NAMES.","gt":"content;"}
{"input":"<s> /**<EOL> * setup watchers for children component/directives provided by @Query decorators<EOL> * - setup @ContentChild/@ContentChildren/@ViewChild/@ViewChildren<EOL> * @param scope<EOL> * @param element<EOL> * @param ctrl<EOL> * @param queries<EOL> * @private<EOL> */<EOL>export function _setupQuery(scope: ng.IScope, element: ng.IAugmentedJQuery, ctrl: DirectiveCtrl, queries: {<EOL>    [key: string]: QueryMetadata | ViewQueryMetadata;<EOL>}) {<EOL>    const SEMAPHORE_PROP_NAMES = Object.freeze({<EOL>        view: '<STR_LIT>',<EOL>        content: '<STR_LIT>'<EOL>    });<EOL>    const DOM_RESOLVER_TYPES = Object.freeze({<EOL>        view: '<STR_LIT>',<EOL>        content: '<STR_LIT>'<EOL>    });<EOL>    if (StringMapWrapper.size(queries) === <NUM_LIT>) {<EOL>        return;<EOL>    }<EOL>    const onChildrenChangedCb = _getOnChildrenResolvers(element, ctrl, queries);<EOL>    ctrl.__readContentChildrenOrderScheduled = false;<EOL>    ctrl.__readViewChildrenOrderScheduled = false;<EOL>    <EOL>    const _ngOnChildrenChanged = function (type: ChildrenChangeHook, onFirstChangeDoneCb: Function[] = [], domResolverCb = onChildrenChangedCb) {<EOL>        let orderScheduledSemaphorePropName = '<STR_LIT>';<EOL>        let domResolverCbType = '<STR_LIT>';<EOL>        if (type === ChildrenChangeHook.FromView) {<EOL>            orderScheduledSemaphorePropName = SEMAPHORE_PROP_NAMES.view;<EOL>            domResolverCbType = DOM_RESOLVER_TYPES.view;<EOL>        }<EOL>        else if (type === ChildrenChangeHook.FromContent) {<EOL>            domResolverCbType = DOM_RESOLVER_TYPES.content;<EOL>            orderScheduledSemaphorePropName = SEMAPHORE_PROP_NAMES.content;<EOL>        }<EOL>        else {<EOL>            throw new Error(`<STR_LIT>`);<EOL>        }<EOL>        if (ctrl[orderScheduledSemaphorePropName]) {<EOL>            return;<EOL>        }<EOL>        ctrl[orderScheduledSemaphorePropName] = true;<EOL>        <EOL>        <EOL>        scope.$evalAsync(() => {<EOL>            <EOL>            ctrl[orderScheduledSemaphorePropName] = false;<EOL>            <EOL>            domResolverCb[domResolverCbType].forEach(cb => cb());<EOL>            <EOL>            <EOL>            onFirstChangeDoneCb.forEach((cb) => { isFunction(cb) && cb(); });<EOL>        });<EOL>    };<EOL>    <EOL>    <EOL>    ctrl._ngOnChildrenChanged = _ngOnChildrenChanged.bind(ctrl);<EOL>    /**<EOL>     * get all callbacks which will be executed withing $scope.$evalAsync,<EOL>     * which are querying for DOM elements and gets controller instances from host element children<EOL>     * @param element<EOL>     * @param ctrl<EOL>     * @param queries<EOL>     * @returns {view: Function[], content: Function[]}<EOL>     * @private<EOL>     */<EOL>","gt":"function _getOnChildrenResolvers(element: ng.IAugmentedJQuery, ctrl: any, queries: {"}
{"input":"<s> /**<EOL> * setup watchers for children component/directives provided by @Query decorators<EOL> * - setup @ContentChild/@ContentChildren/@ViewChild/@ViewChildren<EOL> * @param scope<EOL> * @param element<EOL> * @param ctrl<EOL> * @param queries<EOL> * @private<EOL> */<EOL>export function _setupQuery(scope: ng.IScope, element: ng.IAugmentedJQuery, ctrl: DirectiveCtrl, queries: {<EOL>    [key: string]: QueryMetadata | ViewQueryMetadata;<EOL>}) {<EOL>    const SEMAPHORE_PROP_NAMES = Object.freeze({<EOL>        view: '<STR_LIT>',<EOL>        content: '<STR_LIT>'<EOL>    });<EOL>    const DOM_RESOLVER_TYPES = Object.freeze({<EOL>        view: '<STR_LIT>',<EOL>        content: '<STR_LIT>'<EOL>    });<EOL>    if (StringMapWrapper.size(queries) === <NUM_LIT>) {<EOL>        return;<EOL>    }<EOL>    const onChildrenChangedCb = _getOnChildrenResolvers(element, ctrl, queries);<EOL>    ctrl.__readContentChildrenOrderScheduled = false;<EOL>    ctrl.__readViewChildrenOrderScheduled = false;<EOL>    <EOL>    const _ngOnChildrenChanged = function (type: ChildrenChangeHook, onFirstChangeDoneCb: Function[] = [], domResolverCb = onChildrenChangedCb) {<EOL>        let orderScheduledSemaphorePropName = '<STR_LIT>';<EOL>        let domResolverCbType = '<STR_LIT>';<EOL>        if (type === ChildrenChangeHook.FromView) {<EOL>            orderScheduledSemaphorePropName = SEMAPHORE_PROP_NAMES.view;<EOL>            domResolverCbType = DOM_RESOLVER_TYPES.view;<EOL>        }<EOL>        else if (type === ChildrenChangeHook.FromContent) {<EOL>            domResolverCbType = DOM_RESOLVER_TYPES.content;<EOL>            orderScheduledSemaphorePropName = SEMAPHORE_PROP_NAMES.content;<EOL>        }<EOL>        else {<EOL>            throw new Error(`<STR_LIT>`);<EOL>        }<EOL>        if (ctrl[orderScheduledSemaphorePropName]) {<EOL>            return;<EOL>        }<EOL>        ctrl[orderScheduledSemaphorePropName] = true;<EOL>        <EOL>        <EOL>        scope.$evalAsync(() => {<EOL>            <EOL>            ctrl[orderScheduledSemaphorePropName] = false;<EOL>            <EOL>            domResolverCb[domResolverCbType].forEach(cb => cb());<EOL>            <EOL>            <EOL>            onFirstChangeDoneCb.forEach((cb) => { isFunction(cb) && cb(); });<EOL>        });<EOL>    };<EOL>    <EOL>    <EOL>    ctrl._ngOnChildrenChanged = _ngOnChildrenChanged.bind(ctrl);<EOL>    /**<EOL>     * get all callbacks which will be executed withing $scope.$evalAsync,<EOL>     * which are querying for DOM elements and gets controller instances from host element children<EOL>     * @param element<EOL>     * @param ctrl<EOL>     * @param queries<EOL>     * @returns {view: Function[], content: Function[]}<EOL>     * @private<EOL>     */<EOL>    function _getOnChildrenResolvers(element: ng.IAugmentedJQuery, ctrl: any, queries: {<EOL>        [key: string]: QueryMetadata | ViewQueryMetadata;<EOL>    }) {<EOL>        const","gt":"_onChildrenChangedCbMap = {"}
{"input":"<s> /**<EOL> * setup watchers for children component/directives provided by @Query decorators<EOL> * - setup @ContentChild/@ContentChildren/@ViewChild/@ViewChildren<EOL> * @param scope<EOL> * @param element<EOL> * @param ctrl<EOL> * @param queries<EOL> * @private<EOL> */<EOL>export function _setupQuery(scope: ng.IScope, element: ng.IAugmentedJQuery, ctrl: DirectiveCtrl, queries: {<EOL>    [key: string]: QueryMetadata | ViewQueryMetadata;<EOL>}) {<EOL>    const SEMAPHORE_PROP_NAMES = Object.freeze({<EOL>        view: '<STR_LIT>',<EOL>        content: '<STR_LIT>'<EOL>    });<EOL>    const DOM_RESOLVER_TYPES = Object.freeze({<EOL>        view: '<STR_LIT>',<EOL>        content: '<STR_LIT>'<EOL>    });<EOL>    if (StringMapWrapper.size(queries) === <NUM_LIT>) {<EOL>        return;<EOL>    }<EOL>    const onChildrenChangedCb = _getOnChildrenResolvers(element, ctrl, queries);<EOL>    ctrl.__readContentChildrenOrderScheduled = false;<EOL>    ctrl.__readViewChildrenOrderScheduled = false;<EOL>    <EOL>    const _ngOnChildrenChanged = function (type: ChildrenChangeHook, onFirstChangeDoneCb: Function[] = [], domResolverCb = onChildrenChangedCb) {<EOL>        let orderScheduledSemaphorePropName = '<STR_LIT>';<EOL>        let domResolverCbType = '<STR_LIT>';<EOL>        if (type === ChildrenChangeHook.FromView) {<EOL>            orderScheduledSemaphorePropName = SEMAPHORE_PROP_NAMES.view;<EOL>            domResolverCbType = DOM_RESOLVER_TYPES.view;<EOL>        }<EOL>        else if (type === ChildrenChangeHook.FromContent) {<EOL>            domResolverCbType = DOM_RESOLVER_TYPES.content;<EOL>            orderScheduledSemaphorePropName = SEMAPHORE_PROP_NAMES.content;<EOL>        }<EOL>        else {<EOL>            throw new Error(`<STR_LIT>`);<EOL>        }<EOL>        if (ctrl[orderScheduledSemaphorePropName]) {<EOL>            return;<EOL>        }<EOL>        ctrl[orderScheduledSemaphorePropName] = true;<EOL>        <EOL>        <EOL>        scope.$evalAsync(() => {<EOL>            <EOL>            ctrl[orderScheduledSemaphorePropName] = false;<EOL>            <EOL>            domResolverCb[domResolverCbType].forEach(cb => cb());<EOL>            <EOL>            <EOL>            onFirstChangeDoneCb.forEach((cb) => { isFunction(cb) && cb(); });<EOL>        });<EOL>    };<EOL>    <EOL>    <EOL>    ctrl._ngOnChildrenChanged = _ngOnChildrenChanged.bind(ctrl);<EOL>    /**<EOL>     * get all callbacks which will be executed withing $scope.$evalAsync,<EOL>     * which are querying for DOM elements and gets controller instances from host element children<EOL>     * @param element<EOL>     * @param ctrl<EOL>     * @param queries<EOL>     * @returns {view: Function[], content: Function[]}<EOL>     * @private<EOL>     */<EOL>    function _getOnChildrenResolvers(element: ng.IAugmentedJQuery, ctrl: any, queries: {<EOL>        [key: string]: QueryMetadata | ViewQueryMetadata;<EOL>    }) {<EOL>        const _onChildrenChangedCbMap = {<EOL>            [DOM_RESOLVER_TYPES.view]: [],<EOL>            [DOM_RESOLVER_TYPES.content]: []<EOL>        };<EOL>        StringMapWrapper.forEach(queries, function (meta: QueryMetadata | ViewQueryMetadata, key: string) {<EOL>            if (meta instanceof ViewChildMetadata) {<EOL>                _onChildrenChangedCbMap[DOM_RESOLVER_TYPES.view].push(_resolveViewChild(element, ctrl, key, meta));<EOL>            }<EOL>            if (meta instanceof ViewChildrenMetadata) {<EOL>                _onChildrenChangedCbMap[DOM_RESOLVER_TYPES.view].push(_resolveViewChildren(element, ctrl, key, meta));<EOL>            }<EOL>            if (","gt":"meta instanceof ContentChildMetadata) {"}
{"input":"<s> /**<EOL> * setup watchers for children component/directives provided by @Query decorators<EOL> * - setup @ContentChild/@ContentChildren/@ViewChild/@ViewChildren<EOL> * @param scope<EOL> * @param element<EOL> * @param ctrl<EOL> * @param queries<EOL> * @private<EOL> */<EOL>export function _setupQuery(scope: ng.IScope, element: ng.IAugmentedJQuery, ctrl: DirectiveCtrl, queries: {<EOL>    [key: string]: QueryMetadata | ViewQueryMetadata;<EOL>}) {<EOL>    const SEMAPHORE_PROP_NAMES = Object.freeze({<EOL>        view: '<STR_LIT>',<EOL>        content: '<STR_LIT>'<EOL>    });<EOL>    const DOM_RESOLVER_TYPES = Object.freeze({<EOL>        view: '<STR_LIT>',<EOL>        content: '<STR_LIT>'<EOL>    });<EOL>    if (StringMapWrapper.size(queries) === <NUM_LIT>) {<EOL>        return;<EOL>    }<EOL>    const onChildrenChangedCb = _getOnChildrenResolvers(element, ctrl, queries);<EOL>    ctrl.__readContentChildrenOrderScheduled = false;<EOL>    ctrl.__readViewChildrenOrderScheduled = false;<EOL>    <EOL>    const _ngOnChildrenChanged = function (type: ChildrenChangeHook, onFirstChangeDoneCb: Function[] = [], domResolverCb = onChildrenChangedCb) {<EOL>        let orderScheduledSemaphorePropName = '<STR_LIT>';<EOL>        let domResolverCbType = '<STR_LIT>';<EOL>        if (type === ChildrenChangeHook.FromView) {<EOL>            orderScheduledSemaphorePropName = SEMAPHORE_PROP_NAMES.view;<EOL>            domResolverCbType = DOM_RESOLVER_TYPES.view;<EOL>        }<EOL>        else if (type === ChildrenChangeHook.FromContent) {<EOL>            domResolverCbType = DOM_RESOLVER_TYPES.content;<EOL>            orderScheduledSemaphorePropName = SEMAPHORE_PROP_NAMES.content;<EOL>        }<EOL>        else {<EOL>            throw new Error(`<STR_LIT>`);<EOL>        }<EOL>        if (ctrl[orderScheduledSemaphorePropName]) {<EOL>            return;<EOL>        }<EOL>        ctrl[orderScheduledSemaphorePropName] = true;<EOL>        <EOL>        <EOL>        scope.$evalAsync(() => {<EOL>            <EOL>            ctrl[orderScheduledSemaphorePropName] = false;<EOL>            <EOL>            domResolverCb[domResolverCbType].forEach(cb => cb());<EOL>            <EOL>            <EOL>            onFirstChangeDoneCb.forEach((cb) => { isFunction(cb) && cb(); });<EOL>        });<EOL>    };<EOL>    <EOL>    <EOL>    ctrl._ngOnChildrenChanged = _ngOnChildrenChanged.bind(ctrl);<EOL>    /**<EOL>     * get all callbacks which will be executed withing $scope.$evalAsync,<EOL>     * which are querying for DOM elements and gets controller instances from host element children<EOL>     * @param element<EOL>     * @param ctrl<EOL>     * @param queries<EOL>     * @returns {view: Function[], content: Function[]}<EOL>     * @private<EOL>     */<EOL>    function _getOnChildrenResolvers(element: ng.IAugmentedJQuery, ctrl: any, queries: {<EOL>        [key: string]: QueryMetadata | ViewQueryMetadata;<EOL>    }) {<EOL>        const _onChildrenChangedCbMap = {<EOL>            [DOM_RESOLVER_TYPES.view]: [],<EOL>            [DOM_RESOLVER_TYPES.content]: []<EOL>        };<EOL>        StringMapWrapper.forEach(queries, function (meta: QueryMetadata | ViewQueryMetadata, key: string) {<EOL>            if (meta instanceof ViewChildMetadata) {<EOL>                _onChildrenChangedCbMap[DOM_RESOLVER_TYPES.view].push(_resolveViewChild(element, ctrl, key, meta));<EOL>            }<EOL>            if (meta instanceof ViewChildrenMetadata) {<EOL>                _onChildrenChangedCbMap[DOM_RESOLVER_TYPES.view].push(_resolveViewChildren(element, ctrl, key, meta));<EOL>            }<EOL>            if (meta instanceof ContentChildMetadata) {<EOL>                _onChildrenChangedCbMap[DOM_RESOLVER_TYPES.content].push(_resolveContentChild(element, ctrl, key, meta));<EOL>            }<EOL>            if (meta instanceof ContentChildrenMetadata) {<EOL>                _onChildrenChangedCbMap[DOM_RESOLVER_TYPES.content].push(","gt":"_resolveContentChildren(element, ctrl, key, meta));"}
{"input":"<s> /**<EOL> * setup watchers for children component/directives provided by @Query decorators<EOL> * - setup @ContentChild/@ContentChildren/@ViewChild/@ViewChildren<EOL> * @param scope<EOL> * @param element<EOL> * @param ctrl<EOL> * @param queries<EOL> * @private<EOL> */<EOL>export function _setupQuery(scope: ng.IScope, element: ng.IAugmentedJQuery, ctrl: DirectiveCtrl, queries: {<EOL>    [key: string]: QueryMetadata | ViewQueryMetadata;<EOL>}) {<EOL>    const SEMAPHORE_PROP_NAMES = Object.freeze({<EOL>        view: '<STR_LIT>',<EOL>        content: '<STR_LIT>'<EOL>    });<EOL>    const DOM_RESOLVER_TYPES = Object.freeze({<EOL>        view: '<STR_LIT>',<EOL>        content: '<STR_LIT>'<EOL>    });<EOL>    if (StringMapWrapper.size(queries) === <NUM_LIT>) {<EOL>        return;<EOL>    }<EOL>    const onChildrenChangedCb = _getOnChildrenResolvers(element, ctrl, queries);<EOL>    ctrl.__readContentChildrenOrderScheduled = false;<EOL>    ctrl.__readViewChildrenOrderScheduled = false;<EOL>    <EOL>    const _ngOnChildrenChanged = function (type: ChildrenChangeHook, onFirstChangeDoneCb: Function[] = [], domResolverCb = onChildrenChangedCb) {<EOL>        let orderScheduledSemaphorePropName = '<STR_LIT>';<EOL>        let domResolverCbType = '<STR_LIT>';<EOL>        if (type === ChildrenChangeHook.FromView) {<EOL>            orderScheduledSemaphorePropName = SEMAPHORE_PROP_NAMES.view;<EOL>            domResolverCbType = DOM_RESOLVER_TYPES.view;<EOL>        }<EOL>        else if (type === ChildrenChangeHook.FromContent) {<EOL>            domResolverCbType = DOM_RESOLVER_TYPES.content;<EOL>            orderScheduledSemaphorePropName = SEMAPHORE_PROP_NAMES.content;<EOL>        }<EOL>        else {<EOL>            throw new Error(`<STR_LIT>`);<EOL>        }<EOL>        if (ctrl[orderScheduledSemaphorePropName]) {<EOL>            return;<EOL>        }<EOL>        ctrl[orderScheduledSemaphorePropName] = true;<EOL>        <EOL>        <EOL>        scope.$evalAsync(() => {<EOL>            <EOL>            ctrl[orderScheduledSemaphorePropName] = false;<EOL>            <EOL>            domResolverCb[domResolverCbType].forEach(cb => cb());<EOL>            <EOL>            <EOL>            onFirstChangeDoneCb.forEach((cb) => { isFunction(cb) && cb(); });<EOL>        });<EOL>    };<EOL>    <EOL>    <EOL>    ctrl._ngOnChildrenChanged = _ngOnChildrenChanged.bind(ctrl);<EOL>    /**<EOL>     * get all callbacks which will be executed withing $scope.$evalAsync,<EOL>     * which are querying for DOM elements and gets controller instances from host element children<EOL>     * @param element<EOL>     * @param ctrl<EOL>     * @param queries<EOL>     * @returns {view: Function[], content: Function[]}<EOL>     * @private<EOL>     */<EOL>    function _getOnChildrenResolvers(element: ng.IAugmentedJQuery, ctrl: any, queries: {<EOL>        [key: string]: QueryMetadata | ViewQueryMetadata;<EOL>    }) {<EOL>        const _onChildrenChangedCbMap = {<EOL>            [DOM_RESOLVER_TYPES.view]: [],<EOL>            [DOM_RESOLVER_TYPES.content]: []<EOL>        };<EOL>        StringMapWrapper.forEach(queries, function (meta: QueryMetadata | ViewQueryMetadata, key: string) {<EOL>            if (meta instanceof ViewChildMetadata) {<EOL>                _onChildrenChangedCbMap[DOM_RESOLVER_TYPES.view].push(_resolveViewChild(element, ctrl, key, meta));<EOL>            }<EOL>            if (meta instanceof ViewChildrenMetadata) {<EOL>                _onChildrenChangedCbMap[DOM_RESOLVER_TYPES.view].push(_resolveViewChildren(element, ctrl, key, meta));<EOL>            }<EOL>            if (meta instanceof ContentChildMetadata) {<EOL>                _onChildrenChangedCbMap[DOM_RESOLVER_TYPES.content].push(_resolveContentChild(element, ctrl, key, meta));<EOL>            }<EOL>            if (meta instanceof ContentChildrenMetadata) {<EOL>                _onChildrenChangedCbMap[DOM_RESOLVER_TYPES.content].push(_resolveContentChildren(element, ctrl, key, meta));<EOL>            }<EOL>        });<EOL>        return _onChildrenChangedCbMap;<EOL>        function _resolveViewChild(element: ng.IAugmentedJQuery, ctrl: any, key: string, meta: QueryMetadata | ViewQueryMetadata) {<EOL>","gt":"return _resolveChildrenFactory(element, ctrl, key, meta.selector, DOM_RESOLVER_TYPES.view,"}
{"input":"<s> /**<EOL> * setup watchers for children component/directives provided by @Query decorators<EOL> * - setup @ContentChild/@ContentChildren/@ViewChild/@ViewChildren<EOL> * @param scope<EOL> * @param element<EOL> * @param ctrl<EOL> * @param queries<EOL> * @private<EOL> */<EOL>export function _setupQuery(scope: ng.IScope, element: ng.IAugmentedJQuery, ctrl: DirectiveCtrl, queries: {<EOL>    [key: string]: QueryMetadata | ViewQueryMetadata;<EOL>}) {<EOL>    const SEMAPHORE_PROP_NAMES = Object.freeze({<EOL>        view: '<STR_LIT>',<EOL>        content: '<STR_LIT>'<EOL>    });<EOL>    const DOM_RESOLVER_TYPES = Object.freeze({<EOL>        view: '<STR_LIT>',<EOL>        content: '<STR_LIT>'<EOL>    });<EOL>    if (StringMapWrapper.size(queries) === <NUM_LIT>) {<EOL>        return;<EOL>    }<EOL>    const onChildrenChangedCb = _getOnChildrenResolvers(element, ctrl, queries);<EOL>    ctrl.__readContentChildrenOrderScheduled = false;<EOL>    ctrl.__readViewChildrenOrderScheduled = false;<EOL>    <EOL>    const _ngOnChildrenChanged = function (type: ChildrenChangeHook, onFirstChangeDoneCb: Function[] = [], domResolverCb = onChildrenChangedCb) {<EOL>        let orderScheduledSemaphorePropName = '<STR_LIT>';<EOL>        let domResolverCbType = '<STR_LIT>';<EOL>        if (type === ChildrenChangeHook.FromView) {<EOL>            orderScheduledSemaphorePropName = SEMAPHORE_PROP_NAMES.view;<EOL>            domResolverCbType = DOM_RESOLVER_TYPES.view;<EOL>        }<EOL>        else if (type === ChildrenChangeHook.FromContent) {<EOL>            domResolverCbType = DOM_RESOLVER_TYPES.content;<EOL>            orderScheduledSemaphorePropName = SEMAPHORE_PROP_NAMES.content;<EOL>        }<EOL>        else {<EOL>            throw new Error(`<STR_LIT>`);<EOL>        }<EOL>        if (ctrl[orderScheduledSemaphorePropName]) {<EOL>            return;<EOL>        }<EOL>        ctrl[orderScheduledSemaphorePropName] = true;<EOL>        <EOL>        <EOL>        scope.$evalAsync(() => {<EOL>            <EOL>            ctrl[orderScheduledSemaphorePropName] = false;<EOL>            <EOL>            domResolverCb[domResolverCbType].forEach(cb => cb());<EOL>            <EOL>            <EOL>            onFirstChangeDoneCb.forEach((cb) => { isFunction(cb) && cb(); });<EOL>        });<EOL>    };<EOL>    <EOL>    <EOL>    ctrl._ngOnChildrenChanged = _ngOnChildrenChanged.bind(ctrl);<EOL>    /**<EOL>     * get all callbacks which will be executed withing $scope.$evalAsync,<EOL>     * which are querying for DOM elements and gets controller instances from host element children<EOL>     * @param element<EOL>     * @param ctrl<EOL>     * @param queries<EOL>     * @returns {view: Function[], content: Function[]}<EOL>     * @private<EOL>     */<EOL>    function _getOnChildrenResolvers(element: ng.IAugmentedJQuery, ctrl: any, queries: {<EOL>        [key: string]: QueryMetadata | ViewQueryMetadata;<EOL>    }) {<EOL>        const _onChildrenChangedCbMap = {<EOL>            [DOM_RESOLVER_TYPES.view]: [],<EOL>            [DOM_RESOLVER_TYPES.content]: []<EOL>        };<EOL>        StringMapWrapper.forEach(queries, function (meta: QueryMetadata | ViewQueryMetadata, key: string) {<EOL>            if (meta instanceof ViewChildMetadata) {<EOL>                _onChildrenChangedCbMap[DOM_RESOLVER_TYPES.view].push(_resolveViewChild(element, ctrl, key, meta));<EOL>            }<EOL>            if (meta instanceof ViewChildrenMetadata) {<EOL>                _onChildrenChangedCbMap[DOM_RESOLVER_TYPES.view].push(_resolveViewChildren(element, ctrl, key, meta));<EOL>            }<EOL>            if (meta instanceof ContentChildMetadata) {<EOL>                _onChildrenChangedCbMap[DOM_RESOLVER_TYPES.content].push(_resolveContentChild(element, ctrl, key, meta));<EOL>            }<EOL>            if (meta instanceof ContentChildrenMetadata) {<EOL>                _onChildrenChangedCbMap[DOM_RESOLVER_TYPES.content].push(_resolveContentChildren(element, ctrl, key, meta));<EOL>            }<EOL>        });<EOL>        return _onChildrenChangedCbMap;<EOL>        function _resolveViewChild(element: ng.IAugmentedJQuery, ctrl: any, key: string, meta: QueryMetadata | ViewQueryMetadata) {<EOL>            return _resolveChildrenFactory(element, ctrl, key, meta.selector, DOM_RESOLVER_TYPES.view,","gt":"true);"}
{"input":"<s> /**<EOL> * setup watchers for children component/directives provided by @Query decorators<EOL> * - setup @ContentChild/@ContentChildren/@ViewChild/@ViewChildren<EOL> * @param scope<EOL> * @param element<EOL> * @param ctrl<EOL> * @param queries<EOL> * @private<EOL> */<EOL>export function _setupQuery(scope: ng.IScope, element: ng.IAugmentedJQuery, ctrl: DirectiveCtrl, queries: {<EOL>    [key: string]: QueryMetadata | ViewQueryMetadata;<EOL>}) {<EOL>    const SEMAPHORE_PROP_NAMES = Object.freeze({<EOL>        view: '<STR_LIT>',<EOL>        content: '<STR_LIT>'<EOL>    });<EOL>    const DOM_RESOLVER_TYPES = Object.freeze({<EOL>        view: '<STR_LIT>',<EOL>        content: '<STR_LIT>'<EOL>    });<EOL>    if (StringMapWrapper.size(queries) === <NUM_LIT>) {<EOL>        return;<EOL>    }<EOL>    const onChildrenChangedCb = _getOnChildrenResolvers(element, ctrl, queries);<EOL>    ctrl.__readContentChildrenOrderScheduled = false;<EOL>    ctrl.__readViewChildrenOrderScheduled = false;<EOL>    <EOL>    const _ngOnChildrenChanged = function (type: ChildrenChangeHook, onFirstChangeDoneCb: Function[] = [], domResolverCb = onChildrenChangedCb) {<EOL>        let orderScheduledSemaphorePropName = '<STR_LIT>';<EOL>        let domResolverCbType = '<STR_LIT>';<EOL>        if (type === ChildrenChangeHook.FromView) {<EOL>            orderScheduledSemaphorePropName = SEMAPHORE_PROP_NAMES.view;<EOL>            domResolverCbType = DOM_RESOLVER_TYPES.view;<EOL>        }<EOL>        else if (type === ChildrenChangeHook.FromContent) {<EOL>            domResolverCbType = DOM_RESOLVER_TYPES.content;<EOL>            orderScheduledSemaphorePropName = SEMAPHORE_PROP_NAMES.content;<EOL>        }<EOL>        else {<EOL>            throw new Error(`<STR_LIT>`);<EOL>        }<EOL>        if (ctrl[orderScheduledSemaphorePropName]) {<EOL>            return;<EOL>        }<EOL>        ctrl[orderScheduledSemaphorePropName] = true;<EOL>        <EOL>        <EOL>        scope.$evalAsync(() => {<EOL>            <EOL>            ctrl[orderScheduledSemaphorePropName] = false;<EOL>            <EOL>            domResolverCb[domResolverCbType].forEach(cb => cb());<EOL>            <EOL>            <EOL>            onFirstChangeDoneCb.forEach((cb) => { isFunction(cb) && cb(); });<EOL>        });<EOL>    };<EOL>    <EOL>    <EOL>    ctrl._ngOnChildrenChanged = _ngOnChildrenChanged.bind(ctrl);<EOL>    /**<EOL>     * get all callbacks which will be executed withing $scope.$evalAsync,<EOL>     * which are querying for DOM elements and gets controller instances from host element children<EOL>     * @param element<EOL>     * @param ctrl<EOL>     * @param queries<EOL>     * @returns {view: Function[], content: Function[]}<EOL>     * @private<EOL>     */<EOL>    function _getOnChildrenResolvers(element: ng.IAugmentedJQuery, ctrl: any, queries: {<EOL>        [key: string]: QueryMetadata | ViewQueryMetadata;<EOL>    }) {<EOL>        const _onChildrenChangedCbMap = {<EOL>            [DOM_RESOLVER_TYPES.view]: [],<EOL>            [DOM_RESOLVER_TYPES.content]: []<EOL>        };<EOL>        StringMapWrapper.forEach(queries, function (meta: QueryMetadata | ViewQueryMetadata, key: string) {<EOL>            if (meta instanceof ViewChildMetadata) {<EOL>                _onChildrenChangedCbMap[DOM_RESOLVER_TYPES.view].push(_resolveViewChild(element, ctrl, key, meta));<EOL>            }<EOL>            if (meta instanceof ViewChildrenMetadata) {<EOL>                _onChildrenChangedCbMap[DOM_RESOLVER_TYPES.view].push(_resolveViewChildren(element, ctrl, key, meta));<EOL>            }<EOL>            if (meta instanceof ContentChildMetadata) {<EOL>                _onChildrenChangedCbMap[DOM_RESOLVER_TYPES.content].push(_resolveContentChild(element, ctrl, key, meta));<EOL>            }<EOL>            if (meta instanceof ContentChildrenMetadata) {<EOL>                _onChildrenChangedCbMap[DOM_RESOLVER_TYPES.content].push(_resolveContentChildren(element, ctrl, key, meta));<EOL>            }<EOL>        });<EOL>        return _onChildrenChangedCbMap;<EOL>        function _resolveViewChild(element: ng.IAugmentedJQuery, ctrl: any, key: string, meta: QueryMetadata | ViewQueryMetadata) {<EOL>            return _resolveChildrenFactory(element, ctrl, key, meta.selector, DOM_RESOLVER_TYPES.view, true);<EOL>        }<EOL>        function _resolveContentChild(element: ng.IAugmentedJQuery, ctrl: any, key: string, meta: QueryMetadata | ViewQueryMetadata) {<EOL>            return _resolveChildrenFactory(element, ctrl, key, meta.selector, DOM_RESOLVER_TYPES.","gt":"content, true);"}
{"input":"<s> function returnJustHead<T>(val: T, tail: List<T>): Maybe.Maybe<T> {<EOL>    return","gt":"Maybe.Just(val);"}
{"input":"<s> /**<EOL> *<EOL> * Used to register an Angular 2 Service by including it in the `providers` array of an ng-metadata `@NgModule`,<EOL> * where the service name and downgraded factory functions are automatically generated.<EOL> *<EOL> * **NOTE:** downgraded service must also be registered within Angular 2 Component or NgModule<EOL> *<EOL> * Returns a `ProviderLiteral` which can be used to register an Angular 2 Provider/Injectable<EOL> * by including it in the providers array of an ng-metadata annotated Angular 1<EOL> * `@Component` or `@NgModule`. Either a string or an ng-metadata OpaqueToken can be used for the name.<EOL> *<EOL> * @example<EOL> * ```<EOL> * // foo.component.ts - Angular 1(ngMetadata)<EOL> * import { downgradeInjectable } from '@angular/upgrade/static/';<EOL> * import { provideNg2Injectable } from 'ng-metadata/upgrade';<EOL> * import { Component } from 'ng-metadata/core';<EOL> *<EOL> * import { Ng2Service } from './services/ng2.service';<EOL> * import { Ng2ServiceDecorated } from './services/ng2decorated.service';<EOL> *<EOL> * const OtherServiceToken = new OpaqueToken('otherService')<EOL> *<EOL> * @Component({<EOL>   *  selector: 'my-foo',<EOL>   *  providers: [<EOL>   *    provideNg2Injectable({token:'ng2Service', injectable: Ng2Service, downgradeFn: downgradeInjectable }),<EOL>   *    provideNg2Injectable({token:OtherServiceToken, injectable: Ng2Service, downgradeFn: downgradeInjectable }),<EOL>   *    provideNg2Injectable({injectable:Ng2ServiceDecorated, downgradeFn: downgradeInjectable}),<EOL>   *  ],<EOL>   * })<EOL> * class FooComponent{}<EOL> * ```<EOL> *<EOL> * or via ngMetadata NgModule:<EOL> *<EOL> * @example<EOL> * ```typescript<EOL> * * @example<EOL> * ```<EOL> * // app.module.ts - Angular 1(ngMetadata)<EOL> * import { downgradeInjectable } from '@angular/upgrade/static/';<EOL> * import { provideNg2Injectable } from 'ng-metadata/upgrade';<EOL> * import { NgModule } from 'ng-metadata/core';<EOL> *<EOL> * import { Ng2Service } from './services/ng2.service';<EOL> * import { Ng2ServiceDecorated } from './services/ng2decorated.service';<EOL> *<EOL> * const OtherServiceToken = new OpaqueToken('otherService')<EOL> *<EOL> * @NgModule({<EOL>   *  providers: [<EOL>   *    provideNg2Injectable({token:'ng2Service', injectable: Ng2Service, downgradeFn: downgradeInjectable }),<EOL>   *    provideNg2Injectable({token:OtherServiceToken, injectable: Ng2Service, downgradeFn: downgradeInjectable }),<EOL>   *    provideNg2Injectable({injectable:Ng2ServiceDecorated, downgradeFn: downgradeInjectable}),<EOL>   *  ],<EOL>   * })<EOL> * export class AppModule{}<EOL> * ```<EOL> *<EOL> * as you've may noticed in one registration we've omitted `token`, how is that possible that it works you ask?<EOL> * this is thanks to ngMetadata `@Injectable()` decorator, we can decorate Angular 2 Classes with our ngMetadata `@Injectable`,<EOL> * which gives us benefit to omit Opaque tokens creation and use the same class for DI for both Angular 2 and Angular 1.<EOL> * POWER OVERWHELMING RIGHT?!<EOL> *<EOL> * Enough Talk! Show me how the service looks like:<EOL> * ```typescript<EOL> * // ./services/ng2decorated.service.ts<EOL> *<EOL> * import {Injectable} from '@angular/core';<EOL> * import {Injectable as KeepNg1Injectable} from 'ng-metadata/core';<EOL> *<EOL> * @KeepNg1Injectable()<EOL> * @Injectable()<EOL> * export class Ng2ServiceDecorated {<EOL> *  constructor(){}<EOL> *  greet(){}<EOL> * }<EOL> * ```<EOL> */<EOL>export function provideNg2Injectable({ injectable, downgradeFn, token }: ProvideNg2InjectableParams): ProviderLiteral {<EOL>    const { name, factoryFn, deps } = _downgradeInjectable({<EOL>        token: token || injectable as any,<EOL>        injectable,<EOL>","gt":"downgradeFn"}
{"input":"<s> /**<EOL> *<EOL> * Used to register an Angular 2 Service by including it in the `providers` array of an ng-metadata `@NgModule`,<EOL> * where the service name and downgraded factory functions are automatically generated.<EOL> *<EOL> * **NOTE:** downgraded service must also be registered within Angular 2 Component or NgModule<EOL> *<EOL> * Returns a `ProviderLiteral` which can be used to register an Angular 2 Provider/Injectable<EOL> * by including it in the providers array of an ng-metadata annotated Angular 1<EOL> * `@Component` or `@NgModule`. Either a string or an ng-metadata OpaqueToken can be used for the name.<EOL> *<EOL> * @example<EOL> * ```<EOL> * // foo.component.ts - Angular 1(ngMetadata)<EOL> * import { downgradeInjectable } from '@angular/upgrade/static/';<EOL> * import { provideNg2Injectable } from 'ng-metadata/upgrade';<EOL> * import { Component } from 'ng-metadata/core';<EOL> *<EOL> * import { Ng2Service } from './services/ng2.service';<EOL> * import { Ng2ServiceDecorated } from './services/ng2decorated.service';<EOL> *<EOL> * const OtherServiceToken = new OpaqueToken('otherService')<EOL> *<EOL> * @Component({<EOL>   *  selector: 'my-foo',<EOL>   *  providers: [<EOL>   *    provideNg2Injectable({token:'ng2Service', injectable: Ng2Service, downgradeFn: downgradeInjectable }),<EOL>   *    provideNg2Injectable({token:OtherServiceToken, injectable: Ng2Service, downgradeFn: downgradeInjectable }),<EOL>   *    provideNg2Injectable({injectable:Ng2ServiceDecorated, downgradeFn: downgradeInjectable}),<EOL>   *  ],<EOL>   * })<EOL> * class FooComponent{}<EOL> * ```<EOL> *<EOL> * or via ngMetadata NgModule:<EOL> *<EOL> * @example<EOL> * ```typescript<EOL> * * @example<EOL> * ```<EOL> * // app.module.ts - Angular 1(ngMetadata)<EOL> * import { downgradeInjectable } from '@angular/upgrade/static/';<EOL> * import { provideNg2Injectable } from 'ng-metadata/upgrade';<EOL> * import { NgModule } from 'ng-metadata/core';<EOL> *<EOL> * import { Ng2Service } from './services/ng2.service';<EOL> * import { Ng2ServiceDecorated } from './services/ng2decorated.service';<EOL> *<EOL> * const OtherServiceToken = new OpaqueToken('otherService')<EOL> *<EOL> * @NgModule({<EOL>   *  providers: [<EOL>   *    provideNg2Injectable({token:'ng2Service', injectable: Ng2Service, downgradeFn: downgradeInjectable }),<EOL>   *    provideNg2Injectable({token:OtherServiceToken, injectable: Ng2Service, downgradeFn: downgradeInjectable }),<EOL>   *    provideNg2Injectable({injectable:Ng2ServiceDecorated, downgradeFn: downgradeInjectable}),<EOL>   *  ],<EOL>   * })<EOL> * export class AppModule{}<EOL> * ```<EOL> *<EOL> * as you've may noticed in one registration we've omitted `token`, how is that possible that it works you ask?<EOL> * this is thanks to ngMetadata `@Injectable()` decorator, we can decorate Angular 2 Classes with our ngMetadata `@Injectable`,<EOL> * which gives us benefit to omit Opaque tokens creation and use the same class for DI for both Angular 2 and Angular 1.<EOL> * POWER OVERWHELMING RIGHT?!<EOL> *<EOL> * Enough Talk! Show me how the service looks like:<EOL> * ```typescript<EOL> * // ./services/ng2decorated.service.ts<EOL> *<EOL> * import {Injectable} from '@angular/core';<EOL> * import {Injectable as KeepNg1Injectable} from 'ng-metadata/core';<EOL> *<EOL> * @KeepNg1Injectable()<EOL> * @Injectable()<EOL> * export class Ng2ServiceDecorated {<EOL> *  constructor(){}<EOL> *  greet(){}<EOL> * }<EOL> * ```<EOL> */<EOL>export function provideNg2Injectable({ injectable, downgradeFn, token }: ProvideNg2InjectableParams): ProviderLiteral {<EOL>    const { name, factoryFn, deps } = _downgradeInjectable({<EOL>        token: token || injectable as any,<EOL>        injectable,<EOL>        downgradeFn<EOL>    });<EOL>    return {<EOL>        provide: name,<EOL>        useFactory:","gt":"factoryFn,"}
{"input":"<s> /**<EOL> * use #isDirective instead<EOL> * @deprecated<EOL> */<EOL>export function isAttrDirective(metadata: any): metadata is DirectiveMetadata {<EOL>    return","gt":"metadata instanceof DirectiveMetadata && !(metadata instanceof ComponentMetadata);"}
{"input":"<s> function dispatchNext<T>(arg: DispatchNextArg<T>) {<EOL>    const {","gt":"value, subject } = arg;"}
{"input":"<s> export function isPromise(obj: any): boolean {<EOL>    return obj instanceof (<any>","gt":"_global).Promise;"}
{"input":"<s> function subtypeFromParsedSubtype(subtype: ObjectMonaParser.AlgebraicParsedSubtype): AlgebraicType.Subtype {<EOL>    return subtype.attributeValue ?<EOL>        AlgebraicType.Subtype.SingleAttributeSubtypeDefinition(subtypeAttributeFromParseResultAttribute(subtype.attributeValue)) :<EOL>","gt":"AlgebraicType.Subtype.NamedAttributeCollectionDefinition({"}
{"input":"<s> function _firstTo(value: string, cb: Function): string {<EOL>","gt":"return cb.call(value.charAt(<NUM_LIT>)) + value.substring(<NUM_LIT>);"}
{"input":"<s> function dispatchError<T>(arg: DispatchErrorArg<T>) {<EOL>    const { err, subscriber } = arg;<EOL>","gt":"if (!subscriber.closed) {"}
{"input":"<s> function localImport(file: string): string {<EOL>    if (file.indexOf('<STR_LIT>') === -<NUM_LIT>) {<EOL>        return '<STR_LIT>' + file +","gt":"'<STR_LIT>';"}
{"input":"<s> function toPropertyModifierString(modifier: ObjC.PropertyModifier): string {<EOL>    return modifier.match(returnString('<STR_LIT>'), returnString('<STR_LIT>'), returnString('<STR_LIT>'), returnString('<STR_LIT>'), returnString('<STR_LIT>'), returnString('<STR_LIT>'), returnString('<STR_LIT>'), returnString('<STR_LIT>'), returnString('<STR_LIT>'), returnString('<STR_LIT>'),","gt":"returnString('<STR_LIT>'));"}
{"input":"<s> function commitLocale(store: IStore, lang: string, resourcesIn: II18nKeys) {<EOL>    const resources: II18nKeys = {};<EOL>    for (const","gt":"key of Object.keys(resourcesIn)) {"}
{"input":"<s> /**<EOL> * Converts a higher-order Observable into a first-order Observable by waiting<EOL> * for the outer Observable to complete, then applying {@link combineLatest}.<EOL> *<EOL> * <span class=\"informal\">Flattens an Observable-of-Observables by applying<EOL> * {@link combineLatest} when the Observable-of-Observables completes.</span><EOL> *<EOL> * <img src=\"./img/combineAll.png\" width=\"100%\"><EOL> *<EOL> * Takes an Observable of Observables, and collects all Observables from it.<EOL> * Once the outer Observable completes, it subscribes to all collected<EOL> * Observables and combines their values using the {@link combineLatest}<EOL> * strategy, such that:<EOL> * - Every time an inner Observable emits, the output Observable emits.<EOL> * - When the returned observable emits, it emits all of the latest values by:<EOL> *   - If a `project` function is provided, it is called with each recent value<EOL> *     from each inner Observable in whatever order they arrived, and the result<EOL> *     of the `project` function is what is emitted by the output Observable.<EOL> *   - If there is no `project` function, an array of all of the most recent<EOL> *     values is emitted by the output Observable.<EOL> *<EOL> * @example <caption>Map two click events to a finite interval Observable, then apply combineAll</caption><EOL> * var clicks = Rx.Observable.fromEvent(document, 'click');<EOL> * var higherOrder = clicks.map(ev =><EOL> *   Rx.Observable.interval(Math.random()*2000).take(3)<EOL> * ).take(2);<EOL> * var result = higherOrder.combineAll();<EOL> * result.subscribe(x => console.log(x));<EOL> *<EOL> * @see {@link combineLatest}<EOL> * @see {@link mergeAll}<EOL> *<EOL> * @param {function} [project] An optional function to map the most recent<EOL> * values from each inner Observable into a new result. Takes each of the most<EOL> * recent values from each collected inner Observable as arguments, in order.<EOL> * @return {Observable} An Observable of projected results or arrays of recent<EOL> * values.<EOL> * @method combineAll<EOL> * @owner Observable<EOL> */<EOL>export function combineAll<R>(project?: (...values: Array<any>) => R): Observable<R> {<EOL>    return this.lift(new","gt":"CombineLatestOperator(project));"}
{"input":"<s> function addCommaToEndOfString(str: string): string {<EOL>","gt":"return str + '<STR_LIT>';"}
{"input":"<s> async function performUpdateCheck(ctx: Context, items: CheckUpdateItem[]): Promise<CheckUpdateResult> {<EOL>    let res: CheckUpdateResult;<EOL>    const instance = await makeButlerInstance();<EOL>    instance.onClient(async (client) => {<EOL>        try {<EOL>","gt":"client.onNotification(messages.GameUpdateAvailable, async ({ params }) => {"}
{"input":"<s> async function performUpdateCheck(ctx: Context, items: CheckUpdateItem[]): Promise<CheckUpdateResult> {<EOL>    let res: CheckUpdateResult;<EOL>    const instance = await makeButlerInstance();<EOL>    instance.onClient(async (client) => {<EOL>        try {<EOL>            client.onNotification(messages.GameUpdateAvailable, async ({ params }) => {<EOL>                const { update } = params;<EOL>                ctx.store.dispatch(actions.gameUpdateAvailable({ update }));<EOL>            });<EOL>            res = await client.call(messages.CheckUpdate({","gt":"items }));"}
{"input":"<s> function dispatchError<T>(arg: DispatchErrorArg<T>) {<EOL>    const { err, subject } =","gt":"arg;"}
{"input":"<s> export default function (watcher: Watcher, db: DB) {<EOL>    if (SKIP_GAME_UPDATES) {<EOL>","gt":"logger.debug(\"<STR_LIT>\");"}
{"input":"<s> export default function (watcher: Watcher, db: DB) {<EOL>    if (SKIP_GAME_UPDATES) {<EOL>        logger.debug(\"<STR_LIT>\");<EOL>    }<EOL>","gt":"else {"}
{"input":"<s> export default function (watcher: Watcher, db: DB) {<EOL>    if (SKIP_GAME_UPDATES) {<EOL>        logger.debug(\"<STR_LIT>\");<EOL>    }<EOL>    else {<EOL>        watcher.on(actions.tick, async (store, action) => {<EOL>            const { nextGameUpdateCheck } = store.getState().systemTasks;<EOL>            if (Date.now() <= nextGameUpdateCheck) {<EOL>                <EOL>                return;<EOL>            }<EOL>            logger.info(\"<STR_LIT>\");<EOL>            store.dispatch(actions.","gt":"checkForGameUpdates({}));"}
{"input":"<s> export default function (watcher: Watcher, db: DB) {<EOL>    if (SKIP_GAME_UPDATES) {<EOL>        logger.debug(\"<STR_LIT>\");<EOL>    }<EOL>    else {<EOL>        watcher.on(actions.tick, async (store, action) => {<EOL>            const { nextGameUpdateCheck } = store.getState().systemTasks;<EOL>            if (Date.now() <= nextGameUpdateCheck) {<EOL>                <EOL>                return;<EOL>            }<EOL>            logger.info(\"<STR_LIT>\");<EOL>            store.dispatch(actions.checkForGameUpdates({}));<EOL>        });<EOL>    }<EOL>    watcher.on(actions.checkForGameUpdates, async (store, action) => {<EOL>        reschedule(store);<EOL>        store.dispatch(actions.gameUpdateCheckStatus({<EOL>","gt":"checking: true,"}
{"input":"<s> export default function (watcher: Watcher, db: DB) {<EOL>    if (SKIP_GAME_UPDATES) {<EOL>        logger.debug(\"<STR_LIT>\");<EOL>    }<EOL>    else {<EOL>        watcher.on(actions.tick, async (store, action) => {<EOL>            const { nextGameUpdateCheck } = store.getState().systemTasks;<EOL>            if (Date.now() <= nextGameUpdateCheck) {<EOL>                <EOL>                return;<EOL>            }<EOL>            logger.info(\"<STR_LIT>\");<EOL>            store.dispatch(actions.checkForGameUpdates({}));<EOL>        });<EOL>    }<EOL>    watcher.on(actions.checkForGameUpdates, async (store, action) => {<EOL>        reschedule(store);<EOL>        store.dispatch(actions.gameUpdateCheckStatus({<EOL>            checking: true,<EOL>","gt":"progress: <NUM_LIT>,"}
{"input":"<s> export default function (watcher: Watcher, db: DB) {<EOL>    if (SKIP_GAME_UPDATES) {<EOL>        logger.debug(\"<STR_LIT>\");<EOL>    }<EOL>    else {<EOL>        watcher.on(actions.tick, async (store, action) => {<EOL>            const { nextGameUpdateCheck } = store.getState().systemTasks;<EOL>            if (Date.now() <= nextGameUpdateCheck) {<EOL>                <EOL>                return;<EOL>            }<EOL>            logger.info(\"<STR_LIT>\");<EOL>            store.dispatch(actions.checkForGameUpdates({}));<EOL>        });<EOL>    }<EOL>    watcher.on(actions.checkForGameUpdates, async (store, action) => {<EOL>        reschedule(store);<EOL>        store.dispatch(actions.gameUpdateCheckStatus({<EOL>            checking: true,<EOL>            progress: <NUM_LIT>,<EOL>        }));<EOL>        try {<EOL>            const ctx = new Context(store, db);<EOL>            const totalCaves = db.caves.count(k => k.where(\"<STR_LIT>\"));<EOL>            let limit = <NUM_LIT>;<EOL>            let offset = <NUM_LIT>;<EOL>            while (offset < totalCaves) {<EOL>","gt":"store.dispatch(actions.gameUpdateCheckStatus({"}
{"input":"<s> export default function (watcher: Watcher, db: DB) {<EOL>    if (SKIP_GAME_UPDATES) {<EOL>        logger.debug(\"<STR_LIT>\");<EOL>    }<EOL>    else {<EOL>        watcher.on(actions.tick, async (store, action) => {<EOL>            const { nextGameUpdateCheck } = store.getState().systemTasks;<EOL>            if (Date.now() <= nextGameUpdateCheck) {<EOL>                <EOL>                return;<EOL>            }<EOL>            logger.info(\"<STR_LIT>\");<EOL>            store.dispatch(actions.checkForGameUpdates({}));<EOL>        });<EOL>    }<EOL>    watcher.on(actions.checkForGameUpdates, async (store, action) => {<EOL>        reschedule(store);<EOL>        store.dispatch(actions.gameUpdateCheckStatus({<EOL>            checking: true,<EOL>            progress: <NUM_LIT>,<EOL>        }));<EOL>        try {<EOL>            const ctx = new Context(store, db);<EOL>            const totalCaves = db.caves.count(k => k.where(\"<STR_LIT>\"));<EOL>            let limit = <NUM_LIT>;<EOL>            let offset = <NUM_LIT>;<EOL>            while (offset < totalCaves) {<EOL>                store.dispatch(actions.gameUpdateCheckStatus({<EOL>                    checking: true,<EOL>","gt":"progress: offset /"}
{"input":"<s> export default function (watcher: Watcher, db: DB) {<EOL>    if (SKIP_GAME_UPDATES) {<EOL>        logger.debug(\"<STR_LIT>\");<EOL>    }<EOL>    else {<EOL>        watcher.on(actions.tick, async (store, action) => {<EOL>            const { nextGameUpdateCheck } = store.getState().systemTasks;<EOL>            if (Date.now() <= nextGameUpdateCheck) {<EOL>                <EOL>                return;<EOL>            }<EOL>            logger.info(\"<STR_LIT>\");<EOL>            store.dispatch(actions.checkForGameUpdates({}));<EOL>        });<EOL>    }<EOL>    watcher.on(actions.checkForGameUpdates, async (store, action) => {<EOL>        reschedule(store);<EOL>        store.dispatch(actions.gameUpdateCheckStatus({<EOL>            checking: true,<EOL>            progress: <NUM_LIT>,<EOL>        }));<EOL>        try {<EOL>            const ctx = new Context(store, db);<EOL>            const totalCaves = db.caves.count(k => k.where(\"<STR_LIT>\"));<EOL>            let limit = <NUM_LIT>;<EOL>            let offset = <NUM_LIT>;<EOL>            while (offset < totalCaves) {<EOL>                store.dispatch(actions.gameUpdateCheckStatus({<EOL>                    checking: true,<EOL>                    progress: offset /","gt":"totalCaves,"}
{"input":"<s> export default function (watcher: Watcher, db: DB) {<EOL>    if (SKIP_GAME_UPDATES) {<EOL>        logger.debug(\"<STR_LIT>\");<EOL>    }<EOL>    else {<EOL>        watcher.on(actions.tick, async (store, action) => {<EOL>            const { nextGameUpdateCheck } = store.getState().systemTasks;<EOL>            if (Date.now() <= nextGameUpdateCheck) {<EOL>                <EOL>                return;<EOL>            }<EOL>            logger.info(\"<STR_LIT>\");<EOL>            store.dispatch(actions.checkForGameUpdates({}));<EOL>        });<EOL>    }<EOL>    watcher.on(actions.checkForGameUpdates, async (store, action) => {<EOL>        reschedule(store);<EOL>        store.dispatch(actions.gameUpdateCheckStatus({<EOL>            checking: true,<EOL>            progress: <NUM_LIT>,<EOL>        }));<EOL>        try {<EOL>            const ctx = new Context(store, db);<EOL>            const totalCaves = db.caves.count(k => k.where(\"<STR_LIT>\"));<EOL>            let limit = <NUM_LIT>;<EOL>            let offset = <NUM_LIT>;<EOL>            while (offset < totalCaves) {<EOL>                store.dispatch(actions.gameUpdateCheckStatus({<EOL>                    checking: true,<EOL>                    progress: offset / totalCaves,<EOL>                }));<EOL>                let start = offset;<EOL>                let end = offset + limit;<EOL>                if (end > totalCaves) {<EOL>                    end = totalCaves;<EOL>                }<EOL>                logger.info(`<STR_LIT>`);<EOL>                const caves = db.caves.all(k => k<EOL>                    .where(","gt":"\"<STR_LIT>\")"}
{"input":"<s> export default function (watcher: Watcher, db: DB) {<EOL>    if (SKIP_GAME_UPDATES) {<EOL>        logger.debug(\"<STR_LIT>\");<EOL>    }<EOL>    else {<EOL>        watcher.on(actions.tick, async (store, action) => {<EOL>            const { nextGameUpdateCheck } = store.getState().systemTasks;<EOL>            if (Date.now() <= nextGameUpdateCheck) {<EOL>                <EOL>                return;<EOL>            }<EOL>            logger.info(\"<STR_LIT>\");<EOL>            store.dispatch(actions.checkForGameUpdates({}));<EOL>        });<EOL>    }<EOL>    watcher.on(actions.checkForGameUpdates, async (store, action) => {<EOL>        reschedule(store);<EOL>        store.dispatch(actions.gameUpdateCheckStatus({<EOL>            checking: true,<EOL>            progress: <NUM_LIT>,<EOL>        }));<EOL>        try {<EOL>            const ctx = new Context(store, db);<EOL>            const totalCaves = db.caves.count(k => k.where(\"<STR_LIT>\"));<EOL>            let limit = <NUM_LIT>;<EOL>            let offset = <NUM_LIT>;<EOL>            while (offset < totalCaves) {<EOL>                store.dispatch(actions.gameUpdateCheckStatus({<EOL>                    checking: true,<EOL>                    progress: offset / totalCaves,<EOL>                }));<EOL>                let start = offset;<EOL>                let end = offset + limit;<EOL>                if (end > totalCaves) {<EOL>                    end = totalCaves;<EOL>                }<EOL>                logger.info(`<STR_LIT>`);<EOL>                const caves = db.caves.all(k => k<EOL>                    .where(\"<STR_LIT>\")<EOL>                    .limit(limit)<EOL>                    .offset(offset));<EOL>                let items: CheckUpdateItem[] = [];<EOL>                for (const cave of caves) {<EOL>                    try {<EOL>                        const item = await prepareUpdateItem(ctx, cave);<EOL>                        items.push(item);<EOL>                    }<EOL>                    catch (e) {<EOL>                        logger.error(`<STR_LIT>`);<EOL>                    }<EOL>                }<EOL>                try {<EOL>                    await performUpdateCheck(ctx, items);<EOL>                }<EOL>                catch (e) {<EOL>                    logger.error(`<STR_LIT>`);<EOL>                }<EOL>","gt":"offset += limit;"}
{"input":"<s> export default function (watcher: Watcher, db: DB) {<EOL>    if (SKIP_GAME_UPDATES) {<EOL>        logger.debug(\"<STR_LIT>\");<EOL>    }<EOL>    else {<EOL>        watcher.on(actions.tick, async (store, action) => {<EOL>            const { nextGameUpdateCheck } = store.getState().systemTasks;<EOL>            if (Date.now() <= nextGameUpdateCheck) {<EOL>                <EOL>                return;<EOL>            }<EOL>            logger.info(\"<STR_LIT>\");<EOL>            store.dispatch(actions.checkForGameUpdates({}));<EOL>        });<EOL>    }<EOL>    watcher.on(actions.checkForGameUpdates, async (store, action) => {<EOL>        reschedule(store);<EOL>        store.dispatch(actions.gameUpdateCheckStatus({<EOL>            checking: true,<EOL>            progress: <NUM_LIT>,<EOL>        }));<EOL>        try {<EOL>            const ctx = new Context(store, db);<EOL>            const totalCaves = db.caves.count(k => k.where(\"<STR_LIT>\"));<EOL>            let limit = <NUM_LIT>;<EOL>            let offset = <NUM_LIT>;<EOL>            while (offset < totalCaves) {<EOL>                store.dispatch(actions.gameUpdateCheckStatus({<EOL>                    checking: true,<EOL>                    progress: offset / totalCaves,<EOL>                }));<EOL>                let start = offset;<EOL>                let end = offset + limit;<EOL>                if (end > totalCaves) {<EOL>                    end = totalCaves;<EOL>                }<EOL>                logger.info(`<STR_LIT>`);<EOL>                const caves = db.caves.all(k => k<EOL>                    .where(\"<STR_LIT>\")<EOL>                    .limit(limit)<EOL>                    .offset(offset));<EOL>                let items: CheckUpdateItem[] = [];<EOL>                for (const cave of caves) {<EOL>                    try {<EOL>                        const item = await prepareUpdateItem(ctx, cave);<EOL>                        items.push(item);<EOL>                    }<EOL>                    catch (e) {<EOL>                        logger.error(`<STR_LIT>`);<EOL>                    }<EOL>                }<EOL>                try {<EOL>                    await performUpdateCheck(ctx, items);<EOL>                }<EOL>                catch (e) {<EOL>                    logger.error(`<STR_LIT>`);<EOL>                }<EOL>                offset += limit;<EOL>            }<EOL>        }<EOL>","gt":"finally {"}
{"input":"<s> export default function (watcher: Watcher, db: DB) {<EOL>    if (SKIP_GAME_UPDATES) {<EOL>        logger.debug(\"<STR_LIT>\");<EOL>    }<EOL>    else {<EOL>        watcher.on(actions.tick, async (store, action) => {<EOL>            const { nextGameUpdateCheck } = store.getState().systemTasks;<EOL>            if (Date.now() <= nextGameUpdateCheck) {<EOL>                <EOL>                return;<EOL>            }<EOL>            logger.info(\"<STR_LIT>\");<EOL>            store.dispatch(actions.checkForGameUpdates({}));<EOL>        });<EOL>    }<EOL>    watcher.on(actions.checkForGameUpdates, async (store, action) => {<EOL>        reschedule(store);<EOL>        store.dispatch(actions.gameUpdateCheckStatus({<EOL>            checking: true,<EOL>            progress: <NUM_LIT>,<EOL>        }));<EOL>        try {<EOL>            const ctx = new Context(store, db);<EOL>            const totalCaves = db.caves.count(k => k.where(\"<STR_LIT>\"));<EOL>            let limit = <NUM_LIT>;<EOL>            let offset = <NUM_LIT>;<EOL>            while (offset < totalCaves) {<EOL>                store.dispatch(actions.gameUpdateCheckStatus({<EOL>                    checking: true,<EOL>                    progress: offset / totalCaves,<EOL>                }));<EOL>                let start = offset;<EOL>                let end = offset + limit;<EOL>                if (end > totalCaves) {<EOL>                    end = totalCaves;<EOL>                }<EOL>                logger.info(`<STR_LIT>`);<EOL>                const caves = db.caves.all(k => k<EOL>                    .where(\"<STR_LIT>\")<EOL>                    .limit(limit)<EOL>                    .offset(offset));<EOL>                let items: CheckUpdateItem[] = [];<EOL>                for (const cave of caves) {<EOL>                    try {<EOL>                        const item = await prepareUpdateItem(ctx, cave);<EOL>                        items.push(item);<EOL>                    }<EOL>                    catch (e) {<EOL>                        logger.error(`<STR_LIT>`);<EOL>                    }<EOL>                }<EOL>                try {<EOL>                    await performUpdateCheck(ctx, items);<EOL>                }<EOL>                catch (e) {<EOL>                    logger.error(`<STR_LIT>`);<EOL>                }<EOL>                offset += limit;<EOL>            }<EOL>        }<EOL>        finally {<EOL>            store.dispatch(actions.gameUpdateCheckStatus({<EOL>                checking: false,<EOL>                progress: -<NUM_LIT>,<EOL>            }));<EOL>        }<EOL>    });<EOL>    watcher.on(actions.checkForGameUpdate, async (store, action) => {<EOL>        const { caveId, noisy = false } = action.payload;<EOL>        if (noisy) {<EOL>            logger.info(`<STR_LIT>`);<EOL>        }<EOL>        const","gt":"cave = db.caves.findOneById(caveId);"}
{"input":"<s> export default function (watcher: Watcher, db: DB) {<EOL>    if (SKIP_GAME_UPDATES) {<EOL>        logger.debug(\"<STR_LIT>\");<EOL>    }<EOL>    else {<EOL>        watcher.on(actions.tick, async (store, action) => {<EOL>            const { nextGameUpdateCheck } = store.getState().systemTasks;<EOL>            if (Date.now() <= nextGameUpdateCheck) {<EOL>                <EOL>                return;<EOL>            }<EOL>            logger.info(\"<STR_LIT>\");<EOL>            store.dispatch(actions.checkForGameUpdates({}));<EOL>        });<EOL>    }<EOL>    watcher.on(actions.checkForGameUpdates, async (store, action) => {<EOL>        reschedule(store);<EOL>        store.dispatch(actions.gameUpdateCheckStatus({<EOL>            checking: true,<EOL>            progress: <NUM_LIT>,<EOL>        }));<EOL>        try {<EOL>            const ctx = new Context(store, db);<EOL>            const totalCaves = db.caves.count(k => k.where(\"<STR_LIT>\"));<EOL>            let limit = <NUM_LIT>;<EOL>            let offset = <NUM_LIT>;<EOL>            while (offset < totalCaves) {<EOL>                store.dispatch(actions.gameUpdateCheckStatus({<EOL>                    checking: true,<EOL>                    progress: offset / totalCaves,<EOL>                }));<EOL>                let start = offset;<EOL>                let end = offset + limit;<EOL>                if (end > totalCaves) {<EOL>                    end = totalCaves;<EOL>                }<EOL>                logger.info(`<STR_LIT>`);<EOL>                const caves = db.caves.all(k => k<EOL>                    .where(\"<STR_LIT>\")<EOL>                    .limit(limit)<EOL>                    .offset(offset));<EOL>                let items: CheckUpdateItem[] = [];<EOL>                for (const cave of caves) {<EOL>                    try {<EOL>                        const item = await prepareUpdateItem(ctx, cave);<EOL>                        items.push(item);<EOL>                    }<EOL>                    catch (e) {<EOL>                        logger.error(`<STR_LIT>`);<EOL>                    }<EOL>                }<EOL>                try {<EOL>                    await performUpdateCheck(ctx, items);<EOL>                }<EOL>                catch (e) {<EOL>                    logger.error(`<STR_LIT>`);<EOL>                }<EOL>                offset += limit;<EOL>            }<EOL>        }<EOL>        finally {<EOL>            store.dispatch(actions.gameUpdateCheckStatus({<EOL>                checking: false,<EOL>                progress: -<NUM_LIT>,<EOL>            }));<EOL>        }<EOL>    });<EOL>    watcher.on(actions.checkForGameUpdate, async (store, action) => {<EOL>        const { caveId, noisy = false } = action.payload;<EOL>        if (noisy) {<EOL>            logger.info(`<STR_LIT>`);<EOL>        }<EOL>        const cave = db.caves.findOneById(caveId);<EOL>        if (!cave) {<EOL>            logger.warn(`<STR_LIT>`);<EOL>            return;<EOL>        }<EOL>        const ctx = new Context(store,","gt":"db);"}
{"input":"<s> export default function (watcher: Watcher, db: DB) {<EOL>    if (SKIP_GAME_UPDATES) {<EOL>        logger.debug(\"<STR_LIT>\");<EOL>    }<EOL>    else {<EOL>        watcher.on(actions.tick, async (store, action) => {<EOL>            const { nextGameUpdateCheck } = store.getState().systemTasks;<EOL>            if (Date.now() <= nextGameUpdateCheck) {<EOL>                <EOL>                return;<EOL>            }<EOL>            logger.info(\"<STR_LIT>\");<EOL>            store.dispatch(actions.checkForGameUpdates({}));<EOL>        });<EOL>    }<EOL>    watcher.on(actions.checkForGameUpdates, async (store, action) => {<EOL>        reschedule(store);<EOL>        store.dispatch(actions.gameUpdateCheckStatus({<EOL>            checking: true,<EOL>            progress: <NUM_LIT>,<EOL>        }));<EOL>        try {<EOL>            const ctx = new Context(store, db);<EOL>            const totalCaves = db.caves.count(k => k.where(\"<STR_LIT>\"));<EOL>            let limit = <NUM_LIT>;<EOL>            let offset = <NUM_LIT>;<EOL>            while (offset < totalCaves) {<EOL>                store.dispatch(actions.gameUpdateCheckStatus({<EOL>                    checking: true,<EOL>                    progress: offset / totalCaves,<EOL>                }));<EOL>                let start = offset;<EOL>                let end = offset + limit;<EOL>                if (end > totalCaves) {<EOL>                    end = totalCaves;<EOL>                }<EOL>                logger.info(`<STR_LIT>`);<EOL>                const caves = db.caves.all(k => k<EOL>                    .where(\"<STR_LIT>\")<EOL>                    .limit(limit)<EOL>                    .offset(offset));<EOL>                let items: CheckUpdateItem[] = [];<EOL>                for (const cave of caves) {<EOL>                    try {<EOL>                        const item = await prepareUpdateItem(ctx, cave);<EOL>                        items.push(item);<EOL>                    }<EOL>                    catch (e) {<EOL>                        logger.error(`<STR_LIT>`);<EOL>                    }<EOL>                }<EOL>                try {<EOL>                    await performUpdateCheck(ctx, items);<EOL>                }<EOL>                catch (e) {<EOL>                    logger.error(`<STR_LIT>`);<EOL>                }<EOL>                offset += limit;<EOL>            }<EOL>        }<EOL>        finally {<EOL>            store.dispatch(actions.gameUpdateCheckStatus({<EOL>                checking: false,<EOL>                progress: -<NUM_LIT>,<EOL>            }));<EOL>        }<EOL>    });<EOL>    watcher.on(actions.checkForGameUpdate, async (store, action) => {<EOL>        const { caveId, noisy = false } = action.payload;<EOL>        if (noisy) {<EOL>            logger.info(`<STR_LIT>`);<EOL>        }<EOL>        const cave = db.caves.findOneById(caveId);<EOL>        if (!cave) {<EOL>            logger.warn(`<STR_LIT>`);<EOL>            return;<EOL>        }<EOL>        const ctx = new Context(store, db);<EOL>        const item = await prepareUpdateItem(ctx,","gt":"cave);"}
{"input":"<s> export default function (watcher: Watcher, db: DB) {<EOL>    if (SKIP_GAME_UPDATES) {<EOL>        logger.debug(\"<STR_LIT>\");<EOL>    }<EOL>    else {<EOL>        watcher.on(actions.tick, async (store, action) => {<EOL>            const { nextGameUpdateCheck } = store.getState().systemTasks;<EOL>            if (Date.now() <= nextGameUpdateCheck) {<EOL>                <EOL>                return;<EOL>            }<EOL>            logger.info(\"<STR_LIT>\");<EOL>            store.dispatch(actions.checkForGameUpdates({}));<EOL>        });<EOL>    }<EOL>    watcher.on(actions.checkForGameUpdates, async (store, action) => {<EOL>        reschedule(store);<EOL>        store.dispatch(actions.gameUpdateCheckStatus({<EOL>            checking: true,<EOL>            progress: <NUM_LIT>,<EOL>        }));<EOL>        try {<EOL>            const ctx = new Context(store, db);<EOL>            const totalCaves = db.caves.count(k => k.where(\"<STR_LIT>\"));<EOL>            let limit = <NUM_LIT>;<EOL>            let offset = <NUM_LIT>;<EOL>            while (offset < totalCaves) {<EOL>                store.dispatch(actions.gameUpdateCheckStatus({<EOL>                    checking: true,<EOL>                    progress: offset / totalCaves,<EOL>                }));<EOL>                let start = offset;<EOL>                let end = offset + limit;<EOL>                if (end > totalCaves) {<EOL>                    end = totalCaves;<EOL>                }<EOL>                logger.info(`<STR_LIT>`);<EOL>                const caves = db.caves.all(k => k<EOL>                    .where(\"<STR_LIT>\")<EOL>                    .limit(limit)<EOL>                    .offset(offset));<EOL>                let items: CheckUpdateItem[] = [];<EOL>                for (const cave of caves) {<EOL>                    try {<EOL>                        const item = await prepareUpdateItem(ctx, cave);<EOL>                        items.push(item);<EOL>                    }<EOL>                    catch (e) {<EOL>                        logger.error(`<STR_LIT>`);<EOL>                    }<EOL>                }<EOL>                try {<EOL>                    await performUpdateCheck(ctx, items);<EOL>                }<EOL>                catch (e) {<EOL>                    logger.error(`<STR_LIT>`);<EOL>                }<EOL>                offset += limit;<EOL>            }<EOL>        }<EOL>        finally {<EOL>            store.dispatch(actions.gameUpdateCheckStatus({<EOL>                checking: false,<EOL>                progress: -<NUM_LIT>,<EOL>            }));<EOL>        }<EOL>    });<EOL>    watcher.on(actions.checkForGameUpdate, async (store, action) => {<EOL>        const { caveId, noisy = false } = action.payload;<EOL>        if (noisy) {<EOL>            logger.info(`<STR_LIT>`);<EOL>        }<EOL>        const cave = db.caves.findOneById(caveId);<EOL>        if (!cave) {<EOL>            logger.warn(`<STR_LIT>`);<EOL>            return;<EOL>        }<EOL>        const ctx = new Context(store, db);<EOL>        const item = await prepareUpdateItem(ctx, cave);<EOL>        let res: CheckUpdateResult;<EOL>        try {<EOL>            res = await performUpdateCheck(ctx, [item]);<EOL>        }<EOL>        catch (e) {<EOL>            logger.","gt":"error(`<STR_LIT>`);"}
{"input":"<s> export default function (watcher: Watcher, db: DB) {<EOL>    if (SKIP_GAME_UPDATES) {<EOL>        logger.debug(\"<STR_LIT>\");<EOL>    }<EOL>    else {<EOL>        watcher.on(actions.tick, async (store, action) => {<EOL>            const { nextGameUpdateCheck } = store.getState().systemTasks;<EOL>            if (Date.now() <= nextGameUpdateCheck) {<EOL>                <EOL>                return;<EOL>            }<EOL>            logger.info(\"<STR_LIT>\");<EOL>            store.dispatch(actions.checkForGameUpdates({}));<EOL>        });<EOL>    }<EOL>    watcher.on(actions.checkForGameUpdates, async (store, action) => {<EOL>        reschedule(store);<EOL>        store.dispatch(actions.gameUpdateCheckStatus({<EOL>            checking: true,<EOL>            progress: <NUM_LIT>,<EOL>        }));<EOL>        try {<EOL>            const ctx = new Context(store, db);<EOL>            const totalCaves = db.caves.count(k => k.where(\"<STR_LIT>\"));<EOL>            let limit = <NUM_LIT>;<EOL>            let offset = <NUM_LIT>;<EOL>            while (offset < totalCaves) {<EOL>                store.dispatch(actions.gameUpdateCheckStatus({<EOL>                    checking: true,<EOL>                    progress: offset / totalCaves,<EOL>                }));<EOL>                let start = offset;<EOL>                let end = offset + limit;<EOL>                if (end > totalCaves) {<EOL>                    end = totalCaves;<EOL>                }<EOL>                logger.info(`<STR_LIT>`);<EOL>                const caves = db.caves.all(k => k<EOL>                    .where(\"<STR_LIT>\")<EOL>                    .limit(limit)<EOL>                    .offset(offset));<EOL>                let items: CheckUpdateItem[] = [];<EOL>                for (const cave of caves) {<EOL>                    try {<EOL>                        const item = await prepareUpdateItem(ctx, cave);<EOL>                        items.push(item);<EOL>                    }<EOL>                    catch (e) {<EOL>                        logger.error(`<STR_LIT>`);<EOL>                    }<EOL>                }<EOL>                try {<EOL>                    await performUpdateCheck(ctx, items);<EOL>                }<EOL>                catch (e) {<EOL>                    logger.error(`<STR_LIT>`);<EOL>                }<EOL>                offset += limit;<EOL>            }<EOL>        }<EOL>        finally {<EOL>            store.dispatch(actions.gameUpdateCheckStatus({<EOL>                checking: false,<EOL>                progress: -<NUM_LIT>,<EOL>            }));<EOL>        }<EOL>    });<EOL>    watcher.on(actions.checkForGameUpdate, async (store, action) => {<EOL>        const { caveId, noisy = false } = action.payload;<EOL>        if (noisy) {<EOL>            logger.info(`<STR_LIT>`);<EOL>        }<EOL>        const cave = db.caves.findOneById(caveId);<EOL>        if (!cave) {<EOL>            logger.warn(`<STR_LIT>`);<EOL>            return;<EOL>        }<EOL>        const ctx = new Context(store, db);<EOL>        const item = await prepareUpdateItem(ctx, cave);<EOL>        let res: CheckUpdateResult;<EOL>        try {<EOL>            res = await performUpdateCheck(ctx, [item]);<EOL>        }<EOL>        catch (e) {<EOL>            logger.error(`<STR_LIT>`);<EOL>","gt":"if (!res) {"}
{"input":"<s> /**<EOL> * Returns an Observable that emits whether or not every item of the source satisfies the condition specified.<EOL> *<EOL> * @example <caption>A simple example emitting true if all elements are less than 5, false otherwise</caption><EOL> *  Observable.of(1, 2, 3, 4, 5, 6)<EOL> *     .every(x => x < 5)<EOL> *     .subscribe(x => console.log(x)); // -> false<EOL> *<EOL> * @param {function} predicate A function for determining if an item meets a specified condition.<EOL> * @param {any} [thisArg] Optional object to use for `this` in the callback.<EOL> * @return {Observable} An Observable of booleans that determines if all items of the source Observable meet the condition specified.<EOL> * @method every<EOL> * @owner Observable<EOL> */<EOL>export function every<T>(predicate: (value: T, index: number, source: Observable<T>) => boolean, thisArg?: any): OperatorFunction<T, boolean> {<EOL>    return (source: Observable<T>) => source.lift(new EveryOperator(predicate,","gt":"thisArg, source));"}
{"input":"<s> export default function (watcher: Watcher, db: DB) {<EOL>    watcher.on(actions.tabGotWebContents, async (store, action) => {<EOL>        const { tab, webContentsId } = action.payload;<EOL>        logger.debug(","gt":"} for tab ${tab}`<STR_LIT>;"}
{"input":"<s> export default function (watcher: Watcher, db: DB) {<EOL>    watcher.on(actions.tabGotWebContents, async (store, action) => {<EOL>        const { tab, webContentsId } = action.payload;<EOL>        logger.debug(`<STR_LIT>`);<EOL>        const wc = webContents.fromId(webContentsId) as ExtendedWebContents;<EOL>        if (!wc) {<EOL>            logger.warn(`<STR_LIT>`);<EOL>","gt":"return;"}
{"input":"<s> export default function (watcher: Watcher, db: DB) {<EOL>    watcher.on(actions.tabGotWebContents, async (store, action) => {<EOL>        const { tab, webContentsId } = action.payload;<EOL>        logger.debug(`<STR_LIT>`);<EOL>        const wc = webContents.fromId(webContentsId) as ExtendedWebContents;<EOL>        if (!wc) {<EOL>            logger.warn(`<STR_LIT>`);<EOL>            return;<EOL>        }<EOL>        let pushWeb = (web: Partial<ITabWeb>) => {<EOL>            store.dispatch(actions.tabDataFetched({<EOL>                tab,<EOL>","gt":"data: {"}
{"input":"<s> export default function (watcher: Watcher, db: DB) {<EOL>    watcher.on(actions.tabGotWebContents, async (store, action) => {<EOL>        const { tab, webContentsId } = action.payload;<EOL>        logger.debug(`<STR_LIT>`);<EOL>        const wc = webContents.fromId(webContentsId) as ExtendedWebContents;<EOL>        if (!wc) {<EOL>            logger.warn(`<STR_LIT>`);<EOL>            return;<EOL>        }<EOL>        let pushWeb = (web: Partial<ITabWeb>) => {<EOL>            store.dispatch(actions.tabDataFetched({<EOL>                tab,<EOL>                data: {<EOL>                    web,<EOL>                },<EOL>            }));<EOL>        };<EOL>        pushWeb({ webContentsId, loading: wc.isLoading() });<EOL>        const sp = Space.fromStore(store, tab);<EOL>        const didNavigate = (url: string, replace?: boolean) => {<EOL>            if (sp.isFrozen()) {<EOL>","gt":"return;"}
{"input":"<s> export default function (watcher: Watcher, db: DB) {<EOL>    watcher.on(actions.tabGotWebContents, async (store, action) => {<EOL>        const { tab, webContentsId } = action.payload;<EOL>        logger.debug(`<STR_LIT>`);<EOL>        const wc = webContents.fromId(webContentsId) as ExtendedWebContents;<EOL>        if (!wc) {<EOL>            logger.warn(`<STR_LIT>`);<EOL>            return;<EOL>        }<EOL>        let pushWeb = (web: Partial<ITabWeb>) => {<EOL>            store.dispatch(actions.tabDataFetched({<EOL>                tab,<EOL>                data: {<EOL>                    web,<EOL>                },<EOL>            }));<EOL>        };<EOL>        pushWeb({ webContentsId, loading: wc.isLoading() });<EOL>        const sp = Space.fromStore(store, tab);<EOL>        const didNavigate = (url: string, replace?: boolean) => {<EOL>            if (sp.isFrozen()) {<EOL>                return;<EOL>            }<EOL>            if (url !== \"<STR_LIT>\") {<EOL>                const resource = parseWellKnownUrl(url);<EOL>                store.dispatch(actions.evolveTab({<EOL>","gt":"tab,"}
{"input":"<s> export default function (watcher: Watcher, db: DB) {<EOL>    watcher.on(actions.tabGotWebContents, async (store, action) => {<EOL>        const { tab, webContentsId } = action.payload;<EOL>        logger.debug(`<STR_LIT>`);<EOL>        const wc = webContents.fromId(webContentsId) as ExtendedWebContents;<EOL>        if (!wc) {<EOL>            logger.warn(`<STR_LIT>`);<EOL>            return;<EOL>        }<EOL>        let pushWeb = (web: Partial<ITabWeb>) => {<EOL>            store.dispatch(actions.tabDataFetched({<EOL>                tab,<EOL>                data: {<EOL>                    web,<EOL>                },<EOL>            }));<EOL>        };<EOL>        pushWeb({ webContentsId, loading: wc.isLoading() });<EOL>        const sp = Space.fromStore(store, tab);<EOL>        const didNavigate = (url: string, replace?: boolean) => {<EOL>            if (sp.isFrozen()) {<EOL>                return;<EOL>            }<EOL>            if (url !== \"<STR_LIT>\") {<EOL>                const resource = parseWellKnownUrl(url);<EOL>                store.dispatch(actions.evolveTab({<EOL>                    tab,<EOL>                    url,<EOL>                    resource,<EOL>","gt":"replace,"}
{"input":"<s> export default function (watcher: Watcher, db: DB) {<EOL>    watcher.on(actions.tabGotWebContents, async (store, action) => {<EOL>        const { tab, webContentsId } = action.payload;<EOL>        logger.debug(`<STR_LIT>`);<EOL>        const wc = webContents.fromId(webContentsId) as ExtendedWebContents;<EOL>        if (!wc) {<EOL>            logger.warn(`<STR_LIT>`);<EOL>            return;<EOL>        }<EOL>        let pushWeb = (web: Partial<ITabWeb>) => {<EOL>            store.dispatch(actions.tabDataFetched({<EOL>                tab,<EOL>                data: {<EOL>                    web,<EOL>                },<EOL>            }));<EOL>        };<EOL>        pushWeb({ webContentsId, loading: wc.isLoading() });<EOL>        const sp = Space.fromStore(store, tab);<EOL>        const didNavigate = (url: string, replace?: boolean) => {<EOL>            if (sp.isFrozen()) {<EOL>                return;<EOL>            }<EOL>            if (url !== \"<STR_LIT>\") {<EOL>                const resource = parseWellKnownUrl(url);<EOL>                store.dispatch(actions.evolveTab({<EOL>                    tab,<EOL>                    url,<EOL>                    resource,<EOL>                    replace,<EOL>                }));<EOL>            }<EOL>        };<EOL>        logger.debug(","gt":"wc.getURL()}`<STR_LIT>;"}
{"input":"<s> export default function (watcher: Watcher, db: DB) {<EOL>    watcher.on(actions.tabGotWebContents, async (store, action) => {<EOL>        const { tab, webContentsId } = action.payload;<EOL>        logger.debug(`<STR_LIT>`);<EOL>        const wc = webContents.fromId(webContentsId) as ExtendedWebContents;<EOL>        if (!wc) {<EOL>            logger.warn(`<STR_LIT>`);<EOL>            return;<EOL>        }<EOL>        let pushWeb = (web: Partial<ITabWeb>) => {<EOL>            store.dispatch(actions.tabDataFetched({<EOL>                tab,<EOL>                data: {<EOL>                    web,<EOL>                },<EOL>            }));<EOL>        };<EOL>        pushWeb({ webContentsId, loading: wc.isLoading() });<EOL>        const sp = Space.fromStore(store, tab);<EOL>        const didNavigate = (url: string, replace?: boolean) => {<EOL>            if (sp.isFrozen()) {<EOL>                return;<EOL>            }<EOL>            if (url !== \"<STR_LIT>\") {<EOL>                const resource = parseWellKnownUrl(url);<EOL>                store.dispatch(actions.evolveTab({<EOL>                    tab,<EOL>                    url,<EOL>                    resource,<EOL>                    replace,<EOL>                }));<EOL>            }<EOL>        };<EOL>        logger.debug(`<STR_LIT>`);<EOL>        didNavigate(wc.getURL(), true);<EOL>        if (sp.","gt":"isFrozen()) {"}
{"input":"<s> export default function (watcher: Watcher, db: DB) {<EOL>    watcher.on(actions.tabGotWebContents, async (store, action) => {<EOL>        const { tab, webContentsId } = action.payload;<EOL>        logger.debug(`<STR_LIT>`);<EOL>        const wc = webContents.fromId(webContentsId) as ExtendedWebContents;<EOL>        if (!wc) {<EOL>            logger.warn(`<STR_LIT>`);<EOL>            return;<EOL>        }<EOL>        let pushWeb = (web: Partial<ITabWeb>) => {<EOL>            store.dispatch(actions.tabDataFetched({<EOL>                tab,<EOL>                data: {<EOL>                    web,<EOL>                },<EOL>            }));<EOL>        };<EOL>        pushWeb({ webContentsId, loading: wc.isLoading() });<EOL>        const sp = Space.fromStore(store, tab);<EOL>        const didNavigate = (url: string, replace?: boolean) => {<EOL>            if (sp.isFrozen()) {<EOL>                return;<EOL>            }<EOL>            if (url !== \"<STR_LIT>\") {<EOL>                const resource = parseWellKnownUrl(url);<EOL>                store.dispatch(actions.evolveTab({<EOL>                    tab,<EOL>                    url,<EOL>                    resource,<EOL>                    replace,<EOL>                }));<EOL>            }<EOL>        };<EOL>        logger.debug(`<STR_LIT>`);<EOL>        didNavigate(wc.getURL(), true);<EOL>        if (sp.isFrozen()) {<EOL>            wc.on(\"<STR_LIT>\", (ev, url) => {<EOL>                ev.preventDefault();<EOL>                store.dispatch(actions.navigate({ url }));<EOL>            });<EOL>        }<EOL>        <EOL>        <EOL>        wc.once(","gt":"\"<STR_LIT>\", () => {"}
{"input":"<s> export default function (watcher: Watcher, db: DB) {<EOL>    watcher.on(actions.tabGotWebContents, async (store, action) => {<EOL>        const { tab, webContentsId } = action.payload;<EOL>        logger.debug(`<STR_LIT>`);<EOL>        const wc = webContents.fromId(webContentsId) as ExtendedWebContents;<EOL>        if (!wc) {<EOL>            logger.warn(`<STR_LIT>`);<EOL>            return;<EOL>        }<EOL>        let pushWeb = (web: Partial<ITabWeb>) => {<EOL>            store.dispatch(actions.tabDataFetched({<EOL>                tab,<EOL>                data: {<EOL>                    web,<EOL>                },<EOL>            }));<EOL>        };<EOL>        pushWeb({ webContentsId, loading: wc.isLoading() });<EOL>        const sp = Space.fromStore(store, tab);<EOL>        const didNavigate = (url: string, replace?: boolean) => {<EOL>            if (sp.isFrozen()) {<EOL>                return;<EOL>            }<EOL>            if (url !== \"<STR_LIT>\") {<EOL>                const resource = parseWellKnownUrl(url);<EOL>                store.dispatch(actions.evolveTab({<EOL>                    tab,<EOL>                    url,<EOL>                    resource,<EOL>                    replace,<EOL>                }));<EOL>            }<EOL>        };<EOL>        logger.debug(`<STR_LIT>`);<EOL>        didNavigate(wc.getURL(), true);<EOL>        if (sp.isFrozen()) {<EOL>            wc.on(\"<STR_LIT>\", (ev, url) => {<EOL>                ev.preventDefault();<EOL>                store.dispatch(actions.navigate({ url }));<EOL>            });<EOL>        }<EOL>        <EOL>        <EOL>        wc.once(\"<STR_LIT>\", () => {<EOL>            logger.debug(`<STR_LIT>`);<EOL>            if (DONT_SHOW_WEBVIEWS) {<EOL>                return;<EOL>            }<EOL>            createContextMenu(wc, store);<EOL>            if (","gt":"SHOW_DEVTOOLS) {"}
{"input":"<s> export default function (watcher: Watcher, db: DB) {<EOL>    watcher.on(actions.tabGotWebContents, async (store, action) => {<EOL>        const { tab, webContentsId } = action.payload;<EOL>        logger.debug(`<STR_LIT>`);<EOL>        const wc = webContents.fromId(webContentsId) as ExtendedWebContents;<EOL>        if (!wc) {<EOL>            logger.warn(`<STR_LIT>`);<EOL>            return;<EOL>        }<EOL>        let pushWeb = (web: Partial<ITabWeb>) => {<EOL>            store.dispatch(actions.tabDataFetched({<EOL>                tab,<EOL>                data: {<EOL>                    web,<EOL>                },<EOL>            }));<EOL>        };<EOL>        pushWeb({ webContentsId, loading: wc.isLoading() });<EOL>        const sp = Space.fromStore(store, tab);<EOL>        const didNavigate = (url: string, replace?: boolean) => {<EOL>            if (sp.isFrozen()) {<EOL>                return;<EOL>            }<EOL>            if (url !== \"<STR_LIT>\") {<EOL>                const resource = parseWellKnownUrl(url);<EOL>                store.dispatch(actions.evolveTab({<EOL>                    tab,<EOL>                    url,<EOL>                    resource,<EOL>                    replace,<EOL>                }));<EOL>            }<EOL>        };<EOL>        logger.debug(`<STR_LIT>`);<EOL>        didNavigate(wc.getURL(), true);<EOL>        if (sp.isFrozen()) {<EOL>            wc.on(\"<STR_LIT>\", (ev, url) => {<EOL>                ev.preventDefault();<EOL>                store.dispatch(actions.navigate({ url }));<EOL>            });<EOL>        }<EOL>        <EOL>        <EOL>        wc.once(\"<STR_LIT>\", () => {<EOL>            logger.debug(`<STR_LIT>`);<EOL>            if (DONT_SHOW_WEBVIEWS) {<EOL>                return;<EOL>            }<EOL>            createContextMenu(wc, store);<EOL>            if (SHOW_DEVTOOLS) {<EOL>                wc.openDevTools({ mode: \"<STR_LIT>\" });<EOL>            }<EOL>        });<EOL>        wc.on(","gt":"\"<STR_LIT>\", () => {"}
{"input":"<s> export default function (watcher: Watcher, db: DB) {<EOL>    watcher.on(actions.tabGotWebContents, async (store, action) => {<EOL>        const { tab, webContentsId } = action.payload;<EOL>        logger.debug(`<STR_LIT>`);<EOL>        const wc = webContents.fromId(webContentsId) as ExtendedWebContents;<EOL>        if (!wc) {<EOL>            logger.warn(`<STR_LIT>`);<EOL>            return;<EOL>        }<EOL>        let pushWeb = (web: Partial<ITabWeb>) => {<EOL>            store.dispatch(actions.tabDataFetched({<EOL>                tab,<EOL>                data: {<EOL>                    web,<EOL>                },<EOL>            }));<EOL>        };<EOL>        pushWeb({ webContentsId, loading: wc.isLoading() });<EOL>        const sp = Space.fromStore(store, tab);<EOL>        const didNavigate = (url: string, replace?: boolean) => {<EOL>            if (sp.isFrozen()) {<EOL>                return;<EOL>            }<EOL>            if (url !== \"<STR_LIT>\") {<EOL>                const resource = parseWellKnownUrl(url);<EOL>                store.dispatch(actions.evolveTab({<EOL>                    tab,<EOL>                    url,<EOL>                    resource,<EOL>                    replace,<EOL>                }));<EOL>            }<EOL>        };<EOL>        logger.debug(`<STR_LIT>`);<EOL>        didNavigate(wc.getURL(), true);<EOL>        if (sp.isFrozen()) {<EOL>            wc.on(\"<STR_LIT>\", (ev, url) => {<EOL>                ev.preventDefault();<EOL>                store.dispatch(actions.navigate({ url }));<EOL>            });<EOL>        }<EOL>        <EOL>        <EOL>        wc.once(\"<STR_LIT>\", () => {<EOL>            logger.debug(`<STR_LIT>`);<EOL>            if (DONT_SHOW_WEBVIEWS) {<EOL>                return;<EOL>            }<EOL>            createContextMenu(wc, store);<EOL>            if (SHOW_DEVTOOLS) {<EOL>                wc.openDevTools({ mode: \"<STR_LIT>\" });<EOL>            }<EOL>        });<EOL>        wc.on(\"<STR_LIT>\", () => {<EOL>            logger.debug(`<STR_LIT>`);<EOL>            wc.executeJavaScript(`<STR_LIT>`, false);<EOL>            store.dispatch(actions.analyzePage({<EOL>                tab,<EOL>                url: wc.getURL(),<EOL>                iframe: false,<EOL>            }));<EOL>        });<EOL>        wc.on(\"<STR_LIT>\", () => {<EOL>            pushWeb({ loading: true });<EOL>        });<EOL>        wc.on(\"<STR_LIT>\", () => {<EOL>            pushWeb({ loading: false });<EOL>        });<EOL>        <EOL>        <EOL>        wc.on(\"<STR_LIT>\", (ev, favicons) => {<EOL>            pushWeb({ favicon: favicons[<NUM_LIT>] });<EOL>        });<EOL>","gt":"wc.on(\"<STR_LIT>\", (ev, url, frameName, disposition, options, additionalFeatures) => {"}
{"input":"<s> export default function (watcher: Watcher, db: DB) {<EOL>    watcher.on(actions.tabGotWebContents, async (store, action) => {<EOL>        const { tab, webContentsId } = action.payload;<EOL>        logger.debug(`<STR_LIT>`);<EOL>        const wc = webContents.fromId(webContentsId) as ExtendedWebContents;<EOL>        if (!wc) {<EOL>            logger.warn(`<STR_LIT>`);<EOL>            return;<EOL>        }<EOL>        let pushWeb = (web: Partial<ITabWeb>) => {<EOL>            store.dispatch(actions.tabDataFetched({<EOL>                tab,<EOL>                data: {<EOL>                    web,<EOL>                },<EOL>            }));<EOL>        };<EOL>        pushWeb({ webContentsId, loading: wc.isLoading() });<EOL>        const sp = Space.fromStore(store, tab);<EOL>        const didNavigate = (url: string, replace?: boolean) => {<EOL>            if (sp.isFrozen()) {<EOL>                return;<EOL>            }<EOL>            if (url !== \"<STR_LIT>\") {<EOL>                const resource = parseWellKnownUrl(url);<EOL>                store.dispatch(actions.evolveTab({<EOL>                    tab,<EOL>                    url,<EOL>                    resource,<EOL>                    replace,<EOL>                }));<EOL>            }<EOL>        };<EOL>        logger.debug(`<STR_LIT>`);<EOL>        didNavigate(wc.getURL(), true);<EOL>        if (sp.isFrozen()) {<EOL>            wc.on(\"<STR_LIT>\", (ev, url) => {<EOL>                ev.preventDefault();<EOL>                store.dispatch(actions.navigate({ url }));<EOL>            });<EOL>        }<EOL>        <EOL>        <EOL>        wc.once(\"<STR_LIT>\", () => {<EOL>            logger.debug(`<STR_LIT>`);<EOL>            if (DONT_SHOW_WEBVIEWS) {<EOL>                return;<EOL>            }<EOL>            createContextMenu(wc, store);<EOL>            if (SHOW_DEVTOOLS) {<EOL>                wc.openDevTools({ mode: \"<STR_LIT>\" });<EOL>            }<EOL>        });<EOL>        wc.on(\"<STR_LIT>\", () => {<EOL>            logger.debug(`<STR_LIT>`);<EOL>            wc.executeJavaScript(`<STR_LIT>`, false);<EOL>            store.dispatch(actions.analyzePage({<EOL>                tab,<EOL>                url: wc.getURL(),<EOL>                iframe: false,<EOL>            }));<EOL>        });<EOL>        wc.on(\"<STR_LIT>\", () => {<EOL>            pushWeb({ loading: true });<EOL>        });<EOL>        wc.on(\"<STR_LIT>\", () => {<EOL>            pushWeb({ loading: false });<EOL>        });<EOL>        <EOL>        <EOL>        wc.on(\"<STR_LIT>\", (ev, favicons) => {<EOL>            pushWeb({ favicon: favicons[<NUM_LIT>] });<EOL>        });<EOL>        wc.on(\"<STR_LIT>\", (ev, url, frameName, disposition, options, additionalFeatures) => {<EOL>            const background = disposition === \"<STR_LIT>\";<EOL>            store.dispatch(actions.navigate({ url, background }));<EOL>        });<EOL>        wc.","gt":"on(\"<STR_LIT>\" as any, (event, url, inPage, replaceEntry) => {"}
{"input":"<s> export default function (watcher: Watcher, db: DB) {<EOL>    watcher.on(actions.tabGotWebContents, async (store, action) => {<EOL>        const { tab, webContentsId } = action.payload;<EOL>        logger.debug(`<STR_LIT>`);<EOL>        const wc = webContents.fromId(webContentsId) as ExtendedWebContents;<EOL>        if (!wc) {<EOL>            logger.warn(`<STR_LIT>`);<EOL>            return;<EOL>        }<EOL>        let pushWeb = (web: Partial<ITabWeb>) => {<EOL>            store.dispatch(actions.tabDataFetched({<EOL>                tab,<EOL>                data: {<EOL>                    web,<EOL>                },<EOL>            }));<EOL>        };<EOL>        pushWeb({ webContentsId, loading: wc.isLoading() });<EOL>        const sp = Space.fromStore(store, tab);<EOL>        const didNavigate = (url: string, replace?: boolean) => {<EOL>            if (sp.isFrozen()) {<EOL>                return;<EOL>            }<EOL>            if (url !== \"<STR_LIT>\") {<EOL>                const resource = parseWellKnownUrl(url);<EOL>                store.dispatch(actions.evolveTab({<EOL>                    tab,<EOL>                    url,<EOL>                    resource,<EOL>                    replace,<EOL>                }));<EOL>            }<EOL>        };<EOL>        logger.debug(`<STR_LIT>`);<EOL>        didNavigate(wc.getURL(), true);<EOL>        if (sp.isFrozen()) {<EOL>            wc.on(\"<STR_LIT>\", (ev, url) => {<EOL>                ev.preventDefault();<EOL>                store.dispatch(actions.navigate({ url }));<EOL>            });<EOL>        }<EOL>        <EOL>        <EOL>        wc.once(\"<STR_LIT>\", () => {<EOL>            logger.debug(`<STR_LIT>`);<EOL>            if (DONT_SHOW_WEBVIEWS) {<EOL>                return;<EOL>            }<EOL>            createContextMenu(wc, store);<EOL>            if (SHOW_DEVTOOLS) {<EOL>                wc.openDevTools({ mode: \"<STR_LIT>\" });<EOL>            }<EOL>        });<EOL>        wc.on(\"<STR_LIT>\", () => {<EOL>            logger.debug(`<STR_LIT>`);<EOL>            wc.executeJavaScript(`<STR_LIT>`, false);<EOL>            store.dispatch(actions.analyzePage({<EOL>                tab,<EOL>                url: wc.getURL(),<EOL>                iframe: false,<EOL>            }));<EOL>        });<EOL>        wc.on(\"<STR_LIT>\", () => {<EOL>            pushWeb({ loading: true });<EOL>        });<EOL>        wc.on(\"<STR_LIT>\", () => {<EOL>            pushWeb({ loading: false });<EOL>        });<EOL>        <EOL>        <EOL>        wc.on(\"<STR_LIT>\", (ev, favicons) => {<EOL>            pushWeb({ favicon: favicons[<NUM_LIT>] });<EOL>        });<EOL>        wc.on(\"<STR_LIT>\", (ev, url, frameName, disposition, options, additionalFeatures) => {<EOL>            const background = disposition === \"<STR_LIT>\";<EOL>            store.dispatch(actions.navigate({ url, background }));<EOL>        });<EOL>        wc.on(\"<STR_LIT>\" as any, (event, url, inPage, replaceEntry) => {<EOL>            logger.debug(`<STR_LIT>`);<EOL>            logger.debug(`<STR_LIT>`);<EOL>            logger.debug(","gt":"JSON.stringify(wc.history, null, <NUM_LIT>)}`<STR_LIT>;"}
{"input":"<s> export default function (watcher: Watcher, db: DB) {<EOL>    watcher.on(actions.tabGotWebContents, async (store, action) => {<EOL>        const { tab, webContentsId } = action.payload;<EOL>        logger.debug(`<STR_LIT>`);<EOL>        const wc = webContents.fromId(webContentsId) as ExtendedWebContents;<EOL>        if (!wc) {<EOL>            logger.warn(`<STR_LIT>`);<EOL>            return;<EOL>        }<EOL>        let pushWeb = (web: Partial<ITabWeb>) => {<EOL>            store.dispatch(actions.tabDataFetched({<EOL>                tab,<EOL>                data: {<EOL>                    web,<EOL>                },<EOL>            }));<EOL>        };<EOL>        pushWeb({ webContentsId, loading: wc.isLoading() });<EOL>        const sp = Space.fromStore(store, tab);<EOL>        const didNavigate = (url: string, replace?: boolean) => {<EOL>            if (sp.isFrozen()) {<EOL>                return;<EOL>            }<EOL>            if (url !== \"<STR_LIT>\") {<EOL>                const resource = parseWellKnownUrl(url);<EOL>                store.dispatch(actions.evolveTab({<EOL>                    tab,<EOL>                    url,<EOL>                    resource,<EOL>                    replace,<EOL>                }));<EOL>            }<EOL>        };<EOL>        logger.debug(`<STR_LIT>`);<EOL>        didNavigate(wc.getURL(), true);<EOL>        if (sp.isFrozen()) {<EOL>            wc.on(\"<STR_LIT>\", (ev, url) => {<EOL>                ev.preventDefault();<EOL>                store.dispatch(actions.navigate({ url }));<EOL>            });<EOL>        }<EOL>        <EOL>        <EOL>        wc.once(\"<STR_LIT>\", () => {<EOL>            logger.debug(`<STR_LIT>`);<EOL>            if (DONT_SHOW_WEBVIEWS) {<EOL>                return;<EOL>            }<EOL>            createContextMenu(wc, store);<EOL>            if (SHOW_DEVTOOLS) {<EOL>                wc.openDevTools({ mode: \"<STR_LIT>\" });<EOL>            }<EOL>        });<EOL>        wc.on(\"<STR_LIT>\", () => {<EOL>            logger.debug(`<STR_LIT>`);<EOL>            wc.executeJavaScript(`<STR_LIT>`, false);<EOL>            store.dispatch(actions.analyzePage({<EOL>                tab,<EOL>                url: wc.getURL(),<EOL>                iframe: false,<EOL>            }));<EOL>        });<EOL>        wc.on(\"<STR_LIT>\", () => {<EOL>            pushWeb({ loading: true });<EOL>        });<EOL>        wc.on(\"<STR_LIT>\", () => {<EOL>            pushWeb({ loading: false });<EOL>        });<EOL>        <EOL>        <EOL>        wc.on(\"<STR_LIT>\", (ev, favicons) => {<EOL>            pushWeb({ favicon: favicons[<NUM_LIT>] });<EOL>        });<EOL>        wc.on(\"<STR_LIT>\", (ev, url, frameName, disposition, options, additionalFeatures) => {<EOL>            const background = disposition === \"<STR_LIT>\";<EOL>            store.dispatch(actions.navigate({ url, background }));<EOL>        });<EOL>        wc.on(\"<STR_LIT>\" as any, (event, url, inPage, replaceEntry) => {<EOL>            logger.debug(`<STR_LIT>`);<EOL>            logger.debug(`<STR_LIT>`);<EOL>            logger.debug(`<STR_LIT>`);<EOL>            logger.debug(`<STR_LIT>`);<EOL>            logger.debug(`<STR_LIT>`);<EOL>            didNavigate(url, replaceEntry);<EOL>            logger.debug(`<STR_LIT>`);<EOL>        });<EOL>    });<EOL>    watcher.on(","gt":"actions.analyzePage, async (store, action) => {"}
{"input":"<s> export default function (watcher: Watcher, db: DB) {<EOL>    watcher.on(actions.tabGotWebContents, async (store, action) => {<EOL>        const { tab, webContentsId } = action.payload;<EOL>        logger.debug(`<STR_LIT>`);<EOL>        const wc = webContents.fromId(webContentsId) as ExtendedWebContents;<EOL>        if (!wc) {<EOL>            logger.warn(`<STR_LIT>`);<EOL>            return;<EOL>        }<EOL>        let pushWeb = (web: Partial<ITabWeb>) => {<EOL>            store.dispatch(actions.tabDataFetched({<EOL>                tab,<EOL>                data: {<EOL>                    web,<EOL>                },<EOL>            }));<EOL>        };<EOL>        pushWeb({ webContentsId, loading: wc.isLoading() });<EOL>        const sp = Space.fromStore(store, tab);<EOL>        const didNavigate = (url: string, replace?: boolean) => {<EOL>            if (sp.isFrozen()) {<EOL>                return;<EOL>            }<EOL>            if (url !== \"<STR_LIT>\") {<EOL>                const resource = parseWellKnownUrl(url);<EOL>                store.dispatch(actions.evolveTab({<EOL>                    tab,<EOL>                    url,<EOL>                    resource,<EOL>                    replace,<EOL>                }));<EOL>            }<EOL>        };<EOL>        logger.debug(`<STR_LIT>`);<EOL>        didNavigate(wc.getURL(), true);<EOL>        if (sp.isFrozen()) {<EOL>            wc.on(\"<STR_LIT>\", (ev, url) => {<EOL>                ev.preventDefault();<EOL>                store.dispatch(actions.navigate({ url }));<EOL>            });<EOL>        }<EOL>        <EOL>        <EOL>        wc.once(\"<STR_LIT>\", () => {<EOL>            logger.debug(`<STR_LIT>`);<EOL>            if (DONT_SHOW_WEBVIEWS) {<EOL>                return;<EOL>            }<EOL>            createContextMenu(wc, store);<EOL>            if (SHOW_DEVTOOLS) {<EOL>                wc.openDevTools({ mode: \"<STR_LIT>\" });<EOL>            }<EOL>        });<EOL>        wc.on(\"<STR_LIT>\", () => {<EOL>            logger.debug(`<STR_LIT>`);<EOL>            wc.executeJavaScript(`<STR_LIT>`, false);<EOL>            store.dispatch(actions.analyzePage({<EOL>                tab,<EOL>                url: wc.getURL(),<EOL>                iframe: false,<EOL>            }));<EOL>        });<EOL>        wc.on(\"<STR_LIT>\", () => {<EOL>            pushWeb({ loading: true });<EOL>        });<EOL>        wc.on(\"<STR_LIT>\", () => {<EOL>            pushWeb({ loading: false });<EOL>        });<EOL>        <EOL>        <EOL>        wc.on(\"<STR_LIT>\", (ev, favicons) => {<EOL>            pushWeb({ favicon: favicons[<NUM_LIT>] });<EOL>        });<EOL>        wc.on(\"<STR_LIT>\", (ev, url, frameName, disposition, options, additionalFeatures) => {<EOL>            const background = disposition === \"<STR_LIT>\";<EOL>            store.dispatch(actions.navigate({ url, background }));<EOL>        });<EOL>        wc.on(\"<STR_LIT>\" as any, (event, url, inPage, replaceEntry) => {<EOL>            logger.debug(`<STR_LIT>`);<EOL>            logger.debug(`<STR_LIT>`);<EOL>            logger.debug(`<STR_LIT>`);<EOL>            logger.debug(`<STR_LIT>`);<EOL>            logger.debug(`<STR_LIT>`);<EOL>            didNavigate(url, replaceEntry);<EOL>            logger.debug(`<STR_LIT>`);<EOL>        });<EOL>    });<EOL>    watcher.on(actions.analyzePage, async (store, action) => {<EOL>        const { tab, url, iframe } = action.payload;<EOL>        await withWebContents(store, tab, async (wc) => {<EOL>            const sp = Space.fromStore(store, tab);<EOL>            if (sp.isFrozen()) {<EOL>                logger.debug(`<STR_LIT>`);<EOL>","gt":"return;"}
{"input":"<s> export default function (watcher: Watcher, db: DB) {<EOL>    watcher.on(actions.tabGotWebContents, async (store, action) => {<EOL>        const { tab, webContentsId } = action.payload;<EOL>        logger.debug(`<STR_LIT>`);<EOL>        const wc = webContents.fromId(webContentsId) as ExtendedWebContents;<EOL>        if (!wc) {<EOL>            logger.warn(`<STR_LIT>`);<EOL>            return;<EOL>        }<EOL>        let pushWeb = (web: Partial<ITabWeb>) => {<EOL>            store.dispatch(actions.tabDataFetched({<EOL>                tab,<EOL>                data: {<EOL>                    web,<EOL>                },<EOL>            }));<EOL>        };<EOL>        pushWeb({ webContentsId, loading: wc.isLoading() });<EOL>        const sp = Space.fromStore(store, tab);<EOL>        const didNavigate = (url: string, replace?: boolean) => {<EOL>            if (sp.isFrozen()) {<EOL>                return;<EOL>            }<EOL>            if (url !== \"<STR_LIT>\") {<EOL>                const resource = parseWellKnownUrl(url);<EOL>                store.dispatch(actions.evolveTab({<EOL>                    tab,<EOL>                    url,<EOL>                    resource,<EOL>                    replace,<EOL>                }));<EOL>            }<EOL>        };<EOL>        logger.debug(`<STR_LIT>`);<EOL>        didNavigate(wc.getURL(), true);<EOL>        if (sp.isFrozen()) {<EOL>            wc.on(\"<STR_LIT>\", (ev, url) => {<EOL>                ev.preventDefault();<EOL>                store.dispatch(actions.navigate({ url }));<EOL>            });<EOL>        }<EOL>        <EOL>        <EOL>        wc.once(\"<STR_LIT>\", () => {<EOL>            logger.debug(`<STR_LIT>`);<EOL>            if (DONT_SHOW_WEBVIEWS) {<EOL>                return;<EOL>            }<EOL>            createContextMenu(wc, store);<EOL>            if (SHOW_DEVTOOLS) {<EOL>                wc.openDevTools({ mode: \"<STR_LIT>\" });<EOL>            }<EOL>        });<EOL>        wc.on(\"<STR_LIT>\", () => {<EOL>            logger.debug(`<STR_LIT>`);<EOL>            wc.executeJavaScript(`<STR_LIT>`, false);<EOL>            store.dispatch(actions.analyzePage({<EOL>                tab,<EOL>                url: wc.getURL(),<EOL>                iframe: false,<EOL>            }));<EOL>        });<EOL>        wc.on(\"<STR_LIT>\", () => {<EOL>            pushWeb({ loading: true });<EOL>        });<EOL>        wc.on(\"<STR_LIT>\", () => {<EOL>            pushWeb({ loading: false });<EOL>        });<EOL>        <EOL>        <EOL>        wc.on(\"<STR_LIT>\", (ev, favicons) => {<EOL>            pushWeb({ favicon: favicons[<NUM_LIT>] });<EOL>        });<EOL>        wc.on(\"<STR_LIT>\", (ev, url, frameName, disposition, options, additionalFeatures) => {<EOL>            const background = disposition === \"<STR_LIT>\";<EOL>            store.dispatch(actions.navigate({ url, background }));<EOL>        });<EOL>        wc.on(\"<STR_LIT>\" as any, (event, url, inPage, replaceEntry) => {<EOL>            logger.debug(`<STR_LIT>`);<EOL>            logger.debug(`<STR_LIT>`);<EOL>            logger.debug(`<STR_LIT>`);<EOL>            logger.debug(`<STR_LIT>`);<EOL>            logger.debug(`<STR_LIT>`);<EOL>            didNavigate(url, replaceEntry);<EOL>            logger.debug(`<STR_LIT>`);<EOL>        });<EOL>    });<EOL>    watcher.on(actions.analyzePage, async (store, action) => {<EOL>        const { tab, url, iframe } = action.payload;<EOL>        await withWebContents(store, tab, async (wc) => {<EOL>            const sp = Space.fromStore(store, tab);<EOL>            if (sp.isFrozen()) {<EOL>                logger.debug(`<STR_LIT>`);<EOL>                return;<EOL>            }<EOL>            const onNewPath = (url: string, resource: string) => {<EOL>                if (resource) {<EOL>                    <EOL>                    <EOL>                    logger.debug(`<STR_LIT>`);<EOL>                    store.dispatch(actions.evolveTab({<EOL>                        tab: tab,<EOL>                        url,<EOL>                        resource,<EOL>","gt":"replace: true,"}
{"input":"<s> export default function (watcher: Watcher, db: DB) {<EOL>    watcher.on(actions.tabGotWebContents, async (store, action) => {<EOL>        const { tab, webContentsId } = action.payload;<EOL>        logger.debug(`<STR_LIT>`);<EOL>        const wc = webContents.fromId(webContentsId) as ExtendedWebContents;<EOL>        if (!wc) {<EOL>            logger.warn(`<STR_LIT>`);<EOL>            return;<EOL>        }<EOL>        let pushWeb = (web: Partial<ITabWeb>) => {<EOL>            store.dispatch(actions.tabDataFetched({<EOL>                tab,<EOL>                data: {<EOL>                    web,<EOL>                },<EOL>            }));<EOL>        };<EOL>        pushWeb({ webContentsId, loading: wc.isLoading() });<EOL>        const sp = Space.fromStore(store, tab);<EOL>        const didNavigate = (url: string, replace?: boolean) => {<EOL>            if (sp.isFrozen()) {<EOL>                return;<EOL>            }<EOL>            if (url !== \"<STR_LIT>\") {<EOL>                const resource = parseWellKnownUrl(url);<EOL>                store.dispatch(actions.evolveTab({<EOL>                    tab,<EOL>                    url,<EOL>                    resource,<EOL>                    replace,<EOL>                }));<EOL>            }<EOL>        };<EOL>        logger.debug(`<STR_LIT>`);<EOL>        didNavigate(wc.getURL(), true);<EOL>        if (sp.isFrozen()) {<EOL>            wc.on(\"<STR_LIT>\", (ev, url) => {<EOL>                ev.preventDefault();<EOL>                store.dispatch(actions.navigate({ url }));<EOL>            });<EOL>        }<EOL>        <EOL>        <EOL>        wc.once(\"<STR_LIT>\", () => {<EOL>            logger.debug(`<STR_LIT>`);<EOL>            if (DONT_SHOW_WEBVIEWS) {<EOL>                return;<EOL>            }<EOL>            createContextMenu(wc, store);<EOL>            if (SHOW_DEVTOOLS) {<EOL>                wc.openDevTools({ mode: \"<STR_LIT>\" });<EOL>            }<EOL>        });<EOL>        wc.on(\"<STR_LIT>\", () => {<EOL>            logger.debug(`<STR_LIT>`);<EOL>            wc.executeJavaScript(`<STR_LIT>`, false);<EOL>            store.dispatch(actions.analyzePage({<EOL>                tab,<EOL>                url: wc.getURL(),<EOL>                iframe: false,<EOL>            }));<EOL>        });<EOL>        wc.on(\"<STR_LIT>\", () => {<EOL>            pushWeb({ loading: true });<EOL>        });<EOL>        wc.on(\"<STR_LIT>\", () => {<EOL>            pushWeb({ loading: false });<EOL>        });<EOL>        <EOL>        <EOL>        wc.on(\"<STR_LIT>\", (ev, favicons) => {<EOL>            pushWeb({ favicon: favicons[<NUM_LIT>] });<EOL>        });<EOL>        wc.on(\"<STR_LIT>\", (ev, url, frameName, disposition, options, additionalFeatures) => {<EOL>            const background = disposition === \"<STR_LIT>\";<EOL>            store.dispatch(actions.navigate({ url, background }));<EOL>        });<EOL>        wc.on(\"<STR_LIT>\" as any, (event, url, inPage, replaceEntry) => {<EOL>            logger.debug(`<STR_LIT>`);<EOL>            logger.debug(`<STR_LIT>`);<EOL>            logger.debug(`<STR_LIT>`);<EOL>            logger.debug(`<STR_LIT>`);<EOL>            logger.debug(`<STR_LIT>`);<EOL>            didNavigate(url, replaceEntry);<EOL>            logger.debug(`<STR_LIT>`);<EOL>        });<EOL>    });<EOL>    watcher.on(actions.analyzePage, async (store, action) => {<EOL>        const { tab, url, iframe } = action.payload;<EOL>        await withWebContents(store, tab, async (wc) => {<EOL>            const sp = Space.fromStore(store, tab);<EOL>            if (sp.isFrozen()) {<EOL>                logger.debug(`<STR_LIT>`);<EOL>                return;<EOL>            }<EOL>            const onNewPath = (url: string, resource: string) => {<EOL>                if (resource) {<EOL>                    <EOL>                    <EOL>                    logger.debug(`<STR_LIT>`);<EOL>                    store.dispatch(actions.evolveTab({<EOL>                        tab: tab,<EOL>                        url,<EOL>                        resource,<EOL>                        replace: true,<EOL>                    }));<EOL>                    const parsed = urlParser.","gt":"parse(url);"}
{"input":"<s> export default function (watcher: Watcher, db: DB) {<EOL>    watcher.on(actions.tabGotWebContents, async (store, action) => {<EOL>        const { tab, webContentsId } = action.payload;<EOL>        logger.debug(`<STR_LIT>`);<EOL>        const wc = webContents.fromId(webContentsId) as ExtendedWebContents;<EOL>        if (!wc) {<EOL>            logger.warn(`<STR_LIT>`);<EOL>            return;<EOL>        }<EOL>        let pushWeb = (web: Partial<ITabWeb>) => {<EOL>            store.dispatch(actions.tabDataFetched({<EOL>                tab,<EOL>                data: {<EOL>                    web,<EOL>                },<EOL>            }));<EOL>        };<EOL>        pushWeb({ webContentsId, loading: wc.isLoading() });<EOL>        const sp = Space.fromStore(store, tab);<EOL>        const didNavigate = (url: string, replace?: boolean) => {<EOL>            if (sp.isFrozen()) {<EOL>                return;<EOL>            }<EOL>            if (url !== \"<STR_LIT>\") {<EOL>                const resource = parseWellKnownUrl(url);<EOL>                store.dispatch(actions.evolveTab({<EOL>                    tab,<EOL>                    url,<EOL>                    resource,<EOL>                    replace,<EOL>                }));<EOL>            }<EOL>        };<EOL>        logger.debug(`<STR_LIT>`);<EOL>        didNavigate(wc.getURL(), true);<EOL>        if (sp.isFrozen()) {<EOL>            wc.on(\"<STR_LIT>\", (ev, url) => {<EOL>                ev.preventDefault();<EOL>                store.dispatch(actions.navigate({ url }));<EOL>            });<EOL>        }<EOL>        <EOL>        <EOL>        wc.once(\"<STR_LIT>\", () => {<EOL>            logger.debug(`<STR_LIT>`);<EOL>            if (DONT_SHOW_WEBVIEWS) {<EOL>                return;<EOL>            }<EOL>            createContextMenu(wc, store);<EOL>            if (SHOW_DEVTOOLS) {<EOL>                wc.openDevTools({ mode: \"<STR_LIT>\" });<EOL>            }<EOL>        });<EOL>        wc.on(\"<STR_LIT>\", () => {<EOL>            logger.debug(`<STR_LIT>`);<EOL>            wc.executeJavaScript(`<STR_LIT>`, false);<EOL>            store.dispatch(actions.analyzePage({<EOL>                tab,<EOL>                url: wc.getURL(),<EOL>                iframe: false,<EOL>            }));<EOL>        });<EOL>        wc.on(\"<STR_LIT>\", () => {<EOL>            pushWeb({ loading: true });<EOL>        });<EOL>        wc.on(\"<STR_LIT>\", () => {<EOL>            pushWeb({ loading: false });<EOL>        });<EOL>        <EOL>        <EOL>        wc.on(\"<STR_LIT>\", (ev, favicons) => {<EOL>            pushWeb({ favicon: favicons[<NUM_LIT>] });<EOL>        });<EOL>        wc.on(\"<STR_LIT>\", (ev, url, frameName, disposition, options, additionalFeatures) => {<EOL>            const background = disposition === \"<STR_LIT>\";<EOL>            store.dispatch(actions.navigate({ url, background }));<EOL>        });<EOL>        wc.on(\"<STR_LIT>\" as any, (event, url, inPage, replaceEntry) => {<EOL>            logger.debug(`<STR_LIT>`);<EOL>            logger.debug(`<STR_LIT>`);<EOL>            logger.debug(`<STR_LIT>`);<EOL>            logger.debug(`<STR_LIT>`);<EOL>            logger.debug(`<STR_LIT>`);<EOL>            didNavigate(url, replaceEntry);<EOL>            logger.debug(`<STR_LIT>`);<EOL>        });<EOL>    });<EOL>    watcher.on(actions.analyzePage, async (store, action) => {<EOL>        const { tab, url, iframe } = action.payload;<EOL>        await withWebContents(store, tab, async (wc) => {<EOL>            const sp = Space.fromStore(store, tab);<EOL>            if (sp.isFrozen()) {<EOL>                logger.debug(`<STR_LIT>`);<EOL>                return;<EOL>            }<EOL>            const onNewPath = (url: string, resource: string) => {<EOL>                if (resource) {<EOL>                    <EOL>                    <EOL>                    logger.debug(`<STR_LIT>`);<EOL>                    store.dispatch(actions.evolveTab({<EOL>                        tab: tab,<EOL>                        url,<EOL>                        resource,<EOL>                        replace: true,<EOL>                    }));<EOL>                    const parsed = urlParser.parse(url);<EOL>                    if (parsed.search) {<EOL>                        doSave(resource, parsed.","gt":"search, db);"}
{"input":"<s> export default function (watcher: Watcher, db: DB) {<EOL>    watcher.on(actions.tabGotWebContents, async (store, action) => {<EOL>        const { tab, webContentsId } = action.payload;<EOL>        logger.debug(`<STR_LIT>`);<EOL>        const wc = webContents.fromId(webContentsId) as ExtendedWebContents;<EOL>        if (!wc) {<EOL>            logger.warn(`<STR_LIT>`);<EOL>            return;<EOL>        }<EOL>        let pushWeb = (web: Partial<ITabWeb>) => {<EOL>            store.dispatch(actions.tabDataFetched({<EOL>                tab,<EOL>                data: {<EOL>                    web,<EOL>                },<EOL>            }));<EOL>        };<EOL>        pushWeb({ webContentsId, loading: wc.isLoading() });<EOL>        const sp = Space.fromStore(store, tab);<EOL>        const didNavigate = (url: string, replace?: boolean) => {<EOL>            if (sp.isFrozen()) {<EOL>                return;<EOL>            }<EOL>            if (url !== \"<STR_LIT>\") {<EOL>                const resource = parseWellKnownUrl(url);<EOL>                store.dispatch(actions.evolveTab({<EOL>                    tab,<EOL>                    url,<EOL>                    resource,<EOL>                    replace,<EOL>                }));<EOL>            }<EOL>        };<EOL>        logger.debug(`<STR_LIT>`);<EOL>        didNavigate(wc.getURL(), true);<EOL>        if (sp.isFrozen()) {<EOL>            wc.on(\"<STR_LIT>\", (ev, url) => {<EOL>                ev.preventDefault();<EOL>                store.dispatch(actions.navigate({ url }));<EOL>            });<EOL>        }<EOL>        <EOL>        <EOL>        wc.once(\"<STR_LIT>\", () => {<EOL>            logger.debug(`<STR_LIT>`);<EOL>            if (DONT_SHOW_WEBVIEWS) {<EOL>                return;<EOL>            }<EOL>            createContextMenu(wc, store);<EOL>            if (SHOW_DEVTOOLS) {<EOL>                wc.openDevTools({ mode: \"<STR_LIT>\" });<EOL>            }<EOL>        });<EOL>        wc.on(\"<STR_LIT>\", () => {<EOL>            logger.debug(`<STR_LIT>`);<EOL>            wc.executeJavaScript(`<STR_LIT>`, false);<EOL>            store.dispatch(actions.analyzePage({<EOL>                tab,<EOL>                url: wc.getURL(),<EOL>                iframe: false,<EOL>            }));<EOL>        });<EOL>        wc.on(\"<STR_LIT>\", () => {<EOL>            pushWeb({ loading: true });<EOL>        });<EOL>        wc.on(\"<STR_LIT>\", () => {<EOL>            pushWeb({ loading: false });<EOL>        });<EOL>        <EOL>        <EOL>        wc.on(\"<STR_LIT>\", (ev, favicons) => {<EOL>            pushWeb({ favicon: favicons[<NUM_LIT>] });<EOL>        });<EOL>        wc.on(\"<STR_LIT>\", (ev, url, frameName, disposition, options, additionalFeatures) => {<EOL>            const background = disposition === \"<STR_LIT>\";<EOL>            store.dispatch(actions.navigate({ url, background }));<EOL>        });<EOL>        wc.on(\"<STR_LIT>\" as any, (event, url, inPage, replaceEntry) => {<EOL>            logger.debug(`<STR_LIT>`);<EOL>            logger.debug(`<STR_LIT>`);<EOL>            logger.debug(`<STR_LIT>`);<EOL>            logger.debug(`<STR_LIT>`);<EOL>            logger.debug(`<STR_LIT>`);<EOL>            didNavigate(url, replaceEntry);<EOL>            logger.debug(`<STR_LIT>`);<EOL>        });<EOL>    });<EOL>    watcher.on(actions.analyzePage, async (store, action) => {<EOL>        const { tab, url, iframe } = action.payload;<EOL>        await withWebContents(store, tab, async (wc) => {<EOL>            const sp = Space.fromStore(store, tab);<EOL>            if (sp.isFrozen()) {<EOL>                logger.debug(`<STR_LIT>`);<EOL>                return;<EOL>            }<EOL>            const onNewPath = (url: string, resource: string) => {<EOL>                if (resource) {<EOL>                    <EOL>                    <EOL>                    logger.debug(`<STR_LIT>`);<EOL>                    store.dispatch(actions.evolveTab({<EOL>                        tab: tab,<EOL>                        url,<EOL>                        resource,<EOL>                        replace: true,<EOL>                    }));<EOL>                    const parsed = urlParser.parse(url);<EOL>                    if (parsed.search) {<EOL>                        doSave(resource, parsed.search, db);<EOL>                    }<EOL>                }<EOL>            };<EOL>            if (iframe) {<EOL>                const parsed = nodeURL.parse(url);<EOL>                const { host, protocol, pathname } = parsed;<EOL>                const dataURL = nodeURL.format({<EOL>","gt":"host,"}
{"input":"<s> export default function (watcher: Watcher, db: DB) {<EOL>    watcher.on(actions.tabGotWebContents, async (store, action) => {<EOL>        const { tab, webContentsId } = action.payload;<EOL>        logger.debug(`<STR_LIT>`);<EOL>        const wc = webContents.fromId(webContentsId) as ExtendedWebContents;<EOL>        if (!wc) {<EOL>            logger.warn(`<STR_LIT>`);<EOL>            return;<EOL>        }<EOL>        let pushWeb = (web: Partial<ITabWeb>) => {<EOL>            store.dispatch(actions.tabDataFetched({<EOL>                tab,<EOL>                data: {<EOL>                    web,<EOL>                },<EOL>            }));<EOL>        };<EOL>        pushWeb({ webContentsId, loading: wc.isLoading() });<EOL>        const sp = Space.fromStore(store, tab);<EOL>        const didNavigate = (url: string, replace?: boolean) => {<EOL>            if (sp.isFrozen()) {<EOL>                return;<EOL>            }<EOL>            if (url !== \"<STR_LIT>\") {<EOL>                const resource = parseWellKnownUrl(url);<EOL>                store.dispatch(actions.evolveTab({<EOL>                    tab,<EOL>                    url,<EOL>                    resource,<EOL>                    replace,<EOL>                }));<EOL>            }<EOL>        };<EOL>        logger.debug(`<STR_LIT>`);<EOL>        didNavigate(wc.getURL(), true);<EOL>        if (sp.isFrozen()) {<EOL>            wc.on(\"<STR_LIT>\", (ev, url) => {<EOL>                ev.preventDefault();<EOL>                store.dispatch(actions.navigate({ url }));<EOL>            });<EOL>        }<EOL>        <EOL>        <EOL>        wc.once(\"<STR_LIT>\", () => {<EOL>            logger.debug(`<STR_LIT>`);<EOL>            if (DONT_SHOW_WEBVIEWS) {<EOL>                return;<EOL>            }<EOL>            createContextMenu(wc, store);<EOL>            if (SHOW_DEVTOOLS) {<EOL>                wc.openDevTools({ mode: \"<STR_LIT>\" });<EOL>            }<EOL>        });<EOL>        wc.on(\"<STR_LIT>\", () => {<EOL>            logger.debug(`<STR_LIT>`);<EOL>            wc.executeJavaScript(`<STR_LIT>`, false);<EOL>            store.dispatch(actions.analyzePage({<EOL>                tab,<EOL>                url: wc.getURL(),<EOL>                iframe: false,<EOL>            }));<EOL>        });<EOL>        wc.on(\"<STR_LIT>\", () => {<EOL>            pushWeb({ loading: true });<EOL>        });<EOL>        wc.on(\"<STR_LIT>\", () => {<EOL>            pushWeb({ loading: false });<EOL>        });<EOL>        <EOL>        <EOL>        wc.on(\"<STR_LIT>\", (ev, favicons) => {<EOL>            pushWeb({ favicon: favicons[<NUM_LIT>] });<EOL>        });<EOL>        wc.on(\"<STR_LIT>\", (ev, url, frameName, disposition, options, additionalFeatures) => {<EOL>            const background = disposition === \"<STR_LIT>\";<EOL>            store.dispatch(actions.navigate({ url, background }));<EOL>        });<EOL>        wc.on(\"<STR_LIT>\" as any, (event, url, inPage, replaceEntry) => {<EOL>            logger.debug(`<STR_LIT>`);<EOL>            logger.debug(`<STR_LIT>`);<EOL>            logger.debug(`<STR_LIT>`);<EOL>            logger.debug(`<STR_LIT>`);<EOL>            logger.debug(`<STR_LIT>`);<EOL>            didNavigate(url, replaceEntry);<EOL>            logger.debug(`<STR_LIT>`);<EOL>        });<EOL>    });<EOL>    watcher.on(actions.analyzePage, async (store, action) => {<EOL>        const { tab, url, iframe } = action.payload;<EOL>        await withWebContents(store, tab, async (wc) => {<EOL>            const sp = Space.fromStore(store, tab);<EOL>            if (sp.isFrozen()) {<EOL>                logger.debug(`<STR_LIT>`);<EOL>                return;<EOL>            }<EOL>            const onNewPath = (url: string, resource: string) => {<EOL>                if (resource) {<EOL>                    <EOL>                    <EOL>                    logger.debug(`<STR_LIT>`);<EOL>                    store.dispatch(actions.evolveTab({<EOL>                        tab: tab,<EOL>                        url,<EOL>                        resource,<EOL>                        replace: true,<EOL>                    }));<EOL>                    const parsed = urlParser.parse(url);<EOL>                    if (parsed.search) {<EOL>                        doSave(resource, parsed.search, db);<EOL>                    }<EOL>                }<EOL>            };<EOL>            if (iframe) {<EOL>                const parsed = nodeURL.parse(url);<EOL>                const { host, protocol, pathname } = parsed;<EOL>                const dataURL = nodeURL.format({<EOL>                    host,<EOL>                    protocol,<EOL>                    pathname: `<STR_LIT>`,<EOL>                });<EOL>                const data = await request(\"<STR_LIT>\", dataURL, {}, { format: \"<STR_LIT>\" });<EOL>                if (data && data.body && data.body.id) {<EOL>                    onNewPath(wc.getURL(), `<STR_LIT>`);<EOL>                }<EOL>            }<EOL>            else {<EOL>                const code = `<STR_LIT>`;<EOL>                const newPath = await wc.executeJavaScript(code);<EOL>                onNewPath(url, newPath);<EOL>            }<EOL>        });<EOL>    });<EOL>    watcher.on(","gt":"actions.commandReload, async (store, action) => {"}
{"input":"<s> export default function (watcher: Watcher, db: DB) {<EOL>    watcher.on(actions.tabGotWebContents, async (store, action) => {<EOL>        const { tab, webContentsId } = action.payload;<EOL>        logger.debug(`<STR_LIT>`);<EOL>        const wc = webContents.fromId(webContentsId) as ExtendedWebContents;<EOL>        if (!wc) {<EOL>            logger.warn(`<STR_LIT>`);<EOL>            return;<EOL>        }<EOL>        let pushWeb = (web: Partial<ITabWeb>) => {<EOL>            store.dispatch(actions.tabDataFetched({<EOL>                tab,<EOL>                data: {<EOL>                    web,<EOL>                },<EOL>            }));<EOL>        };<EOL>        pushWeb({ webContentsId, loading: wc.isLoading() });<EOL>        const sp = Space.fromStore(store, tab);<EOL>        const didNavigate = (url: string, replace?: boolean) => {<EOL>            if (sp.isFrozen()) {<EOL>                return;<EOL>            }<EOL>            if (url !== \"<STR_LIT>\") {<EOL>                const resource = parseWellKnownUrl(url);<EOL>                store.dispatch(actions.evolveTab({<EOL>                    tab,<EOL>                    url,<EOL>                    resource,<EOL>                    replace,<EOL>                }));<EOL>            }<EOL>        };<EOL>        logger.debug(`<STR_LIT>`);<EOL>        didNavigate(wc.getURL(), true);<EOL>        if (sp.isFrozen()) {<EOL>            wc.on(\"<STR_LIT>\", (ev, url) => {<EOL>                ev.preventDefault();<EOL>                store.dispatch(actions.navigate({ url }));<EOL>            });<EOL>        }<EOL>        <EOL>        <EOL>        wc.once(\"<STR_LIT>\", () => {<EOL>            logger.debug(`<STR_LIT>`);<EOL>            if (DONT_SHOW_WEBVIEWS) {<EOL>                return;<EOL>            }<EOL>            createContextMenu(wc, store);<EOL>            if (SHOW_DEVTOOLS) {<EOL>                wc.openDevTools({ mode: \"<STR_LIT>\" });<EOL>            }<EOL>        });<EOL>        wc.on(\"<STR_LIT>\", () => {<EOL>            logger.debug(`<STR_LIT>`);<EOL>            wc.executeJavaScript(`<STR_LIT>`, false);<EOL>            store.dispatch(actions.analyzePage({<EOL>                tab,<EOL>                url: wc.getURL(),<EOL>                iframe: false,<EOL>            }));<EOL>        });<EOL>        wc.on(\"<STR_LIT>\", () => {<EOL>            pushWeb({ loading: true });<EOL>        });<EOL>        wc.on(\"<STR_LIT>\", () => {<EOL>            pushWeb({ loading: false });<EOL>        });<EOL>        <EOL>        <EOL>        wc.on(\"<STR_LIT>\", (ev, favicons) => {<EOL>            pushWeb({ favicon: favicons[<NUM_LIT>] });<EOL>        });<EOL>        wc.on(\"<STR_LIT>\", (ev, url, frameName, disposition, options, additionalFeatures) => {<EOL>            const background = disposition === \"<STR_LIT>\";<EOL>            store.dispatch(actions.navigate({ url, background }));<EOL>        });<EOL>        wc.on(\"<STR_LIT>\" as any, (event, url, inPage, replaceEntry) => {<EOL>            logger.debug(`<STR_LIT>`);<EOL>            logger.debug(`<STR_LIT>`);<EOL>            logger.debug(`<STR_LIT>`);<EOL>            logger.debug(`<STR_LIT>`);<EOL>            logger.debug(`<STR_LIT>`);<EOL>            didNavigate(url, replaceEntry);<EOL>            logger.debug(`<STR_LIT>`);<EOL>        });<EOL>    });<EOL>    watcher.on(actions.analyzePage, async (store, action) => {<EOL>        const { tab, url, iframe } = action.payload;<EOL>        await withWebContents(store, tab, async (wc) => {<EOL>            const sp = Space.fromStore(store, tab);<EOL>            if (sp.isFrozen()) {<EOL>                logger.debug(`<STR_LIT>`);<EOL>                return;<EOL>            }<EOL>            const onNewPath = (url: string, resource: string) => {<EOL>                if (resource) {<EOL>                    <EOL>                    <EOL>                    logger.debug(`<STR_LIT>`);<EOL>                    store.dispatch(actions.evolveTab({<EOL>                        tab: tab,<EOL>                        url,<EOL>                        resource,<EOL>                        replace: true,<EOL>                    }));<EOL>                    const parsed = urlParser.parse(url);<EOL>                    if (parsed.search) {<EOL>                        doSave(resource, parsed.search, db);<EOL>                    }<EOL>                }<EOL>            };<EOL>            if (iframe) {<EOL>                const parsed = nodeURL.parse(url);<EOL>                const { host, protocol, pathname } = parsed;<EOL>                const dataURL = nodeURL.format({<EOL>                    host,<EOL>                    protocol,<EOL>                    pathname: `<STR_LIT>`,<EOL>                });<EOL>                const data = await request(\"<STR_LIT>\", dataURL, {}, { format: \"<STR_LIT>\" });<EOL>                if (data && data.body && data.body.id) {<EOL>                    onNewPath(wc.getURL(), `<STR_LIT>`);<EOL>                }<EOL>            }<EOL>            else {<EOL>                const code = `<STR_LIT>`;<EOL>                const newPath = await wc.executeJavaScript(code);<EOL>                onNewPath(url, newPath);<EOL>            }<EOL>        });<EOL>    });<EOL>    watcher.on(actions.commandReload, async (store, action) => {<EOL>        const { tab } = store.getState().session.navigation;<EOL>        withWebContents(store, tab, wc => {<EOL>            wc.reload();<EOL>        });<EOL>    });<EOL>    watcher.on(actions.commandStop, async (store, action) => {<EOL>        const { tab } = store.getState().session.navigation;<EOL>        withWebContents(store, tab, wc => {<EOL>            wc.","gt":"stop();"}
{"input":"<s> export default function (watcher: Watcher, db: DB) {<EOL>    watcher.on(actions.tabGotWebContents, async (store, action) => {<EOL>        const { tab, webContentsId } = action.payload;<EOL>        logger.debug(`<STR_LIT>`);<EOL>        const wc = webContents.fromId(webContentsId) as ExtendedWebContents;<EOL>        if (!wc) {<EOL>            logger.warn(`<STR_LIT>`);<EOL>            return;<EOL>        }<EOL>        let pushWeb = (web: Partial<ITabWeb>) => {<EOL>            store.dispatch(actions.tabDataFetched({<EOL>                tab,<EOL>                data: {<EOL>                    web,<EOL>                },<EOL>            }));<EOL>        };<EOL>        pushWeb({ webContentsId, loading: wc.isLoading() });<EOL>        const sp = Space.fromStore(store, tab);<EOL>        const didNavigate = (url: string, replace?: boolean) => {<EOL>            if (sp.isFrozen()) {<EOL>                return;<EOL>            }<EOL>            if (url !== \"<STR_LIT>\") {<EOL>                const resource = parseWellKnownUrl(url);<EOL>                store.dispatch(actions.evolveTab({<EOL>                    tab,<EOL>                    url,<EOL>                    resource,<EOL>                    replace,<EOL>                }));<EOL>            }<EOL>        };<EOL>        logger.debug(`<STR_LIT>`);<EOL>        didNavigate(wc.getURL(), true);<EOL>        if (sp.isFrozen()) {<EOL>            wc.on(\"<STR_LIT>\", (ev, url) => {<EOL>                ev.preventDefault();<EOL>                store.dispatch(actions.navigate({ url }));<EOL>            });<EOL>        }<EOL>        <EOL>        <EOL>        wc.once(\"<STR_LIT>\", () => {<EOL>            logger.debug(`<STR_LIT>`);<EOL>            if (DONT_SHOW_WEBVIEWS) {<EOL>                return;<EOL>            }<EOL>            createContextMenu(wc, store);<EOL>            if (SHOW_DEVTOOLS) {<EOL>                wc.openDevTools({ mode: \"<STR_LIT>\" });<EOL>            }<EOL>        });<EOL>        wc.on(\"<STR_LIT>\", () => {<EOL>            logger.debug(`<STR_LIT>`);<EOL>            wc.executeJavaScript(`<STR_LIT>`, false);<EOL>            store.dispatch(actions.analyzePage({<EOL>                tab,<EOL>                url: wc.getURL(),<EOL>                iframe: false,<EOL>            }));<EOL>        });<EOL>        wc.on(\"<STR_LIT>\", () => {<EOL>            pushWeb({ loading: true });<EOL>        });<EOL>        wc.on(\"<STR_LIT>\", () => {<EOL>            pushWeb({ loading: false });<EOL>        });<EOL>        <EOL>        <EOL>        wc.on(\"<STR_LIT>\", (ev, favicons) => {<EOL>            pushWeb({ favicon: favicons[<NUM_LIT>] });<EOL>        });<EOL>        wc.on(\"<STR_LIT>\", (ev, url, frameName, disposition, options, additionalFeatures) => {<EOL>            const background = disposition === \"<STR_LIT>\";<EOL>            store.dispatch(actions.navigate({ url, background }));<EOL>        });<EOL>        wc.on(\"<STR_LIT>\" as any, (event, url, inPage, replaceEntry) => {<EOL>            logger.debug(`<STR_LIT>`);<EOL>            logger.debug(`<STR_LIT>`);<EOL>            logger.debug(`<STR_LIT>`);<EOL>            logger.debug(`<STR_LIT>`);<EOL>            logger.debug(`<STR_LIT>`);<EOL>            didNavigate(url, replaceEntry);<EOL>            logger.debug(`<STR_LIT>`);<EOL>        });<EOL>    });<EOL>    watcher.on(actions.analyzePage, async (store, action) => {<EOL>        const { tab, url, iframe } = action.payload;<EOL>        await withWebContents(store, tab, async (wc) => {<EOL>            const sp = Space.fromStore(store, tab);<EOL>            if (sp.isFrozen()) {<EOL>                logger.debug(`<STR_LIT>`);<EOL>                return;<EOL>            }<EOL>            const onNewPath = (url: string, resource: string) => {<EOL>                if (resource) {<EOL>                    <EOL>                    <EOL>                    logger.debug(`<STR_LIT>`);<EOL>                    store.dispatch(actions.evolveTab({<EOL>                        tab: tab,<EOL>                        url,<EOL>                        resource,<EOL>                        replace: true,<EOL>                    }));<EOL>                    const parsed = urlParser.parse(url);<EOL>                    if (parsed.search) {<EOL>                        doSave(resource, parsed.search, db);<EOL>                    }<EOL>                }<EOL>            };<EOL>            if (iframe) {<EOL>                const parsed = nodeURL.parse(url);<EOL>                const { host, protocol, pathname } = parsed;<EOL>                const dataURL = nodeURL.format({<EOL>                    host,<EOL>                    protocol,<EOL>                    pathname: `<STR_LIT>`,<EOL>                });<EOL>                const data = await request(\"<STR_LIT>\", dataURL, {}, { format: \"<STR_LIT>\" });<EOL>                if (data && data.body && data.body.id) {<EOL>                    onNewPath(wc.getURL(), `<STR_LIT>`);<EOL>                }<EOL>            }<EOL>            else {<EOL>                const code = `<STR_LIT>`;<EOL>                const newPath = await wc.executeJavaScript(code);<EOL>                onNewPath(url, newPath);<EOL>            }<EOL>        });<EOL>    });<EOL>    watcher.on(actions.commandReload, async (store, action) => {<EOL>        const { tab } = store.getState().session.navigation;<EOL>        withWebContents(store, tab, wc => {<EOL>            wc.reload();<EOL>        });<EOL>    });<EOL>    watcher.on(actions.commandStop, async (store, action) => {<EOL>        const { tab } = store.getState().session.navigation;<EOL>        withWebContents(store, tab, wc => {<EOL>            wc.stop();<EOL>        });<EOL>    });<EOL>    watcher.on(actions.commandLocation, async (store, action) => {<EOL>        const { tab } = store.","gt":"getState().session.navigation;"}
{"input":"<s> export default function (watcher: Watcher, db: DB) {<EOL>    watcher.on(actions.tabGotWebContents, async (store, action) => {<EOL>        const { tab, webContentsId } = action.payload;<EOL>        logger.debug(`<STR_LIT>`);<EOL>        const wc = webContents.fromId(webContentsId) as ExtendedWebContents;<EOL>        if (!wc) {<EOL>            logger.warn(`<STR_LIT>`);<EOL>            return;<EOL>        }<EOL>        let pushWeb = (web: Partial<ITabWeb>) => {<EOL>            store.dispatch(actions.tabDataFetched({<EOL>                tab,<EOL>                data: {<EOL>                    web,<EOL>                },<EOL>            }));<EOL>        };<EOL>        pushWeb({ webContentsId, loading: wc.isLoading() });<EOL>        const sp = Space.fromStore(store, tab);<EOL>        const didNavigate = (url: string, replace?: boolean) => {<EOL>            if (sp.isFrozen()) {<EOL>                return;<EOL>            }<EOL>            if (url !== \"<STR_LIT>\") {<EOL>                const resource = parseWellKnownUrl(url);<EOL>                store.dispatch(actions.evolveTab({<EOL>                    tab,<EOL>                    url,<EOL>                    resource,<EOL>                    replace,<EOL>                }));<EOL>            }<EOL>        };<EOL>        logger.debug(`<STR_LIT>`);<EOL>        didNavigate(wc.getURL(), true);<EOL>        if (sp.isFrozen()) {<EOL>            wc.on(\"<STR_LIT>\", (ev, url) => {<EOL>                ev.preventDefault();<EOL>                store.dispatch(actions.navigate({ url }));<EOL>            });<EOL>        }<EOL>        <EOL>        <EOL>        wc.once(\"<STR_LIT>\", () => {<EOL>            logger.debug(`<STR_LIT>`);<EOL>            if (DONT_SHOW_WEBVIEWS) {<EOL>                return;<EOL>            }<EOL>            createContextMenu(wc, store);<EOL>            if (SHOW_DEVTOOLS) {<EOL>                wc.openDevTools({ mode: \"<STR_LIT>\" });<EOL>            }<EOL>        });<EOL>        wc.on(\"<STR_LIT>\", () => {<EOL>            logger.debug(`<STR_LIT>`);<EOL>            wc.executeJavaScript(`<STR_LIT>`, false);<EOL>            store.dispatch(actions.analyzePage({<EOL>                tab,<EOL>                url: wc.getURL(),<EOL>                iframe: false,<EOL>            }));<EOL>        });<EOL>        wc.on(\"<STR_LIT>\", () => {<EOL>            pushWeb({ loading: true });<EOL>        });<EOL>        wc.on(\"<STR_LIT>\", () => {<EOL>            pushWeb({ loading: false });<EOL>        });<EOL>        <EOL>        <EOL>        wc.on(\"<STR_LIT>\", (ev, favicons) => {<EOL>            pushWeb({ favicon: favicons[<NUM_LIT>] });<EOL>        });<EOL>        wc.on(\"<STR_LIT>\", (ev, url, frameName, disposition, options, additionalFeatures) => {<EOL>            const background = disposition === \"<STR_LIT>\";<EOL>            store.dispatch(actions.navigate({ url, background }));<EOL>        });<EOL>        wc.on(\"<STR_LIT>\" as any, (event, url, inPage, replaceEntry) => {<EOL>            logger.debug(`<STR_LIT>`);<EOL>            logger.debug(`<STR_LIT>`);<EOL>            logger.debug(`<STR_LIT>`);<EOL>            logger.debug(`<STR_LIT>`);<EOL>            logger.debug(`<STR_LIT>`);<EOL>            didNavigate(url, replaceEntry);<EOL>            logger.debug(`<STR_LIT>`);<EOL>        });<EOL>    });<EOL>    watcher.on(actions.analyzePage, async (store, action) => {<EOL>        const { tab, url, iframe } = action.payload;<EOL>        await withWebContents(store, tab, async (wc) => {<EOL>            const sp = Space.fromStore(store, tab);<EOL>            if (sp.isFrozen()) {<EOL>                logger.debug(`<STR_LIT>`);<EOL>                return;<EOL>            }<EOL>            const onNewPath = (url: string, resource: string) => {<EOL>                if (resource) {<EOL>                    <EOL>                    <EOL>                    logger.debug(`<STR_LIT>`);<EOL>                    store.dispatch(actions.evolveTab({<EOL>                        tab: tab,<EOL>                        url,<EOL>                        resource,<EOL>                        replace: true,<EOL>                    }));<EOL>                    const parsed = urlParser.parse(url);<EOL>                    if (parsed.search) {<EOL>                        doSave(resource, parsed.search, db);<EOL>                    }<EOL>                }<EOL>            };<EOL>            if (iframe) {<EOL>                const parsed = nodeURL.parse(url);<EOL>                const { host, protocol, pathname } = parsed;<EOL>                const dataURL = nodeURL.format({<EOL>                    host,<EOL>                    protocol,<EOL>                    pathname: `<STR_LIT>`,<EOL>                });<EOL>                const data = await request(\"<STR_LIT>\", dataURL, {}, { format: \"<STR_LIT>\" });<EOL>                if (data && data.body && data.body.id) {<EOL>                    onNewPath(wc.getURL(), `<STR_LIT>`);<EOL>                }<EOL>            }<EOL>            else {<EOL>                const code = `<STR_LIT>`;<EOL>                const newPath = await wc.executeJavaScript(code);<EOL>                onNewPath(url, newPath);<EOL>            }<EOL>        });<EOL>    });<EOL>    watcher.on(actions.commandReload, async (store, action) => {<EOL>        const { tab } = store.getState().session.navigation;<EOL>        withWebContents(store, tab, wc => {<EOL>            wc.reload();<EOL>        });<EOL>    });<EOL>    watcher.on(actions.commandStop, async (store, action) => {<EOL>        const { tab } = store.getState().session.navigation;<EOL>        withWebContents(store, tab, wc => {<EOL>            wc.stop();<EOL>        });<EOL>    });<EOL>    watcher.on(actions.commandLocation, async (store, action) => {<EOL>        const { tab } = store.getState().session.navigation;<EOL>        store.dispatch(","gt":"actions.tabDataFetched({"}
{"input":"<s> export default function (watcher: Watcher, db: DB) {<EOL>    watcher.on(actions.tabGotWebContents, async (store, action) => {<EOL>        const { tab, webContentsId } = action.payload;<EOL>        logger.debug(`<STR_LIT>`);<EOL>        const wc = webContents.fromId(webContentsId) as ExtendedWebContents;<EOL>        if (!wc) {<EOL>            logger.warn(`<STR_LIT>`);<EOL>            return;<EOL>        }<EOL>        let pushWeb = (web: Partial<ITabWeb>) => {<EOL>            store.dispatch(actions.tabDataFetched({<EOL>                tab,<EOL>                data: {<EOL>                    web,<EOL>                },<EOL>            }));<EOL>        };<EOL>        pushWeb({ webContentsId, loading: wc.isLoading() });<EOL>        const sp = Space.fromStore(store, tab);<EOL>        const didNavigate = (url: string, replace?: boolean) => {<EOL>            if (sp.isFrozen()) {<EOL>                return;<EOL>            }<EOL>            if (url !== \"<STR_LIT>\") {<EOL>                const resource = parseWellKnownUrl(url);<EOL>                store.dispatch(actions.evolveTab({<EOL>                    tab,<EOL>                    url,<EOL>                    resource,<EOL>                    replace,<EOL>                }));<EOL>            }<EOL>        };<EOL>        logger.debug(`<STR_LIT>`);<EOL>        didNavigate(wc.getURL(), true);<EOL>        if (sp.isFrozen()) {<EOL>            wc.on(\"<STR_LIT>\", (ev, url) => {<EOL>                ev.preventDefault();<EOL>                store.dispatch(actions.navigate({ url }));<EOL>            });<EOL>        }<EOL>        <EOL>        <EOL>        wc.once(\"<STR_LIT>\", () => {<EOL>            logger.debug(`<STR_LIT>`);<EOL>            if (DONT_SHOW_WEBVIEWS) {<EOL>                return;<EOL>            }<EOL>            createContextMenu(wc, store);<EOL>            if (SHOW_DEVTOOLS) {<EOL>                wc.openDevTools({ mode: \"<STR_LIT>\" });<EOL>            }<EOL>        });<EOL>        wc.on(\"<STR_LIT>\", () => {<EOL>            logger.debug(`<STR_LIT>`);<EOL>            wc.executeJavaScript(`<STR_LIT>`, false);<EOL>            store.dispatch(actions.analyzePage({<EOL>                tab,<EOL>                url: wc.getURL(),<EOL>                iframe: false,<EOL>            }));<EOL>        });<EOL>        wc.on(\"<STR_LIT>\", () => {<EOL>            pushWeb({ loading: true });<EOL>        });<EOL>        wc.on(\"<STR_LIT>\", () => {<EOL>            pushWeb({ loading: false });<EOL>        });<EOL>        <EOL>        <EOL>        wc.on(\"<STR_LIT>\", (ev, favicons) => {<EOL>            pushWeb({ favicon: favicons[<NUM_LIT>] });<EOL>        });<EOL>        wc.on(\"<STR_LIT>\", (ev, url, frameName, disposition, options, additionalFeatures) => {<EOL>            const background = disposition === \"<STR_LIT>\";<EOL>            store.dispatch(actions.navigate({ url, background }));<EOL>        });<EOL>        wc.on(\"<STR_LIT>\" as any, (event, url, inPage, replaceEntry) => {<EOL>            logger.debug(`<STR_LIT>`);<EOL>            logger.debug(`<STR_LIT>`);<EOL>            logger.debug(`<STR_LIT>`);<EOL>            logger.debug(`<STR_LIT>`);<EOL>            logger.debug(`<STR_LIT>`);<EOL>            didNavigate(url, replaceEntry);<EOL>            logger.debug(`<STR_LIT>`);<EOL>        });<EOL>    });<EOL>    watcher.on(actions.analyzePage, async (store, action) => {<EOL>        const { tab, url, iframe } = action.payload;<EOL>        await withWebContents(store, tab, async (wc) => {<EOL>            const sp = Space.fromStore(store, tab);<EOL>            if (sp.isFrozen()) {<EOL>                logger.debug(`<STR_LIT>`);<EOL>                return;<EOL>            }<EOL>            const onNewPath = (url: string, resource: string) => {<EOL>                if (resource) {<EOL>                    <EOL>                    <EOL>                    logger.debug(`<STR_LIT>`);<EOL>                    store.dispatch(actions.evolveTab({<EOL>                        tab: tab,<EOL>                        url,<EOL>                        resource,<EOL>                        replace: true,<EOL>                    }));<EOL>                    const parsed = urlParser.parse(url);<EOL>                    if (parsed.search) {<EOL>                        doSave(resource, parsed.search, db);<EOL>                    }<EOL>                }<EOL>            };<EOL>            if (iframe) {<EOL>                const parsed = nodeURL.parse(url);<EOL>                const { host, protocol, pathname } = parsed;<EOL>                const dataURL = nodeURL.format({<EOL>                    host,<EOL>                    protocol,<EOL>                    pathname: `<STR_LIT>`,<EOL>                });<EOL>                const data = await request(\"<STR_LIT>\", dataURL, {}, { format: \"<STR_LIT>\" });<EOL>                if (data && data.body && data.body.id) {<EOL>                    onNewPath(wc.getURL(), `<STR_LIT>`);<EOL>                }<EOL>            }<EOL>            else {<EOL>                const code = `<STR_LIT>`;<EOL>                const newPath = await wc.executeJavaScript(code);<EOL>                onNewPath(url, newPath);<EOL>            }<EOL>        });<EOL>    });<EOL>    watcher.on(actions.commandReload, async (store, action) => {<EOL>        const { tab } = store.getState().session.navigation;<EOL>        withWebContents(store, tab, wc => {<EOL>            wc.reload();<EOL>        });<EOL>    });<EOL>    watcher.on(actions.commandStop, async (store, action) => {<EOL>        const { tab } = store.getState().session.navigation;<EOL>        withWebContents(store, tab, wc => {<EOL>            wc.stop();<EOL>        });<EOL>    });<EOL>    watcher.on(actions.commandLocation, async (store, action) => {<EOL>        const { tab } = store.getState().session.navigation;<EOL>        store.dispatch(actions.tabDataFetched({<EOL>            tab,<EOL>            data: {<EOL>                web: { editingAddress: true },<EOL>            },<EOL>        }));<EOL>    });<EOL>    watcher.on(actions.commandBack, async (store, action) => {<EOL>","gt":"const { tab } = store.getState().session.navigation;"}
{"input":"<s> export default function (watcher: Watcher, db: DB) {<EOL>    watcher.on(actions.tabGotWebContents, async (store, action) => {<EOL>        const { tab, webContentsId } = action.payload;<EOL>        logger.debug(`<STR_LIT>`);<EOL>        const wc = webContents.fromId(webContentsId) as ExtendedWebContents;<EOL>        if (!wc) {<EOL>            logger.warn(`<STR_LIT>`);<EOL>            return;<EOL>        }<EOL>        let pushWeb = (web: Partial<ITabWeb>) => {<EOL>            store.dispatch(actions.tabDataFetched({<EOL>                tab,<EOL>                data: {<EOL>                    web,<EOL>                },<EOL>            }));<EOL>        };<EOL>        pushWeb({ webContentsId, loading: wc.isLoading() });<EOL>        const sp = Space.fromStore(store, tab);<EOL>        const didNavigate = (url: string, replace?: boolean) => {<EOL>            if (sp.isFrozen()) {<EOL>                return;<EOL>            }<EOL>            if (url !== \"<STR_LIT>\") {<EOL>                const resource = parseWellKnownUrl(url);<EOL>                store.dispatch(actions.evolveTab({<EOL>                    tab,<EOL>                    url,<EOL>                    resource,<EOL>                    replace,<EOL>                }));<EOL>            }<EOL>        };<EOL>        logger.debug(`<STR_LIT>`);<EOL>        didNavigate(wc.getURL(), true);<EOL>        if (sp.isFrozen()) {<EOL>            wc.on(\"<STR_LIT>\", (ev, url) => {<EOL>                ev.preventDefault();<EOL>                store.dispatch(actions.navigate({ url }));<EOL>            });<EOL>        }<EOL>        <EOL>        <EOL>        wc.once(\"<STR_LIT>\", () => {<EOL>            logger.debug(`<STR_LIT>`);<EOL>            if (DONT_SHOW_WEBVIEWS) {<EOL>                return;<EOL>            }<EOL>            createContextMenu(wc, store);<EOL>            if (SHOW_DEVTOOLS) {<EOL>                wc.openDevTools({ mode: \"<STR_LIT>\" });<EOL>            }<EOL>        });<EOL>        wc.on(\"<STR_LIT>\", () => {<EOL>            logger.debug(`<STR_LIT>`);<EOL>            wc.executeJavaScript(`<STR_LIT>`, false);<EOL>            store.dispatch(actions.analyzePage({<EOL>                tab,<EOL>                url: wc.getURL(),<EOL>                iframe: false,<EOL>            }));<EOL>        });<EOL>        wc.on(\"<STR_LIT>\", () => {<EOL>            pushWeb({ loading: true });<EOL>        });<EOL>        wc.on(\"<STR_LIT>\", () => {<EOL>            pushWeb({ loading: false });<EOL>        });<EOL>        <EOL>        <EOL>        wc.on(\"<STR_LIT>\", (ev, favicons) => {<EOL>            pushWeb({ favicon: favicons[<NUM_LIT>] });<EOL>        });<EOL>        wc.on(\"<STR_LIT>\", (ev, url, frameName, disposition, options, additionalFeatures) => {<EOL>            const background = disposition === \"<STR_LIT>\";<EOL>            store.dispatch(actions.navigate({ url, background }));<EOL>        });<EOL>        wc.on(\"<STR_LIT>\" as any, (event, url, inPage, replaceEntry) => {<EOL>            logger.debug(`<STR_LIT>`);<EOL>            logger.debug(`<STR_LIT>`);<EOL>            logger.debug(`<STR_LIT>`);<EOL>            logger.debug(`<STR_LIT>`);<EOL>            logger.debug(`<STR_LIT>`);<EOL>            didNavigate(url, replaceEntry);<EOL>            logger.debug(`<STR_LIT>`);<EOL>        });<EOL>    });<EOL>    watcher.on(actions.analyzePage, async (store, action) => {<EOL>        const { tab, url, iframe } = action.payload;<EOL>        await withWebContents(store, tab, async (wc) => {<EOL>            const sp = Space.fromStore(store, tab);<EOL>            if (sp.isFrozen()) {<EOL>                logger.debug(`<STR_LIT>`);<EOL>                return;<EOL>            }<EOL>            const onNewPath = (url: string, resource: string) => {<EOL>                if (resource) {<EOL>                    <EOL>                    <EOL>                    logger.debug(`<STR_LIT>`);<EOL>                    store.dispatch(actions.evolveTab({<EOL>                        tab: tab,<EOL>                        url,<EOL>                        resource,<EOL>                        replace: true,<EOL>                    }));<EOL>                    const parsed = urlParser.parse(url);<EOL>                    if (parsed.search) {<EOL>                        doSave(resource, parsed.search, db);<EOL>                    }<EOL>                }<EOL>            };<EOL>            if (iframe) {<EOL>                const parsed = nodeURL.parse(url);<EOL>                const { host, protocol, pathname } = parsed;<EOL>                const dataURL = nodeURL.format({<EOL>                    host,<EOL>                    protocol,<EOL>                    pathname: `<STR_LIT>`,<EOL>                });<EOL>                const data = await request(\"<STR_LIT>\", dataURL, {}, { format: \"<STR_LIT>\" });<EOL>                if (data && data.body && data.body.id) {<EOL>                    onNewPath(wc.getURL(), `<STR_LIT>`);<EOL>                }<EOL>            }<EOL>            else {<EOL>                const code = `<STR_LIT>`;<EOL>                const newPath = await wc.executeJavaScript(code);<EOL>                onNewPath(url, newPath);<EOL>            }<EOL>        });<EOL>    });<EOL>    watcher.on(actions.commandReload, async (store, action) => {<EOL>        const { tab } = store.getState().session.navigation;<EOL>        withWebContents(store, tab, wc => {<EOL>            wc.reload();<EOL>        });<EOL>    });<EOL>    watcher.on(actions.commandStop, async (store, action) => {<EOL>        const { tab } = store.getState().session.navigation;<EOL>        withWebContents(store, tab, wc => {<EOL>            wc.stop();<EOL>        });<EOL>    });<EOL>    watcher.on(actions.commandLocation, async (store, action) => {<EOL>        const { tab } = store.getState().session.navigation;<EOL>        store.dispatch(actions.tabDataFetched({<EOL>            tab,<EOL>            data: {<EOL>                web: { editingAddress: true },<EOL>            },<EOL>        }));<EOL>    });<EOL>    watcher.on(actions.commandBack, async (store, action) => {<EOL>        const { tab } = store.getState().session.navigation;<EOL>        store.dispatch(","gt":"actions.tabDataFetched({"}
{"input":"<s> export default function (watcher: Watcher, db: DB) {<EOL>    watcher.on(actions.tabGotWebContents, async (store, action) => {<EOL>        const { tab, webContentsId } = action.payload;<EOL>        logger.debug(`<STR_LIT>`);<EOL>        const wc = webContents.fromId(webContentsId) as ExtendedWebContents;<EOL>        if (!wc) {<EOL>            logger.warn(`<STR_LIT>`);<EOL>            return;<EOL>        }<EOL>        let pushWeb = (web: Partial<ITabWeb>) => {<EOL>            store.dispatch(actions.tabDataFetched({<EOL>                tab,<EOL>                data: {<EOL>                    web,<EOL>                },<EOL>            }));<EOL>        };<EOL>        pushWeb({ webContentsId, loading: wc.isLoading() });<EOL>        const sp = Space.fromStore(store, tab);<EOL>        const didNavigate = (url: string, replace?: boolean) => {<EOL>            if (sp.isFrozen()) {<EOL>                return;<EOL>            }<EOL>            if (url !== \"<STR_LIT>\") {<EOL>                const resource = parseWellKnownUrl(url);<EOL>                store.dispatch(actions.evolveTab({<EOL>                    tab,<EOL>                    url,<EOL>                    resource,<EOL>                    replace,<EOL>                }));<EOL>            }<EOL>        };<EOL>        logger.debug(`<STR_LIT>`);<EOL>        didNavigate(wc.getURL(), true);<EOL>        if (sp.isFrozen()) {<EOL>            wc.on(\"<STR_LIT>\", (ev, url) => {<EOL>                ev.preventDefault();<EOL>                store.dispatch(actions.navigate({ url }));<EOL>            });<EOL>        }<EOL>        <EOL>        <EOL>        wc.once(\"<STR_LIT>\", () => {<EOL>            logger.debug(`<STR_LIT>`);<EOL>            if (DONT_SHOW_WEBVIEWS) {<EOL>                return;<EOL>            }<EOL>            createContextMenu(wc, store);<EOL>            if (SHOW_DEVTOOLS) {<EOL>                wc.openDevTools({ mode: \"<STR_LIT>\" });<EOL>            }<EOL>        });<EOL>        wc.on(\"<STR_LIT>\", () => {<EOL>            logger.debug(`<STR_LIT>`);<EOL>            wc.executeJavaScript(`<STR_LIT>`, false);<EOL>            store.dispatch(actions.analyzePage({<EOL>                tab,<EOL>                url: wc.getURL(),<EOL>                iframe: false,<EOL>            }));<EOL>        });<EOL>        wc.on(\"<STR_LIT>\", () => {<EOL>            pushWeb({ loading: true });<EOL>        });<EOL>        wc.on(\"<STR_LIT>\", () => {<EOL>            pushWeb({ loading: false });<EOL>        });<EOL>        <EOL>        <EOL>        wc.on(\"<STR_LIT>\", (ev, favicons) => {<EOL>            pushWeb({ favicon: favicons[<NUM_LIT>] });<EOL>        });<EOL>        wc.on(\"<STR_LIT>\", (ev, url, frameName, disposition, options, additionalFeatures) => {<EOL>            const background = disposition === \"<STR_LIT>\";<EOL>            store.dispatch(actions.navigate({ url, background }));<EOL>        });<EOL>        wc.on(\"<STR_LIT>\" as any, (event, url, inPage, replaceEntry) => {<EOL>            logger.debug(`<STR_LIT>`);<EOL>            logger.debug(`<STR_LIT>`);<EOL>            logger.debug(`<STR_LIT>`);<EOL>            logger.debug(`<STR_LIT>`);<EOL>            logger.debug(`<STR_LIT>`);<EOL>            didNavigate(url, replaceEntry);<EOL>            logger.debug(`<STR_LIT>`);<EOL>        });<EOL>    });<EOL>    watcher.on(actions.analyzePage, async (store, action) => {<EOL>        const { tab, url, iframe } = action.payload;<EOL>        await withWebContents(store, tab, async (wc) => {<EOL>            const sp = Space.fromStore(store, tab);<EOL>            if (sp.isFrozen()) {<EOL>                logger.debug(`<STR_LIT>`);<EOL>                return;<EOL>            }<EOL>            const onNewPath = (url: string, resource: string) => {<EOL>                if (resource) {<EOL>                    <EOL>                    <EOL>                    logger.debug(`<STR_LIT>`);<EOL>                    store.dispatch(actions.evolveTab({<EOL>                        tab: tab,<EOL>                        url,<EOL>                        resource,<EOL>                        replace: true,<EOL>                    }));<EOL>                    const parsed = urlParser.parse(url);<EOL>                    if (parsed.search) {<EOL>                        doSave(resource, parsed.search, db);<EOL>                    }<EOL>                }<EOL>            };<EOL>            if (iframe) {<EOL>                const parsed = nodeURL.parse(url);<EOL>                const { host, protocol, pathname } = parsed;<EOL>                const dataURL = nodeURL.format({<EOL>                    host,<EOL>                    protocol,<EOL>                    pathname: `<STR_LIT>`,<EOL>                });<EOL>                const data = await request(\"<STR_LIT>\", dataURL, {}, { format: \"<STR_LIT>\" });<EOL>                if (data && data.body && data.body.id) {<EOL>                    onNewPath(wc.getURL(), `<STR_LIT>`);<EOL>                }<EOL>            }<EOL>            else {<EOL>                const code = `<STR_LIT>`;<EOL>                const newPath = await wc.executeJavaScript(code);<EOL>                onNewPath(url, newPath);<EOL>            }<EOL>        });<EOL>    });<EOL>    watcher.on(actions.commandReload, async (store, action) => {<EOL>        const { tab } = store.getState().session.navigation;<EOL>        withWebContents(store, tab, wc => {<EOL>            wc.reload();<EOL>        });<EOL>    });<EOL>    watcher.on(actions.commandStop, async (store, action) => {<EOL>        const { tab } = store.getState().session.navigation;<EOL>        withWebContents(store, tab, wc => {<EOL>            wc.stop();<EOL>        });<EOL>    });<EOL>    watcher.on(actions.commandLocation, async (store, action) => {<EOL>        const { tab } = store.getState().session.navigation;<EOL>        store.dispatch(actions.tabDataFetched({<EOL>            tab,<EOL>            data: {<EOL>                web: { editingAddress: true },<EOL>            },<EOL>        }));<EOL>    });<EOL>    watcher.on(actions.commandBack, async (store, action) => {<EOL>        const { tab } = store.getState().session.navigation;<EOL>        store.dispatch(actions.tabDataFetched({<EOL>            tab,<EOL>","gt":"data: {"}
{"input":"<s> export function assignImpl(target: Object, ...sources: Object[]) {<EOL>    const len = sources.length;<EOL>    for (let i = <NUM_LIT>; i < len; i++) {<EOL>        const source = sources[i];<EOL>        for (let","gt":"k in source) {"}
{"input":"<s> function dispatchNext(subscriber: DebounceTimeSubscriber<any>) {<EOL>    subscriber.","gt":"debouncedNext();"}
{"input":"<s> function methodIsNotUnavailableNSObjectMethod(method: ObjC.Method): boolean {<EOL>    return Maybe.match(function Just(type: string) {<EOL>        if (type == \"<STR_LIT>\") {<EOL>            return (method.compilerAttributes.indexOf(\"<STR_LIT>\") === -<NUM_LIT>);<EOL>        }<EOL>        else {<EOL>            return true;<EOL>        }<EOL>    },","gt":"function Nothing() {"}
{"input":"<s> function willHaveImplementationForFunction(func: ObjC.Function): boolean {<EOL>    return func.code.length >","gt":"<NUM_LIT> || !func.isPublic;"}
{"input":"<s> function allocationAndInvocationCanBeOneForAttribute(typeName: string, attributes: ObjectSpec.Attribute[]): boolean {<EOL>    return (attributes.","gt":"length == <NUM_LIT>);"}
{"input":"<s> function blockInvocationForSubtype(algebraicType: AlgebraicType.Type, subtype: AlgebraicType.Subtype): string {<EOL>    return blockParameterNameForMatchMethodFromSubtype(subtype) + '<STR_LIT>' + attributesFromSubtype(subtype).","gt":"map(FunctionUtils.pApplyf2(subtype, valueAccessorForInternalPropertyForAttribute)).join('<STR_LIT>') + '<STR_LIT>';"}
{"input":"<s> function typeInformationContainingDefaultIncludes(typeInformation: AlgebraicType.Type, defaultIncludes: List.List<string>): AlgebraicType.Type {<EOL>    return {<EOL>        annotations: typeInformation.annotations,<EOL>        comments: typeInformation.comments,<EOL>        excludes:","gt":"typeInformation.excludes,"}
{"input":"<s> function typeInformationContainingDefaultIncludes(typeInformation: AlgebraicType.Type, defaultIncludes: List.List<string>): AlgebraicType.Type {<EOL>    return {<EOL>        annotations: typeInformation.annotations,<EOL>        comments: typeInformation.comments,<EOL>        excludes: typeInformation.excludes,<EOL>        includes: PluginInclusionUtils.includesContainingDefaultIncludes(typeInformation.includes, typeInformation.excludes, defaultIncludes),<EOL>        libraryName: typeInformation.libraryName,<EOL>        name: typeInformation.name,<EOL>        typeLookups: typeInformation.","gt":"typeLookups,"}
{"input":"<s> function concatString(soFar: string, thisOne: string): string {<EOL>    return","gt":"soFar + thisOne;"}
{"input":"<s> function wrapInQuotes(str: string): string {<EOL>","gt":"return '<STR_LIT>' + str + '<STR_LIT>';"}
{"input":"<s> function shortNameOfObjectToBuildForValueTypeWithName(valueTypeName: string): string {<EOL>","gt":"return StringUtils.lowercased(StringUtils.stringRemovingCapitalizedPrefix(valueTypeName));"}
{"input":"<s> function toWithInvocationCallForBuilderFromExistingObjectClassMethodForAttribute(indentationProvider: (index: number) => string, existingObjectName: string, soFar: string[], attribute: ObjectSpec.Attribute, index: number, array: ObjectSpec.Attribute[]): string[] {<EOL>    return soFar.concat(indentationProvider(index) + keywordNameForAttribute(","gt":"attribute) + '<STR_LIT>' + existingObjectName + '<STR_LIT>' + attribute.name + '<STR_LIT>');"}
{"input":"<s> function propertyFromAttribute(supportsValueSemantics: boolean, attribute: ObjectSpec.Attribute): ObjC.Property {<EOL>    return {<EOL>        comments: ObjCCommentUtils.commentsAsBlockFromStringArray(attribute.comments),<EOL>        modifiers: propertyModifiersFromAttribute(supportsValueSemantics, attribute),<EOL>","gt":"name: attribute.name,"}
{"input":"<s> /**<EOL> * Maps each source value (an object) to its specified nested property.<EOL> *<EOL> * <span class=\"informal\">Like {@link map}, but meant only for picking one of<EOL> * the nested properties of every emitted object.</span><EOL> *<EOL> * <img src=\"./img/pluck.png\" width=\"100%\"><EOL> *<EOL> * Given a list of strings describing a path to an object property, retrieves<EOL> * the value of a specified nested property from all values in the source<EOL> * Observable. If a property can't be resolved, it will return `undefined` for<EOL> * that value.<EOL> *<EOL> * @example <caption>Map every click to the tagName of the clicked target element</caption><EOL> * var clicks = Rx.Observable.fromEvent(document, 'click');<EOL> * var tagNames = clicks.pluck('target', 'tagName');<EOL> * tagNames.subscribe(x => console.log(x));<EOL> *<EOL> * @see {@link map}<EOL> *<EOL> * @param {...string} properties The nested properties to pluck from each source<EOL> * value (an object).<EOL> * @return {Observable} A new Observable of property values from the source values.<EOL> * @method pluck<EOL> * @owner Observable<EOL> */<EOL>export function pluck<T, R>(...properties: string[]): OperatorFunction<T, R> {<EOL>    const length = properties.length;<EOL>","gt":"if (length === <NUM_LIT>) {"}
{"input":"<s> export default function (watcher: Watcher) {<EOL>    watcher.on(actions.forceCloseGameRequest, async (store, action) => {<EOL>        const { game } = action.payload;<EOL>        store.dispatch(actions.openModal(modalWidgets.naked.make({<EOL>            title: [\"<STR_LIT>\"],<EOL>            message: [\"<STR_LIT>\", { title: game.title }],<EOL>","gt":"buttons: ["}
{"input":"<s> export default function (watcher: Watcher) {<EOL>    watcher.on(actions.forceCloseGameRequest, async (store, action) => {<EOL>        const { game } = action.payload;<EOL>        store.dispatch(actions.openModal(modalWidgets.naked.make({<EOL>            title: [\"<STR_LIT>\"],<EOL>            message: [\"<STR_LIT>\", { title: game.title }],<EOL>            buttons: [<EOL>                {<EOL>                    label: [\"<STR_LIT>\"],<EOL>                    id: \"<STR_LIT>\",<EOL>                    action: actions.","gt":"forceCloseGame({ gameId: game.id }),"}
{"input":"<s> export default function (watcher: Watcher) {<EOL>    watcher.on(actions.forceCloseGameRequest, async (store, action) => {<EOL>        const { game } = action.payload;<EOL>        store.dispatch(actions.openModal(modalWidgets.naked.make({<EOL>            title: [\"<STR_LIT>\"],<EOL>            message: [\"<STR_LIT>\", { title: game.title }],<EOL>            buttons: [<EOL>                {<EOL>                    label: [\"<STR_LIT>\"],<EOL>                    id: \"<STR_LIT>\",<EOL>                    action: actions.forceCloseGame({ gameId: game.id }),<EOL>                    icon: \"<STR_LIT>\",<EOL>                },<EOL>","gt":"\"<STR_LIT>\","}
{"input":"<s> function toArrayReducer<T>(arr: T[], item: T, index: number) {<EOL>    if (index === <NUM_LIT>) {<EOL>","gt":"return [item];"}
{"input":"<s> /**<EOL> * Asynchronously subscribes Observers to this Observable on the specified IScheduler.<EOL> *<EOL> * <img src=\"./img/subscribeOn.png\" width=\"100%\"><EOL> *<EOL> * @param {Scheduler} scheduler - The IScheduler to perform subscription actions on.<EOL> * @return {Observable<T>} The source Observable modified so that its subscriptions happen on the specified IScheduler.<EOL> .<EOL> * @method subscribeOn<EOL> * @owner Observable<EOL> */<EOL>export function subscribeOn<T>(scheduler: IScheduler, delay: number = <NUM_LIT>): MonoTypeOperatorFunction<T> {<EOL>","gt":"return function subscribeOnOperatorFunction(source: Observable<T>): Observable<T> {"}
{"input":"<s> function canAssertExistenceForTypeOfObjectSpecAttribute(attribute: ObjectSpec.Attribute) {<EOL>","gt":"return ObjCNullabilityUtils.canAssertExistenceForType(ObjectSpecCodeUtils.computeTypeOfAttribute(attribute));"}
{"input":"<s> function selectValue(attributeDescription: ComputedAttributeDescription): string {<EOL>    return","gt":"attributeDescription.value;"}
{"input":"<s> function doesAlgebraicAttributeContainAnUnknownType(attribute: AlgebraicType.SubtypeAttribute): boolean {<EOL>    const attributeDescription: AttributeDescription = attributeDescriptionForType(AlgebraicTypeUtils.computeTypeOfAttribute(","gt":"attribute));"}
{"input":"<s> /**<EOL> * Branch out the source Observable values as a nested Observable using a<EOL> * factory function of closing Observables to determine when to start a new<EOL> * window.<EOL> *<EOL> * <span class=\"informal\">It's like {@link bufferWhen}, but emits a nested<EOL> * Observable instead of an array.</span><EOL> *<EOL> * <img src=\"./img/windowWhen.png\" width=\"100%\"><EOL> *<EOL> * Returns an Observable that emits windows of items it collects from the source<EOL> * Observable. The output Observable emits connected, non-overlapping windows.<EOL> * It emits the current window and opens a new one whenever the Observable<EOL> * produced by the specified `closingSelector` function emits an item. The first<EOL> * window is opened immediately when subscribing to the output Observable.<EOL> *<EOL> * @example <caption>Emit only the first two clicks events in every window of [1-5] random seconds</caption><EOL> * var clicks = Rx.Observable.fromEvent(document, 'click');<EOL> * var result = clicks<EOL> *   .windowWhen(() => Rx.Observable.interval(1000 + Math.random() * 4000))<EOL> *   .map(win => win.take(2)) // each window has at most 2 emissions<EOL> *   .mergeAll(); // flatten the Observable-of-Observables<EOL> * result.subscribe(x => console.log(x));<EOL> *<EOL> * @see {@link window}<EOL> * @see {@link windowCount}<EOL> * @see {@link windowTime}<EOL> * @see {@link windowToggle}<EOL> * @see {@link bufferWhen}<EOL> *<EOL> * @param {function(): Observable} closingSelector A function that takes no<EOL> * arguments and returns an Observable that signals (on either `next` or<EOL> * `complete`) when to close the previous window and start a new one.<EOL> * @return {Observable<Observable<T>>} An observable of windows, which in turn<EOL> * are Observables.<EOL> * @method windowWhen<EOL> * @owner Observable<EOL> */<EOL>export function windowWhen<T>(closingSelector: () => Observable<any>): OperatorFunction<T, Observable<T>> {<EOL>","gt":"return function windowWhenOperatorFunction(source: Observable<T>) {"}
{"input":"<s> /**<EOL> * Applies a given `project` function to each value emitted by the source<EOL> * Observable, and emits the resulting values as an Observable.<EOL> *<EOL> * <span class=\"informal\">Like [Array.prototype.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map),<EOL> * it passes each source value through a transformation function to get<EOL> * corresponding output values.</span><EOL> *<EOL> * <img src=\"./img/map.png\" width=\"100%\"><EOL> *<EOL> * Similar to the well known `Array.prototype.map` function, this operator<EOL> * applies a projection to each value and emits that projection in the output<EOL> * Observable.<EOL> *<EOL> * @example <caption>Map every click to the clientX position of that click</caption><EOL> * var clicks = Rx.Observable.fromEvent(document, 'click');<EOL> * var positions = clicks.map(ev => ev.clientX);<EOL> * positions.subscribe(x => console.log(x));<EOL> *<EOL> * @see {@link mapTo}<EOL> * @see {@link pluck}<EOL> *<EOL> * @param {function(value: T, index: number): R} project The function to apply<EOL> * to each `value` emitted by the source Observable. The `index` parameter is<EOL> * the number `i` for the i-th emission that has happened since the<EOL> * subscription, starting from the number `0`.<EOL> * @param {any} [thisArg] An optional argument to define what `this` is in the<EOL> * `project` function.<EOL> * @return {Observable<R>} An Observable that emits the values from the source<EOL> * Observable transformed by the given `project` function.<EOL> * @method map<EOL> * @owner Observable<EOL> */<EOL>export function map<T, R>(project: (value: T, index: number) => R, thisArg?: any): OperatorFunction<T, R> {<EOL>    return function mapOperation(source: Observable<T>): Observable<R> {<EOL>        if (typeof","gt":"project !== '<STR_LIT>') {"}
{"input":"<s> function generatorForProvidingEqualityValuesFromGeneratorOfType(type: ObjC.Type): (attributeValueAccessor: string) => TypeEqualityValue[] {<EOL>    return function (attributeValueAccessor: string): TypeEqualityValue[] {<EOL>        const generationGroup: TypeEqualityGenerationGroup = generationGroupForType(","gt":"type);"}
{"input":"<s> function compareTypeEqualityValuesByComputationCost(typeEqualityValue: TypeEqualityValue, typeEqualityValueToCompare: TypeEqualityValue): ComparisonResult {<EOL>    const baseComputationCostValue: number = computationCostAsNumber(typeEqualityValue.computationCost);<EOL>    const comparisonComputationCostValue: number = computationCostAsNumber(typeEqualityValueToCompare.computationCost);<EOL>    if (baseComputationCostValue < comparisonComputationCostValue) {<EOL>        return ComparisonResult.","gt":"OrderedAscending;"}
{"input":"<s> function compareTypeEqualityValuesByComputationCost(typeEqualityValue: TypeEqualityValue, typeEqualityValueToCompare: TypeEqualityValue): ComparisonResult {<EOL>    const baseComputationCostValue: number = computationCostAsNumber(typeEqualityValue.computationCost);<EOL>    const comparisonComputationCostValue: number = computationCostAsNumber(typeEqualityValueToCompare.computationCost);<EOL>    if (baseComputationCostValue < comparisonComputationCostValue) {<EOL>        return ComparisonResult.OrderedAscending;<EOL>    }<EOL>    else if (baseComputationCostValue > comparisonComputationCostValue) {<EOL>        return ComparisonResult.OrderedDescending;<EOL>    }<EOL>","gt":"else {"}
{"input":"<s> function buildEqualityFunctionsToIncludeTracker(tracker: EqualityFunctionsToIncludeTracker, equalityFunction: EqualityFunction): EqualityFunctionsToIncludeTracker {<EOL>    const equalityFunctionName: string = nameOfEqualityFunction(equalityFunction);<EOL>    if (tracker.equalityFunctionsIncluded[equalityFunctionName] !== true) {<EOL>        return {<EOL>            equalityFunctionsToInclude:","gt":"tracker.equalityFunctionsToInclude.concat(equalityFunction),"}
{"input":"<s> function buildEqualityFunctionsToIncludeTracker(tracker: EqualityFunctionsToIncludeTracker, equalityFunction: EqualityFunction): EqualityFunctionsToIncludeTracker {<EOL>    const equalityFunctionName: string = nameOfEqualityFunction(equalityFunction);<EOL>    if (tracker.equalityFunctionsIncluded[equalityFunctionName] !== true) {<EOL>        return {<EOL>            equalityFunctionsToInclude: tracker.equalityFunctionsToInclude.concat(equalityFunction),<EOL>            equalityFunctionsIncluded: objectIncludingValue(tracker.equalityFunctionsIncluded, equalityFunctionName, true)<EOL>        };<EOL>    }<EOL>","gt":"else {"}
{"input":"<s> function isJQueryStyleEventEmitter(sourceObj: any): sourceObj is JQueryStyleEventEmitter {<EOL>","gt":"return !!sourceObj && typeof sourceObj.on === '<STR_LIT>' && typeof sourceObj.off === '<STR_LIT>';"}
{"input":"<s> /**<EOL> * Buffers the source Observable values until `closingNotifier` emits.<EOL> *<EOL> * <span class=\"informal\">Collects values from the past as an array, and emits<EOL> * that array only when another Observable emits.</span><EOL> *<EOL> * <img src=\"./img/buffer.png\" width=\"100%\"><EOL> *<EOL> * Buffers the incoming Observable values until the given `closingNotifier`<EOL> * Observable emits a value, at which point it emits the buffer on the output<EOL> * Observable and starts a new buffer internally, awaiting the next time<EOL> * `closingNotifier` emits.<EOL> *<EOL> * @example <caption>On every click, emit array of most recent interval events</caption><EOL> * var clicks = Rx.Observable.fromEvent(document, 'click');<EOL> * var interval = Rx.Observable.interval(1000);<EOL> * var buffered = interval.buffer(clicks);<EOL> * buffered.subscribe(x => console.log(x));<EOL> *<EOL> * @see {@link bufferCount}<EOL> * @see {@link bufferTime}<EOL> * @see {@link bufferToggle}<EOL> * @see {@link bufferWhen}<EOL> * @see {@link window}<EOL> *<EOL> * @param {Observable<any>} closingNotifier An Observable that signals the<EOL> * buffer to be emitted on the output Observable.<EOL> * @return {Observable<T[]>} An Observable of buffers, which are arrays of<EOL> * values.<EOL> * @method buffer<EOL> * @owner Observable<EOL> */<EOL>export function buffer<T>(this: Observable<T>, closingNotifier: Observable<any>): Observable<T[]> {<EOL>    return","gt":"higherOrder(closingNotifier)(this) as Observable<T[]>;"}
{"input":"<s> function nameOfObjectWithinInitializer(): string {<EOL>","gt":"return '<STR_LIT>';"}
{"input":"<s> /**<EOL> * Represents all of the notifications from the source Observable as `next`<EOL> * emissions marked with their original types within {@link Notification}<EOL> * objects.<EOL> *<EOL> * <span class=\"informal\">Wraps `next`, `error` and `complete` emissions in<EOL> * {@link Notification} objects, emitted as `next` on the output Observable.<EOL> * </span><EOL> *<EOL> * <img src=\"./img/materialize.png\" width=\"100%\"><EOL> *<EOL> * `materialize` returns an Observable that emits a `next` notification for each<EOL> * `next`, `error`, or `complete` emission of the source Observable. When the<EOL> * source Observable emits `complete`, the output Observable will emit `next` as<EOL> * a Notification of type \"complete\", and then it will emit `complete` as well.<EOL> * When the source Observable emits `error`, the output will emit `next` as a<EOL> * Notification of type \"error\", and then `complete`.<EOL> *<EOL> * This operator is useful for producing metadata of the source Observable, to<EOL> * be consumed as `next` emissions. Use it in conjunction with<EOL> * {@link dematerialize}.<EOL> *<EOL> * @example <caption>Convert a faulty Observable to an Observable of Notifications</caption><EOL> * var letters = Rx.Observable.of('a', 'b', 13, 'd');<EOL> * var upperCase = letters.map(x => x.toUpperCase());<EOL> * var materialized = upperCase.materialize();<EOL> * materialized.subscribe(x => console.log(x));<EOL> *<EOL> * // Results in the following:<EOL> * // - Notification {kind: \"N\", value: \"A\", error: undefined, hasValue: true}<EOL> * // - Notification {kind: \"N\", value: \"B\", error: undefined, hasValue: true}<EOL> * // - Notification {kind: \"E\", value: undefined, error: TypeError:<EOL> * //   x.toUpperCase is not a function at MapSubscriber.letters.map.x<EOL> * //   [as project] (http://1…, hasValue: false}<EOL> *<EOL> * @see {@link Notification}<EOL> * @see {@link dematerialize}<EOL> *<EOL> * @return {Observable<Notification<T>>} An Observable that emits<EOL> * {@link Notification} objects that wrap the original emissions from the source<EOL> * Observable with metadata.<EOL> * @method materialize<EOL> * @owner Observable<EOL> */<EOL>export function materialize<T>(this: Observable<T>): Observable<Notification<T>> {<EOL>","gt":"return higherOrder()(this) as Observable<Notification<T>>;"}
{"input":"<s> function isForwardDeclarationRequiredForTypeLookup(algebraicTypeName: string, typeLookup: ObjectGeneration.TypeLookup): boolean {<EOL>    return","gt":"typeLookup.name === algebraicTypeName;"}
{"input":"<s> /**<EOL> * Delays the emission of items from the source Observable by a given timeout or<EOL> * until a given Date.<EOL> *<EOL> * <span class=\"informal\">Time shifts each item by some specified amount of<EOL> * milliseconds.</span><EOL> *<EOL> * <img src=\"./img/delay.png\" width=\"100%\"><EOL> *<EOL> * If the delay argument is a Number, this operator time shifts the source<EOL> * Observable by that amount of time expressed in milliseconds. The relative<EOL> * time intervals between the values are preserved.<EOL> *<EOL> * If the delay argument is a Date, this operator time shifts the start of the<EOL> * Observable execution until the given date occurs.<EOL> *<EOL> * @example <caption>Delay each click by one second</caption><EOL> * var clicks = Rx.Observable.fromEvent(document, 'click');<EOL> * var delayedClicks = clicks.delay(1000); // each click emitted after 1 second<EOL> * delayedClicks.subscribe(x => console.log(x));<EOL> *<EOL> * @example <caption>Delay all clicks until a future date happens</caption><EOL> * var clicks = Rx.Observable.fromEvent(document, 'click');<EOL> * var date = new Date('March 15, 2050 12:00:00'); // in the future<EOL> * var delayedClicks = clicks.delay(date); // click emitted only after that date<EOL> * delayedClicks.subscribe(x => console.log(x));<EOL> *<EOL> * @see {@link debounceTime}<EOL> * @see {@link delayWhen}<EOL> *<EOL> * @param {number|Date} delay The delay duration in milliseconds (a `number`) or<EOL> * a `Date` until which the emission of the source items is delayed.<EOL> * @param {Scheduler} [scheduler=async] The IScheduler to use for<EOL> * managing the timers that handle the time-shift for each item.<EOL> * @return {Observable} An Observable that delays the emissions of the source<EOL> * Observable by the specified timeout or Date.<EOL> * @method delay<EOL> * @owner Observable<EOL> */<EOL>export function delay<T>(delay: number | Date, scheduler: IScheduler = async): MonoTypeOperatorFunction<T> {<EOL>","gt":"const absoluteDelay = isDate(delay);"}
{"input":"<s> function encodedStatementForSubtypeProperty(subtype: AlgebraicType.Subtype): string {<EOL>","gt":"const subtypeAttribute: CodeableAttribute = codeableAttributeForSubtypePropertyOfAlgebraicType();"}
{"input":"<s> /**<EOL> * Returns an Observable that emits whether or not every item of the source satisfies the condition specified.<EOL> *<EOL> * @example <caption>A simple example emitting true if all elements are less than 5, false otherwise</caption><EOL> *  Observable.of(1, 2, 3, 4, 5, 6)<EOL> *     .every(x => x < 5)<EOL> *     .subscribe(x => console.log(x)); // -> false<EOL> *<EOL> * @param {function} predicate A function for determining if an item meets a specified condition.<EOL> * @param {any} [thisArg] Optional object to use for `this` in the callback.<EOL> * @return {Observable} An Observable of booleans that determines if all items of the source Observable meet the condition specified.<EOL> * @method every<EOL> * @owner Observable<EOL> */<EOL>export function every<T>(predicate: (value: T, index: number, source: Observable<T>) => boolean, thisArg?: any): OperatorFunction<T, boolean> {<EOL>    return (source: Observable<T>) => source.lift(new","gt":"EveryOperator(predicate, thisArg, source));"}
{"input":"<s> export async function cachedGitHub(uri: string, token?: string, maxAge?: number) {<EOL>    let ret = githubCache.get(uri);<EOL>    if (","gt":"ret)"}
{"input":"<s> export function fetchAllOpenPRs(nwo: string) {<EOL>    return","gt":"githubPaginate(apiUrl(`<STR_LIT>`), undefined, <NUM_LIT> * <NUM_LIT>);"}
{"input":"<s> /**<EOL> * Returns an Observable that skips all items emitted by the source Observable as long as a specified condition holds<EOL> * true, but emits all further source items as soon as the condition becomes false.<EOL> *<EOL> * <img src=\"./img/skipWhile.png\" width=\"100%\"><EOL> *<EOL> * @param {Function} predicate - a function to test each item emitted from the source Observable.<EOL> * @return {Observable<T>} an Observable that begins emitting items emitted by the source Observable when the<EOL> * specified predicate becomes false.<EOL> * @method skipWhile<EOL> * @owner Observable<EOL> */<EOL>export function skipWhile<T>(predicate: (value: T, index: number) => boolean): Observable<T> {<EOL>    return this.lift(new","gt":"SkipWhileOperator(predicate));"}
{"input":"<s> /**<EOL> * Buffers the source Observable values for a specific time period.<EOL> *<EOL> * <span class=\"informal\">Collects values from the past as an array, and emits<EOL> * those arrays periodically in time.</span><EOL> *<EOL> * <img src=\"./img/bufferTime.png\" width=\"100%\"><EOL> *<EOL> * Buffers values from the source for a specific time duration `bufferTimeSpan`.<EOL> * Unless the optional argument `bufferCreationInterval` is given, it emits and<EOL> * resets the buffer every `bufferTimeSpan` milliseconds. If<EOL> * `bufferCreationInterval` is given, this operator opens the buffer every<EOL> * `bufferCreationInterval` milliseconds and closes (emits and resets) the<EOL> * buffer every `bufferTimeSpan` milliseconds. When the optional argument<EOL> * `maxBufferSize` is specified, the buffer will be closed either after<EOL> * `bufferTimeSpan` milliseconds or when it contains `maxBufferSize` elements.<EOL> *<EOL> * @example <caption>Every second, emit an array of the recent click events</caption><EOL> * var clicks = Rx.Observable.fromEvent(document, 'click');<EOL> * var buffered = clicks.bufferTime(1000);<EOL> * buffered.subscribe(x => console.log(x));<EOL> *<EOL> * @example <caption>Every 5 seconds, emit the click events from the next 2 seconds</caption><EOL> * var clicks = Rx.Observable.fromEvent(document, 'click');<EOL> * var buffered = clicks.bufferTime(2000, 5000);<EOL> * buffered.subscribe(x => console.log(x));<EOL> *<EOL> * @see {@link buffer}<EOL> * @see {@link bufferCount}<EOL> * @see {@link bufferToggle}<EOL> * @see {@link bufferWhen}<EOL> * @see {@link windowTime}<EOL> *<EOL> * @param {number} bufferTimeSpan The amount of time to fill each buffer array.<EOL> * @param {number} [bufferCreationInterval] The interval at which to start new<EOL> * buffers.<EOL> * @param {number} [maxBufferSize] The maximum buffer size.<EOL> * @param {Scheduler} [scheduler=async] The scheduler on which to schedule the<EOL> * intervals that determine buffer boundaries.<EOL> * @return {Observable<T[]>} An observable of arrays of buffered values.<EOL> * @method bufferTime<EOL> * @owner Observable<EOL> */<EOL>export function bufferTime<T>(bufferTimeSpan: number): Observable<T[]> {<EOL>    let length: number = arguments.length;<EOL>    let scheduler: Scheduler = async;<EOL>    if (isScheduler(arguments[arguments.length - <NUM_LIT>])) {<EOL>        scheduler = arguments[arguments.length - <NUM_LIT>];<EOL>","gt":"length--;"}
{"input":"<s> /**<EOL> * Buffers the source Observable values for a specific time period.<EOL> *<EOL> * <span class=\"informal\">Collects values from the past as an array, and emits<EOL> * those arrays periodically in time.</span><EOL> *<EOL> * <img src=\"./img/bufferTime.png\" width=\"100%\"><EOL> *<EOL> * Buffers values from the source for a specific time duration `bufferTimeSpan`.<EOL> * Unless the optional argument `bufferCreationInterval` is given, it emits and<EOL> * resets the buffer every `bufferTimeSpan` milliseconds. If<EOL> * `bufferCreationInterval` is given, this operator opens the buffer every<EOL> * `bufferCreationInterval` milliseconds and closes (emits and resets) the<EOL> * buffer every `bufferTimeSpan` milliseconds. When the optional argument<EOL> * `maxBufferSize` is specified, the buffer will be closed either after<EOL> * `bufferTimeSpan` milliseconds or when it contains `maxBufferSize` elements.<EOL> *<EOL> * @example <caption>Every second, emit an array of the recent click events</caption><EOL> * var clicks = Rx.Observable.fromEvent(document, 'click');<EOL> * var buffered = clicks.bufferTime(1000);<EOL> * buffered.subscribe(x => console.log(x));<EOL> *<EOL> * @example <caption>Every 5 seconds, emit the click events from the next 2 seconds</caption><EOL> * var clicks = Rx.Observable.fromEvent(document, 'click');<EOL> * var buffered = clicks.bufferTime(2000, 5000);<EOL> * buffered.subscribe(x => console.log(x));<EOL> *<EOL> * @see {@link buffer}<EOL> * @see {@link bufferCount}<EOL> * @see {@link bufferToggle}<EOL> * @see {@link bufferWhen}<EOL> * @see {@link windowTime}<EOL> *<EOL> * @param {number} bufferTimeSpan The amount of time to fill each buffer array.<EOL> * @param {number} [bufferCreationInterval] The interval at which to start new<EOL> * buffers.<EOL> * @param {number} [maxBufferSize] The maximum buffer size.<EOL> * @param {Scheduler} [scheduler=async] The scheduler on which to schedule the<EOL> * intervals that determine buffer boundaries.<EOL> * @return {Observable<T[]>} An observable of arrays of buffered values.<EOL> * @method bufferTime<EOL> * @owner Observable<EOL> */<EOL>export function bufferTime<T>(bufferTimeSpan: number): Observable<T[]> {<EOL>    let length: number = arguments.length;<EOL>    let scheduler: Scheduler = async;<EOL>    if (isScheduler(arguments[arguments.length - <NUM_LIT>])) {<EOL>        scheduler = arguments[arguments.length - <NUM_LIT>];<EOL>        length--;<EOL>    }<EOL>    let bufferCreationInterval: number = null;<EOL>    if (length >= <NUM_LIT>) {<EOL>","gt":"bufferCreationInterval = arguments[<NUM_LIT>];"}
{"input":"<s> /**<EOL> * Buffers the source Observable values for a specific time period.<EOL> *<EOL> * <span class=\"informal\">Collects values from the past as an array, and emits<EOL> * those arrays periodically in time.</span><EOL> *<EOL> * <img src=\"./img/bufferTime.png\" width=\"100%\"><EOL> *<EOL> * Buffers values from the source for a specific time duration `bufferTimeSpan`.<EOL> * Unless the optional argument `bufferCreationInterval` is given, it emits and<EOL> * resets the buffer every `bufferTimeSpan` milliseconds. If<EOL> * `bufferCreationInterval` is given, this operator opens the buffer every<EOL> * `bufferCreationInterval` milliseconds and closes (emits and resets) the<EOL> * buffer every `bufferTimeSpan` milliseconds. When the optional argument<EOL> * `maxBufferSize` is specified, the buffer will be closed either after<EOL> * `bufferTimeSpan` milliseconds or when it contains `maxBufferSize` elements.<EOL> *<EOL> * @example <caption>Every second, emit an array of the recent click events</caption><EOL> * var clicks = Rx.Observable.fromEvent(document, 'click');<EOL> * var buffered = clicks.bufferTime(1000);<EOL> * buffered.subscribe(x => console.log(x));<EOL> *<EOL> * @example <caption>Every 5 seconds, emit the click events from the next 2 seconds</caption><EOL> * var clicks = Rx.Observable.fromEvent(document, 'click');<EOL> * var buffered = clicks.bufferTime(2000, 5000);<EOL> * buffered.subscribe(x => console.log(x));<EOL> *<EOL> * @see {@link buffer}<EOL> * @see {@link bufferCount}<EOL> * @see {@link bufferToggle}<EOL> * @see {@link bufferWhen}<EOL> * @see {@link windowTime}<EOL> *<EOL> * @param {number} bufferTimeSpan The amount of time to fill each buffer array.<EOL> * @param {number} [bufferCreationInterval] The interval at which to start new<EOL> * buffers.<EOL> * @param {number} [maxBufferSize] The maximum buffer size.<EOL> * @param {Scheduler} [scheduler=async] The scheduler on which to schedule the<EOL> * intervals that determine buffer boundaries.<EOL> * @return {Observable<T[]>} An observable of arrays of buffered values.<EOL> * @method bufferTime<EOL> * @owner Observable<EOL> */<EOL>export function bufferTime<T>(bufferTimeSpan: number): Observable<T[]> {<EOL>    let length: number = arguments.length;<EOL>    let scheduler: Scheduler = async;<EOL>    if (isScheduler(arguments[arguments.length - <NUM_LIT>])) {<EOL>        scheduler = arguments[arguments.length - <NUM_LIT>];<EOL>        length--;<EOL>    }<EOL>    let bufferCreationInterval: number = null;<EOL>    if (length >= <NUM_LIT>) {<EOL>        bufferCreationInterval = arguments[<NUM_LIT>];<EOL>    }<EOL>    let maxBufferSize: number = Number.POSITIVE_INFINITY;<EOL>    if (","gt":"length >= <NUM_LIT>) {"}
{"input":"<s> function dispatchBufferCreation<T>(state: CreationState<T>) {<EOL>    const { bufferCreationInterval, bufferTimeSpan, subscriber, scheduler } = state;<EOL>    const context = subscriber.openContext();<EOL>","gt":"const action = <Action<CreationState<T>>>this;"}
{"input":"<s> export function zipAll<T, R>(project?: (...values: Array<any>) => R): OperatorFunction<T, R> {<EOL>    return (source: Observable<T>) =>","gt":"source.lift(new ZipOperator(project));"}
{"input":"<s> /**<EOL> * Returns an Observable that emits the single item emitted by the source Observable that matches a specified<EOL> * predicate, if that Observable emits one such item. If the source Observable emits more than one such item or no<EOL> * such items, notify of an IllegalArgumentException or NoSuchElementException respectively.<EOL> *<EOL> * <img src=\"./img/single.png\" width=\"100%\"><EOL> *<EOL> * @throws {EmptyError} Delivers an EmptyError to the Observer's `error`<EOL> * callback if the Observable completes before any `next` notification was sent.<EOL> * @param {Function} a predicate function to evaluate items emitted by the source Observable.<EOL> * @return {Observable<T>} an Observable that emits the single item emitted by the source Observable that matches<EOL> * the predicate.<EOL> .<EOL> * @method single<EOL> * @owner Observable<EOL> */<EOL>export function single<T>(predicate?: (value: T, index: number, source: Observable<T>) => boolean): Observable<T> {<EOL>    return this.lift(new SingleOperator(predicate,","gt":"this));"}
{"input":"<s> <EOL>export function onErrorResumeNextStatic<T, R>(...nextSources: Array<ObservableInput<any> | Array<ObservableInput<any>> | ((...values: Array<any>) => R)>): Observable<R> {<EOL>    let source: ObservableInput<any> = null;<EOL>    if (","gt":"nextSources.length === <NUM_LIT> && isArray(nextSources[<NUM_LIT>])) {"}
{"input":"<s> /**<EOL> * Maps each source value (an object) to its specified nested property.<EOL> *<EOL> * <span class=\"informal\">Like {@link map}, but meant only for picking one of<EOL> * the nested properties of every emitted object.</span><EOL> *<EOL> * <img src=\"./img/pluck.png\" width=\"100%\"><EOL> *<EOL> * Given a list of strings describing a path to an object property, retrieves<EOL> * the value of a specified nested property from all values in the source<EOL> * Observable. If a property can't be resolved, it will return `undefined` for<EOL> * that value.<EOL> *<EOL> * @example <caption>Map every click to the tagName of the clicked target element</caption><EOL> * var clicks = Rx.Observable.fromEvent(document, 'click');<EOL> * var tagNames = clicks.pluck('target', 'tagName');<EOL> * tagNames.subscribe(x => console.log(x));<EOL> *<EOL> * @see {@link map}<EOL> *<EOL> * @param {...string} properties The nested properties to pluck from each source<EOL> * value (an object).<EOL> * @return {Observable} A new Observable of property values from the source values.<EOL> * @method pluck<EOL> * @owner Observable<EOL> */<EOL>export function pluck<T, R>(this: Observable<T>, ...properties: string[]): Observable<R> {<EOL>    return higherOrder(...properties)(","gt":"this) as Observable<R>;"}
{"input":"<s> /**<EOL> * The Min operator operates on an Observable that emits numbers (or items that can be evaluated as numbers),<EOL> * and when source Observable completes it emits a single item: the item with the smallest number.<EOL> *<EOL> * <img src=\"./img/min.png\" width=\"100%\"><EOL> *<EOL> * @param {Function} optional comparer function that it will use instead of its default to compare the value of two items.<EOL> * @return {Observable<R>} an Observable that emits item with the smallest number.<EOL> * @method min<EOL> * @owner Observable<EOL> */<EOL>export function min<T>(comparer?: (x: T, y: T) => number): Observable<T> {<EOL>    const min: (x: T, y: T) => T = (typeof comparer === '<STR_LIT>')<EOL>        ? (x, y) => comparer(x,","gt":"y) < <NUM_LIT> ? x : y"}
{"input":"<s> /**<EOL> * Combine two effectful actions, keeping only the result of the second<EOL> * @function<EOL> */<EOL>export function applySecond<F>(F: Apply<F>): <A, B>(fa: HKT<F, A>, fb: HKT<F, B>) => HKT<F, B> {<EOL>    return <A, B>(fa: HKT<F, A>, fb: HKT<F, B>) => F.ap(F.map(","gt":"fa, () => (b: B) => b), fb);"}
{"input":"<s> function setImageSize(img, size) {<EOL>    let width, height;<EOL>    if (size) {<EOL>        width = img.style.width;<EOL>        height = img.style.height;<EOL>        if (width ||","gt":"height) {"}
{"input":"<s> function setImageSize(img, size) {<EOL>    let width, height;<EOL>    if (size) {<EOL>        width = img.style.width;<EOL>        height = img.style.height;<EOL>        if (width || height) {<EOL>            img.style.width = size.w + '<STR_LIT>';<EOL>            img.style.height = size.h + '<STR_LIT>';<EOL>            img.removeAttribute('<STR_LIT>');<EOL>        }<EOL>        width = img.width;<EOL>        height = img.height;<EOL>        if (width || height) {<EOL>            img.setAttribute('<STR_LIT>',","gt":"size.w);"}
{"input":"<s> /**<EOL> * Ignores all items emitted by the source Observable and only passes calls of `complete` or `error`.<EOL> *<EOL> * <img src=\"./img/ignoreElements.png\" width=\"100%\"><EOL> *<EOL> * @return {Observable} an empty Observable that only calls `complete`<EOL> * or `error`, based on which one is called by the source Observable.<EOL> * @method ignoreElements<EOL> * @owner Observable<EOL> */<EOL>export function ignoreElements<T>(): Observable<T> {<EOL>    return","gt":"this.lift(new IgnoreElementsOperator());"}
{"input":"<s> /**<EOL> * Emits the most recently emitted value from the source Observable within<EOL> * periodic time intervals.<EOL> *<EOL> * <span class=\"informal\">Samples the source Observable at periodic time<EOL> * intervals, emitting what it samples.</span><EOL> *<EOL> * <img src=\"./img/sampleTime.png\" width=\"100%\"><EOL> *<EOL> * `sampleTime` periodically looks at the source Observable and emits whichever<EOL> * value it has most recently emitted since the previous sampling, unless the<EOL> * source has not emitted anything since the previous sampling. The sampling<EOL> * happens periodically in time every `period` milliseconds (or the time unit<EOL> * defined by the optional `scheduler` argument). The sampling starts as soon as<EOL> * the output Observable is subscribed.<EOL> *<EOL> * @example <caption>Every second, emit the most recent click at most once</caption><EOL> * var clicks = Rx.Observable.fromEvent(document, 'click');<EOL> * var result = clicks.sampleTime(1000);<EOL> * result.subscribe(x => console.log(x));<EOL> *<EOL> * @see {@link auditTime}<EOL> * @see {@link debounceTime}<EOL> * @see {@link delay}<EOL> * @see {@link sample}<EOL> * @see {@link throttleTime}<EOL> *<EOL> * @param {number} period The sampling period expressed in milliseconds or the<EOL> * time unit determined internally by the optional `scheduler`.<EOL> * @param {Scheduler} [scheduler=async] The {@link Scheduler} to use for<EOL> * managing the timers that handle the sampling.<EOL> * @return {Observable<T>} An Observable that emits the results of sampling the<EOL> * values emitted by the source Observable at the specified time interval.<EOL> * @method sampleTime<EOL> * @owner Observable<EOL> */<EOL>export function sampleTime<T>(period: number, scheduler: Scheduler = async): Observable<T> {<EOL>    return this.","gt":"lift(new SampleTimeOperator(period, scheduler));"}
{"input":"<s> /**<EOL> * Perform an Applicative action `n` times, and accumulate all the results<EOL> * @function<EOL> */<EOL>export function replicateA<F, T>(applicative: Applicative<F>, unfoldableTraversable: Unfoldable<T> & Traversable<T>): <A>(n: number, ma: HKT<F, A>) => HKT<F, HKT<T, A>> {<EOL>    return (n, ma) => sequence(applicative,","gt":"unfoldableTraversable)(replicate(unfoldableTraversable)(ma, n));"}
{"input":"<s> /**<EOL> * Emits only the first value emitted by the source Observable that meets some<EOL> * condition.<EOL> *<EOL> * <span class=\"informal\">Finds the first value that passes some test and emits<EOL> * that.</span><EOL> *<EOL> * <img src=\"./img/find.png\" width=\"100%\"><EOL> *<EOL> * `find` searches for the first item in the source Observable that matches the<EOL> * specified condition embodied by the `predicate`, and returns the first<EOL> * occurrence in the source. Unlike {@link first}, the `predicate` is required<EOL> * in `find`, and does not emit an error if a valid value is not found.<EOL> *<EOL> * @example <caption>Find and emit the first click that happens on a DIV element</caption><EOL> * var clicks = Rx.Observable.fromEvent(document, 'click');<EOL> * var result = clicks.find(ev => ev.target.tagName === 'DIV');<EOL> * result.subscribe(x => console.log(x));<EOL> *<EOL> * @see {@link filter}<EOL> * @see {@link first}<EOL> * @see {@link findIndex}<EOL> * @see {@link take}<EOL> *<EOL> * @param {function(value: T, index: number, source: Observable<T>): boolean} predicate<EOL> * A function called with each item to test for condition matching.<EOL> * @param {any} [thisArg] An optional argument to determine the value of `this`<EOL> * in the `predicate` function.<EOL> * @return {Observable<T>} An Observable of the first item that matches the<EOL> * condition.<EOL> * @method find<EOL> * @owner Observable<EOL> */<EOL>export function find<T>(predicate: (value: T, index: number, source: Observable<T>) => boolean, thisArg?: any): Observable<T> {<EOL>    if (typeof predicate !== '<STR_LIT>') {<EOL>        throw new","gt":"TypeError('<STR_LIT>');"}
{"input":"<s> /**<EOL> * Branch out the source Observable values as a nested Observable whenever<EOL> * `windowBoundaries` emits.<EOL> *<EOL> * <span class=\"informal\">It's like {@link buffer}, but emits a nested Observable<EOL> * instead of an array.</span><EOL> *<EOL> * <img src=\"./img/window.png\" width=\"100%\"><EOL> *<EOL> * Returns an Observable that emits windows of items it collects from the source<EOL> * Observable. The output Observable emits connected, non-overlapping<EOL> * windows. It emits the current window and opens a new one whenever the<EOL> * Observable `windowBoundaries` emits an item. Because each window is an<EOL> * Observable, the output is a higher-order Observable.<EOL> *<EOL> * @example <caption>In every window of 1 second each, emit at most 2 click events</caption><EOL> * var clicks = Rx.Observable.fromEvent(document, 'click');<EOL> * var interval = Rx.Observable.interval(1000);<EOL> * var result = clicks.window(interval)<EOL> *   .map(win => win.take(2)) // each window has at most 2 emissions<EOL> *   .mergeAll(); // flatten the Observable-of-Observables<EOL> * result.subscribe(x => console.log(x));<EOL> *<EOL> * @see {@link windowCount}<EOL> * @see {@link windowTime}<EOL> * @see {@link windowToggle}<EOL> * @see {@link windowWhen}<EOL> * @see {@link buffer}<EOL> *<EOL> * @param {Observable<any>} windowBoundaries An Observable that completes the<EOL> * previous window and starts a new window.<EOL> * @return {Observable<Observable<T>>} An Observable of windows, which are<EOL> * Observables emitting values of the source Observable.<EOL> * @method window<EOL> * @owner Observable<EOL> */<EOL>export function window<T>(this: Observable<T>, windowBoundaries: Observable<any>): Observable<Observable<T>> {<EOL>    return","gt":"higherOrder(windowBoundaries)(this) as Observable<Observable<T>>;"}
{"input":"<s> /**<EOL> * A version of `voidRight` with its arguments flipped (`$>`)<EOL> * @function<EOL> */<EOL>export function voidLeft<F>(F: Functor<F>): <A, B>(fa: HKT<F, A>, b: B) => HKT<F, B> {<EOL>    return (fa,","gt":"b) => F.map(fa, constant(b));"}
{"input":"<s> /**<EOL> * Returns an Observable that mirrors the source Observable with the exception of a `complete`. If the source<EOL> * Observable calls `complete`, this method will emit to the Observable returned from `notifier`. If that Observable<EOL> * calls `complete` or `error`, then this method will call `complete` or `error` on the child subscription. Otherwise<EOL> * this method will resubscribe to the source Observable.<EOL> *<EOL> * <img src=\"./img/repeatWhen.png\" width=\"100%\"><EOL> *<EOL> * @param {function(notifications: Observable): Observable} notifier - Receives an Observable of notifications with<EOL> * which a user can `complete` or `error`, aborting the repetition.<EOL> * @return {Observable} The source Observable modified with repeat logic.<EOL> * @method repeatWhen<EOL> * @owner Observable<EOL> */<EOL>export function repeatWhen<T>(this: Observable<T>, notifier: (notifications: Observable<any>) => Observable<any>): Observable<T> {<EOL>    return higherOrder(notifier)(this)","gt":"as Observable<T>;"}
{"input":"<s> /**<EOL> * Find the product of the numeric values in a data structure<EOL> * @function<EOL> */<EOL>export function product<F, A>(F: Foldable<F>, S: Semiring<A>): (fa: HKT<F, A>) => A {<EOL>    return fa => F.reduce(","gt":"fa, S.one, (b, a) => S.mul(b, a));"}
{"input":"<s> /**<EOL> * Converts an absolute baseUrl and paths to an array of absolute mapping entries.<EOL> * The array is sorted by longest prefix.<EOL> * Having an array with entries allows us to keep a sorting order rather than<EOL> * sort by keys each time we use the mappings.<EOL> * @param absoluteBaseUrl<EOL> * @param paths<EOL> * @param addMatchAll<EOL> */<EOL>export function getAbsoluteMappingEntries(absoluteBaseUrl: string, paths: Paths, addMatchAll: boolean): ReadonlyArray<MappingEntry> {<EOL>    <EOL>    <EOL>    <EOL>","gt":"const sortedKeys = sortByLongestPrefix(Object.keys(paths));"}
{"input":"<s> /**<EOL> * Converts an absolute baseUrl and paths to an array of absolute mapping entries.<EOL> * The array is sorted by longest prefix.<EOL> * Having an array with entries allows us to keep a sorting order rather than<EOL> * sort by keys each time we use the mappings.<EOL> * @param absoluteBaseUrl<EOL> * @param paths<EOL> * @param addMatchAll<EOL> */<EOL>export function getAbsoluteMappingEntries(absoluteBaseUrl: string, paths: Paths, addMatchAll: boolean): ReadonlyArray<MappingEntry> {<EOL>    <EOL>    <EOL>    <EOL>    const sortedKeys = sortByLongestPrefix(Object.keys(paths));<EOL>    const absolutePaths: Array<MappingEntry> = [];<EOL>    for (const key of sortedKeys) {<EOL>        absolutePaths.","gt":"push({"}
{"input":"<s> /**<EOL> * Converts an absolute baseUrl and paths to an array of absolute mapping entries.<EOL> * The array is sorted by longest prefix.<EOL> * Having an array with entries allows us to keep a sorting order rather than<EOL> * sort by keys each time we use the mappings.<EOL> * @param absoluteBaseUrl<EOL> * @param paths<EOL> * @param addMatchAll<EOL> */<EOL>export function getAbsoluteMappingEntries(absoluteBaseUrl: string, paths: Paths, addMatchAll: boolean): ReadonlyArray<MappingEntry> {<EOL>    <EOL>    <EOL>    <EOL>    const sortedKeys = sortByLongestPrefix(Object.keys(paths));<EOL>    const absolutePaths: Array<MappingEntry> = [];<EOL>    for (const key of sortedKeys) {<EOL>        absolutePaths.push({<EOL>            pattern: key,<EOL>            paths: paths[key].map((pathToResolve) => path.join(absoluteBaseUrl, pathToResolve)),<EOL>        });<EOL>    }<EOL>    <EOL>    <EOL>    if (!paths[\"<STR_LIT>\"] && addMatchAll) {<EOL>        absolutePaths.push({<EOL>","gt":"pattern: \"<STR_LIT>\","}
{"input":"<s> /**<EOL> * Projects each source value to the same Observable which is flattened multiple<EOL> * times with {@link switch} in the output Observable.<EOL> *<EOL> * <span class=\"informal\">It's like {@link switchMap}, but maps each value<EOL> * always to the same inner Observable.</span><EOL> *<EOL> * <img src=\"./img/switchMapTo.png\" width=\"100%\"><EOL> *<EOL> * Maps each source value to the given Observable `innerObservable` regardless<EOL> * of the source value, and then flattens those resulting Observables into one<EOL> * single Observable, which is the output Observable. The output Observables<EOL> * emits values only from the most recently emitted instance of<EOL> * `innerObservable`.<EOL> *<EOL> * @example <caption>Rerun an interval Observable on every click event</caption><EOL> * var clicks = Rx.Observable.fromEvent(document, 'click');<EOL> * var result = clicks.switchMapTo(Rx.Observable.interval(1000));<EOL> * result.subscribe(x => console.log(x));<EOL> *<EOL> * @see {@link concatMapTo}<EOL> * @see {@link switch}<EOL> * @see {@link switchMap}<EOL> * @see {@link mergeMapTo}<EOL> *<EOL> * @param {Observable} innerObservable An Observable to replace each value from<EOL> * the source Observable.<EOL> * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]<EOL> * A function to produce the value on the output Observable based on the values<EOL> * and the indices of the source (outer) emission and the inner Observable<EOL> * emission. The arguments passed to this function are:<EOL> * - `outerValue`: the value that came from the source<EOL> * - `innerValue`: the value that came from the projected Observable<EOL> * - `outerIndex`: the \"index\" of the value that came from the source<EOL> * - `innerIndex`: the \"index\" of the value from the projected Observable<EOL> * @return {Observable} An Observable that emits items from the given<EOL> * `innerObservable` every time a value is emitted on the source Observable.<EOL> * @return {Observable} An Observable that emits items from the given<EOL> * `innerObservable` (and optionally transformed through `resultSelector`) every<EOL> * time a value is emitted on the source Observable, and taking only the values<EOL> * from the most recently projected inner Observable.<EOL> * @method switchMapTo<EOL> * @owner Observable<EOL> */<EOL>export function switchMapTo<T, I, R>(innerObservable: Observable<I>, resultSelector?: (outerValue: T, innerValue: I, outerIndex: number, innerIndex: number) => R): Observable<R> {<EOL>    return this.lift(new SwitchMapToOperator(","gt":"innerObservable, resultSelector));"}
{"input":"<s> export function splitLinkText(text) {<EOL>    let linkText;<EOL>    let target;<EOL>    let splitIndex;<EOL>    <EOL>    splitIndex = text.indexOf('<STR_LIT>');<EOL>    if (","gt":"splitIndex === -<NUM_LIT>) {"}
{"input":"<s> export function splitLinkText(text) {<EOL>    let linkText;<EOL>    let target;<EOL>    let splitIndex;<EOL>    <EOL>    splitIndex = text.indexOf('<STR_LIT>');<EOL>    if (splitIndex === -<NUM_LIT>) {<EOL>        splitIndex = text.search(/\\s/);<EOL>    }<EOL>    if (splitIndex !== -<NUM_LIT>) {<EOL>        linkText = text.substr(splitIndex +","gt":"<NUM_LIT>);"}
{"input":"<s> export default function () {<EOL>    const store = TestStore();<EOL>    const editorState = {<EOL>        start: Cell(null),<EOL>        content: Cell(","gt":"'<STR_LIT>')"}
{"input":"<s> export default function () {<EOL>    const store = TestStore();<EOL>    const editorState = {<EOL>        start: Cell(null),<EOL>        content: Cell('<STR_LIT>')<EOL>    };<EOL>    const sPrepareState = function (node, content) {<EOL>        return Step.sync(function () {<EOL>            editorState.start.set(","gt":"node);"}
{"input":"<s> export default function () {<EOL>    const store = TestStore();<EOL>    const editorState = {<EOL>        start: Cell(null),<EOL>        content: Cell('<STR_LIT>')<EOL>    };<EOL>    const sPrepareState = function (node, content) {<EOL>        return Step.sync(function () {<EOL>            editorState.start.set(node);<EOL>            editorState.content.set(content);<EOL>        });<EOL>    };<EOL>    const","gt":"editor = {"}
{"input":"<s> export default function () {<EOL>    const store = TestStore();<EOL>    const editorState = {<EOL>        start: Cell(null),<EOL>        content: Cell('<STR_LIT>')<EOL>    };<EOL>    const sPrepareState = function (node, content) {<EOL>        return Step.sync(function () {<EOL>            editorState.start.set(node);<EOL>            editorState.content.set(content);<EOL>        });<EOL>    };<EOL>    const editor = {<EOL>        selection: {<EOL>            getStart: editorState.start.get,<EOL>            getContent: editorState.content.get,<EOL>            select: Fun.noop<EOL>        },<EOL>        insertContent(data) {<EOL>            store.adder({ method: '<STR_LIT>', data })();<EOL>        },<EOL>","gt":"execCommand(name, ui, args) {"}
{"input":"<s> export default function () {<EOL>    const store = TestStore();<EOL>    const editorState = {<EOL>        start: Cell(null),<EOL>        content: Cell('<STR_LIT>')<EOL>    };<EOL>    const sPrepareState = function (node, content) {<EOL>        return Step.sync(function () {<EOL>            editorState.start.set(node);<EOL>            editorState.content.set(content);<EOL>        });<EOL>    };<EOL>    const editor = {<EOL>        selection: {<EOL>            getStart: editorState.start.get,<EOL>            getContent: editorState.content.get,<EOL>            select: Fun.noop<EOL>        },<EOL>        insertContent(data) {<EOL>            store.adder({ method: '<STR_LIT>', data })();<EOL>        },<EOL>        execCommand(name, ui, args) {<EOL>            store.adder({ method: '<STR_LIT>', data: Objects.wrap(name, args) })();<EOL>        },<EOL>        dom: {<EOL>            createHTML(tag, attributes, innerText) {<EOL>                return { tag, attributes, innerText };<EOL>            },<EOL>            encode: Fun.identity<EOL>        },<EOL>","gt":"focus: Fun.noop"}
{"input":"<s> export function em(value: number): number | string {<EOL>    if (typeof value !== '<STR_LIT>') {<EOL>        throw new TypeError(","gt":"'<STR_LIT>');"}
{"input":"<s> /**<EOL> * A foo bar function<EOL> *<EOL> * @param {string} status A status<EOL> */<EOL>export function foo(status: string) {<EOL>    console.","gt":"log('<STR_LIT>');"}
{"input":"<s> async function getArtifactsFromUrl(artifactQueryUrl: string, strictSSL: boolean, localPathRoot: string, itemPattern: string, handler: handlers.BasicCredentialHandler, variables: {<EOL>    [key: string]: any;<EOL>}) {<EOL>    console.log(tl.loc('<STR_LIT>', artifactQueryUrl));<EOL>    var templatePath = path.join(__dirname, '<STR_LIT>');<EOL>    var webProvider = new providers.WebProvider(artifactQueryUrl, templatePath, variables, handler, {","gt":"ignoreSslError: !strictSSL });"}
{"input":"<s> <EOL>function setGradleOpts(gradleOptions: string): void {<EOL>    if (gradleOptions) {<EOL>        process.","gt":"env['<STR_LIT>'] = gradleOptions;"}
{"input":"<s> function findExistingRegisteredTask(target: any, handler: any, name: string, capture: boolean, remove: boolean): Task {<EOL>    const eventTasks: Task[] = target[EVENT_TASKS];<EOL>    if (eventTasks) {<EOL>        for (let i = <NUM_LIT>; i < eventTasks.length; i++) {<EOL>            const eventTask = eventTasks[i];<EOL>            const data = <ListenerTaskMeta>eventTask.","gt":"data;"}
{"input":"<s> export function mergeTagsAndArgs(args: Array<any>, jsdoctags?: Array<any>): Array<any> {<EOL>    let margs = _.cloneDeep(args);<EOL>    _.forEach(margs, (arg) => {<EOL>        arg.","gt":"tagName = {"}
{"input":"<s> export function mergeTagsAndArgs(args: Array<any>, jsdoctags?: Array<any>): Array<any> {<EOL>    let margs = _.cloneDeep(args);<EOL>    _.forEach(margs, (arg) => {<EOL>        arg.tagName = {<EOL>            text: '<STR_LIT>'<EOL>        };<EOL>        if (jsdoctags) {<EOL>            _.forEach(jsdoctags, (","gt":"jsdoctag) => {"}
{"input":"<s> export function mergeTagsAndArgs(args: Array<any>, jsdoctags?: Array<any>): Array<any> {<EOL>    let margs = _.cloneDeep(args);<EOL>    _.forEach(margs, (arg) => {<EOL>        arg.tagName = {<EOL>            text: '<STR_LIT>'<EOL>        };<EOL>        if (jsdoctags) {<EOL>            _.forEach(jsdoctags, (jsdoctag) => {<EOL>                if (jsdoctag.name && jsdoctag.name.text === arg.name) {<EOL>                    arg.tagName = jsdoctag.tagName;<EOL>                    arg.name = jsdoctag.name;<EOL>                    arg.","gt":"comment = jsdoctag.comment;"}
{"input":"<s> export function mergeTagsAndArgs(args: Array<any>, jsdoctags?: Array<any>): Array<any> {<EOL>    let margs = _.cloneDeep(args);<EOL>    _.forEach(margs, (arg) => {<EOL>        arg.tagName = {<EOL>            text: '<STR_LIT>'<EOL>        };<EOL>        if (jsdoctags) {<EOL>            _.forEach(jsdoctags, (jsdoctag) => {<EOL>                if (jsdoctag.name && jsdoctag.name.text === arg.name) {<EOL>                    arg.tagName = jsdoctag.tagName;<EOL>                    arg.name = jsdoctag.name;<EOL>                    arg.comment = jsdoctag.comment;<EOL>                    arg.typeExpression = jsdoctag.typeExpression;<EOL>                }<EOL>            });<EOL>        }<EOL>    });<EOL>    <EOL>    if (jsdoctags) {<EOL>        _.forEach(jsdoctags, (","gt":"jsdoctag) => {"}
{"input":"<s> export function mergeTagsAndArgs(args: Array<any>, jsdoctags?: Array<any>): Array<any> {<EOL>    let margs = _.cloneDeep(args);<EOL>    _.forEach(margs, (arg) => {<EOL>        arg.tagName = {<EOL>            text: '<STR_LIT>'<EOL>        };<EOL>        if (jsdoctags) {<EOL>            _.forEach(jsdoctags, (jsdoctag) => {<EOL>                if (jsdoctag.name && jsdoctag.name.text === arg.name) {<EOL>                    arg.tagName = jsdoctag.tagName;<EOL>                    arg.name = jsdoctag.name;<EOL>                    arg.comment = jsdoctag.comment;<EOL>                    arg.typeExpression = jsdoctag.typeExpression;<EOL>                }<EOL>            });<EOL>        }<EOL>    });<EOL>    <EOL>    if (jsdoctags) {<EOL>        _.forEach(jsdoctags, (jsdoctag) => {<EOL>            if (jsdoctag.tagName && jsdoctag.tagName.text === '<STR_LIT>') {<EOL>                margs.push({<EOL>                    tagName: jsdoctag.tagName,<EOL>                    comment: jsdoctag.comment<EOL>                });<EOL>            }<EOL>            if (","gt":"jsdoctag.tagName && jsdoctag.tagName.text === '<STR_LIT>') {"}
{"input":"<s> async function run() {<EOL>    try {<EOL>        let version = tl.getInput('<STR_LIT>', true).trim();<EOL>        await getGo(","gt":"version);"}
{"input":"<s> function getIterator(obj: any) {<EOL>    const i = obj[$$iterator];<EOL>    if (!i && typeof obj === '<STR_LIT>') {<EOL>        return new StringIterator(obj);<EOL>    }<EOL>    if (!i && obj.length !== undefined) {<EOL>        return new ArrayIterator(obj);<EOL>    }<EOL>    if (!i) {<EOL>        throw new","gt":"TypeError('<STR_LIT>');"}
{"input":"<s> function numberIsFinite(value: any) {<EOL>    return typeof value === '<STR_LIT>' &&","gt":"root.isFinite(value);"}
{"input":"<s> export default function (uploadStatus, blobCache) {<EOL>    const cachedPromises = {};<EOL>    const findAll = function (elm, predicate?) {<EOL>","gt":"let images;"}
{"input":"<s> export default function (uploadStatus, blobCache) {<EOL>    const cachedPromises = {};<EOL>    const findAll = function (elm, predicate?) {<EOL>        let images;<EOL>        if (!predicate) {<EOL>            predicate = Fun.constant(true);<EOL>        }<EOL>        images = Arr.filter(getAllImages(elm), function (img) {<EOL>            const","gt":"src = img.src;"}
{"input":"<s> export default function (uploadStatus, blobCache) {<EOL>    const cachedPromises = {};<EOL>    const findAll = function (elm, predicate?) {<EOL>        let images;<EOL>        if (!predicate) {<EOL>            predicate = Fun.constant(true);<EOL>        }<EOL>        images = Arr.filter(getAllImages(elm), function (img) {<EOL>            const src = img.src;<EOL>            if (!Env.fileApi) {<EOL>                return false;<EOL>            }<EOL>            if (","gt":"img.hasAttribute('<STR_LIT>')) {"}
{"input":"<s> export default function (uploadStatus, blobCache) {<EOL>    const cachedPromises = {};<EOL>    const findAll = function (elm, predicate?) {<EOL>        let images;<EOL>        if (!predicate) {<EOL>            predicate = Fun.constant(true);<EOL>        }<EOL>        images = Arr.filter(getAllImages(elm), function (img) {<EOL>            const src = img.src;<EOL>            if (!Env.fileApi) {<EOL>                return false;<EOL>            }<EOL>            if (img.hasAttribute('<STR_LIT>')) {<EOL>","gt":"return false;"}
{"input":"<s> export default function (uploadStatus, blobCache) {<EOL>    const cachedPromises = {};<EOL>    const findAll = function (elm, predicate?) {<EOL>        let images;<EOL>        if (!predicate) {<EOL>            predicate = Fun.constant(true);<EOL>        }<EOL>        images = Arr.filter(getAllImages(elm), function (img) {<EOL>            const src = img.src;<EOL>            if (!Env.fileApi) {<EOL>                return false;<EOL>            }<EOL>            if (img.hasAttribute('<STR_LIT>')) {<EOL>                return false;<EOL>            }<EOL>            if (img.hasAttribute('<STR_LIT>')) {<EOL>                return false;<EOL>            }<EOL>            if (!src || src === Env.transparentSrc) {<EOL>                return","gt":"false;"}
{"input":"<s> export default function (uploadStatus, blobCache) {<EOL>    const cachedPromises = {};<EOL>    const findAll = function (elm, predicate?) {<EOL>        let images;<EOL>        if (!predicate) {<EOL>            predicate = Fun.constant(true);<EOL>        }<EOL>        images = Arr.filter(getAllImages(elm), function (img) {<EOL>            const src = img.src;<EOL>            if (!Env.fileApi) {<EOL>                return false;<EOL>            }<EOL>            if (img.hasAttribute('<STR_LIT>')) {<EOL>                return false;<EOL>            }<EOL>            if (img.hasAttribute('<STR_LIT>')) {<EOL>                return false;<EOL>            }<EOL>            if (!src || src === Env.transparentSrc) {<EOL>                return false;<EOL>            }<EOL>            if (src.indexOf('<STR_LIT>') === <NUM_LIT>) {<EOL>                return !uploadStatus.isUploaded(src);<EOL>            }<EOL>            if (src.indexOf('<STR_LIT>') === <NUM_LIT>) {<EOL>                return predicate(img);<EOL>            }<EOL>","gt":"return false;"}
{"input":"<s> export default function (uploadStatus, blobCache) {<EOL>    const cachedPromises = {};<EOL>    const findAll = function (elm, predicate?) {<EOL>        let images;<EOL>        if (!predicate) {<EOL>            predicate = Fun.constant(true);<EOL>        }<EOL>        images = Arr.filter(getAllImages(elm), function (img) {<EOL>            const src = img.src;<EOL>            if (!Env.fileApi) {<EOL>                return false;<EOL>            }<EOL>            if (img.hasAttribute('<STR_LIT>')) {<EOL>                return false;<EOL>            }<EOL>            if (img.hasAttribute('<STR_LIT>')) {<EOL>                return false;<EOL>            }<EOL>            if (!src || src === Env.transparentSrc) {<EOL>                return false;<EOL>            }<EOL>            if (src.indexOf('<STR_LIT>') === <NUM_LIT>) {<EOL>                return !uploadStatus.isUploaded(src);<EOL>            }<EOL>            if (src.indexOf('<STR_LIT>') === <NUM_LIT>) {<EOL>                return predicate(img);<EOL>            }<EOL>            return false;<EOL>        });<EOL>        const promises = Arr.map(images, function (img) {<EOL>            if (cachedPromises[img.src]) {<EOL>                <EOL>                <EOL>                return new Promise(function (resolve) {<EOL>                    cachedPromises[img.src].then(function (imageInfo) {<EOL>","gt":"if (typeof imageInfo === '<STR_LIT>') {"}
{"input":"<s> export default function (uploadStatus, blobCache) {<EOL>    const cachedPromises = {};<EOL>    const findAll = function (elm, predicate?) {<EOL>        let images;<EOL>        if (!predicate) {<EOL>            predicate = Fun.constant(true);<EOL>        }<EOL>        images = Arr.filter(getAllImages(elm), function (img) {<EOL>            const src = img.src;<EOL>            if (!Env.fileApi) {<EOL>                return false;<EOL>            }<EOL>            if (img.hasAttribute('<STR_LIT>')) {<EOL>                return false;<EOL>            }<EOL>            if (img.hasAttribute('<STR_LIT>')) {<EOL>                return false;<EOL>            }<EOL>            if (!src || src === Env.transparentSrc) {<EOL>                return false;<EOL>            }<EOL>            if (src.indexOf('<STR_LIT>') === <NUM_LIT>) {<EOL>                return !uploadStatus.isUploaded(src);<EOL>            }<EOL>            if (src.indexOf('<STR_LIT>') === <NUM_LIT>) {<EOL>                return predicate(img);<EOL>            }<EOL>            return false;<EOL>        });<EOL>        const promises = Arr.map(images, function (img) {<EOL>            if (cachedPromises[img.src]) {<EOL>                <EOL>                <EOL>                return new Promise(function (resolve) {<EOL>                    cachedPromises[img.src].then(function (imageInfo) {<EOL>                        if (typeof imageInfo === '<STR_LIT>') { <EOL>                            return imageInfo;<EOL>                        }<EOL>","gt":"resolve({"}
{"input":"<s> export default function (uploadStatus, blobCache) {<EOL>    const cachedPromises = {};<EOL>    const findAll = function (elm, predicate?) {<EOL>        let images;<EOL>        if (!predicate) {<EOL>            predicate = Fun.constant(true);<EOL>        }<EOL>        images = Arr.filter(getAllImages(elm), function (img) {<EOL>            const src = img.src;<EOL>            if (!Env.fileApi) {<EOL>                return false;<EOL>            }<EOL>            if (img.hasAttribute('<STR_LIT>')) {<EOL>                return false;<EOL>            }<EOL>            if (img.hasAttribute('<STR_LIT>')) {<EOL>                return false;<EOL>            }<EOL>            if (!src || src === Env.transparentSrc) {<EOL>                return false;<EOL>            }<EOL>            if (src.indexOf('<STR_LIT>') === <NUM_LIT>) {<EOL>                return !uploadStatus.isUploaded(src);<EOL>            }<EOL>            if (src.indexOf('<STR_LIT>') === <NUM_LIT>) {<EOL>                return predicate(img);<EOL>            }<EOL>            return false;<EOL>        });<EOL>        const promises = Arr.map(images, function (img) {<EOL>            if (cachedPromises[img.src]) {<EOL>                <EOL>                <EOL>                return new Promise(function (resolve) {<EOL>                    cachedPromises[img.src].then(function (imageInfo) {<EOL>                        if (typeof imageInfo === '<STR_LIT>') { <EOL>                            return imageInfo;<EOL>                        }<EOL>                        resolve({<EOL>                            image: img,<EOL>                            blobInfo: imageInfo.blobInfo<EOL>                        });<EOL>                    });<EOL>                });<EOL>            }<EOL>            const newPromise = new Promise<{<EOL>                image;<EOL>                blobInfo;<EOL>            }>(function (resolve, reject) {<EOL>","gt":"imageToBlobInfo(blobCache, img, resolve, reject);"}
{"input":"<s> export default function (uploadStatus, blobCache) {<EOL>    const cachedPromises = {};<EOL>    const findAll = function (elm, predicate?) {<EOL>        let images;<EOL>        if (!predicate) {<EOL>            predicate = Fun.constant(true);<EOL>        }<EOL>        images = Arr.filter(getAllImages(elm), function (img) {<EOL>            const src = img.src;<EOL>            if (!Env.fileApi) {<EOL>                return false;<EOL>            }<EOL>            if (img.hasAttribute('<STR_LIT>')) {<EOL>                return false;<EOL>            }<EOL>            if (img.hasAttribute('<STR_LIT>')) {<EOL>                return false;<EOL>            }<EOL>            if (!src || src === Env.transparentSrc) {<EOL>                return false;<EOL>            }<EOL>            if (src.indexOf('<STR_LIT>') === <NUM_LIT>) {<EOL>                return !uploadStatus.isUploaded(src);<EOL>            }<EOL>            if (src.indexOf('<STR_LIT>') === <NUM_LIT>) {<EOL>                return predicate(img);<EOL>            }<EOL>            return false;<EOL>        });<EOL>        const promises = Arr.map(images, function (img) {<EOL>            if (cachedPromises[img.src]) {<EOL>                <EOL>                <EOL>                return new Promise(function (resolve) {<EOL>                    cachedPromises[img.src].then(function (imageInfo) {<EOL>                        if (typeof imageInfo === '<STR_LIT>') { <EOL>                            return imageInfo;<EOL>                        }<EOL>                        resolve({<EOL>                            image: img,<EOL>                            blobInfo: imageInfo.blobInfo<EOL>                        });<EOL>                    });<EOL>                });<EOL>            }<EOL>            const newPromise = new Promise<{<EOL>                image;<EOL>                blobInfo;<EOL>            }>(function (resolve, reject) {<EOL>                imageToBlobInfo(blobCache, img, resolve, reject);<EOL>            }).then(function (result) {<EOL>                delete cachedPromises[result.image.src];<EOL>                return result;<EOL>            }).catch(function (","gt":"error) {"}
{"input":"<s> export default function (uploadStatus, blobCache) {<EOL>    const cachedPromises = {};<EOL>    const findAll = function (elm, predicate?) {<EOL>        let images;<EOL>        if (!predicate) {<EOL>            predicate = Fun.constant(true);<EOL>        }<EOL>        images = Arr.filter(getAllImages(elm), function (img) {<EOL>            const src = img.src;<EOL>            if (!Env.fileApi) {<EOL>                return false;<EOL>            }<EOL>            if (img.hasAttribute('<STR_LIT>')) {<EOL>                return false;<EOL>            }<EOL>            if (img.hasAttribute('<STR_LIT>')) {<EOL>                return false;<EOL>            }<EOL>            if (!src || src === Env.transparentSrc) {<EOL>                return false;<EOL>            }<EOL>            if (src.indexOf('<STR_LIT>') === <NUM_LIT>) {<EOL>                return !uploadStatus.isUploaded(src);<EOL>            }<EOL>            if (src.indexOf('<STR_LIT>') === <NUM_LIT>) {<EOL>                return predicate(img);<EOL>            }<EOL>            return false;<EOL>        });<EOL>        const promises = Arr.map(images, function (img) {<EOL>            if (cachedPromises[img.src]) {<EOL>                <EOL>                <EOL>                return new Promise(function (resolve) {<EOL>                    cachedPromises[img.src].then(function (imageInfo) {<EOL>                        if (typeof imageInfo === '<STR_LIT>') { <EOL>                            return imageInfo;<EOL>                        }<EOL>                        resolve({<EOL>                            image: img,<EOL>                            blobInfo: imageInfo.blobInfo<EOL>                        });<EOL>                    });<EOL>                });<EOL>            }<EOL>            const newPromise = new Promise<{<EOL>                image;<EOL>                blobInfo;<EOL>            }>(function (resolve, reject) {<EOL>                imageToBlobInfo(blobCache, img, resolve, reject);<EOL>            }).then(function (result) {<EOL>                delete cachedPromises[result.image.src];<EOL>                return result;<EOL>            }).catch(function (error) {<EOL>                delete cachedPromises[img.src];<EOL>                return","gt":"error;"}
{"input":"<s> export function ajaxGet<T>(url: string, resultSelector: (response: AjaxResponse) => T = defaultGetResultSelector, headers: Object = null) {<EOL>    return new AjaxObservable<T>({ method:","gt":"'<STR_LIT>', url, resultSelector, headers });"}
{"input":"<s> /**<EOL> * @return {ConnectableObservable<T>}<EOL> * @method publishLast<EOL> * @owner Observable<EOL> */<EOL>export function publishLast<T>(): ConnectableObservable<T> {<EOL>    return","gt":"multicast.call(this, new AsyncSubject<T>());"}
{"input":"<s> /**<EOL> * Returns an Observable that emits all items emitted by the source Observable that are distinct by comparison from previous items,<EOL> * using a property accessed by using the key provided to check if the two items are distinct.<EOL> * If a comparator function is provided, then it will be called for each item to test for whether or not that value should be emitted.<EOL> * If a comparator function is not provided, an equality check is used by default.<EOL> * As the internal HashSet of this operator grows larger and larger, care should be taken in the domain of inputs this operator may see.<EOL> * An optional parameter is also provided such that an Observable can be provided to queue the internal HashSet to flush the values it holds.<EOL> * @param {string} key string key for object property lookup on each item.<EOL> * @param {function} [compare] optional comparison function called to test if an item is distinct from previous items in the source.<EOL> * @param {Observable} [flushes] optional Observable for flushing the internal HashSet of the operator.<EOL> * @return {Observable} an Observable that emits items from the source Observable with distinct values.<EOL> * @method distinctKey<EOL> * @owner Observable<EOL> */<EOL>export function distinctKey<T>(key: string, compare?: (x: T, y: T) => boolean, flushes?: Observable<any>): Observable<T> {<EOL>    return distinct.call(this, function (x: T, y: T) {<EOL>","gt":"if (compare) {"}
{"input":"<s> /**<EOL> * Combines the source Observable with other Observables to create an Observable<EOL> * whose values are calculated from the latest values of each, only when the<EOL> * source emits.<EOL> *<EOL> * <span class=\"informal\">Whenever the source Observable emits a value, it<EOL> * computes a formula using that value plus the latest values from other input<EOL> * Observables, then emits the output of that formula.</span><EOL> *<EOL> * <img src=\"./img/withLatestFrom.png\" width=\"100%\"><EOL> *<EOL> * `withLatestFrom` combines each value from the source Observable (the<EOL> * instance) with the latest values from the other input Observables only when<EOL> * the source emits a value, optionally using a `project` function to determine<EOL> * the value to be emitted on the output Observable. All input Observables must<EOL> * emit at least one value before the output Observable will emit a value.<EOL> *<EOL> * @example <caption>On every click event, emit an array with the latest timer event plus the click event</caption><EOL> * var clicks = Rx.Observable.fromEvent(document, 'click');<EOL> * var timer = Rx.Observable.interval(1000);<EOL> * var result = clicks.withLatestFrom(timer);<EOL> * result.subscribe(x => console.log(x));<EOL> *<EOL> * @see {@link combineLatest}<EOL> *<EOL> * @param {Observable} other An input Observable to combine with the source<EOL> * Observable. More than one input Observables may be given as argument.<EOL> * @param {Function} [project] Projection function for combining values<EOL> * together. Receives all values in order of the Observables passed, where the<EOL> * first parameter is a value from the source Observable. (e.g.<EOL> * `a.withLatestFrom(b, c, (a1, b1, c1) => a1 + b1 + c1)`). If this is not<EOL> * passed, arrays will be emitted on the output Observable.<EOL> * @return {Observable} An Observable of projected values from the most recent<EOL> * values from each input Observable, or an array of the most recent values from<EOL> * each input Observable.<EOL> * @method withLatestFrom<EOL> * @owner Observable<EOL> */<EOL>export function withLatestFrom<T, R>(...args: Array<ObservableInput<any> | ((...values: Array<any>) => R)>): Observable<R> {<EOL>    let project: any;<EOL>    if (typeof args[","gt":"args.length - <NUM_LIT>] === '<STR_LIT>') {"}
{"input":"<s> function setResponseFile(name: string) {<EOL>    process.env['<STR_LIT>'] = path.join(__dirname,","gt":"name);"}
{"input":"<s> function setResponseFile(name: string) {<EOL>    process.env['<STR_LIT>'] = path.","gt":"join(__dirname, name);"}
{"input":"<s> /**<EOL> * Formats the given path to be appropriate for the operating system.<EOL> * @param canonicalPath A non-rooted path using a forward slash (/) as a directory separator.<EOL> */<EOL>export function formatPath(canonicalPath: string) {<EOL>    if (process.env[TestEnvVars.operatingSystem] === OperatingSystems.Windows) {<EOL>        return \"<STR_LIT>\" + canonicalPath.","gt":"replace('<STR_LIT>', '<STR_LIT>');"}
{"input":"<s> function resolveInputPatternToOneFile(inputName: string, required: boolean, name: string): string {<EOL>    let pattern = tl.getInput(inputName, required);<EOL>    if (!pattern) {<EOL>        return","gt":"null;"}
{"input":"<s> export default async function server(key: string, githubAccessToken: string, dry: boolean, fetcher: Fetcher, options: Options): Promise<Server> {<EOL>    const client = await NpmClient.create();<EOL>    return listenToGithub(key, githubAccessToken, fetcher, updateOneAtATime(async (log, timeStamp) => {<EOL>","gt":"log.info(\"<STR_LIT>\");"}
{"input":"<s> export function matchTag() {<EOL>    if (!validate(false) || !vscode.window.activeTextEditor) {<EOL>        return;<EOL>    }<EOL>    const editor = vscode.window.activeTextEditor;<EOL>    let rootNode = <HtmlNode>parseDocument(editor.document);<EOL>","gt":"if (!rootNode) {"}
{"input":"<s> export function matchTag() {<EOL>    if (!validate(false) || !vscode.window.activeTextEditor) {<EOL>        return;<EOL>    }<EOL>    const editor = vscode.window.activeTextEditor;<EOL>    let rootNode = <HtmlNode>parseDocument(editor.document);<EOL>    if (!rootNode) {<EOL>        return;<EOL>    }<EOL>    let updatedSelections: vscode.Selection[] = [];<EOL>    editor.selections.forEach(selection => {<EOL>        let","gt":"updatedSelection = getUpdatedSelections(editor, selection.start, rootNode);"}
{"input":"<s> export function GetScriptOperationName(operation: ScriptOperation) {<EOL>    let defaultName: string = ScriptOperation[operation];<EOL>    switch (operation) {<EOL>        case ScriptOperation.Select:<EOL>            return nls.localize('<STR_LIT>', '<STR_LIT>');<EOL>","gt":"case ScriptOperation.Create:"}
{"input":"<s> export function GetScriptOperationName(operation: ScriptOperation) {<EOL>    let defaultName: string = ScriptOperation[operation];<EOL>    switch (operation) {<EOL>        case ScriptOperation.Select:<EOL>            return nls.localize('<STR_LIT>', '<STR_LIT>');<EOL>        case ScriptOperation.Create:<EOL>            return nls.localize('<STR_LIT>', '<STR_LIT>');<EOL>        case ScriptOperation.Insert:<EOL>            return nls.localize('<STR_LIT>', '<STR_LIT>');<EOL>","gt":"case ScriptOperation.Update:"}
{"input":"<s> export function GetScriptOperationName(operation: ScriptOperation) {<EOL>    let defaultName: string = ScriptOperation[operation];<EOL>    switch (operation) {<EOL>        case ScriptOperation.Select:<EOL>            return nls.localize('<STR_LIT>', '<STR_LIT>');<EOL>        case ScriptOperation.Create:<EOL>            return nls.localize('<STR_LIT>', '<STR_LIT>');<EOL>        case ScriptOperation.Insert:<EOL>            return nls.localize('<STR_LIT>', '<STR_LIT>');<EOL>        case ScriptOperation.Update:<EOL>            return nls.localize('<STR_LIT>', '<STR_LIT>');<EOL>        case ScriptOperation.Delete:<EOL>            return nls.localize('<STR_LIT>', '<STR_LIT>');<EOL>","gt":"default:"}
{"input":"<s> function runNuGet(executionOptions: NuGetExecutionOptions): IExecSyncResult {<EOL>    let nugetTool = ngToolRunner.createNuGetToolRunner(executionOptions.nuGetPath, executionOptions.environment, executionOptions.authInfo);<EOL>    nugetTool.line(executionOptions.args);<EOL>    nugetTool.arg(","gt":"\"<STR_LIT>\");"}
{"input":"<s> /**<EOL> * Creates a new select box control.<EOL> *<EOL> * @-x-less SelectBox.less<EOL> * @class tinymce.ui.SelectBox<EOL> * @extends tinymce.ui.Widget<EOL> */<EOL>function createOptions(options) {<EOL>    let strOptions = '<STR_LIT>';<EOL>    if (options) {<EOL>        for (let","gt":"i = <NUM_LIT>; i < options.length; i++) {"}
{"input":"<s> function updateStatus(status: StatusBarItem): void {<EOL>    let text = getSelectedLines();<EOL>    if (text) {<EOL>        status.text = '<STR_LIT>' + text;<EOL>    }<EOL>    if (text) {<EOL>        status.show();<EOL>    }<EOL>","gt":"else {"}
{"input":"<s> function validate(args: ParsedArgs): ParsedArgs {<EOL>    if (args.goto) {<EOL>        args._.forEach(arg => assert(/^(\\w:)?[^:]+(:\\d*){0,2}$/.test(arg), localize('<STR_LIT>',","gt":"\"<STR_LIT>\")));"}
{"input":"<s> export function promoteSubtree(textEditor: vscode.TextEditor, edit: vscode.TextEditorEdit) {<EOL>    const document = textEditor.document;<EOL>    const cursorPos = Utils.getCursorPosition();<EOL>    let curLine = Utils.getLine(textEditor.document, cursorPos);<EOL>    let headerPrefix = Utils.getHeaderPrefix(curLine);<EOL>    let endOfContent = Utils.","gt":"findEndOfContent(document, cursorPos, headerPrefix);"}
{"input":"<s> export function promoteSubtree(textEditor: vscode.TextEditor, edit: vscode.TextEditorEdit) {<EOL>    const document = textEditor.document;<EOL>    const cursorPos = Utils.getCursorPosition();<EOL>    let curLine = Utils.getLine(textEditor.document, cursorPos);<EOL>    let headerPrefix = Utils.getHeaderPrefix(curLine);<EOL>    let endOfContent = Utils.findEndOfContent(document, cursorPos, headerPrefix);<EOL>    if (headerPrefix) {<EOL>        for (let i = cursorPos.line; i < endOfContent.line + <NUM_LIT>; ++i) {<EOL>            let curlineStart = new vscode.Position(i, <NUM_LIT>);<EOL>            let lineHeaderPrefix =","gt":"Utils.getHeaderPrefix(Utils.getLine(document, curlineStart));"}
{"input":"<s> <EOL>function expecting(errors: boolean[]): Failure[] {<EOL>    <EOL>    return errors.map((err) => {<EOL>        const status = err ?","gt":"'<STR_LIT>' : '<STR_LIT>';"}
{"input":"<s> export function getLeftZero() {<EOL>    const settings = vscode.workspace.","gt":"getConfiguration(\"<STR_LIT>\");"}
{"input":"<s> export function getUniq(arr: string[]): string[] {<EOL>    <EOL>    let map = {};<EOL>    let uniq = [];<EOL>    arr.","gt":"forEach(el => {"}
{"input":"<s> export function getUniq(arr: string[]): string[] {<EOL>    <EOL>    let map = {};<EOL>    let uniq = [];<EOL>    arr.forEach(el => {<EOL>        if (!map[el]) {<EOL>            uniq.push(el);<EOL>        }<EOL>        map[el] =","gt":"true;"}
{"input":"<s> function createClass<P, S>(clazz: {<EOL>    new (): Component<P, S>;<EOL>}, mixins?: react.Mixin<P, S>[]): react.ComponentClass<P> {<EOL>    var spec: react.ComponentSpec<P, S> = extractPrototype(clazz);<EOL>    spec.displayName = clazz.prototype.constructor.name;<EOL>    if (spec.componentWillMount !== undefined) {<EOL>        var componentWillMount = spec.componentWillMount;<EOL>        spec.componentWillMount = function () {<EOL>            clazz.","gt":"apply(this);"}
{"input":"<s> function createClass<P, S>(clazz: {<EOL>    new (): Component<P, S>;<EOL>}, mixins?: react.Mixin<P, S>[]): react.ComponentClass<P> {<EOL>    var spec: react.ComponentSpec<P, S> = extractPrototype(clazz);<EOL>    spec.displayName = clazz.prototype.constructor.name;<EOL>    if (spec.componentWillMount !== undefined) {<EOL>        var componentWillMount = spec.componentWillMount;<EOL>        spec.componentWillMount = function () {<EOL>            clazz.apply(this);<EOL>            componentWillMount.apply(this);<EOL>        };<EOL>    }<EOL>","gt":"else {"}
{"input":"<s> function expecting(errors: [<EOL>    string,<EOL>    number,<EOL>    number<EOL>][]): Failure[] {<EOL>    <EOL>    return errors.map((err) => {<EOL>","gt":"return {"}
{"input":"<s> function elemPath(elem: HTMLElement): string {<EOL>    const maxLen = <NUM_LIT>;<EOL>    let path: string[] = [];<EOL>    let parent = elem;<EOL>    while (parent) {<EOL>        let name = elemName(parent);<EOL>        if (","gt":"name !== '<STR_LIT>') {"}
{"input":"<s> function getSectionEl(element: HTMLElement) {<EOL>","gt":"return element.firstElementChild;"}
{"input":"<s> export function selectElements(element: HTMLElement, selector: string): HTMLElement[] {<EOL>","gt":"return [].slice.call(element.querySelectorAll(selector));"}
{"input":"<s> function updateSettingsWithParameters(result: any, overrideParametersString: string) {<EOL>    const overrideParameters = parameterParser.parse(overrideParametersString);<EOL>    var parametersArray;<EOL>    if (","gt":"result.RunSettings) {"}
{"input":"<s> function updateSettingsWithParameters(result: any, overrideParametersString: string) {<EOL>    const overrideParameters = parameterParser.parse(overrideParametersString);<EOL>    var parametersArray;<EOL>    if (result.RunSettings) {<EOL>        if (result.RunSettings.TestRunParameters && result.RunSettings.TestRunParameters[<NUM_LIT>] &&<EOL>            result.RunSettings.TestRunParameters[<NUM_LIT>].Parameter) {<EOL>            tl.","gt":"debug('<STR_LIT>');"}
{"input":"<s> function updateSettingsWithParameters(result: any, overrideParametersString: string) {<EOL>    const overrideParameters = parameterParser.parse(overrideParametersString);<EOL>    var parametersArray;<EOL>    if (result.RunSettings) {<EOL>        if (result.RunSettings.TestRunParameters && result.RunSettings.TestRunParameters[<NUM_LIT>] &&<EOL>            result.RunSettings.TestRunParameters[<NUM_LIT>].Parameter) {<EOL>            tl.debug('<STR_LIT>');<EOL>            parametersArray = result.RunSettings.TestRunParameters[<NUM_LIT>].Parameter;<EOL>        }<EOL>    }<EOL>    else","gt":"if (result.TestSettings) {"}
{"input":"<s> function updateSettingsWithParameters(result: any, overrideParametersString: string) {<EOL>    const overrideParameters = parameterParser.parse(overrideParametersString);<EOL>    var parametersArray;<EOL>    if (result.RunSettings) {<EOL>        if (result.RunSettings.TestRunParameters && result.RunSettings.TestRunParameters[<NUM_LIT>] &&<EOL>            result.RunSettings.TestRunParameters[<NUM_LIT>].Parameter) {<EOL>            tl.debug('<STR_LIT>');<EOL>            parametersArray = result.RunSettings.TestRunParameters[<NUM_LIT>].Parameter;<EOL>        }<EOL>    }<EOL>    else if (result.TestSettings) {<EOL>        if (result.TestSettings.Properties && result.TestSettings.Properties[<NUM_LIT>] &&<EOL>            result.TestSettings.Properties[<NUM_LIT>].Property) {<EOL>            tl.","gt":"debug('<STR_LIT>');"}
{"input":"<s> function updateSettingsWithParameters(result: any, overrideParametersString: string) {<EOL>    const overrideParameters = parameterParser.parse(overrideParametersString);<EOL>    var parametersArray;<EOL>    if (result.RunSettings) {<EOL>        if (result.RunSettings.TestRunParameters && result.RunSettings.TestRunParameters[<NUM_LIT>] &&<EOL>            result.RunSettings.TestRunParameters[<NUM_LIT>].Parameter) {<EOL>            tl.debug('<STR_LIT>');<EOL>            parametersArray = result.RunSettings.TestRunParameters[<NUM_LIT>].Parameter;<EOL>        }<EOL>    }<EOL>    else if (result.TestSettings) {<EOL>        if (result.TestSettings.Properties && result.TestSettings.Properties[<NUM_LIT>] &&<EOL>            result.TestSettings.Properties[<NUM_LIT>].Property) {<EOL>            tl.debug('<STR_LIT>');<EOL>            parametersArray = result.TestSettings.Properties[<NUM_LIT>].Property;<EOL>        }<EOL>    }<EOL>","gt":"if (parametersArray) {"}
{"input":"<s> function updateSettingsWithParameters(result: any, overrideParametersString: string) {<EOL>    const overrideParameters = parameterParser.parse(overrideParametersString);<EOL>    var parametersArray;<EOL>    if (result.RunSettings) {<EOL>        if (result.RunSettings.TestRunParameters && result.RunSettings.TestRunParameters[<NUM_LIT>] &&<EOL>            result.RunSettings.TestRunParameters[<NUM_LIT>].Parameter) {<EOL>            tl.debug('<STR_LIT>');<EOL>            parametersArray = result.RunSettings.TestRunParameters[<NUM_LIT>].Parameter;<EOL>        }<EOL>    }<EOL>    else if (result.TestSettings) {<EOL>        if (result.TestSettings.Properties && result.TestSettings.Properties[<NUM_LIT>] &&<EOL>            result.TestSettings.Properties[<NUM_LIT>].Property) {<EOL>            tl.debug('<STR_LIT>');<EOL>            parametersArray = result.TestSettings.Properties[<NUM_LIT>].Property;<EOL>        }<EOL>    }<EOL>    if (parametersArray) {<EOL>        parametersArray.forEach(function (parameter) {<EOL>            const key = parameter.$.Name || parameter.$.name;<EOL>            if (overrideParameters[key] && overrideParameters[key].value) {<EOL>                tl.debug('<STR_LIT>' + key);<EOL>                if (parameter.$.Value) {<EOL>                    parameter.$.Value = overrideParameters[key].","gt":"value;"}
{"input":"<s> export function reducer(state = initialState, action: Action): State {<EOL>    switch (action.type) {<EOL>        case '<STR_LIT>':<EOL>            return Object.assign({}, state);<EOL>","gt":"case '<STR_LIT>':"}
{"input":"<s> export function reducer(state = initialState, action: Action): State {<EOL>    switch (action.type) {<EOL>        case '<STR_LIT>':<EOL>            return Object.assign({}, state);<EOL>        case '<STR_LIT>':<EOL>            return Object.assign({}, state, { currentUser: null, loggedIn: false });<EOL>        case '<STR_LIT>':<EOL>","gt":"case '<STR_LIT>':"}
{"input":"<s> export function reducer(state = initialState, action: Action): State {<EOL>    switch (action.type) {<EOL>        case '<STR_LIT>':<EOL>            return Object.assign({}, state);<EOL>        case '<STR_LIT>':<EOL>            return Object.assign({}, state, { currentUser: null, loggedIn: false });<EOL>        case '<STR_LIT>':<EOL>        case '<STR_LIT>':<EOL>            return Object.assign({}, state, { currentUser: action.payload, loggedIn: true });<EOL>        case '<STR_LIT>':<EOL>            return Object.assign({}, state, { realms: [...state.realms, action.payload] });<EOL>        case","gt":"'<STR_LIT>':"}
{"input":"<s> function walk(ctx: Lint.WalkContext<ITerNoMixedSpacesAndTabsRuleOptions>): void {<EOL>    const { sourceFile, options: { tabs, smartTabs } } = ctx;<EOL>    let regExp: RegExp;<EOL>","gt":"if (tabs === true) {"}
{"input":"<s> function walk(ctx: Lint.WalkContext<ITerNoMixedSpacesAndTabsRuleOptions>): void {<EOL>    const { sourceFile, options: { tabs, smartTabs } } = ctx;<EOL>    let regExp: RegExp;<EOL>    if (tabs === true) {<EOL>        regExp = new RegExp(`<STR_LIT>`);<EOL>    }<EOL>    else if (tabs === false) {<EOL>        regExp =","gt":"new RegExp(`<STR_LIT>`);"}
{"input":"<s> function walk(ctx: Lint.WalkContext<ITerNoMixedSpacesAndTabsRuleOptions>): void {<EOL>    const { sourceFile, options: { tabs, smartTabs } } = ctx;<EOL>    let regExp: RegExp;<EOL>    if (tabs === true) {<EOL>        regExp = new RegExp(`<STR_LIT>`);<EOL>    }<EOL>    else if (tabs === false) {<EOL>        regExp = new RegExp(`<STR_LIT>`);<EOL>    }<EOL>    else {<EOL>        regExp = new RegExp(`<STR_LIT>`);<EOL>    }<EOL>    const failure = Rule.FAILURE_STRING(tabs ? '<STR_LIT>' : '<STR_LIT>', typeof tabs === '<STR_LIT>');<EOL>    for (const { pos, contentLength } of getLineRanges(sourceFile)) {<EOL>        if (contentLength === <NUM_LIT>) {<EOL>","gt":"continue;"}
{"input":"<s> function walk(ctx: Lint.WalkContext<ITerNoMixedSpacesAndTabsRuleOptions>): void {<EOL>    const { sourceFile, options: { tabs, smartTabs } } = ctx;<EOL>    let regExp: RegExp;<EOL>    if (tabs === true) {<EOL>        regExp = new RegExp(`<STR_LIT>`);<EOL>    }<EOL>    else if (tabs === false) {<EOL>        regExp = new RegExp(`<STR_LIT>`);<EOL>    }<EOL>    else {<EOL>        regExp = new RegExp(`<STR_LIT>`);<EOL>    }<EOL>    const failure = Rule.FAILURE_STRING(tabs ? '<STR_LIT>' : '<STR_LIT>', typeof tabs === '<STR_LIT>');<EOL>    for (const { pos, contentLength } of getLineRanges(sourceFile)) {<EOL>        if (contentLength === <NUM_LIT>) {<EOL>            continue;<EOL>        }<EOL>        const line = sourceFile.text.substr(pos, contentLength);<EOL>        let indentEnd = line.search(/\\S/);<EOL>","gt":"if (indentEnd === <NUM_LIT>) {"}
{"input":"<s> export default function makeFilter(): Filter {<EOL>    let lastNoticeJSON: string;<EOL>    let timeout;<EOL>    return function (notice: Notice): Notice | null {<EOL>        let s = JSON.stringify(notice.errors);<EOL>        if (s ===","gt":"lastNoticeJSON) {"}
{"input":"<s> export default function makeFilter(): Filter {<EOL>    let lastNoticeJSON: string;<EOL>    let timeout;<EOL>    return function (notice: Notice): Notice | null {<EOL>        let s = JSON.stringify(notice.errors);<EOL>        if (s === lastNoticeJSON) {<EOL>            return null;<EOL>        }<EOL>        if (timeout) {<EOL>","gt":"clearTimeout(timeout);"}
{"input":"<s> export default function makeFilter(): Filter {<EOL>    let lastNoticeJSON: string;<EOL>    let timeout;<EOL>    return function (notice: Notice): Notice | null {<EOL>        let s = JSON.stringify(notice.errors);<EOL>        if (s === lastNoticeJSON) {<EOL>            return null;<EOL>        }<EOL>        if (timeout) {<EOL>            clearTimeout(timeout);<EOL>        }<EOL>        lastNoticeJSON = s;<EOL>        timeout = setTimeout(() => {<EOL>            lastNoticeJSON =","gt":"'<STR_LIT>';"}
{"input":"<s> function getManager(): Scope {<EOL>","gt":"return wetland().getManager();"}
{"input":"<s> export function getActivatedRouteWithParent(params: any[]) {<EOL>    const route = new MockActivatedRoute();<EOL>    route.parent = new MockActivatedRoute();<EOL>    if (","gt":"params) {"}
{"input":"<s> <EOL>function expecting(errors: [<EOL>    number,<EOL>    number<EOL>]): Failure[] {<EOL>    return [{<EOL>","gt":"failure: '<STR_LIT>',"}
{"input":"<s> /**<EOL> * Return a Huffman Tree for the prefix codes. See the snapshot in `__snapshots`<EOL> * to have a visual rappresentation.<EOL> * @url https://en.wikipedia.org/wiki/Huffman_coding<EOL> *<EOL> * Time complexity: O(n*lg(n))<EOL> * @param frequences Characters frequencies<EOL> */<EOL>export function huffman(frequences: Frequency[]) {<EOL>    /**<EOL>     * Create a min priority queue with min-heap. An almost identical implementation<EOL>     * can be found in 'algorithms/misc/priority-queue' but for max priority.<EOL>     */<EOL>    const queue = new MinHeap((a: Frequency, b: Frequency) => a.frequency - b.frequency);<EOL>    frequences.forEach(freq => queue.insert(freq));<EOL>    range(<NUM_LIT>, frequences.length - <NUM_LIT>).forEach(() => {<EOL>","gt":"const left: Frequency = queue.removeHead();"}
{"input":"<s> <EOL><EOL>export function isInt(value: any): boolean {<EOL>    if (isNaN(value)) {<EOL>","gt":"return false;"}
{"input":"<s> export function binarize(data: Uint8ClampedArray, width: number, height: number): BitMatrix {<EOL>    if (data.length !== width * height * <NUM_LIT>) {<EOL>        throw new Error(\"<STR_LIT>\");<EOL>    }<EOL>    <EOL>    const greyscalePixels = new Matrix(width, height);<EOL>    for (let x = <NUM_LIT>; x < width; x++) {<EOL>        for (let y = <NUM_LIT>;","gt":"y < height; y++) {"}
{"input":"<s> export function binarize(data: Uint8ClampedArray, width: number, height: number): BitMatrix {<EOL>    if (data.length !== width * height * <NUM_LIT>) {<EOL>        throw new Error(\"<STR_LIT>\");<EOL>    }<EOL>    <EOL>    const greyscalePixels = new Matrix(width, height);<EOL>    for (let x = <NUM_LIT>; x < width; x++) {<EOL>        for (let y = <NUM_LIT>; y < height; y++) {<EOL>            const r = data[((y * width + x) * <NUM_LIT>) + <NUM_LIT>];<EOL>            const g = data[((y * width + x) * <NUM_LIT>) + <NUM_LIT>];<EOL>            const b = data[((","gt":"y * width + x) * <NUM_LIT>) + <NUM_LIT>];"}
{"input":"<s> export function binarize(data: Uint8ClampedArray, width: number, height: number): BitMatrix {<EOL>    if (data.length !== width * height * <NUM_LIT>) {<EOL>        throw new Error(\"<STR_LIT>\");<EOL>    }<EOL>    <EOL>    const greyscalePixels = new Matrix(width, height);<EOL>    for (let x = <NUM_LIT>; x < width; x++) {<EOL>        for (let y = <NUM_LIT>; y < height; y++) {<EOL>            const r = data[((y * width + x) * <NUM_LIT>) + <NUM_LIT>];<EOL>            const g = data[((y * width + x) * <NUM_LIT>) + <NUM_LIT>];<EOL>            const b = data[((y * width + x) * <NUM_LIT>) + <NUM_LIT>];<EOL>            greyscalePixels.set(x, y, <NUM_LIT> * r + <NUM_LIT> * g + <NUM_LIT> * b);<EOL>        }<EOL>    }<EOL>    const horizontalRegionCount =","gt":"Math.ceil(width / REGION_SIZE);"}
{"input":"<s> export function binarize(data: Uint8ClampedArray, width: number, height: number): BitMatrix {<EOL>    if (data.length !== width * height * <NUM_LIT>) {<EOL>        throw new Error(\"<STR_LIT>\");<EOL>    }<EOL>    <EOL>    const greyscalePixels = new Matrix(width, height);<EOL>    for (let x = <NUM_LIT>; x < width; x++) {<EOL>        for (let y = <NUM_LIT>; y < height; y++) {<EOL>            const r = data[((y * width + x) * <NUM_LIT>) + <NUM_LIT>];<EOL>            const g = data[((y * width + x) * <NUM_LIT>) + <NUM_LIT>];<EOL>            const b = data[((y * width + x) * <NUM_LIT>) + <NUM_LIT>];<EOL>            greyscalePixels.set(x, y, <NUM_LIT> * r + <NUM_LIT> * g + <NUM_LIT> * b);<EOL>        }<EOL>    }<EOL>    const horizontalRegionCount = Math.ceil(width / REGION_SIZE);<EOL>    const verticalRegionCount =","gt":"Math.ceil(height / REGION_SIZE);"}
{"input":"<s> export function binarize(data: Uint8ClampedArray, width: number, height: number): BitMatrix {<EOL>    if (data.length !== width * height * <NUM_LIT>) {<EOL>        throw new Error(\"<STR_LIT>\");<EOL>    }<EOL>    <EOL>    const greyscalePixels = new Matrix(width, height);<EOL>    for (let x = <NUM_LIT>; x < width; x++) {<EOL>        for (let y = <NUM_LIT>; y < height; y++) {<EOL>            const r = data[((y * width + x) * <NUM_LIT>) + <NUM_LIT>];<EOL>            const g = data[((y * width + x) * <NUM_LIT>) + <NUM_LIT>];<EOL>            const b = data[((y * width + x) * <NUM_LIT>) + <NUM_LIT>];<EOL>            greyscalePixels.set(x, y, <NUM_LIT> * r + <NUM_LIT> * g + <NUM_LIT> * b);<EOL>        }<EOL>    }<EOL>    const horizontalRegionCount = Math.ceil(width / REGION_SIZE);<EOL>    const verticalRegionCount = Math.ceil(height / REGION_SIZE);<EOL>    const blackPoints = new Matrix(horizontalRegionCount, verticalRegionCount);<EOL>    for (let verticalRegion = <NUM_LIT>; verticalRegion < verticalRegionCount; verticalRegion++) {<EOL>        for (let hortizontalRegion = <NUM_LIT>; hortizontalRegion < horizontalRegionCount; hortizontalRegion++) {<EOL>            let sum = <NUM_LIT>;<EOL>            let min = Infinity;<EOL>            let max = <NUM_LIT>;<EOL>            for (let y = <NUM_LIT>; y < REGION_SIZE; y++) {<EOL>                for (let x = <NUM_LIT>; x < REGION_SIZE; x++) {<EOL>                    const pixelLumosity = greyscalePixels.get(hortizontalRegion *","gt":"REGION_SIZE + x, verticalRegion * REGION_SIZE + y);"}
{"input":"<s> export function binarize(data: Uint8ClampedArray, width: number, height: number): BitMatrix {<EOL>    if (data.length !== width * height * <NUM_LIT>) {<EOL>        throw new Error(\"<STR_LIT>\");<EOL>    }<EOL>    <EOL>    const greyscalePixels = new Matrix(width, height);<EOL>    for (let x = <NUM_LIT>; x < width; x++) {<EOL>        for (let y = <NUM_LIT>; y < height; y++) {<EOL>            const r = data[((y * width + x) * <NUM_LIT>) + <NUM_LIT>];<EOL>            const g = data[((y * width + x) * <NUM_LIT>) + <NUM_LIT>];<EOL>            const b = data[((y * width + x) * <NUM_LIT>) + <NUM_LIT>];<EOL>            greyscalePixels.set(x, y, <NUM_LIT> * r + <NUM_LIT> * g + <NUM_LIT> * b);<EOL>        }<EOL>    }<EOL>    const horizontalRegionCount = Math.ceil(width / REGION_SIZE);<EOL>    const verticalRegionCount = Math.ceil(height / REGION_SIZE);<EOL>    const blackPoints = new Matrix(horizontalRegionCount, verticalRegionCount);<EOL>    for (let verticalRegion = <NUM_LIT>; verticalRegion < verticalRegionCount; verticalRegion++) {<EOL>        for (let hortizontalRegion = <NUM_LIT>; hortizontalRegion < horizontalRegionCount; hortizontalRegion++) {<EOL>            let sum = <NUM_LIT>;<EOL>            let min = Infinity;<EOL>            let max = <NUM_LIT>;<EOL>            for (let y = <NUM_LIT>; y < REGION_SIZE; y++) {<EOL>                for (let x = <NUM_LIT>; x < REGION_SIZE; x++) {<EOL>                    const pixelLumosity = greyscalePixels.get(hortizontalRegion * REGION_SIZE + x, verticalRegion * REGION_SIZE + y);<EOL>                    sum += pixelLumosity;<EOL>                    min = Math.min(min, pixelLumosity);<EOL>                    max = Math.max(max, pixelLumosity);<EOL>                }<EOL>            }<EOL>            let average = sum / (REGION_SIZE ** <NUM_LIT>);<EOL>            if (max - min <= MIN_DYNAMIC_RANGE) {<EOL>                <EOL>                <EOL>                <EOL>                <EOL>                <EOL>                average = min / <NUM_LIT>;<EOL>                if (verticalRegion > <NUM_LIT> && hortizontalRegion > <NUM_LIT>) {<EOL>                    <EOL>                    <EOL>                    <EOL>                    <EOL>                    <EOL>                    <EOL>                    const averageNeighborBlackPoint = (blackPoints.","gt":"get(hortizontalRegion, verticalRegion - <NUM_LIT>) +"}
{"input":"<s> export function binarize(data: Uint8ClampedArray, width: number, height: number): BitMatrix {<EOL>    if (data.length !== width * height * <NUM_LIT>) {<EOL>        throw new Error(\"<STR_LIT>\");<EOL>    }<EOL>    <EOL>    const greyscalePixels = new Matrix(width, height);<EOL>    for (let x = <NUM_LIT>; x < width; x++) {<EOL>        for (let y = <NUM_LIT>; y < height; y++) {<EOL>            const r = data[((y * width + x) * <NUM_LIT>) + <NUM_LIT>];<EOL>            const g = data[((y * width + x) * <NUM_LIT>) + <NUM_LIT>];<EOL>            const b = data[((y * width + x) * <NUM_LIT>) + <NUM_LIT>];<EOL>            greyscalePixels.set(x, y, <NUM_LIT> * r + <NUM_LIT> * g + <NUM_LIT> * b);<EOL>        }<EOL>    }<EOL>    const horizontalRegionCount = Math.ceil(width / REGION_SIZE);<EOL>    const verticalRegionCount = Math.ceil(height / REGION_SIZE);<EOL>    const blackPoints = new Matrix(horizontalRegionCount, verticalRegionCount);<EOL>    for (let verticalRegion = <NUM_LIT>; verticalRegion < verticalRegionCount; verticalRegion++) {<EOL>        for (let hortizontalRegion = <NUM_LIT>; hortizontalRegion < horizontalRegionCount; hortizontalRegion++) {<EOL>            let sum = <NUM_LIT>;<EOL>            let min = Infinity;<EOL>            let max = <NUM_LIT>;<EOL>            for (let y = <NUM_LIT>; y < REGION_SIZE; y++) {<EOL>                for (let x = <NUM_LIT>; x < REGION_SIZE; x++) {<EOL>                    const pixelLumosity = greyscalePixels.get(hortizontalRegion * REGION_SIZE + x, verticalRegion * REGION_SIZE + y);<EOL>                    sum += pixelLumosity;<EOL>                    min = Math.min(min, pixelLumosity);<EOL>                    max = Math.max(max, pixelLumosity);<EOL>                }<EOL>            }<EOL>            let average = sum / (REGION_SIZE ** <NUM_LIT>);<EOL>            if (max - min <= MIN_DYNAMIC_RANGE) {<EOL>                <EOL>                <EOL>                <EOL>                <EOL>                <EOL>                average = min / <NUM_LIT>;<EOL>                if (verticalRegion > <NUM_LIT> && hortizontalRegion > <NUM_LIT>) {<EOL>                    <EOL>                    <EOL>                    <EOL>                    <EOL>                    <EOL>                    <EOL>                    const averageNeighborBlackPoint = (blackPoints.get(hortizontalRegion, verticalRegion - <NUM_LIT>) +<EOL>                        (<NUM_LIT> * blackPoints.get(hortizontalRegion - <NUM_LIT>, verticalRegion)) +<EOL>                        blackPoints.get(hortizontalRegion - <NUM_LIT>, verticalRegion - <NUM_LIT>)) / <NUM_LIT>;<EOL>","gt":"if (min < averageNeighborBlackPoint) {"}
{"input":"<s> export function binarize(data: Uint8ClampedArray, width: number, height: number): BitMatrix {<EOL>    if (data.length !== width * height * <NUM_LIT>) {<EOL>        throw new Error(\"<STR_LIT>\");<EOL>    }<EOL>    <EOL>    const greyscalePixels = new Matrix(width, height);<EOL>    for (let x = <NUM_LIT>; x < width; x++) {<EOL>        for (let y = <NUM_LIT>; y < height; y++) {<EOL>            const r = data[((y * width + x) * <NUM_LIT>) + <NUM_LIT>];<EOL>            const g = data[((y * width + x) * <NUM_LIT>) + <NUM_LIT>];<EOL>            const b = data[((y * width + x) * <NUM_LIT>) + <NUM_LIT>];<EOL>            greyscalePixels.set(x, y, <NUM_LIT> * r + <NUM_LIT> * g + <NUM_LIT> * b);<EOL>        }<EOL>    }<EOL>    const horizontalRegionCount = Math.ceil(width / REGION_SIZE);<EOL>    const verticalRegionCount = Math.ceil(height / REGION_SIZE);<EOL>    const blackPoints = new Matrix(horizontalRegionCount, verticalRegionCount);<EOL>    for (let verticalRegion = <NUM_LIT>; verticalRegion < verticalRegionCount; verticalRegion++) {<EOL>        for (let hortizontalRegion = <NUM_LIT>; hortizontalRegion < horizontalRegionCount; hortizontalRegion++) {<EOL>            let sum = <NUM_LIT>;<EOL>            let min = Infinity;<EOL>            let max = <NUM_LIT>;<EOL>            for (let y = <NUM_LIT>; y < REGION_SIZE; y++) {<EOL>                for (let x = <NUM_LIT>; x < REGION_SIZE; x++) {<EOL>                    const pixelLumosity = greyscalePixels.get(hortizontalRegion * REGION_SIZE + x, verticalRegion * REGION_SIZE + y);<EOL>                    sum += pixelLumosity;<EOL>                    min = Math.min(min, pixelLumosity);<EOL>                    max = Math.max(max, pixelLumosity);<EOL>                }<EOL>            }<EOL>            let average = sum / (REGION_SIZE ** <NUM_LIT>);<EOL>            if (max - min <= MIN_DYNAMIC_RANGE) {<EOL>                <EOL>                <EOL>                <EOL>                <EOL>                <EOL>                average = min / <NUM_LIT>;<EOL>                if (verticalRegion > <NUM_LIT> && hortizontalRegion > <NUM_LIT>) {<EOL>                    <EOL>                    <EOL>                    <EOL>                    <EOL>                    <EOL>                    <EOL>                    const averageNeighborBlackPoint = (blackPoints.get(hortizontalRegion, verticalRegion - <NUM_LIT>) +<EOL>                        (<NUM_LIT> * blackPoints.get(hortizontalRegion - <NUM_LIT>, verticalRegion)) +<EOL>                        blackPoints.get(hortizontalRegion - <NUM_LIT>, verticalRegion - <NUM_LIT>)) / <NUM_LIT>;<EOL>                    if (min < averageNeighborBlackPoint) {<EOL>                        average = averageNeighborBlackPoint;<EOL>                    }<EOL>                }<EOL>            }<EOL>            blackPoints.set(hortizontalRegion, verticalRegion, average);<EOL>        }<EOL>    }<EOL>    const binarized = BitMatrix.createEmpty(width, height);<EOL>    for (let verticalRegion = <NUM_LIT>; verticalRegion < verticalRegionCount; verticalRegion++) {<EOL>        for (let hortizontalRegion = <NUM_LIT>;","gt":"hortizontalRegion < horizontalRegionCount; hortizontalRegion++) {"}
{"input":"<s> export function binarize(data: Uint8ClampedArray, width: number, height: number): BitMatrix {<EOL>    if (data.length !== width * height * <NUM_LIT>) {<EOL>        throw new Error(\"<STR_LIT>\");<EOL>    }<EOL>    <EOL>    const greyscalePixels = new Matrix(width, height);<EOL>    for (let x = <NUM_LIT>; x < width; x++) {<EOL>        for (let y = <NUM_LIT>; y < height; y++) {<EOL>            const r = data[((y * width + x) * <NUM_LIT>) + <NUM_LIT>];<EOL>            const g = data[((y * width + x) * <NUM_LIT>) + <NUM_LIT>];<EOL>            const b = data[((y * width + x) * <NUM_LIT>) + <NUM_LIT>];<EOL>            greyscalePixels.set(x, y, <NUM_LIT> * r + <NUM_LIT> * g + <NUM_LIT> * b);<EOL>        }<EOL>    }<EOL>    const horizontalRegionCount = Math.ceil(width / REGION_SIZE);<EOL>    const verticalRegionCount = Math.ceil(height / REGION_SIZE);<EOL>    const blackPoints = new Matrix(horizontalRegionCount, verticalRegionCount);<EOL>    for (let verticalRegion = <NUM_LIT>; verticalRegion < verticalRegionCount; verticalRegion++) {<EOL>        for (let hortizontalRegion = <NUM_LIT>; hortizontalRegion < horizontalRegionCount; hortizontalRegion++) {<EOL>            let sum = <NUM_LIT>;<EOL>            let min = Infinity;<EOL>            let max = <NUM_LIT>;<EOL>            for (let y = <NUM_LIT>; y < REGION_SIZE; y++) {<EOL>                for (let x = <NUM_LIT>; x < REGION_SIZE; x++) {<EOL>                    const pixelLumosity = greyscalePixels.get(hortizontalRegion * REGION_SIZE + x, verticalRegion * REGION_SIZE + y);<EOL>                    sum += pixelLumosity;<EOL>                    min = Math.min(min, pixelLumosity);<EOL>                    max = Math.max(max, pixelLumosity);<EOL>                }<EOL>            }<EOL>            let average = sum / (REGION_SIZE ** <NUM_LIT>);<EOL>            if (max - min <= MIN_DYNAMIC_RANGE) {<EOL>                <EOL>                <EOL>                <EOL>                <EOL>                <EOL>                average = min / <NUM_LIT>;<EOL>                if (verticalRegion > <NUM_LIT> && hortizontalRegion > <NUM_LIT>) {<EOL>                    <EOL>                    <EOL>                    <EOL>                    <EOL>                    <EOL>                    <EOL>                    const averageNeighborBlackPoint = (blackPoints.get(hortizontalRegion, verticalRegion - <NUM_LIT>) +<EOL>                        (<NUM_LIT> * blackPoints.get(hortizontalRegion - <NUM_LIT>, verticalRegion)) +<EOL>                        blackPoints.get(hortizontalRegion - <NUM_LIT>, verticalRegion - <NUM_LIT>)) / <NUM_LIT>;<EOL>                    if (min < averageNeighborBlackPoint) {<EOL>                        average = averageNeighborBlackPoint;<EOL>                    }<EOL>                }<EOL>            }<EOL>            blackPoints.set(hortizontalRegion, verticalRegion, average);<EOL>        }<EOL>    }<EOL>    const binarized = BitMatrix.createEmpty(width, height);<EOL>    for (let verticalRegion = <NUM_LIT>; verticalRegion < verticalRegionCount; verticalRegion++) {<EOL>        for (let hortizontalRegion = <NUM_LIT>; hortizontalRegion < horizontalRegionCount; hortizontalRegion++) {<EOL>            const left = numBetween(hortizontalRegion, <NUM_LIT>, horizontalRegionCount - <NUM_LIT>);<EOL>            const top = numBetween(verticalRegion, <NUM_LIT>, verticalRegionCount - <NUM_LIT>);<EOL>            let sum = <NUM_LIT>;<EOL>            for (let xRegion = -<NUM_LIT>;","gt":"xRegion <= <NUM_LIT>; xRegion++) {"}
{"input":"<s> export function binarize(data: Uint8ClampedArray, width: number, height: number): BitMatrix {<EOL>    if (data.length !== width * height * <NUM_LIT>) {<EOL>        throw new Error(\"<STR_LIT>\");<EOL>    }<EOL>    <EOL>    const greyscalePixels = new Matrix(width, height);<EOL>    for (let x = <NUM_LIT>; x < width; x++) {<EOL>        for (let y = <NUM_LIT>; y < height; y++) {<EOL>            const r = data[((y * width + x) * <NUM_LIT>) + <NUM_LIT>];<EOL>            const g = data[((y * width + x) * <NUM_LIT>) + <NUM_LIT>];<EOL>            const b = data[((y * width + x) * <NUM_LIT>) + <NUM_LIT>];<EOL>            greyscalePixels.set(x, y, <NUM_LIT> * r + <NUM_LIT> * g + <NUM_LIT> * b);<EOL>        }<EOL>    }<EOL>    const horizontalRegionCount = Math.ceil(width / REGION_SIZE);<EOL>    const verticalRegionCount = Math.ceil(height / REGION_SIZE);<EOL>    const blackPoints = new Matrix(horizontalRegionCount, verticalRegionCount);<EOL>    for (let verticalRegion = <NUM_LIT>; verticalRegion < verticalRegionCount; verticalRegion++) {<EOL>        for (let hortizontalRegion = <NUM_LIT>; hortizontalRegion < horizontalRegionCount; hortizontalRegion++) {<EOL>            let sum = <NUM_LIT>;<EOL>            let min = Infinity;<EOL>            let max = <NUM_LIT>;<EOL>            for (let y = <NUM_LIT>; y < REGION_SIZE; y++) {<EOL>                for (let x = <NUM_LIT>; x < REGION_SIZE; x++) {<EOL>                    const pixelLumosity = greyscalePixels.get(hortizontalRegion * REGION_SIZE + x, verticalRegion * REGION_SIZE + y);<EOL>                    sum += pixelLumosity;<EOL>                    min = Math.min(min, pixelLumosity);<EOL>                    max = Math.max(max, pixelLumosity);<EOL>                }<EOL>            }<EOL>            let average = sum / (REGION_SIZE ** <NUM_LIT>);<EOL>            if (max - min <= MIN_DYNAMIC_RANGE) {<EOL>                <EOL>                <EOL>                <EOL>                <EOL>                <EOL>                average = min / <NUM_LIT>;<EOL>                if (verticalRegion > <NUM_LIT> && hortizontalRegion > <NUM_LIT>) {<EOL>                    <EOL>                    <EOL>                    <EOL>                    <EOL>                    <EOL>                    <EOL>                    const averageNeighborBlackPoint = (blackPoints.get(hortizontalRegion, verticalRegion - <NUM_LIT>) +<EOL>                        (<NUM_LIT> * blackPoints.get(hortizontalRegion - <NUM_LIT>, verticalRegion)) +<EOL>                        blackPoints.get(hortizontalRegion - <NUM_LIT>, verticalRegion - <NUM_LIT>)) / <NUM_LIT>;<EOL>                    if (min < averageNeighborBlackPoint) {<EOL>                        average = averageNeighborBlackPoint;<EOL>                    }<EOL>                }<EOL>            }<EOL>            blackPoints.set(hortizontalRegion, verticalRegion, average);<EOL>        }<EOL>    }<EOL>    const binarized = BitMatrix.createEmpty(width, height);<EOL>    for (let verticalRegion = <NUM_LIT>; verticalRegion < verticalRegionCount; verticalRegion++) {<EOL>        for (let hortizontalRegion = <NUM_LIT>; hortizontalRegion < horizontalRegionCount; hortizontalRegion++) {<EOL>            const left = numBetween(hortizontalRegion, <NUM_LIT>, horizontalRegionCount - <NUM_LIT>);<EOL>            const top = numBetween(verticalRegion, <NUM_LIT>, verticalRegionCount - <NUM_LIT>);<EOL>            let sum = <NUM_LIT>;<EOL>            for (let xRegion = -<NUM_LIT>; xRegion <= <NUM_LIT>; xRegion++) {<EOL>                for (let yRegion = -<NUM_LIT>;","gt":"yRegion <= <NUM_LIT>; yRegion++) {"}
{"input":"<s> export function binarize(data: Uint8ClampedArray, width: number, height: number): BitMatrix {<EOL>    if (data.length !== width * height * <NUM_LIT>) {<EOL>        throw new Error(\"<STR_LIT>\");<EOL>    }<EOL>    <EOL>    const greyscalePixels = new Matrix(width, height);<EOL>    for (let x = <NUM_LIT>; x < width; x++) {<EOL>        for (let y = <NUM_LIT>; y < height; y++) {<EOL>            const r = data[((y * width + x) * <NUM_LIT>) + <NUM_LIT>];<EOL>            const g = data[((y * width + x) * <NUM_LIT>) + <NUM_LIT>];<EOL>            const b = data[((y * width + x) * <NUM_LIT>) + <NUM_LIT>];<EOL>            greyscalePixels.set(x, y, <NUM_LIT> * r + <NUM_LIT> * g + <NUM_LIT> * b);<EOL>        }<EOL>    }<EOL>    const horizontalRegionCount = Math.ceil(width / REGION_SIZE);<EOL>    const verticalRegionCount = Math.ceil(height / REGION_SIZE);<EOL>    const blackPoints = new Matrix(horizontalRegionCount, verticalRegionCount);<EOL>    for (let verticalRegion = <NUM_LIT>; verticalRegion < verticalRegionCount; verticalRegion++) {<EOL>        for (let hortizontalRegion = <NUM_LIT>; hortizontalRegion < horizontalRegionCount; hortizontalRegion++) {<EOL>            let sum = <NUM_LIT>;<EOL>            let min = Infinity;<EOL>            let max = <NUM_LIT>;<EOL>            for (let y = <NUM_LIT>; y < REGION_SIZE; y++) {<EOL>                for (let x = <NUM_LIT>; x < REGION_SIZE; x++) {<EOL>                    const pixelLumosity = greyscalePixels.get(hortizontalRegion * REGION_SIZE + x, verticalRegion * REGION_SIZE + y);<EOL>                    sum += pixelLumosity;<EOL>                    min = Math.min(min, pixelLumosity);<EOL>                    max = Math.max(max, pixelLumosity);<EOL>                }<EOL>            }<EOL>            let average = sum / (REGION_SIZE ** <NUM_LIT>);<EOL>            if (max - min <= MIN_DYNAMIC_RANGE) {<EOL>                <EOL>                <EOL>                <EOL>                <EOL>                <EOL>                average = min / <NUM_LIT>;<EOL>                if (verticalRegion > <NUM_LIT> && hortizontalRegion > <NUM_LIT>) {<EOL>                    <EOL>                    <EOL>                    <EOL>                    <EOL>                    <EOL>                    <EOL>                    const averageNeighborBlackPoint = (blackPoints.get(hortizontalRegion, verticalRegion - <NUM_LIT>) +<EOL>                        (<NUM_LIT> * blackPoints.get(hortizontalRegion - <NUM_LIT>, verticalRegion)) +<EOL>                        blackPoints.get(hortizontalRegion - <NUM_LIT>, verticalRegion - <NUM_LIT>)) / <NUM_LIT>;<EOL>                    if (min < averageNeighborBlackPoint) {<EOL>                        average = averageNeighborBlackPoint;<EOL>                    }<EOL>                }<EOL>            }<EOL>            blackPoints.set(hortizontalRegion, verticalRegion, average);<EOL>        }<EOL>    }<EOL>    const binarized = BitMatrix.createEmpty(width, height);<EOL>    for (let verticalRegion = <NUM_LIT>; verticalRegion < verticalRegionCount; verticalRegion++) {<EOL>        for (let hortizontalRegion = <NUM_LIT>; hortizontalRegion < horizontalRegionCount; hortizontalRegion++) {<EOL>            const left = numBetween(hortizontalRegion, <NUM_LIT>, horizontalRegionCount - <NUM_LIT>);<EOL>            const top = numBetween(verticalRegion, <NUM_LIT>, verticalRegionCount - <NUM_LIT>);<EOL>            let sum = <NUM_LIT>;<EOL>            for (let xRegion = -<NUM_LIT>; xRegion <= <NUM_LIT>; xRegion++) {<EOL>                for (let yRegion = -<NUM_LIT>; yRegion <= <NUM_LIT>; yRegion++) {<EOL>                    sum += blackPoints.get(left + xRegion, top + yRegion);<EOL>                }<EOL>            }<EOL>            const","gt":"threshold = sum / <NUM_LIT>;"}
{"input":"<s> function condense(unmatched, map?, filter?, context?, xml?) {<EOL>    let elem, newUnmatched = [], i = <NUM_LIT>, len = unmatched.length, mapped = map != null;<EOL>    for (; i < len; i++) {<EOL>        if ((elem = unmatched[i])) {<EOL>            if (!filter || filter(","gt":"elem, context, xml)) {"}
{"input":"<s> function getSettings(scope: string, selector: string) {<EOL>    VSS.getService(VSS.ServiceIds.ExtensionData).then((dataService: Extension_Data.ExtensionDataService) => {<EOL>        const boolPromise = dataService.getValue(\"<STR_LIT>\", { scopeType: scope });<EOL>        const numPromise = dataService.getValue(\"<STR_LIT>\", { scopeType: scope });<EOL>        const objPromise =","gt":"dataService.getValue(\"<STR_LIT>\", { scopeType: scope });"}
{"input":"<s> function getSettings(scope: string, selector: string) {<EOL>    VSS.getService(VSS.ServiceIds.ExtensionData).then((dataService: Extension_Data.ExtensionDataService) => {<EOL>        const boolPromise = dataService.getValue(\"<STR_LIT>\", { scopeType: scope });<EOL>        const numPromise = dataService.getValue(\"<STR_LIT>\", { scopeType: scope });<EOL>        const objPromise = dataService.getValue(\"<STR_LIT>\", { scopeType: scope });<EOL>        Q.all([boolPromise, numPromise, objPromise]).spread((boolValue: boolean, numValue: number, objValue: any) => {<EOL>            $(selector + \"<STR_LIT>\").prop(\"<STR_LIT>\", boolValue);<EOL>            $(selector + \"<STR_LIT>\").val(numValue ? numValue.toString() : \"<STR_LIT>\");<EOL>            $(selector + \"<STR_LIT>\").val(objValue ? objValue.val1 : \"<STR_LIT>\");<EOL>            $(selector + \"<STR_LIT>\").val(objValue ? objValue.val2 :","gt":"\"<STR_LIT>\");"}
{"input":"<s> function autoFixEdit(startLine, startChar, endLine, endChar): TSLintAutofixEdit {<EOL>    return {<EOL>        range: range(","gt":"startLine, startChar, endLine, endChar),"}
{"input":"<s> function flipIn(rotateX, rotateY) {<EOL>    const params = { timing: DEFAULT_TIMING, delay: <NUM_LIT>, rotateX, rotateY };<EOL>    return animation([<EOL>        style({ '<STR_LIT>': '<STR_LIT>' }),<EOL>        animate('<STR_LIT>', keyframes([<EOL>            style({<EOL>","gt":"opacity: <NUM_LIT>,"}
{"input":"<s> function flipIn(rotateX, rotateY) {<EOL>    const params = { timing: DEFAULT_TIMING, delay: <NUM_LIT>, rotateX, rotateY };<EOL>    return animation([<EOL>        style({ '<STR_LIT>': '<STR_LIT>' }),<EOL>        animate('<STR_LIT>', keyframes([<EOL>            style({<EOL>                opacity: <NUM_LIT>,<EOL>                transform: '<STR_LIT>',<EOL>                offset: <NUM_LIT>,<EOL>            }),<EOL>            style({<EOL>                opacity: <NUM_LIT>,<EOL>                transform:","gt":"'<STR_LIT>',"}
{"input":"<s> function flipIn(rotateX, rotateY) {<EOL>    const params = { timing: DEFAULT_TIMING, delay: <NUM_LIT>, rotateX, rotateY };<EOL>    return animation([<EOL>        style({ '<STR_LIT>': '<STR_LIT>' }),<EOL>        animate('<STR_LIT>', keyframes([<EOL>            style({<EOL>                opacity: <NUM_LIT>,<EOL>                transform: '<STR_LIT>',<EOL>                offset: <NUM_LIT>,<EOL>            }),<EOL>            style({<EOL>                opacity: <NUM_LIT>,<EOL>                transform: '<STR_LIT>',<EOL>                offset: <NUM_LIT>,<EOL>            }),<EOL>","gt":"style({"}
{"input":"<s> function flipIn(rotateX, rotateY) {<EOL>    const params = { timing: DEFAULT_TIMING, delay: <NUM_LIT>, rotateX, rotateY };<EOL>    return animation([<EOL>        style({ '<STR_LIT>': '<STR_LIT>' }),<EOL>        animate('<STR_LIT>', keyframes([<EOL>            style({<EOL>                opacity: <NUM_LIT>,<EOL>                transform: '<STR_LIT>',<EOL>                offset: <NUM_LIT>,<EOL>            }),<EOL>            style({<EOL>                opacity: <NUM_LIT>,<EOL>                transform: '<STR_LIT>',<EOL>                offset: <NUM_LIT>,<EOL>            }),<EOL>            style({<EOL>                transform: '<STR_LIT>',<EOL>                offset: <NUM_LIT>,<EOL>            }),<EOL>            style({<EOL>                transform: '<STR_LIT>',<EOL>                offset:","gt":"<NUM_LIT>,"}
{"input":"<s> export function getSyntheticNodeById(root: any, id: string): SyntheticNode {<EOL>    const","gt":"window = root.$type === SYNTHETIC_WINDOW ? root : getSyntheticNodeWindow(root, id);"}
{"input":"<s> function setClass(instance: IReplaceClass, klasses: string | string[], isAdd: boolean) {<EOL>    if (klasses) {<EOL>        (","gt":"Array.isArray(klasses) ? klasses : [klasses]).forEach(k => {"}
{"input":"<s> export default function loadConfig(): Promise<Config> {<EOL>    return new Promise<Config>(resolve => {<EOL>        fs.readFile(CONFIG_FILE, '<STR_LIT>', (err, json) => {<EOL>            if (err) {<EOL>                log.info('<STR_LIT>',","gt":"CONFIG_FILE);"}
{"input":"<s> export default function loadConfig(): Promise<Config> {<EOL>    return new Promise<Config>(resolve => {<EOL>        fs.readFile(CONFIG_FILE, '<STR_LIT>', (err, json) => {<EOL>            if (err) {<EOL>                log.info('<STR_LIT>', CONFIG_FILE);<EOL>                const default_config = makeDefaultConfig();<EOL>                <EOL>                <EOL>                <EOL>                if (app.isReady()) {<EOL>                    fs.writeFileSync(CONFIG_FILE, JSON.stringify(default_config, null, <NUM_LIT>));<EOL>                    recommendConfigAndDie(CONFIG_FILE);<EOL>                }<EOL>                else {<EOL>","gt":"app.once('<STR_LIT>', () => {"}
{"input":"<s> export default function loadConfig(): Promise<Config> {<EOL>    return new Promise<Config>(resolve => {<EOL>        fs.readFile(CONFIG_FILE, '<STR_LIT>', (err, json) => {<EOL>            if (err) {<EOL>                log.info('<STR_LIT>', CONFIG_FILE);<EOL>                const default_config = makeDefaultConfig();<EOL>                <EOL>                <EOL>                <EOL>                if (app.isReady()) {<EOL>                    fs.writeFileSync(CONFIG_FILE, JSON.stringify(default_config, null, <NUM_LIT>));<EOL>                    recommendConfigAndDie(CONFIG_FILE);<EOL>                }<EOL>                else {<EOL>                    app.once('<STR_LIT>', () => {<EOL>                        fs.writeFileSync(CONFIG_FILE, JSON.stringify(default_config, null, <NUM_LIT>));<EOL>                        recommendConfigAndDie(CONFIG_FILE);<EOL>                    });<EOL>                }<EOL>                return;<EOL>            }<EOL>            try {<EOL>                const config = JSON.parse(json);<EOL>                if (config.hot_key && config.hot_key.startsWith('<STR_LIT>')) {<EOL>                    config.hot_key =","gt":"hot_key.slice(<NUM_LIT>)}`<STR_LIT>;"}
{"input":"<s> export default function loadConfig(): Promise<Config> {<EOL>    return new Promise<Config>(resolve => {<EOL>        fs.readFile(CONFIG_FILE, '<STR_LIT>', (err, json) => {<EOL>            if (err) {<EOL>                log.info('<STR_LIT>', CONFIG_FILE);<EOL>                const default_config = makeDefaultConfig();<EOL>                <EOL>                <EOL>                <EOL>                if (app.isReady()) {<EOL>                    fs.writeFileSync(CONFIG_FILE, JSON.stringify(default_config, null, <NUM_LIT>));<EOL>                    recommendConfigAndDie(CONFIG_FILE);<EOL>                }<EOL>                else {<EOL>                    app.once('<STR_LIT>', () => {<EOL>                        fs.writeFileSync(CONFIG_FILE, JSON.stringify(default_config, null, <NUM_LIT>));<EOL>                        recommendConfigAndDie(CONFIG_FILE);<EOL>                    });<EOL>                }<EOL>                return;<EOL>            }<EOL>            try {<EOL>                const config = JSON.parse(json);<EOL>                if (config.hot_key && config.hot_key.startsWith('<STR_LIT>')) {<EOL>                    config.hot_key = `<STR_LIT>`;<EOL>                }<EOL>                log.debug('<STR_LIT>', config);<EOL>                if (!config.accounts || config.accounts[<NUM_LIT>].host === '<STR_LIT>' || config.accounts[<NUM_LIT>].name === '<STR_LIT>') {<EOL>                    recommendConfigAndDie(CONFIG_FILE);<EOL>                }<EOL>                else {<EOL>                    config.__DATA_DIR = DATA_DIR;<EOL>                    if (config.chromium_sandbox === undefined) {<EOL>                        config.","gt":"chromium_sandbox = true;"}
{"input":"<s> function resolveSpecifiedPath(specified: string): string {<EOL>    if (specified === '<STR_LIT>') {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    if (specified[<NUM_LIT>] === '<STR_LIT>') {<EOL>","gt":"const home = os.homedir();"}
{"input":"<s> function resolveSpecifiedPath(specified: string): string {<EOL>    if (specified === '<STR_LIT>') {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    if (specified[<NUM_LIT>] === '<STR_LIT>') {<EOL>        const home = os.homedir();<EOL>        if (home === '<STR_LIT>') {<EOL>            return '<STR_LIT>';<EOL>        }<EOL>        return resolveSpecifiedPath(home +","gt":"specified.slice(<NUM_LIT>));"}
{"input":"<s> function resolveSpecifiedPath(specified: string): string {<EOL>    if (specified === '<STR_LIT>') {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    if (specified[<NUM_LIT>] === '<STR_LIT>') {<EOL>        const home = os.homedir();<EOL>        if (home === '<STR_LIT>') {<EOL>            return '<STR_LIT>';<EOL>        }<EOL>        return resolveSpecifiedPath(home + specified.slice(<NUM_LIT>));<EOL>    }<EOL>    if (!fs.existsSync(specified)) {<EOL>","gt":"console.log('<STR_LIT>', specified);"}
{"input":"<s> function updateWithTouchData(e) {<EOL>    let keys, i;<EOL>    if (e.changedTouches) {<EOL>        keys =","gt":"'<STR_LIT>'.split('<STR_LIT>');"}
{"input":"<s> function zoomOutDirection(axis: '<STR_LIT>' | '<STR_LIT>') {<EOL>    const translate3d = transformAxis(axis, '<STR_LIT>');<EOL>    return function (steps) {<EOL>        const params = Object.assign({ timing: DEFAULT_TIMING, delay: <NUM_LIT> }, steps);<EOL>        return animation(animate('<STR_LIT>', keyframes([<EOL>","gt":"style({"}
{"input":"<s> function zoomOutDirection(axis: '<STR_LIT>' | '<STR_LIT>') {<EOL>    const translate3d = transformAxis(axis, '<STR_LIT>');<EOL>    return function (steps) {<EOL>        const params = Object.assign({ timing: DEFAULT_TIMING, delay: <NUM_LIT> }, steps);<EOL>        return animation(animate('<STR_LIT>', keyframes([<EOL>            style({<EOL>                opacity: <NUM_LIT>,<EOL>                transform: `<STR_LIT>`,<EOL>                offset: <NUM_LIT>,<EOL>            }),<EOL>            style({<EOL>                opacity: <NUM_LIT>,<EOL>                transform: `<STR_LIT>`,<EOL>                offset:","gt":"<NUM_LIT>,"}
{"input":"<s> <EOL>function openMarkdownLink(event: MouseEvent) {<EOL>    <EOL>    event.preventDefault();<EOL>    let target = event.","gt":"target as HTMLAnchorElement;"}
{"input":"<s> <EOL>function openMarkdownLink(event: MouseEvent) {<EOL>    <EOL>    event.preventDefault();<EOL>    let target = event.target as HTMLAnchorElement;<EOL>    while (target !== null) {<EOL>        if (target.href) {<EOL>            break;<EOL>        }<EOL>        target = target.parentElement as HTMLAnchorElement;<EOL>    }<EOL>    if (target === null) {<EOL>        console.","gt":"log('<STR_LIT>', event);"}
{"input":"<s> <EOL>function openMarkdownLink(event: MouseEvent) {<EOL>    <EOL>    event.preventDefault();<EOL>    let target = event.target as HTMLAnchorElement;<EOL>    while (target !== null) {<EOL>        if (target.href) {<EOL>            break;<EOL>        }<EOL>        target = target.parentElement as HTMLAnchorElement;<EOL>    }<EOL>    if (target === null) {<EOL>        console.log('<STR_LIT>', event);<EOL>        return;<EOL>    }<EOL>    let","gt":"path = unescape(target.href);"}
{"input":"<s> <EOL>function openMarkdownLink(event: MouseEvent) {<EOL>    <EOL>    event.preventDefault();<EOL>    let target = event.target as HTMLAnchorElement;<EOL>    while (target !== null) {<EOL>        if (target.href) {<EOL>            break;<EOL>        }<EOL>        target = target.parentElement as HTMLAnchorElement;<EOL>    }<EOL>    if (target === null) {<EOL>        console.log('<STR_LIT>', event);<EOL>        return;<EOL>    }<EOL>    let path = unescape(target.href);<EOL>    if (path.startsWith('<STR_LIT>')) {<EOL>        path = path.slice(<NUM_LIT>); <EOL>    }<EOL>    const hash_idx =","gt":"path.indexOf('<STR_LIT>');"}
{"input":"<s> export default function startApp(config: Config) {<EOL>    const","gt":"default_account = config.accounts[<NUM_LIT>];"}
{"input":"<s> <EOL>function openHashLink(event: MouseEvent) {<EOL>    <EOL>    event.","gt":"preventDefault();"}
{"input":"<s> function getBackdrop(element: HTMLElement) {<EOL>    return element.querySelector(","gt":"'<STR_LIT>');"}
{"input":"<s> function onGridStepInput(event: UIEvent) {<EOL>    const target = (<HTMLInputElement>event.target);<EOL>    let value = parseFloat(target.value);<EOL>    if (value !== <NUM_LIT> && value < <NUM_LIT>) {<EOL>","gt":"value = <NUM_LIT>;"}
{"input":"<s> function registerCommand(context: vscode.ExtensionContext, command: string, callback: (...args: any[]) => any) {<EOL>    let disposable = vscode.commands.registerCommand(command, async (args) => {<EOL>        if (!vscode.window.activeTextEditor) {<EOL>","gt":"return;"}
{"input":"<s> export async function allowVSCodeToPropagateCursorUpdatesAndReturnThem(): Promise<Range[]> {<EOL>","gt":"await waitForCursorUpdatesToHappen();"}
{"input":"<s> function getElements(element: Element) {<EOL>    const assistiveEl = element.querySelector('<STR_LIT>');<EOL>","gt":"return {"}
{"input":"<s> function styledConsoleLog(...args: any[]) {<EOL>    var argArray = [];<EOL>    if (args.length) {<EOL>        var startTagRe = /<span\\s+style=(['\"])([^'\"]*)\\1\\s*>/gi;<EOL>        var endTagRe = /<\\/span>/gi;<EOL>","gt":"var reResultArray;"}
{"input":"<s> function styledConsoleLog(...args: any[]) {<EOL>    var argArray = [];<EOL>    if (args.length) {<EOL>        var startTagRe = /<span\\s+style=(['\"])([^'\"]*)\\1\\s*>/gi;<EOL>        var endTagRe = /<\\/span>/gi;<EOL>        var reResultArray;<EOL>        argArray.push(arguments[<NUM_LIT>].replace(startTagRe, '<STR_LIT>').replace(endTagRe, '<STR_LIT>'));<EOL>        while (reResultArray = startTagRe.exec(arguments[<NUM_LIT>])) {<EOL>            argArray.push(reResultArray[<NUM_LIT>]);<EOL>            argArray.push(","gt":"'<STR_LIT>');"}
{"input":"<s> function styledConsoleLog(...args: any[]) {<EOL>    var argArray = [];<EOL>    if (args.length) {<EOL>        var startTagRe = /<span\\s+style=(['\"])([^'\"]*)\\1\\s*>/gi;<EOL>        var endTagRe = /<\\/span>/gi;<EOL>        var reResultArray;<EOL>        argArray.push(arguments[<NUM_LIT>].replace(startTagRe, '<STR_LIT>').replace(endTagRe, '<STR_LIT>'));<EOL>        while (reResultArray = startTagRe.exec(arguments[<NUM_LIT>])) {<EOL>            argArray.push(reResultArray[<NUM_LIT>]);<EOL>            argArray.push('<STR_LIT>');<EOL>        }<EOL>        <EOL>        for (var j = <NUM_LIT>; j < arguments.length; j++) {<EOL>","gt":"argArray.push(arguments[j]);"}
{"input":"<s> export function bindProperty(source: IObservable, sourceProperty: string, target: any, destProperty: string = sourceProperty) {<EOL>    return watchProperty(source, sourceProperty, (newValue,","gt":"oldValue) => {"}
{"input":"<s> export async function selectListView<T>({ items, heading, itemTemplate, itemFilterKey, activeItem, }: ISelectListParams<T>): Promise<T | undefined> {<EOL>    const elementForItem = (item: T) => {<EOL>        const li = document.createElement('<STR_LIT>');<EOL>        const div = document.createElement(","gt":"'<STR_LIT>');"}
{"input":"<s> export async function selectListView<T>({ items, heading, itemTemplate, itemFilterKey, activeItem, }: ISelectListParams<T>): Promise<T | undefined> {<EOL>    const elementForItem = (item: T) => {<EOL>        const li = document.createElement('<STR_LIT>');<EOL>        const div = document.createElement('<STR_LIT>');<EOL>        div.style.display = '<STR_LIT>';<EOL>        let isActive;<EOL>        if (","gt":"itemTemplate) {"}
{"input":"<s> export async function selectListView<T>({ items, heading, itemTemplate, itemFilterKey, activeItem, }: ISelectListParams<T>): Promise<T | undefined> {<EOL>    const elementForItem = (item: T) => {<EOL>        const li = document.createElement('<STR_LIT>');<EOL>        const div = document.createElement('<STR_LIT>');<EOL>        div.style.display = '<STR_LIT>';<EOL>        let isActive;<EOL>        if (itemTemplate) {<EOL>            div.innerHTML = itemTemplate(item);<EOL>            isActive = activeItem && itemTemplate(item) ===","gt":"itemTemplate(activeItem);"}
{"input":"<s> export async function selectListView<T>({ items, heading, itemTemplate, itemFilterKey, activeItem, }: ISelectListParams<T>): Promise<T | undefined> {<EOL>    const elementForItem = (item: T) => {<EOL>        const li = document.createElement('<STR_LIT>');<EOL>        const div = document.createElement('<STR_LIT>');<EOL>        div.style.display = '<STR_LIT>';<EOL>        let isActive;<EOL>        if (itemTemplate) {<EOL>            div.innerHTML = itemTemplate(item);<EOL>            isActive = activeItem && itemTemplate(item) === itemTemplate(activeItem);<EOL>        }<EOL>        else {<EOL>            div.innerText = `<STR_LIT>`;<EOL>            isActive =","gt":"activeItem && item === activeItem;"}
{"input":"<s> export async function selectListView<T>({ items, heading, itemTemplate, itemFilterKey, activeItem, }: ISelectListParams<T>): Promise<T | undefined> {<EOL>    const elementForItem = (item: T) => {<EOL>        const li = document.createElement('<STR_LIT>');<EOL>        const div = document.createElement('<STR_LIT>');<EOL>        div.style.display = '<STR_LIT>';<EOL>        let isActive;<EOL>        if (itemTemplate) {<EOL>            div.innerHTML = itemTemplate(item);<EOL>            isActive = activeItem && itemTemplate(item) === itemTemplate(activeItem);<EOL>        }<EOL>        else {<EOL>            div.innerText = `<STR_LIT>`;<EOL>            isActive = activeItem && item === activeItem;<EOL>        }<EOL>        if (isActive)<EOL>            li.classList.add('<STR_LIT>');<EOL>        <EOL>        if (div.firstElementChild && div.firstElementChild.tagName === '<STR_LIT>') {<EOL>            div.innerHTML = div.firstElementChild.","gt":"innerHTML;"}
{"input":"<s> export async function selectListView<T>({ items, heading, itemTemplate, itemFilterKey, activeItem, }: ISelectListParams<T>): Promise<T | undefined> {<EOL>    const elementForItem = (item: T) => {<EOL>        const li = document.createElement('<STR_LIT>');<EOL>        const div = document.createElement('<STR_LIT>');<EOL>        div.style.display = '<STR_LIT>';<EOL>        let isActive;<EOL>        if (itemTemplate) {<EOL>            div.innerHTML = itemTemplate(item);<EOL>            isActive = activeItem && itemTemplate(item) === itemTemplate(activeItem);<EOL>        }<EOL>        else {<EOL>            div.innerText = `<STR_LIT>`;<EOL>            isActive = activeItem && item === activeItem;<EOL>        }<EOL>        if (isActive)<EOL>            li.classList.add('<STR_LIT>');<EOL>        <EOL>        if (div.firstElementChild && div.firstElementChild.tagName === '<STR_LIT>') {<EOL>            div.innerHTML = div.firstElementChild.innerHTML;<EOL>        }<EOL>        li.appendChild(div);<EOL>        return li;<EOL>    };<EOL>    const filterKeyForItem = (item: T) => {<EOL>        if (typeof itemFilterKey === '<STR_LIT>') {<EOL>            return `<STR_LIT>`;<EOL>        }<EOL>        else if (itemFilterKey) {<EOL>            return itemFilterKey(item);<EOL>        }<EOL>        else {<EOL>            return `<STR_LIT>`;<EOL>        }<EOL>    };<EOL>    const myitems =","gt":"await Promise.resolve(items);"}
{"input":"<s> export async function selectListView<T>({ items, heading, itemTemplate, itemFilterKey, activeItem, }: ISelectListParams<T>): Promise<T | undefined> {<EOL>    const elementForItem = (item: T) => {<EOL>        const li = document.createElement('<STR_LIT>');<EOL>        const div = document.createElement('<STR_LIT>');<EOL>        div.style.display = '<STR_LIT>';<EOL>        let isActive;<EOL>        if (itemTemplate) {<EOL>            div.innerHTML = itemTemplate(item);<EOL>            isActive = activeItem && itemTemplate(item) === itemTemplate(activeItem);<EOL>        }<EOL>        else {<EOL>            div.innerText = `<STR_LIT>`;<EOL>            isActive = activeItem && item === activeItem;<EOL>        }<EOL>        if (isActive)<EOL>            li.classList.add('<STR_LIT>');<EOL>        <EOL>        if (div.firstElementChild && div.firstElementChild.tagName === '<STR_LIT>') {<EOL>            div.innerHTML = div.firstElementChild.innerHTML;<EOL>        }<EOL>        li.appendChild(div);<EOL>        return li;<EOL>    };<EOL>    const filterKeyForItem = (item: T) => {<EOL>        if (typeof itemFilterKey === '<STR_LIT>') {<EOL>            return `<STR_LIT>`;<EOL>        }<EOL>        else if (itemFilterKey) {<EOL>            return itemFilterKey(item);<EOL>        }<EOL>        else {<EOL>            return `<STR_LIT>`;<EOL>        }<EOL>    };<EOL>    const myitems = await Promise.resolve(items);<EOL>    let panel: Panel<SelectListView<T>> | undefined;<EOL>    try {<EOL>        return","gt":"await new Promise<T | undefined>((resolve) => {"}
{"input":"<s> export async function selectListView<T>({ items, heading, itemTemplate, itemFilterKey, activeItem, }: ISelectListParams<T>): Promise<T | undefined> {<EOL>    const elementForItem = (item: T) => {<EOL>        const li = document.createElement('<STR_LIT>');<EOL>        const div = document.createElement('<STR_LIT>');<EOL>        div.style.display = '<STR_LIT>';<EOL>        let isActive;<EOL>        if (itemTemplate) {<EOL>            div.innerHTML = itemTemplate(item);<EOL>            isActive = activeItem && itemTemplate(item) === itemTemplate(activeItem);<EOL>        }<EOL>        else {<EOL>            div.innerText = `<STR_LIT>`;<EOL>            isActive = activeItem && item === activeItem;<EOL>        }<EOL>        if (isActive)<EOL>            li.classList.add('<STR_LIT>');<EOL>        <EOL>        if (div.firstElementChild && div.firstElementChild.tagName === '<STR_LIT>') {<EOL>            div.innerHTML = div.firstElementChild.innerHTML;<EOL>        }<EOL>        li.appendChild(div);<EOL>        return li;<EOL>    };<EOL>    const filterKeyForItem = (item: T) => {<EOL>        if (typeof itemFilterKey === '<STR_LIT>') {<EOL>            return `<STR_LIT>`;<EOL>        }<EOL>        else if (itemFilterKey) {<EOL>            return itemFilterKey(item);<EOL>        }<EOL>        else {<EOL>            return `<STR_LIT>`;<EOL>        }<EOL>    };<EOL>    const myitems = await Promise.resolve(items);<EOL>    let panel: Panel<SelectListView<T>> | undefined;<EOL>    try {<EOL>        return await new Promise<T | undefined>((resolve) => {<EOL>            const select = new SelectListView({<EOL>                items: myitems,<EOL>                infoMessage: heading,<EOL>                itemsClassList: ['<STR_LIT>', '<STR_LIT>'],<EOL>                elementForItem,<EOL>                filterKeyForItem,<EOL>                didCancelSelection: () => {<EOL>                    resolve();<EOL>                },<EOL>                didConfirmSelection: (","gt":"item: T) => {"}
{"input":"<s> export async function selectListView<T>({ items, heading, itemTemplate, itemFilterKey, activeItem, }: ISelectListParams<T>): Promise<T | undefined> {<EOL>    const elementForItem = (item: T) => {<EOL>        const li = document.createElement('<STR_LIT>');<EOL>        const div = document.createElement('<STR_LIT>');<EOL>        div.style.display = '<STR_LIT>';<EOL>        let isActive;<EOL>        if (itemTemplate) {<EOL>            div.innerHTML = itemTemplate(item);<EOL>            isActive = activeItem && itemTemplate(item) === itemTemplate(activeItem);<EOL>        }<EOL>        else {<EOL>            div.innerText = `<STR_LIT>`;<EOL>            isActive = activeItem && item === activeItem;<EOL>        }<EOL>        if (isActive)<EOL>            li.classList.add('<STR_LIT>');<EOL>        <EOL>        if (div.firstElementChild && div.firstElementChild.tagName === '<STR_LIT>') {<EOL>            div.innerHTML = div.firstElementChild.innerHTML;<EOL>        }<EOL>        li.appendChild(div);<EOL>        return li;<EOL>    };<EOL>    const filterKeyForItem = (item: T) => {<EOL>        if (typeof itemFilterKey === '<STR_LIT>') {<EOL>            return `<STR_LIT>`;<EOL>        }<EOL>        else if (itemFilterKey) {<EOL>            return itemFilterKey(item);<EOL>        }<EOL>        else {<EOL>            return `<STR_LIT>`;<EOL>        }<EOL>    };<EOL>    const myitems = await Promise.resolve(items);<EOL>    let panel: Panel<SelectListView<T>> | undefined;<EOL>    try {<EOL>        return await new Promise<T | undefined>((resolve) => {<EOL>            const select = new SelectListView({<EOL>                items: myitems,<EOL>                infoMessage: heading,<EOL>                itemsClassList: ['<STR_LIT>', '<STR_LIT>'],<EOL>                elementForItem,<EOL>                filterKeyForItem,<EOL>                didCancelSelection: () => {<EOL>                    resolve();<EOL>                },<EOL>                didConfirmSelection: (item: T) => {<EOL>                    resolve(item);<EOL>                },<EOL>            });<EOL>            select.element.classList.add('<STR_LIT>');<EOL>            panel =","gt":"atom.workspace.addModalPanel({"}
{"input":"<s> function getHeadingsText(element: HTMLElement) {<EOL>    return getHeadings(element).map(","gt":"getHeadingText);"}
{"input":"<s> export function getPill(root: HTMLElement): any {<EOL>    return","gt":"root.firstElementChild;"}
{"input":"<s> export function reducer(state: State = initialState, action: knowledge.Actions): State {<EOL>    switch (action.type) {<EOL>        case knowledge.ActionTypes.CHANGE: {<EOL>            const response = action.payload;<EOL>            return Object.assign({},","gt":"state, {"}
{"input":"<s> export function reducer(state: State = initialState, action: knowledge.Actions): State {<EOL>    switch (action.type) {<EOL>        case knowledge.ActionTypes.CHANGE: {<EOL>            const response = action.payload;<EOL>            return Object.assign({}, state, {<EOL>                response: response,<EOL>            });<EOL>        }<EOL>        default: {<EOL>","gt":"return state;"}
{"input":"<s> function getElement(fixture: ComponentFixture<TestComponent>) {<EOL>    return fixture.nativeElement.","gt":"firstElementChild;"}
{"input":"<s> function getButtonElement(element: Element): HTMLButtonElement {<EOL>    return <HTMLButtonElement>element.","gt":"querySelector('<STR_LIT>');"}
{"input":"<s> export function parse(input: string): node.CommandLine {<EOL>    var cmd = new node.CommandLine();<EOL>    var f: IParseFunction | null = parseLineRange;<EOL>    let state: ParserState = new","gt":"ParserState(input);"}
{"input":"<s> export function registerResource(name: string, plugin: SupRuntime.RuntimeResourcePlugin) {<EOL>    if (resourcePlugins[name] != null) {<EOL>        console.","gt":"error(`<STR_LIT>`);"}
{"input":"<s> export function setupComponent(player: SupRuntime.Player, component: any, config: any) {<EOL>    component.setup(","gt":"config);"}
{"input":"<s> function getDisabledTextElement(element: Element): HTMLSpanElement {<EOL>    return <HTMLSpanElement>element.","gt":"querySelector('<STR_LIT>');"}
{"input":"<s> function parseRequest(req: http.ServerRequest): lark.ServiceCommand {<EOL>    var uri = url.","gt":"parse(req.url, true);"}
{"input":"<s> async function testIt(modeHandler: ModeHandler, testObj: ITestObject): Promise<void> {<EOL>    modeHandler.vimState.editor = vscode.window.activeTextEditor!;<EOL>    let helper = new TestObjectHelper(testObj);<EOL>    <EOL>    (modeHandler as any).vimState.cursorPosition = new","gt":"Position(<NUM_LIT>, <NUM_LIT>);"}
{"input":"<s> async function testIt(modeHandler: ModeHandler, testObj: ITestObject): Promise<void> {<EOL>    modeHandler.vimState.editor = vscode.window.activeTextEditor!;<EOL>    let helper = new TestObjectHelper(testObj);<EOL>    <EOL>    (modeHandler as any).vimState.cursorPosition = new Position(<NUM_LIT>, <NUM_LIT>);<EOL>    await modeHandler.handleKeyEvent('<STR_LIT>');<EOL>    <EOL>    await modeHandler.vimState.editor.edit(builder => {<EOL>        builder.insert(new","gt":"Position(<NUM_LIT>, <NUM_LIT>), testObj.start.join('<STR_LIT>').replace('<STR_LIT>', '<STR_LIT>'));"}
{"input":"<s> async function testIt(modeHandler: ModeHandler, testObj: ITestObject): Promise<void> {<EOL>    modeHandler.vimState.editor = vscode.window.activeTextEditor!;<EOL>    let helper = new TestObjectHelper(testObj);<EOL>    <EOL>    (modeHandler as any).vimState.cursorPosition = new Position(<NUM_LIT>, <NUM_LIT>);<EOL>    await modeHandler.handleKeyEvent('<STR_LIT>');<EOL>    <EOL>    await modeHandler.vimState.editor.edit(builder => {<EOL>        builder.insert(new Position(<NUM_LIT>, <NUM_LIT>), testObj.start.join('<STR_LIT>').replace('<STR_LIT>', '<STR_LIT>'));<EOL>    });<EOL>    await modeHandler.handleMultipleKeyEvents(['<STR_LIT>', '<STR_LIT>', '<STR_LIT>']);<EOL>    await waitForCursorUpdatesToHappen();<EOL>    <EOL>    <EOL>    modeHandler.vimState.historyTracker.addChange();<EOL>    modeHandler.vimState.historyTracker.finishCurrentStep();<EOL>    <EOL>    await modeHandler.handleMultipleKeyEvents(helper.getKeyPressesToMoveToStartPosition());<EOL>","gt":"await waitForCursorUpdatesToHappen();"}
{"input":"<s> async function testIt(modeHandler: ModeHandler, testObj: ITestObject): Promise<void> {<EOL>    modeHandler.vimState.editor = vscode.window.activeTextEditor!;<EOL>    let helper = new TestObjectHelper(testObj);<EOL>    <EOL>    (modeHandler as any).vimState.cursorPosition = new Position(<NUM_LIT>, <NUM_LIT>);<EOL>    await modeHandler.handleKeyEvent('<STR_LIT>');<EOL>    <EOL>    await modeHandler.vimState.editor.edit(builder => {<EOL>        builder.insert(new Position(<NUM_LIT>, <NUM_LIT>), testObj.start.join('<STR_LIT>').replace('<STR_LIT>', '<STR_LIT>'));<EOL>    });<EOL>    await modeHandler.handleMultipleKeyEvents(['<STR_LIT>', '<STR_LIT>', '<STR_LIT>']);<EOL>    await waitForCursorUpdatesToHappen();<EOL>    <EOL>    <EOL>    modeHandler.vimState.historyTracker.addChange();<EOL>    modeHandler.vimState.historyTracker.finishCurrentStep();<EOL>    <EOL>    await modeHandler.handleMultipleKeyEvents(helper.getKeyPressesToMoveToStartPosition());<EOL>    await waitForCursorUpdatesToHappen();<EOL>    Globals.mockModeHandler = modeHandler;<EOL>    let keysPressed = testObj.keysPressed;<EOL>    if (process.platform === '<STR_LIT>') {<EOL>        keysPressed = keysPressed.replace(/\\\\n/g, '<STR_LIT>');<EOL>    }<EOL>    <EOL>    await modeHandler.handleMultipleKeyEvents(tokenizeKeySequence(keysPressed));<EOL>    <EOL>    assert(helper.isValid, \"<STR_LIT>\");<EOL>    <EOL>    <EOL>    assertEqualLines(helper.asVimOutputText());<EOL>    <EOL>    <EOL>    let actualPosition = Position.FromVSCodePosition(TextEditor.getSelection().start);<EOL>    let expectedPosition = helper.endPosition;<EOL>    assert.equal(actualPosition.","gt":"line, expectedPosition.line, '<STR_LIT>');"}
{"input":"<s> function onAssetReceived(err: string, asset: SoundAsset) {<EOL>","gt":"data.asset = asset;"}
{"input":"<s> function onGridStepInput(event: UIEvent) {<EOL>    const target = event.target as HTMLInputElement;<EOL>    let value = parseFloat(target.value);<EOL>    if (value !== <NUM_LIT> && value < <NUM_LIT>) {<EOL>        value =","gt":"<NUM_LIT>;"}
{"input":"<s> function pushAll<T>(to: T[], from: T[]) {<EOL>    if (from) {<EOL>        for (let i =","gt":"<NUM_LIT>; i < from.length; i++) {"}
{"input":"<s> export function start(asset: ScriptAsset) {<EOL>    (document.querySelector(\"<STR_LIT>\") as HTMLDivElement).hidden = true;<EOL>    (document.querySelector(\"<STR_LIT>\") as HTMLDivElement).hidden = false;<EOL>","gt":"ui.editor.setText(asset.pub.draft);"}
{"input":"<s> function exec(command: string, params: string[], callback: Function) {<EOL>    var cdvProcess = childProcess.exec(`<STR_LIT>`, {}, (e, stdout, stdin) => { console.log(e); });<EOL>    cdvProcess.stdout.on(\"<STR_LIT>\", data => console.log(\"<STR_LIT>\" +","gt":"data));"}
{"input":"<s> function* pingFrontEnd() {<EOL>    yield fork(function* () {<EOL>        while (<NUM_LIT>) {<EOL>            yield put({ type: \"<STR_LIT>\", $public: true });<EOL>            const { pong, timeout } =","gt":"yield race({"}
{"input":"<s> function* pingFrontEnd() {<EOL>    yield fork(function* () {<EOL>        while (<NUM_LIT>) {<EOL>            yield put({ type: \"<STR_LIT>\", $public: true });<EOL>            const { pong, timeout } = yield race({<EOL>                pong: take(\"<STR_LIT>\"),<EOL>                timeout: call(delay, DISCONNECTED_TIMEOUT)<EOL>            });<EOL>            yield put(tandemFEConnectivity(Boolean(pong)));<EOL>            yield call(","gt":"delay, PING_TIMEOUT);"}
{"input":"<s> function* handleArtboardSizeChanges() {<EOL>    while (<NUM_LIT>) {<EOL>        const { artboardId } = yield take(ARTBOARD_RENDERED);<EOL>        const artboard = getArtboardById(artboardId, yield select());<EOL>        yield fork(function* () {<EOL>            const resizeChan = eventChannel((","gt":"emit) => {"}
{"input":"<s> function* handleArtboardSizeChanges() {<EOL>    while (<NUM_LIT>) {<EOL>        const { artboardId } = yield take(ARTBOARD_RENDERED);<EOL>        const artboard = getArtboardById(artboardId, yield select());<EOL>        yield fork(function* () {<EOL>            const resizeChan = eventChannel((emit) => {<EOL>                artboard.mount.contentWindow.addEventListener(\"<STR_LIT>\", debounce(emit, RESIZE_TIMEOUT));<EOL>                return () => { };<EOL>            });<EOL>            while (<NUM_LIT>) {<EOL>                yield take(resizeChan);<EOL>                yield","gt":"call(recomputeArtboardInfo, artboard);"}
{"input":"<s> export function parseHTMLDocument(document: TextDocument): HTMLDocument {<EOL>    return","gt":"parse(document.getText());"}
{"input":"<s> function getHostStylesheets(node: Node) {<EOL>    let p = node.parentNode;<EOL>","gt":"while (p.parentNode)"}
{"input":"<s> function onProjectAdded(manifest: SupCore.Data.ProjectManifestPub, index: number) {<EOL>    data.projects.client_add(","gt":"manifest, index);"}
{"input":"<s> export function importActor(entry: SupCore.Data.EntryNode, projectClient: SupClient.ProjectClient, options: SupClient.ImportIntoScenePluginOptions, callback: (err: string, nodeId: string) => any) {<EOL>    let name = entry.name;<EOL>    if (name === \"<STR_LIT>\") {<EOL>        const parentNode = projectClient.entries.","gt":"parentNodesById[entry.id];"}
{"input":"<s> function fix(settings: eclint.ISettings, document: doc.IDocument) {<EOL>    const indentStyle = resolve(settings);<EOL>    const","gt":"tabWidth = getTabWidth(settings, document);"}
{"input":"<s> function createContext(ctx: any) {<EOL>    return {<EOL>","gt":"getValue: (key: string) => {"}
{"input":"<s> function getEmbeddedDocumentByType(document: TextDocument, contents: EmbeddedRegion[], type: EmbeddedType): TextDocument {<EOL>    const oldContent = document.getText();<EOL>    let result = '<STR_LIT>';<EOL>    for (const c of contents) {<EOL>        if (","gt":"c.type === type) {"}
{"input":"<s> export function calculateUntransformedBoundingRect(node: HTMLElement) {<EOL>    const rect = node.getBoundingClientRect();<EOL>    const bounds = new BoundingRect(rect.left, rect.top, rect.","gt":"right, rect.bottom);"}
{"input":"<s> export function init(player: SupRuntime.Player, callback: Function) {<EOL>    player.gameInstance.framesPerSecond = player.resources.gameSettings.framesPerSecond;<EOL>    SupRuntime.Player.updateInterval = <NUM_LIT> / player.gameInstance.framesPerSecond;<EOL>    if (player.resources.gameSettings.ratioNumerator != null && player.resources.gameSettings.ratioDenominator != null) {<EOL>        player.gameInstance.setRatio(player.resources.gameSettings.ratioNumerator / player.resources.gameSettings.","gt":"ratioDenominator);"}
{"input":"<s> export function init(player: SupRuntime.Player, callback: Function) {<EOL>    player.gameInstance.framesPerSecond = player.resources.gameSettings.framesPerSecond;<EOL>    SupRuntime.Player.updateInterval = <NUM_LIT> / player.gameInstance.framesPerSecond;<EOL>    if (player.resources.gameSettings.ratioNumerator != null && player.resources.gameSettings.ratioDenominator != null) {<EOL>        player.gameInstance.setRatio(player.resources.gameSettings.ratioNumerator / player.resources.gameSettings.ratioDenominator);<EOL>    }<EOL>    <EOL>    if (player.resources.gameSettings.customLayers != null) {<EOL>        player.","gt":"gameInstance.layers = player.gameInstance.layers.concat(player.resources.gameSettings.customLayers);"}
{"input":"<s> function* updateSharedArtboards(itemId: string, originArtboardId: string, patchDocument: boolean, createMutations: (nestedObject: VMObject, scopeHash: string, path: any[], root: SlimParentNode) => Mutation<any>[]) {<EOL>    const itemType = getVMObjectIdType(itemId);<EOL>    const state: ApplicationState = yield select();<EOL>    const workspace = getSelectedWorkspace(state);<EOL>    const scopeInfo = getStyleOwnerScopeInfo(itemId, getArtboardById(originArtboardId, state).document);<EOL>    const scopeHash = scopeInfo.join(\"<STR_LIT>\");<EOL>","gt":"for (const artboard of workspace.artboards) {"}
{"input":"<s> function* updateSharedArtboards(itemId: string, originArtboardId: string, patchDocument: boolean, createMutations: (nestedObject: VMObject, scopeHash: string, path: any[], root: SlimParentNode) => Mutation<any>[]) {<EOL>    const itemType = getVMObjectIdType(itemId);<EOL>    const state: ApplicationState = yield select();<EOL>    const workspace = getSelectedWorkspace(state);<EOL>    const scopeInfo = getStyleOwnerScopeInfo(itemId, getArtboardById(originArtboardId, state).document);<EOL>    const scopeHash = scopeInfo.join(\"<STR_LIT>\");<EOL>    for (const artboard of workspace.artboards) {<EOL>        const owner = getStyleOwnerFromScopeInfo(scopeInfo, artboard);<EOL>        if (!owner) {<EOL>            continue;<EOL>        }<EOL>        let document = getArtboardDocumentBody(artboard);<EOL>        const ownerPath = getVMObjectPath(owner, document);<EOL>        const mutations = createMutations(owner, scopeHash, ownerPath, document);<EOL>        if (!mutations.","gt":"length) {"}
{"input":"<s> export function createOuterAsset(player: SupRuntime.Player, asset: any) {<EOL>    return new (<any>","gt":"window).Sup.TileSet(asset);"}
{"input":"<s> function onWelcome(clientId: string) {<EOL>    data = { projectClient: new SupClient.","gt":"ProjectClient(socket, { subEntries: true }) };"}
{"input":"<s> export function teardown(path: string) {<EOL>    process.chdir(root);<EOL>    if (fs.pathExistsSync(path)) {<EOL>        return fs.","gt":"remove(path);"}
{"input":"<s> export default function checkGitExists() {<EOL>    const result = spawn(\"<STR_LIT>\", [\"<STR_LIT>\"], {<EOL>        logStdErrOnError: false,<EOL>","gt":"throwOnError: false,"}
{"input":"<s> <EOL>function containsWildcard(inputValue: string): boolean {<EOL>    return inputValue.indexOf(","gt":"'<STR_LIT>') >= <NUM_LIT> ||"}
{"input":"<s> export function logError(error: {<EOL>    message: string;<EOL>}): void {<EOL>    if (","gt":"isDevelopment)"}
{"input":"<s> function copyDirectory(from: string, to: string, filter?: (filename: string) => boolean) {<EOL>    var fileList: string[] = [];<EOL>    if (!filter)<EOL>        fileList = FileUtil.getDirectoryListing(from);<EOL>","gt":"else"}
{"input":"<s> function copyDirectory(from: string, to: string, filter?: (filename: string) => boolean) {<EOL>    var fileList: string[] = [];<EOL>    if (!filter)<EOL>        fileList = FileUtil.getDirectoryListing(from);<EOL>    else<EOL>        fileList = FileUtil.searchByFunction(from, filter);<EOL>    length = fileList.length;<EOL>    for (var i = <NUM_LIT>; i < length; i++) {<EOL>        var path = fileList[i];<EOL>        var destPath = path.substring(from.length);<EOL>","gt":"destPath = FileUtil.joinPath(to, destPath);"}
{"input":"<s> function onAssetReceived(assetId: string, asset: ShaderAsset) {<EOL>    data.shaderAsset = asset;<EOL>    for (const uniform of asset.pub.uniforms)<EOL>        setupUniform(uniform);<EOL>    ui.useLightUniformsCheckbox.checked =","gt":"asset.pub.useLightUniforms;"}
{"input":"<s> function onAssetReceived(assetId: string, asset: ShaderAsset) {<EOL>    data.shaderAsset = asset;<EOL>    for (const uniform of asset.pub.uniforms)<EOL>        setupUniform(uniform);<EOL>    ui.useLightUniformsCheckbox.checked = asset.pub.useLightUniforms;<EOL>    for (const attribute of asset.pub.attributes)<EOL>        setupAttribute(attribute);<EOL>    ui.vertexEditor.setText(asset.pub.vertexShader.draft);<EOL>    if (asset.pub.vertexShader.draft !== asset.pub.vertexShader.text)<EOL>        checkVertexShader();<EOL>    ui.fragmentEditor.setText(asset.pub.","gt":"fragmentShader.draft);"}
{"input":"<s> function* handleTextDocumentChange() {<EOL>    const chan = eventChannel((emit) => {<EOL>        vscode.workspace.onDidChangeTextDocument((e) => {<EOL>            const document = e.document as vscode.TextDocument;<EOL>            emit(textContentChanged(document.uri.fsPath, document.getText()));<EOL>        });<EOL>","gt":"return () => { };"}
{"input":"<s> function* handleTextDocumentChange() {<EOL>    const chan = eventChannel((emit) => {<EOL>        vscode.workspace.onDidChangeTextDocument((e) => {<EOL>            const document = e.document as vscode.TextDocument;<EOL>            emit(textContentChanged(document.uri.fsPath, document.getText()));<EOL>        });<EOL>        return () => { };<EOL>    });<EOL>    while (true) {<EOL>        const action = yield take(chan);<EOL>","gt":"const state: ExtensionState = yield select();"}
{"input":"<s> function* handleTextDocumentChange() {<EOL>    const chan = eventChannel((emit) => {<EOL>        vscode.workspace.onDidChangeTextDocument((e) => {<EOL>            const document = e.document as vscode.TextDocument;<EOL>            emit(textContentChanged(document.uri.fsPath, document.getText()));<EOL>        });<EOL>        return () => { };<EOL>    });<EOL>    while (true) {<EOL>        const action = yield take(chan);<EOL>        const state: ExtensionState = yield select();<EOL>        <EOL>        <EOL>        if (getFileCacheContent(action.filePath, state) && getFileCacheContent(action.filePath,","gt":"state) === action.content) {"}
{"input":"<s> export function setInspectorVisible(visible: boolean) {<EOL>    ui.visibleCheckbox.checked =","gt":"visible;"}
{"input":"<s> function findFile(file: string, startLocation: string) {<EOL>    let lastParent;<EOL>    let parent = startLocation;<EOL>    while (parent && parent.length > <NUM_LIT> && parent !== lastParent) {<EOL>        const packages = path.","gt":"join(parent, file);"}
{"input":"<s> function findFile(file: string, startLocation: string) {<EOL>    let lastParent;<EOL>    let parent = startLocation;<EOL>    while (parent && parent.length > <NUM_LIT> && parent !== lastParent) {<EOL>        const packages = path.join(parent, file);<EOL>        if (fs.existsSync(packages))<EOL>            return packages;<EOL>        lastParent = parent;<EOL>","gt":"parent = path.dirname(parent);"}
{"input":"<s> function commonCheck(selector: TemmeSelector) {<EOL>    if (selector.type === '<STR_LIT>') {<EOL>        const sectionCount = selector.sections.length;<EOL>        const leadingSections = selector.","gt":"sections.slice(<NUM_LIT>, sectionCount - <NUM_LIT>);"}
{"input":"<s> function* handleOpenTandem() {<EOL>    yield take(OPEN_TANDEM_EXECUTED);<EOL>    let state: ExtensionState = yield select();<EOL>    var textDocumentContentProvider = {<EOL>","gt":"provideTextDocumentContent(uri) {"}
{"input":"<s> function* handleOpenTandem() {<EOL>    yield take(OPEN_TANDEM_EXECUTED);<EOL>    let state: ExtensionState = yield select();<EOL>    var textDocumentContentProvider = {<EOL>        provideTextDocumentContent(uri) {<EOL>            return `<STR_LIT>`;<EOL>        },<EOL>    };<EOL>    state.context.subscriptions.push(vscode.workspace.registerTextDocumentContentProvider(PREVIEW_NAME, textDocumentContentProvider));<EOL>    while (true) {<EOL>        yield call(","gt":"vscode.commands.executeCommand, \"<STR_LIT>\", PREVIEW_URI, vscode.ViewColumn.Two, \"<STR_LIT>\");"}
{"input":"<s> export function isEmptyObject(x: any) {<EOL>    return x !== null<EOL>        &&","gt":"typeof x === '<STR_LIT>'"}
{"input":"<s> function getValueAndRange(document: TextDocument, currRange: Range): {<EOL>    value: string;<EOL>    range: Range;<EOL>} {<EOL>    let value = document.getText();<EOL>    let range = currRange;<EOL>    if (currRange) {<EOL>        const startOffset = document.offsetAt(","gt":"currRange.start);"}
{"input":"<s> function getValueAndRange(document: TextDocument, currRange: Range): {<EOL>    value: string;<EOL>    range: Range;<EOL>} {<EOL>    let value = document.getText();<EOL>    let range = currRange;<EOL>    if (currRange) {<EOL>        const startOffset = document.offsetAt(currRange.start);<EOL>        const endOffset = document.offsetAt(currRange.end);<EOL>        value = value.substring(startOffset, endOffset);<EOL>    }<EOL>    else {<EOL>        range = Range.create(Position.create(","gt":"<NUM_LIT>, <NUM_LIT>), document.positionAt(value.length));"}
{"input":"<s> function* handleSyntheticWindowInstance(window: SEnvWindowInterface) {<EOL>    yield fork(","gt":"handleSyntheticWindowEvents, window);"}
{"input":"<s> export function collectTagsDefault(collector: TagCollector, tagSet: ITagSet): void {<EOL>    for (","gt":"const tag in tagSet) {"}
{"input":"<s> export function createManyRanges(text: string): IProdRange[] {<EOL>    return createOperatorProdRangeParenthesis(text,","gt":"ProdType.MANY, manyRegExGlobal);"}
{"input":"<s> export function partial(func: Function, ...restArgs: any[]): Function {<EOL>    let firstArg = [","gt":"null];"}
{"input":"<s> /**<EOL> * @param bufferSize<EOL> * @param windowTime<EOL> * @param scheduler<EOL> * @return {ConnectableObservable<T>}<EOL> * @method publishReplay<EOL> * @owner Observable<EOL> */<EOL>export function publishReplay<T>(this: Observable<T>, bufferSize: number = Number.POSITIVE_INFINITY, windowTime: number = Number.POSITIVE_INFINITY, scheduler?: IScheduler): ConnectableObservable<T> {<EOL>    return multicast.call(this, new ReplaySubject<T>(","gt":"bufferSize, windowTime, scheduler));"}
{"input":"<s> export function virtual(proto: any, property: string) {<EOL>    proto[property].","gt":"virtual = true;"}
{"input":"<s> function onDeleteMapClick() {<EOL>    if (ui.texturesTreeView.selectedNodes.length === <NUM_LIT>)<EOL>        return;<EOL>    const confirmLabel = SupClient.i18n.t(\"<STR_LIT>\");<EOL>    const validationLabel = SupClient.i18n.t(","gt":"\"<STR_LIT>\");"}
{"input":"<s> function onDeleteMapClick() {<EOL>    if (ui.texturesTreeView.selectedNodes.length === <NUM_LIT>)<EOL>        return;<EOL>    const confirmLabel = SupClient.i18n.t(\"<STR_LIT>\");<EOL>    const validationLabel = SupClient.i18n.t(\"<STR_LIT>\");<EOL>    new SupClient.Dialogs.ConfirmDialog(confirmLabel, { validationLabel }, (confirm) => {<EOL>        if (!confirm)<EOL>            return;<EOL>        for (const","gt":"selectedNode of ui.texturesTreeView.selectedNodes)"}
{"input":"<s> function _memoize(fn: Function, key: string): Function {<EOL>    const memoizeKey = `<STR_LIT>`;<EOL>    return function (this: any, ...args: any[]) {<EOL>        if (!this.hasOwnProperty(memoizeKey)) {<EOL>            Object.defineProperty(this,","gt":"memoizeKey, {"}
{"input":"<s> function getSelectedLines(): string {<EOL>    const editor = window.activeTextEditor;<EOL>    let text: string;<EOL>    if (editor) {<EOL>","gt":"let lines = <NUM_LIT>;"}
{"input":"<s> export function getLookaheadPathsForOptionalProd(occurrence: number, ruleGrammar: Rule, prodType: PROD_TYPE, k: number): lookAheadSequence[] {<EOL>    let insideDefVisitor = new InsideDefinitionFinderVisitor(occurrence, prodType);<EOL>    ruleGrammar.accept(insideDefVisitor);<EOL>    let","gt":"insideDef = insideDefVisitor.result;"}
{"input":"<s> /**<EOL> * Returns an Observable that mirrors the source Observable with the exception of an `error`. If the source Observable<EOL> * calls `error`, this method will resubscribe to the source Observable for a maximum of `count` resubscriptions (given<EOL> * as a number parameter) rather than propagating the `error` call.<EOL> *<EOL> * <img src=\"./img/retry.png\" width=\"100%\"><EOL> *<EOL> * Any and all items emitted by the source Observable will be emitted by the resulting Observable, even those emitted<EOL> * during failed subscriptions. For example, if an Observable fails at first but emits [1, 2] then succeeds the second<EOL> * time and emits: [1, 2, 3, 4, 5] then the complete stream of emissions and notifications<EOL> * would be: [1, 2, 1, 2, 3, 4, 5, `complete`].<EOL> * @param {number} count - Number of retry attempts before failing.<EOL> * @return {Observable} The source Observable modified with the retry logic.<EOL> * @method retry<EOL> * @owner Observable<EOL> */<EOL>export function retry<T>(this: Observable<T>, count: number = -<NUM_LIT>): Observable<T> {<EOL>    return","gt":"this.lift(new RetryOperator(count, this));"}
{"input":"<s> /**<EOL> * Convenience used to express an empty alternative in an OR (alternation).<EOL> * can be used to more clearly describe the intent in a case of empty alternation.<EOL> *<EOL> * For example:<EOL> *<EOL> * 1. without using EMPTY_ALT:<EOL> *<EOL> *    this.OR([<EOL> *      {ALT: () => {<EOL> *        this.CONSUME1(OneTok)<EOL> *        return \"1\"<EOL> *      }},<EOL> *      {ALT: () => {<EOL> *        this.CONSUME1(TwoTok)<EOL> *        return \"2\"<EOL> *      }},<EOL> *      {ALT: () => { // implicitly empty because there are no invoked grammar rules (OR/MANY/CONSUME...) inside this alternative.<EOL> *        return \"666\"<EOL> *      }},<EOL> *    ])<EOL> *<EOL> *<EOL> * 2. using EMPTY_ALT:<EOL> *<EOL> *    this.OR([<EOL> *      {ALT: () => {<EOL> *        this.CONSUME1(OneTok)<EOL> *        return \"1\"<EOL> *      }},<EOL> *      {ALT: () => {<EOL> *        this.CONSUME1(TwoTok)<EOL> *        return \"2\"<EOL> *      }},<EOL> *      {ALT: EMPTY_ALT(\"666\")}, // explicitly empty, clearer intent<EOL> *    ])<EOL> *<EOL> */<EOL>export function EMPTY_ALT<T>(value: T = undefined): () => T {<EOL>    return","gt":"function () {"}
{"input":"<s> function* handleSelectionKeyUp() {<EOL>    while (true) {<EOL>        yield take([","gt":"LEFT_KEY_UP, RIGHT_KEY_UP, UP_KEY_UP, DOWN_KEY_UP]);"}
{"input":"<s> export function* shortcutsService() {<EOL>    const state: ShortcutServiceState = yield select();<EOL>    const mt = Mousetrap();<EOL>    const chan = eventChannel((emit) => {<EOL>        for (const { keyCombo, action, options } of state.shortcuts) {<EOL>            mt.bind(keyCombo, (","gt":"event) => {"}
{"input":"<s> export function getSettingsTargetName(target: ConfigurationTarget, resource: URI, workspaceContextService: IWorkspaceContextService): string {<EOL>    switch (target) {<EOL>        case ConfigurationTarget.USER:<EOL>            return localize('<STR_LIT>', \"<STR_LIT>\");<EOL>","gt":"case ConfigurationTarget.WORKSPACE:"}
{"input":"<s> export function getSettingsTargetName(target: ConfigurationTarget, resource: URI, workspaceContextService: IWorkspaceContextService): string {<EOL>    switch (target) {<EOL>        case ConfigurationTarget.USER:<EOL>            return localize('<STR_LIT>', \"<STR_LIT>\");<EOL>        case ConfigurationTarget.WORKSPACE:<EOL>            return localize('<STR_LIT>', \"<STR_LIT>\");<EOL>        case ConfigurationTarget.WORKSPACE_FOLDER:<EOL>            const folder = workspaceContextService.getWorkspaceFolder(resource);<EOL>","gt":"return folder ? folder.name : '<STR_LIT>';"}
{"input":"<s> function getLiveElement(): Element {<EOL>    return document.body.querySelector(","gt":"'<STR_LIT>')!;"}
{"input":"<s> /**<EOL> * Branch out the source Observable values as a nested Observable starting from<EOL> * an emission from `openings` and ending when the output of `closingSelector`<EOL> * emits.<EOL> *<EOL> * <span class=\"informal\">It's like {@link bufferToggle}, but emits a nested<EOL> * Observable instead of an array.</span><EOL> *<EOL> * <img src=\"./img/windowToggle.png\" width=\"100%\"><EOL> *<EOL> * Returns an Observable that emits windows of items it collects from the source<EOL> * Observable. The output Observable emits windows that contain those items<EOL> * emitted by the source Observable between the time when the `openings`<EOL> * Observable emits an item and when the Observable returned by<EOL> * `closingSelector` emits an item.<EOL> *<EOL> * @example <caption>Every other second, emit the click events from the next 500ms</caption><EOL> * var clicks = Rx.Observable.fromEvent(document, 'click');<EOL> * var openings = Rx.Observable.interval(1000);<EOL> * var result = clicks.windowToggle(openings, i =><EOL> *   i % 2 ? Rx.Observable.interval(500) : Rx.Observable.empty()<EOL> * ).mergeAll();<EOL> * result.subscribe(x => console.log(x));<EOL> *<EOL> * @see {@link window}<EOL> * @see {@link windowCount}<EOL> * @see {@link windowTime}<EOL> * @see {@link windowWhen}<EOL> * @see {@link bufferToggle}<EOL> *<EOL> * @param {Observable<O>} openings An observable of notifications to start new<EOL> * windows.<EOL> * @param {function(value: O): Observable} closingSelector A function that takes<EOL> * the value emitted by the `openings` observable and returns an Observable,<EOL> * which, when it emits (either `next` or `complete`), signals that the<EOL> * associated window should complete.<EOL> * @return {Observable<Observable<T>>} An observable of windows, which in turn<EOL> * are Observables.<EOL> * @method windowToggle<EOL> * @owner Observable<EOL> */<EOL>export function windowToggle<T, O>(this: Observable<T>, openings: Observable<O>, closingSelector: (openValue: O) => Observable<any>): Observable<Observable<T>> {<EOL>    return this.lift(new WindowToggleOperator<T, O>(","gt":"openings, closingSelector));"}
{"input":"<s> function toTelemetryEventName(operation: Operation) {<EOL>    switch (operation) {<EOL>","gt":"case Operation.Installing: return '<STR_LIT>';"}
{"input":"<s> export function main() {<EOL>    platformBrowserDynamic().bootstrapModule(","gt":"ExampleModule);"}
{"input":"<s> /**<EOL> * Custom validator.<EOL> */<EOL>function creditCardValidator(c: AbstractControl): {<EOL>    [key: string]: boolean;<EOL>} {<EOL>    if (c.value && /^\\d{16}$/.test(c.value)) {<EOL>        return","gt":"null;"}
{"input":"<s> function runCoreAsync(res: pxtc.CompileResult) {<EOL>    return new Promise<void>((resolve, reject) => {<EOL>        let f = res.outfiles[pxtc.BINARY_JS];<EOL>        if (f) {<EOL>            let r = new pxsim.Runtime({ type: \"<STR_LIT>\", code: f });<EOL>            r.errorHandler = (e) => {<EOL>","gt":"reject(e);"}
{"input":"<s> function runCoreAsync(res: pxtc.CompileResult) {<EOL>    return new Promise<void>((resolve, reject) => {<EOL>        let f = res.outfiles[pxtc.BINARY_JS];<EOL>        if (f) {<EOL>            let r = new pxsim.Runtime({ type: \"<STR_LIT>\", code: f });<EOL>            r.errorHandler = (e) => {<EOL>                reject(e);<EOL>            };<EOL>            r.run(() => {<EOL>                <EOL>","gt":"pxsim.dumpLivePointers();"}
{"input":"<s> function onChangeActive() {<EOL>    const stopRendering = !isTabActive;<EOL>    if (stopRendering) {<EOL>        if (animationFrame != null) {<EOL>            cancelAnimationFrame(","gt":"animationFrame);"}
{"input":"<s> function onChangeActive() {<EOL>    const stopRendering = !isTabActive;<EOL>    if (stopRendering) {<EOL>        if (animationFrame != null) {<EOL>            cancelAnimationFrame(animationFrame);<EOL>            animationFrame = null;<EOL>        }<EOL>    }<EOL>    else","gt":"if (animationFrame == null) {"}
{"input":"<s> export async function download(url: string, downloadPath: string): Promise<void> {<EOL>    var file = fs.createWriteStream(downloadPath);<EOL>    await new Promise((resolve, reject) => {<EOL>        var req = https.request(url, res => {<EOL>            tl.debug(\"<STR_LIT>\" + res.statusCode);<EOL>            res.pipe(file);<EOL>            res.on(\"<STR_LIT>\", err => reject(","gt":"err));"}
{"input":"<s> export async function download(url: string, downloadPath: string): Promise<void> {<EOL>    var file = fs.createWriteStream(downloadPath);<EOL>    await new Promise((resolve, reject) => {<EOL>        var req = https.request(url, res => {<EOL>            tl.debug(\"<STR_LIT>\" + res.statusCode);<EOL>            res.pipe(file);<EOL>            res.on(\"<STR_LIT>\", err => reject(err));<EOL>            res.on(\"<STR_LIT>\", () => {<EOL>                tl.debug(\"<STR_LIT>\");<EOL>                resolve();<EOL>            });<EOL>        });<EOL>        req.on(\"<STR_LIT>\", err => {<EOL>            tl.debug(err);<EOL>","gt":"reject(err);"}
{"input":"<s> export function createSpdLogService(processName: string, logLevel: LogLevel, logsFolder: string): ILogService {<EOL>    try {<EOL>        setAsyncMode(<NUM_LIT>, <NUM_LIT>);<EOL>        const logfilePath = path.join(logsFolder, `<STR_LIT>`);<EOL>        const logger = new RotatingLogger(processName, logfilePath, <NUM_LIT> * <NUM_LIT> *","gt":"<NUM_LIT>, <NUM_LIT>);"}
{"input":"<s> export function createSpdLogService(processName: string, logLevel: LogLevel, logsFolder: string): ILogService {<EOL>    try {<EOL>        setAsyncMode(<NUM_LIT>, <NUM_LIT>);<EOL>        const logfilePath = path.join(logsFolder, `<STR_LIT>`);<EOL>        const logger = new RotatingLogger(processName, logfilePath, <NUM_LIT> * <NUM_LIT> * <NUM_LIT>, <NUM_LIT>);<EOL>        logger.setLevel(<NUM_LIT>);<EOL>        return new SpdLogService(logger, logLevel);<EOL>    }<EOL>    catch (e) {<EOL>        console.","gt":"error(e);"}
{"input":"<s> <EOL>export function handleVetos(vetos: (boolean | TPromise<boolean>)[], onError: (error: Error) => void): TPromise<boolean > {<EOL>    if (vetos.length === <NUM_LIT>) {<EOL>        return TPromise.as(false);<EOL>    }<EOL>    const promises: TPromise<void>[] = [];<EOL>    let","gt":"lazyValue = false;"}
{"input":"<s> <EOL>export function handleVetos(vetos: (boolean | TPromise<boolean>)[], onError: (error: Error) => void): TPromise<boolean > {<EOL>    if (vetos.length === <NUM_LIT>) {<EOL>        return TPromise.as(false);<EOL>    }<EOL>    const promises: TPromise<void>[] = [];<EOL>    let lazyValue = false;<EOL>    for (let valueOrPromise of vetos) {<EOL>        <EOL>        if (valueOrPromise === true) {<EOL>            return TPromise.as(true);<EOL>        }<EOL>        if (TPromise.is(valueOrPromise)) {<EOL>            promises.push(","gt":"valueOrPromise.then(value => {"}
{"input":"<s> <EOL>export function handleVetos(vetos: (boolean | TPromise<boolean>)[], onError: (error: Error) => void): TPromise<boolean > {<EOL>    if (vetos.length === <NUM_LIT>) {<EOL>        return TPromise.as(false);<EOL>    }<EOL>    const promises: TPromise<void>[] = [];<EOL>    let lazyValue = false;<EOL>    for (let valueOrPromise of vetos) {<EOL>        <EOL>        if (valueOrPromise === true) {<EOL>            return TPromise.as(true);<EOL>        }<EOL>        if (TPromise.is(valueOrPromise)) {<EOL>            promises.push(valueOrPromise.then(value => {<EOL>                if (value) {<EOL>                    lazyValue = true; <EOL>                }<EOL>            }, err => {<EOL>                onError(","gt":"err);"}
{"input":"<s> function setRequestHeaders(xhr: XMLHttpRequest, options: IRequestOptions): void {<EOL>    if (options.headers) {<EOL>        outer: for (let k in options.headers) {<EOL>            switch (k) {<EOL>","gt":"case '<STR_LIT>':"}
{"input":"<s> function setRequestHeaders(xhr: XMLHttpRequest, options: IRequestOptions): void {<EOL>    if (options.headers) {<EOL>        outer: for (let k in options.headers) {<EOL>            switch (k) {<EOL>                case '<STR_LIT>':<EOL>                case '<STR_LIT>':<EOL>                case '<STR_LIT>':<EOL>                    <EOL>                    continue outer;<EOL>            }<EOL>            xhr.setRequestHeader(k, options.","gt":"headers[k]);"}
{"input":"<s> function installFirstSystem(callback: Function) {<EOL>    const label = i18n.t(\"<STR_LIT>\");<EOL>    const options = {<EOL>        header: i18n.t(\"<STR_LIT>\"),<EOL>        validationLabel:","gt":"i18n.t(\"<STR_LIT>\"),"}
{"input":"<s> function installFirstSystem(callback: Function) {<EOL>    const label = i18n.t(\"<STR_LIT>\");<EOL>    const options = {<EOL>        header: i18n.t(\"<STR_LIT>\"),<EOL>        validationLabel: i18n.t(\"<STR_LIT>\"),<EOL>        cancelLabel: i18n.t(\"<STR_LIT>\")<EOL>    };<EOL>    new dialogs.ConfirmDialog(label, options, (installGame) => {<EOL>        if (!installGame) {<EOL>            localServer.","gt":"start();"}
{"input":"<s> function installFirstSystem(callback: Function) {<EOL>    const label = i18n.t(\"<STR_LIT>\");<EOL>    const options = {<EOL>        header: i18n.t(\"<STR_LIT>\"),<EOL>        validationLabel: i18n.t(\"<STR_LIT>\"),<EOL>        cancelLabel: i18n.t(\"<STR_LIT>\")<EOL>    };<EOL>    new dialogs.ConfirmDialog(label, options, (installGame) => {<EOL>        if (!installGame) {<EOL>            localServer.start();<EOL>            callback();<EOL>            return;<EOL>        }<EOL>        const waitingGameInstallElt = document.querySelector(\"<STR_LIT>\") as HTMLDivElement;<EOL>","gt":"async.series(["}
{"input":"<s> function installFirstSystem(callback: Function) {<EOL>    const label = i18n.t(\"<STR_LIT>\");<EOL>    const options = {<EOL>        header: i18n.t(\"<STR_LIT>\"),<EOL>        validationLabel: i18n.t(\"<STR_LIT>\"),<EOL>        cancelLabel: i18n.t(\"<STR_LIT>\")<EOL>    };<EOL>    new dialogs.ConfirmDialog(label, options, (installGame) => {<EOL>        if (!installGame) {<EOL>            localServer.start();<EOL>            callback();<EOL>            return;<EOL>        }<EOL>        const waitingGameInstallElt = document.querySelector(\"<STR_LIT>\") as HTMLDivElement;<EOL>        async.series([<EOL>            (cb) => {<EOL>                openServerSettings();<EOL>                serverSettingsSystems.action(\"<STR_LIT>\", { systemId: \"<STR_LIT>\" }, () => { cb(); });<EOL>                waitingGameInstallElt.hidden = false;<EOL>            },<EOL>            (cb) => {<EOL>                waitingGameInstallElt.hidden = true;<EOL>                const label = i18n.t(\"<STR_LIT>\");<EOL>                const options = {<EOL>                    haeder: i18n.t(","gt":"\"<STR_LIT>\"),"}
{"input":"<s> function installFirstSystem(callback: Function) {<EOL>    const label = i18n.t(\"<STR_LIT>\");<EOL>    const options = {<EOL>        header: i18n.t(\"<STR_LIT>\"),<EOL>        validationLabel: i18n.t(\"<STR_LIT>\"),<EOL>        cancelLabel: i18n.t(\"<STR_LIT>\")<EOL>    };<EOL>    new dialogs.ConfirmDialog(label, options, (installGame) => {<EOL>        if (!installGame) {<EOL>            localServer.start();<EOL>            callback();<EOL>            return;<EOL>        }<EOL>        const waitingGameInstallElt = document.querySelector(\"<STR_LIT>\") as HTMLDivElement;<EOL>        async.series([<EOL>            (cb) => {<EOL>                openServerSettings();<EOL>                serverSettingsSystems.action(\"<STR_LIT>\", { systemId: \"<STR_LIT>\" }, () => { cb(); });<EOL>                waitingGameInstallElt.hidden = false;<EOL>            },<EOL>            (cb) => {<EOL>                waitingGameInstallElt.hidden = true;<EOL>                const label = i18n.t(\"<STR_LIT>\");<EOL>                const options = {<EOL>                    haeder: i18n.t(\"<STR_LIT>\"),<EOL>                    closeLabel: i18n.t(\"<STR_LIT>\")<EOL>                };<EOL>                new dialogs.InfoDialog(label, options, cb);<EOL>            },<EOL>            (cb) => {<EOL>                localServer.start();<EOL>                const label = i18n.t(\"<STR_LIT>\");<EOL>                const options = {<EOL>                    header: i18n.t(\"<STR_LIT>\"),<EOL>","gt":"closeLabel: dialogs.BaseDialog.defaultLabels.close"}
{"input":"<s> function loadPlugins(callback: (err: Error) => void) {<EOL>    const i18nFiles: SupClient.i18n.File[] = [];<EOL>    i18nFiles.push({ root: `<STR_LIT>`, name: \"<STR_LIT>\" });<EOL>    SupClient.fetch(`<STR_LIT>`, \"<STR_LIT>\", (err: Error, pluginsInfo: SupCore.PluginsInfo) => {<EOL>        for (const pluginName of","gt":"pluginsInfo.list) {"}
{"input":"<s> function loadPlugins(callback: (err: Error) => void) {<EOL>    const i18nFiles: SupClient.i18n.File[] = [];<EOL>    i18nFiles.push({ root: `<STR_LIT>`, name: \"<STR_LIT>\" });<EOL>    SupClient.fetch(`<STR_LIT>`, \"<STR_LIT>\", (err: Error, pluginsInfo: SupCore.PluginsInfo) => {<EOL>        for (const pluginName of pluginsInfo.list) {<EOL>            const root = `<STR_LIT>`;<EOL>            i18nFiles.push({ root, name: \"<STR_LIT>\" });<EOL>        }<EOL>        async.parallel([<EOL>            (cb) => {<EOL>                SupClient.i18n.load(i18nFiles, cb);<EOL>            }, (","gt":"cb) => {"}
{"input":"<s> function loadPlugins(callback: (err: Error) => void) {<EOL>    const i18nFiles: SupClient.i18n.File[] = [];<EOL>    i18nFiles.push({ root: `<STR_LIT>`, name: \"<STR_LIT>\" });<EOL>    SupClient.fetch(`<STR_LIT>`, \"<STR_LIT>\", (err: Error, pluginsInfo: SupCore.PluginsInfo) => {<EOL>        for (const pluginName of pluginsInfo.list) {<EOL>            const root = `<STR_LIT>`;<EOL>            i18nFiles.push({ root, name: \"<STR_LIT>\" });<EOL>        }<EOL>        async.parallel([<EOL>            (cb) => {<EOL>                SupClient.i18n.load(i18nFiles, cb);<EOL>            }, (cb) => {<EOL>                async.each(pluginsInfo.list, (pluginName, cb) => {<EOL>                    const pluginPath = `<STR_LIT>`;<EOL>                    async.each([\"<STR_LIT>\", \"<STR_LIT>\", \"<STR_LIT>\", \"<STR_LIT>\"], (name, cb) => {<EOL>                        SupClient.loadScript(`<STR_LIT>`, cb);<EOL>                    },","gt":"cb);"}
{"input":"<s> function updateSystemsAndPlugins() {<EOL>    serverSettingsSystems.getRegistry((registry) => {<EOL>        if (registry == null) {<EOL>            localServer.start();<EOL>","gt":"return;"}
{"input":"<s> function updateSystemsAndPlugins() {<EOL>    serverSettingsSystems.getRegistry((registry) => {<EOL>        if (registry == null) {<EOL>            localServer.start();<EOL>            return;<EOL>        }<EOL>        const systemsAndPlugins: string[] = [];<EOL>","gt":"for (const systemId in registry.systems) {"}
{"input":"<s> function updateSystemsAndPlugins() {<EOL>    serverSettingsSystems.getRegistry((registry) => {<EOL>        if (registry == null) {<EOL>            localServer.start();<EOL>            return;<EOL>        }<EOL>        const systemsAndPlugins: string[] = [];<EOL>        for (const systemId in registry.systems) {<EOL>            const system = registry.systems[systemId];<EOL>            if (!system.isLocalDev && system.localVersion != null && system.version !== system.localVersion)<EOL>                systemsAndPlugins.push(systemId);<EOL>            for (const authorName in system.plugins) {<EOL>                for (const pluginName","gt":"in system.plugins[authorName]) {"}
{"input":"<s> function updateSystemsAndPlugins() {<EOL>    serverSettingsSystems.getRegistry((registry) => {<EOL>        if (registry == null) {<EOL>            localServer.start();<EOL>            return;<EOL>        }<EOL>        const systemsAndPlugins: string[] = [];<EOL>        for (const systemId in registry.systems) {<EOL>            const system = registry.systems[systemId];<EOL>            if (!system.isLocalDev && system.localVersion != null && system.version !== system.localVersion)<EOL>                systemsAndPlugins.push(systemId);<EOL>            for (const authorName in system.plugins) {<EOL>                for (const pluginName in system.plugins[authorName]) {<EOL>                    const plugin = system.plugins[authorName][pluginName];<EOL>                    if (!plugin.isLocalDev && plugin.localVersion != null && plugin.version !== plugin.localVersion)<EOL>                        systemsAndPlugins.push(`<STR_LIT>`);<EOL>                }<EOL>            }<EOL>        }<EOL>        if (systemsAndPlugins.length === <NUM_LIT>) {<EOL>            localServer.","gt":"start();"}
{"input":"<s> function updateSystemsAndPlugins() {<EOL>    serverSettingsSystems.getRegistry((registry) => {<EOL>        if (registry == null) {<EOL>            localServer.start();<EOL>            return;<EOL>        }<EOL>        const systemsAndPlugins: string[] = [];<EOL>        for (const systemId in registry.systems) {<EOL>            const system = registry.systems[systemId];<EOL>            if (!system.isLocalDev && system.localVersion != null && system.version !== system.localVersion)<EOL>                systemsAndPlugins.push(systemId);<EOL>            for (const authorName in system.plugins) {<EOL>                for (const pluginName in system.plugins[authorName]) {<EOL>                    const plugin = system.plugins[authorName][pluginName];<EOL>                    if (!plugin.isLocalDev && plugin.localVersion != null && plugin.version !== plugin.localVersion)<EOL>                        systemsAndPlugins.push(`<STR_LIT>`);<EOL>                }<EOL>            }<EOL>        }<EOL>        if (systemsAndPlugins.length === <NUM_LIT>) {<EOL>            localServer.start();<EOL>            return;<EOL>        }<EOL>        const label = i18n.t(\"<STR_LIT>\", { systemsAndPlugins: systemsAndPlugins.join(\"<STR_LIT>\") });<EOL>        const options = {<EOL>            validationLabel: i18n.t(\"<STR_LIT>\"),<EOL>            cancelLabel: i18n.t(\"<STR_LIT>\")<EOL>        };<EOL>        new dialogs.ConfirmDialog(label,","gt":"options, (shouldUpdate) => {"}
{"input":"<s> /**<EOL> * Execute a callback safely, if it doesn't work, return default and log messages.<EOL> *<EOL> * @param cb The function to be executed,<EOL> * @param defaultText The default value if execution of the cb failed<EOL> * @param fileName The filename of the current document<EOL> * @returns {string} formatted text or defaultText<EOL> */<EOL>export function safeExecution(cb: (() => string) | Promise<string>, defaultText: string, fileName: string): string | Promise<string> {<EOL>    if (cb instanceof Promise) {<EOL>        return cb<EOL>            .then(returnValue => {<EOL>            updateStatusBar('<STR_LIT>');<EOL>","gt":"return returnValue;"}
{"input":"<s> /**<EOL> * Execute a callback safely, if it doesn't work, return default and log messages.<EOL> *<EOL> * @param cb The function to be executed,<EOL> * @param defaultText The default value if execution of the cb failed<EOL> * @param fileName The filename of the current document<EOL> * @returns {string} formatted text or defaultText<EOL> */<EOL>export function safeExecution(cb: (() => string) | Promise<string>, defaultText: string, fileName: string): string | Promise<string> {<EOL>    if (cb instanceof Promise) {<EOL>        return cb<EOL>            .then(returnValue => {<EOL>            updateStatusBar('<STR_LIT>');<EOL>            return returnValue;<EOL>        })<EOL>            .catch((","gt":"err: Error) => {"}
{"input":"<s> export function openStatusTab() {<EOL>    statusChatTab.","gt":"showTab(true);"}
{"input":"<s> function onChangeActive() {<EOL>    const stopRendering = !isTabActive;<EOL>    if (stopRendering) {<EOL>        if (animationFrame != null) {<EOL>            cancelAnimationFrame(","gt":"animationFrame);"}
{"input":"<s> function onChangeActive() {<EOL>    const stopRendering = !isTabActive;<EOL>    if (stopRendering) {<EOL>        if (animationFrame != null) {<EOL>            cancelAnimationFrame(animationFrame);<EOL>            animationFrame = null;<EOL>        }<EOL>    }<EOL>","gt":"else if (animationFrame == null) {"}
{"input":"<s> /** Function that sets a Github commit status */<EOL>export function setGithubStatus(commitSHA: string, data: GithubStatusData) {<EOL>    const state = data.result ? '<STR_LIT>' : '<STR_LIT>';<EOL>    return githubApiV3.repos.createStatus({<EOL>        owner: '<STR_LIT>',<EOL>","gt":"repo: '<STR_LIT>',"}
{"input":"<s> /** Function that sets a Github commit status */<EOL>export function setGithubStatus(commitSHA: string, data: GithubStatusData) {<EOL>    const state = data.result ? '<STR_LIT>' : '<STR_LIT>';<EOL>    return githubApiV3.repos.createStatus({<EOL>        owner: '<STR_LIT>',<EOL>        repo: '<STR_LIT>',<EOL>        sha: commitSHA,<EOL>        state: state,<EOL>        target_url: data.url,<EOL>        description: data.","gt":"description,"}
{"input":"<s> function _findAllPackageJson(dir: string, exclude: RegExp): string[] {<EOL>    const result: string[] = [];<EOL>    fs.readdirSync(dir)<EOL>        .forEach(fileName => {<EOL>        const p = path.join(dir, fileName);<EOL>","gt":"if (exclude.test(p)) {"}
{"input":"<s> function _findAllPackageJson(dir: string, exclude: RegExp): string[] {<EOL>    const result: string[] = [];<EOL>    fs.readdirSync(dir)<EOL>        .forEach(fileName => {<EOL>        const p = path.join(dir, fileName);<EOL>        if (exclude.test(p)) {<EOL>            return;<EOL>        }<EOL>        else if (fileName == '<STR_LIT>') {<EOL>            result.","gt":"push(p);"}
{"input":"<s> function _findAllPackageJson(dir: string, exclude: RegExp): string[] {<EOL>    const result: string[] = [];<EOL>    fs.readdirSync(dir)<EOL>        .forEach(fileName => {<EOL>        const p = path.join(dir, fileName);<EOL>        if (exclude.test(p)) {<EOL>            return;<EOL>        }<EOL>        else if (fileName == '<STR_LIT>') {<EOL>            result.push(p);<EOL>        }<EOL>        else if (fs.statSync(p).isDirectory()) {<EOL>            result.push(...","gt":"_findAllPackageJson(p, exclude));"}
{"input":"<s> export default function openServer(serverEntry: ServerEntry) {<EOL>    clearActiveTab();<EOL>    let tabElt = tabStrip.tabsRoot.querySelector(`<STR_LIT>`) as HTMLLIElement;<EOL>    let paneElt = panesElt.querySelector(`<STR_LIT>`) as HTMLDivElement;<EOL>","gt":"if (tabElt == null) {"}
{"input":"<s> function uninstallPlugin(systemFolderName: string, pluginFullName: string, authorName: string) {<EOL>    rimraf(`<STR_LIT>`, (err) => {<EOL>        if (err != null) {<EOL>            utils.emitError(`<STR_LIT>`);<EOL>        }<EOL>        else {<EOL>            if (fs.readdirSync(`<STR_LIT>`).length === <NUM_LIT>)<EOL>                fs.rmdirSync(`<STR_LIT>`);<EOL>            console.log(\"<STR_LIT>\");<EOL>            process.exit(","gt":"<NUM_LIT>);"}
{"input":"<s> export function downloadRelease(downloadURL: string, downloadPath: string, callback: (err: string) => void) {<EOL>    console.log(\"<STR_LIT>\");<EOL>    https.get({<EOL>","gt":"hostname: \"<STR_LIT>\","}
{"input":"<s> export function downloadRelease(downloadURL: string, downloadPath: string, callback: (err: string) => void) {<EOL>    console.log(\"<STR_LIT>\");<EOL>    https.get({<EOL>        hostname: \"<STR_LIT>\",<EOL>        path: downloadURL,<EOL>        headers: { \"<STR_LIT>\": \"<STR_LIT>\" }<EOL>    }, (","gt":"res) => {"}
{"input":"<s> export function downloadRelease(downloadURL: string, downloadPath: string, callback: (err: string) => void) {<EOL>    console.log(\"<STR_LIT>\");<EOL>    https.get({<EOL>        hostname: \"<STR_LIT>\",<EOL>        path: downloadURL,<EOL>        headers: { \"<STR_LIT>\": \"<STR_LIT>\" }<EOL>    }, (res) => {<EOL>        if (res.statusCode !== <NUM_LIT>) {<EOL>            callback(","gt":"statusCode}`<STR_LIT>;"}
{"input":"<s> export function downloadRelease(downloadURL: string, downloadPath: string, callback: (err: string) => void) {<EOL>    console.log(\"<STR_LIT>\");<EOL>    https.get({<EOL>        hostname: \"<STR_LIT>\",<EOL>        path: downloadURL,<EOL>        headers: { \"<STR_LIT>\": \"<STR_LIT>\" }<EOL>    }, (res) => {<EOL>        if (res.statusCode !== <NUM_LIT>) {<EOL>            callback(`<STR_LIT>`);<EOL>            return;<EOL>        }<EOL>        let progress = <NUM_LIT>;<EOL>        let progressMax =","gt":"parseInt(res.headers[\"<STR_LIT>\"], <NUM_LIT>) * <NUM_LIT>;"}
{"input":"<s> export function downloadRelease(downloadURL: string, downloadPath: string, callback: (err: string) => void) {<EOL>    console.log(\"<STR_LIT>\");<EOL>    https.get({<EOL>        hostname: \"<STR_LIT>\",<EOL>        path: downloadURL,<EOL>        headers: { \"<STR_LIT>\": \"<STR_LIT>\" }<EOL>    }, (res) => {<EOL>        if (res.statusCode !== <NUM_LIT>) {<EOL>            callback(`<STR_LIT>`);<EOL>            return;<EOL>        }<EOL>        let progress = <NUM_LIT>;<EOL>        let progressMax = parseInt(res.headers[\"<STR_LIT>\"], <NUM_LIT>) * <NUM_LIT>;<EOL>        const","gt":"buffers: Buffer[] = [];"}
{"input":"<s> export function downloadRelease(downloadURL: string, downloadPath: string, callback: (err: string) => void) {<EOL>    console.log(\"<STR_LIT>\");<EOL>    https.get({<EOL>        hostname: \"<STR_LIT>\",<EOL>        path: downloadURL,<EOL>        headers: { \"<STR_LIT>\": \"<STR_LIT>\" }<EOL>    }, (res) => {<EOL>        if (res.statusCode !== <NUM_LIT>) {<EOL>            callback(`<STR_LIT>`);<EOL>            return;<EOL>        }<EOL>        let progress = <NUM_LIT>;<EOL>        let progressMax = parseInt(res.headers[\"<STR_LIT>\"], <NUM_LIT>) * <NUM_LIT>;<EOL>        const buffers: Buffer[] = [];<EOL>        res.on(\"<STR_LIT>\", (data: Buffer) => { buffers.push(data); progress += data.length; onProgress(progress / progressMax); });<EOL>        res.on(\"<STR_LIT>\", () => {<EOL>            let zipBuffer = Buffer.concat(buffers);<EOL>            yauzl.fromBuffer(zipBuffer, { lazyEntries: true }, (err: Error, zipFile: any) => {<EOL>                if (err !=","gt":"null)"}
{"input":"<s> export function downloadRelease(downloadURL: string, downloadPath: string, callback: (err: string) => void) {<EOL>    console.log(\"<STR_LIT>\");<EOL>    https.get({<EOL>        hostname: \"<STR_LIT>\",<EOL>        path: downloadURL,<EOL>        headers: { \"<STR_LIT>\": \"<STR_LIT>\" }<EOL>    }, (res) => {<EOL>        if (res.statusCode !== <NUM_LIT>) {<EOL>            callback(`<STR_LIT>`);<EOL>            return;<EOL>        }<EOL>        let progress = <NUM_LIT>;<EOL>        let progressMax = parseInt(res.headers[\"<STR_LIT>\"], <NUM_LIT>) * <NUM_LIT>;<EOL>        const buffers: Buffer[] = [];<EOL>        res.on(\"<STR_LIT>\", (data: Buffer) => { buffers.push(data); progress += data.length; onProgress(progress / progressMax); });<EOL>        res.on(\"<STR_LIT>\", () => {<EOL>            let zipBuffer = Buffer.concat(buffers);<EOL>            yauzl.fromBuffer(zipBuffer, { lazyEntries: true }, (err: Error, zipFile: any) => {<EOL>                if (err != null)<EOL>                    throw err;<EOL>                progress = zipFile.entryCount;<EOL>                progressMax = zipFile.entryCount * <NUM_LIT>;<EOL>                let rootFolderName: string;<EOL>                zipFile.readEntry();<EOL>                zipFile.on(\"<STR_LIT>\", (entry: any) => {<EOL>                    if (rootFolderName ==","gt":"null)"}
{"input":"<s> export function downloadRelease(downloadURL: string, downloadPath: string, callback: (err: string) => void) {<EOL>    console.log(\"<STR_LIT>\");<EOL>    https.get({<EOL>        hostname: \"<STR_LIT>\",<EOL>        path: downloadURL,<EOL>        headers: { \"<STR_LIT>\": \"<STR_LIT>\" }<EOL>    }, (res) => {<EOL>        if (res.statusCode !== <NUM_LIT>) {<EOL>            callback(`<STR_LIT>`);<EOL>            return;<EOL>        }<EOL>        let progress = <NUM_LIT>;<EOL>        let progressMax = parseInt(res.headers[\"<STR_LIT>\"], <NUM_LIT>) * <NUM_LIT>;<EOL>        const buffers: Buffer[] = [];<EOL>        res.on(\"<STR_LIT>\", (data: Buffer) => { buffers.push(data); progress += data.length; onProgress(progress / progressMax); });<EOL>        res.on(\"<STR_LIT>\", () => {<EOL>            let zipBuffer = Buffer.concat(buffers);<EOL>            yauzl.fromBuffer(zipBuffer, { lazyEntries: true }, (err: Error, zipFile: any) => {<EOL>                if (err != null)<EOL>                    throw err;<EOL>                progress = zipFile.entryCount;<EOL>                progressMax = zipFile.entryCount * <NUM_LIT>;<EOL>                let rootFolderName: string;<EOL>                zipFile.readEntry();<EOL>                zipFile.on(\"<STR_LIT>\", (entry: any) => {<EOL>                    if (rootFolderName == null)<EOL>                        rootFolderName = entry.fileName;<EOL>                    if (entry.fileName.indexOf(rootFolderName) !== <NUM_LIT>)<EOL>                        throw new Error(`<STR_LIT>`);<EOL>                    const filename = path.join(downloadPath, entry.fileName.replace(rootFolderName, \"<STR_LIT>\"));<EOL>                    if (/\\/$/.test(entry.fileName)) {<EOL>                        mkdirp(filename, (err) => {<EOL>                            if (err != null)<EOL>","gt":"throw err;"}
{"input":"<s> export function downloadRelease(downloadURL: string, downloadPath: string, callback: (err: string) => void) {<EOL>    console.log(\"<STR_LIT>\");<EOL>    https.get({<EOL>        hostname: \"<STR_LIT>\",<EOL>        path: downloadURL,<EOL>        headers: { \"<STR_LIT>\": \"<STR_LIT>\" }<EOL>    }, (res) => {<EOL>        if (res.statusCode !== <NUM_LIT>) {<EOL>            callback(`<STR_LIT>`);<EOL>            return;<EOL>        }<EOL>        let progress = <NUM_LIT>;<EOL>        let progressMax = parseInt(res.headers[\"<STR_LIT>\"], <NUM_LIT>) * <NUM_LIT>;<EOL>        const buffers: Buffer[] = [];<EOL>        res.on(\"<STR_LIT>\", (data: Buffer) => { buffers.push(data); progress += data.length; onProgress(progress / progressMax); });<EOL>        res.on(\"<STR_LIT>\", () => {<EOL>            let zipBuffer = Buffer.concat(buffers);<EOL>            yauzl.fromBuffer(zipBuffer, { lazyEntries: true }, (err: Error, zipFile: any) => {<EOL>                if (err != null)<EOL>                    throw err;<EOL>                progress = zipFile.entryCount;<EOL>                progressMax = zipFile.entryCount * <NUM_LIT>;<EOL>                let rootFolderName: string;<EOL>                zipFile.readEntry();<EOL>                zipFile.on(\"<STR_LIT>\", (entry: any) => {<EOL>                    if (rootFolderName == null)<EOL>                        rootFolderName = entry.fileName;<EOL>                    if (entry.fileName.indexOf(rootFolderName) !== <NUM_LIT>)<EOL>                        throw new Error(`<STR_LIT>`);<EOL>                    const filename = path.join(downloadPath, entry.fileName.replace(rootFolderName, \"<STR_LIT>\"));<EOL>                    if (/\\/$/.test(entry.fileName)) {<EOL>                        mkdirp(filename, (err) => {<EOL>                            if (err != null)<EOL>                                throw err;<EOL>                            progress++;<EOL>                            onProgress(progress / progressMax);<EOL>                            zipFile.readEntry();<EOL>                        });<EOL>                    }<EOL>                    else {<EOL>                        zipFile.openReadStream(entry, (err: Error, readStream: NodeJS.ReadableStream) => {<EOL>                            if (err)<EOL>                                throw err;<EOL>                            mkdirp(path.dirname(filename), (err: Error) => {<EOL>                                if (err)<EOL>                                    throw err;<EOL>                                readStream.pipe(fs.createWriteStream(","gt":"filename));"}
{"input":"<s> function onDisconnect() {<EOL>","gt":"cleanUp();"}
{"input":"<s> <EOL>/**<EOL> * Projects each source value to the same Observable which is flattened multiple<EOL> * times with {@link switch} in the output Observable.<EOL> *<EOL> * <span class=\"informal\">It's like {@link switchMap}, but maps each value<EOL> * always to the same inner Observable.</span><EOL> *<EOL> * <img src=\"./img/switchMapTo.png\" width=\"100%\"><EOL> *<EOL> * Maps each source value to the given Observable `innerObservable` regardless<EOL> * of the source value, and then flattens those resulting Observables into one<EOL> * single Observable, which is the output Observable. The output Observables<EOL> * emits values only from the most recently emitted instance of<EOL> * `innerObservable`.<EOL> *<EOL> * @example <caption>Rerun an interval Observable on every click event</caption><EOL> * var clicks = Rx.Observable.fromEvent(document, 'click');<EOL> * var result = clicks.switchMapTo(Rx.Observable.interval(1000));<EOL> * result.subscribe(x => console.log(x));<EOL> *<EOL> * @see {@link concatMapTo}<EOL> * @see {@link switch}<EOL> * @see {@link switchMap}<EOL> * @see {@link mergeMapTo}<EOL> *<EOL> * @param {ObservableInput} innerObservable An Observable to replace each value from<EOL> * the source Observable.<EOL> * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]<EOL> * A function to produce the value on the output Observable based on the values<EOL> * and the indices of the source (outer) emission and the inner Observable<EOL> * emission. The arguments passed to this function are:<EOL> * - `outerValue`: the value that came from the source<EOL> * - `innerValue`: the value that came from the projected Observable<EOL> * - `outerIndex`: the \"index\" of the value that came from the source<EOL> * - `innerIndex`: the \"index\" of the value from the projected Observable<EOL> * @return {Observable} An Observable that emits items from the given<EOL> * `innerObservable` (and optionally transformed through `resultSelector`) every<EOL> * time a value is emitted on the source Observable, and taking only the values<EOL> * from the most recently projected inner Observable.<EOL> * @method switchMapTo<EOL> * @owner Observable<EOL> */<EOL>export function switchMapTo<T, I, R>(this: Observable<T>, innerObservable: Observable<I>, resultSelector?: (outerValue: T, innerValue: I, outerIndex: number, innerIndex: number) => R): Observable<I | R> {<EOL>    return this.lift(new","gt":"SwitchMapToOperator(innerObservable, resultSelector));"}
{"input":"<s> export function setKey<T, K extends keyof T>(k: K, v: T[K], o: T): T {<EOL>    if (k in o && structEq(v, o[k])) {<EOL>        return o;<EOL>    }<EOL>    else {<EOL>        <EOL>        <EOL>        const r: {<EOL>            [k in keyof T]: T[k];<EOL>        } = {} as any;<EOL>        for (const p in o)<EOL>","gt":"r[p] = o[p];"}
{"input":"<s> <EOL>/**<EOL> * Derive a reactive list from:<EOL> * - an observable of list item ids<EOL> * - a list item factory – a function that will create a list item based on item id.<EOL> */<EOL>export function reactiveList<TValue>(ids: Observable<string[]> | Observable<number[]>, createListItem: ((x: string) => TValue) | ((x: number) => TValue)): Observable<TValue[]> {<EOL>    return ids.scan(([oldIds, _]: [<EOL>        any,<EOL>        TValue[]<EOL>    ], ids: string[] | number[]) => {<EOL>        <EOL>        <EOL>        <EOL>        const newIds: any = {};<EOL>","gt":"const newValues: TValue[] = Array(ids.length);"}
{"input":"<s> <EOL>/**<EOL> * Derive a reactive list from:<EOL> * - an observable of list item ids<EOL> * - a list item factory – a function that will create a list item based on item id.<EOL> */<EOL>export function reactiveList<TValue>(ids: Observable<string[]> | Observable<number[]>, createListItem: ((x: string) => TValue) | ((x: number) => TValue)): Observable<TValue[]> {<EOL>    return ids.scan(([oldIds, _]: [<EOL>        any,<EOL>        TValue[]<EOL>    ], ids: string[] | number[]) => {<EOL>        <EOL>        <EOL>        <EOL>        const newIds: any = {};<EOL>        const newValues: TValue[] = Array(ids.length);<EOL>        const n = ids.length;<EOL>        for (let i = <NUM_LIT>; i < n; ++i) {<EOL>","gt":"const id = ids[i];"}
{"input":"<s> export function main() {<EOL>    platformWorkerAppDynamic().","gt":"bootstrapModule(ExampleModule);"}
{"input":"<s> export function main() {<EOL>","gt":"platformWorkerAppDynamic().bootstrapModule(ExampleModule);"}
{"input":"<s> function gestureChangeEventMerger(lastEvent: IThrottledGestureEvent, currentEvent: MSGestureEvent): IThrottledGestureEvent {<EOL>    let r = {<EOL>        translationY: currentEvent.translationY,<EOL>        translationX:","gt":"currentEvent.translationX"}
{"input":"<s> function addToHeroName(text: string): promise.Promise<void> {<EOL>    let input = element(by.","gt":"css('<STR_LIT>'));"}
{"input":"<s> function getStyle(el: DebugElement, prop: string): string {<EOL>    return getComputedStyle(","gt":"el.nativeElement).getPropertyValue(prop);"}
{"input":"<s> /**<EOL> * Converts a camelized string into all lower case separated by underscores.<EOL> *<EOL> ```javascript<EOL> decamelize('innerHTML');         // 'inner_html'<EOL> decamelize('action_name');       // 'action_name'<EOL> decamelize('css-class-name');    // 'css-class-name'<EOL> decamelize('my favorite items'); // 'my favorite items'<EOL> ```<EOL><EOL> @method decamelize<EOL> @param {String} str The string to decamelize.<EOL> @return {String} the decamelized string.<EOL> */<EOL>export function decamelize(str: string): string {<EOL>    return str.","gt":"replace(STRING_DECAMELIZE_REGEXP, '<STR_LIT>').toLowerCase();"}
{"input":"<s> function addStringArg(argName: string, inputName: string, required: boolean, tr: ToolRunner) {<EOL>    addArg(","gt":"argName, () => { return tl.getInput(inputName, required); }, tr);"}
{"input":"<s> export function provideRouterConnector() {<EOL>    return {<EOL>        provide:","gt":"APP_BOOTSTRAP_LISTENER,"}
{"input":"<s> function logOfRouterAndStore(router: Router, store: Store<any>): any[] {<EOL>    const log: any[] = [];<EOL>    router.events.subscribe(e => {<EOL>        if (e.hasOwnProperty('<STR_LIT>')) {<EOL>            log.","gt":"push({"}
{"input":"<s> export function getSelectionSearchString(editor: ICodeEditor): string {<EOL>    let selection = editor.getSelection();<EOL>    <EOL>    if (selection.startLineNumber === selection.endLineNumber) {<EOL>        if (selection.isEmpty()) {<EOL>            let","gt":"wordAtPosition = editor.getModel().getWordAtPosition(selection.getStartPosition());"}
{"input":"<s> export function getSelectionSearchString(editor: ICodeEditor): string {<EOL>    let selection = editor.getSelection();<EOL>    <EOL>    if (selection.startLineNumber === selection.endLineNumber) {<EOL>        if (selection.isEmpty()) {<EOL>            let wordAtPosition = editor.getModel().getWordAtPosition(selection.getStartPosition());<EOL>            if (wordAtPosition) {<EOL>                return wordAtPosition.word;<EOL>            }<EOL>        }<EOL>        else {<EOL>","gt":"return editor.getModel().getValueInRange(selection);"}
{"input":"<s> export default function (options: ServiceOptions): Rule {<EOL>    options.path = options.path ? normalize(options.path) : options.path;<EOL>    const sourceDir = options.sourceDir;<EOL>    const statePath = `<STR_LIT>`;<EOL>    const environmentsPath = buildRelativePath(statePath, `<STR_LIT>`);<EOL>    if (!sourceDir) {<EOL>        throw new","gt":"SchematicsException(`<STR_LIT>`);"}
{"input":"<s> export default function (options: ServiceOptions): Rule {<EOL>    options.path = options.path ? normalize(options.path) : options.path;<EOL>    const sourceDir = options.sourceDir;<EOL>    const statePath = `<STR_LIT>`;<EOL>    const environmentsPath = buildRelativePath(statePath, `<STR_LIT>`);<EOL>    if (!sourceDir) {<EOL>        throw new SchematicsException(`<STR_LIT>`);<EOL>    }<EOL>    return (host: Tree, context: SchematicContext) => {<EOL>","gt":"if (options.module) {"}
{"input":"<s> export default function (options: ServiceOptions): Rule {<EOL>    options.path = options.path ? normalize(options.path) : options.path;<EOL>    const sourceDir = options.sourceDir;<EOL>    const statePath = `<STR_LIT>`;<EOL>    const environmentsPath = buildRelativePath(statePath, `<STR_LIT>`);<EOL>    if (!sourceDir) {<EOL>        throw new SchematicsException(`<STR_LIT>`);<EOL>    }<EOL>    return (host: Tree, context: SchematicContext) => {<EOL>        if (options.module) {<EOL>            options.module = findModuleFromOptions(host, options);<EOL>        }<EOL>        const templateSource =","gt":"apply(url('<STR_LIT>'), ["}
{"input":"<s> export default function (options: ServiceOptions): Rule {<EOL>    options.path = options.path ? normalize(options.path) : options.path;<EOL>    const sourceDir = options.sourceDir;<EOL>    const statePath = `<STR_LIT>`;<EOL>    const environmentsPath = buildRelativePath(statePath, `<STR_LIT>`);<EOL>    if (!sourceDir) {<EOL>        throw new SchematicsException(`<STR_LIT>`);<EOL>    }<EOL>    return (host: Tree, context: SchematicContext) => {<EOL>        if (options.module) {<EOL>            options.module = findModuleFromOptions(host, options);<EOL>        }<EOL>        const templateSource = apply(url('<STR_LIT>'), [<EOL>            template({<EOL>                ...stringUtils,<EOL>                ...(options","gt":"as object),"}
{"input":"<s> export default function (options: ServiceOptions): Rule {<EOL>    options.path = options.path ? normalize(options.path) : options.path;<EOL>    const sourceDir = options.sourceDir;<EOL>    const statePath = `<STR_LIT>`;<EOL>    const environmentsPath = buildRelativePath(statePath, `<STR_LIT>`);<EOL>    if (!sourceDir) {<EOL>        throw new SchematicsException(`<STR_LIT>`);<EOL>    }<EOL>    return (host: Tree, context: SchematicContext) => {<EOL>        if (options.module) {<EOL>            options.module = findModuleFromOptions(host, options);<EOL>        }<EOL>        const templateSource = apply(url('<STR_LIT>'), [<EOL>            template({<EOL>                ...stringUtils,<EOL>                ...(options as object),<EOL>                environmentsPath,<EOL>            }),<EOL>            move(sourceDir),<EOL>        ]);<EOL>        return chain([<EOL>            branchAndMerge(chain([<EOL>                filter(path => path.endsWith(","gt":"'<STR_LIT>') &&"}
{"input":"<s> /**<EOL> * Catches errors on the observable to be handled by returning a new observable or throwing an error.<EOL> *<EOL> * <img src=\"./img/catch.png\" width=\"100%\"><EOL> *<EOL> * @example <caption>Continues with a different Observable when there's an error</caption><EOL> *<EOL> * Observable.of(1, 2, 3, 4, 5)<EOL> *   .map(n => {<EOL> * \t   if (n == 4) {<EOL> * \t     throw 'four!';<EOL> *     }<EOL> *\t   return n;<EOL> *   })<EOL> *   .catch(err => Observable.of('I', 'II', 'III', 'IV', 'V'))<EOL> *   .subscribe(x => console.log(x));<EOL> *   // 1, 2, 3, I, II, III, IV, V<EOL> *<EOL> * @example <caption>Retries the caught source Observable again in case of error, similar to retry() operator</caption><EOL> *<EOL> * Observable.of(1, 2, 3, 4, 5)<EOL> *   .map(n => {<EOL> * \t   if (n === 4) {<EOL> * \t     throw 'four!';<EOL> *     }<EOL> * \t   return n;<EOL> *   })<EOL> *   .catch((err, caught) => caught)<EOL> *   .take(30)<EOL> *   .subscribe(x => console.log(x));<EOL> *   // 1, 2, 3, 1, 2, 3, ...<EOL> *<EOL> * @example <caption>Throws a new error when the source Observable throws an error</caption><EOL> *<EOL> * Observable.of(1, 2, 3, 4, 5)<EOL> *   .map(n => {<EOL> *     if (n == 4) {<EOL> *       throw 'four!';<EOL> *     }<EOL> *     return n;<EOL> *   })<EOL> *   .catch(err => {<EOL> *     throw 'error in source. Details: ' + err;<EOL> *   })<EOL> *   .subscribe(<EOL> *     x => console.log(x),<EOL> *     err => console.log(err)<EOL> *   );<EOL> *   // 1, 2, 3, error in source. Details: four!<EOL> *<EOL> * @param {function} selector a function that takes as arguments `err`, which is the error, and `caught`, which<EOL> *  is the source observable, in case you'd like to \"retry\" that observable by returning it again. Whatever observable<EOL> *  is returned by the `selector` will be used to continue the observable chain.<EOL> * @return {Observable} An observable that originates from either the source or the observable returned by the<EOL> *  catch `selector` function.<EOL> * @name catchError<EOL> */<EOL>export function catchError<T, R>(selector: (err: any, caught: Observable<T>) => ObservableInput<R>): OperatorFunction<T, T | R> {<EOL>    return function catchErrorOperatorFunction(source: Observable<T>): Observable<T | R> {<EOL>        const operator = new CatchOperator(","gt":"selector);"}
{"input":"<s> /**<EOL> * Ignores source values for `duration` milliseconds, then emits the most recent<EOL> * value from the source Observable, then repeats this process.<EOL> *<EOL> * <span class=\"informal\">When it sees a source values, it ignores that plus<EOL> * the next ones for `duration` milliseconds, and then it emits the most recent<EOL> * value from the source.</span><EOL> *<EOL> * <img src=\"./img/auditTime.png\" width=\"100%\"><EOL> *<EOL> * `auditTime` is similar to `throttleTime`, but emits the last value from the<EOL> * silenced time window, instead of the first value. `auditTime` emits the most<EOL> * recent value from the source Observable on the output Observable as soon as<EOL> * its internal timer becomes disabled, and ignores source values while the<EOL> * timer is enabled. Initially, the timer is disabled. As soon as the first<EOL> * source value arrives, the timer is enabled. After `duration` milliseconds (or<EOL> * the time unit determined internally by the optional `scheduler`) has passed,<EOL> * the timer is disabled, then the most recent source value is emitted on the<EOL> * output Observable, and this process repeats for the next source value.<EOL> * Optionally takes a {@link IScheduler} for managing timers.<EOL> *<EOL> * @example <caption>Emit clicks at a rate of at most one click per second</caption><EOL> * var clicks = Rx.Observable.fromEvent(document, 'click');<EOL> * var result = clicks.auditTime(1000);<EOL> * result.subscribe(x => console.log(x));<EOL> *<EOL> * @see {@link audit}<EOL> * @see {@link debounceTime}<EOL> * @see {@link delay}<EOL> * @see {@link sampleTime}<EOL> * @see {@link throttleTime}<EOL> *<EOL> * @param {number} duration Time to wait before emitting the most recent source<EOL> * value, measured in milliseconds or the time unit determined internally<EOL> * by the optional `scheduler`.<EOL> * @param {Scheduler} [scheduler=async] The {@link IScheduler} to use for<EOL> * managing the timers that handle the rate-limiting behavior.<EOL> * @return {Observable<T>} An Observable that performs rate-limiting of<EOL> * emissions from the source Observable.<EOL> * @method auditTime<EOL> * @owner Observable<EOL> */<EOL>export function auditTime<T>(duration: number, scheduler: IScheduler = async): MonoTypeOperatorFunction<T> {<EOL>    return audit(() => timer(duration,","gt":"scheduler));"}
{"input":"<s> export function readConfigFile(context: string, query: QueryOptions, options: LoaderConfig, tsImpl: typeof ts): Configs {<EOL>    let configFilePath: string;<EOL>    if (query.configFileName && query.configFileName.match(/\\.json$/)) {<EOL>        configFilePath = absolutize(query.configFileName, context);<EOL>    }<EOL>","gt":"else {"}
{"input":"<s> export function readConfigFile(context: string, query: QueryOptions, options: LoaderConfig, tsImpl: typeof ts): Configs {<EOL>    let configFilePath: string;<EOL>    if (query.configFileName && query.configFileName.match(/\\.json$/)) {<EOL>        configFilePath = absolutize(query.configFileName, context);<EOL>    }<EOL>    else {<EOL>        configFilePath = tsImpl.findConfigFile(context, tsImpl.sys.fileExists);<EOL>    }<EOL>    let existingOptions = tsImpl.convertCompilerOptionsFromJson(query, context, '<STR_LIT>');<EOL>    if (!configFilePath || query.configFileContent) {<EOL>        return {<EOL>            configFilePath: configFilePath || path.join(context, '<STR_LIT>'),<EOL>            compilerConfig: tsImpl.parseJsonConfigFileContent(query.configFileContent || {}, tsImpl.sys, context, _.extend({}, tsImpl.","gt":"getDefaultCompilerOptions(), existingOptions.options) as ts.CompilerOptions, context),"}
{"input":"<s> export function readConfigFile(context: string, query: QueryOptions, options: LoaderConfig, tsImpl: typeof ts): Configs {<EOL>    let configFilePath: string;<EOL>    if (query.configFileName && query.configFileName.match(/\\.json$/)) {<EOL>        configFilePath = absolutize(query.configFileName, context);<EOL>    }<EOL>    else {<EOL>        configFilePath = tsImpl.findConfigFile(context, tsImpl.sys.fileExists);<EOL>    }<EOL>    let existingOptions = tsImpl.convertCompilerOptionsFromJson(query, context, '<STR_LIT>');<EOL>    if (!configFilePath || query.configFileContent) {<EOL>        return {<EOL>            configFilePath: configFilePath || path.join(context, '<STR_LIT>'),<EOL>            compilerConfig: tsImpl.parseJsonConfigFileContent(query.configFileContent || {}, tsImpl.sys, context, _.extend({}, tsImpl.getDefaultCompilerOptions(), existingOptions.options) as ts.CompilerOptions, context),<EOL>            loaderConfig: query as LoaderConfig<EOL>        };<EOL>    }<EOL>    let jsonConfigFile = tsImpl.readConfigFile(configFilePath, tsImpl.sys.readFile);<EOL>    let compilerConfig =","gt":"tsImpl.parseJsonConfigFileContent(jsonConfigFile.config, tsImpl.sys, path.dirname(configFilePath), existingOptions.options, configFilePath);"}
{"input":"<s> function updateBinary<T extends Binary>(binary: T, outputDir: string, proxy: string, ignoreSSL: boolean): Promise<void> {<EOL>    return FileManager<EOL>        .downloadFile(binary, outputDir, (binary: Binary, outputDir: string, fileName: string) => {<EOL>        unzip(binary, outputDir, fileName);<EOL>    })<EOL>        .then<void>(downloaded => {<EOL>        if (!downloaded) {<EOL>            <EOL>            logger.info(binary.name + '<STR_LIT>' + path.resolve(outputDir, binary.filename()));<EOL>            let fileName = binary.filename();<EOL>            unzip(binary,","gt":"outputDir, fileName);"}
{"input":"<s> export function featurePath(group: boolean | undefined, flat: boolean | undefined, path: string, name: string) {<EOL>    if (group && !flat) {<EOL>        return","gt":"path}/${name}/`<STR_LIT>;"}
{"input":"<s> export function verifyOutput(output: EffectNotification, reporter: ErrorHandler) {<EOL>    reportErrorThrown(","gt":"output, reporter);"}
{"input":"<s> /** @docs-private */<EOL>export function VIEWPORT_RULER_PROVIDER_FACTORY(parentRuler: ViewportRuler, platform: Platform, ngZone: NgZone) {<EOL>    return parentRuler ||","gt":"new ViewportRuler(platform, ngZone);"}
{"input":"<s> export function overridePlatform(platform: string): void {<EOL>    IS_ANDROID = platform ==","gt":"'<STR_LIT>';"}
{"input":"<s> export function foo() {<EOL>    return new","gt":"d();"}
{"input":"<s> export function windowTime<T>(this: Observable<T>, windowTimeSpan: number): Observable<Observable<T>> {<EOL>    let scheduler: IScheduler = async;<EOL>    let windowCreationInterval: number = null;<EOL>    let maxWindowSize: number = Number.POSITIVE_INFINITY;<EOL>    if (isScheduler(arguments[<NUM_LIT>])) {<EOL>        scheduler = arguments[<NUM_LIT>];<EOL>    }<EOL>    if (isScheduler(arguments[<NUM_LIT>])) {<EOL>        scheduler = arguments[<NUM_LIT>];<EOL>    }<EOL>    else if (isNumeric(arguments[<NUM_LIT>])) {<EOL>        maxWindowSize = arguments[","gt":"<NUM_LIT>];"}
{"input":"<s> /**<EOL> * Parses the output of the \"git status\" command<EOL> */<EOL>export function parseGitStatus(output: string, packagePath: string): Map<string, GitStatusChangeType> {<EOL>    const changes: Map<string, GitStatusChangeType> = new Map<string, GitStatusChangeType>();<EOL>    <EOL>    <EOL>    <EOL>    if (!output) {<EOL>        return","gt":"changes;"}
{"input":"<s> /**<EOL> * Parses the output of the \"git status\" command<EOL> */<EOL>export function parseGitStatus(output: string, packagePath: string): Map<string, GitStatusChangeType> {<EOL>    const changes: Map<string, GitStatusChangeType> = new Map<string, GitStatusChangeType>();<EOL>    <EOL>    <EOL>    <EOL>    if (!output) {<EOL>        return changes;<EOL>    }<EOL>    <EOL>    output<EOL>        .trim()<EOL>        .split(","gt":"'<STR_LIT>')"}
{"input":"<s> /**<EOL> * Parses the output of the \"git status\" command<EOL> */<EOL>export function parseGitStatus(output: string, packagePath: string): Map<string, GitStatusChangeType> {<EOL>    const changes: Map<string, GitStatusChangeType> = new Map<string, GitStatusChangeType>();<EOL>    <EOL>    <EOL>    <EOL>    if (!output) {<EOL>        return changes;<EOL>    }<EOL>    <EOL>    output<EOL>        .trim()<EOL>        .split('<STR_LIT>')<EOL>        .forEach(line => {<EOL>        const [changeType, filename]: string[] = line.trim().split('<STR_LIT>');<EOL>        <EOL>        if (changeType &&","gt":"filename) {"}
{"input":"<s> /**<EOL> * Find all nodes from the AST in the subtree of node of SyntaxKind kind.<EOL> * @param node<EOL> * @param kind<EOL> * @param max The maximum number of items to return.<EOL> * @return all nodes of kind, or [] if none is found<EOL> */<EOL>export function findNodes(node: ts.Node, kind: ts.SyntaxKind, max = Infinity): ts.Node[] {<EOL>    if (!node || max == <NUM_LIT>) {<EOL>        return [];<EOL>    }<EOL>    const arr: ts.Node[] = [];<EOL>    if (node.kind ===","gt":"kind) {"}
{"input":"<s> /**<EOL> * Find all nodes from the AST in the subtree of node of SyntaxKind kind.<EOL> * @param node<EOL> * @param kind<EOL> * @param max The maximum number of items to return.<EOL> * @return all nodes of kind, or [] if none is found<EOL> */<EOL>export function findNodes(node: ts.Node, kind: ts.SyntaxKind, max = Infinity): ts.Node[] {<EOL>    if (!node || max == <NUM_LIT>) {<EOL>        return [];<EOL>    }<EOL>    const arr: ts.Node[] = [];<EOL>    if (node.kind === kind) {<EOL>        arr.push(node);<EOL>","gt":"max--;"}
{"input":"<s> /**<EOL> * Find all nodes from the AST in the subtree of node of SyntaxKind kind.<EOL> * @param node<EOL> * @param kind<EOL> * @param max The maximum number of items to return.<EOL> * @return all nodes of kind, or [] if none is found<EOL> */<EOL>export function findNodes(node: ts.Node, kind: ts.SyntaxKind, max = Infinity): ts.Node[] {<EOL>    if (!node || max == <NUM_LIT>) {<EOL>        return [];<EOL>    }<EOL>    const arr: ts.Node[] = [];<EOL>    if (node.kind === kind) {<EOL>        arr.push(node);<EOL>        max--;<EOL>    }<EOL>    if (max > <NUM_LIT>) {<EOL>        for (const child of node.getChildren()) {<EOL>            findNodes(child, kind, max).forEach(node => {<EOL>                if (","gt":"max > <NUM_LIT>) {"}
{"input":"<s> /**<EOL> * Find all nodes from the AST in the subtree of node of SyntaxKind kind.<EOL> * @param node<EOL> * @param kind<EOL> * @param max The maximum number of items to return.<EOL> * @return all nodes of kind, or [] if none is found<EOL> */<EOL>export function findNodes(node: ts.Node, kind: ts.SyntaxKind, max = Infinity): ts.Node[] {<EOL>    if (!node || max == <NUM_LIT>) {<EOL>        return [];<EOL>    }<EOL>    const arr: ts.Node[] = [];<EOL>    if (node.kind === kind) {<EOL>        arr.push(node);<EOL>        max--;<EOL>    }<EOL>    if (max > <NUM_LIT>) {<EOL>        for (const child of node.getChildren()) {<EOL>            findNodes(child, kind, max).forEach(node => {<EOL>                if (max > <NUM_LIT>) {<EOL>                    arr.push(node);<EOL>                }<EOL>                max--;<EOL>            });<EOL>","gt":"if (max <= <NUM_LIT>) {"}
{"input":"<s> export function generateMockBook(): Book {<EOL>    return {<EOL>        id: '<STR_LIT>',<EOL>        volumeInfo: {<EOL>            title: '<STR_LIT>',<EOL>            subtitle: '<STR_LIT>',<EOL>            authors: [","gt":"'<STR_LIT>'],"}
{"input":"<s> export function generateMockBook(): Book {<EOL>    return {<EOL>        id: '<STR_LIT>',<EOL>        volumeInfo: {<EOL>            title: '<STR_LIT>',<EOL>            subtitle: '<STR_LIT>',<EOL>            authors: ['<STR_LIT>'],<EOL>            publisher: '<STR_LIT>',<EOL>            publishDate: '<STR_LIT>',<EOL>            description: '<STR_LIT>',<EOL>            averageRating:","gt":"<NUM_LIT>,"}
{"input":"<s> export function generateMockBook(): Book {<EOL>    return {<EOL>        id: '<STR_LIT>',<EOL>        volumeInfo: {<EOL>            title: '<STR_LIT>',<EOL>            subtitle: '<STR_LIT>',<EOL>            authors: ['<STR_LIT>'],<EOL>            publisher: '<STR_LIT>',<EOL>            publishDate: '<STR_LIT>',<EOL>            description: '<STR_LIT>',<EOL>            averageRating: <NUM_LIT>,<EOL>            ratingsCount: <NUM_LIT>,<EOL>            imageLinks: {<EOL>                thumbnail:","gt":"'<STR_LIT>',"}
{"input":"<s> function pipeStdOut(d: any) {<EOL>    process.stdout.","gt":"write(d);"}
{"input":"<s> /**<EOL> * Emits a value from the source Observable only after a particular time span<EOL> * has passed without another source emission.<EOL> *<EOL> * <span class=\"informal\">It's like {@link delay}, but passes only the most<EOL> * recent value from each burst of emissions.</span><EOL> *<EOL> * <img src=\"./img/debounceTime.png\" width=\"100%\"><EOL> *<EOL> * `debounceTime` delays values emitted by the source Observable, but drops<EOL> * previous pending delayed emissions if a new value arrives on the source<EOL> * Observable. This operator keeps track of the most recent value from the<EOL> * source Observable, and emits that only when `dueTime` enough time has passed<EOL> * without any other value appearing on the source Observable. If a new value<EOL> * appears before `dueTime` silence occurs, the previous value will be dropped<EOL> * and will not be emitted on the output Observable.<EOL> *<EOL> * This is a rate-limiting operator, because it is impossible for more than one<EOL> * value to be emitted in any time window of duration `dueTime`, but it is also<EOL> * a delay-like operator since output emissions do not occur at the same time as<EOL> * they did on the source Observable. Optionally takes a {@link IScheduler} for<EOL> * managing timers.<EOL> *<EOL> * @example <caption>Emit the most recent click after a burst of clicks</caption><EOL> * var clicks = Rx.Observable.fromEvent(document, 'click');<EOL> * var result = clicks.debounceTime(1000);<EOL> * result.subscribe(x => console.log(x));<EOL> *<EOL> * @see {@link auditTime}<EOL> * @see {@link debounce}<EOL> * @see {@link delay}<EOL> * @see {@link sampleTime}<EOL> * @see {@link throttleTime}<EOL> *<EOL> * @param {number} dueTime The timeout duration in milliseconds (or the time<EOL> * unit determined internally by the optional `scheduler`) for the window of<EOL> * time required to wait for emission silence before emitting the most recent<EOL> * source value.<EOL> * @param {Scheduler} [scheduler=async] The {@link IScheduler} to use for<EOL> * managing the timers that handle the timeout for each value.<EOL> * @return {Observable} An Observable that delays the emissions of the source<EOL> * Observable by the specified `dueTime`, and may drop some values if they occur<EOL> * too frequently.<EOL> * @method debounceTime<EOL> * @owner Observable<EOL> */<EOL>export function debounceTime<T>(this: Observable<T>, dueTime: number, scheduler: IScheduler = async): Observable<T> {<EOL>","gt":"return higherOrder(dueTime, scheduler)(this) as Observable<T>;"}
{"input":"<s> function convertSeverity(severity: number): DiagnosticSeverity {<EOL>    switch (severity) {<EOL>        <EOL>","gt":"case <NUM_LIT>:"}
{"input":"<s> /**<EOL> * Returns an Observable that mirrors the source Observable with the exception of an `error`. If the source Observable<EOL> * calls `error`, this method will resubscribe to the source Observable for a maximum of `count` resubscriptions (given<EOL> * as a number parameter) rather than propagating the `error` call.<EOL> *<EOL> * <img src=\"./img/retry.png\" width=\"100%\"><EOL> *<EOL> * Any and all items emitted by the source Observable will be emitted by the resulting Observable, even those emitted<EOL> * during failed subscriptions. For example, if an Observable fails at first but emits [1, 2] then succeeds the second<EOL> * time and emits: [1, 2, 3, 4, 5] then the complete stream of emissions and notifications<EOL> * would be: [1, 2, 1, 2, 3, 4, 5, `complete`].<EOL> * @param {number} count - Number of retry attempts before failing.<EOL> * @return {Observable} The source Observable modified with the retry logic.<EOL> * @method retry<EOL> * @owner Observable<EOL> */<EOL>export function retry<T>(count: number = -<NUM_LIT>): MonoTypeOperatorFunction<T> {<EOL>    return (source: Observable<T>) => source.lift(new RetryOperator(count,","gt":"source));"}
{"input":"<s> async function runTask(name: string, taskFn: () => Promise<any>) {<EOL>    const spinner = ora(name);<EOL>    try {<EOL>        spinner.start();<EOL>","gt":"await taskFn();"}
{"input":"<s> async function runTask(name: string, taskFn: () => Promise<any>) {<EOL>    const spinner = ora(name);<EOL>    try {<EOL>        spinner.start();<EOL>        await taskFn();<EOL>        spinner.succeed();<EOL>    }<EOL>    catch (e) {<EOL>        spinner.","gt":"fail();"}
{"input":"<s> function stripLowLevelDomains(domain: string): string {<EOL>    let","gt":"match = domain.match(SecondLevelDomainMatcher);"}
{"input":"<s> function configurationEntries(extensionGalleryService: IExtensionGalleryService, viewletService: IViewletService, query: string, label: string): IPickOpenEntry[] {<EOL>    if (extensionGalleryService.isEnabled()) {<EOL>        return [{<EOL>                id: void <NUM_LIT>,<EOL>                label:","gt":"label,"}
{"input":"<s> export function applyOperators(input$: Observable<any>, operators: any[][]): Observable<any> {<EOL>    return","gt":"operators.reduce((source$, [operator, ...args]) => {"}
{"input":"<s> function _throttle<T>(fn: Function, key: string): Function {<EOL>    const currentKey = `<STR_LIT>`;<EOL>    const nextKey = `<STR_LIT>`;<EOL>    const trigger = function (this: any, ...args: any[]) {<EOL>        if (this[nextKey]) {<EOL>            return this[nextKey];<EOL>        }<EOL>        if (this[currentKey]) {<EOL>            this[nextKey] = done(this[currentKey]).then(() => {<EOL>                this[nextKey] = undefined;<EOL>                return trigger.apply(this, args);<EOL>            });<EOL>            return this[nextKey];<EOL>        }<EOL>        this[currentKey] = fn.apply(this, args) as Promise<T>;<EOL>        const clear = () => this[currentKey] =","gt":"undefined;"}
{"input":"<s> <EOL>/**<EOL> * Projects each source value to an Observable which is merged in the output<EOL> * Observable, in a serialized fashion waiting for each one to complete before<EOL> * merging the next.<EOL> *<EOL> * <span class=\"informal\">Maps each value to an Observable, then flattens all of<EOL> * these inner Observables using {@link concatAll}.</span><EOL> *<EOL> * <img src=\"./img/concatMap.png\" width=\"100%\"><EOL> *<EOL> * Returns an Observable that emits items based on applying a function that you<EOL> * supply to each item emitted by the source Observable, where that function<EOL> * returns an (so-called \"inner\") Observable. Each new inner Observable is<EOL> * concatenated with the previous inner Observable.<EOL> *<EOL> * __Warning:__ if source values arrive endlessly and faster than their<EOL> * corresponding inner Observables can complete, it will result in memory issues<EOL> * as inner Observables amass in an unbounded buffer waiting for their turn to<EOL> * be subscribed to.<EOL> *<EOL> * Note: `concatMap` is equivalent to `mergeMap` with concurrency parameter set<EOL> * to `1`.<EOL> *<EOL> * @example <caption>For each click event, tick every second from 0 to 3, with no concurrency</caption><EOL> * var clicks = Rx.Observable.fromEvent(document, 'click');<EOL> * var result = clicks.concatMap(ev => Rx.Observable.interval(1000).take(4));<EOL> * result.subscribe(x => console.log(x));<EOL> *<EOL> * // Results in the following:<EOL> * // (results are not concurrent)<EOL> * // For every click on the \"document\" it will emit values 0 to 3 spaced<EOL> * // on a 1000ms interval<EOL> * // one click = 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3<EOL> *<EOL> * @see {@link concat}<EOL> * @see {@link concatAll}<EOL> * @see {@link concatMapTo}<EOL> * @see {@link exhaustMap}<EOL> * @see {@link mergeMap}<EOL> * @see {@link switchMap}<EOL> *<EOL> * @param {function(value: T, ?index: number): ObservableInput} project A function<EOL> * that, when applied to an item emitted by the source Observable, returns an<EOL> * Observable.<EOL> * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]<EOL> * A function to produce the value on the output Observable based on the values<EOL> * and the indices of the source (outer) emission and the inner Observable<EOL> * emission. The arguments passed to this function are:<EOL> * - `outerValue`: the value that came from the source<EOL> * - `innerValue`: the value that came from the projected Observable<EOL> * - `outerIndex`: the \"index\" of the value that came from the source<EOL> * - `innerIndex`: the \"index\" of the value from the projected Observable<EOL> * @return {Observable} An Observable that emits the result of applying the<EOL> * projection function (and the optional `resultSelector`) to each item emitted<EOL> * by the source Observable and taking values from each projected inner<EOL> * Observable sequentially.<EOL> * @method concatMap<EOL> * @owner Observable<EOL> */<EOL>export function concatMap<T, I, R>(this: Observable<T>, project: (value: T, index: number) => ObservableInput<I>, resultSelector?: (outerValue: T, innerValue: I, outerIndex: number, innerIndex: number) => R) {<EOL>    return higherOrderConcatMap(","gt":"project, resultSelector)(this);"}
{"input":"<s> function recordCodeAction(document: server.TextDocument, diagnostic: server.Diagnostic, problem: tslint.RuleFailure): void {<EOL>    let documentDisableRuleFixes: Map<string, AutoFix> = codeDisableRuleActions[document.uri];<EOL>    if (!documentDisableRuleFixes) {<EOL>        documentDisableRuleFixes = Object.create(null);<EOL>        codeDisableRuleActions[document.uri] = documentDisableRuleFixes;<EOL>    }<EOL>    documentDisableRuleFixes[computeKey(diagnostic)] = createDisableRuleFix(problem, document);<EOL>    let fix: AutoFix | undefined = undefined;<EOL>    <EOL>    if (problem.getFix && problem.getFix() && !replacementsAreEmpty(problem.getFix())) { <EOL>        fix = createAutoFix(problem, document, problem.getFix()!);<EOL>    }<EOL>    if (!fix) {<EOL>        let vscFix = createVscFixForRuleFailure(problem, document);<EOL>        if (","gt":"vscFix) {"}
{"input":"<s> export function register() {<EOL>","gt":"let schemaRegistry = <IJSONContributionRegistry>Registry.as(JSONExtensions.JSONContribution);"}
{"input":"<s> /**<EOL> * Delays the emission of items from the source Observable by a given time span<EOL> * determined by the emissions of another Observable.<EOL> *<EOL> * <span class=\"informal\">It's like {@link delay}, but the time span of the<EOL> * delay duration is determined by a second Observable.</span><EOL> *<EOL> * <img src=\"./img/delayWhen.png\" width=\"100%\"><EOL> *<EOL> * `delayWhen` time shifts each emitted value from the source Observable by a<EOL> * time span determined by another Observable. When the source emits a value,<EOL> * the `delayDurationSelector` function is called with the source value as<EOL> * argument, and should return an Observable, called the \"duration\" Observable.<EOL> * The source value is emitted on the output Observable only when the duration<EOL> * Observable emits a value or completes.<EOL> *<EOL> * Optionally, `delayWhen` takes a second argument, `subscriptionDelay`, which<EOL> * is an Observable. When `subscriptionDelay` emits its first value or<EOL> * completes, the source Observable is subscribed to and starts behaving like<EOL> * described in the previous paragraph. If `subscriptionDelay` is not provided,<EOL> * `delayWhen` will subscribe to the source Observable as soon as the output<EOL> * Observable is subscribed.<EOL> *<EOL> * @example <caption>Delay each click by a random amount of time, between 0 and 5 seconds</caption><EOL> * var clicks = Rx.Observable.fromEvent(document, 'click');<EOL> * var delayedClicks = clicks.delayWhen(event =><EOL> *   Rx.Observable.interval(Math.random() * 5000)<EOL> * );<EOL> * delayedClicks.subscribe(x => console.log(x));<EOL> *<EOL> * @see {@link debounce}<EOL> * @see {@link delay}<EOL> *<EOL> * @param {function(value: T): Observable} delayDurationSelector A function that<EOL> * returns an Observable for each value emitted by the source Observable, which<EOL> * is then used to delay the emission of that item on the output Observable<EOL> * until the Observable returned from this function emits a value.<EOL> * @param {Observable} subscriptionDelay An Observable that triggers the<EOL> * subscription to the source Observable once it emits any value.<EOL> * @return {Observable} An Observable that delays the emissions of the source<EOL> * Observable by an amount of time specified by the Observable returned by<EOL> * `delayDurationSelector`.<EOL> * @method delayWhen<EOL> * @owner Observable<EOL> */<EOL>export function delayWhen<T>(this: Observable<T>, delayDurationSelector: (value: T) => Observable<any>, subscriptionDelay?: Observable<any>): Observable<T> {<EOL>    return","gt":"higherOrder(delayDurationSelector, subscriptionDelay)(this);"}
{"input":"<s> /**<EOL> * Deploy build artifacts to repos<EOL> */<EOL>export async function publishToRepo(config: Config) {<EOL>    for (let pkg of util.getTopLevelPackages(config)) {<EOL>        const SOURCE_DIR = `<STR_LIT>`;<EOL>        const","gt":"REPO_URL = `<STR_LIT>`;"}
{"input":"<s> /**<EOL> * Deploy build artifacts to repos<EOL> */<EOL>export async function publishToRepo(config: Config) {<EOL>    for (let pkg of util.getTopLevelPackages(config)) {<EOL>        const SOURCE_DIR = `<STR_LIT>`;<EOL>        const REPO_URL = `<STR_LIT>`;<EOL>        const REPO_DIR = `<STR_LIT>`;<EOL>        const SHA = await util.git([`<STR_LIT>`]);<EOL>        const SHORT_SHA = await util.git([`<STR_LIT>`]);<EOL>        const COMMITTER_USER_NAME =","gt":"await util.git(["}
{"input":"<s> /**<EOL> * Deploy build artifacts to repos<EOL> */<EOL>export async function publishToRepo(config: Config) {<EOL>    for (let pkg of util.getTopLevelPackages(config)) {<EOL>        const SOURCE_DIR = `<STR_LIT>`;<EOL>        const REPO_URL = `<STR_LIT>`;<EOL>        const REPO_DIR = `<STR_LIT>`;<EOL>        const SHA = await util.git([`<STR_LIT>`]);<EOL>        const SHORT_SHA = await util.git([`<STR_LIT>`]);<EOL>        const COMMITTER_USER_NAME = await util.git([<EOL>            `<STR_LIT>`,<EOL>        ]);<EOL>        const COMMITTER_USER_EMAIL = await util.git([<EOL>            `<STR_LIT>`,<EOL>        ]);<EOL>        await util.cmd('<STR_LIT>', [`<STR_LIT>`]);<EOL>","gt":"await util.cmd('<STR_LIT>', [`<STR_LIT>`]);"}
{"input":"<s> /**<EOL> * Deploy build artifacts to repos<EOL> */<EOL>export async function publishToRepo(config: Config) {<EOL>    for (let pkg of util.getTopLevelPackages(config)) {<EOL>        const SOURCE_DIR = `<STR_LIT>`;<EOL>        const REPO_URL = `<STR_LIT>`;<EOL>        const REPO_DIR = `<STR_LIT>`;<EOL>        const SHA = await util.git([`<STR_LIT>`]);<EOL>        const SHORT_SHA = await util.git([`<STR_LIT>`]);<EOL>        const COMMITTER_USER_NAME = await util.git([<EOL>            `<STR_LIT>`,<EOL>        ]);<EOL>        const COMMITTER_USER_EMAIL = await util.git([<EOL>            `<STR_LIT>`,<EOL>        ]);<EOL>        await util.cmd('<STR_LIT>', [`<STR_LIT>`]);<EOL>        await util.cmd('<STR_LIT>', [`<STR_LIT>`]);<EOL>        await process.chdir(`<STR_LIT>`);<EOL>        await util.git([`<STR_LIT>`]);<EOL>        await util.git([`<STR_LIT>`]);<EOL>        await","gt":"util.git(['<STR_LIT>']);"}
{"input":"<s> /**<EOL> * Deploy build artifacts to repos<EOL> */<EOL>export async function publishToRepo(config: Config) {<EOL>    for (let pkg of util.getTopLevelPackages(config)) {<EOL>        const SOURCE_DIR = `<STR_LIT>`;<EOL>        const REPO_URL = `<STR_LIT>`;<EOL>        const REPO_DIR = `<STR_LIT>`;<EOL>        const SHA = await util.git([`<STR_LIT>`]);<EOL>        const SHORT_SHA = await util.git([`<STR_LIT>`]);<EOL>        const COMMITTER_USER_NAME = await util.git([<EOL>            `<STR_LIT>`,<EOL>        ]);<EOL>        const COMMITTER_USER_EMAIL = await util.git([<EOL>            `<STR_LIT>`,<EOL>        ]);<EOL>        await util.cmd('<STR_LIT>', [`<STR_LIT>`]);<EOL>        await util.cmd('<STR_LIT>', [`<STR_LIT>`]);<EOL>        await process.chdir(`<STR_LIT>`);<EOL>        await util.git([`<STR_LIT>`]);<EOL>        await util.git([`<STR_LIT>`]);<EOL>        await util.git(['<STR_LIT>']);<EOL>        await util.git(['<STR_LIT>']);<EOL>        await util.git(['<STR_LIT>']);<EOL>        await process.chdir('<STR_LIT>');<EOL>        await util.cmd('<STR_LIT>', [`<STR_LIT>`]);<EOL>        await util.git([`<STR_LIT>`]);<EOL>        await util.cmd('<STR_LIT>', [`<STR_LIT>`]);<EOL>","gt":"await process.chdir(`<STR_LIT>`);"}
{"input":"<s> export function getFileContent(tree: Tree, path: string): string {<EOL>    const fileEntry = tree.get(path);<EOL>","gt":"if (!fileEntry) {"}
{"input":"<s> <EOL>/**<EOL> * Returns an Observable that emits the results of invoking a specified selector on items<EOL> * emitted by a ConnectableObservable that shares a single subscription to the underlying stream.<EOL> *<EOL> * <img src=\"./img/multicast.png\" width=\"100%\"><EOL> *<EOL> * @param {Function|Subject} subjectOrSubjectFactory - Factory function to create an intermediate subject through<EOL> * which the source sequence's elements will be multicast to the selector function<EOL> * or Subject to push source elements into.<EOL> * @param {Function} [selector] - Optional selector function that can use the multicasted source stream<EOL> * as many times as needed, without causing multiple subscriptions to the source stream.<EOL> * Subscribers to the given source will receive all notifications of the source from the<EOL> * time of the subscription forward.<EOL> * @return {Observable} An Observable that emits the results of invoking the selector<EOL> * on the items emitted by a `ConnectableObservable` that shares a single subscription to<EOL> * the underlying stream.<EOL> * @method multicast<EOL> * @owner Observable<EOL> */<EOL>export function multicast<T, R>(subjectOrSubjectFactory: Subject<T> | (() => Subject<T>), selector?: (source: Observable<T>) => Observable<R>): OperatorFunction<T, R> {<EOL>    return function multicastOperatorFunction(source: Observable<T>): Observable<R> {<EOL>        let subjectFactory: () => Subject<T>;<EOL>        if (typeof subjectOrSubjectFactory === '<STR_LIT>') {<EOL>            subjectFactory = <() => Subject<T>>subjectOrSubjectFactory;<EOL>        }<EOL>","gt":"else {"}
{"input":"<s> <EOL>/**<EOL> * Returns an Observable that emits the results of invoking a specified selector on items<EOL> * emitted by a ConnectableObservable that shares a single subscription to the underlying stream.<EOL> *<EOL> * <img src=\"./img/multicast.png\" width=\"100%\"><EOL> *<EOL> * @param {Function|Subject} subjectOrSubjectFactory - Factory function to create an intermediate subject through<EOL> * which the source sequence's elements will be multicast to the selector function<EOL> * or Subject to push source elements into.<EOL> * @param {Function} [selector] - Optional selector function that can use the multicasted source stream<EOL> * as many times as needed, without causing multiple subscriptions to the source stream.<EOL> * Subscribers to the given source will receive all notifications of the source from the<EOL> * time of the subscription forward.<EOL> * @return {Observable} An Observable that emits the results of invoking the selector<EOL> * on the items emitted by a `ConnectableObservable` that shares a single subscription to<EOL> * the underlying stream.<EOL> * @method multicast<EOL> * @owner Observable<EOL> */<EOL>export function multicast<T, R>(subjectOrSubjectFactory: Subject<T> | (() => Subject<T>), selector?: (source: Observable<T>) => Observable<R>): OperatorFunction<T, R> {<EOL>    return function multicastOperatorFunction(source: Observable<T>): Observable<R> {<EOL>        let subjectFactory: () => Subject<T>;<EOL>        if (typeof subjectOrSubjectFactory === '<STR_LIT>') {<EOL>            subjectFactory = <() => Subject<T>>subjectOrSubjectFactory;<EOL>        }<EOL>        else {<EOL>            subjectFactory = function subjectFactory() {<EOL>                return <Subject<T>>subjectOrSubjectFactory;<EOL>            };<EOL>        }<EOL>        if (typeof selector === '<STR_LIT>') {<EOL>            return source.lift(new MulticastOperator(subjectFactory, selector));<EOL>        }<EOL>        const connectable: any = Object.create(source,","gt":"connectableObservableDescriptor);"}
{"input":"<s> function findTsConfig(fileName: string): string | undefined {<EOL>    let dir = path.dirname(fileName);<EOL>    while (fs.existsSync(dir)) {<EOL>        const candidate = path.join(dir, '<STR_LIT>');<EOL>        if (","gt":"fs.existsSync(candidate))"}
{"input":"<s> function findTsConfig(fileName: string): string | undefined {<EOL>    let dir = path.dirname(fileName);<EOL>    while (fs.existsSync(dir)) {<EOL>        const candidate = path.join(dir, '<STR_LIT>');<EOL>        if (fs.existsSync(candidate))<EOL>            return candidate;<EOL>        const parentDir = path.dirname(dir);<EOL>        if (parentDir === dir)<EOL>","gt":"break;"}
{"input":"<s> function expectFormIsValid() {<EOL>    expect(page.form.getAttribute('<STR_LIT>')).toMatch(","gt":"'<STR_LIT>');"}
{"input":"<s> /**<EOL> * Maps each source value (an object) to its specified nested property.<EOL> *<EOL> * <span class=\"informal\">Like {@link map}, but meant only for picking one of<EOL> * the nested properties of every emitted object.</span><EOL> *<EOL> * <img src=\"./img/pluck.png\" width=\"100%\"><EOL> *<EOL> * Given a list of strings describing a path to an object property, retrieves<EOL> * the value of a specified nested property from all values in the source<EOL> * Observable. If a property can't be resolved, it will return `undefined` for<EOL> * that value.<EOL> *<EOL> * @example <caption>Map every click to the tagName of the clicked target element</caption><EOL> * var clicks = Rx.Observable.fromEvent(document, 'click');<EOL> * var tagNames = clicks.pluck('target', 'tagName');<EOL> * tagNames.subscribe(x => console.log(x));<EOL> *<EOL> * @see {@link map}<EOL> *<EOL> * @param {...string} properties The nested properties to pluck from each source<EOL> * value (an object).<EOL> * @return {Observable} A new Observable of property values from the source values.<EOL> * @method pluck<EOL> * @owner Observable<EOL> */<EOL>export function pluck<T, R>(...properties: string[]): OperatorFunction<T, R> {<EOL>    const length = properties.length;<EOL>    if (length ===","gt":"<NUM_LIT>) {"}
{"input":"<s> function _readCoverOptions(testsRoot: string): ITestRunnerOptions {<EOL>    let coverConfigPath = paths.join(testsRoot, testOptions.coverConfig);<EOL>    let coverConfig: ITestRunnerOptions = undefined;<EOL>    if (","gt":"fs.existsSync(coverConfigPath)) {"}
{"input":"<s> /**<EOL> * Emits the most recently emitted value from the source Observable within<EOL> * periodic time intervals.<EOL> *<EOL> * <span class=\"informal\">Samples the source Observable at periodic time<EOL> * intervals, emitting what it samples.</span><EOL> *<EOL> * <img src=\"./img/sampleTime.png\" width=\"100%\"><EOL> *<EOL> * `sampleTime` periodically looks at the source Observable and emits whichever<EOL> * value it has most recently emitted since the previous sampling, unless the<EOL> * source has not emitted anything since the previous sampling. The sampling<EOL> * happens periodically in time every `period` milliseconds (or the time unit<EOL> * defined by the optional `scheduler` argument). The sampling starts as soon as<EOL> * the output Observable is subscribed.<EOL> *<EOL> * @example <caption>Every second, emit the most recent click at most once</caption><EOL> * var clicks = Rx.Observable.fromEvent(document, 'click');<EOL> * var result = clicks.sampleTime(1000);<EOL> * result.subscribe(x => console.log(x));<EOL> *<EOL> * @see {@link auditTime}<EOL> * @see {@link debounceTime}<EOL> * @see {@link delay}<EOL> * @see {@link sample}<EOL> * @see {@link throttleTime}<EOL> *<EOL> * @param {number} period The sampling period expressed in milliseconds or the<EOL> * time unit determined internally by the optional `scheduler`.<EOL> * @param {Scheduler} [scheduler=async] The {@link IScheduler} to use for<EOL> * managing the timers that handle the sampling.<EOL> * @return {Observable<T>} An Observable that emits the results of sampling the<EOL> * values emitted by the source Observable at the specified time interval.<EOL> * @method sampleTime<EOL> * @owner Observable<EOL> */<EOL>export function sampleTime<T>(period: number, scheduler: IScheduler = async): MonoTypeOperatorFunction<T> {<EOL>    return (source: Observable<T>) =>","gt":"source.lift(new SampleTimeOperator(period, scheduler));"}
{"input":"<s> export function detectFileEncoding(fileName: string, buffer: Buffer) {<EOL>    if (buffer.length < <NUM_LIT>) {<EOL>        throw Error(tl.loc(","gt":"'<STR_LIT>', fileName));"}
{"input":"<s> function getDeps(pkg: any): any {<EOL>    const","gt":"packageJson = require(pkg.packageJson);"}
{"input":"<s> /**<EOL> * Finds the index of the first value in an array that matches the specified predicate.<EOL> *<EOL> * @export<EOL> * @template T<EOL> * @param {(x: T) => boolean} predicate<EOL> * @param {T[]} xs<EOL> * @returns {number}<EOL> */<EOL>export function findIndex<T>(predicate: (x: T) => boolean, xs: T[]): number {<EOL>    if (!Array.isArray(xs)) {<EOL>        throw new Error(`<STR_LIT>`);<EOL>    }<EOL>","gt":"let index;"}
{"input":"<s> /**<EOL> * Generates random text array with custom length.<EOL> */<EOL>export function generateRandomText(length: number): string {<EOL>    let text = \"<STR_LIT>\";<EOL>    const","gt":"characters = \"<STR_LIT>\";"}
{"input":"<s> function getSortData(model: editorCommon.ITextModel, selection: Selection, descending: boolean) {<EOL>    let startLineNumber = selection.startLineNumber;<EOL>    let endLineNumber = selection.endLineNumber;<EOL>    if (selection.endColumn === <NUM_LIT>) {<EOL>        endLineNumber--;<EOL>    }<EOL>    <EOL>    if (startLineNumber >= endLineNumber) {<EOL>        return null;<EOL>    }<EOL>    let linesToSort = [];<EOL>    <EOL>    for (","gt":"let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {"}
{"input":"<s> function getSortData(model: editorCommon.ITextModel, selection: Selection, descending: boolean) {<EOL>    let startLineNumber = selection.startLineNumber;<EOL>    let endLineNumber = selection.endLineNumber;<EOL>    if (selection.endColumn === <NUM_LIT>) {<EOL>        endLineNumber--;<EOL>    }<EOL>    <EOL>    if (startLineNumber >= endLineNumber) {<EOL>        return null;<EOL>    }<EOL>    let linesToSort = [];<EOL>    <EOL>    for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {<EOL>        linesToSort.push(model.getLineContent(lineNumber));<EOL>    }<EOL>    let sorted =","gt":"linesToSort.slice(<NUM_LIT>);"}
{"input":"<s> export function f1() {<EOL>    return","gt":"instance1;"}
{"input":"<s> function defaults(opts) {<EOL>    opts = opts || { proto: '<STR_LIT>', addr: <NUM_LIT> };<EOL>    if (typeof opts === '<STR_LIT>') {<EOL>        opts = { proto: '<STR_LIT>', addr: <NUM_LIT> };<EOL>    }<EOL>    if (typeof opts !== '<STR_LIT>') {<EOL>        opts = { proto: '<STR_LIT>', addr: opts };<EOL>    }<EOL>    if (!opts.proto) {<EOL>        opts.proto = '<STR_LIT>';<EOL>    }<EOL>    if (!opts.","gt":"addr) {"}
{"input":"<s> function getSourceFile(out: string, inputFiles: {<EOL>    [file: string]: string;<EOL>}, moduleId: string): ts.SourceFile {<EOL>    if (!SOURCE_FILE_MAP[moduleId]) {<EOL>        let filePath = path.normalize(moduleIdToPath(out, moduleId));<EOL>        if (!inputFiles.hasOwnProperty(filePath)) {<EOL>            logErr('<STR_LIT>' +","gt":"filePath + '<STR_LIT>');"}
{"input":"<s> function getSourceFile(out: string, inputFiles: {<EOL>    [file: string]: string;<EOL>}, moduleId: string): ts.SourceFile {<EOL>    if (!SOURCE_FILE_MAP[moduleId]) {<EOL>        let filePath = path.normalize(moduleIdToPath(out, moduleId));<EOL>        if (!inputFiles.hasOwnProperty(filePath)) {<EOL>            logErr('<STR_LIT>' + filePath + '<STR_LIT>');<EOL>            return null;<EOL>        }<EOL>        let fileContents = inputFiles[filePath];<EOL>        let sourceFile = ts.createSourceFile(filePath, fileContents, ts.ScriptTarget.ES5);<EOL>        SOURCE_FILE_MAP[moduleId] =","gt":"sourceFile;"}
{"input":"<s> /**<EOL> * JoinColumn decorator used on one-to-one relations to specify owner side of relationship.<EOL> * It also can be used on both one-to-one and many-to-one relations to specify custom column name<EOL> * or custom referenced column.<EOL> */<EOL>export function JoinColumn(optionsOrOptionsArray?: JoinColumnOptions | JoinColumnOptions[]): Function {<EOL>    return function (object: Object, propertyName: string) {<EOL>        const options = optionsOrOptionsArray instanceof Array ? optionsOrOptionsArray : [optionsOrOptionsArray || {}];<EOL>        options.forEach(options => {<EOL>            const args:","gt":"JoinColumnMetadataArgs = {"}
{"input":"<s> /**<EOL> * JoinColumn decorator used on one-to-one relations to specify owner side of relationship.<EOL> * It also can be used on both one-to-one and many-to-one relations to specify custom column name<EOL> * or custom referenced column.<EOL> */<EOL>export function JoinColumn(optionsOrOptionsArray?: JoinColumnOptions | JoinColumnOptions[]): Function {<EOL>    return function (object: Object, propertyName: string) {<EOL>        const options = optionsOrOptionsArray instanceof Array ? optionsOrOptionsArray : [optionsOrOptionsArray || {}];<EOL>        options.forEach(options => {<EOL>            const args: JoinColumnMetadataArgs = {<EOL>                target: object.constructor,<EOL>                propertyName: propertyName,<EOL>                name: options.name,<EOL>                referencedColumnName: options.referencedColumnName<EOL>            };<EOL>            getMetadataArgsStorage().","gt":"joinColumns.push(args);"}
{"input":"<s> /**<EOL> * Classes decorated with this decorator will listen to ORM events and their methods will be triggered when event<EOL> * occurs. Those classes must implement EventSubscriberInterface interface.<EOL> */<EOL>export function EventSubscriber() {<EOL>    return function (target: Function) {<EOL>        const args:","gt":"EntitySubscriberMetadataArgs = {"}
{"input":"<s> function updateConfiguration(settings: Settings) {<EOL>    for (let languageId in languageServices) {<EOL>        languageServices[languageId].configure((settings as any)[languageId]);<EOL>    }<EOL>    <EOL>    documentSettings = {};<EOL>    <EOL>    documents.all().forEach(triggerValidation);<EOL>    emmetSettings = settings.emmet;<EOL>    if (currentEmmetExtensionsPath !== emmetSettings['<STR_LIT>']) {<EOL>        currentEmmetExtensionsPath =","gt":"emmetSettings['<STR_LIT>'];"}
{"input":"<s> /**<EOL> * Determine if the validated, flex-direction value specifies<EOL> * a horizontal/row flow.<EOL> */<EOL>export function isFlowHorizontal(value: string): boolean {<EOL>    let [flow,] = validateValue(","gt":"value);"}
{"input":"<s> /**<EOL> * Converts string into snake-case.<EOL> *<EOL> * @see http://stackoverflow.com/questions/30521224/javascript-convert-pascalcase-to-underscore-case<EOL> */<EOL>export function snakeCase(str: string) {<EOL>    return str.replace(","gt":"/(?:^|\\.?)([A-Z])/g, (x, y) => \"<STR_LIT>\" + y.toLowerCase()).replace(/^_/, \"<STR_LIT>\");"}
{"input":"<s> /**<EOL> * Calls a method on which this decorator is applied after this entity removal.<EOL> */<EOL>export function AfterRemove() {<EOL>    return function (object: Object, propertyName: string) {<EOL>        const args: EntityListenerMetadataArgs = {<EOL>            target: object.","gt":"constructor,"}
{"input":"<s> function rootDirRequire(moduleId: string) {<EOL>","gt":"return require(path.join(rootDir, moduleId));"}
{"input":"<s> <EOL>function isZip(file) {<EOL>    return file.endsWith('<STR_LIT>')<EOL>        ||","gt":"file.endsWith('<STR_LIT>')"}
{"input":"<s> /**<EOL> * The path of a diagnostic must be absolute.<EOL> * The function prepends the path of the project to the path of the diagnostic.<EOL> * @param diagnosticPath The path of the diagnostic<EOL> * @param projectPath The path of the project<EOL> */<EOL>export function normalizeDiagnosticPath(diagnosticPath: string, projectPath: string): string {<EOL>    if (isAbsolute(diagnosticPath)) {<EOL>        return","gt":"diagnosticPath;"}
{"input":"<s> /**<EOL> * Asks the user if the dialog has been dismissed intentionally<EOL> * @return The flag indicating if the dialog has been dismissed intentionally<EOL> */<EOL>async function askUserToConfirmCancellation(): Promise<boolean> {<EOL>","gt":"return await askUserToAnswerYesOrNo('<STR_LIT>');"}
{"input":"<s> function getStats(): Map<LoaderEventType, Tick[]> {<EOL>    const stats = require.getStats().slice(<NUM_LIT>).sort((a: ILoaderEvent, b: ILoaderEvent) => {<EOL>        if (a.detail < b.detail) {<EOL>            return -<NUM_LIT>;<EOL>        }<EOL>        else if (a.detail >","gt":"b.detail) {"}
{"input":"<s> function getStats(): Map<LoaderEventType, Tick[]> {<EOL>    const stats = require.getStats().slice(<NUM_LIT>).sort((a: ILoaderEvent, b: ILoaderEvent) => {<EOL>        if (a.detail < b.detail) {<EOL>            return -<NUM_LIT>;<EOL>        }<EOL>        else if (a.detail > b.detail) {<EOL>            return <NUM_LIT>;<EOL>        }<EOL>        else if (a.type < b.type) {<EOL>            return -<NUM_LIT>;<EOL>        }<EOL>        else if (a.type > b.type) {<EOL>","gt":"return <NUM_LIT>;"}
{"input":"<s> function getStats(): Map<LoaderEventType, Tick[]> {<EOL>    const stats = require.getStats().slice(<NUM_LIT>).sort((a: ILoaderEvent, b: ILoaderEvent) => {<EOL>        if (a.detail < b.detail) {<EOL>            return -<NUM_LIT>;<EOL>        }<EOL>        else if (a.detail > b.detail) {<EOL>            return <NUM_LIT>;<EOL>        }<EOL>        else if (a.type < b.type) {<EOL>            return -<NUM_LIT>;<EOL>        }<EOL>        else if (a.type > b.type) {<EOL>            return <NUM_LIT>;<EOL>        }<EOL>        else {<EOL>            return <NUM_LIT>;<EOL>        }<EOL>    });<EOL>    const ticks = new Map<LoaderEventType, Tick[]>();<EOL>    ticks.set(LoaderEventType.BeginLoadingScript, []);<EOL>    ticks.set(LoaderEventType.","gt":"BeginInvokeFactory, []);"}
{"input":"<s> function getUserConfiguration(): any {<EOL>    const configuration = Configuration.getConfiguration();<EOL>    if (!configuration) {<EOL>        return","gt":"undefined;"}
{"input":"<s> function addToHeroName(text: string): promise.Promise<void> {<EOL>    let input =","gt":"element(by.css('<STR_LIT>'));"}
{"input":"<s> /**<EOL> * Recursively get versions of packages to update to, along with peer dependencies. Only recurse<EOL> * peer dependencies and only update versions of packages that are in the original package.json.<EOL> * @param {JsonObject} packageJson The original package.json to update.<EOL> * @param {{[p: string]: string}} packages<EOL> * @param {{[p: string]: string}} allVersions<EOL> * @param {LoggerApi} logger<EOL> * @param {boolean} loose<EOL> * @returns {Observable<void>}<EOL> * @private<EOL> */<EOL>function _getRecursiveVersions(packageJson: JsonObject, packages: {<EOL>    [name: string]: string;<EOL>}, allVersions: {<EOL>    [name: string]: string;<EOL>}, logger: logging.LoggerApi, loose: boolean): Observable<void> {<EOL>    return observableFrom(kPackageJsonDependencyFields).pipe(mergeMap(field => {<EOL>        const deps = packageJson[field] as JsonObject;<EOL>","gt":"if (deps) {"}
{"input":"<s> /**<EOL> * Recursively get versions of packages to update to, along with peer dependencies. Only recurse<EOL> * peer dependencies and only update versions of packages that are in the original package.json.<EOL> * @param {JsonObject} packageJson The original package.json to update.<EOL> * @param {{[p: string]: string}} packages<EOL> * @param {{[p: string]: string}} allVersions<EOL> * @param {LoggerApi} logger<EOL> * @param {boolean} loose<EOL> * @returns {Observable<void>}<EOL> * @private<EOL> */<EOL>function _getRecursiveVersions(packageJson: JsonObject, packages: {<EOL>    [name: string]: string;<EOL>}, allVersions: {<EOL>    [name: string]: string;<EOL>}, logger: logging.LoggerApi, loose: boolean): Observable<void> {<EOL>    return observableFrom(kPackageJsonDependencyFields).pipe(mergeMap(field => {<EOL>        const deps = packageJson[field] as JsonObject;<EOL>        if (deps) {<EOL>            return observableFrom(Object.keys(deps)<EOL>                .","gt":"map(depName => depName in deps ? [depName, deps[depName]] : null)"}
{"input":"<s> /**<EOL> * Recursively get versions of packages to update to, along with peer dependencies. Only recurse<EOL> * peer dependencies and only update versions of packages that are in the original package.json.<EOL> * @param {JsonObject} packageJson The original package.json to update.<EOL> * @param {{[p: string]: string}} packages<EOL> * @param {{[p: string]: string}} allVersions<EOL> * @param {LoggerApi} logger<EOL> * @param {boolean} loose<EOL> * @returns {Observable<void>}<EOL> * @private<EOL> */<EOL>function _getRecursiveVersions(packageJson: JsonObject, packages: {<EOL>    [name: string]: string;<EOL>}, allVersions: {<EOL>    [name: string]: string;<EOL>}, logger: logging.LoggerApi, loose: boolean): Observable<void> {<EOL>    return observableFrom(kPackageJsonDependencyFields).pipe(mergeMap(field => {<EOL>        const deps = packageJson[field] as JsonObject;<EOL>        if (deps) {<EOL>            return observableFrom(Object.keys(deps)<EOL>                .map(depName => depName in deps ? [depName, deps[depName]] : null)<EOL>                .filter(x => !!x));<EOL>        }<EOL>        else {<EOL>            return empty();<EOL>        }<EOL>    }), mergeMap(([","gt":"depName, depVersion]: ["}
{"input":"<s> /**<EOL> * Recursively get versions of packages to update to, along with peer dependencies. Only recurse<EOL> * peer dependencies and only update versions of packages that are in the original package.json.<EOL> * @param {JsonObject} packageJson The original package.json to update.<EOL> * @param {{[p: string]: string}} packages<EOL> * @param {{[p: string]: string}} allVersions<EOL> * @param {LoggerApi} logger<EOL> * @param {boolean} loose<EOL> * @returns {Observable<void>}<EOL> * @private<EOL> */<EOL>function _getRecursiveVersions(packageJson: JsonObject, packages: {<EOL>    [name: string]: string;<EOL>}, allVersions: {<EOL>    [name: string]: string;<EOL>}, logger: logging.LoggerApi, loose: boolean): Observable<void> {<EOL>    return observableFrom(kPackageJsonDependencyFields).pipe(mergeMap(field => {<EOL>        const deps = packageJson[field] as JsonObject;<EOL>        if (deps) {<EOL>            return observableFrom(Object.keys(deps)<EOL>                .map(depName => depName in deps ? [depName, deps[depName]] : null)<EOL>                .filter(x => !!x));<EOL>        }<EOL>        else {<EOL>            return empty();<EOL>        }<EOL>    }), mergeMap(([depName, depVersion]: [<EOL>        string,<EOL>        string<EOL>    ]) => {<EOL>        if (!packages[depName] || packages[depName] === depVersion) {<EOL>            return empty();<EOL>        }<EOL>        if (allVersions[depName] && semver.intersects(allVersions[depName],","gt":"depVersion)) {"}
{"input":"<s> /**<EOL> * Recursively get versions of packages to update to, along with peer dependencies. Only recurse<EOL> * peer dependencies and only update versions of packages that are in the original package.json.<EOL> * @param {JsonObject} packageJson The original package.json to update.<EOL> * @param {{[p: string]: string}} packages<EOL> * @param {{[p: string]: string}} allVersions<EOL> * @param {LoggerApi} logger<EOL> * @param {boolean} loose<EOL> * @returns {Observable<void>}<EOL> * @private<EOL> */<EOL>function _getRecursiveVersions(packageJson: JsonObject, packages: {<EOL>    [name: string]: string;<EOL>}, allVersions: {<EOL>    [name: string]: string;<EOL>}, logger: logging.LoggerApi, loose: boolean): Observable<void> {<EOL>    return observableFrom(kPackageJsonDependencyFields).pipe(mergeMap(field => {<EOL>        const deps = packageJson[field] as JsonObject;<EOL>        if (deps) {<EOL>            return observableFrom(Object.keys(deps)<EOL>                .map(depName => depName in deps ? [depName, deps[depName]] : null)<EOL>                .filter(x => !!x));<EOL>        }<EOL>        else {<EOL>            return empty();<EOL>        }<EOL>    }), mergeMap(([depName, depVersion]: [<EOL>        string,<EOL>        string<EOL>    ]) => {<EOL>        if (!packages[depName] || packages[depName] === depVersion) {<EOL>            return empty();<EOL>        }<EOL>        if (allVersions[depName] && semver.intersects(allVersions[depName], depVersion)) {<EOL>            allVersions[depName] = semverIntersect.intersect(allVersions[depName], depVersion);<EOL>            return empty();<EOL>        }<EOL>        return _getNpmPackageJson(depName, logger).pipe(map(json => [packages[depName], depName, depVersion, json]));<EOL>    }), mergeMap(([","gt":"version, depName, depVersion, npmPackageJson]) => {"}
{"input":"<s> /**<EOL> * Recursively get versions of packages to update to, along with peer dependencies. Only recurse<EOL> * peer dependencies and only update versions of packages that are in the original package.json.<EOL> * @param {JsonObject} packageJson The original package.json to update.<EOL> * @param {{[p: string]: string}} packages<EOL> * @param {{[p: string]: string}} allVersions<EOL> * @param {LoggerApi} logger<EOL> * @param {boolean} loose<EOL> * @returns {Observable<void>}<EOL> * @private<EOL> */<EOL>function _getRecursiveVersions(packageJson: JsonObject, packages: {<EOL>    [name: string]: string;<EOL>}, allVersions: {<EOL>    [name: string]: string;<EOL>}, logger: logging.LoggerApi, loose: boolean): Observable<void> {<EOL>    return observableFrom(kPackageJsonDependencyFields).pipe(mergeMap(field => {<EOL>        const deps = packageJson[field] as JsonObject;<EOL>        if (deps) {<EOL>            return observableFrom(Object.keys(deps)<EOL>                .map(depName => depName in deps ? [depName, deps[depName]] : null)<EOL>                .filter(x => !!x));<EOL>        }<EOL>        else {<EOL>            return empty();<EOL>        }<EOL>    }), mergeMap(([depName, depVersion]: [<EOL>        string,<EOL>        string<EOL>    ]) => {<EOL>        if (!packages[depName] || packages[depName] === depVersion) {<EOL>            return empty();<EOL>        }<EOL>        if (allVersions[depName] && semver.intersects(allVersions[depName], depVersion)) {<EOL>            allVersions[depName] = semverIntersect.intersect(allVersions[depName], depVersion);<EOL>            return empty();<EOL>        }<EOL>        return _getNpmPackageJson(depName, logger).pipe(map(json => [packages[depName], depName, depVersion, json]));<EOL>    }), mergeMap(([version, depName, depVersion, npmPackageJson]) => {<EOL>        const updateVersion = _getVersionFromNpmPackage(npmPackageJson, version, loose);<EOL>        const npmPackageVersions = Object.keys(npmPackageJson['<STR_LIT>'] as JsonObject);<EOL>        const match = semver.maxSatisfying(npmPackageVersions, updateVersion);<EOL>        if (!match) {<EOL>            return empty();<EOL>        }<EOL>        if (semver.lt(semverIntersect.parseRange(updateVersion).","gt":"version, semverIntersect.parseRange(depVersion).version)) {"}
{"input":"<s> /**<EOL> * Recursively get versions of packages to update to, along with peer dependencies. Only recurse<EOL> * peer dependencies and only update versions of packages that are in the original package.json.<EOL> * @param {JsonObject} packageJson The original package.json to update.<EOL> * @param {{[p: string]: string}} packages<EOL> * @param {{[p: string]: string}} allVersions<EOL> * @param {LoggerApi} logger<EOL> * @param {boolean} loose<EOL> * @returns {Observable<void>}<EOL> * @private<EOL> */<EOL>function _getRecursiveVersions(packageJson: JsonObject, packages: {<EOL>    [name: string]: string;<EOL>}, allVersions: {<EOL>    [name: string]: string;<EOL>}, logger: logging.LoggerApi, loose: boolean): Observable<void> {<EOL>    return observableFrom(kPackageJsonDependencyFields).pipe(mergeMap(field => {<EOL>        const deps = packageJson[field] as JsonObject;<EOL>        if (deps) {<EOL>            return observableFrom(Object.keys(deps)<EOL>                .map(depName => depName in deps ? [depName, deps[depName]] : null)<EOL>                .filter(x => !!x));<EOL>        }<EOL>        else {<EOL>            return empty();<EOL>        }<EOL>    }), mergeMap(([depName, depVersion]: [<EOL>        string,<EOL>        string<EOL>    ]) => {<EOL>        if (!packages[depName] || packages[depName] === depVersion) {<EOL>            return empty();<EOL>        }<EOL>        if (allVersions[depName] && semver.intersects(allVersions[depName], depVersion)) {<EOL>            allVersions[depName] = semverIntersect.intersect(allVersions[depName], depVersion);<EOL>            return empty();<EOL>        }<EOL>        return _getNpmPackageJson(depName, logger).pipe(map(json => [packages[depName], depName, depVersion, json]));<EOL>    }), mergeMap(([version, depName, depVersion, npmPackageJson]) => {<EOL>        const updateVersion = _getVersionFromNpmPackage(npmPackageJson, version, loose);<EOL>        const npmPackageVersions = Object.keys(npmPackageJson['<STR_LIT>'] as JsonObject);<EOL>        const match = semver.maxSatisfying(npmPackageVersions, updateVersion);<EOL>        if (!match) {<EOL>            return empty();<EOL>        }<EOL>        if (semver.lt(semverIntersect.parseRange(updateVersion).version, semverIntersect.parseRange(depVersion).version)) {<EOL>            throw new SchematicsException(`<STR_LIT>`);<EOL>        }<EOL>        const innerNpmPackageJson = (npmPackageJson['<STR_LIT>'] as JsonObject)[match] as JsonObject;<EOL>        const","gt":"dependencies: {"}
{"input":"<s> /**<EOL> * Recursively get versions of packages to update to, along with peer dependencies. Only recurse<EOL> * peer dependencies and only update versions of packages that are in the original package.json.<EOL> * @param {JsonObject} packageJson The original package.json to update.<EOL> * @param {{[p: string]: string}} packages<EOL> * @param {{[p: string]: string}} allVersions<EOL> * @param {LoggerApi} logger<EOL> * @param {boolean} loose<EOL> * @returns {Observable<void>}<EOL> * @private<EOL> */<EOL>function _getRecursiveVersions(packageJson: JsonObject, packages: {<EOL>    [name: string]: string;<EOL>}, allVersions: {<EOL>    [name: string]: string;<EOL>}, logger: logging.LoggerApi, loose: boolean): Observable<void> {<EOL>    return observableFrom(kPackageJsonDependencyFields).pipe(mergeMap(field => {<EOL>        const deps = packageJson[field] as JsonObject;<EOL>        if (deps) {<EOL>            return observableFrom(Object.keys(deps)<EOL>                .map(depName => depName in deps ? [depName, deps[depName]] : null)<EOL>                .filter(x => !!x));<EOL>        }<EOL>        else {<EOL>            return empty();<EOL>        }<EOL>    }), mergeMap(([depName, depVersion]: [<EOL>        string,<EOL>        string<EOL>    ]) => {<EOL>        if (!packages[depName] || packages[depName] === depVersion) {<EOL>            return empty();<EOL>        }<EOL>        if (allVersions[depName] && semver.intersects(allVersions[depName], depVersion)) {<EOL>            allVersions[depName] = semverIntersect.intersect(allVersions[depName], depVersion);<EOL>            return empty();<EOL>        }<EOL>        return _getNpmPackageJson(depName, logger).pipe(map(json => [packages[depName], depName, depVersion, json]));<EOL>    }), mergeMap(([version, depName, depVersion, npmPackageJson]) => {<EOL>        const updateVersion = _getVersionFromNpmPackage(npmPackageJson, version, loose);<EOL>        const npmPackageVersions = Object.keys(npmPackageJson['<STR_LIT>'] as JsonObject);<EOL>        const match = semver.maxSatisfying(npmPackageVersions, updateVersion);<EOL>        if (!match) {<EOL>            return empty();<EOL>        }<EOL>        if (semver.lt(semverIntersect.parseRange(updateVersion).version, semverIntersect.parseRange(depVersion).version)) {<EOL>            throw new SchematicsException(`<STR_LIT>`);<EOL>        }<EOL>        const innerNpmPackageJson = (npmPackageJson['<STR_LIT>'] as JsonObject)[match] as JsonObject;<EOL>        const dependencies: {<EOL>            [name: string]: string;<EOL>        } = {};<EOL>        const deps = innerNpmPackageJson['<STR_LIT>'] as JsonObject;<EOL>        if (deps) {<EOL>            for (const depName of Object.keys(deps)) {<EOL>                dependencies[depName] = deps[depName] as string;<EOL>            }<EOL>        }<EOL>        logger.debug(","gt":"stringify(depName)} to version ${updateVersion}.`<STR_LIT>;"}
{"input":"<s> /**<EOL> * Recursively get versions of packages to update to, along with peer dependencies. Only recurse<EOL> * peer dependencies and only update versions of packages that are in the original package.json.<EOL> * @param {JsonObject} packageJson The original package.json to update.<EOL> * @param {{[p: string]: string}} packages<EOL> * @param {{[p: string]: string}} allVersions<EOL> * @param {LoggerApi} logger<EOL> * @param {boolean} loose<EOL> * @returns {Observable<void>}<EOL> * @private<EOL> */<EOL>function _getRecursiveVersions(packageJson: JsonObject, packages: {<EOL>    [name: string]: string;<EOL>}, allVersions: {<EOL>    [name: string]: string;<EOL>}, logger: logging.LoggerApi, loose: boolean): Observable<void> {<EOL>    return observableFrom(kPackageJsonDependencyFields).pipe(mergeMap(field => {<EOL>        const deps = packageJson[field] as JsonObject;<EOL>        if (deps) {<EOL>            return observableFrom(Object.keys(deps)<EOL>                .map(depName => depName in deps ? [depName, deps[depName]] : null)<EOL>                .filter(x => !!x));<EOL>        }<EOL>        else {<EOL>            return empty();<EOL>        }<EOL>    }), mergeMap(([depName, depVersion]: [<EOL>        string,<EOL>        string<EOL>    ]) => {<EOL>        if (!packages[depName] || packages[depName] === depVersion) {<EOL>            return empty();<EOL>        }<EOL>        if (allVersions[depName] && semver.intersects(allVersions[depName], depVersion)) {<EOL>            allVersions[depName] = semverIntersect.intersect(allVersions[depName], depVersion);<EOL>            return empty();<EOL>        }<EOL>        return _getNpmPackageJson(depName, logger).pipe(map(json => [packages[depName], depName, depVersion, json]));<EOL>    }), mergeMap(([version, depName, depVersion, npmPackageJson]) => {<EOL>        const updateVersion = _getVersionFromNpmPackage(npmPackageJson, version, loose);<EOL>        const npmPackageVersions = Object.keys(npmPackageJson['<STR_LIT>'] as JsonObject);<EOL>        const match = semver.maxSatisfying(npmPackageVersions, updateVersion);<EOL>        if (!match) {<EOL>            return empty();<EOL>        }<EOL>        if (semver.lt(semverIntersect.parseRange(updateVersion).version, semverIntersect.parseRange(depVersion).version)) {<EOL>            throw new SchematicsException(`<STR_LIT>`);<EOL>        }<EOL>        const innerNpmPackageJson = (npmPackageJson['<STR_LIT>'] as JsonObject)[match] as JsonObject;<EOL>        const dependencies: {<EOL>            [name: string]: string;<EOL>        } = {};<EOL>        const deps = innerNpmPackageJson['<STR_LIT>'] as JsonObject;<EOL>        if (deps) {<EOL>            for (const depName of Object.keys(deps)) {<EOL>                dependencies[depName] = deps[depName] as string;<EOL>            }<EOL>        }<EOL>        logger.debug(`<STR_LIT>`);<EOL>        if (allVersions[depName]) {<EOL>            if (!semver.intersects(allVersions[depName], updateVersion)) {<EOL>                throw new SchematicsException(","gt":"'<STR_LIT>'"}
{"input":"<s> function minimalPathFilter(path: string): boolean {<EOL>    const toRemoveList: RegExp[] = [/e2e\\//, /editorconfig/, /README/, /karma.conf.js/,<EOL>        /protractor.conf.js/, /test.ts/,","gt":"/tsconfig.spec.json/,"}
{"input":"<s> function text(emphasized: string, text: string): leer.Text {<EOL>    return [<EOL>        { ...p,<EOL>            align: '<STR_LIT>',<EOL>            paragraphLeading: leading,<EOL>","gt":"spans: ["}
{"input":"<s> function updateBrowserFile<T extends Binary>(binary: T, outputDir: string) {<EOL>    let currentDownload = path.resolve(outputDir, binary.executableFilename());<EOL>    <EOL>    if ((browserFile as any)[binary.id()]) {<EOL>        let binaryPath: BinaryPath = (browserFile as any)[binary.id()];<EOL>        if (","gt":"binaryPath.last === currentDownload) {"}
{"input":"<s> function updateBrowserFile<T extends Binary>(binary: T, outputDir: string) {<EOL>    let currentDownload = path.resolve(outputDir, binary.executableFilename());<EOL>    <EOL>    if ((browserFile as any)[binary.id()]) {<EOL>        let binaryPath: BinaryPath = (browserFile as any)[binary.id()];<EOL>        if (binaryPath.last === currentDownload) {<EOL>            return;<EOL>        }<EOL>","gt":"else {"}
{"input":"<s> function updateBrowserFile<T extends Binary>(binary: T, outputDir: string) {<EOL>    let currentDownload = path.resolve(outputDir, binary.executableFilename());<EOL>    <EOL>    if ((browserFile as any)[binary.id()]) {<EOL>        let binaryPath: BinaryPath = (browserFile as any)[binary.id()];<EOL>        if (binaryPath.last === currentDownload) {<EOL>            return;<EOL>        }<EOL>        else {<EOL>            binaryPath.last = currentDownload;<EOL>            for (let bin of binaryPath.all) {<EOL>                if (bin === currentDownload) {<EOL>                    return;<EOL>                }<EOL>            }<EOL>            binaryPath.all.push(currentDownload);<EOL>        }<EOL>    }<EOL>","gt":"else {"}
{"input":"<s> export function renderToPages(doc, format: T.Format, layers: T.RenderNode[][], background?: (page: number) => T.RenderNode[][]) {<EOL>    let page_count = <NUM_LIT>;<EOL>    for (let layer of layers) {<EOL>        for (","gt":"let node of layer) {"}
{"input":"<s> export function renderToPages(doc, format: T.Format, layers: T.RenderNode[][], background?: (page: number) => T.RenderNode[][]) {<EOL>    let page_count = <NUM_LIT>;<EOL>    for (let layer of layers) {<EOL>        for (let node of layer) {<EOL>            const page = Math.floor(node.y / format.height);<EOL>            page_count = Math.max(","gt":"page_count, page);"}
{"input":"<s> export function renderToPages(doc, format: T.Format, layers: T.RenderNode[][], background?: (page: number) => T.RenderNode[][]) {<EOL>    let page_count = <NUM_LIT>;<EOL>    for (let layer of layers) {<EOL>        for (let node of layer) {<EOL>            const page = Math.floor(node.y / format.height);<EOL>            page_count = Math.max(page_count, page);<EOL>        }<EOL>    }<EOL>    const pages = Array(page_count + <NUM_LIT>).fill([]);<EOL>    if (background) {<EOL>        for (let page = <NUM_LIT>; page <= page_count; page++) {<EOL>            for (let layer of","gt":"background(page)) {"}
{"input":"<s> export function renderToPages(doc, format: T.Format, layers: T.RenderNode[][], background?: (page: number) => T.RenderNode[][]) {<EOL>    let page_count = <NUM_LIT>;<EOL>    for (let layer of layers) {<EOL>        for (let node of layer) {<EOL>            const page = Math.floor(node.y / format.height);<EOL>            page_count = Math.max(page_count, page);<EOL>        }<EOL>    }<EOL>    const pages = Array(page_count + <NUM_LIT>).fill([]);<EOL>    if (background) {<EOL>        for (let page = <NUM_LIT>; page <= page_count; page++) {<EOL>            for (let layer of background(page)) {<EOL>                for (let node of layer) {<EOL>                    pages[page].push(node);<EOL>                }<EOL>            }<EOL>        }<EOL>    }<EOL>","gt":"for (let layer of layers) {"}
{"input":"<s> export function renderToPages(doc, format: T.Format, layers: T.RenderNode[][], background?: (page: number) => T.RenderNode[][]) {<EOL>    let page_count = <NUM_LIT>;<EOL>    for (let layer of layers) {<EOL>        for (let node of layer) {<EOL>            const page = Math.floor(node.y / format.height);<EOL>            page_count = Math.max(page_count, page);<EOL>        }<EOL>    }<EOL>    const pages = Array(page_count + <NUM_LIT>).fill([]);<EOL>    if (background) {<EOL>        for (let page = <NUM_LIT>; page <= page_count; page++) {<EOL>            for (let layer of background(page)) {<EOL>                for (let node of layer) {<EOL>                    pages[page].push(node);<EOL>                }<EOL>            }<EOL>        }<EOL>    }<EOL>    for (let layer of layers) {<EOL>        for (let node of layer) {<EOL>            const page = Math.floor(node.y / format.height);<EOL>            pages[page].push(node);<EOL>        }<EOL>    }<EOL>    for (let page = <NUM_LIT>; page <= page_count; page++) {<EOL>        if (page != <NUM_LIT>) {<EOL>            doc.addPage();<EOL>        }<EOL>        for (let node of pages[page]) {<EOL>            doc.save();<EOL>            switch (","gt":"node.type) {"}
{"input":"<s> export function renderToPages(doc, format: T.Format, layers: T.RenderNode[][], background?: (page: number) => T.RenderNode[][]) {<EOL>    let page_count = <NUM_LIT>;<EOL>    for (let layer of layers) {<EOL>        for (let node of layer) {<EOL>            const page = Math.floor(node.y / format.height);<EOL>            page_count = Math.max(page_count, page);<EOL>        }<EOL>    }<EOL>    const pages = Array(page_count + <NUM_LIT>).fill([]);<EOL>    if (background) {<EOL>        for (let page = <NUM_LIT>; page <= page_count; page++) {<EOL>            for (let layer of background(page)) {<EOL>                for (let node of layer) {<EOL>                    pages[page].push(node);<EOL>                }<EOL>            }<EOL>        }<EOL>    }<EOL>    for (let layer of layers) {<EOL>        for (let node of layer) {<EOL>            const page = Math.floor(node.y / format.height);<EOL>            pages[page].push(node);<EOL>        }<EOL>    }<EOL>    for (let page = <NUM_LIT>; page <= page_count; page++) {<EOL>        if (page != <NUM_LIT>) {<EOL>            doc.addPage();<EOL>        }<EOL>        for (let node of pages[page]) {<EOL>            doc.save();<EOL>            switch (node.type) {<EOL>                case '<STR_LIT>':<EOL>                    doc.save();<EOL>                    setStyle(doc, node.span.style || {});<EOL>                    doc.font(node.span.fontFamily).fontSize(node.span.fontSize)._fragment(","gt":"node.text, node.x, node.y - page * format.height, node.span.options || {});"}
{"input":"<s> export function renderToPages(doc, format: T.Format, layers: T.RenderNode[][], background?: (page: number) => T.RenderNode[][]) {<EOL>    let page_count = <NUM_LIT>;<EOL>    for (let layer of layers) {<EOL>        for (let node of layer) {<EOL>            const page = Math.floor(node.y / format.height);<EOL>            page_count = Math.max(page_count, page);<EOL>        }<EOL>    }<EOL>    const pages = Array(page_count + <NUM_LIT>).fill([]);<EOL>    if (background) {<EOL>        for (let page = <NUM_LIT>; page <= page_count; page++) {<EOL>            for (let layer of background(page)) {<EOL>                for (let node of layer) {<EOL>                    pages[page].push(node);<EOL>                }<EOL>            }<EOL>        }<EOL>    }<EOL>    for (let layer of layers) {<EOL>        for (let node of layer) {<EOL>            const page = Math.floor(node.y / format.height);<EOL>            pages[page].push(node);<EOL>        }<EOL>    }<EOL>    for (let page = <NUM_LIT>; page <= page_count; page++) {<EOL>        if (page != <NUM_LIT>) {<EOL>            doc.addPage();<EOL>        }<EOL>        for (let node of pages[page]) {<EOL>            doc.save();<EOL>            switch (node.type) {<EOL>                case '<STR_LIT>':<EOL>                    doc.save();<EOL>                    setStyle(doc, node.span.style || {});<EOL>                    doc.font(node.span.fontFamily).fontSize(node.span.fontSize)._fragment(node.text, node.x, node.y - page * format.height, node.span.options || {});<EOL>                    doc.restore();<EOL>                    break;<EOL>                case '<STR_LIT>':<EOL>                    doc.save();<EOL>                    setStyle(doc, node.style || {});<EOL>                    if (node.style.fillColor && node.style.strokeColor) {<EOL>                        doc.polygon.apply(doc, node.points.map(({ x: x, y: y }) => [x, y]));<EOL>                        doc.","gt":"fillAndStroke();"}
{"input":"<s> export function renderToPages(doc, format: T.Format, layers: T.RenderNode[][], background?: (page: number) => T.RenderNode[][]) {<EOL>    let page_count = <NUM_LIT>;<EOL>    for (let layer of layers) {<EOL>        for (let node of layer) {<EOL>            const page = Math.floor(node.y / format.height);<EOL>            page_count = Math.max(page_count, page);<EOL>        }<EOL>    }<EOL>    const pages = Array(page_count + <NUM_LIT>).fill([]);<EOL>    if (background) {<EOL>        for (let page = <NUM_LIT>; page <= page_count; page++) {<EOL>            for (let layer of background(page)) {<EOL>                for (let node of layer) {<EOL>                    pages[page].push(node);<EOL>                }<EOL>            }<EOL>        }<EOL>    }<EOL>    for (let layer of layers) {<EOL>        for (let node of layer) {<EOL>            const page = Math.floor(node.y / format.height);<EOL>            pages[page].push(node);<EOL>        }<EOL>    }<EOL>    for (let page = <NUM_LIT>; page <= page_count; page++) {<EOL>        if (page != <NUM_LIT>) {<EOL>            doc.addPage();<EOL>        }<EOL>        for (let node of pages[page]) {<EOL>            doc.save();<EOL>            switch (node.type) {<EOL>                case '<STR_LIT>':<EOL>                    doc.save();<EOL>                    setStyle(doc, node.span.style || {});<EOL>                    doc.font(node.span.fontFamily).fontSize(node.span.fontSize)._fragment(node.text, node.x, node.y - page * format.height, node.span.options || {});<EOL>                    doc.restore();<EOL>                    break;<EOL>                case '<STR_LIT>':<EOL>                    doc.save();<EOL>                    setStyle(doc, node.style || {});<EOL>                    if (node.style.fillColor && node.style.strokeColor) {<EOL>                        doc.polygon.apply(doc, node.points.map(({ x: x, y: y }) => [x, y]));<EOL>                        doc.fillAndStroke();<EOL>                    }<EOL>                    else if (node.style.fillColor) {<EOL>                        doc.polygon.apply(doc, node.points.map(({ x: x, y: y }) => [x, y]));<EOL>                        doc.fill();<EOL>                    }<EOL>                    else if (node.style.strokeColor) {<EOL>","gt":"doc.polygon.apply(doc, node.points.map(({ x: x, y: y }) => [x, y]));"}
{"input":"<s> function shrink(span: Span, offset?: number) {<EOL>    if (","gt":"offset == null)"}
{"input":"<s> export function left(measureText: (fontFamily: string, fontSize: number, text: string) => number, hypher, spans: T.Span[], options): T.Node[] {<EOL>    let nodes: T.Node[] = [];<EOL>    spans.forEach(function (span, spanIndex, spanArray) {<EOL>        let words = span.text.split(/\\s/), spaceWidth = measureText(span.fontFamily, span.fontSize, '<STR_LIT>'),","gt":"o = {"}
{"input":"<s> export function left(measureText: (fontFamily: string, fontSize: number, text: string) => number, hypher, spans: T.Span[], options): T.Node[] {<EOL>    let nodes: T.Node[] = [];<EOL>    spans.forEach(function (span, spanIndex, spanArray) {<EOL>        let words = span.text.split(/\\s/), spaceWidth = measureText(span.fontFamily, span.fontSize, '<STR_LIT>'), o = {<EOL>            space: {<EOL>                width: options && options.space.width ||","gt":"<NUM_LIT>,"}
{"input":"<s> export function left(measureText: (fontFamily: string, fontSize: number, text: string) => number, hypher, spans: T.Span[], options): T.Node[] {<EOL>    let nodes: T.Node[] = [];<EOL>    spans.forEach(function (span, spanIndex, spanArray) {<EOL>        let words = span.text.split(/\\s/), spaceWidth = measureText(span.fontFamily, span.fontSize, '<STR_LIT>'), o = {<EOL>            space: {<EOL>                width: options && options.space.width || <NUM_LIT>,<EOL>                stretch: options && options.space.stretch || <NUM_LIT>,<EOL>                shrink: options && options.","gt":"space.shrink || <NUM_LIT>"}
{"input":"<s> export function left(measureText: (fontFamily: string, fontSize: number, text: string) => number, hypher, spans: T.Span[], options): T.Node[] {<EOL>    let nodes: T.Node[] = [];<EOL>    spans.forEach(function (span, spanIndex, spanArray) {<EOL>        let words = span.text.split(/\\s/), spaceWidth = measureText(span.fontFamily, span.fontSize, '<STR_LIT>'), o = {<EOL>            space: {<EOL>                width: options && options.space.width || <NUM_LIT>,<EOL>                stretch: options && options.space.stretch || <NUM_LIT>,<EOL>                shrink: options && options.space.shrink || <NUM_LIT><EOL>            }<EOL>        }, hyphenWidth = measureText(span.fontFamily, span.fontSize, '<STR_LIT>'), hyphenPenalty = <NUM_LIT>, spaceStretch = (spaceWidth * o.space.width) / o.space.stretch, spaceShrink = (spaceWidth * o.space.width) / o.space.shrink;<EOL>        words.forEach(function (word, index, array) {<EOL>            let hyphenated = span.hyphenate ? hypher.hyphenate(","gt":"word) : [word];"}
{"input":"<s> export function left(measureText: (fontFamily: string, fontSize: number, text: string) => number, hypher, spans: T.Span[], options): T.Node[] {<EOL>    let nodes: T.Node[] = [];<EOL>    spans.forEach(function (span, spanIndex, spanArray) {<EOL>        let words = span.text.split(/\\s/), spaceWidth = measureText(span.fontFamily, span.fontSize, '<STR_LIT>'), o = {<EOL>            space: {<EOL>                width: options && options.space.width || <NUM_LIT>,<EOL>                stretch: options && options.space.stretch || <NUM_LIT>,<EOL>                shrink: options && options.space.shrink || <NUM_LIT><EOL>            }<EOL>        }, hyphenWidth = measureText(span.fontFamily, span.fontSize, '<STR_LIT>'), hyphenPenalty = <NUM_LIT>, spaceStretch = (spaceWidth * o.space.width) / o.space.stretch, spaceShrink = (spaceWidth * o.space.width) / o.space.shrink;<EOL>        words.forEach(function (word, index, array) {<EOL>            let hyphenated = span.hyphenate ? hypher.hyphenate(word) : [word];<EOL>            if (hyphenated.length > <NUM_LIT> && word.length > <NUM_LIT>) {<EOL>                hyphenated.forEach(function (part, partIndex, partArray) {<EOL>                    nodes.push({ style: span, value: linebreak.box(measureText(span.fontFamily, span.fontSize, part), part) });<EOL>                    if (partIndex !==","gt":"partArray.length - <NUM_LIT>) {"}
{"input":"<s> /**<EOL> * Quote args if necessary and combine into a space separated string.<EOL> */<EOL>function quote(args: string[]): string {<EOL>    let r = '<STR_LIT>';<EOL>    for (let a of args) {<EOL>        if (a.indexOf('<STR_LIT>') >= <NUM_LIT>) {<EOL>","gt":"r += '<STR_LIT>' + a + '<STR_LIT>';"}
{"input":"<s> /**<EOL> * Quote args if necessary and combine into a space separated string.<EOL> */<EOL>function quote(args: string[]): string {<EOL>    let r = '<STR_LIT>';<EOL>    for (let a of args) {<EOL>        if (a.indexOf('<STR_LIT>') >= <NUM_LIT>) {<EOL>            r += '<STR_LIT>' + a + '<STR_LIT>';<EOL>        }<EOL>        else {<EOL>            r += a;<EOL>        }<EOL>        r +=","gt":"'<STR_LIT>';"}
{"input":"<s> /**<EOL> * Fetch log level stored by `@log` decorator.<EOL> *<EOL> * @param controllerClass Target controller<EOL> * @param methodName Target method<EOL> */<EOL>export function getLogMetadata(controllerClass: Constructor<{}>, methodName: string): LevelMetadata {<EOL>    return (","gt":"MetadataInspector.getMethodMetadata<LevelMetadata>(EXAMPLE_LOG_BINDINGS.METADATA, controllerClass.prototype, methodName) || { level: LOG_LEVEL.OFF });"}
{"input":"<s> /**<EOL> * Create an empty OpenApiSpec object that's still a valid openapi document.<EOL> */<EOL>export function createEmptyApiSpec(): OpenApiSpec {<EOL>    return {<EOL>        openapi: '<STR_LIT>',<EOL>","gt":"info: {"}
{"input":"<s> export async function getLocalNpmRegistries(workingDir: string): Promise<INpmRegistry[]> {<EOL>    let localNpmRegistries: INpmRegistry[] = [];<EOL>    let npmrcPath = path.join(workingDir, '<STR_LIT>');<EOL>    if (tl.exist(npmrcPath)) {<EOL>        let","gt":"npmRegistries: INpmRegistry[] = [];"}
{"input":"<s> export async function getLocalNpmRegistries(workingDir: string): Promise<INpmRegistry[]> {<EOL>    let localNpmRegistries: INpmRegistry[] = [];<EOL>    let npmrcPath = path.join(workingDir, '<STR_LIT>');<EOL>    if (tl.exist(npmrcPath)) {<EOL>        let npmRegistries: INpmRegistry[] = [];<EOL>        for (let registry of await getLocalRegistries(npmrcPath)) {<EOL>            npmRegistries.push(await NpmRegistry.FromFeedId(getFeedIdFromRegistry(registry), true));<EOL>        }<EOL>        localNpmRegistries =","gt":"localNpmRegistries.concat(npmRegistries);"}
{"input":"<s> export function showOutputChannel(): void {<EOL>    getOutputChannel().","gt":"show();"}
{"input":"<s> function queryStringify(object: Object): string {<EOL>    var queryString = \"<STR_LIT>\";<EOL>    var isFirst: boolean = true;<EOL>    for (var property in object) {<EOL>        if (object.hasOwnProperty(property)) {<EOL>","gt":"var value: string = (<any>object)[property];"}
{"input":"<s> function queryStringify(object: Object): string {<EOL>    var queryString = \"<STR_LIT>\";<EOL>    var isFirst: boolean = true;<EOL>    for (var property in object) {<EOL>        if (object.hasOwnProperty(property)) {<EOL>            var value: string = (<any>object)[property];<EOL>            if (!isFirst) {<EOL>                queryString += \"<STR_LIT>\";<EOL>            }<EOL>","gt":"queryString += encodeURIComponent(property) + \"<STR_LIT>\";"}
{"input":"<s> function queryStringify(object: Object): string {<EOL>    var queryString = \"<STR_LIT>\";<EOL>    var isFirst: boolean = true;<EOL>    for (var property in object) {<EOL>        if (object.hasOwnProperty(property)) {<EOL>            var value: string = (<any>object)[property];<EOL>            if (!isFirst) {<EOL>                queryString += \"<STR_LIT>\";<EOL>            }<EOL>            queryString += encodeURIComponent(property) + \"<STR_LIT>\";<EOL>            if (value !== null && typeof value !== \"<STR_LIT>\") {<EOL>                queryString += encodeURIComponent(value);<EOL>            }<EOL>            isFirst =","gt":"false;"}
{"input":"<s> function sorter(a: IKeybindingItem, b: IKeybindingItem): number {<EOL>    if (a.weight1 !== b.weight1) {<EOL>        return a.weight1 - b.weight1;<EOL>    }<EOL>    if (a.command < b.","gt":"command) {"}
{"input":"<s> function sorter(a: IKeybindingItem, b: IKeybindingItem): number {<EOL>    if (a.weight1 !== b.weight1) {<EOL>        return a.weight1 - b.weight1;<EOL>    }<EOL>    if (a.command < b.command) {<EOL>        return -<NUM_LIT>;<EOL>    }<EOL>    if (a.command > b.command) {<EOL>        return","gt":"<NUM_LIT>;"}
{"input":"<s> export function tsProjectFn(plugins) {<EOL>","gt":"return plugins.typescript.createProject('<STR_LIT>', {"}
{"input":"<s> /**<EOL> * Returns the applications version as defined in the `package.json`.<EOL> * @return {number} The applications version.<EOL> */<EOL>function appVersion(): number | string {<EOL>    const","gt":"pkg = require('<STR_LIT>');"}
{"input":"<s> function _assertResolveKeybinding(mapper: WindowsKeyboardMapper, k: number, expected: IResolvedKeybinding[]): void {<EOL>    assertResolveKeybinding(mapper,","gt":"createKeybinding(k, OperatingSystem.Windows), expected);"}
{"input":"<s> /**<EOL> * Get a factory from a bootstrapped module/ module factory<EOL> */<EOL>function getFactory(moduleOrFactory: Type<{}> | NgModuleFactory<{}>, compiler: Compiler): Promise<NgModuleFactory<{}>> {<EOL>    return new Promise<NgModuleFactory<{}>>((resolve, reject) => {<EOL>        <EOL>        if (moduleOrFactory instanceof NgModuleFactory) {<EOL>            resolve(moduleOrFactory);<EOL>","gt":"return;"}
{"input":"<s> /**<EOL> * Get a factory from a bootstrapped module/ module factory<EOL> */<EOL>function getFactory(moduleOrFactory: Type<{}> | NgModuleFactory<{}>, compiler: Compiler): Promise<NgModuleFactory<{}>> {<EOL>    return new Promise<NgModuleFactory<{}>>((resolve, reject) => {<EOL>        <EOL>        if (moduleOrFactory instanceof NgModuleFactory) {<EOL>            resolve(moduleOrFactory);<EOL>            return;<EOL>        }<EOL>        else {<EOL>            let moduleFactory = factoryCacheMap.get(","gt":"moduleOrFactory);"}
{"input":"<s> /**<EOL> * Get a factory from a bootstrapped module/ module factory<EOL> */<EOL>function getFactory(moduleOrFactory: Type<{}> | NgModuleFactory<{}>, compiler: Compiler): Promise<NgModuleFactory<{}>> {<EOL>    return new Promise<NgModuleFactory<{}>>((resolve, reject) => {<EOL>        <EOL>        if (moduleOrFactory instanceof NgModuleFactory) {<EOL>            resolve(moduleOrFactory);<EOL>            return;<EOL>        }<EOL>        else {<EOL>            let moduleFactory = factoryCacheMap.get(moduleOrFactory);<EOL>            <EOL>            if (moduleFactory) {<EOL>                resolve(moduleFactory);<EOL>                return;<EOL>            }<EOL>            <EOL>            compiler.compileModuleAsync(moduleOrFactory)<EOL>                .then((factory) => {<EOL>                factoryCacheMap.set(moduleOrFactory, factory);<EOL>","gt":"resolve(factory);"}
{"input":"<s> /**<EOL> * Returns the application build type.<EOL> */<EOL>function getBuildType() {<EOL>    const type = (argv['<STR_LIT>'] || argv['<STR_LIT>'] || '<STR_LIT>').toLowerCase();<EOL>    const base: string[] = argv['<STR_LIT>'];<EOL>    const prodKeyword = !!base<EOL>        .filter(o => o.indexOf(","gt":"BUILD_TYPES.PRODUCTION) >= <NUM_LIT>)"}
{"input":"<s> /**<EOL> * Returns the application build type.<EOL> */<EOL>function getBuildType() {<EOL>    const type = (argv['<STR_LIT>'] || argv['<STR_LIT>'] || '<STR_LIT>').toLowerCase();<EOL>    const base: string[] = argv['<STR_LIT>'];<EOL>    const prodKeyword = !!base<EOL>        .filter(o => o.indexOf(BUILD_TYPES.PRODUCTION) >= <NUM_LIT>)<EOL>        .pop();<EOL>    if ((base && prodKeyword) || type === BUILD_TYPES.PRODUCTION) {<EOL>        return BUILD_TYPES.PRODUCTION;<EOL>    }<EOL>","gt":"else {"}
{"input":"<s> function getTestState(): AccountManagementState {<EOL>    <EOL>    let mockAccountStore = TypeMoq.Mock.ofType<IAccountStore>(AccountStore);<EOL>","gt":"mockAccountStore.setup(x => x.getAccountsByProvider(TypeMoq.It.isValue(noAccountProvider.id)))"}
{"input":"<s> function getTestState(): AccountManagementState {<EOL>    <EOL>    let mockAccountStore = TypeMoq.Mock.ofType<IAccountStore>(AccountStore);<EOL>    mockAccountStore.setup(x => x.getAccountsByProvider(TypeMoq.It.isValue(noAccountProvider.id)))<EOL>        .returns(() => Promise.resolve([]));<EOL>    mockAccountStore.setup(x => x.getAccountsByProvider(TypeMoq.It.isValue(hasAccountProvider.id)))<EOL>        .","gt":"returns(() => Promise.resolve(accountList));"}
{"input":"<s> function getTestState(): AccountManagementState {<EOL>    <EOL>    let mockAccountStore = TypeMoq.Mock.ofType<IAccountStore>(AccountStore);<EOL>    mockAccountStore.setup(x => x.getAccountsByProvider(TypeMoq.It.isValue(noAccountProvider.id)))<EOL>        .returns(() => Promise.resolve([]));<EOL>    mockAccountStore.setup(x => x.getAccountsByProvider(TypeMoq.It.isValue(hasAccountProvider.id)))<EOL>        .returns(() => Promise.resolve(accountList));<EOL>    <EOL>    let mockInstantiationService = TypeMoq.Mock.ofType(InstantiationService, TypeMoq.MockBehavior.Strict);<EOL>    mockInstantiationService.setup(x => x.createInstance(TypeMoq.It.isValue(AccountStore), TypeMoq.It.isAny()))<EOL>        .returns(() => mockAccountStore.","gt":"object);"}
{"input":"<s> function getTestState(): AccountManagementState {<EOL>    <EOL>    let mockAccountStore = TypeMoq.Mock.ofType<IAccountStore>(AccountStore);<EOL>    mockAccountStore.setup(x => x.getAccountsByProvider(TypeMoq.It.isValue(noAccountProvider.id)))<EOL>        .returns(() => Promise.resolve([]));<EOL>    mockAccountStore.setup(x => x.getAccountsByProvider(TypeMoq.It.isValue(hasAccountProvider.id)))<EOL>        .returns(() => Promise.resolve(accountList));<EOL>    <EOL>    let mockInstantiationService = TypeMoq.Mock.ofType(InstantiationService, TypeMoq.MockBehavior.Strict);<EOL>    mockInstantiationService.setup(x => x.createInstance(TypeMoq.It.isValue(AccountStore), TypeMoq.It.isAny()))<EOL>        .returns(() => mockAccountStore.object);<EOL>    <EOL>    let mockMemento = {};<EOL>    <EOL>    let ams = new AccountManagementService(mockMemento, mockInstantiationService.object, null, null);<EOL>    <EOL>    let evUpdate = new EventVerifierSingle<UpdateAccountListEventParams>();<EOL>    let evAddProvider = new","gt":"EventVerifierSingle<AccountProviderAddedEventParams>();"}
{"input":"<s> function toEnd(node: any) {<EOL>    if (node && node.tokenType !== undefined) {<EOL>        return node.","gt":"endOffset! + <NUM_LIT>;"}
{"input":"<s> function f2() {<EOL>    return new mExported.","gt":"me.class1();"}
{"input":"<s> /**<EOL> * 令文本域随输入内容自动调整高度。<EOL> * @param elem 要处理的文本域节点。<EOL> */<EOL>export default function autoResize(elem: HTMLElement) {<EOL>    function autoResize() {<EOL>        elem.style.height = '<STR_LIT>';<EOL>        elem.","gt":"style.height = elem.scrollHeight + '<STR_LIT>';"}
{"input":"<s> function func() {<EOL>    var fn4;<EOL>","gt":"function fn4() { }"}
{"input":"<s> export function waitUntilExists(done: Function) {<EOL>    browser.executeScript(function () {<EOL>        return (typeof bootstrapPrebootClient !== '<STR_LIT>');<EOL>    })<EOL>        .then((","gt":"keyExists: boolean) => {"}
{"input":"<s> export function waitUntilExists(done: Function) {<EOL>    browser.executeScript(function () {<EOL>        return (typeof bootstrapPrebootClient !== '<STR_LIT>');<EOL>    })<EOL>        .then((keyExists: boolean) => {<EOL>        if (keyExists) {<EOL>            done();<EOL>        }<EOL>        else {<EOL>","gt":"setTimeout(() => waitUntilExists(done), <NUM_LIT>);"}
{"input":"<s> function img(parts: TemplateStringsArray): pxtc.BlockImage {<EOL>    return { kind: \"<STR_LIT>\",","gt":"uri: parts[<NUM_LIT>] };"}
{"input":"<s> function findLiteral(input, currentPosition) {<EOL>    var specialCharacterFlag = false;<EOL>    for (; currentPosition < input.length; currentPosition++) {<EOL>        if (input[currentPosition] == \"<STR_LIT>\" || input[currentPosition] == \"<STR_LIT>\") {<EOL>            for (; currentPosition < input.length;","gt":"currentPosition++) {"}
{"input":"<s> function findLiteral(input, currentPosition) {<EOL>    var specialCharacterFlag = false;<EOL>    for (; currentPosition < input.length; currentPosition++) {<EOL>        if (input[currentPosition] == \"<STR_LIT>\" || input[currentPosition] == \"<STR_LIT>\") {<EOL>            for (; currentPosition < input.length; currentPosition++) {<EOL>                if (input[currentPosition + <NUM_LIT>] != \"<STR_LIT>\" || input[currentPosition + <NUM_LIT>] !=","gt":"\"<STR_LIT>\") {"}
{"input":"<s> function findLiteral(input, currentPosition) {<EOL>    var specialCharacterFlag = false;<EOL>    for (; currentPosition < input.length; currentPosition++) {<EOL>        if (input[currentPosition] == \"<STR_LIT>\" || input[currentPosition] == \"<STR_LIT>\") {<EOL>            for (; currentPosition < input.length; currentPosition++) {<EOL>                if (input[currentPosition + <NUM_LIT>] != \"<STR_LIT>\" || input[currentPosition + <NUM_LIT>] != \"<STR_LIT>\") {<EOL>                    break;<EOL>                }<EOL>            }<EOL>            break;<EOL>        }<EOL>        else if (input[currentPosition] == \"<STR_LIT>\") {<EOL>            currentPosition = findClosingBracketIndex(input, currentPosition + <NUM_LIT>, \"<STR_LIT>\");<EOL>","gt":"specialCharacterFlag = true;"}
{"input":"<s> function findLiteral(input, currentPosition) {<EOL>    var specialCharacterFlag = false;<EOL>    for (; currentPosition < input.length; currentPosition++) {<EOL>        if (input[currentPosition] == \"<STR_LIT>\" || input[currentPosition] == \"<STR_LIT>\") {<EOL>            for (; currentPosition < input.length; currentPosition++) {<EOL>                if (input[currentPosition + <NUM_LIT>] != \"<STR_LIT>\" || input[currentPosition + <NUM_LIT>] != \"<STR_LIT>\") {<EOL>                    break;<EOL>                }<EOL>            }<EOL>            break;<EOL>        }<EOL>        else if (input[currentPosition] == \"<STR_LIT>\") {<EOL>            currentPosition = findClosingBracketIndex(input, currentPosition + <NUM_LIT>, \"<STR_LIT>\");<EOL>            specialCharacterFlag = true;<EOL>        }<EOL>        else if (input[currentPosition] == \"<STR_LIT>\") {<EOL>            currentPosition = findClosingBracketIndex(input, currentPosition + <NUM_LIT>, \"<STR_LIT>\");<EOL>","gt":"specialCharacterFlag = true;"}
{"input":"<s> function findLiteral(input, currentPosition) {<EOL>    var specialCharacterFlag = false;<EOL>    for (; currentPosition < input.length; currentPosition++) {<EOL>        if (input[currentPosition] == \"<STR_LIT>\" || input[currentPosition] == \"<STR_LIT>\") {<EOL>            for (; currentPosition < input.length; currentPosition++) {<EOL>                if (input[currentPosition + <NUM_LIT>] != \"<STR_LIT>\" || input[currentPosition + <NUM_LIT>] != \"<STR_LIT>\") {<EOL>                    break;<EOL>                }<EOL>            }<EOL>            break;<EOL>        }<EOL>        else if (input[currentPosition] == \"<STR_LIT>\") {<EOL>            currentPosition = findClosingBracketIndex(input, currentPosition + <NUM_LIT>, \"<STR_LIT>\");<EOL>            specialCharacterFlag = true;<EOL>        }<EOL>        else if (input[currentPosition] == \"<STR_LIT>\") {<EOL>            currentPosition = findClosingBracketIndex(input, currentPosition + <NUM_LIT>, \"<STR_LIT>\");<EOL>            specialCharacterFlag = true;<EOL>        }<EOL>        else if (input[currentPosition] == \"<STR_LIT>\") {<EOL>            currentPosition = findClosingBracketIndex(input, currentPosition + <NUM_LIT>, \"<STR_LIT>\");<EOL>            specialCharacterFlag =","gt":"true;"}
{"input":"<s> function findLiteral(input, currentPosition) {<EOL>    var specialCharacterFlag = false;<EOL>    for (; currentPosition < input.length; currentPosition++) {<EOL>        if (input[currentPosition] == \"<STR_LIT>\" || input[currentPosition] == \"<STR_LIT>\") {<EOL>            for (; currentPosition < input.length; currentPosition++) {<EOL>                if (input[currentPosition + <NUM_LIT>] != \"<STR_LIT>\" || input[currentPosition + <NUM_LIT>] != \"<STR_LIT>\") {<EOL>                    break;<EOL>                }<EOL>            }<EOL>            break;<EOL>        }<EOL>        else if (input[currentPosition] == \"<STR_LIT>\") {<EOL>            currentPosition = findClosingBracketIndex(input, currentPosition + <NUM_LIT>, \"<STR_LIT>\");<EOL>            specialCharacterFlag = true;<EOL>        }<EOL>        else if (input[currentPosition] == \"<STR_LIT>\") {<EOL>            currentPosition = findClosingBracketIndex(input, currentPosition + <NUM_LIT>, \"<STR_LIT>\");<EOL>            specialCharacterFlag = true;<EOL>        }<EOL>        else if (input[currentPosition] == \"<STR_LIT>\") {<EOL>            currentPosition = findClosingBracketIndex(input, currentPosition + <NUM_LIT>, \"<STR_LIT>\");<EOL>            specialCharacterFlag = true;<EOL>        }<EOL>        else if (input[currentPosition] == \"<STR_LIT>\") {<EOL>            <EOL>            currentPosition = findClosingQuoteIndex(input, currentPosition + <NUM_LIT>, \"<STR_LIT>\");<EOL>            specialCharacterFlag = true;<EOL>        }<EOL>        else if (input[currentPosition] == \"<STR_LIT>\") {<EOL>            <EOL>            currentPosition = findClosingQuoteIndex(input, currentPosition + <NUM_LIT>,","gt":"\"<STR_LIT>\");"}
{"input":"<s> function findLiteral(input, currentPosition) {<EOL>    var specialCharacterFlag = false;<EOL>    for (; currentPosition < input.length; currentPosition++) {<EOL>        if (input[currentPosition] == \"<STR_LIT>\" || input[currentPosition] == \"<STR_LIT>\") {<EOL>            for (; currentPosition < input.length; currentPosition++) {<EOL>                if (input[currentPosition + <NUM_LIT>] != \"<STR_LIT>\" || input[currentPosition + <NUM_LIT>] != \"<STR_LIT>\") {<EOL>                    break;<EOL>                }<EOL>            }<EOL>            break;<EOL>        }<EOL>        else if (input[currentPosition] == \"<STR_LIT>\") {<EOL>            currentPosition = findClosingBracketIndex(input, currentPosition + <NUM_LIT>, \"<STR_LIT>\");<EOL>            specialCharacterFlag = true;<EOL>        }<EOL>        else if (input[currentPosition] == \"<STR_LIT>\") {<EOL>            currentPosition = findClosingBracketIndex(input, currentPosition + <NUM_LIT>, \"<STR_LIT>\");<EOL>            specialCharacterFlag = true;<EOL>        }<EOL>        else if (input[currentPosition] == \"<STR_LIT>\") {<EOL>            currentPosition = findClosingBracketIndex(input, currentPosition + <NUM_LIT>, \"<STR_LIT>\");<EOL>            specialCharacterFlag = true;<EOL>        }<EOL>        else if (input[currentPosition] == \"<STR_LIT>\") {<EOL>            <EOL>            currentPosition = findClosingQuoteIndex(input, currentPosition + <NUM_LIT>, \"<STR_LIT>\");<EOL>            specialCharacterFlag = true;<EOL>        }<EOL>        else if (input[currentPosition] == \"<STR_LIT>\") {<EOL>            <EOL>            currentPosition = findClosingQuoteIndex(input, currentPosition + <NUM_LIT>, \"<STR_LIT>\");<EOL>            specialCharacterFlag = true;<EOL>        }<EOL>        else if (input[currentPosition] == \"<STR_LIT>\") {<EOL>","gt":"currentPosition++;"}
{"input":"<s> function _normalizeProviders(providers: Provider[], res: Provider[]): Provider[] {<EOL>    providers.forEach(b => {<EOL>        if (b instanceof Type) {<EOL>            res.push({ provide: b, useClass: b });<EOL>        }<EOL>        else if (b && typeof b == '<STR_LIT>' && (b","gt":"as any).provide !== undefined) {"}
{"input":"<s> function _normalizeProviders(providers: Provider[], res: Provider[]): Provider[] {<EOL>    providers.forEach(b => {<EOL>        if (b instanceof Type) {<EOL>            res.push({ provide: b, useClass: b });<EOL>        }<EOL>        else if (b && typeof b == '<STR_LIT>' && (b as any).provide !== undefined) {<EOL>            res.push(b as NormalizedProvider);<EOL>        }<EOL>        else if (b instanceof Array) {<EOL>","gt":"_normalizeProviders(b, res);"}
{"input":"<s> function _normalizeProviders(providers: Provider[], res: Provider[]): Provider[] {<EOL>    providers.forEach(b => {<EOL>        if (b instanceof Type) {<EOL>            res.push({ provide: b, useClass: b });<EOL>        }<EOL>        else if (b && typeof b == '<STR_LIT>' && (b as any).provide !== undefined) {<EOL>            res.push(b as NormalizedProvider);<EOL>        }<EOL>        else if (b instanceof Array) {<EOL>            _normalizeProviders(b, res);<EOL>        }<EOL>        else {<EOL>            throw","gt":"invalidProviderError(b);"}
{"input":"<s> <EOL>export function apply(api: _ZonePrivate, _global: any) {<EOL>    const WS = (<any>_global).WebSocket;<EOL>    <EOL>    <EOL>    if (!(<any>","gt":"_global).EventTarget) {"}
{"input":"<s> <EOL>export function apply(api: _ZonePrivate, _global: any) {<EOL>    const WS = (<any>_global).WebSocket;<EOL>    <EOL>    <EOL>    if (!(<any>_global).EventTarget) {<EOL>        patchEventTarget(_global, [WS.prototype]);<EOL>    }<EOL>    (<any>_global).WebSocket = function (x: any, y: any) {<EOL>        const socket = arguments.length > <NUM_LIT> ? new WS(x,","gt":"y) : new WS(x);"}
{"input":"<s> <EOL>export function apply(api: _ZonePrivate, _global: any) {<EOL>    const WS = (<any>_global).WebSocket;<EOL>    <EOL>    <EOL>    if (!(<any>_global).EventTarget) {<EOL>        patchEventTarget(_global, [WS.prototype]);<EOL>    }<EOL>    (<any>_global).WebSocket = function (x: any, y: any) {<EOL>        const socket = arguments.length > <NUM_LIT> ? new WS(x, y) : new WS(x);<EOL>        let proxySocket: any;<EOL>        let proxySocketProto: any;<EOL>        <EOL>        const onmessageDesc = ObjectGetOwnPropertyDescriptor(socket, '<STR_LIT>');<EOL>        if (onmessageDesc && onmessageDesc.configurable === false) {<EOL>            proxySocket =","gt":"ObjectCreate(socket);"}
{"input":"<s> <EOL>export function apply(api: _ZonePrivate, _global: any) {<EOL>    const WS = (<any>_global).WebSocket;<EOL>    <EOL>    <EOL>    if (!(<any>_global).EventTarget) {<EOL>        patchEventTarget(_global, [WS.prototype]);<EOL>    }<EOL>    (<any>_global).WebSocket = function (x: any, y: any) {<EOL>        const socket = arguments.length > <NUM_LIT> ? new WS(x, y) : new WS(x);<EOL>        let proxySocket: any;<EOL>        let proxySocketProto: any;<EOL>        <EOL>        const onmessageDesc = ObjectGetOwnPropertyDescriptor(socket, '<STR_LIT>');<EOL>        if (onmessageDesc && onmessageDesc.configurable === false) {<EOL>            proxySocket = ObjectCreate(socket);<EOL>            <EOL>            <EOL>            <EOL>","gt":"proxySocketProto = socket;"}
{"input":"<s> <EOL>export function apply(api: _ZonePrivate, _global: any) {<EOL>    const WS = (<any>_global).WebSocket;<EOL>    <EOL>    <EOL>    if (!(<any>_global).EventTarget) {<EOL>        patchEventTarget(_global, [WS.prototype]);<EOL>    }<EOL>    (<any>_global).WebSocket = function (x: any, y: any) {<EOL>        const socket = arguments.length > <NUM_LIT> ? new WS(x, y) : new WS(x);<EOL>        let proxySocket: any;<EOL>        let proxySocketProto: any;<EOL>        <EOL>        const onmessageDesc = ObjectGetOwnPropertyDescriptor(socket, '<STR_LIT>');<EOL>        if (onmessageDesc && onmessageDesc.configurable === false) {<EOL>            proxySocket = ObjectCreate(socket);<EOL>            <EOL>            <EOL>            <EOL>            proxySocketProto = socket;<EOL>            [ADD_EVENT_LISTENER_STR, REMOVE_EVENT_LISTENER_STR, '<STR_LIT>', '<STR_LIT>'].forEach(function (propName) {<EOL>                proxySocket[propName] = function () {<EOL>                    const args = ArraySlice.call(arguments);<EOL>                    if (propName === ADD_EVENT_LISTENER_STR || propName === REMOVE_EVENT_LISTENER_STR) {<EOL>                        const eventName = args.length > <NUM_LIT> ? args[<NUM_LIT>] : undefined;<EOL>","gt":"if (eventName) {"}
{"input":"<s> export default function cube(x) {<EOL>    return","gt":"Math.pow(x, <NUM_LIT>);"}
{"input":"<s> function validateTasks(tasks: any) {<EOL>    return Object.keys(tasks)<EOL>        .map((taskName: string) => {<EOL>        if (!tasks[","gt":"taskName] ||"}
{"input":"<s> /**<EOL> * 表示一个补间动画。<EOL> * @param {Dom} dom 执行动画的目标节点。<EOL> * @param {Object} options 动画的相关参数。<EOL> * @class<EOL> */<EOL>function Tween(dom) {<EOL>    this.dom =","gt":"Dom(dom);"}
{"input":"<s> export function multiTrim(text: string | null | undefined, allSpace = false): string {<EOL>    if (typeof text == '<STR_LIT>') {<EOL>        const repl = allSpace ? '<STR_LIT>' :","gt":"'<STR_LIT>';"}
{"input":"<s> function getInvalidTaskErrorMessage(invalid: string[], file: string) {<EOL>    let error = `<STR_LIT>`;<EOL>    if (invalid.length === <NUM_LIT>) {<EOL>        error +=","gt":"'<STR_LIT>';"}
{"input":"<s> export function isDigit(code: number): boolean {<EOL>    return $0 <= code &&","gt":"code <= $9;"}
{"input":"<s> function visitTopLevelDeclarations(sourceFile: ts.SourceFile, visitor: (node: TSTopLevelDeclare) => boolean): void {<EOL>    let stop = false;<EOL>    let visit = (node: ts.Node): void => {<EOL>        if (stop) {<EOL>            return;<EOL>        }<EOL>        switch (node.kind) {<EOL>            case ts.SyntaxKind.InterfaceDeclaration:<EOL>            case ts.SyntaxKind.EnumDeclaration:<EOL>            case","gt":"ts.SyntaxKind.ClassDeclaration:"}
{"input":"<s> function visitTopLevelDeclarations(sourceFile: ts.SourceFile, visitor: (node: TSTopLevelDeclare) => boolean): void {<EOL>    let stop = false;<EOL>    let visit = (node: ts.Node): void => {<EOL>        if (stop) {<EOL>            return;<EOL>        }<EOL>        switch (node.kind) {<EOL>            case ts.SyntaxKind.InterfaceDeclaration:<EOL>            case ts.SyntaxKind.EnumDeclaration:<EOL>            case ts.SyntaxKind.ClassDeclaration:<EOL>            case ts.SyntaxKind.VariableStatement:<EOL>            case ts.SyntaxKind.TypeAliasDeclaration:<EOL>","gt":"case ts.SyntaxKind.FunctionDeclaration:"}
{"input":"<s> /**<EOL> * Asserts that an element is focused.<EOL> */<EOL>export function expectFocusOn(element: FinderResult, expected = true): void {<EOL>    expect(browser.driver.switchTo().activeElement().getId()).toBe(getElement(element).getId(),","gt":"'<STR_LIT>'} to be focused.`<STR_LIT>;"}
{"input":"<s> export function isLineBreak(ch: number): boolean {<EOL>    return ch === LineFeed ||<EOL>","gt":"ch === CarriageReturn ||"}
{"input":"<s> export default function (options: ModuleOptions): Rule {<EOL>    options.path = options.path ? normalize(options.path) : options.path;<EOL>    const sourceDir = options.sourceDir;<EOL>    if (!sourceDir) {<EOL>        throw new SchematicsException(`<STR_LIT>`);<EOL>    }<EOL>    return (host: Tree, context: SchematicContext) => {<EOL>        if (options.module) {<EOL>            options.","gt":"module = findModuleFromOptions(host, options);"}
{"input":"<s> export default function (options: ModuleOptions): Rule {<EOL>    options.path = options.path ? normalize(options.path) : options.path;<EOL>    const sourceDir = options.sourceDir;<EOL>    if (!sourceDir) {<EOL>        throw new SchematicsException(`<STR_LIT>`);<EOL>    }<EOL>    return (host: Tree, context: SchematicContext) => {<EOL>        if (options.module) {<EOL>            options.module = findModuleFromOptions(host, options);<EOL>        }<EOL>        const templateSource = apply(url('<STR_LIT>'), [<EOL>            options.","gt":"spec ? noop() : filter(path => !path.endsWith('<STR_LIT>')),"}
{"input":"<s> export default function (options: ModuleOptions): Rule {<EOL>    options.path = options.path ? normalize(options.path) : options.path;<EOL>    const sourceDir = options.sourceDir;<EOL>    if (!sourceDir) {<EOL>        throw new SchematicsException(`<STR_LIT>`);<EOL>    }<EOL>    return (host: Tree, context: SchematicContext) => {<EOL>        if (options.module) {<EOL>            options.module = findModuleFromOptions(host, options);<EOL>        }<EOL>        const templateSource = apply(url('<STR_LIT>'), [<EOL>            options.spec ? noop() : filter(path => !path.endsWith('<STR_LIT>')),<EOL>            options.routing ? noop() : filter(path => !path.endsWith('<STR_LIT>')),<EOL>            template({<EOL>                ...","gt":"strings,"}
{"input":"<s> export default function (options: ModuleOptions): Rule {<EOL>    options.path = options.path ? normalize(options.path) : options.path;<EOL>    const sourceDir = options.sourceDir;<EOL>    if (!sourceDir) {<EOL>        throw new SchematicsException(`<STR_LIT>`);<EOL>    }<EOL>    return (host: Tree, context: SchematicContext) => {<EOL>        if (options.module) {<EOL>            options.module = findModuleFromOptions(host, options);<EOL>        }<EOL>        const templateSource = apply(url('<STR_LIT>'), [<EOL>            options.spec ? noop() : filter(path => !path.endsWith('<STR_LIT>')),<EOL>            options.routing ? noop() : filter(path => !path.endsWith('<STR_LIT>')),<EOL>            template({<EOL>                ...strings,<EOL>                '<STR_LIT>': (s: string) => options.flat ? '<STR_LIT>' : s,<EOL>                ...options,<EOL>            }),<EOL>            move(sourceDir),<EOL>        ]);<EOL>","gt":"return chain(["}
{"input":"<s> <EOL>export function square(x) {<EOL>    return Math.pow(","gt":"x, <NUM_LIT>);"}
{"input":"<s> function delay<T>(time: number, value: T, shouldThrow = false): Promise<T> {<EOL>    return new Promise((resolve, reject) => {<EOL>        setTimeout(() => {<EOL>","gt":"if (shouldThrow)"}
{"input":"<s> <EOL><EOL>/** Switch to the tab by index (position on tab bar), wrapping round.<EOL><EOL>    @param index<EOL>        1-based index of the tab to target. Wraps such that 0 = last tab, -1 =<EOL>        penultimate tab, etc.<EOL><EOL>        if undefined, return activeTabId()<EOL>*/<EOL>/** @hidden */<EOL><EOL>async function tabIndexSetActive(index: number) {<EOL>    tabSetActive(await idFromIndex(","gt":"index));"}
{"input":"<s> /** Move the current tab to be just in front of the index specified.<EOL><EOL>    Known bug: This supports relative movement, but autocomple doesn't know<EOL>    that yet and will override positive and negative indexes.<EOL><EOL>    Put a space in front of tabmove if you want to disable completion and have<EOL>    the relative indexes at the command line.<EOL><EOL>    Binds are unaffected.<EOL><EOL>    @param index<EOL>        New index for the current tab.<EOL><EOL>        1 is the first index. 0 is the last index. -1 is the penultimate, etc.<EOL>*/<EOL><EOL>export async function tabmove(index = \"<STR_LIT>\") {<EOL>    const aTab = await activeTab();<EOL>    let newindex: number;<EOL>    if (index.startsWith(\"<STR_LIT>\") || index.startsWith(","gt":"\"<STR_LIT>\")) {"}
{"input":"<s> <EOL>export async function winclose() {<EOL>    browser.windows.remove((await browser.","gt":"windows.getCurrent()).id);"}
{"input":"<s> /** Set a key value pair in config.<EOL><EOL>    Use to set any string values found [here](/static/docs/modules/_config_.html#defaults)<EOL><EOL>    e.g.<EOL>        set searchurls.google https://www.google.com/search?q=<EOL>        set logging.messaging info<EOL>*/<EOL><EOL>export function set(key: string, ...values: string[]) {<EOL>    if (!key || !values[<NUM_LIT>]) {<EOL>        throw \"<STR_LIT>\";<EOL>    }<EOL>    const target = key.split('<STR_LIT>');<EOL>    <EOL>    <EOL>    switch (target[<NUM_LIT>]) {<EOL>        case \"<STR_LIT>\":<EOL>            const map = {<EOL>                \"<STR_LIT>\": Logging.LEVEL.","gt":"NEVER,"}
{"input":"<s> /** Set a key value pair in config.<EOL><EOL>    Use to set any string values found [here](/static/docs/modules/_config_.html#defaults)<EOL><EOL>    e.g.<EOL>        set searchurls.google https://www.google.com/search?q=<EOL>        set logging.messaging info<EOL>*/<EOL><EOL>export function set(key: string, ...values: string[]) {<EOL>    if (!key || !values[<NUM_LIT>]) {<EOL>        throw \"<STR_LIT>\";<EOL>    }<EOL>    const target = key.split('<STR_LIT>');<EOL>    <EOL>    <EOL>    switch (target[<NUM_LIT>]) {<EOL>        case \"<STR_LIT>\":<EOL>            const map = {<EOL>                \"<STR_LIT>\": Logging.LEVEL.NEVER,<EOL>                \"<STR_LIT>\": Logging.LEVEL.ERROR,<EOL>                \"<STR_LIT>\": Logging.LEVEL.WARNING,<EOL>                \"<STR_LIT>\": Logging.LEVEL.INFO,<EOL>                \"<STR_LIT>\": Logging.","gt":"LEVEL.DEBUG,"}
{"input":"<s> /** Set a key value pair in config.<EOL><EOL>    Use to set any string values found [here](/static/docs/modules/_config_.html#defaults)<EOL><EOL>    e.g.<EOL>        set searchurls.google https://www.google.com/search?q=<EOL>        set logging.messaging info<EOL>*/<EOL><EOL>export function set(key: string, ...values: string[]) {<EOL>    if (!key || !values[<NUM_LIT>]) {<EOL>        throw \"<STR_LIT>\";<EOL>    }<EOL>    const target = key.split('<STR_LIT>');<EOL>    <EOL>    <EOL>    switch (target[<NUM_LIT>]) {<EOL>        case \"<STR_LIT>\":<EOL>            const map = {<EOL>                \"<STR_LIT>\": Logging.LEVEL.NEVER,<EOL>                \"<STR_LIT>\": Logging.LEVEL.ERROR,<EOL>                \"<STR_LIT>\": Logging.LEVEL.WARNING,<EOL>                \"<STR_LIT>\": Logging.LEVEL.INFO,<EOL>                \"<STR_LIT>\": Logging.LEVEL.DEBUG,<EOL>            };<EOL>            let level = map[values[<NUM_LIT>].toLowerCase()];<EOL>            if (level === undefined)<EOL>                throw","gt":"\"<STR_LIT>\";"}
{"input":"<s> /** Set a key value pair in config.<EOL><EOL>    Use to set any string values found [here](/static/docs/modules/_config_.html#defaults)<EOL><EOL>    e.g.<EOL>        set searchurls.google https://www.google.com/search?q=<EOL>        set logging.messaging info<EOL>*/<EOL><EOL>export function set(key: string, ...values: string[]) {<EOL>    if (!key || !values[<NUM_LIT>]) {<EOL>        throw \"<STR_LIT>\";<EOL>    }<EOL>    const target = key.split('<STR_LIT>');<EOL>    <EOL>    <EOL>    switch (target[<NUM_LIT>]) {<EOL>        case \"<STR_LIT>\":<EOL>            const map = {<EOL>                \"<STR_LIT>\": Logging.LEVEL.NEVER,<EOL>                \"<STR_LIT>\": Logging.LEVEL.ERROR,<EOL>                \"<STR_LIT>\": Logging.LEVEL.WARNING,<EOL>                \"<STR_LIT>\": Logging.LEVEL.INFO,<EOL>                \"<STR_LIT>\": Logging.LEVEL.DEBUG,<EOL>            };<EOL>            let level = map[values[<NUM_LIT>].toLowerCase()];<EOL>            if (level === undefined)<EOL>                throw \"<STR_LIT>\";<EOL>            else<EOL>                config.set(...target, level);<EOL>            return;<EOL>    }<EOL>    const currentValue = config.get(...target);<EOL>    if (Array.isArray(currentValue)) {<EOL>        config.set(...","gt":"target, values);"}
{"input":"<s> /** Hint a page.<EOL><EOL>    @param option<EOL>        - -b open in background<EOL>        - -y copy (yank) link's target to clipboard<EOL>        - -p copy an element's text to the clipboard<EOL>        - -r read an element's text with text-to-speech<EOL>        - -i view an image<EOL>        - -I view an image in a new tab<EOL>        - -k delete an element from the page<EOL>        - -s save (download) the linked resource<EOL>        - -S save the linked image<EOL>        - -a save-as the linked resource<EOL>        - -A save-as the linked image<EOL>        - -; focus an element<EOL>        - -# yank an element's anchor URL to clipboard<EOL>        - -c [selector] hint links that match the css selector<EOL>          - `bind ;c hint -c [class*=\"expand\"],[class=\"togg\"]` works particularly well on reddit and HN<EOL><EOL>    Excepting the custom selector mode and background hint mode, each of these<EOL>    hint modes is available by default as `;<option character>`, so e.g. `;y`<EOL>    to yank a link's target.<EOL><EOL>    To open a hint in the background, the default bind is `F`.<EOL><EOL>    Related settings:<EOL>        \"hintchars\": \"hjklasdfgyuiopqwertnmzxcvb\"<EOL>        \"hintfiltermode\": \"simple\" | \"vimperator\" | \"vimperator-reflow\"<EOL>*/<EOL><EOL>export function hint(option?: string, selectors = \"<STR_LIT>\") {<EOL>    if (option === '<STR_LIT>')<EOL>        hinting.hintPageOpenInBackground();<EOL>    else if (","gt":"option === \"<STR_LIT>\")"}
{"input":"<s> /** Hint a page.<EOL><EOL>    @param option<EOL>        - -b open in background<EOL>        - -y copy (yank) link's target to clipboard<EOL>        - -p copy an element's text to the clipboard<EOL>        - -r read an element's text with text-to-speech<EOL>        - -i view an image<EOL>        - -I view an image in a new tab<EOL>        - -k delete an element from the page<EOL>        - -s save (download) the linked resource<EOL>        - -S save the linked image<EOL>        - -a save-as the linked resource<EOL>        - -A save-as the linked image<EOL>        - -; focus an element<EOL>        - -# yank an element's anchor URL to clipboard<EOL>        - -c [selector] hint links that match the css selector<EOL>          - `bind ;c hint -c [class*=\"expand\"],[class=\"togg\"]` works particularly well on reddit and HN<EOL><EOL>    Excepting the custom selector mode and background hint mode, each of these<EOL>    hint modes is available by default as `;<option character>`, so e.g. `;y`<EOL>    to yank a link's target.<EOL><EOL>    To open a hint in the background, the default bind is `F`.<EOL><EOL>    Related settings:<EOL>        \"hintchars\": \"hjklasdfgyuiopqwertnmzxcvb\"<EOL>        \"hintfiltermode\": \"simple\" | \"vimperator\" | \"vimperator-reflow\"<EOL>*/<EOL><EOL>export function hint(option?: string, selectors = \"<STR_LIT>\") {<EOL>    if (option === '<STR_LIT>')<EOL>        hinting.hintPageOpenInBackground();<EOL>    else if (option === \"<STR_LIT>\")<EOL>        hinting.hintPageYank();<EOL>    else if (option === \"<STR_LIT>\")<EOL>","gt":"hinting.hintPageTextYank();"}
{"input":"<s> /** Hint a page.<EOL><EOL>    @param option<EOL>        - -b open in background<EOL>        - -y copy (yank) link's target to clipboard<EOL>        - -p copy an element's text to the clipboard<EOL>        - -r read an element's text with text-to-speech<EOL>        - -i view an image<EOL>        - -I view an image in a new tab<EOL>        - -k delete an element from the page<EOL>        - -s save (download) the linked resource<EOL>        - -S save the linked image<EOL>        - -a save-as the linked resource<EOL>        - -A save-as the linked image<EOL>        - -; focus an element<EOL>        - -# yank an element's anchor URL to clipboard<EOL>        - -c [selector] hint links that match the css selector<EOL>          - `bind ;c hint -c [class*=\"expand\"],[class=\"togg\"]` works particularly well on reddit and HN<EOL><EOL>    Excepting the custom selector mode and background hint mode, each of these<EOL>    hint modes is available by default as `;<option character>`, so e.g. `;y`<EOL>    to yank a link's target.<EOL><EOL>    To open a hint in the background, the default bind is `F`.<EOL><EOL>    Related settings:<EOL>        \"hintchars\": \"hjklasdfgyuiopqwertnmzxcvb\"<EOL>        \"hintfiltermode\": \"simple\" | \"vimperator\" | \"vimperator-reflow\"<EOL>*/<EOL><EOL>export function hint(option?: string, selectors = \"<STR_LIT>\") {<EOL>    if (option === '<STR_LIT>')<EOL>        hinting.hintPageOpenInBackground();<EOL>    else if (option === \"<STR_LIT>\")<EOL>        hinting.hintPageYank();<EOL>    else if (option === \"<STR_LIT>\")<EOL>        hinting.hintPageTextYank();<EOL>    else if (option === \"<STR_LIT>\")<EOL>        hinting.hintImage(false);<EOL>    else if (option === \"<STR_LIT>\")<EOL>","gt":"hinting.hintImage(true);"}
{"input":"<s> /** Hint a page.<EOL><EOL>    @param option<EOL>        - -b open in background<EOL>        - -y copy (yank) link's target to clipboard<EOL>        - -p copy an element's text to the clipboard<EOL>        - -r read an element's text with text-to-speech<EOL>        - -i view an image<EOL>        - -I view an image in a new tab<EOL>        - -k delete an element from the page<EOL>        - -s save (download) the linked resource<EOL>        - -S save the linked image<EOL>        - -a save-as the linked resource<EOL>        - -A save-as the linked image<EOL>        - -; focus an element<EOL>        - -# yank an element's anchor URL to clipboard<EOL>        - -c [selector] hint links that match the css selector<EOL>          - `bind ;c hint -c [class*=\"expand\"],[class=\"togg\"]` works particularly well on reddit and HN<EOL><EOL>    Excepting the custom selector mode and background hint mode, each of these<EOL>    hint modes is available by default as `;<option character>`, so e.g. `;y`<EOL>    to yank a link's target.<EOL><EOL>    To open a hint in the background, the default bind is `F`.<EOL><EOL>    Related settings:<EOL>        \"hintchars\": \"hjklasdfgyuiopqwertnmzxcvb\"<EOL>        \"hintfiltermode\": \"simple\" | \"vimperator\" | \"vimperator-reflow\"<EOL>*/<EOL><EOL>export function hint(option?: string, selectors = \"<STR_LIT>\") {<EOL>    if (option === '<STR_LIT>')<EOL>        hinting.hintPageOpenInBackground();<EOL>    else if (option === \"<STR_LIT>\")<EOL>        hinting.hintPageYank();<EOL>    else if (option === \"<STR_LIT>\")<EOL>        hinting.hintPageTextYank();<EOL>    else if (option === \"<STR_LIT>\")<EOL>        hinting.hintImage(false);<EOL>    else if (option === \"<STR_LIT>\")<EOL>        hinting.hintImage(true);<EOL>    else if (option === \"<STR_LIT>\")<EOL>        hinting.hintKill();<EOL>","gt":"else if (option === \"<STR_LIT>\")"}
{"input":"<s> /** Hint a page.<EOL><EOL>    @param option<EOL>        - -b open in background<EOL>        - -y copy (yank) link's target to clipboard<EOL>        - -p copy an element's text to the clipboard<EOL>        - -r read an element's text with text-to-speech<EOL>        - -i view an image<EOL>        - -I view an image in a new tab<EOL>        - -k delete an element from the page<EOL>        - -s save (download) the linked resource<EOL>        - -S save the linked image<EOL>        - -a save-as the linked resource<EOL>        - -A save-as the linked image<EOL>        - -; focus an element<EOL>        - -# yank an element's anchor URL to clipboard<EOL>        - -c [selector] hint links that match the css selector<EOL>          - `bind ;c hint -c [class*=\"expand\"],[class=\"togg\"]` works particularly well on reddit and HN<EOL><EOL>    Excepting the custom selector mode and background hint mode, each of these<EOL>    hint modes is available by default as `;<option character>`, so e.g. `;y`<EOL>    to yank a link's target.<EOL><EOL>    To open a hint in the background, the default bind is `F`.<EOL><EOL>    Related settings:<EOL>        \"hintchars\": \"hjklasdfgyuiopqwertnmzxcvb\"<EOL>        \"hintfiltermode\": \"simple\" | \"vimperator\" | \"vimperator-reflow\"<EOL>*/<EOL><EOL>export function hint(option?: string, selectors = \"<STR_LIT>\") {<EOL>    if (option === '<STR_LIT>')<EOL>        hinting.hintPageOpenInBackground();<EOL>    else if (option === \"<STR_LIT>\")<EOL>        hinting.hintPageYank();<EOL>    else if (option === \"<STR_LIT>\")<EOL>        hinting.hintPageTextYank();<EOL>    else if (option === \"<STR_LIT>\")<EOL>        hinting.hintImage(false);<EOL>    else if (option === \"<STR_LIT>\")<EOL>        hinting.hintImage(true);<EOL>    else if (option === \"<STR_LIT>\")<EOL>        hinting.hintKill();<EOL>    else if (option === \"<STR_LIT>\")<EOL>        hinting.hintSave(\"<STR_LIT>\", false);<EOL>    else if (option === \"<STR_LIT>\")<EOL>        hinting.hintSave(\"<STR_LIT>\", false);<EOL>    else if (","gt":"option === \"<STR_LIT>\")"}
{"input":"<s> /** Hint a page.<EOL><EOL>    @param option<EOL>        - -b open in background<EOL>        - -y copy (yank) link's target to clipboard<EOL>        - -p copy an element's text to the clipboard<EOL>        - -r read an element's text with text-to-speech<EOL>        - -i view an image<EOL>        - -I view an image in a new tab<EOL>        - -k delete an element from the page<EOL>        - -s save (download) the linked resource<EOL>        - -S save the linked image<EOL>        - -a save-as the linked resource<EOL>        - -A save-as the linked image<EOL>        - -; focus an element<EOL>        - -# yank an element's anchor URL to clipboard<EOL>        - -c [selector] hint links that match the css selector<EOL>          - `bind ;c hint -c [class*=\"expand\"],[class=\"togg\"]` works particularly well on reddit and HN<EOL><EOL>    Excepting the custom selector mode and background hint mode, each of these<EOL>    hint modes is available by default as `;<option character>`, so e.g. `;y`<EOL>    to yank a link's target.<EOL><EOL>    To open a hint in the background, the default bind is `F`.<EOL><EOL>    Related settings:<EOL>        \"hintchars\": \"hjklasdfgyuiopqwertnmzxcvb\"<EOL>        \"hintfiltermode\": \"simple\" | \"vimperator\" | \"vimperator-reflow\"<EOL>*/<EOL><EOL>export function hint(option?: string, selectors = \"<STR_LIT>\") {<EOL>    if (option === '<STR_LIT>')<EOL>        hinting.hintPageOpenInBackground();<EOL>    else if (option === \"<STR_LIT>\")<EOL>        hinting.hintPageYank();<EOL>    else if (option === \"<STR_LIT>\")<EOL>        hinting.hintPageTextYank();<EOL>    else if (option === \"<STR_LIT>\")<EOL>        hinting.hintImage(false);<EOL>    else if (option === \"<STR_LIT>\")<EOL>        hinting.hintImage(true);<EOL>    else if (option === \"<STR_LIT>\")<EOL>        hinting.hintKill();<EOL>    else if (option === \"<STR_LIT>\")<EOL>        hinting.hintSave(\"<STR_LIT>\", false);<EOL>    else if (option === \"<STR_LIT>\")<EOL>        hinting.hintSave(\"<STR_LIT>\", false);<EOL>    else if (option === \"<STR_LIT>\")<EOL>        hinting.hintSave(\"<STR_LIT>\", true);<EOL>    else if (option === \"<STR_LIT>\")<EOL>        hinting.hintSave(\"<STR_LIT>\", true);<EOL>    else if (option === \"<STR_LIT>\")<EOL>        hinting.hintFocus();<EOL>    else","gt":"if (option === \"<STR_LIT>\")"}
{"input":"<s> export function isType(v: any): v is Type<any> {<EOL>    return","gt":"typeof v === '<STR_LIT>';"}
{"input":"<s> function createTestComponent(template: string): ComponentFixture<TestComponent> {<EOL>    return TestBed.overrideComponent(","gt":"TestComponent, { set: { template: template } })"}
{"input":"<s> /**<EOL> * @license<EOL> * Copyright Google Inc. All Rights Reserved.<EOL> *<EOL> * Use of this source code is governed by an MIT-style license that can be<EOL> * found in the LICENSE file at https://angular.io/license<EOL> */<EOL>export function parseCookieValue(cookieStr: string, name: string): string | null {<EOL>    name = encodeURIComponent(name);<EOL>    for (const cookie of cookieStr.split('<STR_LIT>')) {<EOL>        const eqIndex = cookie.","gt":"indexOf('<STR_LIT>');"}
{"input":"<s> export function setClipboard(content: string) {<EOL>    applyWithTmpTextArea(scratchpad => {<EOL>        scratchpad.value = content;<EOL>        scratchpad.select();<EOL>        if (","gt":"document.execCommand(\"<STR_LIT>\")) {"}
{"input":"<s> /** Init gobble mode. After parsing the defined number of input keys, execute<EOL>`endCmd` with attached parsed input. `Escape` cancels the mode and returns to<EOL>normal mode. */<EOL>export function init(numChars: number, endCommand: string) {<EOL>    state.mode = '<STR_LIT>';<EOL>    modeState = new","gt":"GobbleState();"}
{"input":"<s> function validateTextDocument(textDocument: TextDocument): void {<EOL>    if (textDocument.getText().length === <NUM_LIT>) {<EOL>        <EOL>        connection.sendDiagnostics({ uri: textDocument.uri, diagnostics: [] });<EOL>        return;<EOL>    }<EOL>    try {<EOL>        let jsonDocument = getJSONDocument(textDocument);<EOL>        let documentSettings: DocumentLanguageSettings = textDocument.languageId === '<STR_LIT>' ? { comments: '<STR_LIT>', trailingCommas: '<STR_LIT>' } : { comments: '<STR_LIT>', trailingCommas: '<STR_LIT>' };<EOL>        languageService.doValidation(","gt":"textDocument, jsonDocument, documentSettings).then(diagnostics => {"}
{"input":"<s> /**<EOL> * Thrown when getting an object by index.<EOL> *<EOL> * ### Example ([live demo](http://plnkr.co/edit/bRs0SX2OTQiJzqvjgl8P?p=preview))<EOL> *<EOL> * ```typescript<EOL> * class A {}<EOL> *<EOL> * var injector = Injector.resolveAndCreate([A]);<EOL> *<EOL> * expect(() => injector.getAt(100)).toThrowError();<EOL> * ```<EOL> * @stable<EOL> */<EOL>export function outOfBoundsError(index: number) {<EOL>    return Error(","gt":"index} is out-of-bounds.`<STR_LIT>;"}
{"input":"<s> export function registerTab(tab: IDashboardTab): void {<EOL>    dashboardRegistry.","gt":"registerTab(tab);"}
{"input":"<s> function isSelectorOperatorCharacter(code: number): boolean {<EOL>    switch (code) {<EOL>        case chars.$SLASH:<EOL>","gt":"case chars.$TILDA:"}
{"input":"<s> function caseImpl<U, T>(handlers: {<EOL>    pending?: () => U;<EOL>    fulfilled?: (t: T) => U;<EOL>    rejected?: (e: any) => U;<EOL>}): U {<EOL>    switch (this.state) {<EOL>        case PENDING:<EOL>            return handlers.","gt":"pending && handlers.pending();"}
{"input":"<s> <EOL><EOL><EOL><EOL>function set(path: string, replace = false): void {<EOL>    setTimeout(() =>","gt":"doSet(path, replace), <NUM_LIT>);"}
{"input":"<s> function handleFollowingOnline(data: Array<string>, payload: FollowingOnlinePayload) {<EOL>    <EOL>    const oldFriendList = cloneDeep(friendsApi.list());<EOL>    const friendsPlaying = payload.","gt":"playing;"}
{"input":"<s> function sendLocalNotif(title: string, text: string, route: string) {<EOL>    <EOL>    <EOL>    <EOL>    if (cordova.platformId === '<STR_LIT>' && !router.get().startsWith(route)) {<EOL>        window.cordova.","gt":"plugins.notification.local.schedule({"}
{"input":"<s> function sendLocalNotif(title: string, text: string, route: string) {<EOL>    <EOL>    <EOL>    <EOL>    if (cordova.platformId === '<STR_LIT>' && !router.get().startsWith(route)) {<EOL>        window.cordova.plugins.notification.local.schedule({<EOL>            title,<EOL>            text,<EOL>            at: Date.now(),<EOL>            icon:","gt":"'<STR_LIT>',"}
{"input":"<s> function handleOther(eventData: UniversalLinks.EventData) {<EOL>    const pieces = eventData.path.split('<STR_LIT>');<EOL>    if (eventData.path.search('<STR_LIT>') !== -<NUM_LIT>) {<EOL>        getChallenge(pieces[<NUM_LIT>])<EOL>            .then(() => router.set('<STR_LIT>' + pieces[<NUM_LIT>]))<EOL>            .catch(() => router.set(","gt":"'<STR_LIT>' + pieces[<NUM_LIT>]));"}
{"input":"<s> export function validateComponent(validate: F2<ComponentMetadata, WalkerOptions, Maybe<Failure[]>>): ComponentValidator {<EOL>    return {<EOL>        kind:","gt":"'<STR_LIT>',"}
{"input":"<s> export function getType(error: Error): Function {<EOL>    return (error as any)[","gt":"ERROR_TYPE];"}
{"input":"<s> function uniqId() {<EOL>    return","gt":"String(performance.now());"}
{"input":"<s> export function init(payload: InitRequest): Promise<InitResponse> {<EOL>    return askWorker(worker, { topic: '<STR_LIT>',","gt":"payload });"}
{"input":"<s> export function drop(payload: DropRequest): Promise<MoveResponse> {<EOL>    return askWorker(worker, { topic:","gt":"'<STR_LIT>', payload, reqid: uniqId() });"}
{"input":"<s> /**<EOL> *<EOL> * Converts an subscribable, observable stream (TC 39 observable / RxJS stream)<EOL> * into an object which stores the current value (as `current`). The subscription can be cancelled through the `dispose` method.<EOL> * Takes an initial value as second optional argument<EOL> *<EOL> * @example<EOL> * const debouncedClickDelta = MobxUtils.fromStream(Rx.Observable.fromEvent(button, 'click')<EOL> *     .throttleTime(1000)<EOL> *     .map(event => event.clientX)<EOL> *     .scan((count, clientX) => count + clientX, 0)<EOL> * )<EOL> *<EOL> * autorun(() => {<EOL> *     console.log(\"distance moved\", debouncedClickDelta.current)<EOL> * })<EOL> *<EOL> * @export<EOL> * @template T<EOL> * @param {IObservableStream<T>} observable<EOL> * @returns {{<EOL> *     current: T;<EOL> *     dispose(): void;<EOL> * }}<EOL> */<EOL>export function fromStream<T>(observable: IObservableStream<T>, initialValue: T = undefined): {<EOL>    current: T;<EOL>    dispose(): void;<EOL>} {<EOL>    return","gt":"new StreamListener(observable, initialValue);"}
{"input":"<s> export function addReadOnlyProp(object: any, propName: string, value: any) {<EOL>    Object.defineProperty(object, propName, {<EOL>        enumerable:","gt":"true,"}
{"input":"<s> /**<EOL> * 获取列表中的元素的激活元素。<EOL> * @param items 所有元素列表。<EOL> * @param className 激活的 CSS 类名。<EOL> * @return 返回激活的元素。如果不存在则返回 null。<EOL> */<EOL>export function getActive(items: ArrayLike<HTMLElement>, className: string) {<EOL>    for (const item of items as any) {<EOL>        if (","gt":"dom.hasClass(item, className)) {"}
{"input":"<s> /**<EOL> * 编码 HTML 特殊字符。<EOL> * @param value 要编码的字符串。<EOL> * @return 返回已编码的字符串。HTML 特殊字符 `&`、`<`、`>`、`'`、`\"` 分别会被编码成 `&amp;`、`&lt;`、`&gt;`、`&#39;`、`&quot;`。<EOL> * @example encodeHTML(\"<a></a>\") // \"&lt;a&gt;&lt;/a&gt;\"<EOL> */<EOL>export function encodeHTML(value: string) {<EOL>    return value.replace(/[&<>'\"]/g, c => ({<EOL>        \"<STR_LIT>\": \"<STR_LIT>\",<EOL>","gt":"\"<STR_LIT>\": \"<STR_LIT>\","}
{"input":"<s> export function emptyTest() {<EOL>    assert.ok(","gt":"func.empty);"}
{"input":"<s> /**<EOL>* 检索简繁体表进行转换。<EOL>* @param value 要转换的中文。<EOL>* @param from 源表。<EOL>* @param to 目标表。<EOL>*/<EOL>function convert(value: string, from: string, to: string) {<EOL>    const chars: string[] = [];<EOL>    for (let i = <NUM_LIT>; i < value.length; i++) {<EOL>        let c = value.charAt(i);<EOL>        const p = from.","gt":"indexOf(c);"}
{"input":"<s> /**<EOL>* 检索简繁体表进行转换。<EOL>* @param value 要转换的中文。<EOL>* @param from 源表。<EOL>* @param to 目标表。<EOL>*/<EOL>function convert(value: string, from: string, to: string) {<EOL>    const chars: string[] = [];<EOL>    for (let i = <NUM_LIT>; i < value.length; i++) {<EOL>        let c = value.charAt(i);<EOL>        const p = from.indexOf(c);<EOL>        if (p >= <NUM_LIT>) {<EOL>            c = to.charAt(p);<EOL>        }<EOL>        chars.push(","gt":"c);"}
{"input":"<s> /**<EOL> * 获取元素的状态。<EOL> * @param elem 要获取的元素。<EOL> * @param prefix CSS 类名前缀。<EOL> * @return 返回状态。<EOL> */<EOL>export function getStatus(elem: HTMLElement, prefix: string) {<EOL>    for (const state of [\"<STR_LIT>\", \"<STR_LIT>\", \"<STR_LIT>\", \"<STR_LIT>\"]) {<EOL>        if (dom.hasClass(elem,","gt":"prefix}${state}`<STR_LIT>{"}
{"input":"<s> /**<EOL> * 预加载一个地址的资源。<EOL> * @param url 图片地址。<EOL> * @example preload(\"../../../assets/resources/200x150.png\")<EOL> */<EOL>function preload(url: string) {<EOL>    new Image().src =","gt":"url;"}
{"input":"<s> /**<EOL> * 获取单个中文字符的拼音。<EOL> * @param value 要获取的单个中文字符。<EOL> * @return 返回对应的所有拼音。如果无法获取则返回空数组。<EOL> */<EOL>export function getPinYinOfChar(value: string) {<EOL>    const result: string[] = [];<EOL>    for (const pinyin in dict) {<EOL>","gt":"if (dict[pinyin].indexOf(value) >= <NUM_LIT>) {"}
{"input":"<s> export function parseQueryTest() {<EOL>    assert.deepEqual(query.parseQuery(\"<STR_LIT>\"), {","gt":"foo: \"<STR_LIT>\", goo: [\"<STR_LIT>\", \"<STR_LIT>\"] });"}
{"input":"<s> /**<EOL> * 格式化指定的字符串。<EOL> * @param formatString 格式字符串。具体见下文。<EOL> * @param args 格式化参数。<EOL> * @return 返回格式化后的字符串。<EOL> * @desc<EOL> * 格式字符串中，以下内容会被替换：<EOL> *<EOL> * 元字符   | 意义      | 示例<EOL> * --------|-----------|--------<EOL> * {数字}   | 替换为参数列表 | 如 `String.format(\"{0}年{1}月{2}日\", 2012, 12, 3)` 中，{0} 被替换成 2012，{1} 被替换成 12 ，依次类推。<EOL> * {字符串} | 替换为参数对象 | 如 `String.format(\"{year}年{month} 月 \", {year: 2012, month:12})`。<EOL> * {{      | 被替换为 { |<EOL> * }}      | 被替换为 } |<EOL> *<EOL> * @example format(\"我是{0}，不是{1}\", \"小黑\", \"大白\") // \"我是小黑，不是大白\"<EOL> * @example format(\"我是{xiaohei}，不是{dabai}\", {xiaohei: \"小黑\", dabai: \"大白\"}) // \"我是小黑，不是大白\"<EOL> * @example format(\"在字符串内使用两个{{和}}避免被转换\") //  \"在字符串内使用两个{和}避免被转换\"<EOL> */<EOL>export function format(formatString: string, ...args: any[]) {<EOL>    return formatString ? formatString.replace(/\\{\\{|\\{(.+?)\\}|\\}\\}/g, (source: string, argName: string) => {<EOL>        if (argName == undefined) {<EOL>","gt":"return source.charAt(<NUM_LIT>);"}
{"input":"<s> export function md5Test() {<EOL>    assert.","gt":"strictEqual(md5(\"<STR_LIT>\"), \"<STR_LIT>\");"}
{"input":"<s> export function wrappedError(message: string, originalError: any): Error {<EOL>    const msg = `<STR_LIT>`;<EOL>    const error =","gt":"Error(msg);"}
{"input":"<s> function isIdentifierPart(target: number): boolean {<EOL>    return (chars.isAsciiLetter(target) ||<EOL>","gt":"target == chars.$BACKSLASH ||"}
{"input":"<s> <EOL>export function cons() {<EOL>","gt":"return console;"}
{"input":"<s> function getEntryFromFiles(parts: string[], files: Entry) {<EOL>    let current = files;<EOL>    while (parts.length) {<EOL>        const part = parts.shift()!;<EOL>        if (","gt":"typeof current === '<STR_LIT>') {"}
{"input":"<s> /**<EOL> * 对类数组进行快速排序。<EOL> * @param iteratable 要排序的类数组。<EOL> * @param comparer 用于排序时确定优先级的函数。函数的参数为：<EOL> * - x：比较的第一个参数。<EOL> * - y：比较的第二个参数。<EOL> * - 如果返回 true，则说明 *x* 应该排在 *y* 之前。否则 *x* 应该排在 *y* 之后。<EOL> * @param start 开始排序的索引。<EOL> * @param end 结束排序的索引。<EOL> * @desc 快速排序不是稳定排序算法。<EOL> * @example quickSort([1, 3, 5, 4, 3]) // [1, 3, 3, 4, 5]<EOL>*/<EOL>export function quickSort<T>(iteratable: ArrayList<T>, comparer = (x: T, y: T) => x < y, start = <NUM_LIT>, end = iteratable.length) {<EOL>    if (start < end) {<EOL>        const t = iteratable[start];<EOL>        let low = start;<EOL>        let high = end;<EOL>","gt":"do {"}
{"input":"<s> /**<EOL> * 对类数组进行快速排序。<EOL> * @param iteratable 要排序的类数组。<EOL> * @param comparer 用于排序时确定优先级的函数。函数的参数为：<EOL> * - x：比较的第一个参数。<EOL> * - y：比较的第二个参数。<EOL> * - 如果返回 true，则说明 *x* 应该排在 *y* 之前。否则 *x* 应该排在 *y* 之后。<EOL> * @param start 开始排序的索引。<EOL> * @param end 结束排序的索引。<EOL> * @desc 快速排序不是稳定排序算法。<EOL> * @example quickSort([1, 3, 5, 4, 3]) // [1, 3, 3, 4, 5]<EOL>*/<EOL>export function quickSort<T>(iteratable: ArrayList<T>, comparer = (x: T, y: T) => x < y, start = <NUM_LIT>, end = iteratable.length) {<EOL>    if (start < end) {<EOL>        const t = iteratable[start];<EOL>        let low = start;<EOL>        let high = end;<EOL>        do {<EOL>            while (high > low && !comparer(iteratable[high], t)) {<EOL>                high--;<EOL>            }<EOL>            if (low < high) {<EOL>                iteratable[low++] = iteratable[high];<EOL>            }<EOL>            while (low < high && comparer(iteratable[low], t)) {<EOL>","gt":"low++;"}
{"input":"<s> /**<EOL> * 对类数组进行快速排序。<EOL> * @param iteratable 要排序的类数组。<EOL> * @param comparer 用于排序时确定优先级的函数。函数的参数为：<EOL> * - x：比较的第一个参数。<EOL> * - y：比较的第二个参数。<EOL> * - 如果返回 true，则说明 *x* 应该排在 *y* 之前。否则 *x* 应该排在 *y* 之后。<EOL> * @param start 开始排序的索引。<EOL> * @param end 结束排序的索引。<EOL> * @desc 快速排序不是稳定排序算法。<EOL> * @example quickSort([1, 3, 5, 4, 3]) // [1, 3, 3, 4, 5]<EOL>*/<EOL>export function quickSort<T>(iteratable: ArrayList<T>, comparer = (x: T, y: T) => x < y, start = <NUM_LIT>, end = iteratable.length) {<EOL>    if (start < end) {<EOL>        const t = iteratable[start];<EOL>        let low = start;<EOL>        let high = end;<EOL>        do {<EOL>            while (high > low && !comparer(iteratable[high], t)) {<EOL>                high--;<EOL>            }<EOL>            if (low < high) {<EOL>                iteratable[low++] = iteratable[high];<EOL>            }<EOL>            while (low < high && comparer(iteratable[low], t)) {<EOL>                low++;<EOL>            }<EOL>            if (low < high) {<EOL>                iteratable[high--] = iteratable[low];<EOL>            }<EOL>        }","gt":"while (low < high);"}
{"input":"<s> /**<EOL> * 判断一个对象是否是字符串。<EOL> * @param obj 要判断的对象。<EOL> * @return 如果 obj 是字符串则返回 true，否则返回 false。<EOL> * @example isString(\"\") // true<EOL> */<EOL>export function isString(obj: any): obj is string {<EOL>    return typeof","gt":"obj === \"<STR_LIT>\";"}
{"input":"<s> function isValidStyleFunctionCharacter(code: number): boolean {<EOL>    switch (code) {<EOL>        case chars.$PERIOD:<EOL>        case chars.$MINUS:<EOL>        case","gt":"chars.$PLUS:"}
{"input":"<s> function isValidStyleFunctionCharacter(code: number): boolean {<EOL>    switch (code) {<EOL>        case chars.$PERIOD:<EOL>        case chars.$MINUS:<EOL>        case chars.$PLUS:<EOL>        case chars.$STAR:<EOL>        case chars.$SLASH:<EOL>        case chars.$LPAREN:<EOL>        case chars.$RPAREN:<EOL>        case chars.$COMMA:<EOL>            return","gt":"true;"}
{"input":"<s> function joinGame(g: NowPlayingGame) {<EOL>    lastJoined = g;<EOL>    positionsCache.set(g.fullId, { fen: g.fen,","gt":"orientation: g.color });"}
{"input":"<s> export function convertRuleOptions(ruleConfiguration: Map<string, Partial<IOptions>>): IOptions[] {<EOL>    const output: IOptions[] = [];<EOL>    ruleConfiguration.forEach(({ ruleArguments, ruleSeverity }, ruleName) => {<EOL>        const options: IOptions = {<EOL>","gt":"disabledIntervals: [],"}
{"input":"<s> export function convertRuleOptions(ruleConfiguration: Map<string, Partial<IOptions>>): IOptions[] {<EOL>    const output: IOptions[] = [];<EOL>    ruleConfiguration.forEach(({ ruleArguments, ruleSeverity }, ruleName) => {<EOL>        const options: IOptions = {<EOL>            disabledIntervals: [],<EOL>            ruleArguments: ruleArguments !== null ? ruleArguments : [],<EOL>            ruleName,<EOL>            ruleSeverity: ruleSeverity !== null ? ruleSeverity : '<STR_LIT>',<EOL>        };<EOL>        output.push(","gt":"options);"}
{"input":"<s> function getPageElts() {<EOL>    return {<EOL>        heroes: element.","gt":"all(by.css('<STR_LIT>')),"}
{"input":"<s> function testControlled() {<EOL>    var o: Rx.Observable<string>;<EOL>","gt":"var c = o.controlled();"}
{"input":"<s> function getEngine(version: IRawGalleryExtensionVersion): string {<EOL>    const values = version.properties ?","gt":"version.properties.filter(p => p.key === PropertyType.Engine) : [];"}
{"input":"<s> <EOL><EOL>function* watchLoadMembersRequest() {<EOL>    while (","gt":"true) {"}
{"input":"<s> export function currentTournaments(): Promise<TournamentLists> {<EOL>    return fetchJSON('<STR_LIT>', {},","gt":"true);"}
{"input":"<s> export function loadPage(id: string, p: number): Promise<StandingPage> {<EOL>    return fetchJSON('<STR_LIT>' + id +","gt":"'<STR_LIT>' + p);"}
{"input":"<s> export function unselect(state: State): void {<EOL>","gt":"state.selected = null;"}
{"input":"<s> export function getRelativePathBetweenNodes(base: ObjectNode, target: ObjectNode): string {<EOL>    <EOL>    if (base.root !== target.root)<EOL>        fail(`<STR_LIT>`);<EOL>    const baseParts = splitJsonPath(base.path);<EOL>    const targetParts = splitJsonPath(target.","gt":"path);"}
{"input":"<s> export function getRelativePathBetweenNodes(base: ObjectNode, target: ObjectNode): string {<EOL>    <EOL>    if (base.root !== target.root)<EOL>        fail(`<STR_LIT>`);<EOL>    const baseParts = splitJsonPath(base.path);<EOL>    const targetParts = splitJsonPath(target.path);<EOL>    let common = <NUM_LIT>;<EOL>    for (; common < baseParts.length; common++) {<EOL>        if (baseParts[common] !== targetParts[common])<EOL>","gt":"break;"}
{"input":"<s> export function getRelativePathBetweenNodes(base: ObjectNode, target: ObjectNode): string {<EOL>    <EOL>    if (base.root !== target.root)<EOL>        fail(`<STR_LIT>`);<EOL>    const baseParts = splitJsonPath(base.path);<EOL>    const targetParts = splitJsonPath(target.path);<EOL>    let common = <NUM_LIT>;<EOL>    for (; common < baseParts.length; common++) {<EOL>        if (baseParts[common] !== targetParts[common])<EOL>            break;<EOL>    }<EOL>    <EOL>","gt":"return (baseParts"}
{"input":"<s> function init() {<EOL>    maxDepth = getIntParameter('<STR_LIT>');<EOL>","gt":"treeCreateCount = <NUM_LIT>;"}
{"input":"<s> export function decoratorArgument(dec: ts.Decorator): Maybe<ts.ObjectLiteralExpression> {<EOL>","gt":"return Maybe.lift(dec)"}
{"input":"<s> function chainedMessage(chain: DiagnosticMessageChain, indent = '<STR_LIT>'): string {<EOL>    return indent + chain.message + (chain.next ? chainedMessage(chain.next, indent +","gt":"'<STR_LIT>') : '<STR_LIT>');"}
{"input":"<s> function renderBody(ctrl: IImporterCtrl) {<EOL>    return h('<STR_LIT>', [<EOL>        h('<STR_LIT>', '<STR_LIT>'),<EOL>        h('<STR_LIT>', {<EOL>            onsubmit: (e: Event) => {<EOL>                e.preventDefault();<EOL>","gt":"const target = e.target as HTMLFormElement;"}
{"input":"<s> function renderBody(ctrl: IImporterCtrl) {<EOL>    return h('<STR_LIT>', [<EOL>        h('<STR_LIT>', '<STR_LIT>'),<EOL>        h('<STR_LIT>', {<EOL>            onsubmit: (e: Event) => {<EOL>                e.preventDefault();<EOL>                const target = e.target as HTMLFormElement;<EOL>                const pgn: string = target[<NUM_LIT>].value;<EOL>                if (pgn)<EOL>                    ctrl.importGame(pgn);<EOL>            }<EOL>        }, [<EOL>            h('<STR_LIT>', i18n('<STR_LIT>') + '<STR_LIT>'),<EOL>            h('<STR_LIT>'),<EOL>            formWidgets.renderCheckbox(i18n('<STR_LIT>'), '<STR_LIT>',","gt":"settings.importer.analyse),"}
{"input":"<s> function login(username: string, password: string): Promise<Session | LobbyData> {<EOL>    return fetchJSON('<STR_LIT>', {<EOL>        method: '<STR_LIT>',<EOL>        body: JSON.stringify({<EOL>            username,<EOL>            password<EOL>        })<EOL>    }, true)<EOL>        .then((data: Session | LobbyData) => {<EOL>        if (isSession(data)) {<EOL>            session = <Session>","gt":"data;"}
{"input":"<s> export function TemplateSrvStub() {<EOL>    this.variables = [];<EOL>    this.templateSettings = { interpolate: /\\[\\[([\\s\\S]+?)\\]\\]/g };<EOL>    this.data = {};<EOL>    this.replace = function (text) {<EOL>        return _.template(text, this.templateSettings)(","gt":"this.data);"}
{"input":"<s> export function TemplateSrvStub() {<EOL>    this.variables = [];<EOL>    this.templateSettings = { interpolate: /\\[\\[([\\s\\S]+?)\\]\\]/g };<EOL>    this.data = {};<EOL>    this.replace = function (text) {<EOL>        return _.template(text, this.templateSettings)(this.data);<EOL>    };<EOL>    this.init =","gt":"function () { };"}
{"input":"<s> export function TemplateSrvStub() {<EOL>    this.variables = [];<EOL>    this.templateSettings = { interpolate: /\\[\\[([\\s\\S]+?)\\]\\]/g };<EOL>    this.data = {};<EOL>    this.replace = function (text) {<EOL>        return _.template(text, this.templateSettings)(this.data);<EOL>    };<EOL>    this.init = function () { };<EOL>    this.getAdhocFilters = function () {<EOL>        return [];<EOL>    };<EOL>    this.fillVariableValuesForUrl = function () { };<EOL>","gt":"this.updateTemplateData = function () { };"}
{"input":"<s> export function TemplateSrvStub() {<EOL>    this.variables = [];<EOL>    this.templateSettings = { interpolate: /\\[\\[([\\s\\S]+?)\\]\\]/g };<EOL>    this.data = {};<EOL>    this.replace = function (text) {<EOL>        return _.template(text, this.templateSettings)(this.data);<EOL>    };<EOL>    this.init = function () { };<EOL>    this.getAdhocFilters = function () {<EOL>        return [];<EOL>    };<EOL>    this.fillVariableValuesForUrl = function () { };<EOL>    this.updateTemplateData = function () { };<EOL>    this.variableExists = function () {<EOL>        return false;<EOL>    };<EOL>    this.variableInitialized = function () { };<EOL>","gt":"this.highlightVariablesAsHtml = function (str) {"}
{"input":"<s> function objectTypeToString(this: any) {<EOL>    return getStateTreeNode(","gt":"this).toString();"}
{"input":"<s> function refresh(): void {<EOL>    fetchJSON<Session>('<STR_LIT>')<EOL>        .then((data: Session) => {<EOL>        session = data;<EOL>        storeSession(data);<EOL>        <EOL>        if (","gt":"session.nbChallenges !== challengesApi.incoming().length) {"}
{"input":"<s> function refresh(): void {<EOL>    fetchJSON<Session>('<STR_LIT>')<EOL>        .then((data: Session) => {<EOL>        session = data;<EOL>        storeSession(data);<EOL>        <EOL>        if (session.nbChallenges !== challengesApi.incoming().length) {<EOL>            challengesApi.refresh().then(redraw);<EOL>        }<EOL>        redraw();<EOL>    })<EOL>        .catch((","gt":"err: ErrorResponse) => {"}
{"input":"<s> function refresh(): void {<EOL>    fetchJSON<Session>('<STR_LIT>')<EOL>        .then((data: Session) => {<EOL>        session = data;<EOL>        storeSession(data);<EOL>        <EOL>        if (session.nbChallenges !== challengesApi.incoming().length) {<EOL>            challengesApi.refresh().then(redraw);<EOL>        }<EOL>        redraw();<EOL>    })<EOL>        .catch((err: ErrorResponse) => {<EOL>        if (session !== undefined && err.status === <NUM_LIT>) {<EOL>            session = undefined;<EOL>            clearStoredSession();<EOL>","gt":"redraw();"}
{"input":"<s> /**<EOL> * Returns the current date time as epoch number.<EOL> * The date time is read from an observable which is updated automatically after the given interval.<EOL> * So basically it treats time as an observable.<EOL> *<EOL> * The function takes an interval as parameter, which indicates how often `now()` will return a new value.<EOL> * If no interval is given, it will update each second. If \"frame\" is specified, it will update each time a<EOL> * `requestAnimationFrame` is available.<EOL> *<EOL> * Multiple clocks with the same interval will automatically be synchronized.<EOL> *<EOL> * Countdown example: https://jsfiddle.net/mweststrate/na0qdmkw/<EOL> *<EOL> * @example<EOL> *<EOL> * const start = Date.now()<EOL> *<EOL> * autorun(() => {<EOL> *   console.log(\"Seconds elapsed: \", (mobxUtils.now() - start) / 1000)<EOL> * })<EOL> *<EOL> *<EOL> * @export<EOL> * @param {(number | \"frame\")} [interval=1000] interval in milliseconds about how often the interval should update<EOL> * @returns<EOL> */<EOL>export function now(interval: number | \"<STR_LIT>\" = <NUM_LIT>) {<EOL>    if (!extras.isComputingDerivation()) {<EOL>        <EOL>        return Date.now();<EOL>    }<EOL>    if (!tickers[interval]) {<EOL>        if (typeof interval === \"<STR_LIT>\")<EOL>            tickers[interval] = createIntervalTicker(interval);<EOL>        else<EOL>            tickers[","gt":"interval] = createAnimationFrameTicker();"}
{"input":"<s> export function nbMoves(data: OnlineGameData, color: Color) {<EOL>    return Math.floor((data.game.turns + (color === '<STR_LIT>' ?","gt":"<NUM_LIT> : <NUM_LIT>)) / <NUM_LIT>);"}
{"input":"<s> export function isObjectType(type: any): type is ModelType<any, any> {<EOL>    return isType(type) && (type.flags & TypeFlags.Object) >","gt":"<NUM_LIT>;"}
{"input":"<s> function codegen(ngOptions: AngularCompilerOptions, cliOptions: NgcCliOptions, program: ts.Program, host: ts.CompilerHost) {<EOL>    return CodeGenerator.create(ngOptions, cliOptions, program, host).codegen({","gt":"transitiveModules: true });"}
{"input":"<s> export function autoScroll(movelist: HTMLElement | null) {<EOL>    if (!movelist)<EOL>        return;<EOL>    requestAnimationFrame(() => {<EOL>        const plyEl = (movelist.querySelector('<STR_LIT>') ||","gt":"movelist.querySelector('<STR_LIT>')) as HTMLElement;"}
{"input":"<s> export function autoScroll(movelist: HTMLElement | null) {<EOL>    if (!movelist)<EOL>        return;<EOL>    requestAnimationFrame(() => {<EOL>        const plyEl = (movelist.querySelector('<STR_LIT>') || movelist.querySelector('<STR_LIT>')) as HTMLElement;<EOL>        if (plyEl) {<EOL>            movelist.scrollTop = plyEl.offsetTop - movelist.offsetHeight / <NUM_LIT> + plyEl.offsetHeight / <NUM_LIT>;<EOL>        }<EOL>        else {<EOL>","gt":"movelist.scrollTop = <NUM_LIT>;"}
{"input":"<s> /**<EOL> * Performs a depth first walk through a tree<EOL> */<EOL>export function walk(target: IStateTreeNode, processor: (item: IStateTreeNode) => void) {<EOL>    <EOL>    if (process.env.NODE_ENV !== \"<STR_LIT>\") {<EOL>        if (!isStateTreeNode(target))<EOL>            fail(\"<STR_LIT>\" + target + \"<STR_LIT>\");<EOL>        if (typeof","gt":"processor !== \"<STR_LIT>\")"}
{"input":"<s> /**<EOL> * Performs a depth first walk through a tree<EOL> */<EOL>export function walk(target: IStateTreeNode, processor: (item: IStateTreeNode) => void) {<EOL>    <EOL>    if (process.env.NODE_ENV !== \"<STR_LIT>\") {<EOL>        if (!isStateTreeNode(target))<EOL>            fail(\"<STR_LIT>\" + target + \"<STR_LIT>\");<EOL>        if (typeof processor !== \"<STR_LIT>\")<EOL>            fail(\"<STR_LIT>\" + processor + \"<STR_LIT>\");<EOL>    }<EOL>    const node = getStateTreeNode(target);<EOL>    <EOL>    node.getChildren().forEach(child => {<EOL>","gt":"if (isStateTreeNode(child.storedValue))"}
{"input":"<s> export function removeTest() {<EOL>    const foo = [<NUM_LIT>, <NUM_LIT>, <NUM_LIT>, <NUM_LIT>];<EOL>    assert.strictEqual(array.remove(foo, <NUM_LIT>), <NUM_LIT>);<EOL>    assert.deepEqual(foo, [<NUM_LIT>,","gt":"<NUM_LIT>, <NUM_LIT>]);"}
{"input":"<s> function throwUncaught() {<EOL>    var","gt":"e = new Error('<STR_LIT>');"}
{"input":"<s> function createStore() {<EOL>    return Store.create({<EOL>        boxes: {<EOL>            cc: { id: \"<STR_LIT>\",","gt":"name: \"<STR_LIT>\", x: <NUM_LIT>, y: <NUM_LIT> },"}
{"input":"<s> function filterRelevantStuff(stuff: any): any {<EOL>    return stuff.map(x => {<EOL>","gt":"delete x.context;"}
{"input":"<s> function stubPlugin(): Plugin {<EOL>    return {<EOL>        afterComplete: sinon.stub(),<EOL>        afterError: sinon.stub(),<EOL>        afterNext: sinon.stub(),<EOL>","gt":"afterSubscribe: sinon.stub(),"}
{"input":"<s> function stubPlugin(): Plugin {<EOL>    return {<EOL>        afterComplete: sinon.stub(),<EOL>        afterError: sinon.stub(),<EOL>        afterNext: sinon.stub(),<EOL>        afterSubscribe: sinon.stub(),<EOL>        afterUnsubscribe: sinon.stub(),<EOL>        beforeComplete: sinon.stub(),<EOL>        beforeError: sinon.stub(),<EOL>        beforeNext:","gt":"sinon.stub(),"}
{"input":"<s> function stubPlugin(): Plugin {<EOL>    return {<EOL>        afterComplete: sinon.stub(),<EOL>        afterError: sinon.stub(),<EOL>        afterNext: sinon.stub(),<EOL>        afterSubscribe: sinon.stub(),<EOL>        afterUnsubscribe: sinon.stub(),<EOL>        beforeComplete: sinon.stub(),<EOL>        beforeError: sinon.stub(),<EOL>        beforeNext: sinon.stub(),<EOL>        beforeSubscribe: sinon.stub(),<EOL>        beforeUnsubscribe: sinon.stub(),<EOL>        flush:","gt":"sinon.stub(),"}
{"input":"<s> export function isClientEval(ev: Tree.ServerEval | Tree.ClientEval): ev is Tree.ClientEval {<EOL>","gt":"return (ev as Tree.ClientEval).depth !== undefined;"}
{"input":"<s> export default function () {<EOL>    <EOL>    const pipeDir = join('<STR_LIT>', '<STR_LIT>');<EOL>    return ng('<STR_LIT>',","gt":"'<STR_LIT>', '<STR_LIT>')"}
{"input":"<s> export function generateUuid(): string {<EOL>    return v4().","gt":"asHex();"}
{"input":"<s> function SimpleClock(time: number, onFlag: () => void) {<EOL>    return IncrementClock(time,","gt":"<NUM_LIT>, onFlag);"}
{"input":"<s> export function getAvailableLanguages(): Promise<ReadonlyArray<[<EOL>    string,<EOL>    string<EOL>]>> {<EOL>","gt":"return loadLocalJsonFile('<STR_LIT>');"}
{"input":"<s> function shouldSpawnCliProcess(argv: ParsedArgs): boolean {<EOL>    return !!argv['<STR_LIT>']<EOL>        || !!argv[","gt":"'<STR_LIT>']"}
{"input":"<s> /** @ngInject */<EOL>export function unsavedChangesSrv($rootScope, $q, $location, $timeout, contextSrv, dashboardSrv, $window) {<EOL>    this.Tracker = Tracker;<EOL>    this.init =","gt":"function (dashboard, scope) {"}
{"input":"<s> export function create(options: {<EOL>    [key: string]: any;<EOL>    defaultLogger?: PartialLogger;<EOL>    defaultPlugins?: boolean;<EOL>    warning?: boolean;<EOL>} = {}): Spy {<EOL>    return new","gt":"SpyCore(options);"}
{"input":"<s> function loadFile(code: string): Promise<string> {<EOL>    return loadLocalJsonFile<StringMap>('<STR_LIT>' + code + '<STR_LIT>')<EOL>        .then(data => {<EOL>        lang = code;<EOL>","gt":"messages = data;"}
{"input":"<s> function loadFile(code: string): Promise<string> {<EOL>    return loadLocalJsonFile<StringMap>('<STR_LIT>' + code + '<STR_LIT>')<EOL>        .then(data => {<EOL>        lang = code;<EOL>        messages = data;<EOL>        return code;<EOL>    })<EOL>        .catch(error => {<EOL>        if (code === defaultCode)<EOL>","gt":"throw new Error(error);"}
{"input":"<s> export function serializeQueryParameters(obj: StringMap): string {<EOL>    let str = '<STR_LIT>';<EOL>    const keys = Object.keys(obj);<EOL>    keys.","gt":"forEach(key => {"}
{"input":"<s> /**<EOL> * 动态删除一个样式。<EOL> */<EOL>function removeCssRule(selector, styles, styleSheetName) {<EOL>","gt":"throw \"<STR_LIT>\";"}
{"input":"<s> export function toDeepIFileStat(provider: IFileSystemProvider, tuple: [<EOL>    URI,<EOL>    IStat<EOL>], to: URI[]): TPromise<IFileStat> {<EOL>    const trie = TernarySearchTree.forPaths<true>();<EOL>    trie.set(tuple[<NUM_LIT>].toString(), true);<EOL>","gt":"if (!isFalsyOrEmpty(to)) {"}
{"input":"<s> /**<EOL> * 弹跳渐变。<EOL> * @param x 要渐变的值。<EOL> * @return 返回渐变后的值。<EOL> */<EOL>export function bounce(x: number) {<EOL>    for (let i = <NUM_LIT>, j = <NUM_LIT>; <NUM_LIT>; i += j, j /= <NUM_LIT>) {<EOL>","gt":"if (x >= (<NUM_LIT> - <NUM_LIT> * i) / <NUM_LIT>) {"}
{"input":"<s> /**<EOL> * 获取指定路径的扩展名部分（包括点）。<EOL> * @param path 要处理的路径。<EOL> * @return 返回扩展名部分。<EOL> * @example Path.extname(\"e/a/b.txt\") // \".txt\"<EOL> */<EOL>export function extname(path: string) {<EOL>    return splitPath(path)[","gt":"<NUM_LIT>];"}
{"input":"<s> function resolveCommandHistory(configurationService: IConfigurationService): number {<EOL>    const config = <IWorkbenchQuickOpenConfiguration>configurationService.getValue();<EOL>    let commandHistory = config.workbench &&","gt":"config.workbench.commandPalette && config.workbench.commandPalette.history;"}
{"input":"<s> /**<EOL> * 获取指定地址的查询参数值。<EOL> * @param name 要获取的查询参数名。<EOL> * @param url 要处理的地址，默认为当前页面的地址。<EOL> * @return 返回查询参数值。如果获取不到则返回 null。<EOL> * @example getQuery(\"foo\", \"?foo=1\") // \"1\"<EOL> * @example getQuery(\"goo\", \"?foo=1\") // null<EOL> */<EOL>export function getQuery(name: string, url = location.href) {<EOL>    const match = /\\?([^#]*)/.exec(url);<EOL>    if (match) {<EOL>        const match2 = new RegExp(\"<STR_LIT>\" + encodeURIComponent(name).replace(/([\\-.*+?^${}()|[\\]\\/\\\\])/g,","gt":"\"<STR_LIT>\") + \"<STR_LIT>\", \"<STR_LIT>\").exec(match[<NUM_LIT>]);"}
{"input":"<s> export function decodeHTMLTest() {<EOL>    assert.strictEqual(html.decodeHTML(","gt":"\"<STR_LIT>\"), \"<STR_LIT>\");"}
{"input":"<s> export async function toStyleSheet(tokens: Tokens, osColorSchemes: OSColorSchemes) {<EOL>    if (!fs.existsSync(cssOutputDir)) {<EOL>        await fs.promises.mkdir(cssOutputDir, { recursive: true });<EOL>    }<EOL>","gt":"if (!fs.existsSync(sassOutputDir)) {"}
{"input":"<s> export async function toStyleSheet(tokens: Tokens, osColorSchemes: OSColorSchemes) {<EOL>    if (!fs.existsSync(cssOutputDir)) {<EOL>        await fs.promises.mkdir(cssOutputDir, { recursive: true });<EOL>    }<EOL>    if (!fs.existsSync(sassOutputDir)) {<EOL>        await fs.promises.mkdir(sassOutputDir, { recursive: true });<EOL>    }<EOL>    const staticCustomProperties = getStaticCustomProperties(tokens);<EOL>    const colorSchemeDeclarations = getColorSchemeDeclarations('<STR_LIT>', tokens, osColorSchemes);<EOL>    const defaultDeclarations = `<STR_LIT>`;<EOL>    const styles =","gt":"}}"}
{"input":"<s> /**<EOL> * 使用 MD5 算法加密指定字符串。<EOL> * @param value 要加密的字符串。<EOL> * @return 返回加密后的字符串，其中只包含小写字母。<EOL> * @example md5(\"a\") // \"0cc175b9c0f1b6a831c399e269772661\"<EOL> */<EOL>export default function md5(value: string) {<EOL>","gt":"return binaryToString(raw(value));"}
{"input":"<s> export function lastPly(d: OnlineGameData): number {<EOL>    return d.steps[","gt":"d.steps.length - <NUM_LIT>].ply;"}
{"input":"<s> export function inCircleTest() {<EOL>    assert.deepEqual(drawing.inCircle({ x: <NUM_LIT>, y: <NUM_LIT>, r: <NUM_LIT> }, { x: <NUM_LIT>, y: <NUM_LIT> }), true);<EOL>    assert.","gt":"deepEqual(drawing.inCircle({ x: <NUM_LIT>, y: <NUM_LIT>, r: <NUM_LIT> }, { x: <NUM_LIT>, y: <NUM_LIT> }), true);"}
{"input":"<s> export function compareDayTest() {<EOL>    assert.strictEqual(date.compareDay(new Date(<NUM_LIT>, <NUM_LIT>, <NUM_LIT>),","gt":"new Date(<NUM_LIT>, <NUM_LIT>, <NUM_LIT>)), <NUM_LIT>);"}
{"input":"<s> export function isChildOf(child: Tree.Path, parent: Tree.Path): boolean {<EOL>","gt":"return !!child && child.slice(<NUM_LIT>, -<NUM_LIT>) === parent;"}
{"input":"<s> /**<EOL> * 判断指定字符串是否表示一个身份证号。<EOL> * @param value 要判断的字符串。<EOL> * @return 如果符合条件则返回 true，否则返回 false。<EOL> * @example isChineseId(\"152500198909267865\") // true<EOL> */<EOL>export function isChineseId(value: string) {<EOL>","gt":"return /(^\\d{15}$)|(^\\d{18}$)|(^\\d{17}(\\d|X|x)$)/.test(value);"}
{"input":"<s> function renderBody() {<EOL>    return [<EOL>        h('<STR_LIT>', [<EOL>            h('<STR_LIT>', {<EOL>                oncreate: helper.ontapY(() =>","gt":"router.set('<STR_LIT>'))"}
{"input":"<s> function renderBody() {<EOL>    return [<EOL>        h('<STR_LIT>', [<EOL>            h('<STR_LIT>', {<EOL>                oncreate: helper.ontapY(() => router.set('<STR_LIT>'))<EOL>            }, i18n('<STR_LIT>')),<EOL>            h('<STR_LIT>', {<EOL>                oncreate: helper.ontapY(() => router.set('<STR_LIT>'))<EOL>            }, i18n('<STR_LIT>')),<EOL>            h('<STR_LIT>', {<EOL>                oncreate: helper.ontapY(() => router.","gt":"set('<STR_LIT>'))"}
{"input":"<s> <EOL>export function editorFormatText(document: TextDocument, srcText: string, srcPath: string, lineStart: number, lineEnd: number): Promise<TextEdit[]> {<EOL>    return new Promise<TextEdit[]>((resolve, reject) => {<EOL>        let tes: TextEdit[] = [];<EOL>        editorOpen(srcPath, srcText, false, false, true)<EOL>            .then((v) => {<EOL>            <EOL>","gt":"let p = requestEditorFormatText(srcPath, lineStart, <NUM_LIT>, document);"}
{"input":"<s> <EOL>export function editorFormatText(document: TextDocument, srcText: string, srcPath: string, lineStart: number, lineEnd: number): Promise<TextEdit[]> {<EOL>    return new Promise<TextEdit[]>((resolve, reject) => {<EOL>        let tes: TextEdit[] = [];<EOL>        editorOpen(srcPath, srcText, false, false, true)<EOL>            .then((v) => {<EOL>            <EOL>            let p = requestEditorFormatText(srcPath, lineStart, <NUM_LIT>, document);<EOL>            <EOL>            function nextp(fts: FormatTextState) {<EOL>                tes.push(fts.","gt":"textEdit);"}
{"input":"<s> <EOL>export function editorFormatText(document: TextDocument, srcText: string, srcPath: string, lineStart: number, lineEnd: number): Promise<TextEdit[]> {<EOL>    return new Promise<TextEdit[]>((resolve, reject) => {<EOL>        let tes: TextEdit[] = [];<EOL>        editorOpen(srcPath, srcText, false, false, true)<EOL>            .then((v) => {<EOL>            <EOL>            let p = requestEditorFormatText(srcPath, lineStart, <NUM_LIT>, document);<EOL>            <EOL>            function nextp(fts: FormatTextState) {<EOL>                tes.push(fts.textEdit);<EOL>                if (fts.line != lineEnd) {<EOL>                    let sPos: Position = { line: fts.line, character: <NUM_LIT> };<EOL>                    let ePos: Position = document.positionAt(document.offsetAt({ line: fts.","gt":"line + <NUM_LIT>, character: <NUM_LIT> }) - <NUM_LIT>);"}
{"input":"<s> <EOL>export function editorFormatText(document: TextDocument, srcText: string, srcPath: string, lineStart: number, lineEnd: number): Promise<TextEdit[]> {<EOL>    return new Promise<TextEdit[]>((resolve, reject) => {<EOL>        let tes: TextEdit[] = [];<EOL>        editorOpen(srcPath, srcText, false, false, true)<EOL>            .then((v) => {<EOL>            <EOL>            let p = requestEditorFormatText(srcPath, lineStart, <NUM_LIT>, document);<EOL>            <EOL>            function nextp(fts: FormatTextState) {<EOL>                tes.push(fts.textEdit);<EOL>                if (fts.line != lineEnd) {<EOL>                    let sPos: Position = { line: fts.line, character: <NUM_LIT> };<EOL>                    let ePos: Position = document.positionAt(document.offsetAt({ line: fts.line + <NUM_LIT>, character: <NUM_LIT> }) - <NUM_LIT>);<EOL>                    requestEditorFormatText(srcPath, fts.line + <NUM_LIT>, <NUM_LIT>, document)<EOL>                        .then(nextp)<EOL>                        .catch((err) => {<EOL>","gt":"reject(err);"}
{"input":"<s> export function isDateTest() {<EOL>    assert.","gt":"strictEqual(check.isDate(\"<STR_LIT>\"), true);"}
{"input":"<s> function textProp(elem: HTMLElement) {<EOL>    return /^(INPUT|SELECT|TEXTAREA)$/.test(elem.tagName) ?","gt":"\"<STR_LIT>\" : \"<STR_LIT>\";"}
{"input":"<s> /**<EOL> * 设置对象指定属性的值。<EOL> * @param obj 要设置的对象。<EOL> * @param prop 要设置的属性表达式。如 `a.b[0]`。<EOL> * @param value 要设置的值。<EOL> * @example set({}, \"a[1].b\", 2) // { a: [undefined, { b: 2 }]}<EOL> */<EOL>export function set(obj: any, prop: string, value: any) {<EOL>    let prevObject: any;<EOL>    let prevKey: string;<EOL>    prop.replace(/\\.?\\s*([^\\.\\[]+)|\\[\\s*([^\\]]*)\\s*\\]/g, ((source: string, propName: string | undefined, indexer: string | undefined, index: number) => {<EOL>        let currentObject = prevKey ?","gt":"prevObject[prevKey] : obj;"}
{"input":"<s> /**<EOL> * 设置对象指定属性的值。<EOL> * @param obj 要设置的对象。<EOL> * @param prop 要设置的属性表达式。如 `a.b[0]`。<EOL> * @param value 要设置的值。<EOL> * @example set({}, \"a[1].b\", 2) // { a: [undefined, { b: 2 }]}<EOL> */<EOL>export function set(obj: any, prop: string, value: any) {<EOL>    let prevObject: any;<EOL>    let prevKey: string;<EOL>    prop.replace(/\\.?\\s*([^\\.\\[]+)|\\[\\s*([^\\]]*)\\s*\\]/g, ((source: string, propName: string | undefined, indexer: string | undefined, index: number) => {<EOL>        let currentObject = prevKey ? prevObject[prevKey] : obj;<EOL>        if (currentObject == null) {<EOL>            currentObject = indexer ? [] : {};<EOL>","gt":"if (prevKey) {"}
{"input":"<s> /**<EOL> * 设置对象指定属性的值。<EOL> * @param obj 要设置的对象。<EOL> * @param prop 要设置的属性表达式。如 `a.b[0]`。<EOL> * @param value 要设置的值。<EOL> * @example set({}, \"a[1].b\", 2) // { a: [undefined, { b: 2 }]}<EOL> */<EOL>export function set(obj: any, prop: string, value: any) {<EOL>    let prevObject: any;<EOL>    let prevKey: string;<EOL>    prop.replace(/\\.?\\s*([^\\.\\[]+)|\\[\\s*([^\\]]*)\\s*\\]/g, ((source: string, propName: string | undefined, indexer: string | undefined, index: number) => {<EOL>        let currentObject = prevKey ? prevObject[prevKey] : obj;<EOL>        if (currentObject == null) {<EOL>            currentObject = indexer ? [] : {};<EOL>            if (prevKey) {<EOL>                prevObject[prevKey] = currentObject;<EOL>            }<EOL>            else {<EOL>                prevObject = obj =","gt":"currentObject;"}
{"input":"<s> /**<EOL> * 设置对象指定属性的值。<EOL> * @param obj 要设置的对象。<EOL> * @param prop 要设置的属性表达式。如 `a.b[0]`。<EOL> * @param value 要设置的值。<EOL> * @example set({}, \"a[1].b\", 2) // { a: [undefined, { b: 2 }]}<EOL> */<EOL>export function set(obj: any, prop: string, value: any) {<EOL>    let prevObject: any;<EOL>    let prevKey: string;<EOL>    prop.replace(/\\.?\\s*([^\\.\\[]+)|\\[\\s*([^\\]]*)\\s*\\]/g, ((source: string, propName: string | undefined, indexer: string | undefined, index: number) => {<EOL>        let currentObject = prevKey ? prevObject[prevKey] : obj;<EOL>        if (currentObject == null) {<EOL>            currentObject = indexer ? [] : {};<EOL>            if (prevKey) {<EOL>                prevObject[prevKey] = currentObject;<EOL>            }<EOL>            else {<EOL>                prevObject = obj = currentObject;<EOL>            }<EOL>        }<EOL>        prevObject = currentObject;<EOL>        prevKey = propName || indexer!;<EOL>        if (index + source.length ===","gt":"prop.length) {"}
{"input":"<s> /**<EOL> * 添加指定元素的 CSS 类名。<EOL> * @param elem 要处理的元素。<EOL> * @param className 要添加的 CSS 类名。<EOL> * @example addClass(document.body, \"light\")<EOL> */<EOL>export function addClass(elem: HTMLElement, className: string) {<EOL>    toggleClass(elem,","gt":"className, true);"}
{"input":"<s> export default function drawMoveTimesChart(element: SVGElement, aData: AnalyseData, moveCentis: number[], curPly: number) {<EOL>    const division = aData.game.division;<EOL>    const svg = select(element);<EOL>    const margin = { top: <NUM_LIT>, right: <NUM_LIT>, bottom: <NUM_LIT>, left: <NUM_LIT> };<EOL>    const width = +svg.attr('<STR_LIT>') - margin.left -","gt":"margin.right;"}
{"input":"<s> export default function drawMoveTimesChart(element: SVGElement, aData: AnalyseData, moveCentis: number[], curPly: number) {<EOL>    const division = aData.game.division;<EOL>    const svg = select(element);<EOL>    const margin = { top: <NUM_LIT>, right: <NUM_LIT>, bottom: <NUM_LIT>, left: <NUM_LIT> };<EOL>    const width = +svg.attr('<STR_LIT>') - margin.left - margin.right;<EOL>    const height = +svg.attr('<STR_LIT>') - margin.top - margin.bottom;<EOL>    const g = svg.append('<STR_LIT>').attr('<STR_LIT>', '<STR_LIT>' + margin.left + '<STR_LIT>' + margin.top + '<STR_LIT>');<EOL>    const { max, series } = makeSerieData(aData, moveCentis);<EOL>    function addDivisionLine(xPos:","gt":"number, name: string) {"}
{"input":"<s> export default function drawMoveTimesChart(element: SVGElement, aData: AnalyseData, moveCentis: number[], curPly: number) {<EOL>    const division = aData.game.division;<EOL>    const svg = select(element);<EOL>    const margin = { top: <NUM_LIT>, right: <NUM_LIT>, bottom: <NUM_LIT>, left: <NUM_LIT> };<EOL>    const width = +svg.attr('<STR_LIT>') - margin.left - margin.right;<EOL>    const height = +svg.attr('<STR_LIT>') - margin.top - margin.bottom;<EOL>    const g = svg.append('<STR_LIT>').attr('<STR_LIT>', '<STR_LIT>' + margin.left + '<STR_LIT>' + margin.top + '<STR_LIT>');<EOL>    const { max, series } = makeSerieData(aData, moveCentis);<EOL>    function addDivisionLine(xPos: number, name: string) {<EOL>        g.append('<STR_LIT>')<EOL>            .attr('<STR_LIT>', '<STR_LIT>' + name)<EOL>            .attr(","gt":"'<STR_LIT>', xPos)"}
{"input":"<s> export default function drawMoveTimesChart(element: SVGElement, aData: AnalyseData, moveCentis: number[], curPly: number) {<EOL>    const division = aData.game.division;<EOL>    const svg = select(element);<EOL>    const margin = { top: <NUM_LIT>, right: <NUM_LIT>, bottom: <NUM_LIT>, left: <NUM_LIT> };<EOL>    const width = +svg.attr('<STR_LIT>') - margin.left - margin.right;<EOL>    const height = +svg.attr('<STR_LIT>') - margin.top - margin.bottom;<EOL>    const g = svg.append('<STR_LIT>').attr('<STR_LIT>', '<STR_LIT>' + margin.left + '<STR_LIT>' + margin.top + '<STR_LIT>');<EOL>    const { max, series } = makeSerieData(aData, moveCentis);<EOL>    function addDivisionLine(xPos: number, name: string) {<EOL>        g.append('<STR_LIT>')<EOL>            .attr('<STR_LIT>', '<STR_LIT>' + name)<EOL>            .attr('<STR_LIT>', xPos)<EOL>            .attr('<STR_LIT>', xPos)<EOL>            .attr('<STR_LIT>', y(-max))<EOL>            .attr('<STR_LIT>', y(max));<EOL>        g.append('<STR_LIT>')<EOL>            .attr('<STR_LIT>',","gt":"'<STR_LIT>')"}
{"input":"<s> export default function drawMoveTimesChart(element: SVGElement, aData: AnalyseData, moveCentis: number[], curPly: number) {<EOL>    const division = aData.game.division;<EOL>    const svg = select(element);<EOL>    const margin = { top: <NUM_LIT>, right: <NUM_LIT>, bottom: <NUM_LIT>, left: <NUM_LIT> };<EOL>    const width = +svg.attr('<STR_LIT>') - margin.left - margin.right;<EOL>    const height = +svg.attr('<STR_LIT>') - margin.top - margin.bottom;<EOL>    const g = svg.append('<STR_LIT>').attr('<STR_LIT>', '<STR_LIT>' + margin.left + '<STR_LIT>' + margin.top + '<STR_LIT>');<EOL>    const { max, series } = makeSerieData(aData, moveCentis);<EOL>    function addDivisionLine(xPos: number, name: string) {<EOL>        g.append('<STR_LIT>')<EOL>            .attr('<STR_LIT>', '<STR_LIT>' + name)<EOL>            .attr('<STR_LIT>', xPos)<EOL>            .attr('<STR_LIT>', xPos)<EOL>            .attr('<STR_LIT>', y(-max))<EOL>            .attr('<STR_LIT>', y(max));<EOL>        g.append('<STR_LIT>')<EOL>            .attr('<STR_LIT>', '<STR_LIT>')<EOL>            .attr('<STR_LIT>', '<STR_LIT>')<EOL>            .attr(","gt":"'<STR_LIT>', -xPos)"}
{"input":"<s> export default function drawMoveTimesChart(element: SVGElement, aData: AnalyseData, moveCentis: number[], curPly: number) {<EOL>    const division = aData.game.division;<EOL>    const svg = select(element);<EOL>    const margin = { top: <NUM_LIT>, right: <NUM_LIT>, bottom: <NUM_LIT>, left: <NUM_LIT> };<EOL>    const width = +svg.attr('<STR_LIT>') - margin.left - margin.right;<EOL>    const height = +svg.attr('<STR_LIT>') - margin.top - margin.bottom;<EOL>    const g = svg.append('<STR_LIT>').attr('<STR_LIT>', '<STR_LIT>' + margin.left + '<STR_LIT>' + margin.top + '<STR_LIT>');<EOL>    const { max, series } = makeSerieData(aData, moveCentis);<EOL>    function addDivisionLine(xPos: number, name: string) {<EOL>        g.append('<STR_LIT>')<EOL>            .attr('<STR_LIT>', '<STR_LIT>' + name)<EOL>            .attr('<STR_LIT>', xPos)<EOL>            .attr('<STR_LIT>', xPos)<EOL>            .attr('<STR_LIT>', y(-max))<EOL>            .attr('<STR_LIT>', y(max));<EOL>        g.append('<STR_LIT>')<EOL>            .attr('<STR_LIT>', '<STR_LIT>')<EOL>            .attr('<STR_LIT>', '<STR_LIT>')<EOL>            .attr('<STR_LIT>', -xPos)<EOL>            .attr('<STR_LIT>', '<STR_LIT>')<EOL>            .text(name);<EOL>    }<EOL>    function setCurrentPly(ply: number | null) {<EOL>        g.selectAll('<STR_LIT>').remove();<EOL>        if (ply !== null) {<EOL>","gt":"const isWhite = !!(ply & <NUM_LIT>);"}
{"input":"<s> export default function drawMoveTimesChart(element: SVGElement, aData: AnalyseData, moveCentis: number[], curPly: number) {<EOL>    const division = aData.game.division;<EOL>    const svg = select(element);<EOL>    const margin = { top: <NUM_LIT>, right: <NUM_LIT>, bottom: <NUM_LIT>, left: <NUM_LIT> };<EOL>    const width = +svg.attr('<STR_LIT>') - margin.left - margin.right;<EOL>    const height = +svg.attr('<STR_LIT>') - margin.top - margin.bottom;<EOL>    const g = svg.append('<STR_LIT>').attr('<STR_LIT>', '<STR_LIT>' + margin.left + '<STR_LIT>' + margin.top + '<STR_LIT>');<EOL>    const { max, series } = makeSerieData(aData, moveCentis);<EOL>    function addDivisionLine(xPos: number, name: string) {<EOL>        g.append('<STR_LIT>')<EOL>            .attr('<STR_LIT>', '<STR_LIT>' + name)<EOL>            .attr('<STR_LIT>', xPos)<EOL>            .attr('<STR_LIT>', xPos)<EOL>            .attr('<STR_LIT>', y(-max))<EOL>            .attr('<STR_LIT>', y(max));<EOL>        g.append('<STR_LIT>')<EOL>            .attr('<STR_LIT>', '<STR_LIT>')<EOL>            .attr('<STR_LIT>', '<STR_LIT>')<EOL>            .attr('<STR_LIT>', -xPos)<EOL>            .attr('<STR_LIT>', '<STR_LIT>')<EOL>            .text(name);<EOL>    }<EOL>    function setCurrentPly(ply: number | null) {<EOL>        g.selectAll('<STR_LIT>').remove();<EOL>        if (ply !== null) {<EOL>            const isWhite = !!(ply & <NUM_LIT>);<EOL>            const p = isWhite ? series.white.find(p => p.ply === ply) : series.black.find(p => p.ply === ply);<EOL>            if (","gt":"p) {"}
{"input":"<s> export default function drawMoveTimesChart(element: SVGElement, aData: AnalyseData, moveCentis: number[], curPly: number) {<EOL>    const division = aData.game.division;<EOL>    const svg = select(element);<EOL>    const margin = { top: <NUM_LIT>, right: <NUM_LIT>, bottom: <NUM_LIT>, left: <NUM_LIT> };<EOL>    const width = +svg.attr('<STR_LIT>') - margin.left - margin.right;<EOL>    const height = +svg.attr('<STR_LIT>') - margin.top - margin.bottom;<EOL>    const g = svg.append('<STR_LIT>').attr('<STR_LIT>', '<STR_LIT>' + margin.left + '<STR_LIT>' + margin.top + '<STR_LIT>');<EOL>    const { max, series } = makeSerieData(aData, moveCentis);<EOL>    function addDivisionLine(xPos: number, name: string) {<EOL>        g.append('<STR_LIT>')<EOL>            .attr('<STR_LIT>', '<STR_LIT>' + name)<EOL>            .attr('<STR_LIT>', xPos)<EOL>            .attr('<STR_LIT>', xPos)<EOL>            .attr('<STR_LIT>', y(-max))<EOL>            .attr('<STR_LIT>', y(max));<EOL>        g.append('<STR_LIT>')<EOL>            .attr('<STR_LIT>', '<STR_LIT>')<EOL>            .attr('<STR_LIT>', '<STR_LIT>')<EOL>            .attr('<STR_LIT>', -xPos)<EOL>            .attr('<STR_LIT>', '<STR_LIT>')<EOL>            .text(name);<EOL>    }<EOL>    function setCurrentPly(ply: number | null) {<EOL>        g.selectAll('<STR_LIT>').remove();<EOL>        if (ply !== null) {<EOL>            const isWhite = !!(ply & <NUM_LIT>);<EOL>            const p = isWhite ? series.white.find(p => p.ply === ply) : series.black.find(p => p.ply === ply);<EOL>            if (p) {<EOL>                g.append('<STR_LIT>')<EOL>                    .attr('<STR_LIT>', '<STR_LIT>')<EOL>                    .attr('<STR_LIT>', x(ply))<EOL>                    .attr('<STR_LIT>', y(p.y))<EOL>                    .attr('<STR_LIT>', <NUM_LIT>);<EOL>            }<EOL>        }<EOL>    }<EOL>    const x = scaleLinear()<EOL>        .domain([<NUM_LIT>, series.white.","gt":"length + series.black.length])"}
{"input":"<s> export default function drawMoveTimesChart(element: SVGElement, aData: AnalyseData, moveCentis: number[], curPly: number) {<EOL>    const division = aData.game.division;<EOL>    const svg = select(element);<EOL>    const margin = { top: <NUM_LIT>, right: <NUM_LIT>, bottom: <NUM_LIT>, left: <NUM_LIT> };<EOL>    const width = +svg.attr('<STR_LIT>') - margin.left - margin.right;<EOL>    const height = +svg.attr('<STR_LIT>') - margin.top - margin.bottom;<EOL>    const g = svg.append('<STR_LIT>').attr('<STR_LIT>', '<STR_LIT>' + margin.left + '<STR_LIT>' + margin.top + '<STR_LIT>');<EOL>    const { max, series } = makeSerieData(aData, moveCentis);<EOL>    function addDivisionLine(xPos: number, name: string) {<EOL>        g.append('<STR_LIT>')<EOL>            .attr('<STR_LIT>', '<STR_LIT>' + name)<EOL>            .attr('<STR_LIT>', xPos)<EOL>            .attr('<STR_LIT>', xPos)<EOL>            .attr('<STR_LIT>', y(-max))<EOL>            .attr('<STR_LIT>', y(max));<EOL>        g.append('<STR_LIT>')<EOL>            .attr('<STR_LIT>', '<STR_LIT>')<EOL>            .attr('<STR_LIT>', '<STR_LIT>')<EOL>            .attr('<STR_LIT>', -xPos)<EOL>            .attr('<STR_LIT>', '<STR_LIT>')<EOL>            .text(name);<EOL>    }<EOL>    function setCurrentPly(ply: number | null) {<EOL>        g.selectAll('<STR_LIT>').remove();<EOL>        if (ply !== null) {<EOL>            const isWhite = !!(ply & <NUM_LIT>);<EOL>            const p = isWhite ? series.white.find(p => p.ply === ply) : series.black.find(p => p.ply === ply);<EOL>            if (p) {<EOL>                g.append('<STR_LIT>')<EOL>                    .attr('<STR_LIT>', '<STR_LIT>')<EOL>                    .attr('<STR_LIT>', x(ply))<EOL>                    .attr('<STR_LIT>', y(p.y))<EOL>                    .attr('<STR_LIT>', <NUM_LIT>);<EOL>            }<EOL>        }<EOL>    }<EOL>    const x = scaleLinear()<EOL>        .domain([<NUM_LIT>, series.white.length + series.black.length])<EOL>        .rangeRound([<NUM_LIT>, width]);<EOL>    const y = scaleLinear()<EOL>        .domain([-max, max])<EOL>        .rangeRound([height, <NUM_LIT>]);<EOL>    const line = d3Area<Point>()<EOL>        .x(d => x(d.ply))<EOL>        .y(d => y(d.y));<EOL>    const area = d3Area<Point>()<EOL>        .x(d => x(d.ply))<EOL>        .y0(y(<NUM_LIT>))<EOL>        .y1(","gt":"d => y(d.y));"}
{"input":"<s> export default function drawMoveTimesChart(element: SVGElement, aData: AnalyseData, moveCentis: number[], curPly: number) {<EOL>    const division = aData.game.division;<EOL>    const svg = select(element);<EOL>    const margin = { top: <NUM_LIT>, right: <NUM_LIT>, bottom: <NUM_LIT>, left: <NUM_LIT> };<EOL>    const width = +svg.attr('<STR_LIT>') - margin.left - margin.right;<EOL>    const height = +svg.attr('<STR_LIT>') - margin.top - margin.bottom;<EOL>    const g = svg.append('<STR_LIT>').attr('<STR_LIT>', '<STR_LIT>' + margin.left + '<STR_LIT>' + margin.top + '<STR_LIT>');<EOL>    const { max, series } = makeSerieData(aData, moveCentis);<EOL>    function addDivisionLine(xPos: number, name: string) {<EOL>        g.append('<STR_LIT>')<EOL>            .attr('<STR_LIT>', '<STR_LIT>' + name)<EOL>            .attr('<STR_LIT>', xPos)<EOL>            .attr('<STR_LIT>', xPos)<EOL>            .attr('<STR_LIT>', y(-max))<EOL>            .attr('<STR_LIT>', y(max));<EOL>        g.append('<STR_LIT>')<EOL>            .attr('<STR_LIT>', '<STR_LIT>')<EOL>            .attr('<STR_LIT>', '<STR_LIT>')<EOL>            .attr('<STR_LIT>', -xPos)<EOL>            .attr('<STR_LIT>', '<STR_LIT>')<EOL>            .text(name);<EOL>    }<EOL>    function setCurrentPly(ply: number | null) {<EOL>        g.selectAll('<STR_LIT>').remove();<EOL>        if (ply !== null) {<EOL>            const isWhite = !!(ply & <NUM_LIT>);<EOL>            const p = isWhite ? series.white.find(p => p.ply === ply) : series.black.find(p => p.ply === ply);<EOL>            if (p) {<EOL>                g.append('<STR_LIT>')<EOL>                    .attr('<STR_LIT>', '<STR_LIT>')<EOL>                    .attr('<STR_LIT>', x(ply))<EOL>                    .attr('<STR_LIT>', y(p.y))<EOL>                    .attr('<STR_LIT>', <NUM_LIT>);<EOL>            }<EOL>        }<EOL>    }<EOL>    const x = scaleLinear()<EOL>        .domain([<NUM_LIT>, series.white.length + series.black.length])<EOL>        .rangeRound([<NUM_LIT>, width]);<EOL>    const y = scaleLinear()<EOL>        .domain([-max, max])<EOL>        .rangeRound([height, <NUM_LIT>]);<EOL>    const line = d3Area<Point>()<EOL>        .x(d => x(d.ply))<EOL>        .y(d => y(d.y));<EOL>    const area = d3Area<Point>()<EOL>        .x(d => x(d.ply))<EOL>        .y0(y(<NUM_LIT>))<EOL>        .y1(d => y(d.y));<EOL>    const maxCentis = Math.max.apply(Math, moveCentis) / <NUM_LIT>;<EOL>    const legendScale = scaleLinear()<EOL>        .domain([-maxCentis, maxCentis])<EOL>        .rangeRound([height, <NUM_LIT>]);<EOL>    const yAxis =","gt":"axisLeft<number>(legendScale)"}
{"input":"<s> export default function drawMoveTimesChart(element: SVGElement, aData: AnalyseData, moveCentis: number[], curPly: number) {<EOL>    const division = aData.game.division;<EOL>    const svg = select(element);<EOL>    const margin = { top: <NUM_LIT>, right: <NUM_LIT>, bottom: <NUM_LIT>, left: <NUM_LIT> };<EOL>    const width = +svg.attr('<STR_LIT>') - margin.left - margin.right;<EOL>    const height = +svg.attr('<STR_LIT>') - margin.top - margin.bottom;<EOL>    const g = svg.append('<STR_LIT>').attr('<STR_LIT>', '<STR_LIT>' + margin.left + '<STR_LIT>' + margin.top + '<STR_LIT>');<EOL>    const { max, series } = makeSerieData(aData, moveCentis);<EOL>    function addDivisionLine(xPos: number, name: string) {<EOL>        g.append('<STR_LIT>')<EOL>            .attr('<STR_LIT>', '<STR_LIT>' + name)<EOL>            .attr('<STR_LIT>', xPos)<EOL>            .attr('<STR_LIT>', xPos)<EOL>            .attr('<STR_LIT>', y(-max))<EOL>            .attr('<STR_LIT>', y(max));<EOL>        g.append('<STR_LIT>')<EOL>            .attr('<STR_LIT>', '<STR_LIT>')<EOL>            .attr('<STR_LIT>', '<STR_LIT>')<EOL>            .attr('<STR_LIT>', -xPos)<EOL>            .attr('<STR_LIT>', '<STR_LIT>')<EOL>            .text(name);<EOL>    }<EOL>    function setCurrentPly(ply: number | null) {<EOL>        g.selectAll('<STR_LIT>').remove();<EOL>        if (ply !== null) {<EOL>            const isWhite = !!(ply & <NUM_LIT>);<EOL>            const p = isWhite ? series.white.find(p => p.ply === ply) : series.black.find(p => p.ply === ply);<EOL>            if (p) {<EOL>                g.append('<STR_LIT>')<EOL>                    .attr('<STR_LIT>', '<STR_LIT>')<EOL>                    .attr('<STR_LIT>', x(ply))<EOL>                    .attr('<STR_LIT>', y(p.y))<EOL>                    .attr('<STR_LIT>', <NUM_LIT>);<EOL>            }<EOL>        }<EOL>    }<EOL>    const x = scaleLinear()<EOL>        .domain([<NUM_LIT>, series.white.length + series.black.length])<EOL>        .rangeRound([<NUM_LIT>, width]);<EOL>    const y = scaleLinear()<EOL>        .domain([-max, max])<EOL>        .rangeRound([height, <NUM_LIT>]);<EOL>    const line = d3Area<Point>()<EOL>        .x(d => x(d.ply))<EOL>        .y(d => y(d.y));<EOL>    const area = d3Area<Point>()<EOL>        .x(d => x(d.ply))<EOL>        .y0(y(<NUM_LIT>))<EOL>        .y1(d => y(d.y));<EOL>    const maxCentis = Math.max.apply(Math, moveCentis) / <NUM_LIT>;<EOL>    const legendScale = scaleLinear()<EOL>        .domain([-maxCentis, maxCentis])<EOL>        .rangeRound([height, <NUM_LIT>]);<EOL>    const yAxis = axisLeft<number>(legendScale)<EOL>        .tickFormat(d => String(Math.abs(d)));<EOL>    g.append('<STR_LIT>')<EOL>        .call(","gt":"yAxis)"}
{"input":"<s> export default function drawMoveTimesChart(element: SVGElement, aData: AnalyseData, moveCentis: number[], curPly: number) {<EOL>    const division = aData.game.division;<EOL>    const svg = select(element);<EOL>    const margin = { top: <NUM_LIT>, right: <NUM_LIT>, bottom: <NUM_LIT>, left: <NUM_LIT> };<EOL>    const width = +svg.attr('<STR_LIT>') - margin.left - margin.right;<EOL>    const height = +svg.attr('<STR_LIT>') - margin.top - margin.bottom;<EOL>    const g = svg.append('<STR_LIT>').attr('<STR_LIT>', '<STR_LIT>' + margin.left + '<STR_LIT>' + margin.top + '<STR_LIT>');<EOL>    const { max, series } = makeSerieData(aData, moveCentis);<EOL>    function addDivisionLine(xPos: number, name: string) {<EOL>        g.append('<STR_LIT>')<EOL>            .attr('<STR_LIT>', '<STR_LIT>' + name)<EOL>            .attr('<STR_LIT>', xPos)<EOL>            .attr('<STR_LIT>', xPos)<EOL>            .attr('<STR_LIT>', y(-max))<EOL>            .attr('<STR_LIT>', y(max));<EOL>        g.append('<STR_LIT>')<EOL>            .attr('<STR_LIT>', '<STR_LIT>')<EOL>            .attr('<STR_LIT>', '<STR_LIT>')<EOL>            .attr('<STR_LIT>', -xPos)<EOL>            .attr('<STR_LIT>', '<STR_LIT>')<EOL>            .text(name);<EOL>    }<EOL>    function setCurrentPly(ply: number | null) {<EOL>        g.selectAll('<STR_LIT>').remove();<EOL>        if (ply !== null) {<EOL>            const isWhite = !!(ply & <NUM_LIT>);<EOL>            const p = isWhite ? series.white.find(p => p.ply === ply) : series.black.find(p => p.ply === ply);<EOL>            if (p) {<EOL>                g.append('<STR_LIT>')<EOL>                    .attr('<STR_LIT>', '<STR_LIT>')<EOL>                    .attr('<STR_LIT>', x(ply))<EOL>                    .attr('<STR_LIT>', y(p.y))<EOL>                    .attr('<STR_LIT>', <NUM_LIT>);<EOL>            }<EOL>        }<EOL>    }<EOL>    const x = scaleLinear()<EOL>        .domain([<NUM_LIT>, series.white.length + series.black.length])<EOL>        .rangeRound([<NUM_LIT>, width]);<EOL>    const y = scaleLinear()<EOL>        .domain([-max, max])<EOL>        .rangeRound([height, <NUM_LIT>]);<EOL>    const line = d3Area<Point>()<EOL>        .x(d => x(d.ply))<EOL>        .y(d => y(d.y));<EOL>    const area = d3Area<Point>()<EOL>        .x(d => x(d.ply))<EOL>        .y0(y(<NUM_LIT>))<EOL>        .y1(d => y(d.y));<EOL>    const maxCentis = Math.max.apply(Math, moveCentis) / <NUM_LIT>;<EOL>    const legendScale = scaleLinear()<EOL>        .domain([-maxCentis, maxCentis])<EOL>        .rangeRound([height, <NUM_LIT>]);<EOL>    const yAxis = axisLeft<number>(legendScale)<EOL>        .tickFormat(d => String(Math.abs(d)));<EOL>    g.append('<STR_LIT>')<EOL>        .call(yAxis)<EOL>        .append('<STR_LIT>')<EOL>        .attr('<STR_LIT>', '<STR_LIT>')<EOL>        .attr('<STR_LIT>', '<STR_LIT>')<EOL>        .attr('<STR_LIT>', <NUM_LIT>)<EOL>        .attr('<STR_LIT>', '<STR_LIT>')<EOL>        .attr('<STR_LIT>', '<STR_LIT>')<EOL>        .text('<STR_LIT>');<EOL>    g.append('<STR_LIT>')<EOL>        .datum(series.white)<EOL>        .attr('<STR_LIT>',","gt":"'<STR_LIT>')"}
{"input":"<s> export default function drawMoveTimesChart(element: SVGElement, aData: AnalyseData, moveCentis: number[], curPly: number) {<EOL>    const division = aData.game.division;<EOL>    const svg = select(element);<EOL>    const margin = { top: <NUM_LIT>, right: <NUM_LIT>, bottom: <NUM_LIT>, left: <NUM_LIT> };<EOL>    const width = +svg.attr('<STR_LIT>') - margin.left - margin.right;<EOL>    const height = +svg.attr('<STR_LIT>') - margin.top - margin.bottom;<EOL>    const g = svg.append('<STR_LIT>').attr('<STR_LIT>', '<STR_LIT>' + margin.left + '<STR_LIT>' + margin.top + '<STR_LIT>');<EOL>    const { max, series } = makeSerieData(aData, moveCentis);<EOL>    function addDivisionLine(xPos: number, name: string) {<EOL>        g.append('<STR_LIT>')<EOL>            .attr('<STR_LIT>', '<STR_LIT>' + name)<EOL>            .attr('<STR_LIT>', xPos)<EOL>            .attr('<STR_LIT>', xPos)<EOL>            .attr('<STR_LIT>', y(-max))<EOL>            .attr('<STR_LIT>', y(max));<EOL>        g.append('<STR_LIT>')<EOL>            .attr('<STR_LIT>', '<STR_LIT>')<EOL>            .attr('<STR_LIT>', '<STR_LIT>')<EOL>            .attr('<STR_LIT>', -xPos)<EOL>            .attr('<STR_LIT>', '<STR_LIT>')<EOL>            .text(name);<EOL>    }<EOL>    function setCurrentPly(ply: number | null) {<EOL>        g.selectAll('<STR_LIT>').remove();<EOL>        if (ply !== null) {<EOL>            const isWhite = !!(ply & <NUM_LIT>);<EOL>            const p = isWhite ? series.white.find(p => p.ply === ply) : series.black.find(p => p.ply === ply);<EOL>            if (p) {<EOL>                g.append('<STR_LIT>')<EOL>                    .attr('<STR_LIT>', '<STR_LIT>')<EOL>                    .attr('<STR_LIT>', x(ply))<EOL>                    .attr('<STR_LIT>', y(p.y))<EOL>                    .attr('<STR_LIT>', <NUM_LIT>);<EOL>            }<EOL>        }<EOL>    }<EOL>    const x = scaleLinear()<EOL>        .domain([<NUM_LIT>, series.white.length + series.black.length])<EOL>        .rangeRound([<NUM_LIT>, width]);<EOL>    const y = scaleLinear()<EOL>        .domain([-max, max])<EOL>        .rangeRound([height, <NUM_LIT>]);<EOL>    const line = d3Area<Point>()<EOL>        .x(d => x(d.ply))<EOL>        .y(d => y(d.y));<EOL>    const area = d3Area<Point>()<EOL>        .x(d => x(d.ply))<EOL>        .y0(y(<NUM_LIT>))<EOL>        .y1(d => y(d.y));<EOL>    const maxCentis = Math.max.apply(Math, moveCentis) / <NUM_LIT>;<EOL>    const legendScale = scaleLinear()<EOL>        .domain([-maxCentis, maxCentis])<EOL>        .rangeRound([height, <NUM_LIT>]);<EOL>    const yAxis = axisLeft<number>(legendScale)<EOL>        .tickFormat(d => String(Math.abs(d)));<EOL>    g.append('<STR_LIT>')<EOL>        .call(yAxis)<EOL>        .append('<STR_LIT>')<EOL>        .attr('<STR_LIT>', '<STR_LIT>')<EOL>        .attr('<STR_LIT>', '<STR_LIT>')<EOL>        .attr('<STR_LIT>', <NUM_LIT>)<EOL>        .attr('<STR_LIT>', '<STR_LIT>')<EOL>        .attr('<STR_LIT>', '<STR_LIT>')<EOL>        .text('<STR_LIT>');<EOL>    g.append('<STR_LIT>')<EOL>        .datum(series.white)<EOL>        .attr('<STR_LIT>', '<STR_LIT>')<EOL>        .attr('<STR_LIT>', area);<EOL>    g.append('<STR_LIT>')<EOL>        .datum(series.black)<EOL>        .attr('<STR_LIT>', '<STR_LIT>')<EOL>        .attr('<STR_LIT>', area);<EOL>","gt":"g.append('<STR_LIT>')"}
{"input":"<s> export default function drawMoveTimesChart(element: SVGElement, aData: AnalyseData, moveCentis: number[], curPly: number) {<EOL>    const division = aData.game.division;<EOL>    const svg = select(element);<EOL>    const margin = { top: <NUM_LIT>, right: <NUM_LIT>, bottom: <NUM_LIT>, left: <NUM_LIT> };<EOL>    const width = +svg.attr('<STR_LIT>') - margin.left - margin.right;<EOL>    const height = +svg.attr('<STR_LIT>') - margin.top - margin.bottom;<EOL>    const g = svg.append('<STR_LIT>').attr('<STR_LIT>', '<STR_LIT>' + margin.left + '<STR_LIT>' + margin.top + '<STR_LIT>');<EOL>    const { max, series } = makeSerieData(aData, moveCentis);<EOL>    function addDivisionLine(xPos: number, name: string) {<EOL>        g.append('<STR_LIT>')<EOL>            .attr('<STR_LIT>', '<STR_LIT>' + name)<EOL>            .attr('<STR_LIT>', xPos)<EOL>            .attr('<STR_LIT>', xPos)<EOL>            .attr('<STR_LIT>', y(-max))<EOL>            .attr('<STR_LIT>', y(max));<EOL>        g.append('<STR_LIT>')<EOL>            .attr('<STR_LIT>', '<STR_LIT>')<EOL>            .attr('<STR_LIT>', '<STR_LIT>')<EOL>            .attr('<STR_LIT>', -xPos)<EOL>            .attr('<STR_LIT>', '<STR_LIT>')<EOL>            .text(name);<EOL>    }<EOL>    function setCurrentPly(ply: number | null) {<EOL>        g.selectAll('<STR_LIT>').remove();<EOL>        if (ply !== null) {<EOL>            const isWhite = !!(ply & <NUM_LIT>);<EOL>            const p = isWhite ? series.white.find(p => p.ply === ply) : series.black.find(p => p.ply === ply);<EOL>            if (p) {<EOL>                g.append('<STR_LIT>')<EOL>                    .attr('<STR_LIT>', '<STR_LIT>')<EOL>                    .attr('<STR_LIT>', x(ply))<EOL>                    .attr('<STR_LIT>', y(p.y))<EOL>                    .attr('<STR_LIT>', <NUM_LIT>);<EOL>            }<EOL>        }<EOL>    }<EOL>    const x = scaleLinear()<EOL>        .domain([<NUM_LIT>, series.white.length + series.black.length])<EOL>        .rangeRound([<NUM_LIT>, width]);<EOL>    const y = scaleLinear()<EOL>        .domain([-max, max])<EOL>        .rangeRound([height, <NUM_LIT>]);<EOL>    const line = d3Area<Point>()<EOL>        .x(d => x(d.ply))<EOL>        .y(d => y(d.y));<EOL>    const area = d3Area<Point>()<EOL>        .x(d => x(d.ply))<EOL>        .y0(y(<NUM_LIT>))<EOL>        .y1(d => y(d.y));<EOL>    const maxCentis = Math.max.apply(Math, moveCentis) / <NUM_LIT>;<EOL>    const legendScale = scaleLinear()<EOL>        .domain([-maxCentis, maxCentis])<EOL>        .rangeRound([height, <NUM_LIT>]);<EOL>    const yAxis = axisLeft<number>(legendScale)<EOL>        .tickFormat(d => String(Math.abs(d)));<EOL>    g.append('<STR_LIT>')<EOL>        .call(yAxis)<EOL>        .append('<STR_LIT>')<EOL>        .attr('<STR_LIT>', '<STR_LIT>')<EOL>        .attr('<STR_LIT>', '<STR_LIT>')<EOL>        .attr('<STR_LIT>', <NUM_LIT>)<EOL>        .attr('<STR_LIT>', '<STR_LIT>')<EOL>        .attr('<STR_LIT>', '<STR_LIT>')<EOL>        .text('<STR_LIT>');<EOL>    g.append('<STR_LIT>')<EOL>        .datum(series.white)<EOL>        .attr('<STR_LIT>', '<STR_LIT>')<EOL>        .attr('<STR_LIT>', area);<EOL>    g.append('<STR_LIT>')<EOL>        .datum(series.black)<EOL>        .attr('<STR_LIT>', '<STR_LIT>')<EOL>        .attr('<STR_LIT>', area);<EOL>    g.append('<STR_LIT>')<EOL>        .attr(","gt":"'<STR_LIT>', '<STR_LIT>')"}
{"input":"<s> export default function drawMoveTimesChart(element: SVGElement, aData: AnalyseData, moveCentis: number[], curPly: number) {<EOL>    const division = aData.game.division;<EOL>    const svg = select(element);<EOL>    const margin = { top: <NUM_LIT>, right: <NUM_LIT>, bottom: <NUM_LIT>, left: <NUM_LIT> };<EOL>    const width = +svg.attr('<STR_LIT>') - margin.left - margin.right;<EOL>    const height = +svg.attr('<STR_LIT>') - margin.top - margin.bottom;<EOL>    const g = svg.append('<STR_LIT>').attr('<STR_LIT>', '<STR_LIT>' + margin.left + '<STR_LIT>' + margin.top + '<STR_LIT>');<EOL>    const { max, series } = makeSerieData(aData, moveCentis);<EOL>    function addDivisionLine(xPos: number, name: string) {<EOL>        g.append('<STR_LIT>')<EOL>            .attr('<STR_LIT>', '<STR_LIT>' + name)<EOL>            .attr('<STR_LIT>', xPos)<EOL>            .attr('<STR_LIT>', xPos)<EOL>            .attr('<STR_LIT>', y(-max))<EOL>            .attr('<STR_LIT>', y(max));<EOL>        g.append('<STR_LIT>')<EOL>            .attr('<STR_LIT>', '<STR_LIT>')<EOL>            .attr('<STR_LIT>', '<STR_LIT>')<EOL>            .attr('<STR_LIT>', -xPos)<EOL>            .attr('<STR_LIT>', '<STR_LIT>')<EOL>            .text(name);<EOL>    }<EOL>    function setCurrentPly(ply: number | null) {<EOL>        g.selectAll('<STR_LIT>').remove();<EOL>        if (ply !== null) {<EOL>            const isWhite = !!(ply & <NUM_LIT>);<EOL>            const p = isWhite ? series.white.find(p => p.ply === ply) : series.black.find(p => p.ply === ply);<EOL>            if (p) {<EOL>                g.append('<STR_LIT>')<EOL>                    .attr('<STR_LIT>', '<STR_LIT>')<EOL>                    .attr('<STR_LIT>', x(ply))<EOL>                    .attr('<STR_LIT>', y(p.y))<EOL>                    .attr('<STR_LIT>', <NUM_LIT>);<EOL>            }<EOL>        }<EOL>    }<EOL>    const x = scaleLinear()<EOL>        .domain([<NUM_LIT>, series.white.length + series.black.length])<EOL>        .rangeRound([<NUM_LIT>, width]);<EOL>    const y = scaleLinear()<EOL>        .domain([-max, max])<EOL>        .rangeRound([height, <NUM_LIT>]);<EOL>    const line = d3Area<Point>()<EOL>        .x(d => x(d.ply))<EOL>        .y(d => y(d.y));<EOL>    const area = d3Area<Point>()<EOL>        .x(d => x(d.ply))<EOL>        .y0(y(<NUM_LIT>))<EOL>        .y1(d => y(d.y));<EOL>    const maxCentis = Math.max.apply(Math, moveCentis) / <NUM_LIT>;<EOL>    const legendScale = scaleLinear()<EOL>        .domain([-maxCentis, maxCentis])<EOL>        .rangeRound([height, <NUM_LIT>]);<EOL>    const yAxis = axisLeft<number>(legendScale)<EOL>        .tickFormat(d => String(Math.abs(d)));<EOL>    g.append('<STR_LIT>')<EOL>        .call(yAxis)<EOL>        .append('<STR_LIT>')<EOL>        .attr('<STR_LIT>', '<STR_LIT>')<EOL>        .attr('<STR_LIT>', '<STR_LIT>')<EOL>        .attr('<STR_LIT>', <NUM_LIT>)<EOL>        .attr('<STR_LIT>', '<STR_LIT>')<EOL>        .attr('<STR_LIT>', '<STR_LIT>')<EOL>        .text('<STR_LIT>');<EOL>    g.append('<STR_LIT>')<EOL>        .datum(series.white)<EOL>        .attr('<STR_LIT>', '<STR_LIT>')<EOL>        .attr('<STR_LIT>', area);<EOL>    g.append('<STR_LIT>')<EOL>        .datum(series.black)<EOL>        .attr('<STR_LIT>', '<STR_LIT>')<EOL>        .attr('<STR_LIT>', area);<EOL>    g.append('<STR_LIT>')<EOL>        .attr('<STR_LIT>', '<STR_LIT>')<EOL>        .datum(series.white)<EOL>        .attr('<STR_LIT>', line);<EOL>    g.append('<STR_LIT>')<EOL>        .attr(","gt":"'<STR_LIT>',"}
{"input":"<s> export default function drawMoveTimesChart(element: SVGElement, aData: AnalyseData, moveCentis: number[], curPly: number) {<EOL>    const division = aData.game.division;<EOL>    const svg = select(element);<EOL>    const margin = { top: <NUM_LIT>, right: <NUM_LIT>, bottom: <NUM_LIT>, left: <NUM_LIT> };<EOL>    const width = +svg.attr('<STR_LIT>') - margin.left - margin.right;<EOL>    const height = +svg.attr('<STR_LIT>') - margin.top - margin.bottom;<EOL>    const g = svg.append('<STR_LIT>').attr('<STR_LIT>', '<STR_LIT>' + margin.left + '<STR_LIT>' + margin.top + '<STR_LIT>');<EOL>    const { max, series } = makeSerieData(aData, moveCentis);<EOL>    function addDivisionLine(xPos: number, name: string) {<EOL>        g.append('<STR_LIT>')<EOL>            .attr('<STR_LIT>', '<STR_LIT>' + name)<EOL>            .attr('<STR_LIT>', xPos)<EOL>            .attr('<STR_LIT>', xPos)<EOL>            .attr('<STR_LIT>', y(-max))<EOL>            .attr('<STR_LIT>', y(max));<EOL>        g.append('<STR_LIT>')<EOL>            .attr('<STR_LIT>', '<STR_LIT>')<EOL>            .attr('<STR_LIT>', '<STR_LIT>')<EOL>            .attr('<STR_LIT>', -xPos)<EOL>            .attr('<STR_LIT>', '<STR_LIT>')<EOL>            .text(name);<EOL>    }<EOL>    function setCurrentPly(ply: number | null) {<EOL>        g.selectAll('<STR_LIT>').remove();<EOL>        if (ply !== null) {<EOL>            const isWhite = !!(ply & <NUM_LIT>);<EOL>            const p = isWhite ? series.white.find(p => p.ply === ply) : series.black.find(p => p.ply === ply);<EOL>            if (p) {<EOL>                g.append('<STR_LIT>')<EOL>                    .attr('<STR_LIT>', '<STR_LIT>')<EOL>                    .attr('<STR_LIT>', x(ply))<EOL>                    .attr('<STR_LIT>', y(p.y))<EOL>                    .attr('<STR_LIT>', <NUM_LIT>);<EOL>            }<EOL>        }<EOL>    }<EOL>    const x = scaleLinear()<EOL>        .domain([<NUM_LIT>, series.white.length + series.black.length])<EOL>        .rangeRound([<NUM_LIT>, width]);<EOL>    const y = scaleLinear()<EOL>        .domain([-max, max])<EOL>        .rangeRound([height, <NUM_LIT>]);<EOL>    const line = d3Area<Point>()<EOL>        .x(d => x(d.ply))<EOL>        .y(d => y(d.y));<EOL>    const area = d3Area<Point>()<EOL>        .x(d => x(d.ply))<EOL>        .y0(y(<NUM_LIT>))<EOL>        .y1(d => y(d.y));<EOL>    const maxCentis = Math.max.apply(Math, moveCentis) / <NUM_LIT>;<EOL>    const legendScale = scaleLinear()<EOL>        .domain([-maxCentis, maxCentis])<EOL>        .rangeRound([height, <NUM_LIT>]);<EOL>    const yAxis = axisLeft<number>(legendScale)<EOL>        .tickFormat(d => String(Math.abs(d)));<EOL>    g.append('<STR_LIT>')<EOL>        .call(yAxis)<EOL>        .append('<STR_LIT>')<EOL>        .attr('<STR_LIT>', '<STR_LIT>')<EOL>        .attr('<STR_LIT>', '<STR_LIT>')<EOL>        .attr('<STR_LIT>', <NUM_LIT>)<EOL>        .attr('<STR_LIT>', '<STR_LIT>')<EOL>        .attr('<STR_LIT>', '<STR_LIT>')<EOL>        .text('<STR_LIT>');<EOL>    g.append('<STR_LIT>')<EOL>        .datum(series.white)<EOL>        .attr('<STR_LIT>', '<STR_LIT>')<EOL>        .attr('<STR_LIT>', area);<EOL>    g.append('<STR_LIT>')<EOL>        .datum(series.black)<EOL>        .attr('<STR_LIT>', '<STR_LIT>')<EOL>        .attr('<STR_LIT>', area);<EOL>    g.append('<STR_LIT>')<EOL>        .attr('<STR_LIT>', '<STR_LIT>')<EOL>        .datum(series.white)<EOL>        .attr('<STR_LIT>', line);<EOL>    g.append('<STR_LIT>')<EOL>        .attr('<STR_LIT>',","gt":"'<STR_LIT>')"}
{"input":"<s> export default function drawMoveTimesChart(element: SVGElement, aData: AnalyseData, moveCentis: number[], curPly: number) {<EOL>    const division = aData.game.division;<EOL>    const svg = select(element);<EOL>    const margin = { top: <NUM_LIT>, right: <NUM_LIT>, bottom: <NUM_LIT>, left: <NUM_LIT> };<EOL>    const width = +svg.attr('<STR_LIT>') - margin.left - margin.right;<EOL>    const height = +svg.attr('<STR_LIT>') - margin.top - margin.bottom;<EOL>    const g = svg.append('<STR_LIT>').attr('<STR_LIT>', '<STR_LIT>' + margin.left + '<STR_LIT>' + margin.top + '<STR_LIT>');<EOL>    const { max, series } = makeSerieData(aData, moveCentis);<EOL>    function addDivisionLine(xPos: number, name: string) {<EOL>        g.append('<STR_LIT>')<EOL>            .attr('<STR_LIT>', '<STR_LIT>' + name)<EOL>            .attr('<STR_LIT>', xPos)<EOL>            .attr('<STR_LIT>', xPos)<EOL>            .attr('<STR_LIT>', y(-max))<EOL>            .attr('<STR_LIT>', y(max));<EOL>        g.append('<STR_LIT>')<EOL>            .attr('<STR_LIT>', '<STR_LIT>')<EOL>            .attr('<STR_LIT>', '<STR_LIT>')<EOL>            .attr('<STR_LIT>', -xPos)<EOL>            .attr('<STR_LIT>', '<STR_LIT>')<EOL>            .text(name);<EOL>    }<EOL>    function setCurrentPly(ply: number | null) {<EOL>        g.selectAll('<STR_LIT>').remove();<EOL>        if (ply !== null) {<EOL>            const isWhite = !!(ply & <NUM_LIT>);<EOL>            const p = isWhite ? series.white.find(p => p.ply === ply) : series.black.find(p => p.ply === ply);<EOL>            if (p) {<EOL>                g.append('<STR_LIT>')<EOL>                    .attr('<STR_LIT>', '<STR_LIT>')<EOL>                    .attr('<STR_LIT>', x(ply))<EOL>                    .attr('<STR_LIT>', y(p.y))<EOL>                    .attr('<STR_LIT>', <NUM_LIT>);<EOL>            }<EOL>        }<EOL>    }<EOL>    const x = scaleLinear()<EOL>        .domain([<NUM_LIT>, series.white.length + series.black.length])<EOL>        .rangeRound([<NUM_LIT>, width]);<EOL>    const y = scaleLinear()<EOL>        .domain([-max, max])<EOL>        .rangeRound([height, <NUM_LIT>]);<EOL>    const line = d3Area<Point>()<EOL>        .x(d => x(d.ply))<EOL>        .y(d => y(d.y));<EOL>    const area = d3Area<Point>()<EOL>        .x(d => x(d.ply))<EOL>        .y0(y(<NUM_LIT>))<EOL>        .y1(d => y(d.y));<EOL>    const maxCentis = Math.max.apply(Math, moveCentis) / <NUM_LIT>;<EOL>    const legendScale = scaleLinear()<EOL>        .domain([-maxCentis, maxCentis])<EOL>        .rangeRound([height, <NUM_LIT>]);<EOL>    const yAxis = axisLeft<number>(legendScale)<EOL>        .tickFormat(d => String(Math.abs(d)));<EOL>    g.append('<STR_LIT>')<EOL>        .call(yAxis)<EOL>        .append('<STR_LIT>')<EOL>        .attr('<STR_LIT>', '<STR_LIT>')<EOL>        .attr('<STR_LIT>', '<STR_LIT>')<EOL>        .attr('<STR_LIT>', <NUM_LIT>)<EOL>        .attr('<STR_LIT>', '<STR_LIT>')<EOL>        .attr('<STR_LIT>', '<STR_LIT>')<EOL>        .text('<STR_LIT>');<EOL>    g.append('<STR_LIT>')<EOL>        .datum(series.white)<EOL>        .attr('<STR_LIT>', '<STR_LIT>')<EOL>        .attr('<STR_LIT>', area);<EOL>    g.append('<STR_LIT>')<EOL>        .datum(series.black)<EOL>        .attr('<STR_LIT>', '<STR_LIT>')<EOL>        .attr('<STR_LIT>', area);<EOL>    g.append('<STR_LIT>')<EOL>        .attr('<STR_LIT>', '<STR_LIT>')<EOL>        .datum(series.white)<EOL>        .attr('<STR_LIT>', line);<EOL>    g.append('<STR_LIT>')<EOL>        .attr('<STR_LIT>', '<STR_LIT>')<EOL>        .datum(series.black)<EOL>        .attr('<STR_LIT>', line);<EOL>","gt":"if (division && (division.middle || division.end)) {"}
{"input":"<s> function convertValidationType(type: InputValidationType): MessageType {<EOL>    switch (type) {<EOL>        case InputValidationType.Information: return MessageType.","gt":"INFO;"}
{"input":"<s> /**<EOL> * 计算一个元素的样式值。<EOL> * @param elem 要计算的元素。<EOL> * @param propNames 要计算的 CSS 属性名(骆驼规则)列表。<EOL> * @return 返回所有 CSS 属性值的和。<EOL> * @example getStyleNumber(document.body, \"fontSize\", \"lineHeight\")<EOL> */<EOL>export function computeStyle(elem: HTMLElement, ...propNames: string[]) {<EOL>    let result = <NUM_LIT>;<EOL>    const computedStyle = elem.ownerDocument.defaultView.getComputedStyle(","gt":"elem);"}
{"input":"<s> /**<EOL> * 交换数组中的两个项。<EOL> * @param arr 相关的数组。<EOL> * @param x 要交换的第一个索引。<EOL> * @param y 要交换的第二个索引。<EOL> * @example swap([1, 2, 3], 1, 2)<EOL> */<EOL>export function swap<T>(arr: T[], x: number, y: number) {<EOL>    const t = arr[","gt":"x];"}
{"input":"<s> /**<EOL> * 判断指定的年份是否是闰年。<EOL> * @param year 要判断的年份。<EOL> * @return 如果 *year* 是闰年，则返回 true，否则返回 false。<EOL> * @example isLeapYear(2004) // true<EOL> * @example isLeapYear(2000) // true<EOL> * @example isLeapYear(2100) // false<EOL> * @example isLeapYear(2002) // false<EOL> */<EOL>export function isLeapYear(year: number) {<EOL>    return (year % <NUM_LIT> == <NUM_LIT> &&","gt":"year % <NUM_LIT> != <NUM_LIT>) || year % <NUM_LIT> == <NUM_LIT>;"}
{"input":"<s> export function findTest() {<EOL>    assert.strictEqual(object.find([<NUM_LIT>,","gt":"<NUM_LIT>], function (item) { return item > <NUM_LIT>; }), <NUM_LIT>);"}
{"input":"<s> export function trigger(elem: HTMLElement | Document, eventName: string, selector: string | typeof event, event?: Partial<Event>) {<EOL>    if (typeof selector !== \"<STR_LIT>\") {<EOL>        event = selector;<EOL>        selector = \"<STR_LIT>\";<EOL>    }<EOL>    const listeners = (elem as any).__events__[selector ? eventName + \"<STR_LIT>\" + selector : eventName];<EOL>    if (listeners) {<EOL>        event =","gt":"event || {};"}
{"input":"<s> export function trigger(elem: HTMLElement | Document, eventName: string, selector: string | typeof event, event?: Partial<Event>) {<EOL>    if (typeof selector !== \"<STR_LIT>\") {<EOL>        event = selector;<EOL>        selector = \"<STR_LIT>\";<EOL>    }<EOL>    const listeners = (elem as any).__events__[selector ? eventName + \"<STR_LIT>\" + selector : eventName];<EOL>    if (listeners) {<EOL>        event = event || {};<EOL>        if (!event.type)<EOL>            (event as any).type = eventName;<EOL>        if (!event.target)<EOL>            (event as any).","gt":"target = selector ? find(elem, selector as string) : elem;"}
{"input":"<s> export function cloneTest() {<EOL>    assert.","gt":"deepEqual(object.clone({ a: <NUM_LIT>, b: [<NUM_LIT>] }), { a: <NUM_LIT>, b: [<NUM_LIT>] });"}
{"input":"<s> export function diffTest() {<EOL>    assert.deepEqual(object.diff({ a: <NUM_LIT>, c: <NUM_LIT> }, { b:","gt":"<NUM_LIT>, c: <NUM_LIT> }), { left: [\"<STR_LIT>\"], right: [\"<STR_LIT>\"], both: [\"<STR_LIT>\"] });"}
{"input":"<s> export function keyOfTest() {<EOL>    assert.strictEqual(object.keyOf({ a: <NUM_LIT>, b: <NUM_LIT> }, <NUM_LIT>),","gt":"\"<STR_LIT>\");"}
{"input":"<s> <EOL><EOL><EOL>export function povDiff(color: Color, e1: Eval, e2: Eval) {<EOL>    return (povChances(","gt":"color, e1) - povChances(color, e2)) / <NUM_LIT>;"}
{"input":"<s> export function formatTournamentDuration(timeInMin: number): string {<EOL>","gt":"const hours = Math.floor(timeInMin / <NUM_LIT>);"}
{"input":"<s> export function getStylesFromClasses(names: string | string[], elementType: string = \"<STR_LIT>\"): {<EOL>    [key: string]: string | number;<EOL>} {<EOL>    let elem = document.createElement(elementType);<EOL>    (typeof names == \"<STR_LIT>\" ? [names] : names).forEach(c => elem.classList.add(c));<EOL>    let result = {};<EOL>    for (let i = <NUM_LIT>; i < document.styleSheets.length; i++) {<EOL>        let sheet = document.styleSheets[i] as CSSStyleSheet;<EOL>        let rules =","gt":"sheet.rules || sheet.cssRules;"}
{"input":"<s> export function getStylesFromClasses(names: string | string[], elementType: string = \"<STR_LIT>\"): {<EOL>    [key: string]: string | number;<EOL>} {<EOL>    let elem = document.createElement(elementType);<EOL>    (typeof names == \"<STR_LIT>\" ? [names] : names).forEach(c => elem.classList.add(c));<EOL>    let result = {};<EOL>    for (let i = <NUM_LIT>; i < document.styleSheets.length; i++) {<EOL>        let sheet = document.styleSheets[i] as CSSStyleSheet;<EOL>        let rules = sheet.rules || sheet.cssRules;<EOL>        for (let j = <NUM_LIT>; j < rules.length; j++) {<EOL>            if (rules[j].type == CSSRule.STYLE_RULE) {<EOL>                let styleRule = rules[j] as CSSStyleRule;<EOL>                if (elem.matches(styleRule.selectorText)) {<EOL>                    for (let k = <NUM_LIT>; k < styleRule.style.","gt":"length; k++) {"}
{"input":"<s> /** @ngInject **/<EOL>export function axesEditorComponent() {<EOL>    '<STR_LIT>';<EOL>    return {<EOL>        restrict:","gt":"'<STR_LIT>',"}
{"input":"<s> function addMathStrategy(selectParts, partModel) {<EOL>    var partCount = selectParts.length;<EOL>    if (partCount > <NUM_LIT>) {<EOL>        <EOL>        if (selectParts[partCount - <NUM_LIT>].def.type === '<STR_LIT>') {<EOL>            selectParts[partCount - <NUM_LIT>] = partModel;<EOL>","gt":"return;"}
{"input":"<s> function addMathStrategy(selectParts, partModel) {<EOL>    var partCount = selectParts.length;<EOL>    if (partCount > <NUM_LIT>) {<EOL>        <EOL>        if (selectParts[partCount - <NUM_LIT>].def.type === '<STR_LIT>') {<EOL>            selectParts[partCount - <NUM_LIT>] = partModel;<EOL>            return;<EOL>        }<EOL>        <EOL>        if (partCount > <NUM_LIT> && selectParts[partCount - <NUM_LIT>].def.type === '<STR_LIT>') {<EOL>            selectParts[partCount - <NUM_LIT>] = partModel;<EOL>","gt":"return;"}
{"input":"<s> function addMathStrategy(selectParts, partModel) {<EOL>    var partCount = selectParts.length;<EOL>    if (partCount > <NUM_LIT>) {<EOL>        <EOL>        if (selectParts[partCount - <NUM_LIT>].def.type === '<STR_LIT>') {<EOL>            selectParts[partCount - <NUM_LIT>] = partModel;<EOL>            return;<EOL>        }<EOL>        <EOL>        if (partCount > <NUM_LIT> && selectParts[partCount - <NUM_LIT>].def.type === '<STR_LIT>') {<EOL>            selectParts[partCount - <NUM_LIT>] = partModel;<EOL>            return;<EOL>        }<EOL>        else if (selectParts[partCount - <NUM_LIT>].def.type === '<STR_LIT>') {<EOL>            <EOL>            selectParts.splice(partCount - <NUM_LIT>,","gt":"<NUM_LIT>, partModel);"}
{"input":"<s> /** @ngInject **/<EOL>function queryEditorRowDirective() {<EOL>    return {<EOL>        restrict: '<STR_LIT>',<EOL>        controller: QueryRowCtrl,<EOL>        bindToController:","gt":"true,"}
{"input":"<s> /** @ngInject **/<EOL>function queryEditorRowDirective() {<EOL>    return {<EOL>        restrict: '<STR_LIT>',<EOL>        controller: QueryRowCtrl,<EOL>        bindToController: true,<EOL>        controllerAs: '<STR_LIT>',<EOL>        templateUrl: '<STR_LIT>',<EOL>        transclude: true,<EOL>        scope: {<EOL>            queryCtrl: '<STR_LIT>',<EOL>            canCollapse:","gt":"'<STR_LIT>',"}
{"input":"<s> export function flatten<T>(arr: T[][]): T[] {<EOL>","gt":"return arr.reduce((a: T[], b: T[]) => a.concat(b), []);"}
{"input":"<s> function describeSharedTooltip(desc, fn) {<EOL>    var ctx: any = {};<EOL>    ctx.ctrl = scope.ctrl;<EOL>    ctx.ctrl.panel = {<EOL>","gt":"tooltip: {"}
{"input":"<s> function describeSharedTooltip(desc, fn) {<EOL>    var ctx: any = {};<EOL>    ctx.ctrl = scope.ctrl;<EOL>    ctx.ctrl.panel = {<EOL>        tooltip: {<EOL>            shared: true,<EOL>        },<EOL>","gt":"legend: {},"}
{"input":"<s> function describeSharedTooltip(desc, fn) {<EOL>    var ctx: any = {};<EOL>    ctx.ctrl = scope.ctrl;<EOL>    ctx.ctrl.panel = {<EOL>        tooltip: {<EOL>            shared: true,<EOL>        },<EOL>        legend: {},<EOL>        stack: false,<EOL>    };<EOL>    ctx.setup = function (setupFn) {<EOL>        ctx.setupFn =","gt":"setupFn;"}
{"input":"<s> function describeSharedTooltip(desc, fn) {<EOL>    var ctx: any = {};<EOL>    ctx.ctrl = scope.ctrl;<EOL>    ctx.ctrl.panel = {<EOL>        tooltip: {<EOL>            shared: true,<EOL>        },<EOL>        legend: {},<EOL>        stack: false,<EOL>    };<EOL>    ctx.setup = function (setupFn) {<EOL>        ctx.setupFn = setupFn;<EOL>    };<EOL>    describe(desc, function () {<EOL>        beforeEach(function () {<EOL>            ctx.setupFn();<EOL>            var tooltip = new GraphTooltip(elem, dashboard,","gt":"scope);"}
{"input":"<s> function getFileContents(file: string, options: TslintBuilderOptions, program?: ts.Program): string | undefined {<EOL>    <EOL>    if (program) {<EOL>        if (program.getSourceFile(file) == undefined) {<EOL>            const message = `<STR_LIT>`;<EOL>            throw","gt":"new Error(message);"}
{"input":"<s> export function getDataTransferFiles(event: DropZoneEvent) {<EOL>    if (isDragEvent(event) && event.dataTransfer) {<EOL>        const dt = event.dataTransfer;<EOL>        if (dt.files && dt.files.length) {<EOL>            return Array.from(dt.files);<EOL>        }<EOL>        else if (dt.items && dt.items.length) {<EOL>            <EOL>            <EOL>            return Array.from(dt.","gt":"items);"}
{"input":"<s> export function registerAngularDirectives() {<EOL>    react2AngularDirective('<STR_LIT>', PasswordStrength, ['<STR_LIT>']);<EOL>    react2AngularDirective('<STR_LIT>', PageHeader, ['<STR_LIT>', '<STR_LIT>']);<EOL>    react2AngularDirective('<STR_LIT>', EmptyListCTA, ['<STR_LIT>']);<EOL>    react2AngularDirective(","gt":"'<STR_LIT>', LoginBackground, []);"}
{"input":"<s> export function pluckDeep(obj: {<EOL>    [key: string]: any;<EOL>} | null, key: string): any {<EOL>    if (!obj) {<EOL>        return null;<EOL>    }<EOL>    const keys = Object.keys(obj);<EOL>    for (const currKey","gt":"of keys) {"}
{"input":"<s> export function pluckDeep(obj: {<EOL>    [key: string]: any;<EOL>} | null, key: string): any {<EOL>    if (!obj) {<EOL>        return null;<EOL>    }<EOL>    const keys = Object.keys(obj);<EOL>    for (const currKey of keys) {<EOL>        if (currKey === key) {<EOL>            return obj[key];<EOL>        }<EOL>        if (isObject(obj[","gt":"currKey])) {"}
{"input":"<s> function setupWatchRun(compiler, instanceName: string) {<EOL>    compiler.plugin('<STR_LIT>', function (watching, callback) {<EOL>        const instance = resolveInstance(watching.compiler, instanceName);<EOL>        const checker = instance.checker;<EOL>        const watcher = watching.compiler.watchFileSystem.","gt":"watcher"}
{"input":"<s> function setupWatchRun(compiler, instanceName: string) {<EOL>    compiler.plugin('<STR_LIT>', function (watching, callback) {<EOL>        const instance = resolveInstance(watching.compiler, instanceName);<EOL>        const checker = instance.checker;<EOL>        const watcher = watching.compiler.watchFileSystem.watcher<EOL>            || watching.compiler.watchFileSystem.wfs.watcher;<EOL>        const startTime = instance.startTime || watching.","gt":"startTime;"}
{"input":"<s> function setupWatchRun(compiler, instanceName: string) {<EOL>    compiler.plugin('<STR_LIT>', function (watching, callback) {<EOL>        const instance = resolveInstance(watching.compiler, instanceName);<EOL>        const checker = instance.checker;<EOL>        const watcher = watching.compiler.watchFileSystem.watcher<EOL>            || watching.compiler.watchFileSystem.wfs.watcher;<EOL>        const startTime = instance.startTime || watching.startTime;<EOL>        const times = filterMtimes(watcher.getTimes());<EOL>        const lastCompiled = instance.compiledFiles;<EOL>        instance.","gt":"compiledFiles = {};"}
{"input":"<s> function setupWatchRun(compiler, instanceName: string) {<EOL>    compiler.plugin('<STR_LIT>', function (watching, callback) {<EOL>        const instance = resolveInstance(watching.compiler, instanceName);<EOL>        const checker = instance.checker;<EOL>        const watcher = watching.compiler.watchFileSystem.watcher<EOL>            || watching.compiler.watchFileSystem.wfs.watcher;<EOL>        const startTime = instance.startTime || watching.startTime;<EOL>        const times = filterMtimes(watcher.getTimes());<EOL>        const lastCompiled = instance.compiledFiles;<EOL>        instance.compiledFiles = {};<EOL>        instance.startTime = startTime;<EOL>        const set = new Set(Object.keys(times).map(toUnix));<EOL>        if (instance.watchedFiles || lastCompiled) {<EOL>            const removedFiles = [];<EOL>            const checkFiles = (instance.watchedFiles || Object.keys(lastCompiled)) as any;<EOL>            checkFiles.","gt":"forEach(file => {"}
{"input":"<s> function setupWatchRun(compiler, instanceName: string) {<EOL>    compiler.plugin('<STR_LIT>', function (watching, callback) {<EOL>        const instance = resolveInstance(watching.compiler, instanceName);<EOL>        const checker = instance.checker;<EOL>        const watcher = watching.compiler.watchFileSystem.watcher<EOL>            || watching.compiler.watchFileSystem.wfs.watcher;<EOL>        const startTime = instance.startTime || watching.startTime;<EOL>        const times = filterMtimes(watcher.getTimes());<EOL>        const lastCompiled = instance.compiledFiles;<EOL>        instance.compiledFiles = {};<EOL>        instance.startTime = startTime;<EOL>        const set = new Set(Object.keys(times).map(toUnix));<EOL>        if (instance.watchedFiles || lastCompiled) {<EOL>            const removedFiles = [];<EOL>            const checkFiles = (instance.watchedFiles || Object.keys(lastCompiled)) as any;<EOL>            checkFiles.forEach(file => {<EOL>                if (!set.has(file)) {<EOL>                    removedFiles.push(file);<EOL>                }<EOL>            });<EOL>            removedFiles.","gt":"forEach(file => {"}
{"input":"<s> function setupWatchRun(compiler, instanceName: string) {<EOL>    compiler.plugin('<STR_LIT>', function (watching, callback) {<EOL>        const instance = resolveInstance(watching.compiler, instanceName);<EOL>        const checker = instance.checker;<EOL>        const watcher = watching.compiler.watchFileSystem.watcher<EOL>            || watching.compiler.watchFileSystem.wfs.watcher;<EOL>        const startTime = instance.startTime || watching.startTime;<EOL>        const times = filterMtimes(watcher.getTimes());<EOL>        const lastCompiled = instance.compiledFiles;<EOL>        instance.compiledFiles = {};<EOL>        instance.startTime = startTime;<EOL>        const set = new Set(Object.keys(times).map(toUnix));<EOL>        if (instance.watchedFiles || lastCompiled) {<EOL>            const removedFiles = [];<EOL>            const checkFiles = (instance.watchedFiles || Object.keys(lastCompiled)) as any;<EOL>            checkFiles.forEach(file => {<EOL>                if (!set.has(file)) {<EOL>                    removedFiles.push(file);<EOL>                }<EOL>            });<EOL>            removedFiles.forEach(file => {<EOL>                checker.removeFile(file);<EOL>            });<EOL>        }<EOL>        instance.watchedFiles = set;<EOL>        const instanceTimes = instance.times;<EOL>        instance.times = Object.","gt":"assign({}, times) as any;"}
{"input":"<s> function setupWatchRun(compiler, instanceName: string) {<EOL>    compiler.plugin('<STR_LIT>', function (watching, callback) {<EOL>        const instance = resolveInstance(watching.compiler, instanceName);<EOL>        const checker = instance.checker;<EOL>        const watcher = watching.compiler.watchFileSystem.watcher<EOL>            || watching.compiler.watchFileSystem.wfs.watcher;<EOL>        const startTime = instance.startTime || watching.startTime;<EOL>        const times = filterMtimes(watcher.getTimes());<EOL>        const lastCompiled = instance.compiledFiles;<EOL>        instance.compiledFiles = {};<EOL>        instance.startTime = startTime;<EOL>        const set = new Set(Object.keys(times).map(toUnix));<EOL>        if (instance.watchedFiles || lastCompiled) {<EOL>            const removedFiles = [];<EOL>            const checkFiles = (instance.watchedFiles || Object.keys(lastCompiled)) as any;<EOL>            checkFiles.forEach(file => {<EOL>                if (!set.has(file)) {<EOL>                    removedFiles.push(file);<EOL>                }<EOL>            });<EOL>            removedFiles.forEach(file => {<EOL>                checker.removeFile(file);<EOL>            });<EOL>        }<EOL>        instance.watchedFiles = set;<EOL>        const instanceTimes = instance.times;<EOL>        instance.times = Object.assign({}, times) as any;<EOL>        const changedFiles = Object.keys(times)<EOL>            .filter(fileName => {<EOL>            const updated = times[fileName] > (instanceTimes[fileName] || startTime);<EOL>            return updated;<EOL>        });<EOL>        const updates = changedFiles<EOL>            .map(fileName => {<EOL>            const unixFileName = toUnix(fileName);<EOL>            if (fs.existsSync(unixFileName)) {<EOL>                return","gt":"checker.updateFile(unixFileName, fs.readFileSync(unixFileName).toString(), true);"}
{"input":"<s> function setupWatchRun(compiler, instanceName: string) {<EOL>    compiler.plugin('<STR_LIT>', function (watching, callback) {<EOL>        const instance = resolveInstance(watching.compiler, instanceName);<EOL>        const checker = instance.checker;<EOL>        const watcher = watching.compiler.watchFileSystem.watcher<EOL>            || watching.compiler.watchFileSystem.wfs.watcher;<EOL>        const startTime = instance.startTime || watching.startTime;<EOL>        const times = filterMtimes(watcher.getTimes());<EOL>        const lastCompiled = instance.compiledFiles;<EOL>        instance.compiledFiles = {};<EOL>        instance.startTime = startTime;<EOL>        const set = new Set(Object.keys(times).map(toUnix));<EOL>        if (instance.watchedFiles || lastCompiled) {<EOL>            const removedFiles = [];<EOL>            const checkFiles = (instance.watchedFiles || Object.keys(lastCompiled)) as any;<EOL>            checkFiles.forEach(file => {<EOL>                if (!set.has(file)) {<EOL>                    removedFiles.push(file);<EOL>                }<EOL>            });<EOL>            removedFiles.forEach(file => {<EOL>                checker.removeFile(file);<EOL>            });<EOL>        }<EOL>        instance.watchedFiles = set;<EOL>        const instanceTimes = instance.times;<EOL>        instance.times = Object.assign({}, times) as any;<EOL>        const changedFiles = Object.keys(times)<EOL>            .filter(fileName => {<EOL>            const updated = times[fileName] > (instanceTimes[fileName] || startTime);<EOL>            return updated;<EOL>        });<EOL>        const updates = changedFiles<EOL>            .map(fileName => {<EOL>            const unixFileName = toUnix(fileName);<EOL>            if (fs.existsSync(unixFileName)) {<EOL>                return checker.updateFile(unixFileName, fs.readFileSync(unixFileName).toString(), true);<EOL>            }<EOL>            else {<EOL>                return","gt":"checker.removeFile(unixFileName);"}
{"input":"<s> function setupWatchRun(compiler, instanceName: string) {<EOL>    compiler.plugin('<STR_LIT>', function (watching, callback) {<EOL>        const instance = resolveInstance(watching.compiler, instanceName);<EOL>        const checker = instance.checker;<EOL>        const watcher = watching.compiler.watchFileSystem.watcher<EOL>            || watching.compiler.watchFileSystem.wfs.watcher;<EOL>        const startTime = instance.startTime || watching.startTime;<EOL>        const times = filterMtimes(watcher.getTimes());<EOL>        const lastCompiled = instance.compiledFiles;<EOL>        instance.compiledFiles = {};<EOL>        instance.startTime = startTime;<EOL>        const set = new Set(Object.keys(times).map(toUnix));<EOL>        if (instance.watchedFiles || lastCompiled) {<EOL>            const removedFiles = [];<EOL>            const checkFiles = (instance.watchedFiles || Object.keys(lastCompiled)) as any;<EOL>            checkFiles.forEach(file => {<EOL>                if (!set.has(file)) {<EOL>                    removedFiles.push(file);<EOL>                }<EOL>            });<EOL>            removedFiles.forEach(file => {<EOL>                checker.removeFile(file);<EOL>            });<EOL>        }<EOL>        instance.watchedFiles = set;<EOL>        const instanceTimes = instance.times;<EOL>        instance.times = Object.assign({}, times) as any;<EOL>        const changedFiles = Object.keys(times)<EOL>            .filter(fileName => {<EOL>            const updated = times[fileName] > (instanceTimes[fileName] || startTime);<EOL>            return updated;<EOL>        });<EOL>        const updates = changedFiles<EOL>            .map(fileName => {<EOL>            const unixFileName = toUnix(fileName);<EOL>            if (fs.existsSync(unixFileName)) {<EOL>                return checker.updateFile(unixFileName, fs.readFileSync(unixFileName).toString(), true);<EOL>            }<EOL>            else {<EOL>                return checker.removeFile(unixFileName);<EOL>            }<EOL>        });<EOL>","gt":"Promise.all(updates)"}
{"input":"<s> export function status() {<EOL>    return fetchJSON('<STR_LIT>', {<EOL>        query: {<EOL>            v: window.AppVersion ? window.AppVersion.version : null<EOL>        }<EOL>    })<EOL>        .then((","gt":"data: ApiStatus) => {"}
{"input":"<s> export function status() {<EOL>    return fetchJSON('<STR_LIT>', {<EOL>        query: {<EOL>            v: window.AppVersion ? window.AppVersion.version : null<EOL>        }<EOL>    })<EOL>        .then((data: ApiStatus) => {<EOL>        <EOL>        if (data.mustUpgrade) {<EOL>            const","gt":"v = window.AppVersion ? window.AppVersion.version : '<STR_LIT>';"}
{"input":"<s> export function status() {<EOL>    return fetchJSON('<STR_LIT>', {<EOL>        query: {<EOL>            v: window.AppVersion ? window.AppVersion.version : null<EOL>        }<EOL>    })<EOL>        .then((data: ApiStatus) => {<EOL>        <EOL>        if (data.mustUpgrade) {<EOL>            const v = window.AppVersion ? window.AppVersion.version : '<STR_LIT>';<EOL>            const key = '<STR_LIT>' + v;<EOL>            const warnCount = Number(storage.get(key)) || <NUM_LIT>;<EOL>            if (warnCount === <NUM_LIT>) {<EOL>                window.navigator.notification.alert('<STR_LIT>', () => {<EOL>                    storage.set(key, <NUM_LIT>);<EOL>                });<EOL>            }<EOL>            else if (warnCount === <NUM_LIT>) {<EOL>                storage.remove(key);<EOL>            }<EOL>","gt":"else {"}
{"input":"<s> export function status() {<EOL>    return fetchJSON('<STR_LIT>', {<EOL>        query: {<EOL>            v: window.AppVersion ? window.AppVersion.version : null<EOL>        }<EOL>    })<EOL>        .then((data: ApiStatus) => {<EOL>        <EOL>        if (data.mustUpgrade) {<EOL>            const v = window.AppVersion ? window.AppVersion.version : '<STR_LIT>';<EOL>            const key = '<STR_LIT>' + v;<EOL>            const warnCount = Number(storage.get(key)) || <NUM_LIT>;<EOL>            if (warnCount === <NUM_LIT>) {<EOL>                window.navigator.notification.alert('<STR_LIT>', () => {<EOL>                    storage.set(key, <NUM_LIT>);<EOL>                });<EOL>            }<EOL>            else if (warnCount === <NUM_LIT>) {<EOL>                storage.remove(key);<EOL>            }<EOL>            else {<EOL>                storage.set(key, warnCount + <NUM_LIT>);<EOL>            }<EOL>        }<EOL>        else if (data.api.current > globalConfig.apiVersion) {<EOL>            const versionInfo = data.api.olds.find(o => o.version === globalConfig.apiVersion);<EOL>            if (","gt":"versionInfo) {"}
{"input":"<s> export function status() {<EOL>    return fetchJSON('<STR_LIT>', {<EOL>        query: {<EOL>            v: window.AppVersion ? window.AppVersion.version : null<EOL>        }<EOL>    })<EOL>        .then((data: ApiStatus) => {<EOL>        <EOL>        if (data.mustUpgrade) {<EOL>            const v = window.AppVersion ? window.AppVersion.version : '<STR_LIT>';<EOL>            const key = '<STR_LIT>' + v;<EOL>            const warnCount = Number(storage.get(key)) || <NUM_LIT>;<EOL>            if (warnCount === <NUM_LIT>) {<EOL>                window.navigator.notification.alert('<STR_LIT>', () => {<EOL>                    storage.set(key, <NUM_LIT>);<EOL>                });<EOL>            }<EOL>            else if (warnCount === <NUM_LIT>) {<EOL>                storage.remove(key);<EOL>            }<EOL>            else {<EOL>                storage.set(key, warnCount + <NUM_LIT>);<EOL>            }<EOL>        }<EOL>        else if (data.api.current > globalConfig.apiVersion) {<EOL>            const versionInfo = data.api.olds.find(o => o.version === globalConfig.apiVersion);<EOL>            if (versionInfo) {<EOL>                const now = new Date(), unsupportedDate = new Date(versionInfo.unsupportedAt), deprecatedDate = new Date(versionInfo.deprecatedAt);<EOL>                const key = '<STR_LIT>' + versionInfo.version;<EOL>                const deprWarnCount = Number(storage.get(key)) || <NUM_LIT>;<EOL>                if (now > unsupportedDate) {<EOL>                    window.navigator.notification.alert(i18n('<STR_LIT>'), noop);<EOL>                }<EOL>                else if (now > deprecatedDate) {<EOL>                    if (deprWarnCount === <NUM_LIT>) {<EOL>                        window.navigator.notification.alert(i18n('<STR_LIT>', window.moment(unsupportedDate).format('<STR_LIT>')), () => {<EOL>                            storage.set(key,","gt":"<NUM_LIT>);"}
{"input":"<s> export function status() {<EOL>    return fetchJSON('<STR_LIT>', {<EOL>        query: {<EOL>            v: window.AppVersion ? window.AppVersion.version : null<EOL>        }<EOL>    })<EOL>        .then((data: ApiStatus) => {<EOL>        <EOL>        if (data.mustUpgrade) {<EOL>            const v = window.AppVersion ? window.AppVersion.version : '<STR_LIT>';<EOL>            const key = '<STR_LIT>' + v;<EOL>            const warnCount = Number(storage.get(key)) || <NUM_LIT>;<EOL>            if (warnCount === <NUM_LIT>) {<EOL>                window.navigator.notification.alert('<STR_LIT>', () => {<EOL>                    storage.set(key, <NUM_LIT>);<EOL>                });<EOL>            }<EOL>            else if (warnCount === <NUM_LIT>) {<EOL>                storage.remove(key);<EOL>            }<EOL>            else {<EOL>                storage.set(key, warnCount + <NUM_LIT>);<EOL>            }<EOL>        }<EOL>        else if (data.api.current > globalConfig.apiVersion) {<EOL>            const versionInfo = data.api.olds.find(o => o.version === globalConfig.apiVersion);<EOL>            if (versionInfo) {<EOL>                const now = new Date(), unsupportedDate = new Date(versionInfo.unsupportedAt), deprecatedDate = new Date(versionInfo.deprecatedAt);<EOL>                const key = '<STR_LIT>' + versionInfo.version;<EOL>                const deprWarnCount = Number(storage.get(key)) || <NUM_LIT>;<EOL>                if (now > unsupportedDate) {<EOL>                    window.navigator.notification.alert(i18n('<STR_LIT>'), noop);<EOL>                }<EOL>                else if (now > deprecatedDate) {<EOL>                    if (deprWarnCount === <NUM_LIT>) {<EOL>                        window.navigator.notification.alert(i18n('<STR_LIT>', window.moment(unsupportedDate).format('<STR_LIT>')), () => {<EOL>                            storage.set(key, <NUM_LIT>);<EOL>                        });<EOL>                    }<EOL>                    else if (deprWarnCount === <NUM_LIT>) {<EOL>                        storage.","gt":"remove(key);"}
{"input":"<s> export function status() {<EOL>    return fetchJSON('<STR_LIT>', {<EOL>        query: {<EOL>            v: window.AppVersion ? window.AppVersion.version : null<EOL>        }<EOL>    })<EOL>        .then((data: ApiStatus) => {<EOL>        <EOL>        if (data.mustUpgrade) {<EOL>            const v = window.AppVersion ? window.AppVersion.version : '<STR_LIT>';<EOL>            const key = '<STR_LIT>' + v;<EOL>            const warnCount = Number(storage.get(key)) || <NUM_LIT>;<EOL>            if (warnCount === <NUM_LIT>) {<EOL>                window.navigator.notification.alert('<STR_LIT>', () => {<EOL>                    storage.set(key, <NUM_LIT>);<EOL>                });<EOL>            }<EOL>            else if (warnCount === <NUM_LIT>) {<EOL>                storage.remove(key);<EOL>            }<EOL>            else {<EOL>                storage.set(key, warnCount + <NUM_LIT>);<EOL>            }<EOL>        }<EOL>        else if (data.api.current > globalConfig.apiVersion) {<EOL>            const versionInfo = data.api.olds.find(o => o.version === globalConfig.apiVersion);<EOL>            if (versionInfo) {<EOL>                const now = new Date(), unsupportedDate = new Date(versionInfo.unsupportedAt), deprecatedDate = new Date(versionInfo.deprecatedAt);<EOL>                const key = '<STR_LIT>' + versionInfo.version;<EOL>                const deprWarnCount = Number(storage.get(key)) || <NUM_LIT>;<EOL>                if (now > unsupportedDate) {<EOL>                    window.navigator.notification.alert(i18n('<STR_LIT>'), noop);<EOL>                }<EOL>                else if (now > deprecatedDate) {<EOL>                    if (deprWarnCount === <NUM_LIT>) {<EOL>                        window.navigator.notification.alert(i18n('<STR_LIT>', window.moment(unsupportedDate).format('<STR_LIT>')), () => {<EOL>                            storage.set(key, <NUM_LIT>);<EOL>                        });<EOL>                    }<EOL>                    else if (deprWarnCount === <NUM_LIT>) {<EOL>                        storage.remove(key);<EOL>                    }<EOL>","gt":"else {"}
{"input":"<s> export function generateWebConfigFile(webConfigTargetPath: string, appType: string, substitutionParameters: any) {<EOL>    <EOL>    var webConfigTemplatePath = path.join(__dirname, '<STR_LIT>',","gt":"appType.toLowerCase());"}
{"input":"<s> export function search(query: SearchQuery, page: number = <NUM_LIT>): Promise<SearchResult> {<EOL>    return fetchJSON('<STR_LIT>', {<EOL>        method:","gt":"'<STR_LIT>',"}
{"input":"<s> export function getWeeksForMonth(month: number, year: number, weekStartsOn = <NUM_LIT>): Week[] {<EOL>    const firstOfMonth = new Date(year, month, <NUM_LIT>);<EOL>    const firstDayOfWeek = firstOfMonth.getDay();<EOL>    const weeks: Week[] = [[]];<EOL>","gt":"let currentWeek = weeks[<NUM_LIT>];"}
{"input":"<s> export function getWeeksForMonth(month: number, year: number, weekStartsOn = <NUM_LIT>): Week[] {<EOL>    const firstOfMonth = new Date(year, month, <NUM_LIT>);<EOL>    const firstDayOfWeek = firstOfMonth.getDay();<EOL>    const weeks: Week[] = [[]];<EOL>    let currentWeek = weeks[<NUM_LIT>];<EOL>    let currentDate = firstOfMonth;<EOL>    const orderedWeekday = getOrderedWeekdays(weekStartsOn);<EOL>    for (","gt":"let i = <NUM_LIT>; i < orderedWeekday.indexOf(firstDayOfWeek); i++) {"}
{"input":"<s> export function getWeeksForMonth(month: number, year: number, weekStartsOn = <NUM_LIT>): Week[] {<EOL>    const firstOfMonth = new Date(year, month, <NUM_LIT>);<EOL>    const firstDayOfWeek = firstOfMonth.getDay();<EOL>    const weeks: Week[] = [[]];<EOL>    let currentWeek = weeks[<NUM_LIT>];<EOL>    let currentDate = firstOfMonth;<EOL>    const orderedWeekday = getOrderedWeekdays(weekStartsOn);<EOL>    for (let i = <NUM_LIT>; i < orderedWeekday.indexOf(firstDayOfWeek); i++) {<EOL>        currentWeek.push(null);<EOL>    }<EOL>    while (currentDate.getMonth() === month) {<EOL>        if (currentWeek.length === WEEK_LENGTH) {<EOL>","gt":"currentWeek = [];"}
{"input":"<s> export function getWeeksForMonth(month: number, year: number, weekStartsOn = <NUM_LIT>): Week[] {<EOL>    const firstOfMonth = new Date(year, month, <NUM_LIT>);<EOL>    const firstDayOfWeek = firstOfMonth.getDay();<EOL>    const weeks: Week[] = [[]];<EOL>    let currentWeek = weeks[<NUM_LIT>];<EOL>    let currentDate = firstOfMonth;<EOL>    const orderedWeekday = getOrderedWeekdays(weekStartsOn);<EOL>    for (let i = <NUM_LIT>; i < orderedWeekday.indexOf(firstDayOfWeek); i++) {<EOL>        currentWeek.push(null);<EOL>    }<EOL>    while (currentDate.getMonth() === month) {<EOL>        if (currentWeek.length === WEEK_LENGTH) {<EOL>            currentWeek = [];<EOL>            weeks.push(currentWeek);<EOL>        }<EOL>        currentWeek.push(currentDate);<EOL>        currentDate = new Date(year, month,","gt":"currentDate.getDate() + <NUM_LIT>);"}
{"input":"<s> export function boolean(value: any): value is boolean {<EOL>    return value ===","gt":"true || value === false;"}
{"input":"<s> async function uploadBlob(blobService: azure.BlobService, quality: string, blobName: string, file: string): Promise<void> {<EOL>    const blobOptions: azure.BlobService.CreateBlockBlobRequestOptions = {<EOL>        contentSettings: {<EOL>","gt":"contentType: mime.lookup(file),"}
{"input":"<s> /** @ngInject **/<EOL>export function metricsTabDirective() {<EOL>    '<STR_LIT>';<EOL>    return {<EOL>        restrict:","gt":"'<STR_LIT>',"}
{"input":"<s> function tablebaseRelevant(fen: string) {<EOL>    const parts = fen.","gt":"split(/\\s/);"}
{"input":"<s> export function getPreviousDisplayYear(month: number, year: number): number {<EOL>    if (month === <NUM_LIT>) {<EOL>","gt":"return year - <NUM_LIT>;"}
{"input":"<s> function aLocalExtension(id: string, contributes?: IExtensionContributions): ILocalExtension {<EOL>    const [publisher, name] = id.split('<STR_LIT>');<EOL>    return <ILocalExtension>Object.create({<EOL>        identifier: {","gt":"id },"}
{"input":"<s> function escapeSpecialChars(query: string): string {<EOL>    return query.replace(/\\./g, '<STR_LIT>')<EOL>        .replace(/[\\\\/+\\-&|!\"~*?:(){}\\[\\]\\^]/g,","gt":"'<STR_LIT>')"}
{"input":"<s> function createBooleanProperty(args: PropertyFactoryArgs): BooleanProperty | undefined {<EOL>    if ((args.type.flags & ts.TypeFlags.BooleanLiteral) === ts.TypeFlags.BooleanLiteral ||<EOL>        (args.","gt":"type.symbol && args.type.symbol.name === '<STR_LIT>')) {"}
{"input":"<s> function createArrayProperty(args: PropertyFactoryArgs): Property | undefined {<EOL>    if (args.typechecker.isArrayLikeType(args.type)) {<EOL>        const arrayType: ts.GenericType = args.type as ts.GenericType;<EOL>        if (!arrayType.typeArguments) {<EOL>            return;<EOL>        }<EOL>        const itemType = arrayType.typeArguments[<NUM_LIT>];<EOL>        if ((itemType.flags & ts.TypeFlags.String) === ts.TypeFlags.String) {<EOL>            const property = new StringArrayProperty(args.id);<EOL>","gt":"return property;"}
{"input":"<s> function createArrayProperty(args: PropertyFactoryArgs): Property | undefined {<EOL>    if (args.typechecker.isArrayLikeType(args.type)) {<EOL>        const arrayType: ts.GenericType = args.type as ts.GenericType;<EOL>        if (!arrayType.typeArguments) {<EOL>            return;<EOL>        }<EOL>        const itemType = arrayType.typeArguments[<NUM_LIT>];<EOL>        if ((itemType.flags & ts.TypeFlags.String) === ts.TypeFlags.String) {<EOL>            const property = new StringArrayProperty(args.id);<EOL>            return property;<EOL>        }<EOL>        if ((itemType.flags & ts.TypeFlags.Number) === ts.TypeFlags.Number) {<EOL>            const property = new NumberArrayProperty(args.id);<EOL>","gt":"return property;"}
{"input":"<s> export function getRectForNode(node: Element | React.ReactNode | Window): Rect {<EOL>    if (!(node instanceof Element)) {<EOL>        return new Rect({<EOL>            width: window.innerWidth,<EOL>","gt":"height: window.innerHeight,"}
{"input":"<s> export function getRectForNode(node: Element | React.ReactNode | Window): Rect {<EOL>    if (!(node instanceof Element)) {<EOL>        return new Rect({<EOL>            width: window.innerWidth,<EOL>            height: window.innerHeight,<EOL>        });<EOL>    }<EOL>    const rect = node.getBoundingClientRect();<EOL>    return new Rect({<EOL>        top: rect.top,<EOL>","gt":"left: rect.left,"}
{"input":"<s> export function isReactElement<T>(x: T): x is T {<EOL>    return isValidElement(x) && x !==","gt":"undefined;"}
{"input":"<s> function getEnumTypeOptions(declaration: ts.EnumDeclaration): Option[] {<EOL>    return declaration.members.map((enumMember, index) => {<EOL>        const enumMemberId = enumMember.name.getText();<EOL>        let enumMemberName = getJsDocValue(enumMember, '<STR_LIT>');<EOL>        if (","gt":"enumMemberName === undefined) {"}
{"input":"<s> function getEnumTypeOptions(declaration: ts.EnumDeclaration): Option[] {<EOL>    return declaration.members.map((enumMember, index) => {<EOL>        const enumMemberId = enumMember.name.getText();<EOL>        let enumMemberName = getJsDocValue(enumMember, '<STR_LIT>');<EOL>        if (enumMemberName === undefined) {<EOL>            enumMemberName = enumMemberId;<EOL>        }<EOL>        const enumMemberOrdinal: number = enumMember.initializer<EOL>            ? parseInt(enumMember.initializer.getText(), <NUM_LIT>)<EOL>            :","gt":"index;"}
{"input":"<s> export function file(fileName: string, text: string) {<EOL>    return new","gt":"Fixture(fileName, text);"}
{"input":"<s> function removeDragElements(dom: cg.DOM) {<EOL>    if (dom.elements.shadow) {<EOL>        dom.","gt":"elements.shadow.style.transform = util.translate3dAway;"}
{"input":"<s> function reload(ground: Chessground, data: OnlineGameData, fen: string, flip: boolean) {<EOL>    ground.reconfigure(makeConfig(","gt":"data, fen, flip));"}
{"input":"<s> function init() {<EOL>    return (req: Req): Promise<Res> => {<EOL>        <EOL>        const { form, ...o } = req.o || { form: undefined };<EOL>        const opts: Options = o;<EOL>        if (form) {<EOL>            const fd =","gt":"new FormData();"}
{"input":"<s> function init() {<EOL>    return (req: Req): Promise<Res> => {<EOL>        <EOL>        const { form, ...o } = req.o || { form: undefined };<EOL>        const opts: Options = o;<EOL>        if (form) {<EOL>            const fd = new FormData();<EOL>            form.forEach(entry => {<EOL>                fd.append(entry.key, entry.value, entry.fileName);<EOL>            });<EOL>            opts.","gt":"form = fd;"}
{"input":"<s> function init() {<EOL>    return (req: Req): Promise<Res> => {<EOL>        <EOL>        const { form, ...o } = req.o || { form: undefined };<EOL>        const opts: Options = o;<EOL>        if (form) {<EOL>            const fd = new FormData();<EOL>            form.forEach(entry => {<EOL>                fd.append(entry.key, entry.value, entry.fileName);<EOL>            });<EOL>            opts.form = fd;<EOL>        }<EOL>        return request(req.m, req.u, opts).then(response => ({<EOL>            s: response.statusCode,<EOL>            h: response.","gt":"headers,"}
{"input":"<s> function buildParams(params: {<EOL>    [name: string]: any;<EOL>}): AnimationOptions {<EOL>","gt":"return <AnimationOptions>{ params };"}
{"input":"<s> export function initBoard(cfg: cg.InitConfig): State {<EOL>","gt":"const defaults = makeDefaults();"}
{"input":"<s> export function overlay(ctrl: TrainingCtrl) {<EOL>    return [<EOL>        renderPromotion(","gt":"ctrl),"}
{"input":"<s> function it(label: string, test: () => void) {<EOL>","gt":"testName = label;"}
{"input":"<s> function scoreSeparatorAtPos(charCode: number): number {<EOL>    switch (charCode) {<EOL>        case CharCode.Slash:<EOL>        case CharCode.Backslash:<EOL>            return <NUM_LIT>; <EOL>","gt":"case CharCode.Underline:"}
{"input":"<s> function scoreSeparatorAtPos(charCode: number): number {<EOL>    switch (charCode) {<EOL>        case CharCode.Slash:<EOL>        case CharCode.Backslash:<EOL>            return <NUM_LIT>; <EOL>        case CharCode.Underline:<EOL>        case CharCode.Dash:<EOL>        case CharCode.Period:<EOL>        case CharCode.Space:<EOL>","gt":"case CharCode.SingleQuote:"}
{"input":"<s> function scoreSeparatorAtPos(charCode: number): number {<EOL>    switch (charCode) {<EOL>        case CharCode.Slash:<EOL>        case CharCode.Backslash:<EOL>            return <NUM_LIT>; <EOL>        case CharCode.Underline:<EOL>        case CharCode.Dash:<EOL>        case CharCode.Period:<EOL>        case CharCode.Space:<EOL>        case CharCode.SingleQuote:<EOL>        case CharCode.DoubleQuote:<EOL>        case CharCode.Colon:<EOL>            return","gt":"<NUM_LIT>;"}
{"input":"<s> export function initialLayout() {<EOL>    return {<EOL>        berniePage: initialBerniePageLayout,<EOL>        blogPage:","gt":"initialBlogPageLayout,"}
{"input":"<s> function onKeyboardShow(e: Ionic.KeyboardEvent) {<EOL>    if (window.cordova.platformId === '<STR_LIT>') {<EOL>        let ta = document.getElementById('<STR_LIT>');<EOL>","gt":"if (!ta)"}
{"input":"<s> function loadFileFromArguments(platform, args, workingDirectory) {<EOL>    const localOni = \"<STR_LIT>\";<EOL>    if (!process.env[localOni]) {<EOL>        createWindow(args.slice(<NUM_LIT>),","gt":"workingDirectory);"}
{"input":"<s> export function isSection(arr: Descriptor[]): arr is SectionDescriptor[] {<EOL>","gt":"return (typeof arr[<NUM_LIT>] === '<STR_LIT>' &&"}
{"input":"<s> export default function retroView(root: AnalyseCtrl): Mithril.BaseNode | undefined {<EOL>    const ctrl = root.retro;<EOL>    if (!ctrl)<EOL>        return;<EOL>    const","gt":"fb = ctrl.vm.feedback;"}
{"input":"<s> export default function retroView(root: AnalyseCtrl): Mithril.BaseNode | undefined {<EOL>    const ctrl = root.retro;<EOL>    if (!ctrl)<EOL>        return;<EOL>    const fb = ctrl.vm.feedback;<EOL>    return h('<STR_LIT>', {<EOL>        className: ctrl.vm.minimized ? '<STR_LIT>' : '<STR_LIT>'<EOL>    }, [<EOL>        renderTitle(","gt":"ctrl),"}
{"input":"<s> export function isElementInViewport(element: Element) {<EOL>    const { top, left, bottom, right } = element.getBoundingClientRect();<EOL>    return (","gt":"top >= <NUM_LIT> &&"}
{"input":"<s> export function secondsToTimestamp(numSeconds: number) {<EOL>    const { hours, minutes, seconds } = secondsToTimeComponents(numSeconds);<EOL>","gt":"const hasHours = numSeconds > HOUR;"}
{"input":"<s> export function isDrop(o: MoveOrDrop): o is Drop {<EOL>","gt":"return (<Drop>o).isDrop;"}
{"input":"<s> function cancel(ctrl: OnlineRoundInterface) {<EOL>    if (","gt":"promoting)"}
{"input":"<s> function internalScriptRecord(startTime: number, endTime: number) {<EOL>    return {<EOL>        '<STR_LIT>':","gt":"'<STR_LIT>',"}
{"input":"<s> function capture(chessgroundCtrl: Chessground, key: Key) {<EOL>    const exploding: Key[] = [];<EOL>    const diff: cg.PiecesDiff = {};<EOL>    const orig = key2pos(key);<EOL>    for (let x = -<NUM_LIT>; x < <NUM_LIT>; x++) {<EOL>        for (let y = -<NUM_LIT>;","gt":"y < <NUM_LIT>; y++) {"}
{"input":"<s> function capture(chessgroundCtrl: Chessground, key: Key) {<EOL>    const exploding: Key[] = [];<EOL>    const diff: cg.PiecesDiff = {};<EOL>    const orig = key2pos(key);<EOL>    for (let x = -<NUM_LIT>; x < <NUM_LIT>; x++) {<EOL>        for (let y = -<NUM_LIT>; y < <NUM_LIT>; y++) {<EOL>            const k = pos2key([orig[<NUM_LIT>] + x, orig[<NUM_LIT>] + y] as cg.Pos);<EOL>            if (k) {<EOL>                exploding.push(k);<EOL>                const explodes = chessgroundCtrl.state.pieces[k] && (k === key || chessgroundCtrl.state.","gt":"pieces[k].role !== '<STR_LIT>');"}
{"input":"<s> export function annotate(typeChecker: ts.TypeChecker, file: ts.SourceFile, host: AnnotatorHost, tsHost: ts.ModuleResolutionHost, tsOpts: ts.CompilerOptions, sourceMapper?: SourceMapper): {<EOL>    output: string;<EOL>    diagnostics: ts.Diagnostic[];<EOL>} {<EOL>","gt":"return new Annotator(typeChecker, file, host, tsHost, tsOpts, sourceMapper).annotate();"}
{"input":"<s> export function measureFont(fontFamily: string, fontSize: string, characterToTest = \"<STR_LIT>\") {<EOL>    const div = document.createElement(\"<STR_LIT>\");<EOL>    div.style.position = \"<STR_LIT>\";<EOL>    div.style.left = \"<STR_LIT>\";<EOL>    div.style.top = \"<STR_LIT>\";<EOL>    div.style.backgroundColor =","gt":"\"<STR_LIT>\";"}
{"input":"<s> export function measureFont(fontFamily: string, fontSize: string, characterToTest = \"<STR_LIT>\") {<EOL>    const div = document.createElement(\"<STR_LIT>\");<EOL>    div.style.position = \"<STR_LIT>\";<EOL>    div.style.left = \"<STR_LIT>\";<EOL>    div.style.top = \"<STR_LIT>\";<EOL>    div.style.backgroundColor = \"<STR_LIT>\";<EOL>    div.style.left = \"<STR_LIT>\";<EOL>    div.style.top = \"<STR_LIT>\";<EOL>    div.","gt":"textContent = characterToTest;"}
{"input":"<s> export function measureFont(fontFamily: string, fontSize: string, characterToTest = \"<STR_LIT>\") {<EOL>    const div = document.createElement(\"<STR_LIT>\");<EOL>    div.style.position = \"<STR_LIT>\";<EOL>    div.style.left = \"<STR_LIT>\";<EOL>    div.style.top = \"<STR_LIT>\";<EOL>    div.style.backgroundColor = \"<STR_LIT>\";<EOL>    div.style.left = \"<STR_LIT>\";<EOL>    div.style.top = \"<STR_LIT>\";<EOL>    div.textContent = characterToTest;<EOL>    div.style.fontFamily = `<STR_LIT>`;<EOL>    div.style.fontSize = fontSize;<EOL>    const isItalicAvailable = isStyleAvailable(fontFamily, \"<STR_LIT>\", fontSize);<EOL>    const isBoldAvailable = isStyleAvailable(fontFamily, \"<STR_LIT>\", fontSize);<EOL>    document.body.appendChild(","gt":"div);"}
{"input":"<s> export function measureFont(fontFamily: string, fontSize: string, characterToTest = \"<STR_LIT>\") {<EOL>    const div = document.createElement(\"<STR_LIT>\");<EOL>    div.style.position = \"<STR_LIT>\";<EOL>    div.style.left = \"<STR_LIT>\";<EOL>    div.style.top = \"<STR_LIT>\";<EOL>    div.style.backgroundColor = \"<STR_LIT>\";<EOL>    div.style.left = \"<STR_LIT>\";<EOL>    div.style.top = \"<STR_LIT>\";<EOL>    div.textContent = characterToTest;<EOL>    div.style.fontFamily = `<STR_LIT>`;<EOL>    div.style.fontSize = fontSize;<EOL>    const isItalicAvailable = isStyleAvailable(fontFamily, \"<STR_LIT>\", fontSize);<EOL>    const isBoldAvailable = isStyleAvailable(fontFamily, \"<STR_LIT>\", fontSize);<EOL>    document.body.appendChild(div);<EOL>    const rect = div.getBoundingClientRect();<EOL>    const width = rect.width;<EOL>    const height = rect.height;<EOL>    document.body.removeChild(div);<EOL>","gt":"return {"}
{"input":"<s> function removeTagPrefix(value: string): string {<EOL>    return value.replace(TAG_PREFIX,","gt":"'<STR_LIT>');"}
{"input":"<s> /** @ngInject */<EOL>function editorOptBool($compile) {<EOL>    return {<EOL>        restrict: '<STR_LIT>',<EOL>        link: function (scope,","gt":"elem, attrs) {"}
{"input":"<s> /** @ngInject */<EOL>function editorOptBool($compile) {<EOL>    return {<EOL>        restrict: '<STR_LIT>',<EOL>        link: function (scope, elem, attrs) {<EOL>            var ngchange = attrs.change ? '<STR_LIT>' + attrs.change + '<STR_LIT>' : '<STR_LIT>';<EOL>            var tip = attrs.tip ? '<STR_LIT>' + attrs.tip + '<STR_LIT>' : '<STR_LIT>';<EOL>            var showIf =","gt":"attrs.showIf ? '<STR_LIT>' + attrs.showIf + '<STR_LIT>' : '<STR_LIT>';"}
{"input":"<s> /** @ngInject */<EOL>function editorOptBool($compile) {<EOL>    return {<EOL>        restrict: '<STR_LIT>',<EOL>        link: function (scope, elem, attrs) {<EOL>            var ngchange = attrs.change ? '<STR_LIT>' + attrs.change + '<STR_LIT>' : '<STR_LIT>';<EOL>            var tip = attrs.tip ? '<STR_LIT>' + attrs.tip + '<STR_LIT>' : '<STR_LIT>';<EOL>            var showIf = attrs.showIf ? '<STR_LIT>' + attrs.showIf + '<STR_LIT>' : '<STR_LIT>';<EOL>            var template = '<STR_LIT>' +<EOL>                showIf +<EOL>                '<STR_LIT>' +<EOL>","gt":"'<STR_LIT>' +"}
{"input":"<s> /** @ngInject */<EOL>function editorOptBool($compile) {<EOL>    return {<EOL>        restrict: '<STR_LIT>',<EOL>        link: function (scope, elem, attrs) {<EOL>            var ngchange = attrs.change ? '<STR_LIT>' + attrs.change + '<STR_LIT>' : '<STR_LIT>';<EOL>            var tip = attrs.tip ? '<STR_LIT>' + attrs.tip + '<STR_LIT>' : '<STR_LIT>';<EOL>            var showIf = attrs.showIf ? '<STR_LIT>' + attrs.showIf + '<STR_LIT>' : '<STR_LIT>';<EOL>            var template = '<STR_LIT>' +<EOL>                showIf +<EOL>                '<STR_LIT>' +<EOL>                '<STR_LIT>' +<EOL>                attrs.model +<EOL>                '<STR_LIT>' +<EOL>                attrs.","gt":"text +"}
{"input":"<s> /** @ngInject */<EOL>function editorOptBool($compile) {<EOL>    return {<EOL>        restrict: '<STR_LIT>',<EOL>        link: function (scope, elem, attrs) {<EOL>            var ngchange = attrs.change ? '<STR_LIT>' + attrs.change + '<STR_LIT>' : '<STR_LIT>';<EOL>            var tip = attrs.tip ? '<STR_LIT>' + attrs.tip + '<STR_LIT>' : '<STR_LIT>';<EOL>            var showIf = attrs.showIf ? '<STR_LIT>' + attrs.showIf + '<STR_LIT>' : '<STR_LIT>';<EOL>            var template = '<STR_LIT>' +<EOL>                showIf +<EOL>                '<STR_LIT>' +<EOL>                '<STR_LIT>' +<EOL>                attrs.model +<EOL>                '<STR_LIT>' +<EOL>                attrs.text +<EOL>                tip +<EOL>                '<STR_LIT>' +<EOL>                '<STR_LIT>' +<EOL>","gt":"attrs.model +"}
{"input":"<s> /** @ngInject */<EOL>function editorOptBool($compile) {<EOL>    return {<EOL>        restrict: '<STR_LIT>',<EOL>        link: function (scope, elem, attrs) {<EOL>            var ngchange = attrs.change ? '<STR_LIT>' + attrs.change + '<STR_LIT>' : '<STR_LIT>';<EOL>            var tip = attrs.tip ? '<STR_LIT>' + attrs.tip + '<STR_LIT>' : '<STR_LIT>';<EOL>            var showIf = attrs.showIf ? '<STR_LIT>' + attrs.showIf + '<STR_LIT>' : '<STR_LIT>';<EOL>            var template = '<STR_LIT>' +<EOL>                showIf +<EOL>                '<STR_LIT>' +<EOL>                '<STR_LIT>' +<EOL>                attrs.model +<EOL>                '<STR_LIT>' +<EOL>                attrs.text +<EOL>                tip +<EOL>                '<STR_LIT>' +<EOL>                '<STR_LIT>' +<EOL>                attrs.model +<EOL>                '<STR_LIT>' +<EOL>                '<STR_LIT>' +<EOL>                attrs.model +<EOL>                '<STR_LIT>' +<EOL>                ngchange +<EOL>                '<STR_LIT>' +<EOL>","gt":"attrs.model +"}
{"input":"<s> export function userPicker() {<EOL>    return {<EOL>        restrict: '<STR_LIT>',<EOL>        template: template,<EOL>        controller: UserPickerCtrl,<EOL>        bindToController:","gt":"true,"}
{"input":"<s> export function userPicker() {<EOL>    return {<EOL>        restrict: '<STR_LIT>',<EOL>        template: template,<EOL>        controller: UserPickerCtrl,<EOL>        bindToController: true,<EOL>        controllerAs: '<STR_LIT>',<EOL>        scope: {<EOL>            userPicked: '<STR_LIT>',<EOL>        },<EOL>        link: function (scope, elem, attrs, ctrl) {<EOL>            scope.$on('<STR_LIT>', () => {<EOL>                ctrl.","gt":"reset();"}
{"input":"<s> function hasExplicitStyle(domElement, key) {<EOL>    if (!domElement.__haikuExplicitStyles) {<EOL>","gt":"return false;"}
{"input":"<s> <EOL>export function p2pGameReducer(state: any = initialGame.get('<STR_LIT>'), action: PayloadAction) {<EOL>    switch (action.type) {<EOL>        case START_GAME:<EOL>            state = fromJS({});<EOL>","gt":"break;"}
{"input":"<s> <EOL>export function p2pGameReducer(state: any = initialGame.get('<STR_LIT>'), action: PayloadAction) {<EOL>    switch (action.type) {<EOL>        case START_GAME:<EOL>            state = fromJS({});<EOL>            break;<EOL>        case PARTNER_PROGRESS:<EOL>            state = state.set('<STR_LIT>', action.payload.text);<EOL>            break;<EOL>        case PARTNER_COMPLETED:<EOL>            state = state.set('<STR_LIT>', true);<EOL>","gt":"break;"}
{"input":"<s> /** @ngInject */<EOL>export function dashboardViewStateSrv($location, $timeout, $rootScope) {<EOL>    return {<EOL>        create:","gt":"function ($scope) {"}
{"input":"<s> export function readConfiguration(project: string, existingOptions?: ts.CompilerOptions): ParsedConfiguration {<EOL>    try {<EOL>        const { projectFile, basePath } = calcProjectFileAndBasePath(project);<EOL>        let { config, error } = ts.readConfigFile(projectFile, ts.sys.readFile);<EOL>        if (","gt":"error) {"}
{"input":"<s> export function readConfiguration(project: string, existingOptions?: ts.CompilerOptions): ParsedConfiguration {<EOL>    try {<EOL>        const { projectFile, basePath } = calcProjectFileAndBasePath(project);<EOL>        let { config, error } = ts.readConfigFile(projectFile, ts.sys.readFile);<EOL>        if (error) {<EOL>","gt":"return {"}
{"input":"<s> export function readConfiguration(project: string, existingOptions?: ts.CompilerOptions): ParsedConfiguration {<EOL>    try {<EOL>        const { projectFile, basePath } = calcProjectFileAndBasePath(project);<EOL>        let { config, error } = ts.readConfigFile(projectFile, ts.sys.readFile);<EOL>        if (error) {<EOL>            return {<EOL>                project,<EOL>                errors: [error],<EOL>","gt":"rootNames: [],"}
{"input":"<s> export function readConfiguration(project: string, existingOptions?: ts.CompilerOptions): ParsedConfiguration {<EOL>    try {<EOL>        const { projectFile, basePath } = calcProjectFileAndBasePath(project);<EOL>        let { config, error } = ts.readConfigFile(projectFile, ts.sys.readFile);<EOL>        if (error) {<EOL>            return {<EOL>                project,<EOL>                errors: [error],<EOL>                rootNames: [],<EOL>                options: {},<EOL>                emitFlags: api.EmitFlags.Default<EOL>            };<EOL>        }<EOL>        const parseConfigHost = {<EOL>            useCaseSensitiveFileNames: true,<EOL>            fileExists: fs.existsSync,<EOL>            readDirectory: ts.sys.readDirectory,<EOL>            readFile:","gt":"ts.sys.readFile"}
{"input":"<s> export function readConfiguration(project: string, existingOptions?: ts.CompilerOptions): ParsedConfiguration {<EOL>    try {<EOL>        const { projectFile, basePath } = calcProjectFileAndBasePath(project);<EOL>        let { config, error } = ts.readConfigFile(projectFile, ts.sys.readFile);<EOL>        if (error) {<EOL>            return {<EOL>                project,<EOL>                errors: [error],<EOL>                rootNames: [],<EOL>                options: {},<EOL>                emitFlags: api.EmitFlags.Default<EOL>            };<EOL>        }<EOL>        const parseConfigHost = {<EOL>            useCaseSensitiveFileNames: true,<EOL>            fileExists: fs.existsSync,<EOL>            readDirectory: ts.sys.readDirectory,<EOL>            readFile: ts.sys.readFile<EOL>        };<EOL>        const parsed = ts.parseJsonConfigFileContent(config, parseConfigHost, basePath, existingOptions);<EOL>        const rootNames = parsed.fileNames.map(f => path.normalize(f));<EOL>        const options =","gt":"createNgCompilerOptions(basePath, config, parsed.options);"}
{"input":"<s> export function readConfiguration(project: string, existingOptions?: ts.CompilerOptions): ParsedConfiguration {<EOL>    try {<EOL>        const { projectFile, basePath } = calcProjectFileAndBasePath(project);<EOL>        let { config, error } = ts.readConfigFile(projectFile, ts.sys.readFile);<EOL>        if (error) {<EOL>            return {<EOL>                project,<EOL>                errors: [error],<EOL>                rootNames: [],<EOL>                options: {},<EOL>                emitFlags: api.EmitFlags.Default<EOL>            };<EOL>        }<EOL>        const parseConfigHost = {<EOL>            useCaseSensitiveFileNames: true,<EOL>            fileExists: fs.existsSync,<EOL>            readDirectory: ts.sys.readDirectory,<EOL>            readFile: ts.sys.readFile<EOL>        };<EOL>        const parsed = ts.parseJsonConfigFileContent(config, parseConfigHost, basePath, existingOptions);<EOL>        const rootNames = parsed.fileNames.map(f => path.normalize(f));<EOL>        const options = createNgCompilerOptions(basePath, config, parsed.options);<EOL>        let emitFlags = api.EmitFlags.Default;<EOL>        if (!(options.skipMetadataEmit || options.flatModuleOutFile)) {<EOL>            emitFlags |= api.EmitFlags.Metadata;<EOL>        }<EOL>        if (options.skipTemplateCodegen) {<EOL>            emitFlags = emitFlags & ~api.EmitFlags.Codegen;<EOL>        }<EOL>        return { project: projectFile, rootNames, options, errors: parsed.errors,","gt":"emitFlags };"}
{"input":"<s> export function setScrollRegion(top: number, bottom: number, left: number, right: number): ISetScrollRegionAction {<EOL>    return {<EOL>        type: SET_SCROLL_REGION,<EOL>","gt":"top,"}
{"input":"<s> /**<EOL> * Reducers<EOL> */<EOL>export function updateIDs(state: IDs, action: SliceAction): IDs {<EOL>    const entities = action.payload;<EOL>","gt":"return Object.assign({}, state, {"}
{"input":"<s> /** Shorthand to dispatch a fake event on a specified node. */<EOL>export function dispatchFakeEvent(node: Node | Window, type: string, canBubble?: boolean): Event {<EOL>    return dispatchEvent(","gt":"node, createFakeEvent(type, canBubble));"}
{"input":"<s> /** @ngInject */<EOL>export function spectrumPicker() {<EOL>    return {<EOL>        restrict: '<STR_LIT>',<EOL>        require: '<STR_LIT>',<EOL>","gt":"scope: true,"}
{"input":"<s> /** @ngInject */<EOL>export function spectrumPicker() {<EOL>    return {<EOL>        restrict: '<STR_LIT>',<EOL>        require: '<STR_LIT>',<EOL>        scope: true,<EOL>        replace: true,<EOL>        template: '<STR_LIT>',<EOL>        link: function (scope, element, attrs, ngModel) {<EOL>            scope.ngModel = ngModel;<EOL>            scope.onColorChange = color => {<EOL>                ngModel.$setViewValue(","gt":"color);"}
{"input":"<s> <EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL>function controlFlowPlaceholderImpl(element, surrogate, component) {<EOL>    if (!component._didElementRenderSurrogate(element, surrogate)) {<EOL>        element.elementName = surrogate.elementName;<EOL>        element.children = surrogate.children || [];<EOL>        if (surrogate.attributes) {<EOL>            if (!element.","gt":"attributes) {"}
{"input":"<s> <EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL>function controlFlowPlaceholderImpl(element, surrogate, component) {<EOL>    if (!component._didElementRenderSurrogate(element, surrogate)) {<EOL>        element.elementName = surrogate.elementName;<EOL>        element.children = surrogate.children || [];<EOL>        if (surrogate.attributes) {<EOL>            if (!element.attributes) {<EOL>                element.attributes = {};<EOL>            }<EOL>            for (const key in surrogate.attributes) {<EOL>                if (key ===","gt":"'<STR_LIT>') {"}
{"input":"<s> export default function functionToRFO(fn) {<EOL>    let str = fn.toString();<EOL>    <EOL>    if (str[str.","gt":"length - <NUM_LIT>] === '<STR_LIT>') {"}
{"input":"<s> export default function functionToRFO(fn) {<EOL>    let str = fn.toString();<EOL>    <EOL>    if (str[str.length - <NUM_LIT>] === '<STR_LIT>') {<EOL>        if (str[<NUM_LIT>] === '<STR_LIT>') {<EOL>            str = str.slice(<NUM_LIT>);<EOL>        }<EOL>    }<EOL>    const pidx1 = str.indexOf('<STR_LIT>');<EOL>    const pidx2 = str.indexOf('<STR_LIT>');<EOL>","gt":"const prefix = str.slice(<NUM_LIT>, pidx1);"}
{"input":"<s> export default function functionToRFO(fn) {<EOL>    let str = fn.toString();<EOL>    <EOL>    if (str[str.length - <NUM_LIT>] === '<STR_LIT>') {<EOL>        if (str[<NUM_LIT>] === '<STR_LIT>') {<EOL>            str = str.slice(<NUM_LIT>);<EOL>        }<EOL>    }<EOL>    const pidx1 = str.indexOf('<STR_LIT>');<EOL>    const pidx2 = str.indexOf('<STR_LIT>');<EOL>    const prefix = str.slice(<NUM_LIT>, pidx1);<EOL>    const signature = str.slice(pidx1, pidx2 + <NUM_LIT>);<EOL>    const suffix = str.slice(pidx2 + <NUM_LIT>, str.length);<EOL>    const body = suffix.slice(suffix.indexOf('<STR_LIT>') + <NUM_LIT>, suffix.length - <NUM_LIT>).trim(); <EOL>    const type = suffix.match(","gt":"/^\\s*=>\\s*{/)"}
{"input":"<s> export default function functionToRFO(fn) {<EOL>    let str = fn.toString();<EOL>    <EOL>    if (str[str.length - <NUM_LIT>] === '<STR_LIT>') {<EOL>        if (str[<NUM_LIT>] === '<STR_LIT>') {<EOL>            str = str.slice(<NUM_LIT>);<EOL>        }<EOL>    }<EOL>    const pidx1 = str.indexOf('<STR_LIT>');<EOL>    const pidx2 = str.indexOf('<STR_LIT>');<EOL>    const prefix = str.slice(<NUM_LIT>, pidx1);<EOL>    const signature = str.slice(pidx1, pidx2 + <NUM_LIT>);<EOL>    const suffix = str.slice(pidx2 + <NUM_LIT>, str.length);<EOL>    const body = suffix.slice(suffix.indexOf('<STR_LIT>') + <NUM_LIT>, suffix.length - <NUM_LIT>).trim(); <EOL>    const type = suffix.match(/^\\s*=>\\s*{/)<EOL>        ? '<STR_LIT>'<EOL>        : '<STR_LIT>';<EOL>    const name = nth(<NUM_LIT>, '<STR_LIT>', tokenize(prefix)).value;<EOL>    const params =","gt":"signatureToParams(signature);"}
{"input":"<s> export function clear(): IAction {<EOL>","gt":"return {"}
{"input":"<s> function f1() {<EOL>    return","gt":"instance1;"}
{"input":"<s> export function addToLocal$(actions$: Actions, slice: keyof RootState, db, localStoreKey: string): Observable<{}> {<EOL>    return actions$<EOL>        .ofType(","gt":"typeFor(slice, actions.ADD))"}
{"input":"<s> function copyMatrix(m: number[]) {<EOL>","gt":"return [...m];"}
{"input":"<s> function flexIdIfSame(virtual, dom) {<EOL>    if (virtual.attributes) {<EOL>        if (virtual.attributes['<STR_LIT>']) {<EOL>            if (dom.getAttribute('<STR_LIT>') === virtual.attributes['<STR_LIT>']) {<EOL>                return","gt":"virtual.attributes['<STR_LIT>'];"}
{"input":"<s> function interpolate(now, curve, started, ends, origin, destination) {<EOL>    if (Array.isArray(origin) && Array.isArray(destination)) {<EOL>        const arrayOutput = [];<EOL>        for (let i = <NUM_LIT>; i < origin.length; i++) {<EOL>            arrayOutput[i] = interpolate(now, curve, started, ends, origin[i], destination[i]);<EOL>        }<EOL>        return","gt":"arrayOutput;"}
{"input":"<s> function interpolate(now, curve, started, ends, origin, destination) {<EOL>    if (Array.isArray(origin) && Array.isArray(destination)) {<EOL>        const arrayOutput = [];<EOL>        for (let i = <NUM_LIT>; i < origin.length; i++) {<EOL>            arrayOutput[i] = interpolate(now, curve, started, ends, origin[i], destination[i]);<EOL>        }<EOL>        return arrayOutput;<EOL>    }<EOL>    if (origin && typeof origin === OBJECT && destination && typeof destination === OBJECT) {<EOL>        const objectOutput = {};<EOL>","gt":"for (const key in origin) {"}
{"input":"<s> function ascendingSort(a, b) {<EOL>    return a -","gt":"b;"}
{"input":"<s> /**<EOL> * Copyright (c) Haiku 2016-2018. All rights reserved.<EOL> */<EOL>export default function getWindowsBrowser(window) {<EOL>    let rv = -<NUM_LIT>;<EOL>    if (!window) {<EOL>        return rv;<EOL>    }<EOL>","gt":"if (!window.navigator) {"}
{"input":"<s> /**<EOL> * Copyright (c) Haiku 2016-2018. All rights reserved.<EOL> */<EOL>export default function getWindowsBrowser(window) {<EOL>    let rv = -<NUM_LIT>;<EOL>    if (!window) {<EOL>        return rv;<EOL>    }<EOL>    if (!window.navigator) {<EOL>        return rv;<EOL>    }<EOL>","gt":"if (!window.navigator.userAgent) {"}
{"input":"<s> function getLogScaleBucketBound(value, yBucketSplitFactor, logBase) {<EOL>    let bounds = getLogScaleBucketBounds(","gt":"value, yBucketSplitFactor, logBase);"}
{"input":"<s> export function isDirectory(filePath: string): boolean {<EOL>    let stat;<EOL>    try {<EOL>        stat = fs.statSync(filePath);<EOL>    }<EOL>    catch (e) {<EOL>        if (e && (e.code === '<STR_LIT>' || e.code === '<STR_LIT>')) {<EOL>            return false;<EOL>        }<EOL>","gt":"throw e;"}
{"input":"<s> function _build(logger: logging.Logger) {<EOL>    logger.info('<STR_LIT>');<EOL>    const tsConfigPath = path.relative(process.cwd(), path.join(__dirname, '<STR_LIT>'));<EOL>    <EOL>    const tsConfig = ts.readConfigFile(tsConfigPath, ts.sys.readFile);<EOL>    const parsedTsConfig =","gt":"ts.parseJsonConfigFileContent(tsConfig.config, ts.sys, '<STR_LIT>');"}
{"input":"<s> function _build(logger: logging.Logger) {<EOL>    logger.info('<STR_LIT>');<EOL>    const tsConfigPath = path.relative(process.cwd(), path.join(__dirname, '<STR_LIT>'));<EOL>    <EOL>    const tsConfig = ts.readConfigFile(tsConfigPath, ts.sys.readFile);<EOL>    const parsedTsConfig = ts.parseJsonConfigFileContent(tsConfig.config, ts.sys, '<STR_LIT>');<EOL>    <EOL>    const program = ts.createProgram(parsedTsConfig.fileNames, parsedTsConfig.options);<EOL>    const result =","gt":"program.emit();"}
{"input":"<s> function _build(logger: logging.Logger) {<EOL>    logger.info('<STR_LIT>');<EOL>    const tsConfigPath = path.relative(process.cwd(), path.join(__dirname, '<STR_LIT>'));<EOL>    <EOL>    const tsConfig = ts.readConfigFile(tsConfigPath, ts.sys.readFile);<EOL>    const parsedTsConfig = ts.parseJsonConfigFileContent(tsConfig.config, ts.sys, '<STR_LIT>');<EOL>    <EOL>    const program = ts.createProgram(parsedTsConfig.fileNames, parsedTsConfig.options);<EOL>    const result = program.emit();<EOL>    if (result.emitSkipped) {<EOL>        logger.error(`<STR_LIT>`);<EOL>        const diagLogger = logger.createChild(","gt":"'<STR_LIT>');"}
{"input":"<s> function _build(logger: logging.Logger) {<EOL>    logger.info('<STR_LIT>');<EOL>    const tsConfigPath = path.relative(process.cwd(), path.join(__dirname, '<STR_LIT>'));<EOL>    <EOL>    const tsConfig = ts.readConfigFile(tsConfigPath, ts.sys.readFile);<EOL>    const parsedTsConfig = ts.parseJsonConfigFileContent(tsConfig.config, ts.sys, '<STR_LIT>');<EOL>    <EOL>    const program = ts.createProgram(parsedTsConfig.fileNames, parsedTsConfig.options);<EOL>    const result = program.emit();<EOL>    if (result.emitSkipped) {<EOL>        logger.error(`<STR_LIT>`);<EOL>        const diagLogger = logger.createChild('<STR_LIT>');<EOL>        result.diagnostics.forEach(diagnostic => {<EOL>            const messageText = ts.flattenDiagnosticMessageText(diagnostic.messageText, '<STR_LIT>');<EOL>            if (diagnostic.","gt":"file) {"}
{"input":"<s> /**<EOL> *<EOL> * @param state<EOL> * @param action contains a payload that could be a primitive value, an object or a function with argument state<EOL> * that could return a primitive value or an object<EOL> * @param update boolean true if updating, false if patching<EOL> */<EOL>function patchOrUpdate(state: any, action: SliceAction, update: boolean): any {<EOL>    let obj = [state];<EOL>    let patch = !update;<EOL>    const path = action.payload.path;<EOL>    const hasPath = path &&","gt":"path.length;"}
{"input":"<s> /**<EOL> *<EOL> * @param state<EOL> * @param action contains a payload that could be a primitive value, an object or a function with argument state<EOL> * that could return a primitive value or an object<EOL> * @param update boolean true if updating, false if patching<EOL> */<EOL>function patchOrUpdate(state: any, action: SliceAction, update: boolean): any {<EOL>    let obj = [state];<EOL>    let patch = !update;<EOL>    const path = action.payload.path;<EOL>    const hasPath = path && path.length;<EOL>    const pathLength =","gt":"hasPath ? path.length : <NUM_LIT>;"}
{"input":"<s> /**<EOL> *<EOL> * @param state<EOL> * @param action contains a payload that could be a primitive value, an object or a function with argument state<EOL> * that could return a primitive value or an object<EOL> * @param update boolean true if updating, false if patching<EOL> */<EOL>function patchOrUpdate(state: any, action: SliceAction, update: boolean): any {<EOL>    let obj = [state];<EOL>    let patch = !update;<EOL>    const path = action.payload.path;<EOL>    const hasPath = path && path.length;<EOL>    const pathLength = hasPath ? path.length : <NUM_LIT>;<EOL>    const key = path[path.length - <NUM_LIT>];<EOL>    let val = {};<EOL>    let","gt":"pos = pathLength;"}
{"input":"<s> /**<EOL> *<EOL> * @param state<EOL> * @param action contains a payload that could be a primitive value, an object or a function with argument state<EOL> * that could return a primitive value or an object<EOL> * @param update boolean true if updating, false if patching<EOL> */<EOL>function patchOrUpdate(state: any, action: SliceAction, update: boolean): any {<EOL>    let obj = [state];<EOL>    let patch = !update;<EOL>    const path = action.payload.path;<EOL>    const hasPath = path && path.length;<EOL>    const pathLength = hasPath ? path.length : <NUM_LIT>;<EOL>    const key = path[path.length - <NUM_LIT>];<EOL>    let val = {};<EOL>    let pos = pathLength;<EOL>    <EOL>    if (typeof action.payload.val === '<STR_LIT>') {<EOL>        <EOL>        val =","gt":"action.payload.val;"}
{"input":"<s> /**<EOL> *<EOL> * @param state<EOL> * @param action contains a payload that could be a primitive value, an object or a function with argument state<EOL> * that could return a primitive value or an object<EOL> * @param update boolean true if updating, false if patching<EOL> */<EOL>function patchOrUpdate(state: any, action: SliceAction, update: boolean): any {<EOL>    let obj = [state];<EOL>    let patch = !update;<EOL>    const path = action.payload.path;<EOL>    const hasPath = path && path.length;<EOL>    const pathLength = hasPath ? path.length : <NUM_LIT>;<EOL>    const key = path[path.length - <NUM_LIT>];<EOL>    let val = {};<EOL>    let pos = pathLength;<EOL>    <EOL>    if (typeof action.payload.val === '<STR_LIT>') {<EOL>        <EOL>        val = action.payload.val;<EOL>    }<EOL>    else if (typeof action.payload.val === '<STR_LIT>') {<EOL>        <EOL>        val[key] = action.payload.val(state);<EOL>","gt":"pos--;"}
{"input":"<s> /**<EOL> *<EOL> * @param state<EOL> * @param action contains a payload that could be a primitive value, an object or a function with argument state<EOL> * that could return a primitive value or an object<EOL> * @param update boolean true if updating, false if patching<EOL> */<EOL>function patchOrUpdate(state: any, action: SliceAction, update: boolean): any {<EOL>    let obj = [state];<EOL>    let patch = !update;<EOL>    const path = action.payload.path;<EOL>    const hasPath = path && path.length;<EOL>    const pathLength = hasPath ? path.length : <NUM_LIT>;<EOL>    const key = path[path.length - <NUM_LIT>];<EOL>    let val = {};<EOL>    let pos = pathLength;<EOL>    <EOL>    if (typeof action.payload.val === '<STR_LIT>') {<EOL>        <EOL>        val = action.payload.val;<EOL>    }<EOL>    else if (typeof action.payload.val === '<STR_LIT>') {<EOL>        <EOL>        val[key] = action.payload.val(state);<EOL>        pos--;<EOL>        patch = true;<EOL>    }<EOL>","gt":"else {"}
{"input":"<s> /**<EOL> *<EOL> * @param state<EOL> * @param action contains a payload that could be a primitive value, an object or a function with argument state<EOL> * that could return a primitive value or an object<EOL> * @param update boolean true if updating, false if patching<EOL> */<EOL>function patchOrUpdate(state: any, action: SliceAction, update: boolean): any {<EOL>    let obj = [state];<EOL>    let patch = !update;<EOL>    const path = action.payload.path;<EOL>    const hasPath = path && path.length;<EOL>    const pathLength = hasPath ? path.length : <NUM_LIT>;<EOL>    const key = path[path.length - <NUM_LIT>];<EOL>    let val = {};<EOL>    let pos = pathLength;<EOL>    <EOL>    if (typeof action.payload.val === '<STR_LIT>') {<EOL>        <EOL>        val = action.payload.val;<EOL>    }<EOL>    else if (typeof action.payload.val === '<STR_LIT>') {<EOL>        <EOL>        val[key] = action.payload.val(state);<EOL>        pos--;<EOL>        patch = true;<EOL>    }<EOL>    else {<EOL>        <EOL>        val[key] = action.payload.val;<EOL>        pos--;<EOL>        patch = true;<EOL>    }<EOL>    let i = <NUM_LIT>;<EOL>    for (i = <NUM_LIT>; i < pos; i++) {<EOL>        obj[i + <NUM_LIT>] = obj[i][path[i]];<EOL>    }<EOL>","gt":"if (patch) {"}
{"input":"<s> function httpToRemote$(method: string, actions$: Actions, slice: keyof RootState, dataService, triggerAction: string, successAction: SliceAction, errorAction: SliceAction, responseTransform: Function = ((resp) => resp)): Observable<Action> {<EOL>    return actions$<EOL>        .ofType(typeFor(slice, triggerAction))<EOL>        .switchMap((action: PayloadAction) => dataService[method](action.payload.route, action.payload.requestObject || {})<EOL>        .","gt":"map(responseTransform)"}
{"input":"<s> function httpToRemote$(method: string, actions$: Actions, slice: keyof RootState, dataService, triggerAction: string, successAction: SliceAction, errorAction: SliceAction, responseTransform: Function = ((resp) => resp)): Observable<Action> {<EOL>    return actions$<EOL>        .ofType(typeFor(slice, triggerAction))<EOL>        .switchMap((action: PayloadAction) => dataService[method](action.payload.route, action.payload.requestObject || {})<EOL>        .map(responseTransform)<EOL>        .map((responseSlice: any) => {<EOL>        successAction.payload = responseSlice;<EOL>        return successAction;<EOL>    })<EOL>        .catch((error) => {<EOL>        errorAction.","gt":"payload = error;"}
{"input":"<s> /**<EOL> * Note: Only the source of<EOL> * https://github.com/Modernizr/Modernizr/blob/master/feature-detects/css/transformstylepreserve3d.js<EOL> *<EOL> * The MIT License<EOL> *<EOL> * Copyright (c) 2016 Modernizr<EOL> *<EOL> * Permission is hereby granted, free of charge, to any person obtaining a copy of this<EOL> * software and associated documentation files (the \"Software\"), to deal in the Software<EOL> * without restriction, including without limitation the rights to use, copy, modify, merge,<EOL> * publish, distribute, sublicense, and/or sell copies of the Software, and to permit<EOL> * persons to whom the Software is furnished to do so, subject to the following conditions:<EOL> *<EOL> * The above copyright notice and this permission notice shall be included in all copies<EOL> * or substantial portions of the Software.<EOL> *<EOL> * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,<EOL> * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR<EOL> * PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE<EOL> * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,<EOL> * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE<EOL> * OR OTHER DEALINGS IN THE SOFTWARE.<EOL> */<EOL>function hasPreserve3d(window) {<EOL>    if (!window) {<EOL>        return false;<EOL>    }<EOL>    if (!window.document) {<EOL>","gt":"return false;"}
{"input":"<s> /**<EOL> * Note: Only the source of<EOL> * https://github.com/Modernizr/Modernizr/blob/master/feature-detects/css/transformstylepreserve3d.js<EOL> *<EOL> * The MIT License<EOL> *<EOL> * Copyright (c) 2016 Modernizr<EOL> *<EOL> * Permission is hereby granted, free of charge, to any person obtaining a copy of this<EOL> * software and associated documentation files (the \"Software\"), to deal in the Software<EOL> * without restriction, including without limitation the rights to use, copy, modify, merge,<EOL> * publish, distribute, sublicense, and/or sell copies of the Software, and to permit<EOL> * persons to whom the Software is furnished to do so, subject to the following conditions:<EOL> *<EOL> * The above copyright notice and this permission notice shall be included in all copies<EOL> * or substantial portions of the Software.<EOL> *<EOL> * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,<EOL> * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR<EOL> * PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE<EOL> * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,<EOL> * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE<EOL> * OR OTHER DEALINGS IN THE SOFTWARE.<EOL> */<EOL>function hasPreserve3d(window) {<EOL>    if (!window) {<EOL>        return false;<EOL>    }<EOL>    if (!window.document) {<EOL>        return false;<EOL>    }<EOL>    let outerAnchor;<EOL>","gt":"let innerAnchor;"}
{"input":"<s> /**<EOL> * Note: Only the source of<EOL> * https://github.com/Modernizr/Modernizr/blob/master/feature-detects/css/transformstylepreserve3d.js<EOL> *<EOL> * The MIT License<EOL> *<EOL> * Copyright (c) 2016 Modernizr<EOL> *<EOL> * Permission is hereby granted, free of charge, to any person obtaining a copy of this<EOL> * software and associated documentation files (the \"Software\"), to deal in the Software<EOL> * without restriction, including without limitation the rights to use, copy, modify, merge,<EOL> * publish, distribute, sublicense, and/or sell copies of the Software, and to permit<EOL> * persons to whom the Software is furnished to do so, subject to the following conditions:<EOL> *<EOL> * The above copyright notice and this permission notice shall be included in all copies<EOL> * or substantial portions of the Software.<EOL> *<EOL> * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,<EOL> * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR<EOL> * PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE<EOL> * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,<EOL> * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE<EOL> * OR OTHER DEALINGS IN THE SOFTWARE.<EOL> */<EOL>function hasPreserve3d(window) {<EOL>    if (!window) {<EOL>        return false;<EOL>    }<EOL>    if (!window.document) {<EOL>        return false;<EOL>    }<EOL>    let outerAnchor;<EOL>    let innerAnchor;<EOL>    const CSS = window.CSS;<EOL>    let result = false;<EOL>","gt":"let tmp;"}
{"input":"<s> <EOL>function copyVec3(out, a) {<EOL>    out[<NUM_LIT>] = a[<NUM_LIT>] || <NUM_LIT>;<EOL>    out[<NUM_LIT>] = a[<NUM_LIT>] ||","gt":"<NUM_LIT>;"}
{"input":"<s> export function replacePrefixWithCompletion(bufferLine: string, basePosition: number, cursorColumn: number, completion: string): string {<EOL>    const startPosition = basePosition;<EOL>    const before =","gt":"bufferLine.substring(<NUM_LIT>, startPosition);"}
{"input":"<s> export function createFakeScopedLineTokens(rawTokens: TokenText[]): ScopedLineTokens {<EOL>    let tokens = new Uint32Array(rawTokens.length << <NUM_LIT>);<EOL>    let line = '<STR_LIT>';<EOL>    for (let i = <NUM_LIT>, len = rawTokens.length; i < len; i++) {<EOL>","gt":"let rawToken = rawTokens[i];"}
{"input":"<s> export function createFakeScopedLineTokens(rawTokens: TokenText[]): ScopedLineTokens {<EOL>    let tokens = new Uint32Array(rawTokens.length << <NUM_LIT>);<EOL>    let line = '<STR_LIT>';<EOL>    for (let i = <NUM_LIT>, len = rawTokens.length; i < len; i++) {<EOL>        let rawToken = rawTokens[i];<EOL>        let startOffset = line.length;<EOL>        let metadata = ((rawToken.type << MetadataConsts.TOKEN_TYPE_OFFSET)) >>> <NUM_LIT>;<EOL>        tokens[(i << <NUM_LIT>)] = startOffset;<EOL>        tokens[(i << <NUM_LIT>) + <NUM_LIT>] = metadata;<EOL>        line += rawToken.","gt":"text;"}
{"input":"<s> function constructTimingAst(value: string | number | AnimateTimings, errors: any[]) {<EOL>    let timings: AnimateTimings | null = null;<EOL>    if (value.hasOwnProperty('<STR_LIT>')) {<EOL>        timings = value as AnimateTimings;<EOL>    }<EOL>    else if (typeof value == '<STR_LIT>') {<EOL>        const duration = resolveTiming(","gt":"value as number, errors).duration;"}
{"input":"<s> function constructTimingAst(value: string | number | AnimateTimings, errors: any[]) {<EOL>    let timings: AnimateTimings | null = null;<EOL>    if (value.hasOwnProperty('<STR_LIT>')) {<EOL>        timings = value as AnimateTimings;<EOL>    }<EOL>    else if (typeof value == '<STR_LIT>') {<EOL>        const duration = resolveTiming(value as number, errors).duration;<EOL>        return makeTimingAst(duration as number, <NUM_LIT>, '<STR_LIT>');<EOL>    }<EOL>    const strValue = value as string;<EOL>    const isDynamic = strValue.","gt":"split(/\\s+/).some(v => v.charAt(<NUM_LIT>) == '<STR_LIT>' && v.charAt(<NUM_LIT>) == '<STR_LIT>');"}
{"input":"<s> function constructTimingAst(value: string | number | AnimateTimings, errors: any[]) {<EOL>    let timings: AnimateTimings | null = null;<EOL>    if (value.hasOwnProperty('<STR_LIT>')) {<EOL>        timings = value as AnimateTimings;<EOL>    }<EOL>    else if (typeof value == '<STR_LIT>') {<EOL>        const duration = resolveTiming(value as number, errors).duration;<EOL>        return makeTimingAst(duration as number, <NUM_LIT>, '<STR_LIT>');<EOL>    }<EOL>    const strValue = value as string;<EOL>    const isDynamic = strValue.split(/\\s+/).some(v => v.charAt(<NUM_LIT>) == '<STR_LIT>' && v.charAt(<NUM_LIT>) == '<STR_LIT>');<EOL>    if (isDynamic) {<EOL>        const ast = makeTimingAst(<NUM_LIT>, <NUM_LIT>, '<STR_LIT>') as any;<EOL>        ast.dynamic = true;<EOL>        ast.","gt":"strValue = strValue;"}
{"input":"<s> /**<EOL> * Scales the mat4 by the dimensions in the given vec3<EOL> *<EOL> * @param {mat4} out the receiving matrix<EOL> * @param {mat4} a the matrix to scale<EOL> * @param {vec3} v the vec3 to scale the matrix by<EOL> * @returns {mat4} out<EOL> **/<EOL>export default function scale(out, a, v) {<EOL>    const x = v[<NUM_LIT>];<EOL>    const y = v[<NUM_LIT>];<EOL>    const z = v[<NUM_LIT>];<EOL>    out[<NUM_LIT>] = a[<NUM_LIT>] *","gt":"x;"}
{"input":"<s> /**<EOL> * Scales the mat4 by the dimensions in the given vec3<EOL> *<EOL> * @param {mat4} out the receiving matrix<EOL> * @param {mat4} a the matrix to scale<EOL> * @param {vec3} v the vec3 to scale the matrix by<EOL> * @returns {mat4} out<EOL> **/<EOL>export default function scale(out, a, v) {<EOL>    const x = v[<NUM_LIT>];<EOL>    const y = v[<NUM_LIT>];<EOL>    const z = v[<NUM_LIT>];<EOL>    out[<NUM_LIT>] = a[<NUM_LIT>] * x;<EOL>    out[<NUM_LIT>] = a[<NUM_LIT>] * x;<EOL>    out[<NUM_LIT>] = a[<NUM_LIT>] * x;<EOL>    out[<NUM_LIT>] =","gt":"a[<NUM_LIT>] * x;"}
{"input":"<s> /**<EOL> * Scales the mat4 by the dimensions in the given vec3<EOL> *<EOL> * @param {mat4} out the receiving matrix<EOL> * @param {mat4} a the matrix to scale<EOL> * @param {vec3} v the vec3 to scale the matrix by<EOL> * @returns {mat4} out<EOL> **/<EOL>export default function scale(out, a, v) {<EOL>    const x = v[<NUM_LIT>];<EOL>    const y = v[<NUM_LIT>];<EOL>    const z = v[<NUM_LIT>];<EOL>    out[<NUM_LIT>] = a[<NUM_LIT>] * x;<EOL>    out[<NUM_LIT>] = a[<NUM_LIT>] * x;<EOL>    out[<NUM_LIT>] = a[<NUM_LIT>] * x;<EOL>    out[<NUM_LIT>] = a[<NUM_LIT>] * x;<EOL>    out[<NUM_LIT>] = a[<NUM_LIT>] * y;<EOL>    out[<NUM_LIT>] = a[<NUM_LIT>] * y;<EOL>    out[<NUM_LIT>] = a[<NUM_LIT>] * y;<EOL>    out[<NUM_LIT>] =","gt":"a[<NUM_LIT>] * y;"}
{"input":"<s> /**<EOL> * Scales the mat4 by the dimensions in the given vec3<EOL> *<EOL> * @param {mat4} out the receiving matrix<EOL> * @param {mat4} a the matrix to scale<EOL> * @param {vec3} v the vec3 to scale the matrix by<EOL> * @returns {mat4} out<EOL> **/<EOL>export default function scale(out, a, v) {<EOL>    const x = v[<NUM_LIT>];<EOL>    const y = v[<NUM_LIT>];<EOL>    const z = v[<NUM_LIT>];<EOL>    out[<NUM_LIT>] = a[<NUM_LIT>] * x;<EOL>    out[<NUM_LIT>] = a[<NUM_LIT>] * x;<EOL>    out[<NUM_LIT>] = a[<NUM_LIT>] * x;<EOL>    out[<NUM_LIT>] = a[<NUM_LIT>] * x;<EOL>    out[<NUM_LIT>] = a[<NUM_LIT>] * y;<EOL>    out[<NUM_LIT>] = a[<NUM_LIT>] * y;<EOL>    out[<NUM_LIT>] = a[<NUM_LIT>] * y;<EOL>    out[<NUM_LIT>] = a[<NUM_LIT>] * y;<EOL>    out[<NUM_LIT>] = a[<NUM_LIT>] * z;<EOL>    out[<NUM_LIT>] = a[<NUM_LIT>] * z;<EOL>    out[<NUM_LIT>] = a[<NUM_LIT>] * z;<EOL>    out[<NUM_LIT>] = a[<NUM_LIT>] * z;<EOL>    out[","gt":"<NUM_LIT>] = a[<NUM_LIT>];"}
{"input":"<s> <EOL><EOL>function doSequence(observer, arr, idx) {<EOL>    return setTimeout(() => {<EOL>        observer.next(arr[idx]);<EOL>        if (idx === arr.","gt":"length - <NUM_LIT>) {"}
{"input":"<s> <EOL>export default function configureStore() {<EOL>    let userService = new UserService();<EOL>    let questionService =","gt":"new QuestionService();"}
{"input":"<s> <EOL>export function createArchive(sourceFolder: string, archiveType: string, archiveFile: string) {<EOL>    rootFolder = sourceFolder;<EOL>    if (tl.osType().match(/^Win/)) { <EOL>        var sourcePath = sourceFolder + \"<STR_LIT>\";<EOL>        if (archiveType == \"<STR_LIT>\") {<EOL>","gt":"sevenZipArchive(archiveFile, \"<STR_LIT>\", [sourcePath]);"}
{"input":"<s> <EOL>export function createArchive(sourceFolder: string, archiveType: string, archiveFile: string) {<EOL>    rootFolder = sourceFolder;<EOL>    if (tl.osType().match(/^Win/)) { <EOL>        var sourcePath = sourceFolder + \"<STR_LIT>\";<EOL>        if (archiveType == \"<STR_LIT>\") {<EOL>            sevenZipArchive(archiveFile, \"<STR_LIT>\", [sourcePath]);<EOL>        }<EOL>        else if (archiveType == \"<STR_LIT>\") {<EOL>            var tarFile = archiveFile.substring(<NUM_LIT>, archiveFile.lastIndexOf('<STR_LIT>'));<EOL>","gt":"try {"}
{"input":"<s> <EOL>export function createArchive(sourceFolder: string, archiveType: string, archiveFile: string) {<EOL>    rootFolder = sourceFolder;<EOL>    if (tl.osType().match(/^Win/)) { <EOL>        var sourcePath = sourceFolder + \"<STR_LIT>\";<EOL>        if (archiveType == \"<STR_LIT>\") {<EOL>            sevenZipArchive(archiveFile, \"<STR_LIT>\", [sourcePath]);<EOL>        }<EOL>        else if (archiveType == \"<STR_LIT>\") {<EOL>            var tarFile = archiveFile.substring(<NUM_LIT>, archiveFile.lastIndexOf('<STR_LIT>'));<EOL>            try {<EOL>                <EOL>                sevenZipArchive(tarFile, \"<STR_LIT>\", [sourcePath]);<EOL>                <EOL>                sevenZipArchive(archiveFile, \"<STR_LIT>\", [tarFile]);<EOL>            }<EOL>","gt":"finally {"}
{"input":"<s> <EOL>export function createArchive(sourceFolder: string, archiveType: string, archiveFile: string) {<EOL>    rootFolder = sourceFolder;<EOL>    if (tl.osType().match(/^Win/)) { <EOL>        var sourcePath = sourceFolder + \"<STR_LIT>\";<EOL>        if (archiveType == \"<STR_LIT>\") {<EOL>            sevenZipArchive(archiveFile, \"<STR_LIT>\", [sourcePath]);<EOL>        }<EOL>        else if (archiveType == \"<STR_LIT>\") {<EOL>            var tarFile = archiveFile.substring(<NUM_LIT>, archiveFile.lastIndexOf('<STR_LIT>'));<EOL>            try {<EOL>                <EOL>                sevenZipArchive(tarFile, \"<STR_LIT>\", [sourcePath]);<EOL>                <EOL>                sevenZipArchive(archiveFile, \"<STR_LIT>\", [tarFile]);<EOL>            }<EOL>            finally {<EOL>                tl.rmRF(tarFile);<EOL>            }<EOL>        }<EOL>    }<EOL>    else { <EOL>","gt":"if (archiveType == \"<STR_LIT>\") {"}
{"input":"<s> function getPm2File() {<EOL>","gt":"return path.join(__dirname, '<STR_LIT>');"}
{"input":"<s> function resolveElementFromTarget(target: '<STR_LIT>' | '<STR_LIT>' | '<STR_LIT>' | any): any {<EOL>    switch (target) {<EOL>        case '<STR_LIT>':<EOL>            return document.body;<EOL>","gt":"case '<STR_LIT>':"}
{"input":"<s> function resolveElementFromTarget(target: '<STR_LIT>' | '<STR_LIT>' | '<STR_LIT>' | any): any {<EOL>    switch (target) {<EOL>        case '<STR_LIT>':<EOL>            return document.body;<EOL>        case '<STR_LIT>':<EOL>            return document;<EOL>        case '<STR_LIT>':<EOL>            return window;<EOL>","gt":"default:"}
{"input":"<s> /**<EOL> * Escapes all potentially dangerous characters, so that the<EOL> * resulting string can be safely inserted into attribute or<EOL> * element text.<EOL> * @param value<EOL> */<EOL>function encodeEntities(value: string) {<EOL>    return value.replace(/&/g, '<STR_LIT>')<EOL>        .replace(SURROGATE_PAIR_REGEXP, function (match: string) {<EOL>        const hi = match.","gt":"charCodeAt(<NUM_LIT>);"}
{"input":"<s> export function stressTestState(state: StressTestState = stressDefaultValue, action: any): StressTestState {<EOL>    switch (action.type) {<EOL>        case LoginSuccessType:<EOL>        case","gt":"SyncUserDataSuccessType: {"}
{"input":"<s> export function stressTestState(state: StressTestState = stressDefaultValue, action: any): StressTestState {<EOL>    switch (action.type) {<EOL>        case LoginSuccessType:<EOL>        case SyncUserDataSuccessType: {<EOL>            const stresses = action.value.result.stresses as _.Dictionary<DtoStress>;<EOL>            const stressIds = _.keys(stresses);<EOL>            const activeStress = state.activeStress || (stressIds.","gt":"length > <NUM_LIT> ? (stressIds[<NUM_LIT>] || '<STR_LIT>') : '<STR_LIT>');"}
{"input":"<s> export function stressTestState(state: StressTestState = stressDefaultValue, action: any): StressTestState {<EOL>    switch (action.type) {<EOL>        case LoginSuccessType:<EOL>        case SyncUserDataSuccessType: {<EOL>            const stresses = action.value.result.stresses as _.Dictionary<DtoStress>;<EOL>            const stressIds = _.keys(stresses);<EOL>            const activeStress = state.activeStress || (stressIds.length > <NUM_LIT> ? (stressIds[<NUM_LIT>] || '<STR_LIT>') : '<STR_LIT>');<EOL>            return { ...state, stresses, activeStress };<EOL>        }<EOL>","gt":"case SaveStressType: {"}
{"input":"<s> export function stressTestState(state: StressTestState = stressDefaultValue, action: any): StressTestState {<EOL>    switch (action.type) {<EOL>        case LoginSuccessType:<EOL>        case SyncUserDataSuccessType: {<EOL>            const stresses = action.value.result.stresses as _.Dictionary<DtoStress>;<EOL>            const stressIds = _.keys(stresses);<EOL>            const activeStress = state.activeStress || (stressIds.length > <NUM_LIT> ? (stressIds[<NUM_LIT>] || '<STR_LIT>') : '<STR_LIT>');<EOL>            return { ...state, stresses, activeStress };<EOL>        }<EOL>        case SaveStressType: {<EOL>            const stress = action.value.stress as DtoStress;<EOL>            return { ...state, stresses: { ...state.stresses, [stress.id]: stress }, activeStress: stress.id };<EOL>        }<EOL>        case ActiveStressType: {<EOL>            return { ...state, activeStress: action.","gt":"value };"}
{"input":"<s> export function stressTestState(state: StressTestState = stressDefaultValue, action: any): StressTestState {<EOL>    switch (action.type) {<EOL>        case LoginSuccessType:<EOL>        case SyncUserDataSuccessType: {<EOL>            const stresses = action.value.result.stresses as _.Dictionary<DtoStress>;<EOL>            const stressIds = _.keys(stresses);<EOL>            const activeStress = state.activeStress || (stressIds.length > <NUM_LIT> ? (stressIds[<NUM_LIT>] || '<STR_LIT>') : '<STR_LIT>');<EOL>            return { ...state, stresses, activeStress };<EOL>        }<EOL>        case SaveStressType: {<EOL>            const stress = action.value.stress as DtoStress;<EOL>            return { ...state, stresses: { ...state.stresses, [stress.id]: stress }, activeStress: stress.id };<EOL>        }<EOL>        case ActiveStressType: {<EOL>            return { ...state, activeStress: action.value };<EOL>        }<EOL>        case DeleteStressType: {<EOL>            const stresses = { ...state.stresses };<EOL>            Reflect.deleteProperty(stresses, action.value);<EOL>            const activeStress = state.activeStress === action.value ? (_.keys(stresses).length > <NUM_LIT> ? (_.keys(stresses)[<NUM_LIT>] || '<STR_LIT>') : '<STR_LIT>') : state.activeStress;<EOL>            return { ...state, stresses, activeStress };<EOL>        }<EOL>","gt":"case StressStatusType: {"}
{"input":"<s> export function stressTestState(state: StressTestState = stressDefaultValue, action: any): StressTestState {<EOL>    switch (action.type) {<EOL>        case LoginSuccessType:<EOL>        case SyncUserDataSuccessType: {<EOL>            const stresses = action.value.result.stresses as _.Dictionary<DtoStress>;<EOL>            const stressIds = _.keys(stresses);<EOL>            const activeStress = state.activeStress || (stressIds.length > <NUM_LIT> ? (stressIds[<NUM_LIT>] || '<STR_LIT>') : '<STR_LIT>');<EOL>            return { ...state, stresses, activeStress };<EOL>        }<EOL>        case SaveStressType: {<EOL>            const stress = action.value.stress as DtoStress;<EOL>            return { ...state, stresses: { ...state.stresses, [stress.id]: stress }, activeStress: stress.id };<EOL>        }<EOL>        case ActiveStressType: {<EOL>            return { ...state, activeStress: action.value };<EOL>        }<EOL>        case DeleteStressType: {<EOL>            const stresses = { ...state.stresses };<EOL>            Reflect.deleteProperty(stresses, action.value);<EOL>            const activeStress = state.activeStress === action.value ? (_.keys(stresses).length > <NUM_LIT> ? (_.keys(stresses)[<NUM_LIT>] || '<STR_LIT>') : '<STR_LIT>') : state.activeStress;<EOL>            return { ...state, stresses, activeStress };<EOL>        }<EOL>        case StressStatusType: {<EOL>            const { workerInfos,","gt":"tasks, currentTask, currentStressId } = action.value;"}
{"input":"<s> export function stressTestState(state: StressTestState = stressDefaultValue, action: any): StressTestState {<EOL>    switch (action.type) {<EOL>        case LoginSuccessType:<EOL>        case SyncUserDataSuccessType: {<EOL>            const stresses = action.value.result.stresses as _.Dictionary<DtoStress>;<EOL>            const stressIds = _.keys(stresses);<EOL>            const activeStress = state.activeStress || (stressIds.length > <NUM_LIT> ? (stressIds[<NUM_LIT>] || '<STR_LIT>') : '<STR_LIT>');<EOL>            return { ...state, stresses, activeStress };<EOL>        }<EOL>        case SaveStressType: {<EOL>            const stress = action.value.stress as DtoStress;<EOL>            return { ...state, stresses: { ...state.stresses, [stress.id]: stress }, activeStress: stress.id };<EOL>        }<EOL>        case ActiveStressType: {<EOL>            return { ...state, activeStress: action.value };<EOL>        }<EOL>        case DeleteStressType: {<EOL>            const stresses = { ...state.stresses };<EOL>            Reflect.deleteProperty(stresses, action.value);<EOL>            const activeStress = state.activeStress === action.value ? (_.keys(stresses).length > <NUM_LIT> ? (_.keys(stresses)[<NUM_LIT>] || '<STR_LIT>') : '<STR_LIT>') : state.activeStress;<EOL>            return { ...state, stresses, activeStress };<EOL>        }<EOL>        case StressStatusType: {<EOL>            const { workerInfos, tasks, currentTask, currentStressId } = action.value;<EOL>            if (currentTask) {<EOL>                tasks.unshift(currentStressId);<EOL>            }<EOL>            return {<EOL>                ...state,<EOL>                workerInfos: workerInfos,<EOL>","gt":"tasks: tasks,"}
{"input":"<s> export function stressTestState(state: StressTestState = stressDefaultValue, action: any): StressTestState {<EOL>    switch (action.type) {<EOL>        case LoginSuccessType:<EOL>        case SyncUserDataSuccessType: {<EOL>            const stresses = action.value.result.stresses as _.Dictionary<DtoStress>;<EOL>            const stressIds = _.keys(stresses);<EOL>            const activeStress = state.activeStress || (stressIds.length > <NUM_LIT> ? (stressIds[<NUM_LIT>] || '<STR_LIT>') : '<STR_LIT>');<EOL>            return { ...state, stresses, activeStress };<EOL>        }<EOL>        case SaveStressType: {<EOL>            const stress = action.value.stress as DtoStress;<EOL>            return { ...state, stresses: { ...state.stresses, [stress.id]: stress }, activeStress: stress.id };<EOL>        }<EOL>        case ActiveStressType: {<EOL>            return { ...state, activeStress: action.value };<EOL>        }<EOL>        case DeleteStressType: {<EOL>            const stresses = { ...state.stresses };<EOL>            Reflect.deleteProperty(stresses, action.value);<EOL>            const activeStress = state.activeStress === action.value ? (_.keys(stresses).length > <NUM_LIT> ? (_.keys(stresses)[<NUM_LIT>] || '<STR_LIT>') : '<STR_LIT>') : state.activeStress;<EOL>            return { ...state, stresses, activeStress };<EOL>        }<EOL>        case StressStatusType: {<EOL>            const { workerInfos, tasks, currentTask, currentStressId } = action.value;<EOL>            if (currentTask) {<EOL>                tasks.unshift(currentStressId);<EOL>            }<EOL>            return {<EOL>                ...state,<EOL>                workerInfos: workerInfos,<EOL>                tasks: tasks,<EOL>                currentRunStressName: currentTask,<EOL>                currentRunStressId: currentStressId<EOL>            };<EOL>        }<EOL>        case StressChunkDataType: {<EOL>            return {<EOL>                ...state,<EOL>                runState:","gt":"action.value.data"}
{"input":"<s> export function stressTestState(state: StressTestState = stressDefaultValue, action: any): StressTestState {<EOL>    switch (action.type) {<EOL>        case LoginSuccessType:<EOL>        case SyncUserDataSuccessType: {<EOL>            const stresses = action.value.result.stresses as _.Dictionary<DtoStress>;<EOL>            const stressIds = _.keys(stresses);<EOL>            const activeStress = state.activeStress || (stressIds.length > <NUM_LIT> ? (stressIds[<NUM_LIT>] || '<STR_LIT>') : '<STR_LIT>');<EOL>            return { ...state, stresses, activeStress };<EOL>        }<EOL>        case SaveStressType: {<EOL>            const stress = action.value.stress as DtoStress;<EOL>            return { ...state, stresses: { ...state.stresses, [stress.id]: stress }, activeStress: stress.id };<EOL>        }<EOL>        case ActiveStressType: {<EOL>            return { ...state, activeStress: action.value };<EOL>        }<EOL>        case DeleteStressType: {<EOL>            const stresses = { ...state.stresses };<EOL>            Reflect.deleteProperty(stresses, action.value);<EOL>            const activeStress = state.activeStress === action.value ? (_.keys(stresses).length > <NUM_LIT> ? (_.keys(stresses)[<NUM_LIT>] || '<STR_LIT>') : '<STR_LIT>') : state.activeStress;<EOL>            return { ...state, stresses, activeStress };<EOL>        }<EOL>        case StressStatusType: {<EOL>            const { workerInfos, tasks, currentTask, currentStressId } = action.value;<EOL>            if (currentTask) {<EOL>                tasks.unshift(currentStressId);<EOL>            }<EOL>            return {<EOL>                ...state,<EOL>                workerInfos: workerInfos,<EOL>                tasks: tasks,<EOL>                currentRunStressName: currentTask,<EOL>                currentRunStressId: currentStressId<EOL>            };<EOL>        }<EOL>        case StressChunkDataType: {<EOL>            return {<EOL>                ...state,<EOL>                runState: action.value.data<EOL>            };<EOL>        }<EOL>        case RunStressFulfillType: {<EOL>            const stressId = action.value.currentStressId;<EOL>            const stress = state.","gt":"stresses[stressId];"}
{"input":"<s> export function stressTestState(state: StressTestState = stressDefaultValue, action: any): StressTestState {<EOL>    switch (action.type) {<EOL>        case LoginSuccessType:<EOL>        case SyncUserDataSuccessType: {<EOL>            const stresses = action.value.result.stresses as _.Dictionary<DtoStress>;<EOL>            const stressIds = _.keys(stresses);<EOL>            const activeStress = state.activeStress || (stressIds.length > <NUM_LIT> ? (stressIds[<NUM_LIT>] || '<STR_LIT>') : '<STR_LIT>');<EOL>            return { ...state, stresses, activeStress };<EOL>        }<EOL>        case SaveStressType: {<EOL>            const stress = action.value.stress as DtoStress;<EOL>            return { ...state, stresses: { ...state.stresses, [stress.id]: stress }, activeStress: stress.id };<EOL>        }<EOL>        case ActiveStressType: {<EOL>            return { ...state, activeStress: action.value };<EOL>        }<EOL>        case DeleteStressType: {<EOL>            const stresses = { ...state.stresses };<EOL>            Reflect.deleteProperty(stresses, action.value);<EOL>            const activeStress = state.activeStress === action.value ? (_.keys(stresses).length > <NUM_LIT> ? (_.keys(stresses)[<NUM_LIT>] || '<STR_LIT>') : '<STR_LIT>') : state.activeStress;<EOL>            return { ...state, stresses, activeStress };<EOL>        }<EOL>        case StressStatusType: {<EOL>            const { workerInfos, tasks, currentTask, currentStressId } = action.value;<EOL>            if (currentTask) {<EOL>                tasks.unshift(currentStressId);<EOL>            }<EOL>            return {<EOL>                ...state,<EOL>                workerInfos: workerInfos,<EOL>                tasks: tasks,<EOL>                currentRunStressName: currentTask,<EOL>                currentRunStressId: currentStressId<EOL>            };<EOL>        }<EOL>        case StressChunkDataType: {<EOL>            return {<EOL>                ...state,<EOL>                runState: action.value.data<EOL>            };<EOL>        }<EOL>        case RunStressFulfillType: {<EOL>            const stressId = action.value.currentStressId;<EOL>            const stress = state.stresses[stressId];<EOL>            if (!stress) {<EOL>","gt":"return state;"}
{"input":"<s> export function stressTestState(state: StressTestState = stressDefaultValue, action: any): StressTestState {<EOL>    switch (action.type) {<EOL>        case LoginSuccessType:<EOL>        case SyncUserDataSuccessType: {<EOL>            const stresses = action.value.result.stresses as _.Dictionary<DtoStress>;<EOL>            const stressIds = _.keys(stresses);<EOL>            const activeStress = state.activeStress || (stressIds.length > <NUM_LIT> ? (stressIds[<NUM_LIT>] || '<STR_LIT>') : '<STR_LIT>');<EOL>            return { ...state, stresses, activeStress };<EOL>        }<EOL>        case SaveStressType: {<EOL>            const stress = action.value.stress as DtoStress;<EOL>            return { ...state, stresses: { ...state.stresses, [stress.id]: stress }, activeStress: stress.id };<EOL>        }<EOL>        case ActiveStressType: {<EOL>            return { ...state, activeStress: action.value };<EOL>        }<EOL>        case DeleteStressType: {<EOL>            const stresses = { ...state.stresses };<EOL>            Reflect.deleteProperty(stresses, action.value);<EOL>            const activeStress = state.activeStress === action.value ? (_.keys(stresses).length > <NUM_LIT> ? (_.keys(stresses)[<NUM_LIT>] || '<STR_LIT>') : '<STR_LIT>') : state.activeStress;<EOL>            return { ...state, stresses, activeStress };<EOL>        }<EOL>        case StressStatusType: {<EOL>            const { workerInfos, tasks, currentTask, currentStressId } = action.value;<EOL>            if (currentTask) {<EOL>                tasks.unshift(currentStressId);<EOL>            }<EOL>            return {<EOL>                ...state,<EOL>                workerInfos: workerInfos,<EOL>                tasks: tasks,<EOL>                currentRunStressName: currentTask,<EOL>                currentRunStressId: currentStressId<EOL>            };<EOL>        }<EOL>        case StressChunkDataType: {<EOL>            return {<EOL>                ...state,<EOL>                runState: action.value.data<EOL>            };<EOL>        }<EOL>        case RunStressFulfillType: {<EOL>            const stressId = action.value.currentStressId;<EOL>            const stress = state.stresses[stressId];<EOL>            if (!stress) {<EOL>                return state;<EOL>            }<EOL>            const stresses = {<EOL>                ...state.stresses, [stressId]: {<EOL>                    ...stress,<EOL>                    stressRecords: [<EOL>                        {<EOL>                            stressId,<EOL>                            result: action.value.data,<EOL>","gt":"createDate: new Date()"}
{"input":"<s> export function stressTestState(state: StressTestState = stressDefaultValue, action: any): StressTestState {<EOL>    switch (action.type) {<EOL>        case LoginSuccessType:<EOL>        case SyncUserDataSuccessType: {<EOL>            const stresses = action.value.result.stresses as _.Dictionary<DtoStress>;<EOL>            const stressIds = _.keys(stresses);<EOL>            const activeStress = state.activeStress || (stressIds.length > <NUM_LIT> ? (stressIds[<NUM_LIT>] || '<STR_LIT>') : '<STR_LIT>');<EOL>            return { ...state, stresses, activeStress };<EOL>        }<EOL>        case SaveStressType: {<EOL>            const stress = action.value.stress as DtoStress;<EOL>            return { ...state, stresses: { ...state.stresses, [stress.id]: stress }, activeStress: stress.id };<EOL>        }<EOL>        case ActiveStressType: {<EOL>            return { ...state, activeStress: action.value };<EOL>        }<EOL>        case DeleteStressType: {<EOL>            const stresses = { ...state.stresses };<EOL>            Reflect.deleteProperty(stresses, action.value);<EOL>            const activeStress = state.activeStress === action.value ? (_.keys(stresses).length > <NUM_LIT> ? (_.keys(stresses)[<NUM_LIT>] || '<STR_LIT>') : '<STR_LIT>') : state.activeStress;<EOL>            return { ...state, stresses, activeStress };<EOL>        }<EOL>        case StressStatusType: {<EOL>            const { workerInfos, tasks, currentTask, currentStressId } = action.value;<EOL>            if (currentTask) {<EOL>                tasks.unshift(currentStressId);<EOL>            }<EOL>            return {<EOL>                ...state,<EOL>                workerInfos: workerInfos,<EOL>                tasks: tasks,<EOL>                currentRunStressName: currentTask,<EOL>                currentRunStressId: currentStressId<EOL>            };<EOL>        }<EOL>        case StressChunkDataType: {<EOL>            return {<EOL>                ...state,<EOL>                runState: action.value.data<EOL>            };<EOL>        }<EOL>        case RunStressFulfillType: {<EOL>            const stressId = action.value.currentStressId;<EOL>            const stress = state.stresses[stressId];<EOL>            if (!stress) {<EOL>                return state;<EOL>            }<EOL>            const stresses = {<EOL>                ...state.stresses, [stressId]: {<EOL>                    ...stress,<EOL>                    stressRecords: [<EOL>                        {<EOL>                            stressId,<EOL>                            result: action.value.data,<EOL>                            createDate: new Date()<EOL>                        },<EOL>                        ...stress.stressRecords<EOL>                    ],<EOL>                    lastRunDate: new Date()<EOL>                }<EOL>            };<EOL>            return {<EOL>                ...","gt":"state,"}
{"input":"<s> export default function assignAttributes(domElement, virtualElement, component, isPatchOperation) {<EOL>    const flexId = getFlexId(virtualElement);<EOL>    const cache = component.cache[flexId];<EOL>    if (!isPatchOperation) {<EOL>        <EOL>        if (domElement.haiku &&","gt":"domElement.haiku.element) {"}
{"input":"<s> export default function assignAttributes(domElement, virtualElement, component, isPatchOperation) {<EOL>    const flexId = getFlexId(virtualElement);<EOL>    const cache = component.cache[flexId];<EOL>    if (!isPatchOperation) {<EOL>        <EOL>        if (domElement.haiku && domElement.haiku.element) {<EOL>            for (const oldKey in domElement.haiku.element.attributes) {<EOL>                const oldValue =","gt":"domElement.haiku.element.attributes[oldKey];"}
{"input":"<s> export default function assignAttributes(domElement, virtualElement, component, isPatchOperation) {<EOL>    const flexId = getFlexId(virtualElement);<EOL>    const cache = component.cache[flexId];<EOL>    if (!isPatchOperation) {<EOL>        <EOL>        if (domElement.haiku && domElement.haiku.element) {<EOL>            for (const oldKey in domElement.haiku.element.attributes) {<EOL>                const oldValue = domElement.haiku.element.attributes[oldKey];<EOL>                const newValue = virtualElement.attributes[oldKey];<EOL>                if (oldKey !== STYLE) {<EOL>                    <EOL>                    if (newValue ===","gt":"null || newValue === undefined || oldValue !== newValue) {"}
{"input":"<s> export default function assignAttributes(domElement, virtualElement, component, isPatchOperation) {<EOL>    const flexId = getFlexId(virtualElement);<EOL>    const cache = component.cache[flexId];<EOL>    if (!isPatchOperation) {<EOL>        <EOL>        if (domElement.haiku && domElement.haiku.element) {<EOL>            for (const oldKey in domElement.haiku.element.attributes) {<EOL>                const oldValue = domElement.haiku.element.attributes[oldKey];<EOL>                const newValue = virtualElement.attributes[oldKey];<EOL>                if (oldKey !== STYLE) {<EOL>                    <EOL>                    if (newValue === null || newValue === undefined || oldValue !== newValue) {<EOL>                        domElement.removeAttribute(oldKey);<EOL>                        if (cache[oldKey]) {<EOL>                            cache[oldKey] = null;<EOL>                        }<EOL>                    }<EOL>                }<EOL>            }<EOL>        }<EOL>    }<EOL>    for (const key in virtualElement.attributes) {<EOL>        const anotherNewValue = virtualElement.attributes[key];<EOL>","gt":"if (key === STYLE &&"}
{"input":"<s> export default function assignAttributes(domElement, virtualElement, component, isPatchOperation) {<EOL>    const flexId = getFlexId(virtualElement);<EOL>    const cache = component.cache[flexId];<EOL>    if (!isPatchOperation) {<EOL>        <EOL>        if (domElement.haiku && domElement.haiku.element) {<EOL>            for (const oldKey in domElement.haiku.element.attributes) {<EOL>                const oldValue = domElement.haiku.element.attributes[oldKey];<EOL>                const newValue = virtualElement.attributes[oldKey];<EOL>                if (oldKey !== STYLE) {<EOL>                    <EOL>                    if (newValue === null || newValue === undefined || oldValue !== newValue) {<EOL>                        domElement.removeAttribute(oldKey);<EOL>                        if (cache[oldKey]) {<EOL>                            cache[oldKey] = null;<EOL>                        }<EOL>                    }<EOL>                }<EOL>            }<EOL>        }<EOL>    }<EOL>    for (const key in virtualElement.attributes) {<EOL>        const anotherNewValue = virtualElement.attributes[key];<EOL>        if (key === STYLE &&<EOL>            anotherNewValue &&<EOL>            typeof anotherNewValue === OBJECT) {<EOL>            if (Object.keys(anotherNewValue).length > <NUM_LIT>) {<EOL>                assignStyle(domElement, anotherNewValue, component, isPatchOperation);<EOL>            }<EOL>            continue;<EOL>        }<EOL>        if ((key === CLASS || key === CLASS_NAME) && anotherNewValue) {<EOL>            assignClass(domElement, anotherNewValue);<EOL>            continue;<EOL>        }<EOL>        <EOL>        if (key[<NUM_LIT>] === '<STR_LIT>' && key[<NUM_LIT>] === '<STR_LIT>' && typeof anotherNewValue === FUNCTION) {<EOL>            attachEventListener(virtualElement, domElement, key.slice(<NUM_LIT>).toLowerCase(), anotherNewValue, component);<EOL>            continue;<EOL>        }<EOL>        setAttribute(domElement, key, anotherNewValue,","gt":"cache);"}
{"input":"<s> export default function assignAttributes(domElement, virtualElement, component, isPatchOperation) {<EOL>    const flexId = getFlexId(virtualElement);<EOL>    const cache = component.cache[flexId];<EOL>    if (!isPatchOperation) {<EOL>        <EOL>        if (domElement.haiku && domElement.haiku.element) {<EOL>            for (const oldKey in domElement.haiku.element.attributes) {<EOL>                const oldValue = domElement.haiku.element.attributes[oldKey];<EOL>                const newValue = virtualElement.attributes[oldKey];<EOL>                if (oldKey !== STYLE) {<EOL>                    <EOL>                    if (newValue === null || newValue === undefined || oldValue !== newValue) {<EOL>                        domElement.removeAttribute(oldKey);<EOL>                        if (cache[oldKey]) {<EOL>                            cache[oldKey] = null;<EOL>                        }<EOL>                    }<EOL>                }<EOL>            }<EOL>        }<EOL>    }<EOL>    for (const key in virtualElement.attributes) {<EOL>        const anotherNewValue = virtualElement.attributes[key];<EOL>        if (key === STYLE &&<EOL>            anotherNewValue &&<EOL>            typeof anotherNewValue === OBJECT) {<EOL>            if (Object.keys(anotherNewValue).length > <NUM_LIT>) {<EOL>                assignStyle(domElement, anotherNewValue, component, isPatchOperation);<EOL>            }<EOL>            continue;<EOL>        }<EOL>        if ((key === CLASS || key === CLASS_NAME) && anotherNewValue) {<EOL>            assignClass(domElement, anotherNewValue);<EOL>            continue;<EOL>        }<EOL>        <EOL>        if (key[<NUM_LIT>] === '<STR_LIT>' && key[<NUM_LIT>] === '<STR_LIT>' && typeof anotherNewValue === FUNCTION) {<EOL>            attachEventListener(virtualElement, domElement, key.slice(<NUM_LIT>).toLowerCase(), anotherNewValue, component);<EOL>            continue;<EOL>        }<EOL>        setAttribute(domElement, key, anotherNewValue, cache);<EOL>    }<EOL>    <EOL>    <EOL>    <EOL>    if (virtualElement.","gt":"__handlers) {"}
{"input":"<s> export default function assignAttributes(domElement, virtualElement, component, isPatchOperation) {<EOL>    const flexId = getFlexId(virtualElement);<EOL>    const cache = component.cache[flexId];<EOL>    if (!isPatchOperation) {<EOL>        <EOL>        if (domElement.haiku && domElement.haiku.element) {<EOL>            for (const oldKey in domElement.haiku.element.attributes) {<EOL>                const oldValue = domElement.haiku.element.attributes[oldKey];<EOL>                const newValue = virtualElement.attributes[oldKey];<EOL>                if (oldKey !== STYLE) {<EOL>                    <EOL>                    if (newValue === null || newValue === undefined || oldValue !== newValue) {<EOL>                        domElement.removeAttribute(oldKey);<EOL>                        if (cache[oldKey]) {<EOL>                            cache[oldKey] = null;<EOL>                        }<EOL>                    }<EOL>                }<EOL>            }<EOL>        }<EOL>    }<EOL>    for (const key in virtualElement.attributes) {<EOL>        const anotherNewValue = virtualElement.attributes[key];<EOL>        if (key === STYLE &&<EOL>            anotherNewValue &&<EOL>            typeof anotherNewValue === OBJECT) {<EOL>            if (Object.keys(anotherNewValue).length > <NUM_LIT>) {<EOL>                assignStyle(domElement, anotherNewValue, component, isPatchOperation);<EOL>            }<EOL>            continue;<EOL>        }<EOL>        if ((key === CLASS || key === CLASS_NAME) && anotherNewValue) {<EOL>            assignClass(domElement, anotherNewValue);<EOL>            continue;<EOL>        }<EOL>        <EOL>        if (key[<NUM_LIT>] === '<STR_LIT>' && key[<NUM_LIT>] === '<STR_LIT>' && typeof anotherNewValue === FUNCTION) {<EOL>            attachEventListener(virtualElement, domElement, key.slice(<NUM_LIT>).toLowerCase(), anotherNewValue, component);<EOL>            continue;<EOL>        }<EOL>        setAttribute(domElement, key, anotherNewValue, cache);<EOL>    }<EOL>    <EOL>    <EOL>    <EOL>    if (virtualElement.__handlers) {<EOL>        for (const eventName in virtualElement.__handlers) {<EOL>            const handler = virtualElement.__handlers[eventName];<EOL>            if (!handler.","gt":"__subscribed) {"}
{"input":"<s> <EOL>function someOtherFn() {<EOL>    var arr = (","gt":"n: number) => '<STR_LIT>' + n;"}
{"input":"<s> /**<EOL> * Compose with sourceMapCompiler options if you want to specify an outFile.<EOL> *<EOL> * Controls the name of the file produced by the compiler.  If there's more<EOL> * than one input file, they'll all be concatenated together in the outFile<EOL> */<EOL>export function generateOutfileCompilerOptions(outFile: string): ts.CompilerOptions {<EOL>    return {<EOL>","gt":"outFile,"}
{"input":"<s> <EOL>export function appendTextToFileSync(filePath: string, fileContent: string) {<EOL>    if (isFileExists(filePath)) {<EOL>        fs.appendFileSync(","gt":"filePath, fileContent);"}
{"input":"<s> export function* stopStress() {<EOL>","gt":"yield takeLatest(StopStressType, function* (action: any) {"}
{"input":"<s> <EOL>/**<EOL> * Is a string null, undefined, or empty?<EOL> */<EOL>export function empty(s: string): boolean {<EOL>    return (","gt":"s ? false : true);"}
{"input":"<s> export function SuccessResponse(name: string | number, description?: string): any {<EOL>","gt":"return () => { return; };"}
{"input":"<s> export function createDir(path: string) {<EOL>    return","gt":"_recursiveMkDir(path);"}
{"input":"<s> export function root(state: DisplayRecordsState = displayRecordsDefaultValue, action: any): DisplayRecordsState {<EOL>    const intermediateState = combineReducers<DisplayRecordsState>({<EOL>        activeKey,<EOL>","gt":"recordStates,"}
{"input":"<s> function parseTriggerCallbackName(triggerName: string) {<EOL>    const dotIndex = triggerName.indexOf('<STR_LIT>');<EOL>    const trigger = triggerName.substring(<NUM_LIT>,","gt":"dotIndex);"}
{"input":"<s> function broadcastMsgToUsers(type: StressMessageType, data?: any) {<EOL>    Log.","gt":"info(`<STR_LIT>`);"}
{"input":"<s> export function* changePassword() {<EOL>    yield takeLatest(ChangePasswordType, function* (action: any) {<EOL>        try {<EOL>            yield put(actionCreator(ChangePasswordPendingType));<EOL>            const res = yield call(RequestManager.put, Urls.getUrl(`<STR_LIT>`), action.value);<EOL>            const body = yield","gt":"res.json();"}
{"input":"<s> export function* changePassword() {<EOL>    yield takeLatest(ChangePasswordType, function* (action: any) {<EOL>        try {<EOL>            yield put(actionCreator(ChangePasswordPendingType));<EOL>            const res = yield call(RequestManager.put, Urls.getUrl(`<STR_LIT>`), action.value);<EOL>            const body = yield res.json();<EOL>            if (body.success) {<EOL>                yield put(actionCreator(ChangePasswordSuccessType, body.message));<EOL>            }<EOL>","gt":"else {"}
{"input":"<s> export function* changePassword() {<EOL>    yield takeLatest(ChangePasswordType, function* (action: any) {<EOL>        try {<EOL>            yield put(actionCreator(ChangePasswordPendingType));<EOL>            const res = yield call(RequestManager.put, Urls.getUrl(`<STR_LIT>`), action.value);<EOL>            const body = yield res.json();<EOL>            if (body.success) {<EOL>                yield put(actionCreator(ChangePasswordSuccessType, body.message));<EOL>            }<EOL>            else {<EOL>                yield put(actionCreator(ChangePasswordFailedType, body.message));<EOL>            }<EOL>        }<EOL>        catch (","gt":"err) {"}
{"input":"<s> function getReferenceType(type: ts.EntityName, extractEnum = true, genericTypes?: ts.NodeArray<ts.TypeNode>): Tsoa.ReferenceType {<EOL>    const typeName = resolveFqTypeName(type);<EOL>    const refNameWithGenerics = getTypeName(typeName, genericTypes);<EOL>","gt":"try {"}
{"input":"<s> function getReferenceType(type: ts.EntityName, extractEnum = true, genericTypes?: ts.NodeArray<ts.TypeNode>): Tsoa.ReferenceType {<EOL>    const typeName = resolveFqTypeName(type);<EOL>    const refNameWithGenerics = getTypeName(typeName, genericTypes);<EOL>    try {<EOL>        const existingType = localReferenceTypeCache[refNameWithGenerics];<EOL>        if (existingType) {<EOL>            return existingType;<EOL>        }<EOL>        const referenceEnumType = getEnumerateType(type, true) as Tsoa.ReferenceType;<EOL>        if (referenceEnumType) {<EOL>            localReferenceTypeCache[refNameWithGenerics] = referenceEnumType;<EOL>            return","gt":"referenceEnumType;"}
{"input":"<s> function getReferenceType(type: ts.EntityName, extractEnum = true, genericTypes?: ts.NodeArray<ts.TypeNode>): Tsoa.ReferenceType {<EOL>    const typeName = resolveFqTypeName(type);<EOL>    const refNameWithGenerics = getTypeName(typeName, genericTypes);<EOL>    try {<EOL>        const existingType = localReferenceTypeCache[refNameWithGenerics];<EOL>        if (existingType) {<EOL>            return existingType;<EOL>        }<EOL>        const referenceEnumType = getEnumerateType(type, true) as Tsoa.ReferenceType;<EOL>        if (referenceEnumType) {<EOL>            localReferenceTypeCache[refNameWithGenerics] = referenceEnumType;<EOL>            return referenceEnumType;<EOL>        }<EOL>        if (inProgressTypes[refNameWithGenerics]) {<EOL>            return createCircularDependencyResolver(refNameWithGenerics);<EOL>        }<EOL>        inProgressTypes[refNameWithGenerics] = true;<EOL>        const modelType = getModelTypeDeclaration(type);<EOL>        const properties = getModelProperties(modelType, genericTypes);<EOL>        const additionalProperties = getModelAdditionalProperties(modelType);<EOL>        const inheritedProperties =","gt":"getModelInheritedProperties(modelType) || [];"}
{"input":"<s> function getReferenceType(type: ts.EntityName, extractEnum = true, genericTypes?: ts.NodeArray<ts.TypeNode>): Tsoa.ReferenceType {<EOL>    const typeName = resolveFqTypeName(type);<EOL>    const refNameWithGenerics = getTypeName(typeName, genericTypes);<EOL>    try {<EOL>        const existingType = localReferenceTypeCache[refNameWithGenerics];<EOL>        if (existingType) {<EOL>            return existingType;<EOL>        }<EOL>        const referenceEnumType = getEnumerateType(type, true) as Tsoa.ReferenceType;<EOL>        if (referenceEnumType) {<EOL>            localReferenceTypeCache[refNameWithGenerics] = referenceEnumType;<EOL>            return referenceEnumType;<EOL>        }<EOL>        if (inProgressTypes[refNameWithGenerics]) {<EOL>            return createCircularDependencyResolver(refNameWithGenerics);<EOL>        }<EOL>        inProgressTypes[refNameWithGenerics] = true;<EOL>        const modelType = getModelTypeDeclaration(type);<EOL>        const properties = getModelProperties(modelType, genericTypes);<EOL>        const additionalProperties = getModelAdditionalProperties(modelType);<EOL>        const inheritedProperties = getModelInheritedProperties(modelType) || [];<EOL>        const referenceType = {<EOL>            additionalProperties,<EOL>            dataType: '<STR_LIT>',<EOL>            description: getNodeDescription(modelType),<EOL>            properties: inheritedProperties,<EOL>            refName: refNameWithGenerics,<EOL>        } as Tsoa.ReferenceType;<EOL>        referenceType.","gt":"properties = (referenceType.properties as Tsoa.Property[]).concat(properties);"}
{"input":"<s> function resolveFqTypeName(type: ts.EntityName): string {<EOL>    if (type.kind === ts.SyntaxKind.Identifier) {<EOL>        return (type as ts.Identifier).","gt":"text;"}
{"input":"<s> export function validateDateTime(name: string, value: any, fieldErrors: FieldErrors, validators?: DateTimeValidator, parent = '<STR_LIT>') {<EOL>    const momentDateTime = moment(String(value), moment.ISO_8601, true);<EOL>    if (!momentDateTime.isValid()) {<EOL>","gt":"const message = (validators && validators.isDateTime && validators.isDateTime.errorMsg) ? validators.isDateTime.errorMsg : `<STR_LIT>`;"}
{"input":"<s> export function validateDateTime(name: string, value: any, fieldErrors: FieldErrors, validators?: DateTimeValidator, parent = '<STR_LIT>') {<EOL>    const momentDateTime = moment(String(value), moment.ISO_8601, true);<EOL>    if (!momentDateTime.isValid()) {<EOL>        const message = (validators && validators.isDateTime && validators.isDateTime.errorMsg) ? validators.isDateTime.errorMsg : `<STR_LIT>`;<EOL>        fieldErrors[parent + name] = {<EOL>            message,<EOL>            value,<EOL>        };<EOL>        return;<EOL>    }<EOL>    const datetimeValue = new Date(String(value));<EOL>","gt":"if (!validators) {"}
{"input":"<s> export function validateDateTime(name: string, value: any, fieldErrors: FieldErrors, validators?: DateTimeValidator, parent = '<STR_LIT>') {<EOL>    const momentDateTime = moment(String(value), moment.ISO_8601, true);<EOL>    if (!momentDateTime.isValid()) {<EOL>        const message = (validators && validators.isDateTime && validators.isDateTime.errorMsg) ? validators.isDateTime.errorMsg : `<STR_LIT>`;<EOL>        fieldErrors[parent + name] = {<EOL>            message,<EOL>            value,<EOL>        };<EOL>        return;<EOL>    }<EOL>    const datetimeValue = new Date(String(value));<EOL>    if (!validators) {<EOL>        return datetimeValue;<EOL>    }<EOL>    if (validators.minDate && validators.minDate.","gt":"value) {"}
{"input":"<s> export function validateDateTime(name: string, value: any, fieldErrors: FieldErrors, validators?: DateTimeValidator, parent = '<STR_LIT>') {<EOL>    const momentDateTime = moment(String(value), moment.ISO_8601, true);<EOL>    if (!momentDateTime.isValid()) {<EOL>        const message = (validators && validators.isDateTime && validators.isDateTime.errorMsg) ? validators.isDateTime.errorMsg : `<STR_LIT>`;<EOL>        fieldErrors[parent + name] = {<EOL>            message,<EOL>            value,<EOL>        };<EOL>        return;<EOL>    }<EOL>    const datetimeValue = new Date(String(value));<EOL>    if (!validators) {<EOL>        return datetimeValue;<EOL>    }<EOL>    if (validators.minDate && validators.minDate.value) {<EOL>        const minDate = new Date(validators.minDate.value);<EOL>        if (minDate.getTime() > datetimeValue.getTime()) {<EOL>            fieldErrors[parent + name] = {<EOL>                message: validators.minDate.errorMsg || `<STR_LIT>`,<EOL>                value,<EOL>            };<EOL>            return;<EOL>        }<EOL>    }<EOL>    if (validators.maxDate && validators.maxDate.value) {<EOL>        const maxDate = new Date(validators.maxDate.value);<EOL>        if (maxDate.","gt":"getTime() < datetimeValue.getTime()) {"}
{"input":"<s> export function Post(value?: string): any {<EOL>","gt":"return () => { return; };"}
{"input":"<s> function handleMsg(msg: StressRequest) {<EOL>    switch (msg.type) {<EOL>        case StressMessageType.task:<EOL>            testCase = msg.testCase;<EOL>            send(createMsg(WorkerStatus.ready, StressMessageType.status));<EOL>            Log.","gt":"info('<STR_LIT>');"}
{"input":"<s> function handleMsg(msg: StressRequest) {<EOL>    switch (msg.type) {<EOL>        case StressMessageType.task:<EOL>            testCase = msg.testCase;<EOL>            send(createMsg(WorkerStatus.ready, StressMessageType.status));<EOL>            Log.info('<STR_LIT>');<EOL>            break;<EOL>        case StressMessageType.start:<EOL>            Log.","gt":"info('<STR_LIT>');"}
{"input":"<s> function handleMsg(msg: StressRequest) {<EOL>    switch (msg.type) {<EOL>        case StressMessageType.task:<EOL>            testCase = msg.testCase;<EOL>            send(createMsg(WorkerStatus.ready, StressMessageType.status));<EOL>            Log.info('<STR_LIT>');<EOL>            break;<EOL>        case StressMessageType.start:<EOL>            Log.info('<STR_LIT>');<EOL>            send(createMsg(WorkerStatus.working, StressMessageType.status));<EOL>            run();<EOL>","gt":"break;"}
{"input":"<s> function handleMsg(msg: StressRequest) {<EOL>    switch (msg.type) {<EOL>        case StressMessageType.task:<EOL>            testCase = msg.testCase;<EOL>            send(createMsg(WorkerStatus.ready, StressMessageType.status));<EOL>            Log.info('<STR_LIT>');<EOL>            break;<EOL>        case StressMessageType.start:<EOL>            Log.info('<STR_LIT>');<EOL>            send(createMsg(WorkerStatus.working, StressMessageType.status));<EOL>            run();<EOL>            break;<EOL>        case StressMessageType.fileStart:<EOL>            Log.info('<STR_LIT>');<EOL>","gt":"willReceiveFile = true;"}
{"input":"<s> function handleMsg(msg: StressRequest) {<EOL>    switch (msg.type) {<EOL>        case StressMessageType.task:<EOL>            testCase = msg.testCase;<EOL>            send(createMsg(WorkerStatus.ready, StressMessageType.status));<EOL>            Log.info('<STR_LIT>');<EOL>            break;<EOL>        case StressMessageType.start:<EOL>            Log.info('<STR_LIT>');<EOL>            send(createMsg(WorkerStatus.working, StressMessageType.status));<EOL>            run();<EOL>            break;<EOL>        case StressMessageType.fileStart:<EOL>            Log.info('<STR_LIT>');<EOL>            willReceiveFile = true;<EOL>            break;<EOL>        case StressMessageType.finish:<EOL>            Log.info('<STR_LIT>');<EOL>            finish();<EOL>            break;<EOL>        case","gt":"StressMessageType.stop:"}
{"input":"<s> export function throwDialogContentAlreadyAttachedError() {<EOL>","gt":"throw Error('<STR_LIT>');"}
{"input":"<s> function getNodeDescription(node: UsableDeclaration | ts.PropertyDeclaration | ts.ParameterDeclaration | ts.EnumDeclaration) {<EOL>    const symbol = MetadataGenerator.current.typeChecker.getSymbolAtLocation(node.name as ts.Node);<EOL>    if (!symbol) {<EOL>        return undefined;<EOL>    }<EOL>    /**<EOL>     * TODO: Workaround for what seems like a bug in the compiler<EOL>     * Warrants more investigation and possibly a PR against typescript<EOL>     */<EOL>    if (node.kind === ts.SyntaxKind.Parameter) {<EOL>        <EOL>        symbol.flags = <NUM_LIT>;<EOL>    }<EOL>    const comments = symbol.getDocumentationComment(undefined);<EOL>","gt":"if (comments.length) {"}
{"input":"<s> export function setupTestingRouter(urlSerializer: UrlSerializer, childrenOutletContexts: ChildrenOutletContexts, location: Location, loader: NgModuleFactoryLoader, compiler: Compiler, injector: Injector, routes: Route[][]) {<EOL>    return new Router(null, urlSerializer, childrenOutletContexts, location, injector, loader, compiler,","gt":"ɵflatten(routes));"}
{"input":"<s> export function createDom(component: LargeTableComponent) {<EOL>    component.data =","gt":"buildTable();"}
{"input":"<s> function createMessageBus(zone: NgZone): MessageBus {<EOL>    let sink = new ElectronMessageBusSink(electron['<STR_LIT>']);<EOL>","gt":"let source = new ElectronMessageBusSource(electron['<STR_LIT>']);"}
{"input":"<s> <EOL>async function f8() {<EOL>    let x: any,","gt":"y: any;"}
{"input":"<s> export function _getAngularFireAuth(app: FirebaseApp) {<EOL>    return new","gt":"AngularFireAuth(app);"}
{"input":"<s> function uploadSymbols(uploadUrl: string, file: string, userAgent: string): Q.Promise<void> {<EOL>    tl.debug(\"<STR_LIT>\");<EOL>    let defer = Q.defer<void>();<EOL>    tl.debug(`<STR_LIT>`);<EOL>    let stat = fs.statSync(file);<EOL>    let headers = {<EOL>        \"<STR_LIT>\":","gt":"\"<STR_LIT>\","}
{"input":"<s> function uploadSymbols(uploadUrl: string, file: string, userAgent: string): Q.Promise<void> {<EOL>    tl.debug(\"<STR_LIT>\");<EOL>    let defer = Q.defer<void>();<EOL>    tl.debug(`<STR_LIT>`);<EOL>    let stat = fs.statSync(file);<EOL>    let headers = {<EOL>        \"<STR_LIT>\": \"<STR_LIT>\",<EOL>        \"<STR_LIT>\": stat.size,<EOL>        \"<STR_LIT>\": userAgent,<EOL>        \"<STR_LIT>\": \"<STR_LIT>\"<EOL>    };<EOL>    fs.createReadStream(file).pipe(request.put({ url: uploadUrl, headers: headers }, (err, res, body) => {<EOL>        responseHandler(defer, err, res, body, () => {<EOL>            tl.","gt":"debug('<STR_LIT>');"}
{"input":"<s> function tarExtract(file, destinationFolder) {<EOL>    console.log(tl.loc('<STR_LIT>', file));<EOL>    if (typeof xpTarLocation == \"<STR_LIT>\") {<EOL>        xpTarLocation = tl.which('<STR_LIT>', true);<EOL>    }<EOL>    var tar = tl.tool(xpTarLocation);<EOL>    tar.arg('<STR_LIT>'); <EOL>    tar.arg(file);<EOL>    tar.arg(","gt":"'<STR_LIT>');"}
{"input":"<s> function addRouterModule(options: AppShellOptions): Rule {<EOL>    return (host: Tree) => {<EOL>        const config = getConfig(host);<EOL>        const app = getAppFromConfig(config, options.clientApp || '<STR_LIT>');<EOL>        if (app === null) {<EOL>            throw new","gt":"SchematicsException(formatMissingAppMsg('<STR_LIT>', options.clientApp));"}
{"input":"<s> function addRouterModule(options: AppShellOptions): Rule {<EOL>    return (host: Tree) => {<EOL>        const config = getConfig(host);<EOL>        const app = getAppFromConfig(config, options.clientApp || '<STR_LIT>');<EOL>        if (app === null) {<EOL>            throw new SchematicsException(formatMissingAppMsg('<STR_LIT>', options.clientApp));<EOL>        }<EOL>        const modulePath = getAppModulePath(host, app);<EOL>        const moduleSource = getSourceFile(host, modulePath);<EOL>        const changes = addImportToModule(moduleSource, modulePath, '<STR_LIT>',","gt":"'<STR_LIT>');"}
{"input":"<s> function getkubectlDownloadURL(version: string): string {<EOL>    switch (os.type()) {<EOL>        case '<STR_LIT>':<EOL>            return","gt":"util.format(\"<STR_LIT>\", version);"}
{"input":"<s> /**<EOL> * `sequence` is an animation-specific function that is designed to be used inside of Angular's<EOL> * animation DSL language. If this information is new, please navigate to the {@link<EOL> * Component#animations component animations metadata page} to gain a better understanding of<EOL> * how animations in Angular are used.<EOL> *<EOL> * `sequence` Specifies a list of animation steps that are run one by one. (`sequence` is used by<EOL> * default when an array is passed as animation data into {@link transition transition}.)<EOL> *<EOL> * The `sequence` function can either be used within a {@link group group} or a {@link transition<EOL> * transition} and it will only continue to the next instruction once each of the inner animation<EOL> * steps have completed.<EOL> *<EOL> * To perform animation styling in parallel with other animation steps then have a look at the<EOL> * {@link group group} animation function.<EOL> *<EOL> * ### Usage<EOL> *<EOL> * The `steps` data that is passed into the `sequence` animation function can either consist of<EOL> * {@link style style} or {@link animate animate} function calls. A call to `style()` will apply the<EOL> * provided styling data immediately while a call to `animate()` will apply its styling data over a<EOL> * given time depending on its timing data.<EOL> *<EOL> * ```typescript<EOL> * sequence([<EOL> *   style({ opacity: 0 })),<EOL> *   animate(\"1s\", { opacity: 1 }))<EOL> * ])<EOL> * ```<EOL> *<EOL> * {@example core/animation/ts/dsl/animation_example.ts region='Component'}<EOL> *<EOL> * @experimental Animation support is experimental.<EOL> */<EOL>export function sequence(steps: AnimationMetadata[], options: AnimationOptions | null = null): AnimationSequenceMetadata {<EOL>    return { type:","gt":"AnimationMetadataType.Sequence, steps, options };"}
{"input":"<s> function destroyDom() {<EOL>","gt":"table.data = emptyTable;"}
{"input":"<s> function addRange<T>(to: T[], from: T[]): void {<EOL>    if (to && from) {<EOL>","gt":"for (const v of from) {"}
{"input":"<s> <EOL>function mkCategories(categoryJson: any): Category[] {<EOL>    return Object.keys(categoryJson).map(catKey => {<EOL>        const cat = categoryJson[catKey];<EOL>        return {<EOL>            id: makeId(","gt":"catKey),"}
{"input":"<s> <EOL>function mkCategories(categoryJson: any): Category[] {<EOL>    return Object.keys(categoryJson).map(catKey => {<EOL>        const cat = categoryJson[catKey];<EOL>        return {<EOL>            id: makeId(catKey),<EOL>            title: catKey,<EOL>            order: cat.order,<EOL>            subCategories: mkSubCategories(cat.subCategories, catKey)<EOL>        }","gt":"as Category;"}
{"input":"<s> /**<EOL> * Spawns a child process that compiles using ngc.<EOL> * @param flags Command-line flags to be passed to ngc.<EOL> * @returns Promise that resolves/rejects when the child process exits.<EOL> */<EOL>export function ngcCompile(flags: string[]) {<EOL>    return new Promise((resolve, reject) => {<EOL>        const ngcPath = resolvePath('<STR_LIT>');<EOL>        const childProcess = spawn(","gt":"ngcPath, flags, { shell: true });"}
{"input":"<s> function f2<T extends string | undefined>(x: T, y: NonNullable<T>) {<EOL>    x = y;<EOL>    y =","gt":"x;"}
{"input":"<s> export function getColorRegistry(): IColorRegistry {<EOL>    return","gt":"colorRegistry;"}
{"input":"<s> function kvcrAsString(kvcr: KeyValueChangeRecord<string, any>) {<EOL>    return looseIdentical(kvcr.previousValue, kvcr.currentValue) ?<EOL>        stringify(","gt":"kvcr.key) :"}
{"input":"<s> function createTestComponent(template: string): ComponentFixture<TestComponent> {<EOL>    return TestBed.overrideComponent(TestComponent, {","gt":"set: { template: template } })"}
{"input":"<s> /** @docs-private */<EOL>export function getSortInvalidDirectionError(direction: string): Error {<EOL>    return","gt":"Error(`<STR_LIT>`);"}
{"input":"<s> export function genStubs() {<EOL>    console.log(\"<STR_LIT>\");<EOL>    usageCounts = loadJson(\"<STR_LIT>\");<EOL>    var","gt":"libPath = \"<STR_LIT>\";"}
{"input":"<s> export function genStubs() {<EOL>    console.log(\"<STR_LIT>\");<EOL>    usageCounts = loadJson(\"<STR_LIT>\");<EOL>    var libPath = \"<STR_LIT>\";<EOL>    fs.readdirSync(libPath).forEach((fn) => {<EOL>        fileCnt++;<EOL>        processFile(path.join(libPath, fn));<EOL>    });<EOL>    var srcPaths = [\"<STR_LIT>\", \"<STR_LIT>\", \"<STR_LIT>\", \"<STR_LIT>\", \"<STR_LIT>\", \"<STR_LIT>\", \"<STR_LIT>\", \"<STR_LIT>\", \"<STR_LIT>\"];<EOL>    srcPaths.forEach(pth => {<EOL>        fs.readdirSync(pth).forEach((fn) => {<EOL>","gt":"fileCnt++;"}
{"input":"<s> export function genStubs() {<EOL>    console.log(\"<STR_LIT>\");<EOL>    usageCounts = loadJson(\"<STR_LIT>\");<EOL>    var libPath = \"<STR_LIT>\";<EOL>    fs.readdirSync(libPath).forEach((fn) => {<EOL>        fileCnt++;<EOL>        processFile(path.join(libPath, fn));<EOL>    });<EOL>    var srcPaths = [\"<STR_LIT>\", \"<STR_LIT>\", \"<STR_LIT>\", \"<STR_LIT>\", \"<STR_LIT>\", \"<STR_LIT>\", \"<STR_LIT>\", \"<STR_LIT>\", \"<STR_LIT>\"];<EOL>    srcPaths.forEach(pth => {<EOL>        fs.readdirSync(pth).forEach((fn) => {<EOL>            fileCnt++;<EOL>","gt":"processLf(path.join(pth, fn));"}
{"input":"<s> export function genStubs() {<EOL>    console.log(\"<STR_LIT>\");<EOL>    usageCounts = loadJson(\"<STR_LIT>\");<EOL>    var libPath = \"<STR_LIT>\";<EOL>    fs.readdirSync(libPath).forEach((fn) => {<EOL>        fileCnt++;<EOL>        processFile(path.join(libPath, fn));<EOL>    });<EOL>    var srcPaths = [\"<STR_LIT>\", \"<STR_LIT>\", \"<STR_LIT>\", \"<STR_LIT>\", \"<STR_LIT>\", \"<STR_LIT>\", \"<STR_LIT>\", \"<STR_LIT>\", \"<STR_LIT>\"];<EOL>    srcPaths.forEach(pth => {<EOL>        fs.readdirSync(pth).forEach((fn) => {<EOL>            fileCnt++;<EOL>            processLf(path.join(pth, fn));<EOL>        });<EOL>    });<EOL>","gt":"processLf(\"<STR_LIT>\");"}
{"input":"<s> export function genStubs() {<EOL>    console.log(\"<STR_LIT>\");<EOL>    usageCounts = loadJson(\"<STR_LIT>\");<EOL>    var libPath = \"<STR_LIT>\";<EOL>    fs.readdirSync(libPath).forEach((fn) => {<EOL>        fileCnt++;<EOL>        processFile(path.join(libPath, fn));<EOL>    });<EOL>    var srcPaths = [\"<STR_LIT>\", \"<STR_LIT>\", \"<STR_LIT>\", \"<STR_LIT>\", \"<STR_LIT>\", \"<STR_LIT>\", \"<STR_LIT>\", \"<STR_LIT>\", \"<STR_LIT>\"];<EOL>    srcPaths.forEach(pth => {<EOL>        fs.readdirSync(pth).forEach((fn) => {<EOL>            fileCnt++;<EOL>            processLf(path.join(pth, fn));<EOL>        });<EOL>    });<EOL>    processLf(\"<STR_LIT>\");<EOL>    [\"<STR_LIT>\"].forEach(pth => {<EOL>        fs.readdirSync(pth).forEach((fn) => {<EOL>            fileCnt++;<EOL>            processLib(path.join(pth, fn));<EOL>        });<EOL>    });<EOL>    Object.keys(translationHelpStrings).forEach(k => translationStrings[k] = <NUM_LIT>);<EOL>    var tr = Object.keys(translationStrings);<EOL>    tr.sort();<EOL>    <EOL>    console.log('<STR_LIT>' + tr.length);<EOL>    fs.writeFileSync(\"<STR_LIT>\", JSON.stringify({ strings: tr }, null, <NUM_LIT>));<EOL>    helpDefinitions += \"<STR_LIT>\" + JSON.stringify(loadText(\"<STR_LIT>\").replace(/\\r/g,","gt":"\"<STR_LIT>\")) + \"<STR_LIT>\";"}
{"input":"<s> export function registerEditorContribution(ctor: IEditorContributionCtor): void {<EOL>","gt":"EditorContributionRegistry.INSTANCE.registerEditorContribution(ctor);"}
{"input":"<s> /**<EOL> * API to register custom dropdown component<EOL> */<EOL>export function registerDropdown(): boolean {<EOL>    if (!ko.bindingHandlers.msoptions)<EOL>        addMsDropdownBindingHandler();<EOL>    if (!ko.components.isRegistered(","gt":"DROPDOWN_COMPONENT)) {"}
{"input":"<s> /**<EOL> * Throw an error if issues with any options<EOL> * @param opts<EOL> */<EOL>export function validateOptions(opts: PrebootOptions) {<EOL>    if (!opts.appRoot || !opts.appRoot.length) {<EOL>        throw new Error(","gt":"'<STR_LIT>' +"}
{"input":"<s> /**<EOL> * The cache is valid if all the returned entries are empty.<EOL> */<EOL>export function validateCache(): {<EOL>    exists: string[];<EOL>    unused: string[];<EOL>    reported: string[];<EOL>} {<EOL>    const exists: string[] = [];<EOL>    const unused: string[] = [];<EOL>    for (const fileName of iterableToArray(missingCache.keys())) {<EOL>        if (","gt":"fs.existsSync(fileName)) {"}
{"input":"<s> /**<EOL> * Returns a date formatter that transforms a date and an offset into a timezone with ISO8601 or<EOL> * GMT format depending on the width (eg: short = +0430, short:GMT = GMT+4, long = GMT+04:30,<EOL> * extended = +04:30)<EOL> */<EOL>function timeZoneGetter(width: ZoneWidth): DateFormatter {<EOL>    return function (date: Date, locale: string, offset: number) {<EOL>        const zone = -<NUM_LIT> * offset;<EOL>        const minusSign = getLocaleNumberSymbol(locale, NumberSymbol.MinusSign);<EOL>        const hours = zone > <NUM_LIT> ? Math.floor(zone / <NUM_LIT>) : Math.ceil(zone / <NUM_LIT>);<EOL>","gt":"switch (width) {"}
{"input":"<s> /**<EOL> * Returns a date formatter that transforms a date and an offset into a timezone with ISO8601 or<EOL> * GMT format depending on the width (eg: short = +0430, short:GMT = GMT+4, long = GMT+04:30,<EOL> * extended = +04:30)<EOL> */<EOL>function timeZoneGetter(width: ZoneWidth): DateFormatter {<EOL>    return function (date: Date, locale: string, offset: number) {<EOL>        const zone = -<NUM_LIT> * offset;<EOL>        const minusSign = getLocaleNumberSymbol(locale, NumberSymbol.MinusSign);<EOL>        const hours = zone > <NUM_LIT> ? Math.floor(zone / <NUM_LIT>) : Math.ceil(zone / <NUM_LIT>);<EOL>        switch (width) {<EOL>            case ZoneWidth.Short:<EOL>                return ((zone >= <NUM_LIT>) ? '<STR_LIT>' : '<STR_LIT>') + padNumber(hours, <NUM_LIT>, minusSign) +<EOL>                    padNumber(Math.","gt":"abs(zone % <NUM_LIT>), <NUM_LIT>, minusSign);"}
{"input":"<s> /**<EOL> * Returns a date formatter that transforms a date and an offset into a timezone with ISO8601 or<EOL> * GMT format depending on the width (eg: short = +0430, short:GMT = GMT+4, long = GMT+04:30,<EOL> * extended = +04:30)<EOL> */<EOL>function timeZoneGetter(width: ZoneWidth): DateFormatter {<EOL>    return function (date: Date, locale: string, offset: number) {<EOL>        const zone = -<NUM_LIT> * offset;<EOL>        const minusSign = getLocaleNumberSymbol(locale, NumberSymbol.MinusSign);<EOL>        const hours = zone > <NUM_LIT> ? Math.floor(zone / <NUM_LIT>) : Math.ceil(zone / <NUM_LIT>);<EOL>        switch (width) {<EOL>            case ZoneWidth.Short:<EOL>                return ((zone >= <NUM_LIT>) ? '<STR_LIT>' : '<STR_LIT>') + padNumber(hours, <NUM_LIT>, minusSign) +<EOL>                    padNumber(Math.abs(zone % <NUM_LIT>), <NUM_LIT>, minusSign);<EOL>            case ZoneWidth.ShortGMT:<EOL>                return '<STR_LIT>' + ((zone >= <NUM_LIT>) ? '<STR_LIT>' : '<STR_LIT>') + padNumber(hours, <NUM_LIT>, minusSign);<EOL>            case","gt":"ZoneWidth.Long:"}
{"input":"<s> /**<EOL> * Returns a date formatter that transforms a date and an offset into a timezone with ISO8601 or<EOL> * GMT format depending on the width (eg: short = +0430, short:GMT = GMT+4, long = GMT+04:30,<EOL> * extended = +04:30)<EOL> */<EOL>function timeZoneGetter(width: ZoneWidth): DateFormatter {<EOL>    return function (date: Date, locale: string, offset: number) {<EOL>        const zone = -<NUM_LIT> * offset;<EOL>        const minusSign = getLocaleNumberSymbol(locale, NumberSymbol.MinusSign);<EOL>        const hours = zone > <NUM_LIT> ? Math.floor(zone / <NUM_LIT>) : Math.ceil(zone / <NUM_LIT>);<EOL>        switch (width) {<EOL>            case ZoneWidth.Short:<EOL>                return ((zone >= <NUM_LIT>) ? '<STR_LIT>' : '<STR_LIT>') + padNumber(hours, <NUM_LIT>, minusSign) +<EOL>                    padNumber(Math.abs(zone % <NUM_LIT>), <NUM_LIT>, minusSign);<EOL>            case ZoneWidth.ShortGMT:<EOL>                return '<STR_LIT>' + ((zone >= <NUM_LIT>) ? '<STR_LIT>' : '<STR_LIT>') + padNumber(hours, <NUM_LIT>, minusSign);<EOL>            case ZoneWidth.Long:<EOL>                return '<STR_LIT>' + ((zone >= <NUM_LIT>) ? '<STR_LIT>' : '<STR_LIT>') + padNumber(hours, <NUM_LIT>, minusSign) + '<STR_LIT>' +<EOL>                    padNumber(Math.abs(zone % <NUM_LIT>), <NUM_LIT>, minusSign);<EOL>","gt":"case ZoneWidth.Extended:"}
{"input":"<s> /**<EOL> * Returns a date formatter that transforms a date and an offset into a timezone with ISO8601 or<EOL> * GMT format depending on the width (eg: short = +0430, short:GMT = GMT+4, long = GMT+04:30,<EOL> * extended = +04:30)<EOL> */<EOL>function timeZoneGetter(width: ZoneWidth): DateFormatter {<EOL>    return function (date: Date, locale: string, offset: number) {<EOL>        const zone = -<NUM_LIT> * offset;<EOL>        const minusSign = getLocaleNumberSymbol(locale, NumberSymbol.MinusSign);<EOL>        const hours = zone > <NUM_LIT> ? Math.floor(zone / <NUM_LIT>) : Math.ceil(zone / <NUM_LIT>);<EOL>        switch (width) {<EOL>            case ZoneWidth.Short:<EOL>                return ((zone >= <NUM_LIT>) ? '<STR_LIT>' : '<STR_LIT>') + padNumber(hours, <NUM_LIT>, minusSign) +<EOL>                    padNumber(Math.abs(zone % <NUM_LIT>), <NUM_LIT>, minusSign);<EOL>            case ZoneWidth.ShortGMT:<EOL>                return '<STR_LIT>' + ((zone >= <NUM_LIT>) ? '<STR_LIT>' : '<STR_LIT>') + padNumber(hours, <NUM_LIT>, minusSign);<EOL>            case ZoneWidth.Long:<EOL>                return '<STR_LIT>' + ((zone >= <NUM_LIT>) ? '<STR_LIT>' : '<STR_LIT>') + padNumber(hours, <NUM_LIT>, minusSign) + '<STR_LIT>' +<EOL>                    padNumber(Math.abs(zone % <NUM_LIT>), <NUM_LIT>, minusSign);<EOL>            case ZoneWidth.Extended:<EOL>                if (offset === <NUM_LIT>) {<EOL>                    return '<STR_LIT>';<EOL>                }<EOL>                else {<EOL>                    return ((zone >= <NUM_LIT>) ? '<STR_LIT>' : '<STR_LIT>') +","gt":"padNumber(hours, <NUM_LIT>, minusSign) + '<STR_LIT>' +"}
{"input":"<s> /**<EOL> * Methods to return handler objects (see handlers folder)<EOL> */<EOL>export function getBasicHandler(username: string, password: string): VsoBaseInterfaces.IRequestHandler {<EOL>    return new basicm.BasicCredentialHandler(username,","gt":"password);"}
{"input":"<s> export function mergeDeep(target: any, source: any): any {<EOL>    let output = Object.assign({}, target);<EOL>    if (isObject(target) && isObject(source)) {<EOL>        Object.keys(source).forEach((key: any) => {<EOL>            if (isObject(source[key])) {<EOL>                if (!(key in target)) {<EOL>                    Object.assign(output, { [key]:","gt":"source[key] });"}
{"input":"<s> export function mergeDeep(target: any, source: any): any {<EOL>    let output = Object.assign({}, target);<EOL>    if (isObject(target) && isObject(source)) {<EOL>        Object.keys(source).forEach((key: any) => {<EOL>            if (isObject(source[key])) {<EOL>                if (!(key in target)) {<EOL>                    Object.assign(output, { [key]: source[key] });<EOL>                }<EOL>                else {<EOL>                    output[key] = mergeDeep(target[key], source[key]);<EOL>                }<EOL>            }<EOL>            else {<EOL>                Object.assign(output, { [key]:","gt":"source[key] });"}
{"input":"<s> /** Asserts that keyboard interaction works correctly. */<EOL>function assertCorrectKeyboardInteraction(fixture: ComponentFixture<any>, stepHeaders: DebugElement[], orientation: StepperOrientation) {<EOL>    let stepperComponent = fixture.debugElement.query(By.directive(MatStepper)).componentInstance;<EOL>    let nextKey = orientation === '<STR_LIT>' ? DOWN_ARROW : RIGHT_ARROW;<EOL>    let prevKey = orientation === '<STR_LIT>' ? UP_ARROW : LEFT_ARROW;<EOL>    expect(stepperComponent._focusIndex).toBe(","gt":"<NUM_LIT>);"}
{"input":"<s> /** Asserts that keyboard interaction works correctly. */<EOL>function assertCorrectKeyboardInteraction(fixture: ComponentFixture<any>, stepHeaders: DebugElement[], orientation: StepperOrientation) {<EOL>    let stepperComponent = fixture.debugElement.query(By.directive(MatStepper)).componentInstance;<EOL>    let nextKey = orientation === '<STR_LIT>' ? DOWN_ARROW : RIGHT_ARROW;<EOL>    let prevKey = orientation === '<STR_LIT>' ? UP_ARROW : LEFT_ARROW;<EOL>    expect(stepperComponent._focusIndex).toBe(<NUM_LIT>);<EOL>    expect(stepperComponent.selectedIndex).toBe(<NUM_LIT>);<EOL>    let stepHeaderEl = stepHeaders[<NUM_LIT>].","gt":"nativeElement;"}
{"input":"<s> /** Asserts that keyboard interaction works correctly. */<EOL>function assertCorrectKeyboardInteraction(fixture: ComponentFixture<any>, stepHeaders: DebugElement[], orientation: StepperOrientation) {<EOL>    let stepperComponent = fixture.debugElement.query(By.directive(MatStepper)).componentInstance;<EOL>    let nextKey = orientation === '<STR_LIT>' ? DOWN_ARROW : RIGHT_ARROW;<EOL>    let prevKey = orientation === '<STR_LIT>' ? UP_ARROW : LEFT_ARROW;<EOL>    expect(stepperComponent._focusIndex).toBe(<NUM_LIT>);<EOL>    expect(stepperComponent.selectedIndex).toBe(<NUM_LIT>);<EOL>    let stepHeaderEl = stepHeaders[<NUM_LIT>].nativeElement;<EOL>    dispatchKeyboardEvent(stepHeaderEl, '<STR_LIT>', nextKey);<EOL>    fixture.detectChanges();<EOL>    expect(stepperComponent._focusIndex)<EOL>        .toBe(<NUM_LIT>,","gt":"'<STR_LIT>');"}
{"input":"<s> /** Asserts that keyboard interaction works correctly. */<EOL>function assertCorrectKeyboardInteraction(fixture: ComponentFixture<any>, stepHeaders: DebugElement[], orientation: StepperOrientation) {<EOL>    let stepperComponent = fixture.debugElement.query(By.directive(MatStepper)).componentInstance;<EOL>    let nextKey = orientation === '<STR_LIT>' ? DOWN_ARROW : RIGHT_ARROW;<EOL>    let prevKey = orientation === '<STR_LIT>' ? UP_ARROW : LEFT_ARROW;<EOL>    expect(stepperComponent._focusIndex).toBe(<NUM_LIT>);<EOL>    expect(stepperComponent.selectedIndex).toBe(<NUM_LIT>);<EOL>    let stepHeaderEl = stepHeaders[<NUM_LIT>].nativeElement;<EOL>    dispatchKeyboardEvent(stepHeaderEl, '<STR_LIT>', nextKey);<EOL>    fixture.detectChanges();<EOL>    expect(stepperComponent._focusIndex)<EOL>        .toBe(<NUM_LIT>, '<STR_LIT>');<EOL>    expect(stepperComponent.selectedIndex)<EOL>        .toBe(<NUM_LIT>, '<STR_LIT>');<EOL>    stepHeaderEl = stepHeaders[<NUM_LIT>].nativeElement;<EOL>    dispatchKeyboardEvent(stepHeaderEl, '<STR_LIT>', ENTER);<EOL>","gt":"fixture.detectChanges();"}
{"input":"<s> /** Asserts that keyboard interaction works correctly. */<EOL>function assertCorrectKeyboardInteraction(fixture: ComponentFixture<any>, stepHeaders: DebugElement[], orientation: StepperOrientation) {<EOL>    let stepperComponent = fixture.debugElement.query(By.directive(MatStepper)).componentInstance;<EOL>    let nextKey = orientation === '<STR_LIT>' ? DOWN_ARROW : RIGHT_ARROW;<EOL>    let prevKey = orientation === '<STR_LIT>' ? UP_ARROW : LEFT_ARROW;<EOL>    expect(stepperComponent._focusIndex).toBe(<NUM_LIT>);<EOL>    expect(stepperComponent.selectedIndex).toBe(<NUM_LIT>);<EOL>    let stepHeaderEl = stepHeaders[<NUM_LIT>].nativeElement;<EOL>    dispatchKeyboardEvent(stepHeaderEl, '<STR_LIT>', nextKey);<EOL>    fixture.detectChanges();<EOL>    expect(stepperComponent._focusIndex)<EOL>        .toBe(<NUM_LIT>, '<STR_LIT>');<EOL>    expect(stepperComponent.selectedIndex)<EOL>        .toBe(<NUM_LIT>, '<STR_LIT>');<EOL>    stepHeaderEl = stepHeaders[<NUM_LIT>].nativeElement;<EOL>    dispatchKeyboardEvent(stepHeaderEl, '<STR_LIT>', ENTER);<EOL>    fixture.detectChanges();<EOL>","gt":"expect(stepperComponent._focusIndex)"}
{"input":"<s> /** Asserts that keyboard interaction works correctly. */<EOL>function assertCorrectKeyboardInteraction(fixture: ComponentFixture<any>, stepHeaders: DebugElement[], orientation: StepperOrientation) {<EOL>    let stepperComponent = fixture.debugElement.query(By.directive(MatStepper)).componentInstance;<EOL>    let nextKey = orientation === '<STR_LIT>' ? DOWN_ARROW : RIGHT_ARROW;<EOL>    let prevKey = orientation === '<STR_LIT>' ? UP_ARROW : LEFT_ARROW;<EOL>    expect(stepperComponent._focusIndex).toBe(<NUM_LIT>);<EOL>    expect(stepperComponent.selectedIndex).toBe(<NUM_LIT>);<EOL>    let stepHeaderEl = stepHeaders[<NUM_LIT>].nativeElement;<EOL>    dispatchKeyboardEvent(stepHeaderEl, '<STR_LIT>', nextKey);<EOL>    fixture.detectChanges();<EOL>    expect(stepperComponent._focusIndex)<EOL>        .toBe(<NUM_LIT>, '<STR_LIT>');<EOL>    expect(stepperComponent.selectedIndex)<EOL>        .toBe(<NUM_LIT>, '<STR_LIT>');<EOL>    stepHeaderEl = stepHeaders[<NUM_LIT>].nativeElement;<EOL>    dispatchKeyboardEvent(stepHeaderEl, '<STR_LIT>', ENTER);<EOL>    fixture.detectChanges();<EOL>    expect(stepperComponent._focusIndex)<EOL>        .toBe(<NUM_LIT>, '<STR_LIT>');<EOL>    expect(stepperComponent.selectedIndex)<EOL>        .toBe(<NUM_LIT>, '<STR_LIT>');<EOL>    stepHeaderEl = stepHeaders[<NUM_LIT>].","gt":"nativeElement;"}
{"input":"<s> /** Asserts that keyboard interaction works correctly. */<EOL>function assertCorrectKeyboardInteraction(fixture: ComponentFixture<any>, stepHeaders: DebugElement[], orientation: StepperOrientation) {<EOL>    let stepperComponent = fixture.debugElement.query(By.directive(MatStepper)).componentInstance;<EOL>    let nextKey = orientation === '<STR_LIT>' ? DOWN_ARROW : RIGHT_ARROW;<EOL>    let prevKey = orientation === '<STR_LIT>' ? UP_ARROW : LEFT_ARROW;<EOL>    expect(stepperComponent._focusIndex).toBe(<NUM_LIT>);<EOL>    expect(stepperComponent.selectedIndex).toBe(<NUM_LIT>);<EOL>    let stepHeaderEl = stepHeaders[<NUM_LIT>].nativeElement;<EOL>    dispatchKeyboardEvent(stepHeaderEl, '<STR_LIT>', nextKey);<EOL>    fixture.detectChanges();<EOL>    expect(stepperComponent._focusIndex)<EOL>        .toBe(<NUM_LIT>, '<STR_LIT>');<EOL>    expect(stepperComponent.selectedIndex)<EOL>        .toBe(<NUM_LIT>, '<STR_LIT>');<EOL>    stepHeaderEl = stepHeaders[<NUM_LIT>].nativeElement;<EOL>    dispatchKeyboardEvent(stepHeaderEl, '<STR_LIT>', ENTER);<EOL>    fixture.detectChanges();<EOL>    expect(stepperComponent._focusIndex)<EOL>        .toBe(<NUM_LIT>, '<STR_LIT>');<EOL>    expect(stepperComponent.selectedIndex)<EOL>        .toBe(<NUM_LIT>, '<STR_LIT>');<EOL>    stepHeaderEl = stepHeaders[<NUM_LIT>].nativeElement;<EOL>    dispatchKeyboardEvent(stepHeaderEl, '<STR_LIT>', prevKey);<EOL>    fixture.detectChanges();<EOL>    expect(stepperComponent._focusIndex)<EOL>        .toBe(<NUM_LIT>, '<STR_LIT>');<EOL>    expect(stepperComponent.selectedIndex).toBe(<NUM_LIT>, '<STR_LIT>');<EOL>    <EOL>    <EOL>    stepperComponent._focusIndex = <NUM_LIT>;<EOL>    stepHeaderEl = stepHeaders[<NUM_LIT>].nativeElement;<EOL>    dispatchKeyboardEvent(stepHeaderEl, '<STR_LIT>', nextKey);<EOL>    fixture.detectChanges();<EOL>    expect(stepperComponent._focusIndex).toBe(<NUM_LIT>, '<STR_LIT>');<EOL>    expect(stepperComponent.selectedIndex)<EOL>        .toBe(<NUM_LIT>, '<STR_LIT>');<EOL>    stepHeaderEl = stepHeaders[<NUM_LIT>].nativeElement;<EOL>    dispatchKeyboardEvent(stepHeaderEl, '<STR_LIT>',","gt":"SPACE);"}
{"input":"<s> /** Asserts that keyboard interaction works correctly. */<EOL>function assertCorrectKeyboardInteraction(fixture: ComponentFixture<any>, stepHeaders: DebugElement[], orientation: StepperOrientation) {<EOL>    let stepperComponent = fixture.debugElement.query(By.directive(MatStepper)).componentInstance;<EOL>    let nextKey = orientation === '<STR_LIT>' ? DOWN_ARROW : RIGHT_ARROW;<EOL>    let prevKey = orientation === '<STR_LIT>' ? UP_ARROW : LEFT_ARROW;<EOL>    expect(stepperComponent._focusIndex).toBe(<NUM_LIT>);<EOL>    expect(stepperComponent.selectedIndex).toBe(<NUM_LIT>);<EOL>    let stepHeaderEl = stepHeaders[<NUM_LIT>].nativeElement;<EOL>    dispatchKeyboardEvent(stepHeaderEl, '<STR_LIT>', nextKey);<EOL>    fixture.detectChanges();<EOL>    expect(stepperComponent._focusIndex)<EOL>        .toBe(<NUM_LIT>, '<STR_LIT>');<EOL>    expect(stepperComponent.selectedIndex)<EOL>        .toBe(<NUM_LIT>, '<STR_LIT>');<EOL>    stepHeaderEl = stepHeaders[<NUM_LIT>].nativeElement;<EOL>    dispatchKeyboardEvent(stepHeaderEl, '<STR_LIT>', ENTER);<EOL>    fixture.detectChanges();<EOL>    expect(stepperComponent._focusIndex)<EOL>        .toBe(<NUM_LIT>, '<STR_LIT>');<EOL>    expect(stepperComponent.selectedIndex)<EOL>        .toBe(<NUM_LIT>, '<STR_LIT>');<EOL>    stepHeaderEl = stepHeaders[<NUM_LIT>].nativeElement;<EOL>    dispatchKeyboardEvent(stepHeaderEl, '<STR_LIT>', prevKey);<EOL>    fixture.detectChanges();<EOL>    expect(stepperComponent._focusIndex)<EOL>        .toBe(<NUM_LIT>, '<STR_LIT>');<EOL>    expect(stepperComponent.selectedIndex).toBe(<NUM_LIT>, '<STR_LIT>');<EOL>    <EOL>    <EOL>    stepperComponent._focusIndex = <NUM_LIT>;<EOL>    stepHeaderEl = stepHeaders[<NUM_LIT>].nativeElement;<EOL>    dispatchKeyboardEvent(stepHeaderEl, '<STR_LIT>', nextKey);<EOL>    fixture.detectChanges();<EOL>    expect(stepperComponent._focusIndex).toBe(<NUM_LIT>, '<STR_LIT>');<EOL>    expect(stepperComponent.selectedIndex)<EOL>        .toBe(<NUM_LIT>, '<STR_LIT>');<EOL>    stepHeaderEl = stepHeaders[<NUM_LIT>].nativeElement;<EOL>    dispatchKeyboardEvent(stepHeaderEl, '<STR_LIT>', SPACE);<EOL>    fixture.detectChanges();<EOL>    expect(stepperComponent._focusIndex)<EOL>        .toBe(<NUM_LIT>, '<STR_LIT>');<EOL>    expect(stepperComponent.selectedIndex)<EOL>        .","gt":"toBe(<NUM_LIT>, '<STR_LIT>');"}
{"input":"<s> <EOL>export function requireProjectModule(root: string, moduleName: string) {<EOL>    return require(resolve.sync(","gt":"moduleName, { basedir: root }));"}
{"input":"<s> export function isSortedMap<K, V, U>(arg: any): arg is SortedMapStructure<K, V, U> {<EOL>    return","gt":"isObject(arg) && arg instanceof SortedMapStructure;"}
{"input":"<s> function f4() {<EOL>    const","gt":"rec = { foo: \"<STR_LIT>\", bar: \"<STR_LIT>\", baz: \"<STR_LIT>\" };"}
{"input":"<s> export function rootView<T>(arg: ListOrView<T>): View<T> {<EOL>    var view = arg instanceof View ? arg : firstActiveView(arg);<EOL>    while (view &&","gt":"view.parent && view.parent.parent)"}
{"input":"<s> export function deleteTasksDirectory(agentFolder: string): void {<EOL>","gt":"var config: cm.IConfiguration = createTestConfig();"}
{"input":"<s> function commitSymbols(apiServer: string, apiVersion: string, appSlug: string, symbol_upload_id: string, token: string, userAgent: string): Q.Promise<void> {<EOL>    tl.debug(\"<STR_LIT>\");<EOL>    let defer = Q.defer<void>();<EOL>    let commitSymbolsUrl: string = `<STR_LIT>`;<EOL>    tl.debug(`<STR_LIT>`);<EOL>","gt":"let headers = {"}
{"input":"<s> function commitSymbols(apiServer: string, apiVersion: string, appSlug: string, symbol_upload_id: string, token: string, userAgent: string): Q.Promise<void> {<EOL>    tl.debug(\"<STR_LIT>\");<EOL>    let defer = Q.defer<void>();<EOL>    let commitSymbolsUrl: string = `<STR_LIT>`;<EOL>    tl.debug(`<STR_LIT>`);<EOL>    let headers = {<EOL>        \"<STR_LIT>\": token,<EOL>        \"<STR_LIT>\": userAgent,<EOL>        \"<STR_LIT>\": \"<STR_LIT>\"<EOL>    };<EOL>    let commitBody = { \"<STR_LIT>\": \"<STR_LIT>\" };<EOL>    request.patch({ url: commitSymbolsUrl, headers: headers, json: commitBody }, (err, res, body) => {<EOL>        responseHandler(defer, err, res, body, () => {<EOL>            defer.","gt":"resolve();"}
{"input":"<s> function greeter(person: Person) {<EOL>    return '<STR_LIT>' + person.","gt":"firstName + '<STR_LIT>' + person.lastName;"}
{"input":"<s> export function searchQuestions(searchText: string, categoryFilter: string | null) {<EOL>    return (dispatch) => {<EOL>","gt":"dispatch(updateSearchText(searchText));"}
{"input":"<s> export function addList(spHttpClient: SPHttpClient, currentWebUrl: string, listTitle: string) {<EOL>    return async (dispatch: any) => {<EOL>        <EOL>        <EOL>        dispatch(addListRequest());<EOL>        const spOpts: ISPHttpClientOptions = {<EOL>","gt":"body: `<STR_LIT>`"}
{"input":"<s> export function addList(spHttpClient: SPHttpClient, currentWebUrl: string, listTitle: string) {<EOL>    return async (dispatch: any) => {<EOL>        <EOL>        <EOL>        dispatch(addListRequest());<EOL>        const spOpts: ISPHttpClientOptions = {<EOL>            body: `<STR_LIT>`<EOL>        };<EOL>        try {<EOL>            const response: SPHttpClientResponse = await spHttpClient.post(`<STR_LIT>`, SPHttpClient.configurations.v1, spOpts);<EOL>            const","gt":"list: IODataList = await response.json();"}
{"input":"<s> export function addList(spHttpClient: SPHttpClient, currentWebUrl: string, listTitle: string) {<EOL>    return async (dispatch: any) => {<EOL>        <EOL>        <EOL>        dispatch(addListRequest());<EOL>        const spOpts: ISPHttpClientOptions = {<EOL>            body: `<STR_LIT>`<EOL>        };<EOL>        try {<EOL>            const response: SPHttpClientResponse = await spHttpClient.post(`<STR_LIT>`, SPHttpClient.configurations.v1, spOpts);<EOL>            const list: IODataList = await response.json();<EOL>            <EOL>            dispatch(addListSuccess(list.Title));<EOL>        }<EOL>        catch (","gt":"error) {"}
{"input":"<s> function resolve(...filePart: string[]) {<EOL>    return","gt":"path.resolve(__dirname, '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', ...filePart);"}
{"input":"<s> function addDevHeaders(res: express.Response) {<EOL>    res.setHeader('<STR_LIT>',","gt":"'<STR_LIT>');"}
{"input":"<s> export function cloneHashSet<T>(set: HashSetStructure<T>, mutability?: PreferredContext): HashSetStructure<T> {<EOL>    if (isUndefined(mutability))<EOL>        mutability = isMutable(","gt":"set);"}
{"input":"<s> export function generateCssString(meta: StylableMeta, minify: boolean, stylable: Stylable, assetsIds: string[]) {<EOL>    const css = meta<EOL>        .outputAst!.toString()<EOL>        .","gt":"replace(/__stylable_url_asset_(.*?)__/g, (_$0, $1) => assetsIds[Number($1)]);"}
{"input":"<s> function testMoveCaretLeftCommand(lines: string[], selection: Selection, expectedLines: string[], expectedSelection: Selection): void {<EOL>    testCommand(lines, null, selection, (sel) => new MoveCaretCommand(sel, true),","gt":"expectedLines, expectedSelection);"}
{"input":"<s> function loginIsEmptyGroupValidator(c: FormGroup) {<EOL>","gt":"return c.controls['<STR_LIT>'].value == '<STR_LIT>' ? { '<STR_LIT>': true } : null;"}
{"input":"<s> function getPageStubs() {<EOL>","gt":"return {"}
{"input":"<s> export function headSize<T>(arg: ListOrView<T>, t): number {<EOL>    return","gt":"headSlot(arg, t).slots.length;"}
{"input":"<s> export function resolveGlobalYarnPath(tracer?: (message: string) => void): string | undefined {<EOL>    let yarnCommand = isWindows() ? '<STR_LIT>' : '<STR_LIT>';<EOL>    let results = spawnSync(yarnCommand, ['<STR_LIT>', '<STR_LIT>', '<STR_LIT>'], {<EOL>        encoding: '<STR_LIT>'<EOL>    });<EOL>","gt":"let stdout = results.stdout;"}
{"input":"<s> export function resolveGlobalYarnPath(tracer?: (message: string) => void): string | undefined {<EOL>    let yarnCommand = isWindows() ? '<STR_LIT>' : '<STR_LIT>';<EOL>    let results = spawnSync(yarnCommand, ['<STR_LIT>', '<STR_LIT>', '<STR_LIT>'], {<EOL>        encoding: '<STR_LIT>'<EOL>    });<EOL>    let stdout = results.stdout;<EOL>    if (!stdout) {<EOL>        if (tracer) {<EOL>            tracer(`<STR_LIT>`);<EOL>            if (","gt":"results.stderr) {"}
{"input":"<s> export function resolveGlobalYarnPath(tracer?: (message: string) => void): string | undefined {<EOL>    let yarnCommand = isWindows() ? '<STR_LIT>' : '<STR_LIT>';<EOL>    let results = spawnSync(yarnCommand, ['<STR_LIT>', '<STR_LIT>', '<STR_LIT>'], {<EOL>        encoding: '<STR_LIT>'<EOL>    });<EOL>    let stdout = results.stdout;<EOL>    if (!stdout) {<EOL>        if (tracer) {<EOL>            tracer(`<STR_LIT>`);<EOL>            if (results.stderr) {<EOL>                tracer(results.stderr);<EOL>            }<EOL>        }<EOL>        return undefined;<EOL>    }<EOL>    let lines = stdout.trim().split(","gt":"/\\r?\\n/);"}
{"input":"<s> /**<EOL> * Prediction API<EOL> *<EOL> * Lets you access a cloud hosted machine learning service that makes it easy to<EOL> * build smart apps<EOL> *<EOL> * @example<EOL> * const google = require('googleapis');<EOL> * const prediction = google.prediction('v1.4');<EOL> *<EOL> * @namespace prediction<EOL> * @type {Function}<EOL> * @version v1.4<EOL> * @variation v1.4<EOL> * @param {object=} options Options for Prediction<EOL> */<EOL>function Prediction(options) {<EOL>    const self = this;<EOL>    self._options = options || {};<EOL>    self.","gt":"hostedmodels = {"}
{"input":"<s> /**<EOL> * Prediction API<EOL> *<EOL> * Lets you access a cloud hosted machine learning service that makes it easy to<EOL> * build smart apps<EOL> *<EOL> * @example<EOL> * const google = require('googleapis');<EOL> * const prediction = google.prediction('v1.4');<EOL> *<EOL> * @namespace prediction<EOL> * @type {Function}<EOL> * @version v1.4<EOL> * @variation v1.4<EOL> * @param {object=} options Options for Prediction<EOL> */<EOL>function Prediction(options) {<EOL>    const self = this;<EOL>    self._options = options || {};<EOL>    self.hostedmodels = {<EOL>        /**<EOL>         * prediction.hostedmodels.predict<EOL>         * @desc Submit input and request an output against a hosted model.<EOL>         * @alias prediction.hostedmodels.predict<EOL>         * @memberOf! prediction(v1.4)<EOL>         *<EOL>         * @param {object} params Parameters for request<EOL>         * @param {string} params.hostedModelName The name of a hosted model.<EOL>         * @param {prediction(v1.4).Input} params.resource Request body data<EOL>         * @param {object} [options] Optionally override request options, such as `url`, `method`, and `encoding`.<EOL>         * @param {callback} callback The callback that handles the response.<EOL>         * @return {object} Request object<EOL>         */<EOL>        predict(params,","gt":"options, callback) {"}
{"input":"<s> /**<EOL> * Prediction API<EOL> *<EOL> * Lets you access a cloud hosted machine learning service that makes it easy to<EOL> * build smart apps<EOL> *<EOL> * @example<EOL> * const google = require('googleapis');<EOL> * const prediction = google.prediction('v1.4');<EOL> *<EOL> * @namespace prediction<EOL> * @type {Function}<EOL> * @version v1.4<EOL> * @variation v1.4<EOL> * @param {object=} options Options for Prediction<EOL> */<EOL>function Prediction(options) {<EOL>    const self = this;<EOL>    self._options = options || {};<EOL>    self.hostedmodels = {<EOL>        /**<EOL>         * prediction.hostedmodels.predict<EOL>         * @desc Submit input and request an output against a hosted model.<EOL>         * @alias prediction.hostedmodels.predict<EOL>         * @memberOf! prediction(v1.4)<EOL>         *<EOL>         * @param {object} params Parameters for request<EOL>         * @param {string} params.hostedModelName The name of a hosted model.<EOL>         * @param {prediction(v1.4).Input} params.resource Request body data<EOL>         * @param {object} [options] Optionally override request options, such as `url`, `method`, and `encoding`.<EOL>         * @param {callback} callback The callback that handles the response.<EOL>         * @return {object} Request object<EOL>         */<EOL>        predict(params, options, callback) {<EOL>            if (typeof options === '<STR_LIT>') {<EOL>                callback = options;<EOL>                options = {};<EOL>            }<EOL>            options = options || {};<EOL>","gt":"const rootUrl = options.rootUrl || '<STR_LIT>';"}
{"input":"<s> /**<EOL> * Prediction API<EOL> *<EOL> * Lets you access a cloud hosted machine learning service that makes it easy to<EOL> * build smart apps<EOL> *<EOL> * @example<EOL> * const google = require('googleapis');<EOL> * const prediction = google.prediction('v1.4');<EOL> *<EOL> * @namespace prediction<EOL> * @type {Function}<EOL> * @version v1.4<EOL> * @variation v1.4<EOL> * @param {object=} options Options for Prediction<EOL> */<EOL>function Prediction(options) {<EOL>    const self = this;<EOL>    self._options = options || {};<EOL>    self.hostedmodels = {<EOL>        /**<EOL>         * prediction.hostedmodels.predict<EOL>         * @desc Submit input and request an output against a hosted model.<EOL>         * @alias prediction.hostedmodels.predict<EOL>         * @memberOf! prediction(v1.4)<EOL>         *<EOL>         * @param {object} params Parameters for request<EOL>         * @param {string} params.hostedModelName The name of a hosted model.<EOL>         * @param {prediction(v1.4).Input} params.resource Request body data<EOL>         * @param {object} [options] Optionally override request options, such as `url`, `method`, and `encoding`.<EOL>         * @param {callback} callback The callback that handles the response.<EOL>         * @return {object} Request object<EOL>         */<EOL>        predict(params, options, callback) {<EOL>            if (typeof options === '<STR_LIT>') {<EOL>                callback = options;<EOL>                options = {};<EOL>            }<EOL>            options = options || {};<EOL>            const rootUrl = options.rootUrl || '<STR_LIT>';<EOL>            const parameters = {<EOL>                options: Object.assign({<EOL>                    url: (rootUrl +<EOL>                        '<STR_LIT>')<EOL>                        .replace(/([^:]\\/)\\/+/g,","gt":"'<STR_LIT>'),"}
{"input":"<s> /**<EOL> * Prediction API<EOL> *<EOL> * Lets you access a cloud hosted machine learning service that makes it easy to<EOL> * build smart apps<EOL> *<EOL> * @example<EOL> * const google = require('googleapis');<EOL> * const prediction = google.prediction('v1.4');<EOL> *<EOL> * @namespace prediction<EOL> * @type {Function}<EOL> * @version v1.4<EOL> * @variation v1.4<EOL> * @param {object=} options Options for Prediction<EOL> */<EOL>function Prediction(options) {<EOL>    const self = this;<EOL>    self._options = options || {};<EOL>    self.hostedmodels = {<EOL>        /**<EOL>         * prediction.hostedmodels.predict<EOL>         * @desc Submit input and request an output against a hosted model.<EOL>         * @alias prediction.hostedmodels.predict<EOL>         * @memberOf! prediction(v1.4)<EOL>         *<EOL>         * @param {object} params Parameters for request<EOL>         * @param {string} params.hostedModelName The name of a hosted model.<EOL>         * @param {prediction(v1.4).Input} params.resource Request body data<EOL>         * @param {object} [options] Optionally override request options, such as `url`, `method`, and `encoding`.<EOL>         * @param {callback} callback The callback that handles the response.<EOL>         * @return {object} Request object<EOL>         */<EOL>        predict(params, options, callback) {<EOL>            if (typeof options === '<STR_LIT>') {<EOL>                callback = options;<EOL>                options = {};<EOL>            }<EOL>            options = options || {};<EOL>            const rootUrl = options.rootUrl || '<STR_LIT>';<EOL>            const parameters = {<EOL>                options: Object.assign({<EOL>                    url: (rootUrl +<EOL>                        '<STR_LIT>')<EOL>                        .replace(/([^:]\\/)\\/+/g, '<STR_LIT>'),<EOL>                    method: '<STR_LIT>'<EOL>                }, options),<EOL>                params,<EOL>                requiredParams: ['<STR_LIT>'],<EOL>                pathParams: ['<STR_LIT>'],<EOL>                context: self<EOL>            };<EOL>            return","gt":"createAPIRequest(parameters, callback);"}
{"input":"<s> /**<EOL> * Prediction API<EOL> *<EOL> * Lets you access a cloud hosted machine learning service that makes it easy to<EOL> * build smart apps<EOL> *<EOL> * @example<EOL> * const google = require('googleapis');<EOL> * const prediction = google.prediction('v1.4');<EOL> *<EOL> * @namespace prediction<EOL> * @type {Function}<EOL> * @version v1.4<EOL> * @variation v1.4<EOL> * @param {object=} options Options for Prediction<EOL> */<EOL>function Prediction(options) {<EOL>    const self = this;<EOL>    self._options = options || {};<EOL>    self.hostedmodels = {<EOL>        /**<EOL>         * prediction.hostedmodels.predict<EOL>         * @desc Submit input and request an output against a hosted model.<EOL>         * @alias prediction.hostedmodels.predict<EOL>         * @memberOf! prediction(v1.4)<EOL>         *<EOL>         * @param {object} params Parameters for request<EOL>         * @param {string} params.hostedModelName The name of a hosted model.<EOL>         * @param {prediction(v1.4).Input} params.resource Request body data<EOL>         * @param {object} [options] Optionally override request options, such as `url`, `method`, and `encoding`.<EOL>         * @param {callback} callback The callback that handles the response.<EOL>         * @return {object} Request object<EOL>         */<EOL>        predict(params, options, callback) {<EOL>            if (typeof options === '<STR_LIT>') {<EOL>                callback = options;<EOL>                options = {};<EOL>            }<EOL>            options = options || {};<EOL>            const rootUrl = options.rootUrl || '<STR_LIT>';<EOL>            const parameters = {<EOL>                options: Object.assign({<EOL>                    url: (rootUrl +<EOL>                        '<STR_LIT>')<EOL>                        .replace(/([^:]\\/)\\/+/g, '<STR_LIT>'),<EOL>                    method: '<STR_LIT>'<EOL>                }, options),<EOL>                params,<EOL>                requiredParams: ['<STR_LIT>'],<EOL>                pathParams: ['<STR_LIT>'],<EOL>                context: self<EOL>            };<EOL>            return createAPIRequest(parameters, callback);<EOL>        }<EOL>    };<EOL>    self.trainedmodels = {<EOL>        /**<EOL>         * prediction.trainedmodels.delete<EOL>         * @desc Delete a trained model.<EOL>         * @alias prediction.trainedmodels.delete<EOL>         * @memberOf! prediction(v1.4)<EOL>         *<EOL>         * @param {object} params Parameters for request<EOL>         * @param {string} params.id The unique name for the predictive model.<EOL>         * @param {object} [options] Optionally override request options, such as `url`, `method`, and `encoding`.<EOL>         * @param {callback} callback The callback that handles the response.<EOL>         * @return {object} Request object<EOL>         */<EOL>        delete(params, options, callback) {<EOL>            if (typeof options === '<STR_LIT>') {<EOL>                callback = options;<EOL>                options = {};<EOL>            }<EOL>            options = options || {};<EOL>            const rootUrl = options.rootUrl || '<STR_LIT>';<EOL>            const parameters = {<EOL>                options: Object.","gt":"assign({"}
{"input":"<s> /**<EOL> * Prediction API<EOL> *<EOL> * Lets you access a cloud hosted machine learning service that makes it easy to<EOL> * build smart apps<EOL> *<EOL> * @example<EOL> * const google = require('googleapis');<EOL> * const prediction = google.prediction('v1.4');<EOL> *<EOL> * @namespace prediction<EOL> * @type {Function}<EOL> * @version v1.4<EOL> * @variation v1.4<EOL> * @param {object=} options Options for Prediction<EOL> */<EOL>function Prediction(options) {<EOL>    const self = this;<EOL>    self._options = options || {};<EOL>    self.hostedmodels = {<EOL>        /**<EOL>         * prediction.hostedmodels.predict<EOL>         * @desc Submit input and request an output against a hosted model.<EOL>         * @alias prediction.hostedmodels.predict<EOL>         * @memberOf! prediction(v1.4)<EOL>         *<EOL>         * @param {object} params Parameters for request<EOL>         * @param {string} params.hostedModelName The name of a hosted model.<EOL>         * @param {prediction(v1.4).Input} params.resource Request body data<EOL>         * @param {object} [options] Optionally override request options, such as `url`, `method`, and `encoding`.<EOL>         * @param {callback} callback The callback that handles the response.<EOL>         * @return {object} Request object<EOL>         */<EOL>        predict(params, options, callback) {<EOL>            if (typeof options === '<STR_LIT>') {<EOL>                callback = options;<EOL>                options = {};<EOL>            }<EOL>            options = options || {};<EOL>            const rootUrl = options.rootUrl || '<STR_LIT>';<EOL>            const parameters = {<EOL>                options: Object.assign({<EOL>                    url: (rootUrl +<EOL>                        '<STR_LIT>')<EOL>                        .replace(/([^:]\\/)\\/+/g, '<STR_LIT>'),<EOL>                    method: '<STR_LIT>'<EOL>                }, options),<EOL>                params,<EOL>                requiredParams: ['<STR_LIT>'],<EOL>                pathParams: ['<STR_LIT>'],<EOL>                context: self<EOL>            };<EOL>            return createAPIRequest(parameters, callback);<EOL>        }<EOL>    };<EOL>    self.trainedmodels = {<EOL>        /**<EOL>         * prediction.trainedmodels.delete<EOL>         * @desc Delete a trained model.<EOL>         * @alias prediction.trainedmodels.delete<EOL>         * @memberOf! prediction(v1.4)<EOL>         *<EOL>         * @param {object} params Parameters for request<EOL>         * @param {string} params.id The unique name for the predictive model.<EOL>         * @param {object} [options] Optionally override request options, such as `url`, `method`, and `encoding`.<EOL>         * @param {callback} callback The callback that handles the response.<EOL>         * @return {object} Request object<EOL>         */<EOL>        delete(params, options, callback) {<EOL>            if (typeof options === '<STR_LIT>') {<EOL>                callback = options;<EOL>                options = {};<EOL>            }<EOL>            options = options || {};<EOL>            const rootUrl = options.rootUrl || '<STR_LIT>';<EOL>            const parameters = {<EOL>                options: Object.assign({<EOL>                    url: (rootUrl + '<STR_LIT>')<EOL>                        .replace(/([^:]\\/)\\/+/g,","gt":"'<STR_LIT>'),"}
{"input":"<s> /**<EOL> * Prediction API<EOL> *<EOL> * Lets you access a cloud hosted machine learning service that makes it easy to<EOL> * build smart apps<EOL> *<EOL> * @example<EOL> * const google = require('googleapis');<EOL> * const prediction = google.prediction('v1.4');<EOL> *<EOL> * @namespace prediction<EOL> * @type {Function}<EOL> * @version v1.4<EOL> * @variation v1.4<EOL> * @param {object=} options Options for Prediction<EOL> */<EOL>function Prediction(options) {<EOL>    const self = this;<EOL>    self._options = options || {};<EOL>    self.hostedmodels = {<EOL>        /**<EOL>         * prediction.hostedmodels.predict<EOL>         * @desc Submit input and request an output against a hosted model.<EOL>         * @alias prediction.hostedmodels.predict<EOL>         * @memberOf! prediction(v1.4)<EOL>         *<EOL>         * @param {object} params Parameters for request<EOL>         * @param {string} params.hostedModelName The name of a hosted model.<EOL>         * @param {prediction(v1.4).Input} params.resource Request body data<EOL>         * @param {object} [options] Optionally override request options, such as `url`, `method`, and `encoding`.<EOL>         * @param {callback} callback The callback that handles the response.<EOL>         * @return {object} Request object<EOL>         */<EOL>        predict(params, options, callback) {<EOL>            if (typeof options === '<STR_LIT>') {<EOL>                callback = options;<EOL>                options = {};<EOL>            }<EOL>            options = options || {};<EOL>            const rootUrl = options.rootUrl || '<STR_LIT>';<EOL>            const parameters = {<EOL>                options: Object.assign({<EOL>                    url: (rootUrl +<EOL>                        '<STR_LIT>')<EOL>                        .replace(/([^:]\\/)\\/+/g, '<STR_LIT>'),<EOL>                    method: '<STR_LIT>'<EOL>                }, options),<EOL>                params,<EOL>                requiredParams: ['<STR_LIT>'],<EOL>                pathParams: ['<STR_LIT>'],<EOL>                context: self<EOL>            };<EOL>            return createAPIRequest(parameters, callback);<EOL>        }<EOL>    };<EOL>    self.trainedmodels = {<EOL>        /**<EOL>         * prediction.trainedmodels.delete<EOL>         * @desc Delete a trained model.<EOL>         * @alias prediction.trainedmodels.delete<EOL>         * @memberOf! prediction(v1.4)<EOL>         *<EOL>         * @param {object} params Parameters for request<EOL>         * @param {string} params.id The unique name for the predictive model.<EOL>         * @param {object} [options] Optionally override request options, such as `url`, `method`, and `encoding`.<EOL>         * @param {callback} callback The callback that handles the response.<EOL>         * @return {object} Request object<EOL>         */<EOL>        delete(params, options, callback) {<EOL>            if (typeof options === '<STR_LIT>') {<EOL>                callback = options;<EOL>                options = {};<EOL>            }<EOL>            options = options || {};<EOL>            const rootUrl = options.rootUrl || '<STR_LIT>';<EOL>            const parameters = {<EOL>                options: Object.assign({<EOL>                    url: (rootUrl + '<STR_LIT>')<EOL>                        .replace(/([^:]\\/)\\/+/g, '<STR_LIT>'),<EOL>                    method: '<STR_LIT>'<EOL>                }, options),<EOL>                params,<EOL>                requiredParams: ['<STR_LIT>'],<EOL>                pathParams: ['<STR_LIT>'],<EOL>                context:","gt":"self"}
{"input":"<s> /**<EOL> * Prediction API<EOL> *<EOL> * Lets you access a cloud hosted machine learning service that makes it easy to<EOL> * build smart apps<EOL> *<EOL> * @example<EOL> * const google = require('googleapis');<EOL> * const prediction = google.prediction('v1.4');<EOL> *<EOL> * @namespace prediction<EOL> * @type {Function}<EOL> * @version v1.4<EOL> * @variation v1.4<EOL> * @param {object=} options Options for Prediction<EOL> */<EOL>function Prediction(options) {<EOL>    const self = this;<EOL>    self._options = options || {};<EOL>    self.hostedmodels = {<EOL>        /**<EOL>         * prediction.hostedmodels.predict<EOL>         * @desc Submit input and request an output against a hosted model.<EOL>         * @alias prediction.hostedmodels.predict<EOL>         * @memberOf! prediction(v1.4)<EOL>         *<EOL>         * @param {object} params Parameters for request<EOL>         * @param {string} params.hostedModelName The name of a hosted model.<EOL>         * @param {prediction(v1.4).Input} params.resource Request body data<EOL>         * @param {object} [options] Optionally override request options, such as `url`, `method`, and `encoding`.<EOL>         * @param {callback} callback The callback that handles the response.<EOL>         * @return {object} Request object<EOL>         */<EOL>        predict(params, options, callback) {<EOL>            if (typeof options === '<STR_LIT>') {<EOL>                callback = options;<EOL>                options = {};<EOL>            }<EOL>            options = options || {};<EOL>            const rootUrl = options.rootUrl || '<STR_LIT>';<EOL>            const parameters = {<EOL>                options: Object.assign({<EOL>                    url: (rootUrl +<EOL>                        '<STR_LIT>')<EOL>                        .replace(/([^:]\\/)\\/+/g, '<STR_LIT>'),<EOL>                    method: '<STR_LIT>'<EOL>                }, options),<EOL>                params,<EOL>                requiredParams: ['<STR_LIT>'],<EOL>                pathParams: ['<STR_LIT>'],<EOL>                context: self<EOL>            };<EOL>            return createAPIRequest(parameters, callback);<EOL>        }<EOL>    };<EOL>    self.trainedmodels = {<EOL>        /**<EOL>         * prediction.trainedmodels.delete<EOL>         * @desc Delete a trained model.<EOL>         * @alias prediction.trainedmodels.delete<EOL>         * @memberOf! prediction(v1.4)<EOL>         *<EOL>         * @param {object} params Parameters for request<EOL>         * @param {string} params.id The unique name for the predictive model.<EOL>         * @param {object} [options] Optionally override request options, such as `url`, `method`, and `encoding`.<EOL>         * @param {callback} callback The callback that handles the response.<EOL>         * @return {object} Request object<EOL>         */<EOL>        delete(params, options, callback) {<EOL>            if (typeof options === '<STR_LIT>') {<EOL>                callback = options;<EOL>                options = {};<EOL>            }<EOL>            options = options || {};<EOL>            const rootUrl = options.rootUrl || '<STR_LIT>';<EOL>            const parameters = {<EOL>                options: Object.assign({<EOL>                    url: (rootUrl + '<STR_LIT>')<EOL>                        .replace(/([^:]\\/)\\/+/g, '<STR_LIT>'),<EOL>                    method: '<STR_LIT>'<EOL>                }, options),<EOL>                params,<EOL>                requiredParams: ['<STR_LIT>'],<EOL>                pathParams: ['<STR_LIT>'],<EOL>                context: self<EOL>            };<EOL>            return createAPIRequest(parameters, callback);<EOL>        },<EOL>        get(params, options, callback) {<EOL>            if (typeof options === '<STR_LIT>') {<EOL>                callback = options;<EOL>                options = {};<EOL>            }<EOL>            options = options || {};<EOL>            const rootUrl = options.rootUrl || '<STR_LIT>';<EOL>            const parameters = {<EOL>                options: Object.assign({<EOL>                    url: (rootUrl + '<STR_LIT>')<EOL>                        .replace(/([^:]\\/)\\/+/g, '<STR_LIT>'),<EOL>                    method: '<STR_LIT>'<EOL>                }, options),<EOL>                params,<EOL>                requiredParams: ['<STR_LIT>'],<EOL>                pathParams: ['<STR_LIT>'],<EOL>                context: self<EOL>            };<EOL>            return createAPIRequest(parameters, callback);<EOL>        },<EOL>        insert(params, options, callback) {<EOL>","gt":"if (typeof options === '<STR_LIT>') {"}
{"input":"<s> /**<EOL> * Prediction API<EOL> *<EOL> * Lets you access a cloud hosted machine learning service that makes it easy to<EOL> * build smart apps<EOL> *<EOL> * @example<EOL> * const google = require('googleapis');<EOL> * const prediction = google.prediction('v1.4');<EOL> *<EOL> * @namespace prediction<EOL> * @type {Function}<EOL> * @version v1.4<EOL> * @variation v1.4<EOL> * @param {object=} options Options for Prediction<EOL> */<EOL>function Prediction(options) {<EOL>    const self = this;<EOL>    self._options = options || {};<EOL>    self.hostedmodels = {<EOL>        /**<EOL>         * prediction.hostedmodels.predict<EOL>         * @desc Submit input and request an output against a hosted model.<EOL>         * @alias prediction.hostedmodels.predict<EOL>         * @memberOf! prediction(v1.4)<EOL>         *<EOL>         * @param {object} params Parameters for request<EOL>         * @param {string} params.hostedModelName The name of a hosted model.<EOL>         * @param {prediction(v1.4).Input} params.resource Request body data<EOL>         * @param {object} [options] Optionally override request options, such as `url`, `method`, and `encoding`.<EOL>         * @param {callback} callback The callback that handles the response.<EOL>         * @return {object} Request object<EOL>         */<EOL>        predict(params, options, callback) {<EOL>            if (typeof options === '<STR_LIT>') {<EOL>                callback = options;<EOL>                options = {};<EOL>            }<EOL>            options = options || {};<EOL>            const rootUrl = options.rootUrl || '<STR_LIT>';<EOL>            const parameters = {<EOL>                options: Object.assign({<EOL>                    url: (rootUrl +<EOL>                        '<STR_LIT>')<EOL>                        .replace(/([^:]\\/)\\/+/g, '<STR_LIT>'),<EOL>                    method: '<STR_LIT>'<EOL>                }, options),<EOL>                params,<EOL>                requiredParams: ['<STR_LIT>'],<EOL>                pathParams: ['<STR_LIT>'],<EOL>                context: self<EOL>            };<EOL>            return createAPIRequest(parameters, callback);<EOL>        }<EOL>    };<EOL>    self.trainedmodels = {<EOL>        /**<EOL>         * prediction.trainedmodels.delete<EOL>         * @desc Delete a trained model.<EOL>         * @alias prediction.trainedmodels.delete<EOL>         * @memberOf! prediction(v1.4)<EOL>         *<EOL>         * @param {object} params Parameters for request<EOL>         * @param {string} params.id The unique name for the predictive model.<EOL>         * @param {object} [options] Optionally override request options, such as `url`, `method`, and `encoding`.<EOL>         * @param {callback} callback The callback that handles the response.<EOL>         * @return {object} Request object<EOL>         */<EOL>        delete(params, options, callback) {<EOL>            if (typeof options === '<STR_LIT>') {<EOL>                callback = options;<EOL>                options = {};<EOL>            }<EOL>            options = options || {};<EOL>            const rootUrl = options.rootUrl || '<STR_LIT>';<EOL>            const parameters = {<EOL>                options: Object.assign({<EOL>                    url: (rootUrl + '<STR_LIT>')<EOL>                        .replace(/([^:]\\/)\\/+/g, '<STR_LIT>'),<EOL>                    method: '<STR_LIT>'<EOL>                }, options),<EOL>                params,<EOL>                requiredParams: ['<STR_LIT>'],<EOL>                pathParams: ['<STR_LIT>'],<EOL>                context: self<EOL>            };<EOL>            return createAPIRequest(parameters, callback);<EOL>        },<EOL>        get(params, options, callback) {<EOL>            if (typeof options === '<STR_LIT>') {<EOL>                callback = options;<EOL>                options = {};<EOL>            }<EOL>            options = options || {};<EOL>            const rootUrl = options.rootUrl || '<STR_LIT>';<EOL>            const parameters = {<EOL>                options: Object.assign({<EOL>                    url: (rootUrl + '<STR_LIT>')<EOL>                        .replace(/([^:]\\/)\\/+/g, '<STR_LIT>'),<EOL>                    method: '<STR_LIT>'<EOL>                }, options),<EOL>                params,<EOL>                requiredParams: ['<STR_LIT>'],<EOL>                pathParams: ['<STR_LIT>'],<EOL>                context: self<EOL>            };<EOL>            return createAPIRequest(parameters, callback);<EOL>        },<EOL>        insert(params, options, callback) {<EOL>            if (typeof options === '<STR_LIT>') {<EOL>                callback = options;<EOL>","gt":"options = {};"}
{"input":"<s> /**<EOL> * Prediction API<EOL> *<EOL> * Lets you access a cloud hosted machine learning service that makes it easy to<EOL> * build smart apps<EOL> *<EOL> * @example<EOL> * const google = require('googleapis');<EOL> * const prediction = google.prediction('v1.4');<EOL> *<EOL> * @namespace prediction<EOL> * @type {Function}<EOL> * @version v1.4<EOL> * @variation v1.4<EOL> * @param {object=} options Options for Prediction<EOL> */<EOL>function Prediction(options) {<EOL>    const self = this;<EOL>    self._options = options || {};<EOL>    self.hostedmodels = {<EOL>        /**<EOL>         * prediction.hostedmodels.predict<EOL>         * @desc Submit input and request an output against a hosted model.<EOL>         * @alias prediction.hostedmodels.predict<EOL>         * @memberOf! prediction(v1.4)<EOL>         *<EOL>         * @param {object} params Parameters for request<EOL>         * @param {string} params.hostedModelName The name of a hosted model.<EOL>         * @param {prediction(v1.4).Input} params.resource Request body data<EOL>         * @param {object} [options] Optionally override request options, such as `url`, `method`, and `encoding`.<EOL>         * @param {callback} callback The callback that handles the response.<EOL>         * @return {object} Request object<EOL>         */<EOL>        predict(params, options, callback) {<EOL>            if (typeof options === '<STR_LIT>') {<EOL>                callback = options;<EOL>                options = {};<EOL>            }<EOL>            options = options || {};<EOL>            const rootUrl = options.rootUrl || '<STR_LIT>';<EOL>            const parameters = {<EOL>                options: Object.assign({<EOL>                    url: (rootUrl +<EOL>                        '<STR_LIT>')<EOL>                        .replace(/([^:]\\/)\\/+/g, '<STR_LIT>'),<EOL>                    method: '<STR_LIT>'<EOL>                }, options),<EOL>                params,<EOL>                requiredParams: ['<STR_LIT>'],<EOL>                pathParams: ['<STR_LIT>'],<EOL>                context: self<EOL>            };<EOL>            return createAPIRequest(parameters, callback);<EOL>        }<EOL>    };<EOL>    self.trainedmodels = {<EOL>        /**<EOL>         * prediction.trainedmodels.delete<EOL>         * @desc Delete a trained model.<EOL>         * @alias prediction.trainedmodels.delete<EOL>         * @memberOf! prediction(v1.4)<EOL>         *<EOL>         * @param {object} params Parameters for request<EOL>         * @param {string} params.id The unique name for the predictive model.<EOL>         * @param {object} [options] Optionally override request options, such as `url`, `method`, and `encoding`.<EOL>         * @param {callback} callback The callback that handles the response.<EOL>         * @return {object} Request object<EOL>         */<EOL>        delete(params, options, callback) {<EOL>            if (typeof options === '<STR_LIT>') {<EOL>                callback = options;<EOL>                options = {};<EOL>            }<EOL>            options = options || {};<EOL>            const rootUrl = options.rootUrl || '<STR_LIT>';<EOL>            const parameters = {<EOL>                options: Object.assign({<EOL>                    url: (rootUrl + '<STR_LIT>')<EOL>                        .replace(/([^:]\\/)\\/+/g, '<STR_LIT>'),<EOL>                    method: '<STR_LIT>'<EOL>                }, options),<EOL>                params,<EOL>                requiredParams: ['<STR_LIT>'],<EOL>                pathParams: ['<STR_LIT>'],<EOL>                context: self<EOL>            };<EOL>            return createAPIRequest(parameters, callback);<EOL>        },<EOL>        get(params, options, callback) {<EOL>            if (typeof options === '<STR_LIT>') {<EOL>                callback = options;<EOL>                options = {};<EOL>            }<EOL>            options = options || {};<EOL>            const rootUrl = options.rootUrl || '<STR_LIT>';<EOL>            const parameters = {<EOL>                options: Object.assign({<EOL>                    url: (rootUrl + '<STR_LIT>')<EOL>                        .replace(/([^:]\\/)\\/+/g, '<STR_LIT>'),<EOL>                    method: '<STR_LIT>'<EOL>                }, options),<EOL>                params,<EOL>                requiredParams: ['<STR_LIT>'],<EOL>                pathParams: ['<STR_LIT>'],<EOL>                context: self<EOL>            };<EOL>            return createAPIRequest(parameters, callback);<EOL>        },<EOL>        insert(params, options, callback) {<EOL>            if (typeof options === '<STR_LIT>') {<EOL>                callback = options;<EOL>                options = {};<EOL>            }<EOL>            options = options || {};<EOL>            const rootUrl = options.rootUrl || '<STR_LIT>';<EOL>            const parameters = {<EOL>                options:","gt":"Object.assign({"}
{"input":"<s> /**<EOL> * Prediction API<EOL> *<EOL> * Lets you access a cloud hosted machine learning service that makes it easy to<EOL> * build smart apps<EOL> *<EOL> * @example<EOL> * const google = require('googleapis');<EOL> * const prediction = google.prediction('v1.4');<EOL> *<EOL> * @namespace prediction<EOL> * @type {Function}<EOL> * @version v1.4<EOL> * @variation v1.4<EOL> * @param {object=} options Options for Prediction<EOL> */<EOL>function Prediction(options) {<EOL>    const self = this;<EOL>    self._options = options || {};<EOL>    self.hostedmodels = {<EOL>        /**<EOL>         * prediction.hostedmodels.predict<EOL>         * @desc Submit input and request an output against a hosted model.<EOL>         * @alias prediction.hostedmodels.predict<EOL>         * @memberOf! prediction(v1.4)<EOL>         *<EOL>         * @param {object} params Parameters for request<EOL>         * @param {string} params.hostedModelName The name of a hosted model.<EOL>         * @param {prediction(v1.4).Input} params.resource Request body data<EOL>         * @param {object} [options] Optionally override request options, such as `url`, `method`, and `encoding`.<EOL>         * @param {callback} callback The callback that handles the response.<EOL>         * @return {object} Request object<EOL>         */<EOL>        predict(params, options, callback) {<EOL>            if (typeof options === '<STR_LIT>') {<EOL>                callback = options;<EOL>                options = {};<EOL>            }<EOL>            options = options || {};<EOL>            const rootUrl = options.rootUrl || '<STR_LIT>';<EOL>            const parameters = {<EOL>                options: Object.assign({<EOL>                    url: (rootUrl +<EOL>                        '<STR_LIT>')<EOL>                        .replace(/([^:]\\/)\\/+/g, '<STR_LIT>'),<EOL>                    method: '<STR_LIT>'<EOL>                }, options),<EOL>                params,<EOL>                requiredParams: ['<STR_LIT>'],<EOL>                pathParams: ['<STR_LIT>'],<EOL>                context: self<EOL>            };<EOL>            return createAPIRequest(parameters, callback);<EOL>        }<EOL>    };<EOL>    self.trainedmodels = {<EOL>        /**<EOL>         * prediction.trainedmodels.delete<EOL>         * @desc Delete a trained model.<EOL>         * @alias prediction.trainedmodels.delete<EOL>         * @memberOf! prediction(v1.4)<EOL>         *<EOL>         * @param {object} params Parameters for request<EOL>         * @param {string} params.id The unique name for the predictive model.<EOL>         * @param {object} [options] Optionally override request options, such as `url`, `method`, and `encoding`.<EOL>         * @param {callback} callback The callback that handles the response.<EOL>         * @return {object} Request object<EOL>         */<EOL>        delete(params, options, callback) {<EOL>            if (typeof options === '<STR_LIT>') {<EOL>                callback = options;<EOL>                options = {};<EOL>            }<EOL>            options = options || {};<EOL>            const rootUrl = options.rootUrl || '<STR_LIT>';<EOL>            const parameters = {<EOL>                options: Object.assign({<EOL>                    url: (rootUrl + '<STR_LIT>')<EOL>                        .replace(/([^:]\\/)\\/+/g, '<STR_LIT>'),<EOL>                    method: '<STR_LIT>'<EOL>                }, options),<EOL>                params,<EOL>                requiredParams: ['<STR_LIT>'],<EOL>                pathParams: ['<STR_LIT>'],<EOL>                context: self<EOL>            };<EOL>            return createAPIRequest(parameters, callback);<EOL>        },<EOL>        get(params, options, callback) {<EOL>            if (typeof options === '<STR_LIT>') {<EOL>                callback = options;<EOL>                options = {};<EOL>            }<EOL>            options = options || {};<EOL>            const rootUrl = options.rootUrl || '<STR_LIT>';<EOL>            const parameters = {<EOL>                options: Object.assign({<EOL>                    url: (rootUrl + '<STR_LIT>')<EOL>                        .replace(/([^:]\\/)\\/+/g, '<STR_LIT>'),<EOL>                    method: '<STR_LIT>'<EOL>                }, options),<EOL>                params,<EOL>                requiredParams: ['<STR_LIT>'],<EOL>                pathParams: ['<STR_LIT>'],<EOL>                context: self<EOL>            };<EOL>            return createAPIRequest(parameters, callback);<EOL>        },<EOL>        insert(params, options, callback) {<EOL>            if (typeof options === '<STR_LIT>') {<EOL>                callback = options;<EOL>                options = {};<EOL>            }<EOL>            options = options || {};<EOL>            const rootUrl = options.rootUrl || '<STR_LIT>';<EOL>            const parameters = {<EOL>                options: Object.assign({<EOL>","gt":"url: (rootUrl + '<STR_LIT>')"}
{"input":"<s> /**<EOL> * Prediction API<EOL> *<EOL> * Lets you access a cloud hosted machine learning service that makes it easy to<EOL> * build smart apps<EOL> *<EOL> * @example<EOL> * const google = require('googleapis');<EOL> * const prediction = google.prediction('v1.4');<EOL> *<EOL> * @namespace prediction<EOL> * @type {Function}<EOL> * @version v1.4<EOL> * @variation v1.4<EOL> * @param {object=} options Options for Prediction<EOL> */<EOL>function Prediction(options) {<EOL>    const self = this;<EOL>    self._options = options || {};<EOL>    self.hostedmodels = {<EOL>        /**<EOL>         * prediction.hostedmodels.predict<EOL>         * @desc Submit input and request an output against a hosted model.<EOL>         * @alias prediction.hostedmodels.predict<EOL>         * @memberOf! prediction(v1.4)<EOL>         *<EOL>         * @param {object} params Parameters for request<EOL>         * @param {string} params.hostedModelName The name of a hosted model.<EOL>         * @param {prediction(v1.4).Input} params.resource Request body data<EOL>         * @param {object} [options] Optionally override request options, such as `url`, `method`, and `encoding`.<EOL>         * @param {callback} callback The callback that handles the response.<EOL>         * @return {object} Request object<EOL>         */<EOL>        predict(params, options, callback) {<EOL>            if (typeof options === '<STR_LIT>') {<EOL>                callback = options;<EOL>                options = {};<EOL>            }<EOL>            options = options || {};<EOL>            const rootUrl = options.rootUrl || '<STR_LIT>';<EOL>            const parameters = {<EOL>                options: Object.assign({<EOL>                    url: (rootUrl +<EOL>                        '<STR_LIT>')<EOL>                        .replace(/([^:]\\/)\\/+/g, '<STR_LIT>'),<EOL>                    method: '<STR_LIT>'<EOL>                }, options),<EOL>                params,<EOL>                requiredParams: ['<STR_LIT>'],<EOL>                pathParams: ['<STR_LIT>'],<EOL>                context: self<EOL>            };<EOL>            return createAPIRequest(parameters, callback);<EOL>        }<EOL>    };<EOL>    self.trainedmodels = {<EOL>        /**<EOL>         * prediction.trainedmodels.delete<EOL>         * @desc Delete a trained model.<EOL>         * @alias prediction.trainedmodels.delete<EOL>         * @memberOf! prediction(v1.4)<EOL>         *<EOL>         * @param {object} params Parameters for request<EOL>         * @param {string} params.id The unique name for the predictive model.<EOL>         * @param {object} [options] Optionally override request options, such as `url`, `method`, and `encoding`.<EOL>         * @param {callback} callback The callback that handles the response.<EOL>         * @return {object} Request object<EOL>         */<EOL>        delete(params, options, callback) {<EOL>            if (typeof options === '<STR_LIT>') {<EOL>                callback = options;<EOL>                options = {};<EOL>            }<EOL>            options = options || {};<EOL>            const rootUrl = options.rootUrl || '<STR_LIT>';<EOL>            const parameters = {<EOL>                options: Object.assign({<EOL>                    url: (rootUrl + '<STR_LIT>')<EOL>                        .replace(/([^:]\\/)\\/+/g, '<STR_LIT>'),<EOL>                    method: '<STR_LIT>'<EOL>                }, options),<EOL>                params,<EOL>                requiredParams: ['<STR_LIT>'],<EOL>                pathParams: ['<STR_LIT>'],<EOL>                context: self<EOL>            };<EOL>            return createAPIRequest(parameters, callback);<EOL>        },<EOL>        get(params, options, callback) {<EOL>            if (typeof options === '<STR_LIT>') {<EOL>                callback = options;<EOL>                options = {};<EOL>            }<EOL>            options = options || {};<EOL>            const rootUrl = options.rootUrl || '<STR_LIT>';<EOL>            const parameters = {<EOL>                options: Object.assign({<EOL>                    url: (rootUrl + '<STR_LIT>')<EOL>                        .replace(/([^:]\\/)\\/+/g, '<STR_LIT>'),<EOL>                    method: '<STR_LIT>'<EOL>                }, options),<EOL>                params,<EOL>                requiredParams: ['<STR_LIT>'],<EOL>                pathParams: ['<STR_LIT>'],<EOL>                context: self<EOL>            };<EOL>            return createAPIRequest(parameters, callback);<EOL>        },<EOL>        insert(params, options, callback) {<EOL>            if (typeof options === '<STR_LIT>') {<EOL>                callback = options;<EOL>                options = {};<EOL>            }<EOL>            options = options || {};<EOL>            const rootUrl = options.rootUrl || '<STR_LIT>';<EOL>            const parameters = {<EOL>                options: Object.assign({<EOL>                    url: (rootUrl + '<STR_LIT>')<EOL>                        .replace(/([^:]\\/)\\/+/g, '<STR_LIT>'),<EOL>","gt":"method: '<STR_LIT>'"}
{"input":"<s> /**<EOL> * Prediction API<EOL> *<EOL> * Lets you access a cloud hosted machine learning service that makes it easy to<EOL> * build smart apps<EOL> *<EOL> * @example<EOL> * const google = require('googleapis');<EOL> * const prediction = google.prediction('v1.4');<EOL> *<EOL> * @namespace prediction<EOL> * @type {Function}<EOL> * @version v1.4<EOL> * @variation v1.4<EOL> * @param {object=} options Options for Prediction<EOL> */<EOL>function Prediction(options) {<EOL>    const self = this;<EOL>    self._options = options || {};<EOL>    self.hostedmodels = {<EOL>        /**<EOL>         * prediction.hostedmodels.predict<EOL>         * @desc Submit input and request an output against a hosted model.<EOL>         * @alias prediction.hostedmodels.predict<EOL>         * @memberOf! prediction(v1.4)<EOL>         *<EOL>         * @param {object} params Parameters for request<EOL>         * @param {string} params.hostedModelName The name of a hosted model.<EOL>         * @param {prediction(v1.4).Input} params.resource Request body data<EOL>         * @param {object} [options] Optionally override request options, such as `url`, `method`, and `encoding`.<EOL>         * @param {callback} callback The callback that handles the response.<EOL>         * @return {object} Request object<EOL>         */<EOL>        predict(params, options, callback) {<EOL>            if (typeof options === '<STR_LIT>') {<EOL>                callback = options;<EOL>                options = {};<EOL>            }<EOL>            options = options || {};<EOL>            const rootUrl = options.rootUrl || '<STR_LIT>';<EOL>            const parameters = {<EOL>                options: Object.assign({<EOL>                    url: (rootUrl +<EOL>                        '<STR_LIT>')<EOL>                        .replace(/([^:]\\/)\\/+/g, '<STR_LIT>'),<EOL>                    method: '<STR_LIT>'<EOL>                }, options),<EOL>                params,<EOL>                requiredParams: ['<STR_LIT>'],<EOL>                pathParams: ['<STR_LIT>'],<EOL>                context: self<EOL>            };<EOL>            return createAPIRequest(parameters, callback);<EOL>        }<EOL>    };<EOL>    self.trainedmodels = {<EOL>        /**<EOL>         * prediction.trainedmodels.delete<EOL>         * @desc Delete a trained model.<EOL>         * @alias prediction.trainedmodels.delete<EOL>         * @memberOf! prediction(v1.4)<EOL>         *<EOL>         * @param {object} params Parameters for request<EOL>         * @param {string} params.id The unique name for the predictive model.<EOL>         * @param {object} [options] Optionally override request options, such as `url`, `method`, and `encoding`.<EOL>         * @param {callback} callback The callback that handles the response.<EOL>         * @return {object} Request object<EOL>         */<EOL>        delete(params, options, callback) {<EOL>            if (typeof options === '<STR_LIT>') {<EOL>                callback = options;<EOL>                options = {};<EOL>            }<EOL>            options = options || {};<EOL>            const rootUrl = options.rootUrl || '<STR_LIT>';<EOL>            const parameters = {<EOL>                options: Object.assign({<EOL>                    url: (rootUrl + '<STR_LIT>')<EOL>                        .replace(/([^:]\\/)\\/+/g, '<STR_LIT>'),<EOL>                    method: '<STR_LIT>'<EOL>                }, options),<EOL>                params,<EOL>                requiredParams: ['<STR_LIT>'],<EOL>                pathParams: ['<STR_LIT>'],<EOL>                context: self<EOL>            };<EOL>            return createAPIRequest(parameters, callback);<EOL>        },<EOL>        get(params, options, callback) {<EOL>            if (typeof options === '<STR_LIT>') {<EOL>                callback = options;<EOL>                options = {};<EOL>            }<EOL>            options = options || {};<EOL>            const rootUrl = options.rootUrl || '<STR_LIT>';<EOL>            const parameters = {<EOL>                options: Object.assign({<EOL>                    url: (rootUrl + '<STR_LIT>')<EOL>                        .replace(/([^:]\\/)\\/+/g, '<STR_LIT>'),<EOL>                    method: '<STR_LIT>'<EOL>                }, options),<EOL>                params,<EOL>                requiredParams: ['<STR_LIT>'],<EOL>                pathParams: ['<STR_LIT>'],<EOL>                context: self<EOL>            };<EOL>            return createAPIRequest(parameters, callback);<EOL>        },<EOL>        insert(params, options, callback) {<EOL>            if (typeof options === '<STR_LIT>') {<EOL>                callback = options;<EOL>                options = {};<EOL>            }<EOL>            options = options || {};<EOL>            const rootUrl = options.rootUrl || '<STR_LIT>';<EOL>            const parameters = {<EOL>                options: Object.assign({<EOL>                    url: (rootUrl + '<STR_LIT>')<EOL>                        .replace(/([^:]\\/)\\/+/g, '<STR_LIT>'),<EOL>                    method: '<STR_LIT>'<EOL>                }, options),<EOL>                params,<EOL>                requiredParams: [],<EOL>                pathParams: [],<EOL>                context: self<EOL>            };<EOL>            return createAPIRequest(parameters, callback);<EOL>        },<EOL>        predict(params, options, callback) {<EOL>            if (typeof options === '<STR_LIT>') {<EOL>                callback = options;<EOL>                options = {};<EOL>            }<EOL>            options = options || {};<EOL>            const rootUrl = options.rootUrl ||","gt":"'<STR_LIT>';"}
{"input":"<s> /**<EOL> * Prediction API<EOL> *<EOL> * Lets you access a cloud hosted machine learning service that makes it easy to<EOL> * build smart apps<EOL> *<EOL> * @example<EOL> * const google = require('googleapis');<EOL> * const prediction = google.prediction('v1.4');<EOL> *<EOL> * @namespace prediction<EOL> * @type {Function}<EOL> * @version v1.4<EOL> * @variation v1.4<EOL> * @param {object=} options Options for Prediction<EOL> */<EOL>function Prediction(options) {<EOL>    const self = this;<EOL>    self._options = options || {};<EOL>    self.hostedmodels = {<EOL>        /**<EOL>         * prediction.hostedmodels.predict<EOL>         * @desc Submit input and request an output against a hosted model.<EOL>         * @alias prediction.hostedmodels.predict<EOL>         * @memberOf! prediction(v1.4)<EOL>         *<EOL>         * @param {object} params Parameters for request<EOL>         * @param {string} params.hostedModelName The name of a hosted model.<EOL>         * @param {prediction(v1.4).Input} params.resource Request body data<EOL>         * @param {object} [options] Optionally override request options, such as `url`, `method`, and `encoding`.<EOL>         * @param {callback} callback The callback that handles the response.<EOL>         * @return {object} Request object<EOL>         */<EOL>        predict(params, options, callback) {<EOL>            if (typeof options === '<STR_LIT>') {<EOL>                callback = options;<EOL>                options = {};<EOL>            }<EOL>            options = options || {};<EOL>            const rootUrl = options.rootUrl || '<STR_LIT>';<EOL>            const parameters = {<EOL>                options: Object.assign({<EOL>                    url: (rootUrl +<EOL>                        '<STR_LIT>')<EOL>                        .replace(/([^:]\\/)\\/+/g, '<STR_LIT>'),<EOL>                    method: '<STR_LIT>'<EOL>                }, options),<EOL>                params,<EOL>                requiredParams: ['<STR_LIT>'],<EOL>                pathParams: ['<STR_LIT>'],<EOL>                context: self<EOL>            };<EOL>            return createAPIRequest(parameters, callback);<EOL>        }<EOL>    };<EOL>    self.trainedmodels = {<EOL>        /**<EOL>         * prediction.trainedmodels.delete<EOL>         * @desc Delete a trained model.<EOL>         * @alias prediction.trainedmodels.delete<EOL>         * @memberOf! prediction(v1.4)<EOL>         *<EOL>         * @param {object} params Parameters for request<EOL>         * @param {string} params.id The unique name for the predictive model.<EOL>         * @param {object} [options] Optionally override request options, such as `url`, `method`, and `encoding`.<EOL>         * @param {callback} callback The callback that handles the response.<EOL>         * @return {object} Request object<EOL>         */<EOL>        delete(params, options, callback) {<EOL>            if (typeof options === '<STR_LIT>') {<EOL>                callback = options;<EOL>                options = {};<EOL>            }<EOL>            options = options || {};<EOL>            const rootUrl = options.rootUrl || '<STR_LIT>';<EOL>            const parameters = {<EOL>                options: Object.assign({<EOL>                    url: (rootUrl + '<STR_LIT>')<EOL>                        .replace(/([^:]\\/)\\/+/g, '<STR_LIT>'),<EOL>                    method: '<STR_LIT>'<EOL>                }, options),<EOL>                params,<EOL>                requiredParams: ['<STR_LIT>'],<EOL>                pathParams: ['<STR_LIT>'],<EOL>                context: self<EOL>            };<EOL>            return createAPIRequest(parameters, callback);<EOL>        },<EOL>        get(params, options, callback) {<EOL>            if (typeof options === '<STR_LIT>') {<EOL>                callback = options;<EOL>                options = {};<EOL>            }<EOL>            options = options || {};<EOL>            const rootUrl = options.rootUrl || '<STR_LIT>';<EOL>            const parameters = {<EOL>                options: Object.assign({<EOL>                    url: (rootUrl + '<STR_LIT>')<EOL>                        .replace(/([^:]\\/)\\/+/g, '<STR_LIT>'),<EOL>                    method: '<STR_LIT>'<EOL>                }, options),<EOL>                params,<EOL>                requiredParams: ['<STR_LIT>'],<EOL>                pathParams: ['<STR_LIT>'],<EOL>                context: self<EOL>            };<EOL>            return createAPIRequest(parameters, callback);<EOL>        },<EOL>        insert(params, options, callback) {<EOL>            if (typeof options === '<STR_LIT>') {<EOL>                callback = options;<EOL>                options = {};<EOL>            }<EOL>            options = options || {};<EOL>            const rootUrl = options.rootUrl || '<STR_LIT>';<EOL>            const parameters = {<EOL>                options: Object.assign({<EOL>                    url: (rootUrl + '<STR_LIT>')<EOL>                        .replace(/([^:]\\/)\\/+/g, '<STR_LIT>'),<EOL>                    method: '<STR_LIT>'<EOL>                }, options),<EOL>                params,<EOL>                requiredParams: [],<EOL>                pathParams: [],<EOL>                context: self<EOL>            };<EOL>            return createAPIRequest(parameters, callback);<EOL>        },<EOL>        predict(params, options, callback) {<EOL>            if (typeof options === '<STR_LIT>') {<EOL>                callback = options;<EOL>                options = {};<EOL>            }<EOL>            options = options || {};<EOL>            const rootUrl = options.rootUrl || '<STR_LIT>';<EOL>            const parameters = {<EOL>                options: Object.assign({<EOL>","gt":"url: (rootUrl + '<STR_LIT>')"}
{"input":"<s> /**<EOL> * Prediction API<EOL> *<EOL> * Lets you access a cloud hosted machine learning service that makes it easy to<EOL> * build smart apps<EOL> *<EOL> * @example<EOL> * const google = require('googleapis');<EOL> * const prediction = google.prediction('v1.4');<EOL> *<EOL> * @namespace prediction<EOL> * @type {Function}<EOL> * @version v1.4<EOL> * @variation v1.4<EOL> * @param {object=} options Options for Prediction<EOL> */<EOL>function Prediction(options) {<EOL>    const self = this;<EOL>    self._options = options || {};<EOL>    self.hostedmodels = {<EOL>        /**<EOL>         * prediction.hostedmodels.predict<EOL>         * @desc Submit input and request an output against a hosted model.<EOL>         * @alias prediction.hostedmodels.predict<EOL>         * @memberOf! prediction(v1.4)<EOL>         *<EOL>         * @param {object} params Parameters for request<EOL>         * @param {string} params.hostedModelName The name of a hosted model.<EOL>         * @param {prediction(v1.4).Input} params.resource Request body data<EOL>         * @param {object} [options] Optionally override request options, such as `url`, `method`, and `encoding`.<EOL>         * @param {callback} callback The callback that handles the response.<EOL>         * @return {object} Request object<EOL>         */<EOL>        predict(params, options, callback) {<EOL>            if (typeof options === '<STR_LIT>') {<EOL>                callback = options;<EOL>                options = {};<EOL>            }<EOL>            options = options || {};<EOL>            const rootUrl = options.rootUrl || '<STR_LIT>';<EOL>            const parameters = {<EOL>                options: Object.assign({<EOL>                    url: (rootUrl +<EOL>                        '<STR_LIT>')<EOL>                        .replace(/([^:]\\/)\\/+/g, '<STR_LIT>'),<EOL>                    method: '<STR_LIT>'<EOL>                }, options),<EOL>                params,<EOL>                requiredParams: ['<STR_LIT>'],<EOL>                pathParams: ['<STR_LIT>'],<EOL>                context: self<EOL>            };<EOL>            return createAPIRequest(parameters, callback);<EOL>        }<EOL>    };<EOL>    self.trainedmodels = {<EOL>        /**<EOL>         * prediction.trainedmodels.delete<EOL>         * @desc Delete a trained model.<EOL>         * @alias prediction.trainedmodels.delete<EOL>         * @memberOf! prediction(v1.4)<EOL>         *<EOL>         * @param {object} params Parameters for request<EOL>         * @param {string} params.id The unique name for the predictive model.<EOL>         * @param {object} [options] Optionally override request options, such as `url`, `method`, and `encoding`.<EOL>         * @param {callback} callback The callback that handles the response.<EOL>         * @return {object} Request object<EOL>         */<EOL>        delete(params, options, callback) {<EOL>            if (typeof options === '<STR_LIT>') {<EOL>                callback = options;<EOL>                options = {};<EOL>            }<EOL>            options = options || {};<EOL>            const rootUrl = options.rootUrl || '<STR_LIT>';<EOL>            const parameters = {<EOL>                options: Object.assign({<EOL>                    url: (rootUrl + '<STR_LIT>')<EOL>                        .replace(/([^:]\\/)\\/+/g, '<STR_LIT>'),<EOL>                    method: '<STR_LIT>'<EOL>                }, options),<EOL>                params,<EOL>                requiredParams: ['<STR_LIT>'],<EOL>                pathParams: ['<STR_LIT>'],<EOL>                context: self<EOL>            };<EOL>            return createAPIRequest(parameters, callback);<EOL>        },<EOL>        get(params, options, callback) {<EOL>            if (typeof options === '<STR_LIT>') {<EOL>                callback = options;<EOL>                options = {};<EOL>            }<EOL>            options = options || {};<EOL>            const rootUrl = options.rootUrl || '<STR_LIT>';<EOL>            const parameters = {<EOL>                options: Object.assign({<EOL>                    url: (rootUrl + '<STR_LIT>')<EOL>                        .replace(/([^:]\\/)\\/+/g, '<STR_LIT>'),<EOL>                    method: '<STR_LIT>'<EOL>                }, options),<EOL>                params,<EOL>                requiredParams: ['<STR_LIT>'],<EOL>                pathParams: ['<STR_LIT>'],<EOL>                context: self<EOL>            };<EOL>            return createAPIRequest(parameters, callback);<EOL>        },<EOL>        insert(params, options, callback) {<EOL>            if (typeof options === '<STR_LIT>') {<EOL>                callback = options;<EOL>                options = {};<EOL>            }<EOL>            options = options || {};<EOL>            const rootUrl = options.rootUrl || '<STR_LIT>';<EOL>            const parameters = {<EOL>                options: Object.assign({<EOL>                    url: (rootUrl + '<STR_LIT>')<EOL>                        .replace(/([^:]\\/)\\/+/g, '<STR_LIT>'),<EOL>                    method: '<STR_LIT>'<EOL>                }, options),<EOL>                params,<EOL>                requiredParams: [],<EOL>                pathParams: [],<EOL>                context: self<EOL>            };<EOL>            return createAPIRequest(parameters, callback);<EOL>        },<EOL>        predict(params, options, callback) {<EOL>            if (typeof options === '<STR_LIT>') {<EOL>                callback = options;<EOL>                options = {};<EOL>            }<EOL>            options = options || {};<EOL>            const rootUrl = options.rootUrl || '<STR_LIT>';<EOL>            const parameters = {<EOL>                options: Object.assign({<EOL>                    url: (rootUrl + '<STR_LIT>')<EOL>                        .replace(/([^:]\\/)\\/+/g, '<STR_LIT>'),<EOL>                    method: '<STR_LIT>'<EOL>                }, options),<EOL>                params,<EOL>                requiredParams: ['<STR_LIT>'],<EOL>                pathParams: [","gt":"'<STR_LIT>'],"}
{"input":"<s> /**<EOL> * Prediction API<EOL> *<EOL> * Lets you access a cloud hosted machine learning service that makes it easy to<EOL> * build smart apps<EOL> *<EOL> * @example<EOL> * const google = require('googleapis');<EOL> * const prediction = google.prediction('v1.4');<EOL> *<EOL> * @namespace prediction<EOL> * @type {Function}<EOL> * @version v1.4<EOL> * @variation v1.4<EOL> * @param {object=} options Options for Prediction<EOL> */<EOL>function Prediction(options) {<EOL>    const self = this;<EOL>    self._options = options || {};<EOL>    self.hostedmodels = {<EOL>        /**<EOL>         * prediction.hostedmodels.predict<EOL>         * @desc Submit input and request an output against a hosted model.<EOL>         * @alias prediction.hostedmodels.predict<EOL>         * @memberOf! prediction(v1.4)<EOL>         *<EOL>         * @param {object} params Parameters for request<EOL>         * @param {string} params.hostedModelName The name of a hosted model.<EOL>         * @param {prediction(v1.4).Input} params.resource Request body data<EOL>         * @param {object} [options] Optionally override request options, such as `url`, `method`, and `encoding`.<EOL>         * @param {callback} callback The callback that handles the response.<EOL>         * @return {object} Request object<EOL>         */<EOL>        predict(params, options, callback) {<EOL>            if (typeof options === '<STR_LIT>') {<EOL>                callback = options;<EOL>                options = {};<EOL>            }<EOL>            options = options || {};<EOL>            const rootUrl = options.rootUrl || '<STR_LIT>';<EOL>            const parameters = {<EOL>                options: Object.assign({<EOL>                    url: (rootUrl +<EOL>                        '<STR_LIT>')<EOL>                        .replace(/([^:]\\/)\\/+/g, '<STR_LIT>'),<EOL>                    method: '<STR_LIT>'<EOL>                }, options),<EOL>                params,<EOL>                requiredParams: ['<STR_LIT>'],<EOL>                pathParams: ['<STR_LIT>'],<EOL>                context: self<EOL>            };<EOL>            return createAPIRequest(parameters, callback);<EOL>        }<EOL>    };<EOL>    self.trainedmodels = {<EOL>        /**<EOL>         * prediction.trainedmodels.delete<EOL>         * @desc Delete a trained model.<EOL>         * @alias prediction.trainedmodels.delete<EOL>         * @memberOf! prediction(v1.4)<EOL>         *<EOL>         * @param {object} params Parameters for request<EOL>         * @param {string} params.id The unique name for the predictive model.<EOL>         * @param {object} [options] Optionally override request options, such as `url`, `method`, and `encoding`.<EOL>         * @param {callback} callback The callback that handles the response.<EOL>         * @return {object} Request object<EOL>         */<EOL>        delete(params, options, callback) {<EOL>            if (typeof options === '<STR_LIT>') {<EOL>                callback = options;<EOL>                options = {};<EOL>            }<EOL>            options = options || {};<EOL>            const rootUrl = options.rootUrl || '<STR_LIT>';<EOL>            const parameters = {<EOL>                options: Object.assign({<EOL>                    url: (rootUrl + '<STR_LIT>')<EOL>                        .replace(/([^:]\\/)\\/+/g, '<STR_LIT>'),<EOL>                    method: '<STR_LIT>'<EOL>                }, options),<EOL>                params,<EOL>                requiredParams: ['<STR_LIT>'],<EOL>                pathParams: ['<STR_LIT>'],<EOL>                context: self<EOL>            };<EOL>            return createAPIRequest(parameters, callback);<EOL>        },<EOL>        get(params, options, callback) {<EOL>            if (typeof options === '<STR_LIT>') {<EOL>                callback = options;<EOL>                options = {};<EOL>            }<EOL>            options = options || {};<EOL>            const rootUrl = options.rootUrl || '<STR_LIT>';<EOL>            const parameters = {<EOL>                options: Object.assign({<EOL>                    url: (rootUrl + '<STR_LIT>')<EOL>                        .replace(/([^:]\\/)\\/+/g, '<STR_LIT>'),<EOL>                    method: '<STR_LIT>'<EOL>                }, options),<EOL>                params,<EOL>                requiredParams: ['<STR_LIT>'],<EOL>                pathParams: ['<STR_LIT>'],<EOL>                context: self<EOL>            };<EOL>            return createAPIRequest(parameters, callback);<EOL>        },<EOL>        insert(params, options, callback) {<EOL>            if (typeof options === '<STR_LIT>') {<EOL>                callback = options;<EOL>                options = {};<EOL>            }<EOL>            options = options || {};<EOL>            const rootUrl = options.rootUrl || '<STR_LIT>';<EOL>            const parameters = {<EOL>                options: Object.assign({<EOL>                    url: (rootUrl + '<STR_LIT>')<EOL>                        .replace(/([^:]\\/)\\/+/g, '<STR_LIT>'),<EOL>                    method: '<STR_LIT>'<EOL>                }, options),<EOL>                params,<EOL>                requiredParams: [],<EOL>                pathParams: [],<EOL>                context: self<EOL>            };<EOL>            return createAPIRequest(parameters, callback);<EOL>        },<EOL>        predict(params, options, callback) {<EOL>            if (typeof options === '<STR_LIT>') {<EOL>                callback = options;<EOL>                options = {};<EOL>            }<EOL>            options = options || {};<EOL>            const rootUrl = options.rootUrl || '<STR_LIT>';<EOL>            const parameters = {<EOL>                options: Object.assign({<EOL>                    url: (rootUrl + '<STR_LIT>')<EOL>                        .replace(/([^:]\\/)\\/+/g, '<STR_LIT>'),<EOL>                    method: '<STR_LIT>'<EOL>                }, options),<EOL>                params,<EOL>                requiredParams: ['<STR_LIT>'],<EOL>                pathParams: ['<STR_LIT>'],<EOL>","gt":"context: self"}
{"input":"<s> /**<EOL> * Prediction API<EOL> *<EOL> * Lets you access a cloud hosted machine learning service that makes it easy to<EOL> * build smart apps<EOL> *<EOL> * @example<EOL> * const google = require('googleapis');<EOL> * const prediction = google.prediction('v1.4');<EOL> *<EOL> * @namespace prediction<EOL> * @type {Function}<EOL> * @version v1.4<EOL> * @variation v1.4<EOL> * @param {object=} options Options for Prediction<EOL> */<EOL>function Prediction(options) {<EOL>    const self = this;<EOL>    self._options = options || {};<EOL>    self.hostedmodels = {<EOL>        /**<EOL>         * prediction.hostedmodels.predict<EOL>         * @desc Submit input and request an output against a hosted model.<EOL>         * @alias prediction.hostedmodels.predict<EOL>         * @memberOf! prediction(v1.4)<EOL>         *<EOL>         * @param {object} params Parameters for request<EOL>         * @param {string} params.hostedModelName The name of a hosted model.<EOL>         * @param {prediction(v1.4).Input} params.resource Request body data<EOL>         * @param {object} [options] Optionally override request options, such as `url`, `method`, and `encoding`.<EOL>         * @param {callback} callback The callback that handles the response.<EOL>         * @return {object} Request object<EOL>         */<EOL>        predict(params, options, callback) {<EOL>            if (typeof options === '<STR_LIT>') {<EOL>                callback = options;<EOL>                options = {};<EOL>            }<EOL>            options = options || {};<EOL>            const rootUrl = options.rootUrl || '<STR_LIT>';<EOL>            const parameters = {<EOL>                options: Object.assign({<EOL>                    url: (rootUrl +<EOL>                        '<STR_LIT>')<EOL>                        .replace(/([^:]\\/)\\/+/g, '<STR_LIT>'),<EOL>                    method: '<STR_LIT>'<EOL>                }, options),<EOL>                params,<EOL>                requiredParams: ['<STR_LIT>'],<EOL>                pathParams: ['<STR_LIT>'],<EOL>                context: self<EOL>            };<EOL>            return createAPIRequest(parameters, callback);<EOL>        }<EOL>    };<EOL>    self.trainedmodels = {<EOL>        /**<EOL>         * prediction.trainedmodels.delete<EOL>         * @desc Delete a trained model.<EOL>         * @alias prediction.trainedmodels.delete<EOL>         * @memberOf! prediction(v1.4)<EOL>         *<EOL>         * @param {object} params Parameters for request<EOL>         * @param {string} params.id The unique name for the predictive model.<EOL>         * @param {object} [options] Optionally override request options, such as `url`, `method`, and `encoding`.<EOL>         * @param {callback} callback The callback that handles the response.<EOL>         * @return {object} Request object<EOL>         */<EOL>        delete(params, options, callback) {<EOL>            if (typeof options === '<STR_LIT>') {<EOL>                callback = options;<EOL>                options = {};<EOL>            }<EOL>            options = options || {};<EOL>            const rootUrl = options.rootUrl || '<STR_LIT>';<EOL>            const parameters = {<EOL>                options: Object.assign({<EOL>                    url: (rootUrl + '<STR_LIT>')<EOL>                        .replace(/([^:]\\/)\\/+/g, '<STR_LIT>'),<EOL>                    method: '<STR_LIT>'<EOL>                }, options),<EOL>                params,<EOL>                requiredParams: ['<STR_LIT>'],<EOL>                pathParams: ['<STR_LIT>'],<EOL>                context: self<EOL>            };<EOL>            return createAPIRequest(parameters, callback);<EOL>        },<EOL>        get(params, options, callback) {<EOL>            if (typeof options === '<STR_LIT>') {<EOL>                callback = options;<EOL>                options = {};<EOL>            }<EOL>            options = options || {};<EOL>            const rootUrl = options.rootUrl || '<STR_LIT>';<EOL>            const parameters = {<EOL>                options: Object.assign({<EOL>                    url: (rootUrl + '<STR_LIT>')<EOL>                        .replace(/([^:]\\/)\\/+/g, '<STR_LIT>'),<EOL>                    method: '<STR_LIT>'<EOL>                }, options),<EOL>                params,<EOL>                requiredParams: ['<STR_LIT>'],<EOL>                pathParams: ['<STR_LIT>'],<EOL>                context: self<EOL>            };<EOL>            return createAPIRequest(parameters, callback);<EOL>        },<EOL>        insert(params, options, callback) {<EOL>            if (typeof options === '<STR_LIT>') {<EOL>                callback = options;<EOL>                options = {};<EOL>            }<EOL>            options = options || {};<EOL>            const rootUrl = options.rootUrl || '<STR_LIT>';<EOL>            const parameters = {<EOL>                options: Object.assign({<EOL>                    url: (rootUrl + '<STR_LIT>')<EOL>                        .replace(/([^:]\\/)\\/+/g, '<STR_LIT>'),<EOL>                    method: '<STR_LIT>'<EOL>                }, options),<EOL>                params,<EOL>                requiredParams: [],<EOL>                pathParams: [],<EOL>                context: self<EOL>            };<EOL>            return createAPIRequest(parameters, callback);<EOL>        },<EOL>        predict(params, options, callback) {<EOL>            if (typeof options === '<STR_LIT>') {<EOL>                callback = options;<EOL>                options = {};<EOL>            }<EOL>            options = options || {};<EOL>            const rootUrl = options.rootUrl || '<STR_LIT>';<EOL>            const parameters = {<EOL>                options: Object.assign({<EOL>                    url: (rootUrl + '<STR_LIT>')<EOL>                        .replace(/([^:]\\/)\\/+/g, '<STR_LIT>'),<EOL>                    method: '<STR_LIT>'<EOL>                }, options),<EOL>                params,<EOL>                requiredParams: ['<STR_LIT>'],<EOL>                pathParams: ['<STR_LIT>'],<EOL>                context: self<EOL>            };<EOL>            return createAPIRequest(parameters, callback);<EOL>        },<EOL>        update(params, options, callback) {<EOL>            if (typeof options === '<STR_LIT>') {<EOL>                callback =","gt":"options;"}
{"input":"<s> /**<EOL> * Prediction API<EOL> *<EOL> * Lets you access a cloud hosted machine learning service that makes it easy to<EOL> * build smart apps<EOL> *<EOL> * @example<EOL> * const google = require('googleapis');<EOL> * const prediction = google.prediction('v1.4');<EOL> *<EOL> * @namespace prediction<EOL> * @type {Function}<EOL> * @version v1.4<EOL> * @variation v1.4<EOL> * @param {object=} options Options for Prediction<EOL> */<EOL>function Prediction(options) {<EOL>    const self = this;<EOL>    self._options = options || {};<EOL>    self.hostedmodels = {<EOL>        /**<EOL>         * prediction.hostedmodels.predict<EOL>         * @desc Submit input and request an output against a hosted model.<EOL>         * @alias prediction.hostedmodels.predict<EOL>         * @memberOf! prediction(v1.4)<EOL>         *<EOL>         * @param {object} params Parameters for request<EOL>         * @param {string} params.hostedModelName The name of a hosted model.<EOL>         * @param {prediction(v1.4).Input} params.resource Request body data<EOL>         * @param {object} [options] Optionally override request options, such as `url`, `method`, and `encoding`.<EOL>         * @param {callback} callback The callback that handles the response.<EOL>         * @return {object} Request object<EOL>         */<EOL>        predict(params, options, callback) {<EOL>            if (typeof options === '<STR_LIT>') {<EOL>                callback = options;<EOL>                options = {};<EOL>            }<EOL>            options = options || {};<EOL>            const rootUrl = options.rootUrl || '<STR_LIT>';<EOL>            const parameters = {<EOL>                options: Object.assign({<EOL>                    url: (rootUrl +<EOL>                        '<STR_LIT>')<EOL>                        .replace(/([^:]\\/)\\/+/g, '<STR_LIT>'),<EOL>                    method: '<STR_LIT>'<EOL>                }, options),<EOL>                params,<EOL>                requiredParams: ['<STR_LIT>'],<EOL>                pathParams: ['<STR_LIT>'],<EOL>                context: self<EOL>            };<EOL>            return createAPIRequest(parameters, callback);<EOL>        }<EOL>    };<EOL>    self.trainedmodels = {<EOL>        /**<EOL>         * prediction.trainedmodels.delete<EOL>         * @desc Delete a trained model.<EOL>         * @alias prediction.trainedmodels.delete<EOL>         * @memberOf! prediction(v1.4)<EOL>         *<EOL>         * @param {object} params Parameters for request<EOL>         * @param {string} params.id The unique name for the predictive model.<EOL>         * @param {object} [options] Optionally override request options, such as `url`, `method`, and `encoding`.<EOL>         * @param {callback} callback The callback that handles the response.<EOL>         * @return {object} Request object<EOL>         */<EOL>        delete(params, options, callback) {<EOL>            if (typeof options === '<STR_LIT>') {<EOL>                callback = options;<EOL>                options = {};<EOL>            }<EOL>            options = options || {};<EOL>            const rootUrl = options.rootUrl || '<STR_LIT>';<EOL>            const parameters = {<EOL>                options: Object.assign({<EOL>                    url: (rootUrl + '<STR_LIT>')<EOL>                        .replace(/([^:]\\/)\\/+/g, '<STR_LIT>'),<EOL>                    method: '<STR_LIT>'<EOL>                }, options),<EOL>                params,<EOL>                requiredParams: ['<STR_LIT>'],<EOL>                pathParams: ['<STR_LIT>'],<EOL>                context: self<EOL>            };<EOL>            return createAPIRequest(parameters, callback);<EOL>        },<EOL>        get(params, options, callback) {<EOL>            if (typeof options === '<STR_LIT>') {<EOL>                callback = options;<EOL>                options = {};<EOL>            }<EOL>            options = options || {};<EOL>            const rootUrl = options.rootUrl || '<STR_LIT>';<EOL>            const parameters = {<EOL>                options: Object.assign({<EOL>                    url: (rootUrl + '<STR_LIT>')<EOL>                        .replace(/([^:]\\/)\\/+/g, '<STR_LIT>'),<EOL>                    method: '<STR_LIT>'<EOL>                }, options),<EOL>                params,<EOL>                requiredParams: ['<STR_LIT>'],<EOL>                pathParams: ['<STR_LIT>'],<EOL>                context: self<EOL>            };<EOL>            return createAPIRequest(parameters, callback);<EOL>        },<EOL>        insert(params, options, callback) {<EOL>            if (typeof options === '<STR_LIT>') {<EOL>                callback = options;<EOL>                options = {};<EOL>            }<EOL>            options = options || {};<EOL>            const rootUrl = options.rootUrl || '<STR_LIT>';<EOL>            const parameters = {<EOL>                options: Object.assign({<EOL>                    url: (rootUrl + '<STR_LIT>')<EOL>                        .replace(/([^:]\\/)\\/+/g, '<STR_LIT>'),<EOL>                    method: '<STR_LIT>'<EOL>                }, options),<EOL>                params,<EOL>                requiredParams: [],<EOL>                pathParams: [],<EOL>                context: self<EOL>            };<EOL>            return createAPIRequest(parameters, callback);<EOL>        },<EOL>        predict(params, options, callback) {<EOL>            if (typeof options === '<STR_LIT>') {<EOL>                callback = options;<EOL>                options = {};<EOL>            }<EOL>            options = options || {};<EOL>            const rootUrl = options.rootUrl || '<STR_LIT>';<EOL>            const parameters = {<EOL>                options: Object.assign({<EOL>                    url: (rootUrl + '<STR_LIT>')<EOL>                        .replace(/([^:]\\/)\\/+/g, '<STR_LIT>'),<EOL>                    method: '<STR_LIT>'<EOL>                }, options),<EOL>                params,<EOL>                requiredParams: ['<STR_LIT>'],<EOL>                pathParams: ['<STR_LIT>'],<EOL>                context: self<EOL>            };<EOL>            return createAPIRequest(parameters, callback);<EOL>        },<EOL>        update(params, options, callback) {<EOL>            if (typeof options === '<STR_LIT>') {<EOL>                callback = options;<EOL>                options = {};<EOL>            }<EOL>","gt":"options = options || {};"}
{"input":"<s> /**<EOL> * Prediction API<EOL> *<EOL> * Lets you access a cloud hosted machine learning service that makes it easy to<EOL> * build smart apps<EOL> *<EOL> * @example<EOL> * const google = require('googleapis');<EOL> * const prediction = google.prediction('v1.4');<EOL> *<EOL> * @namespace prediction<EOL> * @type {Function}<EOL> * @version v1.4<EOL> * @variation v1.4<EOL> * @param {object=} options Options for Prediction<EOL> */<EOL>function Prediction(options) {<EOL>    const self = this;<EOL>    self._options = options || {};<EOL>    self.hostedmodels = {<EOL>        /**<EOL>         * prediction.hostedmodels.predict<EOL>         * @desc Submit input and request an output against a hosted model.<EOL>         * @alias prediction.hostedmodels.predict<EOL>         * @memberOf! prediction(v1.4)<EOL>         *<EOL>         * @param {object} params Parameters for request<EOL>         * @param {string} params.hostedModelName The name of a hosted model.<EOL>         * @param {prediction(v1.4).Input} params.resource Request body data<EOL>         * @param {object} [options] Optionally override request options, such as `url`, `method`, and `encoding`.<EOL>         * @param {callback} callback The callback that handles the response.<EOL>         * @return {object} Request object<EOL>         */<EOL>        predict(params, options, callback) {<EOL>            if (typeof options === '<STR_LIT>') {<EOL>                callback = options;<EOL>                options = {};<EOL>            }<EOL>            options = options || {};<EOL>            const rootUrl = options.rootUrl || '<STR_LIT>';<EOL>            const parameters = {<EOL>                options: Object.assign({<EOL>                    url: (rootUrl +<EOL>                        '<STR_LIT>')<EOL>                        .replace(/([^:]\\/)\\/+/g, '<STR_LIT>'),<EOL>                    method: '<STR_LIT>'<EOL>                }, options),<EOL>                params,<EOL>                requiredParams: ['<STR_LIT>'],<EOL>                pathParams: ['<STR_LIT>'],<EOL>                context: self<EOL>            };<EOL>            return createAPIRequest(parameters, callback);<EOL>        }<EOL>    };<EOL>    self.trainedmodels = {<EOL>        /**<EOL>         * prediction.trainedmodels.delete<EOL>         * @desc Delete a trained model.<EOL>         * @alias prediction.trainedmodels.delete<EOL>         * @memberOf! prediction(v1.4)<EOL>         *<EOL>         * @param {object} params Parameters for request<EOL>         * @param {string} params.id The unique name for the predictive model.<EOL>         * @param {object} [options] Optionally override request options, such as `url`, `method`, and `encoding`.<EOL>         * @param {callback} callback The callback that handles the response.<EOL>         * @return {object} Request object<EOL>         */<EOL>        delete(params, options, callback) {<EOL>            if (typeof options === '<STR_LIT>') {<EOL>                callback = options;<EOL>                options = {};<EOL>            }<EOL>            options = options || {};<EOL>            const rootUrl = options.rootUrl || '<STR_LIT>';<EOL>            const parameters = {<EOL>                options: Object.assign({<EOL>                    url: (rootUrl + '<STR_LIT>')<EOL>                        .replace(/([^:]\\/)\\/+/g, '<STR_LIT>'),<EOL>                    method: '<STR_LIT>'<EOL>                }, options),<EOL>                params,<EOL>                requiredParams: ['<STR_LIT>'],<EOL>                pathParams: ['<STR_LIT>'],<EOL>                context: self<EOL>            };<EOL>            return createAPIRequest(parameters, callback);<EOL>        },<EOL>        get(params, options, callback) {<EOL>            if (typeof options === '<STR_LIT>') {<EOL>                callback = options;<EOL>                options = {};<EOL>            }<EOL>            options = options || {};<EOL>            const rootUrl = options.rootUrl || '<STR_LIT>';<EOL>            const parameters = {<EOL>                options: Object.assign({<EOL>                    url: (rootUrl + '<STR_LIT>')<EOL>                        .replace(/([^:]\\/)\\/+/g, '<STR_LIT>'),<EOL>                    method: '<STR_LIT>'<EOL>                }, options),<EOL>                params,<EOL>                requiredParams: ['<STR_LIT>'],<EOL>                pathParams: ['<STR_LIT>'],<EOL>                context: self<EOL>            };<EOL>            return createAPIRequest(parameters, callback);<EOL>        },<EOL>        insert(params, options, callback) {<EOL>            if (typeof options === '<STR_LIT>') {<EOL>                callback = options;<EOL>                options = {};<EOL>            }<EOL>            options = options || {};<EOL>            const rootUrl = options.rootUrl || '<STR_LIT>';<EOL>            const parameters = {<EOL>                options: Object.assign({<EOL>                    url: (rootUrl + '<STR_LIT>')<EOL>                        .replace(/([^:]\\/)\\/+/g, '<STR_LIT>'),<EOL>                    method: '<STR_LIT>'<EOL>                }, options),<EOL>                params,<EOL>                requiredParams: [],<EOL>                pathParams: [],<EOL>                context: self<EOL>            };<EOL>            return createAPIRequest(parameters, callback);<EOL>        },<EOL>        predict(params, options, callback) {<EOL>            if (typeof options === '<STR_LIT>') {<EOL>                callback = options;<EOL>                options = {};<EOL>            }<EOL>            options = options || {};<EOL>            const rootUrl = options.rootUrl || '<STR_LIT>';<EOL>            const parameters = {<EOL>                options: Object.assign({<EOL>                    url: (rootUrl + '<STR_LIT>')<EOL>                        .replace(/([^:]\\/)\\/+/g, '<STR_LIT>'),<EOL>                    method: '<STR_LIT>'<EOL>                }, options),<EOL>                params,<EOL>                requiredParams: ['<STR_LIT>'],<EOL>                pathParams: ['<STR_LIT>'],<EOL>                context: self<EOL>            };<EOL>            return createAPIRequest(parameters, callback);<EOL>        },<EOL>        update(params, options, callback) {<EOL>            if (typeof options === '<STR_LIT>') {<EOL>                callback = options;<EOL>                options = {};<EOL>            }<EOL>            options = options || {};<EOL>            const rootUrl = options.","gt":"rootUrl || '<STR_LIT>';"}
{"input":"<s> /**<EOL> * Prediction API<EOL> *<EOL> * Lets you access a cloud hosted machine learning service that makes it easy to<EOL> * build smart apps<EOL> *<EOL> * @example<EOL> * const google = require('googleapis');<EOL> * const prediction = google.prediction('v1.4');<EOL> *<EOL> * @namespace prediction<EOL> * @type {Function}<EOL> * @version v1.4<EOL> * @variation v1.4<EOL> * @param {object=} options Options for Prediction<EOL> */<EOL>function Prediction(options) {<EOL>    const self = this;<EOL>    self._options = options || {};<EOL>    self.hostedmodels = {<EOL>        /**<EOL>         * prediction.hostedmodels.predict<EOL>         * @desc Submit input and request an output against a hosted model.<EOL>         * @alias prediction.hostedmodels.predict<EOL>         * @memberOf! prediction(v1.4)<EOL>         *<EOL>         * @param {object} params Parameters for request<EOL>         * @param {string} params.hostedModelName The name of a hosted model.<EOL>         * @param {prediction(v1.4).Input} params.resource Request body data<EOL>         * @param {object} [options] Optionally override request options, such as `url`, `method`, and `encoding`.<EOL>         * @param {callback} callback The callback that handles the response.<EOL>         * @return {object} Request object<EOL>         */<EOL>        predict(params, options, callback) {<EOL>            if (typeof options === '<STR_LIT>') {<EOL>                callback = options;<EOL>                options = {};<EOL>            }<EOL>            options = options || {};<EOL>            const rootUrl = options.rootUrl || '<STR_LIT>';<EOL>            const parameters = {<EOL>                options: Object.assign({<EOL>                    url: (rootUrl +<EOL>                        '<STR_LIT>')<EOL>                        .replace(/([^:]\\/)\\/+/g, '<STR_LIT>'),<EOL>                    method: '<STR_LIT>'<EOL>                }, options),<EOL>                params,<EOL>                requiredParams: ['<STR_LIT>'],<EOL>                pathParams: ['<STR_LIT>'],<EOL>                context: self<EOL>            };<EOL>            return createAPIRequest(parameters, callback);<EOL>        }<EOL>    };<EOL>    self.trainedmodels = {<EOL>        /**<EOL>         * prediction.trainedmodels.delete<EOL>         * @desc Delete a trained model.<EOL>         * @alias prediction.trainedmodels.delete<EOL>         * @memberOf! prediction(v1.4)<EOL>         *<EOL>         * @param {object} params Parameters for request<EOL>         * @param {string} params.id The unique name for the predictive model.<EOL>         * @param {object} [options] Optionally override request options, such as `url`, `method`, and `encoding`.<EOL>         * @param {callback} callback The callback that handles the response.<EOL>         * @return {object} Request object<EOL>         */<EOL>        delete(params, options, callback) {<EOL>            if (typeof options === '<STR_LIT>') {<EOL>                callback = options;<EOL>                options = {};<EOL>            }<EOL>            options = options || {};<EOL>            const rootUrl = options.rootUrl || '<STR_LIT>';<EOL>            const parameters = {<EOL>                options: Object.assign({<EOL>                    url: (rootUrl + '<STR_LIT>')<EOL>                        .replace(/([^:]\\/)\\/+/g, '<STR_LIT>'),<EOL>                    method: '<STR_LIT>'<EOL>                }, options),<EOL>                params,<EOL>                requiredParams: ['<STR_LIT>'],<EOL>                pathParams: ['<STR_LIT>'],<EOL>                context: self<EOL>            };<EOL>            return createAPIRequest(parameters, callback);<EOL>        },<EOL>        get(params, options, callback) {<EOL>            if (typeof options === '<STR_LIT>') {<EOL>                callback = options;<EOL>                options = {};<EOL>            }<EOL>            options = options || {};<EOL>            const rootUrl = options.rootUrl || '<STR_LIT>';<EOL>            const parameters = {<EOL>                options: Object.assign({<EOL>                    url: (rootUrl + '<STR_LIT>')<EOL>                        .replace(/([^:]\\/)\\/+/g, '<STR_LIT>'),<EOL>                    method: '<STR_LIT>'<EOL>                }, options),<EOL>                params,<EOL>                requiredParams: ['<STR_LIT>'],<EOL>                pathParams: ['<STR_LIT>'],<EOL>                context: self<EOL>            };<EOL>            return createAPIRequest(parameters, callback);<EOL>        },<EOL>        insert(params, options, callback) {<EOL>            if (typeof options === '<STR_LIT>') {<EOL>                callback = options;<EOL>                options = {};<EOL>            }<EOL>            options = options || {};<EOL>            const rootUrl = options.rootUrl || '<STR_LIT>';<EOL>            const parameters = {<EOL>                options: Object.assign({<EOL>                    url: (rootUrl + '<STR_LIT>')<EOL>                        .replace(/([^:]\\/)\\/+/g, '<STR_LIT>'),<EOL>                    method: '<STR_LIT>'<EOL>                }, options),<EOL>                params,<EOL>                requiredParams: [],<EOL>                pathParams: [],<EOL>                context: self<EOL>            };<EOL>            return createAPIRequest(parameters, callback);<EOL>        },<EOL>        predict(params, options, callback) {<EOL>            if (typeof options === '<STR_LIT>') {<EOL>                callback = options;<EOL>                options = {};<EOL>            }<EOL>            options = options || {};<EOL>            const rootUrl = options.rootUrl || '<STR_LIT>';<EOL>            const parameters = {<EOL>                options: Object.assign({<EOL>                    url: (rootUrl + '<STR_LIT>')<EOL>                        .replace(/([^:]\\/)\\/+/g, '<STR_LIT>'),<EOL>                    method: '<STR_LIT>'<EOL>                }, options),<EOL>                params,<EOL>                requiredParams: ['<STR_LIT>'],<EOL>                pathParams: ['<STR_LIT>'],<EOL>                context: self<EOL>            };<EOL>            return createAPIRequest(parameters, callback);<EOL>        },<EOL>        update(params, options, callback) {<EOL>            if (typeof options === '<STR_LIT>') {<EOL>                callback = options;<EOL>                options = {};<EOL>            }<EOL>            options = options || {};<EOL>            const rootUrl = options.rootUrl || '<STR_LIT>';<EOL>            const parameters = {<EOL>                options: Object.assign({<EOL>                    url: (rootUrl +","gt":"'<STR_LIT>')"}
{"input":"<s> export function firstValue<K, V, U>(map: SortedMapStructure<K, V, U>): V | undefined {<EOL>    const item = getFirstItem(map.","gt":"_sorted);"}
{"input":"<s> /**<EOL> * @overview create reducer from the object, with creating reducing functions<EOL> * @param  {Any} initialState – initial state of this part of the store<EOL> * @param  {Object} handlers – object with keys as action types, and<EOL> * newValues to set at store as values<EOL> * @return {Function} – function to act as a reducer<EOL> */<EOL>export function createReducer(initialState: any, handlers: ReducerObject): Reducer<any> {<EOL>    return createReducerFromObject(initialState, mapValues(handlers, (value: any) => (state: any, action: Action): any => reducerCreator({<EOL>","gt":"state,"}
{"input":"<s> /**<EOL> * Could be called ends with :)<EOL> */<EOL>export function isExt(path: string, ext: string): boolean {<EOL>    return path && ext && path.indexOf(ext, path.","gt":"length - ext.length) !== -<NUM_LIT>;"}
{"input":"<s> export function generateModuleSource(stylableResult: StylableResults, moduleId: string, beforeModule: string[], renderer: string, createFunction: string, createRenderableFunction: string, css: string, depth: string, exportsArgument: string, afterModule: string, renderableOnly = false): string {<EOL>    const { exports, meta } = stylableResult;<EOL>    const localsExports = JSON.stringify(exports);<EOL>    const namespace = JSON.","gt":"stringify(meta.namespace);"}
{"input":"<s> export function set<T>(index: number, value: T, list: ListStructure<T>): ListStructure<T> {<EOL>","gt":"list = modify(list);"}
{"input":"<s> /**<EOL> * Determines if the specified string consists entirely of numeric characters.<EOL> */<EOL>function isNumeric(input) {<EOL>","gt":"return input !== undefined"}
{"input":"<s> export function total(...numbers: number[]) {<EOL>    return numbers.reduce((","gt":"a, b) => a + b);"}
{"input":"<s> function factoryMethod<T>(defaults: () => T) {<EOL>","gt":"return (overrides?: Partial<T>) => Object.assign({}, defaults(), overrides);"}
{"input":"<s> function supportMediaQuery() {<EOL>    const _global = typeof window === '<STR_LIT>' && window || typeof self === '<STR_LIT>' &&","gt":"self || global;"}
{"input":"<s> export function configureTestingModule(mock: ReactNativeWrapper, testCpt: any, declarations: Array<any> = [], modules: Array<any> = []): typeof TestBed {<EOL>    const tb = TestBed.configureTestingModule({<EOL>        imports: [ReactNativeAndroidModule].concat(modules),<EOL>        providers: getTestingProviders(","gt":"mock, testCpt),"}
{"input":"<s> export function render(text: string, rL: boolean) {<EOL>    if (needsInit(rL)) {<EOL>        init(","gt":"rL);"}
{"input":"<s> /**<EOL> * Helper method to create a SPList Picker on the PropertyPane.<EOL> * @param targetProperty - Target property the SharePoint list picker is associated to.<EOL> * @param properties - Strongly typed SPList Picker properties.<EOL> */<EOL>export function PropertyFieldListPicker(targetProperty: string, properties: IPropertyFieldListPickerProps): IPropertyPaneField<IPropertyFieldListPickerPropsInternal> {<EOL>    <EOL>    const newProperties: IPropertyFieldListPickerPropsInternal = {<EOL>        label: properties.label,<EOL>        targetProperty: targetProperty,<EOL>        context: properties.","gt":"context,"}
{"input":"<s> /**<EOL> * Helper method to create a SPList Picker on the PropertyPane.<EOL> * @param targetProperty - Target property the SharePoint list picker is associated to.<EOL> * @param properties - Strongly typed SPList Picker properties.<EOL> */<EOL>export function PropertyFieldListPicker(targetProperty: string, properties: IPropertyFieldListPickerProps): IPropertyPaneField<IPropertyFieldListPickerPropsInternal> {<EOL>    <EOL>    const newProperties: IPropertyFieldListPickerPropsInternal = {<EOL>        label: properties.label,<EOL>        targetProperty: targetProperty,<EOL>        context: properties.context,<EOL>        selectedList: typeof properties.selectedList === '<STR_LIT>' ? properties.selectedList : null,<EOL>        selectedLists: typeof properties.selectedList !== '<STR_LIT>' ? properties.selectedList : null,<EOL>        baseTemplate: properties.","gt":"baseTemplate,"}
{"input":"<s> /**<EOL> * Helper method to create a SPList Picker on the PropertyPane.<EOL> * @param targetProperty - Target property the SharePoint list picker is associated to.<EOL> * @param properties - Strongly typed SPList Picker properties.<EOL> */<EOL>export function PropertyFieldListPicker(targetProperty: string, properties: IPropertyFieldListPickerProps): IPropertyPaneField<IPropertyFieldListPickerPropsInternal> {<EOL>    <EOL>    const newProperties: IPropertyFieldListPickerPropsInternal = {<EOL>        label: properties.label,<EOL>        targetProperty: targetProperty,<EOL>        context: properties.context,<EOL>        selectedList: typeof properties.selectedList === '<STR_LIT>' ? properties.selectedList : null,<EOL>        selectedLists: typeof properties.selectedList !== '<STR_LIT>' ? properties.selectedList : null,<EOL>        baseTemplate: properties.baseTemplate,<EOL>        orderBy: properties.orderBy,<EOL>        multiSelect: properties.multiSelect || false,<EOL>        includeHidden: properties.includeHidden,<EOL>        onPropertyChange: properties.onPropertyChange,<EOL>        properties: properties.","gt":"properties,"}
{"input":"<s> /**<EOL> * Helper method to create a SPList Picker on the PropertyPane.<EOL> * @param targetProperty - Target property the SharePoint list picker is associated to.<EOL> * @param properties - Strongly typed SPList Picker properties.<EOL> */<EOL>export function PropertyFieldListPicker(targetProperty: string, properties: IPropertyFieldListPickerProps): IPropertyPaneField<IPropertyFieldListPickerPropsInternal> {<EOL>    <EOL>    const newProperties: IPropertyFieldListPickerPropsInternal = {<EOL>        label: properties.label,<EOL>        targetProperty: targetProperty,<EOL>        context: properties.context,<EOL>        selectedList: typeof properties.selectedList === '<STR_LIT>' ? properties.selectedList : null,<EOL>        selectedLists: typeof properties.selectedList !== '<STR_LIT>' ? properties.selectedList : null,<EOL>        baseTemplate: properties.baseTemplate,<EOL>        orderBy: properties.orderBy,<EOL>        multiSelect: properties.multiSelect || false,<EOL>        includeHidden: properties.includeHidden,<EOL>        onPropertyChange: properties.onPropertyChange,<EOL>        properties: properties.properties,<EOL>        onDispose: null,<EOL>        onRender: null,<EOL>        key: properties.key,<EOL>        disabled: properties.disabled,<EOL>        onGetErrorMessage:","gt":"properties.onGetErrorMessage,"}
{"input":"<s> export function getCodeActions(model: IReadOnlyModel, range: Range): TPromise<CodeAction[]> {<EOL>    const allResults: CodeAction[] = [];<EOL>    const promises = CodeActionProviderRegistry.all(model).map(support => {<EOL>        return asWinJsPromise(token => support.provideCodeActions(model, range, token)).then(result => {<EOL>            if (Array.isArray(result)) {<EOL>                for (const quickFix of","gt":"result) {"}
{"input":"<s> export function getCodeActions(model: IReadOnlyModel, range: Range): TPromise<CodeAction[]> {<EOL>    const allResults: CodeAction[] = [];<EOL>    const promises = CodeActionProviderRegistry.all(model).map(support => {<EOL>        return asWinJsPromise(token => support.provideCodeActions(model, range, token)).then(result => {<EOL>            if (Array.isArray(result)) {<EOL>                for (const quickFix of result) {<EOL>                    if (quickFix) {<EOL>                        allResults.push(quickFix);<EOL>                    }<EOL>                }<EOL>            }<EOL>        }, err => {<EOL>","gt":"onUnexpectedExternalError(err);"}
{"input":"<s> export function allowPreviousPlayerStylesMerge(duration: number, delay: number) {<EOL>    return duration === <NUM_LIT> ||","gt":"delay === <NUM_LIT>;"}
{"input":"<s> export function createMockInstance<T>(type: Constructor<T>) {<EOL>    return sinon.createStubInstance(","gt":"type) as Mock<T>;"}
{"input":"<s> export function isWillNotExecutedPayload(v: Payload): v is WillNotExecutedPayload {<EOL>    return v.","gt":"type === TYPE;"}
{"input":"<s> export default function applyMiddleware(...middleware: Middleware[]) {<EOL>    var next: DispatchFunction = finalDispatch;<EOL>    for (var i =","gt":"middleware.length - <NUM_LIT>; i >= <NUM_LIT>; i--) {"}
{"input":"<s> export function getStartAtObservable(query: Query): Observable<Primitive> {<EOL>    if (query.startAt instanceof Observable) {<EOL>        return query.startAt;<EOL>    }<EOL>    else","gt":"if (hasKey(query, '<STR_LIT>')) {"}
{"input":"<s> export function getStartAtObservable(query: Query): Observable<Primitive> {<EOL>    if (query.startAt instanceof Observable) {<EOL>        return query.startAt;<EOL>    }<EOL>    else if (hasKey(query, '<STR_LIT>')) {<EOL>        return new Observable<Primitive>(subscriber => {<EOL>            subscriber.next(query.startAt);<EOL>        });<EOL>    }<EOL>    else {<EOL>","gt":"return new Observable<Primitive>(subscriber => {"}
{"input":"<s> export function isWillExecutedPayload(v: Payload): v is WillExecutedPayload {<EOL>    return v.type ===","gt":"TYPE;"}
{"input":"<s> export function isDidExecutedPayload(v: Payload): v is DidExecutedPayload {<EOL>    return v.","gt":"type === TYPE;"}
{"input":"<s> function _exceptionHandler(): ExceptionHandler {<EOL>    return new ExceptionHandler(new","gt":"PrintLogger());"}
{"input":"<s> /** Creates a block element with a default size. */<EOL>function createBlockElement() {<EOL>    let element = document.createElement('<STR_LIT>');<EOL>    element.","gt":"style.width = `<STR_LIT>`;"}
{"input":"<s> function valueOf<T>(item: SortedSetItem<T>): T {<EOL>","gt":"return item.value;"}
{"input":"<s> /**<EOL> * Read the first line of stderr and return an error for display or undefined, based on a whitelist.<EOL> * Ripgrep produces stderr output which is not from a fatal error, and we only want the search to be<EOL> * \"failed\" when a fatal error was produced.<EOL> */<EOL>export function rgErrorMsgForDisplay(msg: string): string | undefined {<EOL>    const firstLine = msg.split('<STR_LIT>')[<NUM_LIT>];<EOL>    if (strings.startsWith(firstLine, '<STR_LIT>')) {<EOL>        return firstLine;<EOL>    }<EOL>    if (strings.startsWith(","gt":"firstLine, '<STR_LIT>') ||"}
{"input":"<s> /**<EOL> * Removes the specified key from the tree. If the key was not in the tree, no changes are made, and the original tree<EOL> * is returned.<EOL> *<EOL> * @export<EOL> * @template K The type of keys in the tree<EOL> * @template V The type of values in the tree<EOL> * @param {K} key The key of the entry to be removed<EOL> * @param {RedBlackTreeStructure<K, V>} tree The tree to be updated<EOL> * @returns {RedBlackTreeStructure<K, V>} An updated copy of the tree, or the same tree if the input tree was already mutable<EOL> */<EOL>export function remove<K, V = null>(key: K, tree: RedBlackTreeStructure<K, V>): RedBlackTreeStructure<K, V> {<EOL>    if (tree._size === <NUM_LIT>) {<EOL>        return tree;<EOL>    }<EOL>    var originalTree = tree;<EOL>    tree = C.modify(tree);<EOL>    C.modifyProperty(","gt":"tree, '<STR_LIT>');"}
{"input":"<s> /**<EOL> * Removes the specified key from the tree. If the key was not in the tree, no changes are made, and the original tree<EOL> * is returned.<EOL> *<EOL> * @export<EOL> * @template K The type of keys in the tree<EOL> * @template V The type of values in the tree<EOL> * @param {K} key The key of the entry to be removed<EOL> * @param {RedBlackTreeStructure<K, V>} tree The tree to be updated<EOL> * @returns {RedBlackTreeStructure<K, V>} An updated copy of the tree, or the same tree if the input tree was already mutable<EOL> */<EOL>export function remove<K, V = null>(key: K, tree: RedBlackTreeStructure<K, V>): RedBlackTreeStructure<K, V> {<EOL>    if (tree._size === <NUM_LIT>) {<EOL>        return tree;<EOL>    }<EOL>    var originalTree = tree;<EOL>    tree = C.modify(tree);<EOL>    C.modifyProperty(tree, '<STR_LIT>');<EOL>    var p: PathNode<K, V> = findPath(tree, key, tree._root, tree._compare);<EOL>    if (p.next !== BRANCH.NONE) {<EOL>        PathNode.release(p, tree._root);<EOL>        return originalTree;<EOL>    }<EOL>    if (tree._size === <NUM_LIT>) {<EOL>        PathNode.release(p,","gt":"tree._root);"}
{"input":"<s> /**<EOL> * Removes the specified key from the tree. If the key was not in the tree, no changes are made, and the original tree<EOL> * is returned.<EOL> *<EOL> * @export<EOL> * @template K The type of keys in the tree<EOL> * @template V The type of values in the tree<EOL> * @param {K} key The key of the entry to be removed<EOL> * @param {RedBlackTreeStructure<K, V>} tree The tree to be updated<EOL> * @returns {RedBlackTreeStructure<K, V>} An updated copy of the tree, or the same tree if the input tree was already mutable<EOL> */<EOL>export function remove<K, V = null>(key: K, tree: RedBlackTreeStructure<K, V>): RedBlackTreeStructure<K, V> {<EOL>    if (tree._size === <NUM_LIT>) {<EOL>        return tree;<EOL>    }<EOL>    var originalTree = tree;<EOL>    tree = C.modify(tree);<EOL>    C.modifyProperty(tree, '<STR_LIT>');<EOL>    var p: PathNode<K, V> = findPath(tree, key, tree._root, tree._compare);<EOL>    if (p.next !== BRANCH.NONE) {<EOL>        PathNode.release(p, tree._root);<EOL>        return originalTree;<EOL>    }<EOL>    if (tree._size === <NUM_LIT>) {<EOL>        PathNode.release(p, tree._root);<EOL>        if (tree !== originalTree) {<EOL>            return createTree<K, V>(tree._compare);<EOL>        }<EOL>        tree._size = <NUM_LIT>;<EOL>","gt":"tree._root = NONE;"}
{"input":"<s> /**<EOL> * Removes the specified key from the tree. If the key was not in the tree, no changes are made, and the original tree<EOL> * is returned.<EOL> *<EOL> * @export<EOL> * @template K The type of keys in the tree<EOL> * @template V The type of values in the tree<EOL> * @param {K} key The key of the entry to be removed<EOL> * @param {RedBlackTreeStructure<K, V>} tree The tree to be updated<EOL> * @returns {RedBlackTreeStructure<K, V>} An updated copy of the tree, or the same tree if the input tree was already mutable<EOL> */<EOL>export function remove<K, V = null>(key: K, tree: RedBlackTreeStructure<K, V>): RedBlackTreeStructure<K, V> {<EOL>    if (tree._size === <NUM_LIT>) {<EOL>        return tree;<EOL>    }<EOL>    var originalTree = tree;<EOL>    tree = C.modify(tree);<EOL>    C.modifyProperty(tree, '<STR_LIT>');<EOL>    var p: PathNode<K, V> = findPath(tree, key, tree._root, tree._compare);<EOL>    if (p.next !== BRANCH.NONE) {<EOL>        PathNode.release(p, tree._root);<EOL>        return originalTree;<EOL>    }<EOL>    if (tree._size === <NUM_LIT>) {<EOL>        PathNode.release(p, tree._root);<EOL>        if (tree !== originalTree) {<EOL>            return createTree<K, V>(tree._compare);<EOL>        }<EOL>        tree._size = <NUM_LIT>;<EOL>        tree._root = NONE;<EOL>        return tree;<EOL>    }<EOL>    var current = p.node;<EOL>    var hasRight = !isNone(","gt":"current._right);"}
{"input":"<s> /**<EOL> * Removes the specified key from the tree. If the key was not in the tree, no changes are made, and the original tree<EOL> * is returned.<EOL> *<EOL> * @export<EOL> * @template K The type of keys in the tree<EOL> * @template V The type of values in the tree<EOL> * @param {K} key The key of the entry to be removed<EOL> * @param {RedBlackTreeStructure<K, V>} tree The tree to be updated<EOL> * @returns {RedBlackTreeStructure<K, V>} An updated copy of the tree, or the same tree if the input tree was already mutable<EOL> */<EOL>export function remove<K, V = null>(key: K, tree: RedBlackTreeStructure<K, V>): RedBlackTreeStructure<K, V> {<EOL>    if (tree._size === <NUM_LIT>) {<EOL>        return tree;<EOL>    }<EOL>    var originalTree = tree;<EOL>    tree = C.modify(tree);<EOL>    C.modifyProperty(tree, '<STR_LIT>');<EOL>    var p: PathNode<K, V> = findPath(tree, key, tree._root, tree._compare);<EOL>    if (p.next !== BRANCH.NONE) {<EOL>        PathNode.release(p, tree._root);<EOL>        return originalTree;<EOL>    }<EOL>    if (tree._size === <NUM_LIT>) {<EOL>        PathNode.release(p, tree._root);<EOL>        if (tree !== originalTree) {<EOL>            return createTree<K, V>(tree._compare);<EOL>        }<EOL>        tree._size = <NUM_LIT>;<EOL>        tree._root = NONE;<EOL>        return tree;<EOL>    }<EOL>    var current = p.node;<EOL>    var hasRight = !isNone(current._right);<EOL>    var hasLeft = !isNone(current._left);<EOL>    var debt = <NUM_LIT>;<EOL>    if (hasRight || hasLeft) {<EOL>        if (hasRight) {<EOL>            if (hasLeft) {<EOL>                p =","gt":"findSuccessor(tree, p);"}
{"input":"<s> /**<EOL> * Removes the specified key from the tree. If the key was not in the tree, no changes are made, and the original tree<EOL> * is returned.<EOL> *<EOL> * @export<EOL> * @template K The type of keys in the tree<EOL> * @template V The type of values in the tree<EOL> * @param {K} key The key of the entry to be removed<EOL> * @param {RedBlackTreeStructure<K, V>} tree The tree to be updated<EOL> * @returns {RedBlackTreeStructure<K, V>} An updated copy of the tree, or the same tree if the input tree was already mutable<EOL> */<EOL>export function remove<K, V = null>(key: K, tree: RedBlackTreeStructure<K, V>): RedBlackTreeStructure<K, V> {<EOL>    if (tree._size === <NUM_LIT>) {<EOL>        return tree;<EOL>    }<EOL>    var originalTree = tree;<EOL>    tree = C.modify(tree);<EOL>    C.modifyProperty(tree, '<STR_LIT>');<EOL>    var p: PathNode<K, V> = findPath(tree, key, tree._root, tree._compare);<EOL>    if (p.next !== BRANCH.NONE) {<EOL>        PathNode.release(p, tree._root);<EOL>        return originalTree;<EOL>    }<EOL>    if (tree._size === <NUM_LIT>) {<EOL>        PathNode.release(p, tree._root);<EOL>        if (tree !== originalTree) {<EOL>            return createTree<K, V>(tree._compare);<EOL>        }<EOL>        tree._size = <NUM_LIT>;<EOL>        tree._root = NONE;<EOL>        return tree;<EOL>    }<EOL>    var current = p.node;<EOL>    var hasRight = !isNone(current._right);<EOL>    var hasLeft = !isNone(current._left);<EOL>    var debt = <NUM_LIT>;<EOL>    if (hasRight || hasLeft) {<EOL>        if (hasRight) {<EOL>            if (hasLeft) {<EOL>                p = findSuccessor(tree, p);<EOL>                swapNodeContents(p.node, current);<EOL>                current =","gt":"p.node;"}
{"input":"<s> /**<EOL> * Removes the specified key from the tree. If the key was not in the tree, no changes are made, and the original tree<EOL> * is returned.<EOL> *<EOL> * @export<EOL> * @template K The type of keys in the tree<EOL> * @template V The type of values in the tree<EOL> * @param {K} key The key of the entry to be removed<EOL> * @param {RedBlackTreeStructure<K, V>} tree The tree to be updated<EOL> * @returns {RedBlackTreeStructure<K, V>} An updated copy of the tree, or the same tree if the input tree was already mutable<EOL> */<EOL>export function remove<K, V = null>(key: K, tree: RedBlackTreeStructure<K, V>): RedBlackTreeStructure<K, V> {<EOL>    if (tree._size === <NUM_LIT>) {<EOL>        return tree;<EOL>    }<EOL>    var originalTree = tree;<EOL>    tree = C.modify(tree);<EOL>    C.modifyProperty(tree, '<STR_LIT>');<EOL>    var p: PathNode<K, V> = findPath(tree, key, tree._root, tree._compare);<EOL>    if (p.next !== BRANCH.NONE) {<EOL>        PathNode.release(p, tree._root);<EOL>        return originalTree;<EOL>    }<EOL>    if (tree._size === <NUM_LIT>) {<EOL>        PathNode.release(p, tree._root);<EOL>        if (tree !== originalTree) {<EOL>            return createTree<K, V>(tree._compare);<EOL>        }<EOL>        tree._size = <NUM_LIT>;<EOL>        tree._root = NONE;<EOL>        return tree;<EOL>    }<EOL>    var current = p.node;<EOL>    var hasRight = !isNone(current._right);<EOL>    var hasLeft = !isNone(current._left);<EOL>    var debt = <NUM_LIT>;<EOL>    if (hasRight || hasLeft) {<EOL>        if (hasRight) {<EOL>            if (hasLeft) {<EOL>                p = findSuccessor(tree, p);<EOL>                swapNodeContents(p.node, current);<EOL>                current = p.node;<EOL>            }<EOL>            debt = current._red ? <NUM_LIT> : <NUM_LIT>;<EOL>            current = editRightChild(tree, current);<EOL>        }<EOL>        else if (hasLeft) {<EOL>            debt = current._red ? <NUM_LIT> : <NUM_LIT>;<EOL>","gt":"current = editLeftChild(tree, current);"}
{"input":"<s> /**<EOL> * Removes the specified key from the tree. If the key was not in the tree, no changes are made, and the original tree<EOL> * is returned.<EOL> *<EOL> * @export<EOL> * @template K The type of keys in the tree<EOL> * @template V The type of values in the tree<EOL> * @param {K} key The key of the entry to be removed<EOL> * @param {RedBlackTreeStructure<K, V>} tree The tree to be updated<EOL> * @returns {RedBlackTreeStructure<K, V>} An updated copy of the tree, or the same tree if the input tree was already mutable<EOL> */<EOL>export function remove<K, V = null>(key: K, tree: RedBlackTreeStructure<K, V>): RedBlackTreeStructure<K, V> {<EOL>    if (tree._size === <NUM_LIT>) {<EOL>        return tree;<EOL>    }<EOL>    var originalTree = tree;<EOL>    tree = C.modify(tree);<EOL>    C.modifyProperty(tree, '<STR_LIT>');<EOL>    var p: PathNode<K, V> = findPath(tree, key, tree._root, tree._compare);<EOL>    if (p.next !== BRANCH.NONE) {<EOL>        PathNode.release(p, tree._root);<EOL>        return originalTree;<EOL>    }<EOL>    if (tree._size === <NUM_LIT>) {<EOL>        PathNode.release(p, tree._root);<EOL>        if (tree !== originalTree) {<EOL>            return createTree<K, V>(tree._compare);<EOL>        }<EOL>        tree._size = <NUM_LIT>;<EOL>        tree._root = NONE;<EOL>        return tree;<EOL>    }<EOL>    var current = p.node;<EOL>    var hasRight = !isNone(current._right);<EOL>    var hasLeft = !isNone(current._left);<EOL>    var debt = <NUM_LIT>;<EOL>    if (hasRight || hasLeft) {<EOL>        if (hasRight) {<EOL>            if (hasLeft) {<EOL>                p = findSuccessor(tree, p);<EOL>                swapNodeContents(p.node, current);<EOL>                current = p.node;<EOL>            }<EOL>            debt = current._red ? <NUM_LIT> : <NUM_LIT>;<EOL>            current = editRightChild(tree, current);<EOL>        }<EOL>        else if (hasLeft) {<EOL>            debt = current._red ? <NUM_LIT> : <NUM_LIT>;<EOL>            current = editLeftChild(tree, current);<EOL>        }<EOL>    }<EOL>    else {<EOL>        debt = current._red ? <NUM_LIT> : <NUM_LIT>;<EOL>","gt":"current = NONE;"}
{"input":"<s> /**<EOL> * Removes the specified key from the tree. If the key was not in the tree, no changes are made, and the original tree<EOL> * is returned.<EOL> *<EOL> * @export<EOL> * @template K The type of keys in the tree<EOL> * @template V The type of values in the tree<EOL> * @param {K} key The key of the entry to be removed<EOL> * @param {RedBlackTreeStructure<K, V>} tree The tree to be updated<EOL> * @returns {RedBlackTreeStructure<K, V>} An updated copy of the tree, or the same tree if the input tree was already mutable<EOL> */<EOL>export function remove<K, V = null>(key: K, tree: RedBlackTreeStructure<K, V>): RedBlackTreeStructure<K, V> {<EOL>    if (tree._size === <NUM_LIT>) {<EOL>        return tree;<EOL>    }<EOL>    var originalTree = tree;<EOL>    tree = C.modify(tree);<EOL>    C.modifyProperty(tree, '<STR_LIT>');<EOL>    var p: PathNode<K, V> = findPath(tree, key, tree._root, tree._compare);<EOL>    if (p.next !== BRANCH.NONE) {<EOL>        PathNode.release(p, tree._root);<EOL>        return originalTree;<EOL>    }<EOL>    if (tree._size === <NUM_LIT>) {<EOL>        PathNode.release(p, tree._root);<EOL>        if (tree !== originalTree) {<EOL>            return createTree<K, V>(tree._compare);<EOL>        }<EOL>        tree._size = <NUM_LIT>;<EOL>        tree._root = NONE;<EOL>        return tree;<EOL>    }<EOL>    var current = p.node;<EOL>    var hasRight = !isNone(current._right);<EOL>    var hasLeft = !isNone(current._left);<EOL>    var debt = <NUM_LIT>;<EOL>    if (hasRight || hasLeft) {<EOL>        if (hasRight) {<EOL>            if (hasLeft) {<EOL>                p = findSuccessor(tree, p);<EOL>                swapNodeContents(p.node, current);<EOL>                current = p.node;<EOL>            }<EOL>            debt = current._red ? <NUM_LIT> : <NUM_LIT>;<EOL>            current = editRightChild(tree, current);<EOL>        }<EOL>        else if (hasLeft) {<EOL>            debt = current._red ? <NUM_LIT> : <NUM_LIT>;<EOL>            current = editLeftChild(tree, current);<EOL>        }<EOL>    }<EOL>    else {<EOL>        debt = current._red ? <NUM_LIT> : <NUM_LIT>;<EOL>        current = NONE;<EOL>    }<EOL>    if (p.parent.isNone()) {<EOL>        tree.","gt":"_root = current;"}
{"input":"<s> /**<EOL> * Removes the specified key from the tree. If the key was not in the tree, no changes are made, and the original tree<EOL> * is returned.<EOL> *<EOL> * @export<EOL> * @template K The type of keys in the tree<EOL> * @template V The type of values in the tree<EOL> * @param {K} key The key of the entry to be removed<EOL> * @param {RedBlackTreeStructure<K, V>} tree The tree to be updated<EOL> * @returns {RedBlackTreeStructure<K, V>} An updated copy of the tree, or the same tree if the input tree was already mutable<EOL> */<EOL>export function remove<K, V = null>(key: K, tree: RedBlackTreeStructure<K, V>): RedBlackTreeStructure<K, V> {<EOL>    if (tree._size === <NUM_LIT>) {<EOL>        return tree;<EOL>    }<EOL>    var originalTree = tree;<EOL>    tree = C.modify(tree);<EOL>    C.modifyProperty(tree, '<STR_LIT>');<EOL>    var p: PathNode<K, V> = findPath(tree, key, tree._root, tree._compare);<EOL>    if (p.next !== BRANCH.NONE) {<EOL>        PathNode.release(p, tree._root);<EOL>        return originalTree;<EOL>    }<EOL>    if (tree._size === <NUM_LIT>) {<EOL>        PathNode.release(p, tree._root);<EOL>        if (tree !== originalTree) {<EOL>            return createTree<K, V>(tree._compare);<EOL>        }<EOL>        tree._size = <NUM_LIT>;<EOL>        tree._root = NONE;<EOL>        return tree;<EOL>    }<EOL>    var current = p.node;<EOL>    var hasRight = !isNone(current._right);<EOL>    var hasLeft = !isNone(current._left);<EOL>    var debt = <NUM_LIT>;<EOL>    if (hasRight || hasLeft) {<EOL>        if (hasRight) {<EOL>            if (hasLeft) {<EOL>                p = findSuccessor(tree, p);<EOL>                swapNodeContents(p.node, current);<EOL>                current = p.node;<EOL>            }<EOL>            debt = current._red ? <NUM_LIT> : <NUM_LIT>;<EOL>            current = editRightChild(tree, current);<EOL>        }<EOL>        else if (hasLeft) {<EOL>            debt = current._red ? <NUM_LIT> : <NUM_LIT>;<EOL>            current = editLeftChild(tree, current);<EOL>        }<EOL>    }<EOL>    else {<EOL>        debt = current._red ? <NUM_LIT> : <NUM_LIT>;<EOL>        current = NONE;<EOL>    }<EOL>    if (p.parent.isNone()) {<EOL>        tree._root = current;<EOL>    }<EOL>    p.replace(current);<EOL>    if (current._red && p.parent.node._red) {<EOL>        current._red = false;<EOL>        debt = <NUM_LIT>;<EOL>    }<EOL>    if (","gt":"debt > <NUM_LIT>) {"}
{"input":"<s> /**<EOL> * Removes the specified key from the tree. If the key was not in the tree, no changes are made, and the original tree<EOL> * is returned.<EOL> *<EOL> * @export<EOL> * @template K The type of keys in the tree<EOL> * @template V The type of values in the tree<EOL> * @param {K} key The key of the entry to be removed<EOL> * @param {RedBlackTreeStructure<K, V>} tree The tree to be updated<EOL> * @returns {RedBlackTreeStructure<K, V>} An updated copy of the tree, or the same tree if the input tree was already mutable<EOL> */<EOL>export function remove<K, V = null>(key: K, tree: RedBlackTreeStructure<K, V>): RedBlackTreeStructure<K, V> {<EOL>    if (tree._size === <NUM_LIT>) {<EOL>        return tree;<EOL>    }<EOL>    var originalTree = tree;<EOL>    tree = C.modify(tree);<EOL>    C.modifyProperty(tree, '<STR_LIT>');<EOL>    var p: PathNode<K, V> = findPath(tree, key, tree._root, tree._compare);<EOL>    if (p.next !== BRANCH.NONE) {<EOL>        PathNode.release(p, tree._root);<EOL>        return originalTree;<EOL>    }<EOL>    if (tree._size === <NUM_LIT>) {<EOL>        PathNode.release(p, tree._root);<EOL>        if (tree !== originalTree) {<EOL>            return createTree<K, V>(tree._compare);<EOL>        }<EOL>        tree._size = <NUM_LIT>;<EOL>        tree._root = NONE;<EOL>        return tree;<EOL>    }<EOL>    var current = p.node;<EOL>    var hasRight = !isNone(current._right);<EOL>    var hasLeft = !isNone(current._left);<EOL>    var debt = <NUM_LIT>;<EOL>    if (hasRight || hasLeft) {<EOL>        if (hasRight) {<EOL>            if (hasLeft) {<EOL>                p = findSuccessor(tree, p);<EOL>                swapNodeContents(p.node, current);<EOL>                current = p.node;<EOL>            }<EOL>            debt = current._red ? <NUM_LIT> : <NUM_LIT>;<EOL>            current = editRightChild(tree, current);<EOL>        }<EOL>        else if (hasLeft) {<EOL>            debt = current._red ? <NUM_LIT> : <NUM_LIT>;<EOL>            current = editLeftChild(tree, current);<EOL>        }<EOL>    }<EOL>    else {<EOL>        debt = current._red ? <NUM_LIT> : <NUM_LIT>;<EOL>        current = NONE;<EOL>    }<EOL>    if (p.parent.isNone()) {<EOL>        tree._root = current;<EOL>    }<EOL>    p.replace(current);<EOL>    if (current._red && p.parent.node._red) {<EOL>        current._red = false;<EOL>        debt = <NUM_LIT>;<EOL>    }<EOL>    if (debt > <NUM_LIT>) {<EOL>        var parent = (p = p.release()).node, gp = p.parent, sibling = NONE, left = NONE, right = NONE;<EOL>        do {<EOL>            var branch = p.next;<EOL>            if (p.isNone()) {<EOL>                p.node._red = false;<EOL>                updateCount(p.node);<EOL>                debt--;<EOL>            }<EOL>            else if (branch === BRANCH.LEFT) {<EOL>                if ((","gt":"sibling = editRightChild(tree, parent))._red) {"}
{"input":"<s> /**<EOL> * Removes the specified key from the tree. If the key was not in the tree, no changes are made, and the original tree<EOL> * is returned.<EOL> *<EOL> * @export<EOL> * @template K The type of keys in the tree<EOL> * @template V The type of values in the tree<EOL> * @param {K} key The key of the entry to be removed<EOL> * @param {RedBlackTreeStructure<K, V>} tree The tree to be updated<EOL> * @returns {RedBlackTreeStructure<K, V>} An updated copy of the tree, or the same tree if the input tree was already mutable<EOL> */<EOL>export function remove<K, V = null>(key: K, tree: RedBlackTreeStructure<K, V>): RedBlackTreeStructure<K, V> {<EOL>    if (tree._size === <NUM_LIT>) {<EOL>        return tree;<EOL>    }<EOL>    var originalTree = tree;<EOL>    tree = C.modify(tree);<EOL>    C.modifyProperty(tree, '<STR_LIT>');<EOL>    var p: PathNode<K, V> = findPath(tree, key, tree._root, tree._compare);<EOL>    if (p.next !== BRANCH.NONE) {<EOL>        PathNode.release(p, tree._root);<EOL>        return originalTree;<EOL>    }<EOL>    if (tree._size === <NUM_LIT>) {<EOL>        PathNode.release(p, tree._root);<EOL>        if (tree !== originalTree) {<EOL>            return createTree<K, V>(tree._compare);<EOL>        }<EOL>        tree._size = <NUM_LIT>;<EOL>        tree._root = NONE;<EOL>        return tree;<EOL>    }<EOL>    var current = p.node;<EOL>    var hasRight = !isNone(current._right);<EOL>    var hasLeft = !isNone(current._left);<EOL>    var debt = <NUM_LIT>;<EOL>    if (hasRight || hasLeft) {<EOL>        if (hasRight) {<EOL>            if (hasLeft) {<EOL>                p = findSuccessor(tree, p);<EOL>                swapNodeContents(p.node, current);<EOL>                current = p.node;<EOL>            }<EOL>            debt = current._red ? <NUM_LIT> : <NUM_LIT>;<EOL>            current = editRightChild(tree, current);<EOL>        }<EOL>        else if (hasLeft) {<EOL>            debt = current._red ? <NUM_LIT> : <NUM_LIT>;<EOL>            current = editLeftChild(tree, current);<EOL>        }<EOL>    }<EOL>    else {<EOL>        debt = current._red ? <NUM_LIT> : <NUM_LIT>;<EOL>        current = NONE;<EOL>    }<EOL>    if (p.parent.isNone()) {<EOL>        tree._root = current;<EOL>    }<EOL>    p.replace(current);<EOL>    if (current._red && p.parent.node._red) {<EOL>        current._red = false;<EOL>        debt = <NUM_LIT>;<EOL>    }<EOL>    if (debt > <NUM_LIT>) {<EOL>        var parent = (p = p.release()).node, gp = p.parent, sibling = NONE, left = NONE, right = NONE;<EOL>        do {<EOL>            var branch = p.next;<EOL>            if (p.isNone()) {<EOL>                p.node._red = false;<EOL>                updateCount(p.node);<EOL>                debt--;<EOL>            }<EOL>            else if (branch === BRANCH.LEFT) {<EOL>                if ((sibling = editRightChild(tree, parent))._red) {<EOL>                    swapNodeColors(parent, sibling);<EOL>                    rotateLeft(gp, parent, sibling, tree);<EOL>                    p.node = sibling;<EOL>                    gp = p;<EOL>                    p = PathNode.next(parent, p, BRANCH.","gt":"LEFT);"}
{"input":"<s> /**<EOL> * Removes the specified key from the tree. If the key was not in the tree, no changes are made, and the original tree<EOL> * is returned.<EOL> *<EOL> * @export<EOL> * @template K The type of keys in the tree<EOL> * @template V The type of values in the tree<EOL> * @param {K} key The key of the entry to be removed<EOL> * @param {RedBlackTreeStructure<K, V>} tree The tree to be updated<EOL> * @returns {RedBlackTreeStructure<K, V>} An updated copy of the tree, or the same tree if the input tree was already mutable<EOL> */<EOL>export function remove<K, V = null>(key: K, tree: RedBlackTreeStructure<K, V>): RedBlackTreeStructure<K, V> {<EOL>    if (tree._size === <NUM_LIT>) {<EOL>        return tree;<EOL>    }<EOL>    var originalTree = tree;<EOL>    tree = C.modify(tree);<EOL>    C.modifyProperty(tree, '<STR_LIT>');<EOL>    var p: PathNode<K, V> = findPath(tree, key, tree._root, tree._compare);<EOL>    if (p.next !== BRANCH.NONE) {<EOL>        PathNode.release(p, tree._root);<EOL>        return originalTree;<EOL>    }<EOL>    if (tree._size === <NUM_LIT>) {<EOL>        PathNode.release(p, tree._root);<EOL>        if (tree !== originalTree) {<EOL>            return createTree<K, V>(tree._compare);<EOL>        }<EOL>        tree._size = <NUM_LIT>;<EOL>        tree._root = NONE;<EOL>        return tree;<EOL>    }<EOL>    var current = p.node;<EOL>    var hasRight = !isNone(current._right);<EOL>    var hasLeft = !isNone(current._left);<EOL>    var debt = <NUM_LIT>;<EOL>    if (hasRight || hasLeft) {<EOL>        if (hasRight) {<EOL>            if (hasLeft) {<EOL>                p = findSuccessor(tree, p);<EOL>                swapNodeContents(p.node, current);<EOL>                current = p.node;<EOL>            }<EOL>            debt = current._red ? <NUM_LIT> : <NUM_LIT>;<EOL>            current = editRightChild(tree, current);<EOL>        }<EOL>        else if (hasLeft) {<EOL>            debt = current._red ? <NUM_LIT> : <NUM_LIT>;<EOL>            current = editLeftChild(tree, current);<EOL>        }<EOL>    }<EOL>    else {<EOL>        debt = current._red ? <NUM_LIT> : <NUM_LIT>;<EOL>        current = NONE;<EOL>    }<EOL>    if (p.parent.isNone()) {<EOL>        tree._root = current;<EOL>    }<EOL>    p.replace(current);<EOL>    if (current._red && p.parent.node._red) {<EOL>        current._red = false;<EOL>        debt = <NUM_LIT>;<EOL>    }<EOL>    if (debt > <NUM_LIT>) {<EOL>        var parent = (p = p.release()).node, gp = p.parent, sibling = NONE, left = NONE, right = NONE;<EOL>        do {<EOL>            var branch = p.next;<EOL>            if (p.isNone()) {<EOL>                p.node._red = false;<EOL>                updateCount(p.node);<EOL>                debt--;<EOL>            }<EOL>            else if (branch === BRANCH.LEFT) {<EOL>                if ((sibling = editRightChild(tree, parent))._red) {<EOL>                    swapNodeColors(parent, sibling);<EOL>                    rotateLeft(gp, parent, sibling, tree);<EOL>                    p.node = sibling;<EOL>                    gp = p;<EOL>                    p = PathNode.next(parent, p, BRANCH.LEFT);<EOL>                }<EOL>                else if (!(left = sibling._left)._red && !sibling._right._red) {<EOL>                    sibling._red = true;<EOL>                    if (parent._red) {<EOL>                        parent._red = false;<EOL>                        debt--;<EOL>                        if (p.isNone()) {<EOL>                            tree._root = current;<EOL>                        }<EOL>                    }<EOL>                    else {<EOL>","gt":"current = parent;"}
{"input":"<s> /**<EOL> * Removes the specified key from the tree. If the key was not in the tree, no changes are made, and the original tree<EOL> * is returned.<EOL> *<EOL> * @export<EOL> * @template K The type of keys in the tree<EOL> * @template V The type of values in the tree<EOL> * @param {K} key The key of the entry to be removed<EOL> * @param {RedBlackTreeStructure<K, V>} tree The tree to be updated<EOL> * @returns {RedBlackTreeStructure<K, V>} An updated copy of the tree, or the same tree if the input tree was already mutable<EOL> */<EOL>export function remove<K, V = null>(key: K, tree: RedBlackTreeStructure<K, V>): RedBlackTreeStructure<K, V> {<EOL>    if (tree._size === <NUM_LIT>) {<EOL>        return tree;<EOL>    }<EOL>    var originalTree = tree;<EOL>    tree = C.modify(tree);<EOL>    C.modifyProperty(tree, '<STR_LIT>');<EOL>    var p: PathNode<K, V> = findPath(tree, key, tree._root, tree._compare);<EOL>    if (p.next !== BRANCH.NONE) {<EOL>        PathNode.release(p, tree._root);<EOL>        return originalTree;<EOL>    }<EOL>    if (tree._size === <NUM_LIT>) {<EOL>        PathNode.release(p, tree._root);<EOL>        if (tree !== originalTree) {<EOL>            return createTree<K, V>(tree._compare);<EOL>        }<EOL>        tree._size = <NUM_LIT>;<EOL>        tree._root = NONE;<EOL>        return tree;<EOL>    }<EOL>    var current = p.node;<EOL>    var hasRight = !isNone(current._right);<EOL>    var hasLeft = !isNone(current._left);<EOL>    var debt = <NUM_LIT>;<EOL>    if (hasRight || hasLeft) {<EOL>        if (hasRight) {<EOL>            if (hasLeft) {<EOL>                p = findSuccessor(tree, p);<EOL>                swapNodeContents(p.node, current);<EOL>                current = p.node;<EOL>            }<EOL>            debt = current._red ? <NUM_LIT> : <NUM_LIT>;<EOL>            current = editRightChild(tree, current);<EOL>        }<EOL>        else if (hasLeft) {<EOL>            debt = current._red ? <NUM_LIT> : <NUM_LIT>;<EOL>            current = editLeftChild(tree, current);<EOL>        }<EOL>    }<EOL>    else {<EOL>        debt = current._red ? <NUM_LIT> : <NUM_LIT>;<EOL>        current = NONE;<EOL>    }<EOL>    if (p.parent.isNone()) {<EOL>        tree._root = current;<EOL>    }<EOL>    p.replace(current);<EOL>    if (current._red && p.parent.node._red) {<EOL>        current._red = false;<EOL>        debt = <NUM_LIT>;<EOL>    }<EOL>    if (debt > <NUM_LIT>) {<EOL>        var parent = (p = p.release()).node, gp = p.parent, sibling = NONE, left = NONE, right = NONE;<EOL>        do {<EOL>            var branch = p.next;<EOL>            if (p.isNone()) {<EOL>                p.node._red = false;<EOL>                updateCount(p.node);<EOL>                debt--;<EOL>            }<EOL>            else if (branch === BRANCH.LEFT) {<EOL>                if ((sibling = editRightChild(tree, parent))._red) {<EOL>                    swapNodeColors(parent, sibling);<EOL>                    rotateLeft(gp, parent, sibling, tree);<EOL>                    p.node = sibling;<EOL>                    gp = p;<EOL>                    p = PathNode.next(parent, p, BRANCH.LEFT);<EOL>                }<EOL>                else if (!(left = sibling._left)._red && !sibling._right._red) {<EOL>                    sibling._red = true;<EOL>                    if (parent._red) {<EOL>                        parent._red = false;<EOL>                        debt--;<EOL>                        if (p.isNone()) {<EOL>                            tree._root = current;<EOL>                        }<EOL>                    }<EOL>                    else {<EOL>                        current = parent;<EOL>                        p = p.release();<EOL>                        gp = p.parent;<EOL>                        parent = p.","gt":"node;"}
{"input":"<s> /**<EOL> * Removes the specified key from the tree. If the key was not in the tree, no changes are made, and the original tree<EOL> * is returned.<EOL> *<EOL> * @export<EOL> * @template K The type of keys in the tree<EOL> * @template V The type of values in the tree<EOL> * @param {K} key The key of the entry to be removed<EOL> * @param {RedBlackTreeStructure<K, V>} tree The tree to be updated<EOL> * @returns {RedBlackTreeStructure<K, V>} An updated copy of the tree, or the same tree if the input tree was already mutable<EOL> */<EOL>export function remove<K, V = null>(key: K, tree: RedBlackTreeStructure<K, V>): RedBlackTreeStructure<K, V> {<EOL>    if (tree._size === <NUM_LIT>) {<EOL>        return tree;<EOL>    }<EOL>    var originalTree = tree;<EOL>    tree = C.modify(tree);<EOL>    C.modifyProperty(tree, '<STR_LIT>');<EOL>    var p: PathNode<K, V> = findPath(tree, key, tree._root, tree._compare);<EOL>    if (p.next !== BRANCH.NONE) {<EOL>        PathNode.release(p, tree._root);<EOL>        return originalTree;<EOL>    }<EOL>    if (tree._size === <NUM_LIT>) {<EOL>        PathNode.release(p, tree._root);<EOL>        if (tree !== originalTree) {<EOL>            return createTree<K, V>(tree._compare);<EOL>        }<EOL>        tree._size = <NUM_LIT>;<EOL>        tree._root = NONE;<EOL>        return tree;<EOL>    }<EOL>    var current = p.node;<EOL>    var hasRight = !isNone(current._right);<EOL>    var hasLeft = !isNone(current._left);<EOL>    var debt = <NUM_LIT>;<EOL>    if (hasRight || hasLeft) {<EOL>        if (hasRight) {<EOL>            if (hasLeft) {<EOL>                p = findSuccessor(tree, p);<EOL>                swapNodeContents(p.node, current);<EOL>                current = p.node;<EOL>            }<EOL>            debt = current._red ? <NUM_LIT> : <NUM_LIT>;<EOL>            current = editRightChild(tree, current);<EOL>        }<EOL>        else if (hasLeft) {<EOL>            debt = current._red ? <NUM_LIT> : <NUM_LIT>;<EOL>            current = editLeftChild(tree, current);<EOL>        }<EOL>    }<EOL>    else {<EOL>        debt = current._red ? <NUM_LIT> : <NUM_LIT>;<EOL>        current = NONE;<EOL>    }<EOL>    if (p.parent.isNone()) {<EOL>        tree._root = current;<EOL>    }<EOL>    p.replace(current);<EOL>    if (current._red && p.parent.node._red) {<EOL>        current._red = false;<EOL>        debt = <NUM_LIT>;<EOL>    }<EOL>    if (debt > <NUM_LIT>) {<EOL>        var parent = (p = p.release()).node, gp = p.parent, sibling = NONE, left = NONE, right = NONE;<EOL>        do {<EOL>            var branch = p.next;<EOL>            if (p.isNone()) {<EOL>                p.node._red = false;<EOL>                updateCount(p.node);<EOL>                debt--;<EOL>            }<EOL>            else if (branch === BRANCH.LEFT) {<EOL>                if ((sibling = editRightChild(tree, parent))._red) {<EOL>                    swapNodeColors(parent, sibling);<EOL>                    rotateLeft(gp, parent, sibling, tree);<EOL>                    p.node = sibling;<EOL>                    gp = p;<EOL>                    p = PathNode.next(parent, p, BRANCH.LEFT);<EOL>                }<EOL>                else if (!(left = sibling._left)._red && !sibling._right._red) {<EOL>                    sibling._red = true;<EOL>                    if (parent._red) {<EOL>                        parent._red = false;<EOL>                        debt--;<EOL>                        if (p.isNone()) {<EOL>                            tree._root = current;<EOL>                        }<EOL>                    }<EOL>                    else {<EOL>                        current = parent;<EOL>                        p = p.release();<EOL>                        gp = p.parent;<EOL>                        parent = p.node;<EOL>                    }<EOL>                    updateCount(parent);<EOL>                }<EOL>                else {<EOL>                    if (!sibling._right._red && left._red) {<EOL>                        left = editLeftChild(tree, sibling);<EOL>                        p.","gt":"next = BRANCH."}
{"input":"<s> /**<EOL> * Removes the specified key from the tree. If the key was not in the tree, no changes are made, and the original tree<EOL> * is returned.<EOL> *<EOL> * @export<EOL> * @template K The type of keys in the tree<EOL> * @template V The type of values in the tree<EOL> * @param {K} key The key of the entry to be removed<EOL> * @param {RedBlackTreeStructure<K, V>} tree The tree to be updated<EOL> * @returns {RedBlackTreeStructure<K, V>} An updated copy of the tree, or the same tree if the input tree was already mutable<EOL> */<EOL>export function remove<K, V = null>(key: K, tree: RedBlackTreeStructure<K, V>): RedBlackTreeStructure<K, V> {<EOL>    if (tree._size === <NUM_LIT>) {<EOL>        return tree;<EOL>    }<EOL>    var originalTree = tree;<EOL>    tree = C.modify(tree);<EOL>    C.modifyProperty(tree, '<STR_LIT>');<EOL>    var p: PathNode<K, V> = findPath(tree, key, tree._root, tree._compare);<EOL>    if (p.next !== BRANCH.NONE) {<EOL>        PathNode.release(p, tree._root);<EOL>        return originalTree;<EOL>    }<EOL>    if (tree._size === <NUM_LIT>) {<EOL>        PathNode.release(p, tree._root);<EOL>        if (tree !== originalTree) {<EOL>            return createTree<K, V>(tree._compare);<EOL>        }<EOL>        tree._size = <NUM_LIT>;<EOL>        tree._root = NONE;<EOL>        return tree;<EOL>    }<EOL>    var current = p.node;<EOL>    var hasRight = !isNone(current._right);<EOL>    var hasLeft = !isNone(current._left);<EOL>    var debt = <NUM_LIT>;<EOL>    if (hasRight || hasLeft) {<EOL>        if (hasRight) {<EOL>            if (hasLeft) {<EOL>                p = findSuccessor(tree, p);<EOL>                swapNodeContents(p.node, current);<EOL>                current = p.node;<EOL>            }<EOL>            debt = current._red ? <NUM_LIT> : <NUM_LIT>;<EOL>            current = editRightChild(tree, current);<EOL>        }<EOL>        else if (hasLeft) {<EOL>            debt = current._red ? <NUM_LIT> : <NUM_LIT>;<EOL>            current = editLeftChild(tree, current);<EOL>        }<EOL>    }<EOL>    else {<EOL>        debt = current._red ? <NUM_LIT> : <NUM_LIT>;<EOL>        current = NONE;<EOL>    }<EOL>    if (p.parent.isNone()) {<EOL>        tree._root = current;<EOL>    }<EOL>    p.replace(current);<EOL>    if (current._red && p.parent.node._red) {<EOL>        current._red = false;<EOL>        debt = <NUM_LIT>;<EOL>    }<EOL>    if (debt > <NUM_LIT>) {<EOL>        var parent = (p = p.release()).node, gp = p.parent, sibling = NONE, left = NONE, right = NONE;<EOL>        do {<EOL>            var branch = p.next;<EOL>            if (p.isNone()) {<EOL>                p.node._red = false;<EOL>                updateCount(p.node);<EOL>                debt--;<EOL>            }<EOL>            else if (branch === BRANCH.LEFT) {<EOL>                if ((sibling = editRightChild(tree, parent))._red) {<EOL>                    swapNodeColors(parent, sibling);<EOL>                    rotateLeft(gp, parent, sibling, tree);<EOL>                    p.node = sibling;<EOL>                    gp = p;<EOL>                    p = PathNode.next(parent, p, BRANCH.LEFT);<EOL>                }<EOL>                else if (!(left = sibling._left)._red && !sibling._right._red) {<EOL>                    sibling._red = true;<EOL>                    if (parent._red) {<EOL>                        parent._red = false;<EOL>                        debt--;<EOL>                        if (p.isNone()) {<EOL>                            tree._root = current;<EOL>                        }<EOL>                    }<EOL>                    else {<EOL>                        current = parent;<EOL>                        p = p.release();<EOL>                        gp = p.parent;<EOL>                        parent = p.node;<EOL>                    }<EOL>                    updateCount(parent);<EOL>                }<EOL>                else {<EOL>                    if (!sibling._right._red && left._red) {<EOL>                        left = editLeftChild(tree, sibling);<EOL>                        p.next = BRANCH.","gt":"RIGHT;"}
{"input":"<s> /**<EOL> * Removes the specified key from the tree. If the key was not in the tree, no changes are made, and the original tree<EOL> * is returned.<EOL> *<EOL> * @export<EOL> * @template K The type of keys in the tree<EOL> * @template V The type of values in the tree<EOL> * @param {K} key The key of the entry to be removed<EOL> * @param {RedBlackTreeStructure<K, V>} tree The tree to be updated<EOL> * @returns {RedBlackTreeStructure<K, V>} An updated copy of the tree, or the same tree if the input tree was already mutable<EOL> */<EOL>export function remove<K, V = null>(key: K, tree: RedBlackTreeStructure<K, V>): RedBlackTreeStructure<K, V> {<EOL>    if (tree._size === <NUM_LIT>) {<EOL>        return tree;<EOL>    }<EOL>    var originalTree = tree;<EOL>    tree = C.modify(tree);<EOL>    C.modifyProperty(tree, '<STR_LIT>');<EOL>    var p: PathNode<K, V> = findPath(tree, key, tree._root, tree._compare);<EOL>    if (p.next !== BRANCH.NONE) {<EOL>        PathNode.release(p, tree._root);<EOL>        return originalTree;<EOL>    }<EOL>    if (tree._size === <NUM_LIT>) {<EOL>        PathNode.release(p, tree._root);<EOL>        if (tree !== originalTree) {<EOL>            return createTree<K, V>(tree._compare);<EOL>        }<EOL>        tree._size = <NUM_LIT>;<EOL>        tree._root = NONE;<EOL>        return tree;<EOL>    }<EOL>    var current = p.node;<EOL>    var hasRight = !isNone(current._right);<EOL>    var hasLeft = !isNone(current._left);<EOL>    var debt = <NUM_LIT>;<EOL>    if (hasRight || hasLeft) {<EOL>        if (hasRight) {<EOL>            if (hasLeft) {<EOL>                p = findSuccessor(tree, p);<EOL>                swapNodeContents(p.node, current);<EOL>                current = p.node;<EOL>            }<EOL>            debt = current._red ? <NUM_LIT> : <NUM_LIT>;<EOL>            current = editRightChild(tree, current);<EOL>        }<EOL>        else if (hasLeft) {<EOL>            debt = current._red ? <NUM_LIT> : <NUM_LIT>;<EOL>            current = editLeftChild(tree, current);<EOL>        }<EOL>    }<EOL>    else {<EOL>        debt = current._red ? <NUM_LIT> : <NUM_LIT>;<EOL>        current = NONE;<EOL>    }<EOL>    if (p.parent.isNone()) {<EOL>        tree._root = current;<EOL>    }<EOL>    p.replace(current);<EOL>    if (current._red && p.parent.node._red) {<EOL>        current._red = false;<EOL>        debt = <NUM_LIT>;<EOL>    }<EOL>    if (debt > <NUM_LIT>) {<EOL>        var parent = (p = p.release()).node, gp = p.parent, sibling = NONE, left = NONE, right = NONE;<EOL>        do {<EOL>            var branch = p.next;<EOL>            if (p.isNone()) {<EOL>                p.node._red = false;<EOL>                updateCount(p.node);<EOL>                debt--;<EOL>            }<EOL>            else if (branch === BRANCH.LEFT) {<EOL>                if ((sibling = editRightChild(tree, parent))._red) {<EOL>                    swapNodeColors(parent, sibling);<EOL>                    rotateLeft(gp, parent, sibling, tree);<EOL>                    p.node = sibling;<EOL>                    gp = p;<EOL>                    p = PathNode.next(parent, p, BRANCH.LEFT);<EOL>                }<EOL>                else if (!(left = sibling._left)._red && !sibling._right._red) {<EOL>                    sibling._red = true;<EOL>                    if (parent._red) {<EOL>                        parent._red = false;<EOL>                        debt--;<EOL>                        if (p.isNone()) {<EOL>                            tree._root = current;<EOL>                        }<EOL>                    }<EOL>                    else {<EOL>                        current = parent;<EOL>                        p = p.release();<EOL>                        gp = p.parent;<EOL>                        parent = p.node;<EOL>                    }<EOL>                    updateCount(parent);<EOL>                }<EOL>                else {<EOL>                    if (!sibling._right._red && left._red) {<EOL>                        left = editLeftChild(tree, sibling);<EOL>                        p.next = BRANCH.RIGHT;<EOL>                        swapNodeColors(sibling, left);<EOL>                        rotateRight(p, sibling, left, tree);<EOL>","gt":"sibling = left;"}
{"input":"<s> /**<EOL> * Removes the specified key from the tree. If the key was not in the tree, no changes are made, and the original tree<EOL> * is returned.<EOL> *<EOL> * @export<EOL> * @template K The type of keys in the tree<EOL> * @template V The type of values in the tree<EOL> * @param {K} key The key of the entry to be removed<EOL> * @param {RedBlackTreeStructure<K, V>} tree The tree to be updated<EOL> * @returns {RedBlackTreeStructure<K, V>} An updated copy of the tree, or the same tree if the input tree was already mutable<EOL> */<EOL>export function remove<K, V = null>(key: K, tree: RedBlackTreeStructure<K, V>): RedBlackTreeStructure<K, V> {<EOL>    if (tree._size === <NUM_LIT>) {<EOL>        return tree;<EOL>    }<EOL>    var originalTree = tree;<EOL>    tree = C.modify(tree);<EOL>    C.modifyProperty(tree, '<STR_LIT>');<EOL>    var p: PathNode<K, V> = findPath(tree, key, tree._root, tree._compare);<EOL>    if (p.next !== BRANCH.NONE) {<EOL>        PathNode.release(p, tree._root);<EOL>        return originalTree;<EOL>    }<EOL>    if (tree._size === <NUM_LIT>) {<EOL>        PathNode.release(p, tree._root);<EOL>        if (tree !== originalTree) {<EOL>            return createTree<K, V>(tree._compare);<EOL>        }<EOL>        tree._size = <NUM_LIT>;<EOL>        tree._root = NONE;<EOL>        return tree;<EOL>    }<EOL>    var current = p.node;<EOL>    var hasRight = !isNone(current._right);<EOL>    var hasLeft = !isNone(current._left);<EOL>    var debt = <NUM_LIT>;<EOL>    if (hasRight || hasLeft) {<EOL>        if (hasRight) {<EOL>            if (hasLeft) {<EOL>                p = findSuccessor(tree, p);<EOL>                swapNodeContents(p.node, current);<EOL>                current = p.node;<EOL>            }<EOL>            debt = current._red ? <NUM_LIT> : <NUM_LIT>;<EOL>            current = editRightChild(tree, current);<EOL>        }<EOL>        else if (hasLeft) {<EOL>            debt = current._red ? <NUM_LIT> : <NUM_LIT>;<EOL>            current = editLeftChild(tree, current);<EOL>        }<EOL>    }<EOL>    else {<EOL>        debt = current._red ? <NUM_LIT> : <NUM_LIT>;<EOL>        current = NONE;<EOL>    }<EOL>    if (p.parent.isNone()) {<EOL>        tree._root = current;<EOL>    }<EOL>    p.replace(current);<EOL>    if (current._red && p.parent.node._red) {<EOL>        current._red = false;<EOL>        debt = <NUM_LIT>;<EOL>    }<EOL>    if (debt > <NUM_LIT>) {<EOL>        var parent = (p = p.release()).node, gp = p.parent, sibling = NONE, left = NONE, right = NONE;<EOL>        do {<EOL>            var branch = p.next;<EOL>            if (p.isNone()) {<EOL>                p.node._red = false;<EOL>                updateCount(p.node);<EOL>                debt--;<EOL>            }<EOL>            else if (branch === BRANCH.LEFT) {<EOL>                if ((sibling = editRightChild(tree, parent))._red) {<EOL>                    swapNodeColors(parent, sibling);<EOL>                    rotateLeft(gp, parent, sibling, tree);<EOL>                    p.node = sibling;<EOL>                    gp = p;<EOL>                    p = PathNode.next(parent, p, BRANCH.LEFT);<EOL>                }<EOL>                else if (!(left = sibling._left)._red && !sibling._right._red) {<EOL>                    sibling._red = true;<EOL>                    if (parent._red) {<EOL>                        parent._red = false;<EOL>                        debt--;<EOL>                        if (p.isNone()) {<EOL>                            tree._root = current;<EOL>                        }<EOL>                    }<EOL>                    else {<EOL>                        current = parent;<EOL>                        p = p.release();<EOL>                        gp = p.parent;<EOL>                        parent = p.node;<EOL>                    }<EOL>                    updateCount(parent);<EOL>                }<EOL>                else {<EOL>                    if (!sibling._right._red && left._red) {<EOL>                        left = editLeftChild(tree, sibling);<EOL>                        p.next = BRANCH.RIGHT;<EOL>                        swapNodeColors(sibling, left);<EOL>                        rotateRight(p, sibling, left, tree);<EOL>                        sibling = left;<EOL>                    }<EOL>                    right = editRightChild(tree, sibling);<EOL>                    rotateLeft(gp, parent,","gt":"sibling, tree);"}
{"input":"<s> /**<EOL> * Removes the specified key from the tree. If the key was not in the tree, no changes are made, and the original tree<EOL> * is returned.<EOL> *<EOL> * @export<EOL> * @template K The type of keys in the tree<EOL> * @template V The type of values in the tree<EOL> * @param {K} key The key of the entry to be removed<EOL> * @param {RedBlackTreeStructure<K, V>} tree The tree to be updated<EOL> * @returns {RedBlackTreeStructure<K, V>} An updated copy of the tree, or the same tree if the input tree was already mutable<EOL> */<EOL>export function remove<K, V = null>(key: K, tree: RedBlackTreeStructure<K, V>): RedBlackTreeStructure<K, V> {<EOL>    if (tree._size === <NUM_LIT>) {<EOL>        return tree;<EOL>    }<EOL>    var originalTree = tree;<EOL>    tree = C.modify(tree);<EOL>    C.modifyProperty(tree, '<STR_LIT>');<EOL>    var p: PathNode<K, V> = findPath(tree, key, tree._root, tree._compare);<EOL>    if (p.next !== BRANCH.NONE) {<EOL>        PathNode.release(p, tree._root);<EOL>        return originalTree;<EOL>    }<EOL>    if (tree._size === <NUM_LIT>) {<EOL>        PathNode.release(p, tree._root);<EOL>        if (tree !== originalTree) {<EOL>            return createTree<K, V>(tree._compare);<EOL>        }<EOL>        tree._size = <NUM_LIT>;<EOL>        tree._root = NONE;<EOL>        return tree;<EOL>    }<EOL>    var current = p.node;<EOL>    var hasRight = !isNone(current._right);<EOL>    var hasLeft = !isNone(current._left);<EOL>    var debt = <NUM_LIT>;<EOL>    if (hasRight || hasLeft) {<EOL>        if (hasRight) {<EOL>            if (hasLeft) {<EOL>                p = findSuccessor(tree, p);<EOL>                swapNodeContents(p.node, current);<EOL>                current = p.node;<EOL>            }<EOL>            debt = current._red ? <NUM_LIT> : <NUM_LIT>;<EOL>            current = editRightChild(tree, current);<EOL>        }<EOL>        else if (hasLeft) {<EOL>            debt = current._red ? <NUM_LIT> : <NUM_LIT>;<EOL>            current = editLeftChild(tree, current);<EOL>        }<EOL>    }<EOL>    else {<EOL>        debt = current._red ? <NUM_LIT> : <NUM_LIT>;<EOL>        current = NONE;<EOL>    }<EOL>    if (p.parent.isNone()) {<EOL>        tree._root = current;<EOL>    }<EOL>    p.replace(current);<EOL>    if (current._red && p.parent.node._red) {<EOL>        current._red = false;<EOL>        debt = <NUM_LIT>;<EOL>    }<EOL>    if (debt > <NUM_LIT>) {<EOL>        var parent = (p = p.release()).node, gp = p.parent, sibling = NONE, left = NONE, right = NONE;<EOL>        do {<EOL>            var branch = p.next;<EOL>            if (p.isNone()) {<EOL>                p.node._red = false;<EOL>                updateCount(p.node);<EOL>                debt--;<EOL>            }<EOL>            else if (branch === BRANCH.LEFT) {<EOL>                if ((sibling = editRightChild(tree, parent))._red) {<EOL>                    swapNodeColors(parent, sibling);<EOL>                    rotateLeft(gp, parent, sibling, tree);<EOL>                    p.node = sibling;<EOL>                    gp = p;<EOL>                    p = PathNode.next(parent, p, BRANCH.LEFT);<EOL>                }<EOL>                else if (!(left = sibling._left)._red && !sibling._right._red) {<EOL>                    sibling._red = true;<EOL>                    if (parent._red) {<EOL>                        parent._red = false;<EOL>                        debt--;<EOL>                        if (p.isNone()) {<EOL>                            tree._root = current;<EOL>                        }<EOL>                    }<EOL>                    else {<EOL>                        current = parent;<EOL>                        p = p.release();<EOL>                        gp = p.parent;<EOL>                        parent = p.node;<EOL>                    }<EOL>                    updateCount(parent);<EOL>                }<EOL>                else {<EOL>                    if (!sibling._right._red && left._red) {<EOL>                        left = editLeftChild(tree, sibling);<EOL>                        p.next = BRANCH.RIGHT;<EOL>                        swapNodeColors(sibling, left);<EOL>                        rotateRight(p, sibling, left, tree);<EOL>                        sibling = left;<EOL>                    }<EOL>                    right = editRightChild(tree, sibling);<EOL>                    rotateLeft(gp, parent, sibling, tree);<EOL>                    sibling._red = parent._red;<EOL>                    parent._red = false;<EOL>                    right._red = false;<EOL>                    debt--;<EOL>                }<EOL>            }<EOL>            else {<EOL>                if ((sibling = editLeftChild(tree, parent))._red) {<EOL>                    rotateRight(gp, parent, sibling, tree);<EOL>                    swapNodeColors(parent, sibling);<EOL>                    p.node = sibling;<EOL>                    gp = p;<EOL>                    p = PathNode.next(parent, p, BRANCH.RIGHT);<EOL>                }<EOL>                else if (!(right = sibling._right)._red && !sibling._left._red) {<EOL>","gt":"sibling._red = true;"}
{"input":"<s> /**<EOL> * Removes the specified key from the tree. If the key was not in the tree, no changes are made, and the original tree<EOL> * is returned.<EOL> *<EOL> * @export<EOL> * @template K The type of keys in the tree<EOL> * @template V The type of values in the tree<EOL> * @param {K} key The key of the entry to be removed<EOL> * @param {RedBlackTreeStructure<K, V>} tree The tree to be updated<EOL> * @returns {RedBlackTreeStructure<K, V>} An updated copy of the tree, or the same tree if the input tree was already mutable<EOL> */<EOL>export function remove<K, V = null>(key: K, tree: RedBlackTreeStructure<K, V>): RedBlackTreeStructure<K, V> {<EOL>    if (tree._size === <NUM_LIT>) {<EOL>        return tree;<EOL>    }<EOL>    var originalTree = tree;<EOL>    tree = C.modify(tree);<EOL>    C.modifyProperty(tree, '<STR_LIT>');<EOL>    var p: PathNode<K, V> = findPath(tree, key, tree._root, tree._compare);<EOL>    if (p.next !== BRANCH.NONE) {<EOL>        PathNode.release(p, tree._root);<EOL>        return originalTree;<EOL>    }<EOL>    if (tree._size === <NUM_LIT>) {<EOL>        PathNode.release(p, tree._root);<EOL>        if (tree !== originalTree) {<EOL>            return createTree<K, V>(tree._compare);<EOL>        }<EOL>        tree._size = <NUM_LIT>;<EOL>        tree._root = NONE;<EOL>        return tree;<EOL>    }<EOL>    var current = p.node;<EOL>    var hasRight = !isNone(current._right);<EOL>    var hasLeft = !isNone(current._left);<EOL>    var debt = <NUM_LIT>;<EOL>    if (hasRight || hasLeft) {<EOL>        if (hasRight) {<EOL>            if (hasLeft) {<EOL>                p = findSuccessor(tree, p);<EOL>                swapNodeContents(p.node, current);<EOL>                current = p.node;<EOL>            }<EOL>            debt = current._red ? <NUM_LIT> : <NUM_LIT>;<EOL>            current = editRightChild(tree, current);<EOL>        }<EOL>        else if (hasLeft) {<EOL>            debt = current._red ? <NUM_LIT> : <NUM_LIT>;<EOL>            current = editLeftChild(tree, current);<EOL>        }<EOL>    }<EOL>    else {<EOL>        debt = current._red ? <NUM_LIT> : <NUM_LIT>;<EOL>        current = NONE;<EOL>    }<EOL>    if (p.parent.isNone()) {<EOL>        tree._root = current;<EOL>    }<EOL>    p.replace(current);<EOL>    if (current._red && p.parent.node._red) {<EOL>        current._red = false;<EOL>        debt = <NUM_LIT>;<EOL>    }<EOL>    if (debt > <NUM_LIT>) {<EOL>        var parent = (p = p.release()).node, gp = p.parent, sibling = NONE, left = NONE, right = NONE;<EOL>        do {<EOL>            var branch = p.next;<EOL>            if (p.isNone()) {<EOL>                p.node._red = false;<EOL>                updateCount(p.node);<EOL>                debt--;<EOL>            }<EOL>            else if (branch === BRANCH.LEFT) {<EOL>                if ((sibling = editRightChild(tree, parent))._red) {<EOL>                    swapNodeColors(parent, sibling);<EOL>                    rotateLeft(gp, parent, sibling, tree);<EOL>                    p.node = sibling;<EOL>                    gp = p;<EOL>                    p = PathNode.next(parent, p, BRANCH.LEFT);<EOL>                }<EOL>                else if (!(left = sibling._left)._red && !sibling._right._red) {<EOL>                    sibling._red = true;<EOL>                    if (parent._red) {<EOL>                        parent._red = false;<EOL>                        debt--;<EOL>                        if (p.isNone()) {<EOL>                            tree._root = current;<EOL>                        }<EOL>                    }<EOL>                    else {<EOL>                        current = parent;<EOL>                        p = p.release();<EOL>                        gp = p.parent;<EOL>                        parent = p.node;<EOL>                    }<EOL>                    updateCount(parent);<EOL>                }<EOL>                else {<EOL>                    if (!sibling._right._red && left._red) {<EOL>                        left = editLeftChild(tree, sibling);<EOL>                        p.next = BRANCH.RIGHT;<EOL>                        swapNodeColors(sibling, left);<EOL>                        rotateRight(p, sibling, left, tree);<EOL>                        sibling = left;<EOL>                    }<EOL>                    right = editRightChild(tree, sibling);<EOL>                    rotateLeft(gp, parent, sibling, tree);<EOL>                    sibling._red = parent._red;<EOL>                    parent._red = false;<EOL>                    right._red = false;<EOL>                    debt--;<EOL>                }<EOL>            }<EOL>            else {<EOL>                if ((sibling = editLeftChild(tree, parent))._red) {<EOL>                    rotateRight(gp, parent, sibling, tree);<EOL>                    swapNodeColors(parent, sibling);<EOL>                    p.node = sibling;<EOL>                    gp = p;<EOL>                    p = PathNode.next(parent, p, BRANCH.RIGHT);<EOL>                }<EOL>                else if (!(right = sibling._right)._red && !sibling._left._red) {<EOL>                    sibling._red = true;<EOL>                    if (parent.","gt":"_red) {"}
{"input":"<s> /**<EOL> * Removes the specified key from the tree. If the key was not in the tree, no changes are made, and the original tree<EOL> * is returned.<EOL> *<EOL> * @export<EOL> * @template K The type of keys in the tree<EOL> * @template V The type of values in the tree<EOL> * @param {K} key The key of the entry to be removed<EOL> * @param {RedBlackTreeStructure<K, V>} tree The tree to be updated<EOL> * @returns {RedBlackTreeStructure<K, V>} An updated copy of the tree, or the same tree if the input tree was already mutable<EOL> */<EOL>export function remove<K, V = null>(key: K, tree: RedBlackTreeStructure<K, V>): RedBlackTreeStructure<K, V> {<EOL>    if (tree._size === <NUM_LIT>) {<EOL>        return tree;<EOL>    }<EOL>    var originalTree = tree;<EOL>    tree = C.modify(tree);<EOL>    C.modifyProperty(tree, '<STR_LIT>');<EOL>    var p: PathNode<K, V> = findPath(tree, key, tree._root, tree._compare);<EOL>    if (p.next !== BRANCH.NONE) {<EOL>        PathNode.release(p, tree._root);<EOL>        return originalTree;<EOL>    }<EOL>    if (tree._size === <NUM_LIT>) {<EOL>        PathNode.release(p, tree._root);<EOL>        if (tree !== originalTree) {<EOL>            return createTree<K, V>(tree._compare);<EOL>        }<EOL>        tree._size = <NUM_LIT>;<EOL>        tree._root = NONE;<EOL>        return tree;<EOL>    }<EOL>    var current = p.node;<EOL>    var hasRight = !isNone(current._right);<EOL>    var hasLeft = !isNone(current._left);<EOL>    var debt = <NUM_LIT>;<EOL>    if (hasRight || hasLeft) {<EOL>        if (hasRight) {<EOL>            if (hasLeft) {<EOL>                p = findSuccessor(tree, p);<EOL>                swapNodeContents(p.node, current);<EOL>                current = p.node;<EOL>            }<EOL>            debt = current._red ? <NUM_LIT> : <NUM_LIT>;<EOL>            current = editRightChild(tree, current);<EOL>        }<EOL>        else if (hasLeft) {<EOL>            debt = current._red ? <NUM_LIT> : <NUM_LIT>;<EOL>            current = editLeftChild(tree, current);<EOL>        }<EOL>    }<EOL>    else {<EOL>        debt = current._red ? <NUM_LIT> : <NUM_LIT>;<EOL>        current = NONE;<EOL>    }<EOL>    if (p.parent.isNone()) {<EOL>        tree._root = current;<EOL>    }<EOL>    p.replace(current);<EOL>    if (current._red && p.parent.node._red) {<EOL>        current._red = false;<EOL>        debt = <NUM_LIT>;<EOL>    }<EOL>    if (debt > <NUM_LIT>) {<EOL>        var parent = (p = p.release()).node, gp = p.parent, sibling = NONE, left = NONE, right = NONE;<EOL>        do {<EOL>            var branch = p.next;<EOL>            if (p.isNone()) {<EOL>                p.node._red = false;<EOL>                updateCount(p.node);<EOL>                debt--;<EOL>            }<EOL>            else if (branch === BRANCH.LEFT) {<EOL>                if ((sibling = editRightChild(tree, parent))._red) {<EOL>                    swapNodeColors(parent, sibling);<EOL>                    rotateLeft(gp, parent, sibling, tree);<EOL>                    p.node = sibling;<EOL>                    gp = p;<EOL>                    p = PathNode.next(parent, p, BRANCH.LEFT);<EOL>                }<EOL>                else if (!(left = sibling._left)._red && !sibling._right._red) {<EOL>                    sibling._red = true;<EOL>                    if (parent._red) {<EOL>                        parent._red = false;<EOL>                        debt--;<EOL>                        if (p.isNone()) {<EOL>                            tree._root = current;<EOL>                        }<EOL>                    }<EOL>                    else {<EOL>                        current = parent;<EOL>                        p = p.release();<EOL>                        gp = p.parent;<EOL>                        parent = p.node;<EOL>                    }<EOL>                    updateCount(parent);<EOL>                }<EOL>                else {<EOL>                    if (!sibling._right._red && left._red) {<EOL>                        left = editLeftChild(tree, sibling);<EOL>                        p.next = BRANCH.RIGHT;<EOL>                        swapNodeColors(sibling, left);<EOL>                        rotateRight(p, sibling, left, tree);<EOL>                        sibling = left;<EOL>                    }<EOL>                    right = editRightChild(tree, sibling);<EOL>                    rotateLeft(gp, parent, sibling, tree);<EOL>                    sibling._red = parent._red;<EOL>                    parent._red = false;<EOL>                    right._red = false;<EOL>                    debt--;<EOL>                }<EOL>            }<EOL>            else {<EOL>                if ((sibling = editLeftChild(tree, parent))._red) {<EOL>                    rotateRight(gp, parent, sibling, tree);<EOL>                    swapNodeColors(parent, sibling);<EOL>                    p.node = sibling;<EOL>                    gp = p;<EOL>                    p = PathNode.next(parent, p, BRANCH.RIGHT);<EOL>                }<EOL>                else if (!(right = sibling._right)._red && !sibling._left._red) {<EOL>                    sibling._red = true;<EOL>                    if (parent._red) {<EOL>                        parent._red = false;<EOL>                        debt--;<EOL>                        if (p.isNone()) {<EOL>                            tree._root = current;<EOL>                        }<EOL>                    }<EOL>                    else {<EOL>                        current =","gt":"parent;"}
{"input":"<s> /**<EOL> * Removes the specified key from the tree. If the key was not in the tree, no changes are made, and the original tree<EOL> * is returned.<EOL> *<EOL> * @export<EOL> * @template K The type of keys in the tree<EOL> * @template V The type of values in the tree<EOL> * @param {K} key The key of the entry to be removed<EOL> * @param {RedBlackTreeStructure<K, V>} tree The tree to be updated<EOL> * @returns {RedBlackTreeStructure<K, V>} An updated copy of the tree, or the same tree if the input tree was already mutable<EOL> */<EOL>export function remove<K, V = null>(key: K, tree: RedBlackTreeStructure<K, V>): RedBlackTreeStructure<K, V> {<EOL>    if (tree._size === <NUM_LIT>) {<EOL>        return tree;<EOL>    }<EOL>    var originalTree = tree;<EOL>    tree = C.modify(tree);<EOL>    C.modifyProperty(tree, '<STR_LIT>');<EOL>    var p: PathNode<K, V> = findPath(tree, key, tree._root, tree._compare);<EOL>    if (p.next !== BRANCH.NONE) {<EOL>        PathNode.release(p, tree._root);<EOL>        return originalTree;<EOL>    }<EOL>    if (tree._size === <NUM_LIT>) {<EOL>        PathNode.release(p, tree._root);<EOL>        if (tree !== originalTree) {<EOL>            return createTree<K, V>(tree._compare);<EOL>        }<EOL>        tree._size = <NUM_LIT>;<EOL>        tree._root = NONE;<EOL>        return tree;<EOL>    }<EOL>    var current = p.node;<EOL>    var hasRight = !isNone(current._right);<EOL>    var hasLeft = !isNone(current._left);<EOL>    var debt = <NUM_LIT>;<EOL>    if (hasRight || hasLeft) {<EOL>        if (hasRight) {<EOL>            if (hasLeft) {<EOL>                p = findSuccessor(tree, p);<EOL>                swapNodeContents(p.node, current);<EOL>                current = p.node;<EOL>            }<EOL>            debt = current._red ? <NUM_LIT> : <NUM_LIT>;<EOL>            current = editRightChild(tree, current);<EOL>        }<EOL>        else if (hasLeft) {<EOL>            debt = current._red ? <NUM_LIT> : <NUM_LIT>;<EOL>            current = editLeftChild(tree, current);<EOL>        }<EOL>    }<EOL>    else {<EOL>        debt = current._red ? <NUM_LIT> : <NUM_LIT>;<EOL>        current = NONE;<EOL>    }<EOL>    if (p.parent.isNone()) {<EOL>        tree._root = current;<EOL>    }<EOL>    p.replace(current);<EOL>    if (current._red && p.parent.node._red) {<EOL>        current._red = false;<EOL>        debt = <NUM_LIT>;<EOL>    }<EOL>    if (debt > <NUM_LIT>) {<EOL>        var parent = (p = p.release()).node, gp = p.parent, sibling = NONE, left = NONE, right = NONE;<EOL>        do {<EOL>            var branch = p.next;<EOL>            if (p.isNone()) {<EOL>                p.node._red = false;<EOL>                updateCount(p.node);<EOL>                debt--;<EOL>            }<EOL>            else if (branch === BRANCH.LEFT) {<EOL>                if ((sibling = editRightChild(tree, parent))._red) {<EOL>                    swapNodeColors(parent, sibling);<EOL>                    rotateLeft(gp, parent, sibling, tree);<EOL>                    p.node = sibling;<EOL>                    gp = p;<EOL>                    p = PathNode.next(parent, p, BRANCH.LEFT);<EOL>                }<EOL>                else if (!(left = sibling._left)._red && !sibling._right._red) {<EOL>                    sibling._red = true;<EOL>                    if (parent._red) {<EOL>                        parent._red = false;<EOL>                        debt--;<EOL>                        if (p.isNone()) {<EOL>                            tree._root = current;<EOL>                        }<EOL>                    }<EOL>                    else {<EOL>                        current = parent;<EOL>                        p = p.release();<EOL>                        gp = p.parent;<EOL>                        parent = p.node;<EOL>                    }<EOL>                    updateCount(parent);<EOL>                }<EOL>                else {<EOL>                    if (!sibling._right._red && left._red) {<EOL>                        left = editLeftChild(tree, sibling);<EOL>                        p.next = BRANCH.RIGHT;<EOL>                        swapNodeColors(sibling, left);<EOL>                        rotateRight(p, sibling, left, tree);<EOL>                        sibling = left;<EOL>                    }<EOL>                    right = editRightChild(tree, sibling);<EOL>                    rotateLeft(gp, parent, sibling, tree);<EOL>                    sibling._red = parent._red;<EOL>                    parent._red = false;<EOL>                    right._red = false;<EOL>                    debt--;<EOL>                }<EOL>            }<EOL>            else {<EOL>                if ((sibling = editLeftChild(tree, parent))._red) {<EOL>                    rotateRight(gp, parent, sibling, tree);<EOL>                    swapNodeColors(parent, sibling);<EOL>                    p.node = sibling;<EOL>                    gp = p;<EOL>                    p = PathNode.next(parent, p, BRANCH.RIGHT);<EOL>                }<EOL>                else if (!(right = sibling._right)._red && !sibling._left._red) {<EOL>                    sibling._red = true;<EOL>                    if (parent._red) {<EOL>                        parent._red = false;<EOL>                        debt--;<EOL>                        if (p.isNone()) {<EOL>                            tree._root = current;<EOL>                        }<EOL>                    }<EOL>                    else {<EOL>                        current = parent;<EOL>                        p = p.release();<EOL>                        gp = p.","gt":"parent;"}
{"input":"<s> /**<EOL> * Removes the specified key from the tree. If the key was not in the tree, no changes are made, and the original tree<EOL> * is returned.<EOL> *<EOL> * @export<EOL> * @template K The type of keys in the tree<EOL> * @template V The type of values in the tree<EOL> * @param {K} key The key of the entry to be removed<EOL> * @param {RedBlackTreeStructure<K, V>} tree The tree to be updated<EOL> * @returns {RedBlackTreeStructure<K, V>} An updated copy of the tree, or the same tree if the input tree was already mutable<EOL> */<EOL>export function remove<K, V = null>(key: K, tree: RedBlackTreeStructure<K, V>): RedBlackTreeStructure<K, V> {<EOL>    if (tree._size === <NUM_LIT>) {<EOL>        return tree;<EOL>    }<EOL>    var originalTree = tree;<EOL>    tree = C.modify(tree);<EOL>    C.modifyProperty(tree, '<STR_LIT>');<EOL>    var p: PathNode<K, V> = findPath(tree, key, tree._root, tree._compare);<EOL>    if (p.next !== BRANCH.NONE) {<EOL>        PathNode.release(p, tree._root);<EOL>        return originalTree;<EOL>    }<EOL>    if (tree._size === <NUM_LIT>) {<EOL>        PathNode.release(p, tree._root);<EOL>        if (tree !== originalTree) {<EOL>            return createTree<K, V>(tree._compare);<EOL>        }<EOL>        tree._size = <NUM_LIT>;<EOL>        tree._root = NONE;<EOL>        return tree;<EOL>    }<EOL>    var current = p.node;<EOL>    var hasRight = !isNone(current._right);<EOL>    var hasLeft = !isNone(current._left);<EOL>    var debt = <NUM_LIT>;<EOL>    if (hasRight || hasLeft) {<EOL>        if (hasRight) {<EOL>            if (hasLeft) {<EOL>                p = findSuccessor(tree, p);<EOL>                swapNodeContents(p.node, current);<EOL>                current = p.node;<EOL>            }<EOL>            debt = current._red ? <NUM_LIT> : <NUM_LIT>;<EOL>            current = editRightChild(tree, current);<EOL>        }<EOL>        else if (hasLeft) {<EOL>            debt = current._red ? <NUM_LIT> : <NUM_LIT>;<EOL>            current = editLeftChild(tree, current);<EOL>        }<EOL>    }<EOL>    else {<EOL>        debt = current._red ? <NUM_LIT> : <NUM_LIT>;<EOL>        current = NONE;<EOL>    }<EOL>    if (p.parent.isNone()) {<EOL>        tree._root = current;<EOL>    }<EOL>    p.replace(current);<EOL>    if (current._red && p.parent.node._red) {<EOL>        current._red = false;<EOL>        debt = <NUM_LIT>;<EOL>    }<EOL>    if (debt > <NUM_LIT>) {<EOL>        var parent = (p = p.release()).node, gp = p.parent, sibling = NONE, left = NONE, right = NONE;<EOL>        do {<EOL>            var branch = p.next;<EOL>            if (p.isNone()) {<EOL>                p.node._red = false;<EOL>                updateCount(p.node);<EOL>                debt--;<EOL>            }<EOL>            else if (branch === BRANCH.LEFT) {<EOL>                if ((sibling = editRightChild(tree, parent))._red) {<EOL>                    swapNodeColors(parent, sibling);<EOL>                    rotateLeft(gp, parent, sibling, tree);<EOL>                    p.node = sibling;<EOL>                    gp = p;<EOL>                    p = PathNode.next(parent, p, BRANCH.LEFT);<EOL>                }<EOL>                else if (!(left = sibling._left)._red && !sibling._right._red) {<EOL>                    sibling._red = true;<EOL>                    if (parent._red) {<EOL>                        parent._red = false;<EOL>                        debt--;<EOL>                        if (p.isNone()) {<EOL>                            tree._root = current;<EOL>                        }<EOL>                    }<EOL>                    else {<EOL>                        current = parent;<EOL>                        p = p.release();<EOL>                        gp = p.parent;<EOL>                        parent = p.node;<EOL>                    }<EOL>                    updateCount(parent);<EOL>                }<EOL>                else {<EOL>                    if (!sibling._right._red && left._red) {<EOL>                        left = editLeftChild(tree, sibling);<EOL>                        p.next = BRANCH.RIGHT;<EOL>                        swapNodeColors(sibling, left);<EOL>                        rotateRight(p, sibling, left, tree);<EOL>                        sibling = left;<EOL>                    }<EOL>                    right = editRightChild(tree, sibling);<EOL>                    rotateLeft(gp, parent, sibling, tree);<EOL>                    sibling._red = parent._red;<EOL>                    parent._red = false;<EOL>                    right._red = false;<EOL>                    debt--;<EOL>                }<EOL>            }<EOL>            else {<EOL>                if ((sibling = editLeftChild(tree, parent))._red) {<EOL>                    rotateRight(gp, parent, sibling, tree);<EOL>                    swapNodeColors(parent, sibling);<EOL>                    p.node = sibling;<EOL>                    gp = p;<EOL>                    p = PathNode.next(parent, p, BRANCH.RIGHT);<EOL>                }<EOL>                else if (!(right = sibling._right)._red && !sibling._left._red) {<EOL>                    sibling._red = true;<EOL>                    if (parent._red) {<EOL>                        parent._red = false;<EOL>                        debt--;<EOL>                        if (p.isNone()) {<EOL>                            tree._root = current;<EOL>                        }<EOL>                    }<EOL>                    else {<EOL>                        current = parent;<EOL>                        p = p.release();<EOL>                        gp = p.parent;<EOL>                        parent = p.node;<EOL>                    }<EOL>                    updateCount(parent);<EOL>                }<EOL>                else {<EOL>                    if (!sibling._left._red && right._red) {<EOL>","gt":"right = editRightChild(tree, sibling);"}
{"input":"<s> /**<EOL> * Removes the specified key from the tree. If the key was not in the tree, no changes are made, and the original tree<EOL> * is returned.<EOL> *<EOL> * @export<EOL> * @template K The type of keys in the tree<EOL> * @template V The type of values in the tree<EOL> * @param {K} key The key of the entry to be removed<EOL> * @param {RedBlackTreeStructure<K, V>} tree The tree to be updated<EOL> * @returns {RedBlackTreeStructure<K, V>} An updated copy of the tree, or the same tree if the input tree was already mutable<EOL> */<EOL>export function remove<K, V = null>(key: K, tree: RedBlackTreeStructure<K, V>): RedBlackTreeStructure<K, V> {<EOL>    if (tree._size === <NUM_LIT>) {<EOL>        return tree;<EOL>    }<EOL>    var originalTree = tree;<EOL>    tree = C.modify(tree);<EOL>    C.modifyProperty(tree, '<STR_LIT>');<EOL>    var p: PathNode<K, V> = findPath(tree, key, tree._root, tree._compare);<EOL>    if (p.next !== BRANCH.NONE) {<EOL>        PathNode.release(p, tree._root);<EOL>        return originalTree;<EOL>    }<EOL>    if (tree._size === <NUM_LIT>) {<EOL>        PathNode.release(p, tree._root);<EOL>        if (tree !== originalTree) {<EOL>            return createTree<K, V>(tree._compare);<EOL>        }<EOL>        tree._size = <NUM_LIT>;<EOL>        tree._root = NONE;<EOL>        return tree;<EOL>    }<EOL>    var current = p.node;<EOL>    var hasRight = !isNone(current._right);<EOL>    var hasLeft = !isNone(current._left);<EOL>    var debt = <NUM_LIT>;<EOL>    if (hasRight || hasLeft) {<EOL>        if (hasRight) {<EOL>            if (hasLeft) {<EOL>                p = findSuccessor(tree, p);<EOL>                swapNodeContents(p.node, current);<EOL>                current = p.node;<EOL>            }<EOL>            debt = current._red ? <NUM_LIT> : <NUM_LIT>;<EOL>            current = editRightChild(tree, current);<EOL>        }<EOL>        else if (hasLeft) {<EOL>            debt = current._red ? <NUM_LIT> : <NUM_LIT>;<EOL>            current = editLeftChild(tree, current);<EOL>        }<EOL>    }<EOL>    else {<EOL>        debt = current._red ? <NUM_LIT> : <NUM_LIT>;<EOL>        current = NONE;<EOL>    }<EOL>    if (p.parent.isNone()) {<EOL>        tree._root = current;<EOL>    }<EOL>    p.replace(current);<EOL>    if (current._red && p.parent.node._red) {<EOL>        current._red = false;<EOL>        debt = <NUM_LIT>;<EOL>    }<EOL>    if (debt > <NUM_LIT>) {<EOL>        var parent = (p = p.release()).node, gp = p.parent, sibling = NONE, left = NONE, right = NONE;<EOL>        do {<EOL>            var branch = p.next;<EOL>            if (p.isNone()) {<EOL>                p.node._red = false;<EOL>                updateCount(p.node);<EOL>                debt--;<EOL>            }<EOL>            else if (branch === BRANCH.LEFT) {<EOL>                if ((sibling = editRightChild(tree, parent))._red) {<EOL>                    swapNodeColors(parent, sibling);<EOL>                    rotateLeft(gp, parent, sibling, tree);<EOL>                    p.node = sibling;<EOL>                    gp = p;<EOL>                    p = PathNode.next(parent, p, BRANCH.LEFT);<EOL>                }<EOL>                else if (!(left = sibling._left)._red && !sibling._right._red) {<EOL>                    sibling._red = true;<EOL>                    if (parent._red) {<EOL>                        parent._red = false;<EOL>                        debt--;<EOL>                        if (p.isNone()) {<EOL>                            tree._root = current;<EOL>                        }<EOL>                    }<EOL>                    else {<EOL>                        current = parent;<EOL>                        p = p.release();<EOL>                        gp = p.parent;<EOL>                        parent = p.node;<EOL>                    }<EOL>                    updateCount(parent);<EOL>                }<EOL>                else {<EOL>                    if (!sibling._right._red && left._red) {<EOL>                        left = editLeftChild(tree, sibling);<EOL>                        p.next = BRANCH.RIGHT;<EOL>                        swapNodeColors(sibling, left);<EOL>                        rotateRight(p, sibling, left, tree);<EOL>                        sibling = left;<EOL>                    }<EOL>                    right = editRightChild(tree, sibling);<EOL>                    rotateLeft(gp, parent, sibling, tree);<EOL>                    sibling._red = parent._red;<EOL>                    parent._red = false;<EOL>                    right._red = false;<EOL>                    debt--;<EOL>                }<EOL>            }<EOL>            else {<EOL>                if ((sibling = editLeftChild(tree, parent))._red) {<EOL>                    rotateRight(gp, parent, sibling, tree);<EOL>                    swapNodeColors(parent, sibling);<EOL>                    p.node = sibling;<EOL>                    gp = p;<EOL>                    p = PathNode.next(parent, p, BRANCH.RIGHT);<EOL>                }<EOL>                else if (!(right = sibling._right)._red && !sibling._left._red) {<EOL>                    sibling._red = true;<EOL>                    if (parent._red) {<EOL>                        parent._red = false;<EOL>                        debt--;<EOL>                        if (p.isNone()) {<EOL>                            tree._root = current;<EOL>                        }<EOL>                    }<EOL>                    else {<EOL>                        current = parent;<EOL>                        p = p.release();<EOL>                        gp = p.parent;<EOL>                        parent = p.node;<EOL>                    }<EOL>                    updateCount(parent);<EOL>                }<EOL>                else {<EOL>                    if (!sibling._left._red && right._red) {<EOL>                        right = editRightChild(tree, sibling);<EOL>                        p.","gt":"next = BRANCH.LEFT;"}
{"input":"<s> /**<EOL> * Removes the specified key from the tree. If the key was not in the tree, no changes are made, and the original tree<EOL> * is returned.<EOL> *<EOL> * @export<EOL> * @template K The type of keys in the tree<EOL> * @template V The type of values in the tree<EOL> * @param {K} key The key of the entry to be removed<EOL> * @param {RedBlackTreeStructure<K, V>} tree The tree to be updated<EOL> * @returns {RedBlackTreeStructure<K, V>} An updated copy of the tree, or the same tree if the input tree was already mutable<EOL> */<EOL>export function remove<K, V = null>(key: K, tree: RedBlackTreeStructure<K, V>): RedBlackTreeStructure<K, V> {<EOL>    if (tree._size === <NUM_LIT>) {<EOL>        return tree;<EOL>    }<EOL>    var originalTree = tree;<EOL>    tree = C.modify(tree);<EOL>    C.modifyProperty(tree, '<STR_LIT>');<EOL>    var p: PathNode<K, V> = findPath(tree, key, tree._root, tree._compare);<EOL>    if (p.next !== BRANCH.NONE) {<EOL>        PathNode.release(p, tree._root);<EOL>        return originalTree;<EOL>    }<EOL>    if (tree._size === <NUM_LIT>) {<EOL>        PathNode.release(p, tree._root);<EOL>        if (tree !== originalTree) {<EOL>            return createTree<K, V>(tree._compare);<EOL>        }<EOL>        tree._size = <NUM_LIT>;<EOL>        tree._root = NONE;<EOL>        return tree;<EOL>    }<EOL>    var current = p.node;<EOL>    var hasRight = !isNone(current._right);<EOL>    var hasLeft = !isNone(current._left);<EOL>    var debt = <NUM_LIT>;<EOL>    if (hasRight || hasLeft) {<EOL>        if (hasRight) {<EOL>            if (hasLeft) {<EOL>                p = findSuccessor(tree, p);<EOL>                swapNodeContents(p.node, current);<EOL>                current = p.node;<EOL>            }<EOL>            debt = current._red ? <NUM_LIT> : <NUM_LIT>;<EOL>            current = editRightChild(tree, current);<EOL>        }<EOL>        else if (hasLeft) {<EOL>            debt = current._red ? <NUM_LIT> : <NUM_LIT>;<EOL>            current = editLeftChild(tree, current);<EOL>        }<EOL>    }<EOL>    else {<EOL>        debt = current._red ? <NUM_LIT> : <NUM_LIT>;<EOL>        current = NONE;<EOL>    }<EOL>    if (p.parent.isNone()) {<EOL>        tree._root = current;<EOL>    }<EOL>    p.replace(current);<EOL>    if (current._red && p.parent.node._red) {<EOL>        current._red = false;<EOL>        debt = <NUM_LIT>;<EOL>    }<EOL>    if (debt > <NUM_LIT>) {<EOL>        var parent = (p = p.release()).node, gp = p.parent, sibling = NONE, left = NONE, right = NONE;<EOL>        do {<EOL>            var branch = p.next;<EOL>            if (p.isNone()) {<EOL>                p.node._red = false;<EOL>                updateCount(p.node);<EOL>                debt--;<EOL>            }<EOL>            else if (branch === BRANCH.LEFT) {<EOL>                if ((sibling = editRightChild(tree, parent))._red) {<EOL>                    swapNodeColors(parent, sibling);<EOL>                    rotateLeft(gp, parent, sibling, tree);<EOL>                    p.node = sibling;<EOL>                    gp = p;<EOL>                    p = PathNode.next(parent, p, BRANCH.LEFT);<EOL>                }<EOL>                else if (!(left = sibling._left)._red && !sibling._right._red) {<EOL>                    sibling._red = true;<EOL>                    if (parent._red) {<EOL>                        parent._red = false;<EOL>                        debt--;<EOL>                        if (p.isNone()) {<EOL>                            tree._root = current;<EOL>                        }<EOL>                    }<EOL>                    else {<EOL>                        current = parent;<EOL>                        p = p.release();<EOL>                        gp = p.parent;<EOL>                        parent = p.node;<EOL>                    }<EOL>                    updateCount(parent);<EOL>                }<EOL>                else {<EOL>                    if (!sibling._right._red && left._red) {<EOL>                        left = editLeftChild(tree, sibling);<EOL>                        p.next = BRANCH.RIGHT;<EOL>                        swapNodeColors(sibling, left);<EOL>                        rotateRight(p, sibling, left, tree);<EOL>                        sibling = left;<EOL>                    }<EOL>                    right = editRightChild(tree, sibling);<EOL>                    rotateLeft(gp, parent, sibling, tree);<EOL>                    sibling._red = parent._red;<EOL>                    parent._red = false;<EOL>                    right._red = false;<EOL>                    debt--;<EOL>                }<EOL>            }<EOL>            else {<EOL>                if ((sibling = editLeftChild(tree, parent))._red) {<EOL>                    rotateRight(gp, parent, sibling, tree);<EOL>                    swapNodeColors(parent, sibling);<EOL>                    p.node = sibling;<EOL>                    gp = p;<EOL>                    p = PathNode.next(parent, p, BRANCH.RIGHT);<EOL>                }<EOL>                else if (!(right = sibling._right)._red && !sibling._left._red) {<EOL>                    sibling._red = true;<EOL>                    if (parent._red) {<EOL>                        parent._red = false;<EOL>                        debt--;<EOL>                        if (p.isNone()) {<EOL>                            tree._root = current;<EOL>                        }<EOL>                    }<EOL>                    else {<EOL>                        current = parent;<EOL>                        p = p.release();<EOL>                        gp = p.parent;<EOL>                        parent = p.node;<EOL>                    }<EOL>                    updateCount(parent);<EOL>                }<EOL>                else {<EOL>                    if (!sibling._left._red && right._red) {<EOL>                        right = editRightChild(tree, sibling);<EOL>                        p.next = BRANCH.LEFT;<EOL>                        swapNodeColors(sibling,","gt":"right);"}
{"input":"<s> /**<EOL> * Removes the specified key from the tree. If the key was not in the tree, no changes are made, and the original tree<EOL> * is returned.<EOL> *<EOL> * @export<EOL> * @template K The type of keys in the tree<EOL> * @template V The type of values in the tree<EOL> * @param {K} key The key of the entry to be removed<EOL> * @param {RedBlackTreeStructure<K, V>} tree The tree to be updated<EOL> * @returns {RedBlackTreeStructure<K, V>} An updated copy of the tree, or the same tree if the input tree was already mutable<EOL> */<EOL>export function remove<K, V = null>(key: K, tree: RedBlackTreeStructure<K, V>): RedBlackTreeStructure<K, V> {<EOL>    if (tree._size === <NUM_LIT>) {<EOL>        return tree;<EOL>    }<EOL>    var originalTree = tree;<EOL>    tree = C.modify(tree);<EOL>    C.modifyProperty(tree, '<STR_LIT>');<EOL>    var p: PathNode<K, V> = findPath(tree, key, tree._root, tree._compare);<EOL>    if (p.next !== BRANCH.NONE) {<EOL>        PathNode.release(p, tree._root);<EOL>        return originalTree;<EOL>    }<EOL>    if (tree._size === <NUM_LIT>) {<EOL>        PathNode.release(p, tree._root);<EOL>        if (tree !== originalTree) {<EOL>            return createTree<K, V>(tree._compare);<EOL>        }<EOL>        tree._size = <NUM_LIT>;<EOL>        tree._root = NONE;<EOL>        return tree;<EOL>    }<EOL>    var current = p.node;<EOL>    var hasRight = !isNone(current._right);<EOL>    var hasLeft = !isNone(current._left);<EOL>    var debt = <NUM_LIT>;<EOL>    if (hasRight || hasLeft) {<EOL>        if (hasRight) {<EOL>            if (hasLeft) {<EOL>                p = findSuccessor(tree, p);<EOL>                swapNodeContents(p.node, current);<EOL>                current = p.node;<EOL>            }<EOL>            debt = current._red ? <NUM_LIT> : <NUM_LIT>;<EOL>            current = editRightChild(tree, current);<EOL>        }<EOL>        else if (hasLeft) {<EOL>            debt = current._red ? <NUM_LIT> : <NUM_LIT>;<EOL>            current = editLeftChild(tree, current);<EOL>        }<EOL>    }<EOL>    else {<EOL>        debt = current._red ? <NUM_LIT> : <NUM_LIT>;<EOL>        current = NONE;<EOL>    }<EOL>    if (p.parent.isNone()) {<EOL>        tree._root = current;<EOL>    }<EOL>    p.replace(current);<EOL>    if (current._red && p.parent.node._red) {<EOL>        current._red = false;<EOL>        debt = <NUM_LIT>;<EOL>    }<EOL>    if (debt > <NUM_LIT>) {<EOL>        var parent = (p = p.release()).node, gp = p.parent, sibling = NONE, left = NONE, right = NONE;<EOL>        do {<EOL>            var branch = p.next;<EOL>            if (p.isNone()) {<EOL>                p.node._red = false;<EOL>                updateCount(p.node);<EOL>                debt--;<EOL>            }<EOL>            else if (branch === BRANCH.LEFT) {<EOL>                if ((sibling = editRightChild(tree, parent))._red) {<EOL>                    swapNodeColors(parent, sibling);<EOL>                    rotateLeft(gp, parent, sibling, tree);<EOL>                    p.node = sibling;<EOL>                    gp = p;<EOL>                    p = PathNode.next(parent, p, BRANCH.LEFT);<EOL>                }<EOL>                else if (!(left = sibling._left)._red && !sibling._right._red) {<EOL>                    sibling._red = true;<EOL>                    if (parent._red) {<EOL>                        parent._red = false;<EOL>                        debt--;<EOL>                        if (p.isNone()) {<EOL>                            tree._root = current;<EOL>                        }<EOL>                    }<EOL>                    else {<EOL>                        current = parent;<EOL>                        p = p.release();<EOL>                        gp = p.parent;<EOL>                        parent = p.node;<EOL>                    }<EOL>                    updateCount(parent);<EOL>                }<EOL>                else {<EOL>                    if (!sibling._right._red && left._red) {<EOL>                        left = editLeftChild(tree, sibling);<EOL>                        p.next = BRANCH.RIGHT;<EOL>                        swapNodeColors(sibling, left);<EOL>                        rotateRight(p, sibling, left, tree);<EOL>                        sibling = left;<EOL>                    }<EOL>                    right = editRightChild(tree, sibling);<EOL>                    rotateLeft(gp, parent, sibling, tree);<EOL>                    sibling._red = parent._red;<EOL>                    parent._red = false;<EOL>                    right._red = false;<EOL>                    debt--;<EOL>                }<EOL>            }<EOL>            else {<EOL>                if ((sibling = editLeftChild(tree, parent))._red) {<EOL>                    rotateRight(gp, parent, sibling, tree);<EOL>                    swapNodeColors(parent, sibling);<EOL>                    p.node = sibling;<EOL>                    gp = p;<EOL>                    p = PathNode.next(parent, p, BRANCH.RIGHT);<EOL>                }<EOL>                else if (!(right = sibling._right)._red && !sibling._left._red) {<EOL>                    sibling._red = true;<EOL>                    if (parent._red) {<EOL>                        parent._red = false;<EOL>                        debt--;<EOL>                        if (p.isNone()) {<EOL>                            tree._root = current;<EOL>                        }<EOL>                    }<EOL>                    else {<EOL>                        current = parent;<EOL>                        p = p.release();<EOL>                        gp = p.parent;<EOL>                        parent = p.node;<EOL>                    }<EOL>                    updateCount(parent);<EOL>                }<EOL>                else {<EOL>                    if (!sibling._left._red && right._red) {<EOL>                        right = editRightChild(tree, sibling);<EOL>                        p.next = BRANCH.LEFT;<EOL>                        swapNodeColors(sibling, right);<EOL>                        rotateLeft(p, sibling, right, tree);<EOL>                        sibling = right;<EOL>                    }<EOL>                    left = editLeftChild(tree, sibling);<EOL>                    rotateRight(gp, parent, sibling, tree);<EOL>","gt":"sibling._red = parent._red;"}
{"input":"<s> export function getStyles(context: string): string[] {<EOL>    if (getStylesOverride)<EOL>        return getStylesOverride(context);<EOL>    const textEditorStyles = document.createElement('<STR_LIT>')","gt":"as HTMLElement & {"}
{"input":"<s> <EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL>export function bubbleToContainerElement(element: HTMLElement): HTMLElement {<EOL>    let testElement = element;<EOL>    for (;;) {<EOL>        const parent = testElement.parentElement;<EOL>        if (!parent)<EOL>","gt":"break;"}
{"input":"<s> function registerGrammars(grammars: string[], disp: CompositeDisposable, cm: ContextMenu) {<EOL>    for (const gr of grammars) {<EOL>        const grs = gr.replace(/\\./g, '<STR_LIT>');<EOL>        const selector = `<STR_LIT>`;<EOL>        disp.add(atom.commands.add(selector as '<STR_LIT>', {<EOL>            '<STR_LIT>': (e) => {<EOL>                toggle(e.","gt":"currentTarget.getModel());"}
{"input":"<s> function registerGrammars(grammars: string[], disp: CompositeDisposable, cm: ContextMenu) {<EOL>    for (const gr of grammars) {<EOL>        const grs = gr.replace(/\\./g, '<STR_LIT>');<EOL>        const selector = `<STR_LIT>`;<EOL>        disp.add(atom.commands.add(selector as '<STR_LIT>', {<EOL>            '<STR_LIT>': (e) => {<EOL>                toggle(e.currentTarget.getModel());<EOL>            },<EOL>            '<STR_LIT>': (e) => {<EOL>                handlePromise(copyHtmlInternal(e.currentTarget.getModel()));<EOL>            },<EOL>        }));<EOL>        cm[selector] = [<EOL>            {<EOL>                label:","gt":"'<STR_LIT>',"}
{"input":"<s> function getImageData(name: string): string {<EOL>    return","gt":"images[name].data;"}
{"input":"<s> function createLargeProjectMonitorForProject(item: ExcludeHintItem, client: ITypeScriptServiceClient, isOpen: (path: string) => Promise<boolean>, memento: vscode.Memento): vscode.Disposable[] {<EOL>    const toDispose: vscode.Disposable[] = [];<EOL>    const","gt":"projectHinted: ProjectHintedMap = Object.create(null);"}
{"input":"<s> function createLargeProjectMonitorForProject(item: ExcludeHintItem, client: ITypeScriptServiceClient, isOpen: (path: string) => Promise<boolean>, memento: vscode.Memento): vscode.Disposable[] {<EOL>    const toDispose: vscode.Disposable[] = [];<EOL>    const projectHinted: ProjectHintedMap = Object.create(null);<EOL>    const projectHintIgnoreList = memento.get<string[]>('<STR_LIT>', []);<EOL>    for (let path of projectHintIgnoreList) {<EOL>        if (","gt":"path === null) {"}
{"input":"<s> function createLargeProjectMonitorForProject(item: ExcludeHintItem, client: ITypeScriptServiceClient, isOpen: (path: string) => Promise<boolean>, memento: vscode.Memento): vscode.Disposable[] {<EOL>    const toDispose: vscode.Disposable[] = [];<EOL>    const projectHinted: ProjectHintedMap = Object.create(null);<EOL>    const projectHintIgnoreList = memento.get<string[]>('<STR_LIT>', []);<EOL>    for (let path of projectHintIgnoreList) {<EOL>        if (path === null) {<EOL>            path = '<STR_LIT>';<EOL>        }<EOL>        projectHinted[path] = true;<EOL>    }<EOL>    function","gt":"onEditor(editor: vscode.TextEditor | undefined): void {"}
{"input":"<s> function createLargeProjectMonitorForProject(item: ExcludeHintItem, client: ITypeScriptServiceClient, isOpen: (path: string) => Promise<boolean>, memento: vscode.Memento): vscode.Disposable[] {<EOL>    const toDispose: vscode.Disposable[] = [];<EOL>    const projectHinted: ProjectHintedMap = Object.create(null);<EOL>    const projectHintIgnoreList = memento.get<string[]>('<STR_LIT>', []);<EOL>    for (let path of projectHintIgnoreList) {<EOL>        if (path === null) {<EOL>            path = '<STR_LIT>';<EOL>        }<EOL>        projectHinted[path] = true;<EOL>    }<EOL>    function onEditor(editor: vscode.TextEditor | undefined): void {<EOL>        if (!editor<EOL>            || !vscode.languages.match(selector, editor.document)<EOL>            || !client.normalizePath(editor.document.uri)) {<EOL>            item.hide();<EOL>","gt":"return;"}
{"input":"<s> function createLargeProjectMonitorForProject(item: ExcludeHintItem, client: ITypeScriptServiceClient, isOpen: (path: string) => Promise<boolean>, memento: vscode.Memento): vscode.Disposable[] {<EOL>    const toDispose: vscode.Disposable[] = [];<EOL>    const projectHinted: ProjectHintedMap = Object.create(null);<EOL>    const projectHintIgnoreList = memento.get<string[]>('<STR_LIT>', []);<EOL>    for (let path of projectHintIgnoreList) {<EOL>        if (path === null) {<EOL>            path = '<STR_LIT>';<EOL>        }<EOL>        projectHinted[path] = true;<EOL>    }<EOL>    function onEditor(editor: vscode.TextEditor | undefined): void {<EOL>        if (!editor<EOL>            || !vscode.languages.match(selector, editor.document)<EOL>            || !client.normalizePath(editor.document.uri)) {<EOL>            item.hide();<EOL>            return;<EOL>        }<EOL>        const file = client.normalizePath(editor.document.uri);<EOL>        if (!file) {<EOL>            return;<EOL>        }<EOL>        isOpen(file).then(","gt":"value => {"}
{"input":"<s> function createLargeProjectMonitorForProject(item: ExcludeHintItem, client: ITypeScriptServiceClient, isOpen: (path: string) => Promise<boolean>, memento: vscode.Memento): vscode.Disposable[] {<EOL>    const toDispose: vscode.Disposable[] = [];<EOL>    const projectHinted: ProjectHintedMap = Object.create(null);<EOL>    const projectHintIgnoreList = memento.get<string[]>('<STR_LIT>', []);<EOL>    for (let path of projectHintIgnoreList) {<EOL>        if (path === null) {<EOL>            path = '<STR_LIT>';<EOL>        }<EOL>        projectHinted[path] = true;<EOL>    }<EOL>    function onEditor(editor: vscode.TextEditor | undefined): void {<EOL>        if (!editor<EOL>            || !vscode.languages.match(selector, editor.document)<EOL>            || !client.normalizePath(editor.document.uri)) {<EOL>            item.hide();<EOL>            return;<EOL>        }<EOL>        const file = client.normalizePath(editor.document.uri);<EOL>        if (!file) {<EOL>            return;<EOL>        }<EOL>        isOpen(file).then(value => {<EOL>            if (!value) {<EOL>                return;<EOL>            }<EOL>            return client.execute('<STR_LIT>', { file, needFileNameList: true } as protocol.ProjectInfoRequestArgs).then(res => {<EOL>                if (!res.body) {<EOL>","gt":"return;"}
{"input":"<s> function createLargeProjectMonitorForProject(item: ExcludeHintItem, client: ITypeScriptServiceClient, isOpen: (path: string) => Promise<boolean>, memento: vscode.Memento): vscode.Disposable[] {<EOL>    const toDispose: vscode.Disposable[] = [];<EOL>    const projectHinted: ProjectHintedMap = Object.create(null);<EOL>    const projectHintIgnoreList = memento.get<string[]>('<STR_LIT>', []);<EOL>    for (let path of projectHintIgnoreList) {<EOL>        if (path === null) {<EOL>            path = '<STR_LIT>';<EOL>        }<EOL>        projectHinted[path] = true;<EOL>    }<EOL>    function onEditor(editor: vscode.TextEditor | undefined): void {<EOL>        if (!editor<EOL>            || !vscode.languages.match(selector, editor.document)<EOL>            || !client.normalizePath(editor.document.uri)) {<EOL>            item.hide();<EOL>            return;<EOL>        }<EOL>        const file = client.normalizePath(editor.document.uri);<EOL>        if (!file) {<EOL>            return;<EOL>        }<EOL>        isOpen(file).then(value => {<EOL>            if (!value) {<EOL>                return;<EOL>            }<EOL>            return client.execute('<STR_LIT>', { file, needFileNameList: true } as protocol.ProjectInfoRequestArgs).then(res => {<EOL>                if (!res.body) {<EOL>                    return;<EOL>                }<EOL>                let { configFileName, fileNames } = res.body;<EOL>                if (projectHinted[configFileName] === true || !fileNames) {<EOL>                    return;<EOL>                }<EOL>                if (fileNames.length > fileLimit || res.body.languageServiceDisabled) {<EOL>                    let largeRoots = computeLargeRoots(configFileName, fileNames).map(f => `<STR_LIT>`).join('<STR_LIT>');<EOL>                    item.show(largeRoots);<EOL>                    projectHinted[configFileName] = true;<EOL>                }<EOL>","gt":"else {"}
{"input":"<s> function createLargeProjectMonitorForProject(item: ExcludeHintItem, client: ITypeScriptServiceClient, isOpen: (path: string) => Promise<boolean>, memento: vscode.Memento): vscode.Disposable[] {<EOL>    const toDispose: vscode.Disposable[] = [];<EOL>    const projectHinted: ProjectHintedMap = Object.create(null);<EOL>    const projectHintIgnoreList = memento.get<string[]>('<STR_LIT>', []);<EOL>    for (let path of projectHintIgnoreList) {<EOL>        if (path === null) {<EOL>            path = '<STR_LIT>';<EOL>        }<EOL>        projectHinted[path] = true;<EOL>    }<EOL>    function onEditor(editor: vscode.TextEditor | undefined): void {<EOL>        if (!editor<EOL>            || !vscode.languages.match(selector, editor.document)<EOL>            || !client.normalizePath(editor.document.uri)) {<EOL>            item.hide();<EOL>            return;<EOL>        }<EOL>        const file = client.normalizePath(editor.document.uri);<EOL>        if (!file) {<EOL>            return;<EOL>        }<EOL>        isOpen(file).then(value => {<EOL>            if (!value) {<EOL>                return;<EOL>            }<EOL>            return client.execute('<STR_LIT>', { file, needFileNameList: true } as protocol.ProjectInfoRequestArgs).then(res => {<EOL>                if (!res.body) {<EOL>                    return;<EOL>                }<EOL>                let { configFileName, fileNames } = res.body;<EOL>                if (projectHinted[configFileName] === true || !fileNames) {<EOL>                    return;<EOL>                }<EOL>                if (fileNames.length > fileLimit || res.body.languageServiceDisabled) {<EOL>                    let largeRoots = computeLargeRoots(configFileName, fileNames).map(f => `<STR_LIT>`).join('<STR_LIT>');<EOL>                    item.show(largeRoots);<EOL>                    projectHinted[configFileName] = true;<EOL>                }<EOL>                else {<EOL>                    item.hide();<EOL>                }<EOL>            });<EOL>        }).catch(err => {<EOL>            client.logger.","gt":"warn(err);"}
{"input":"<s> function checkMacros(macrosObject: object) {<EOL>    const namePattern = /^[^a-zA-Z\\d\\s]$|^[a-zA-Z]*$/; <EOL>    for (const name in macrosObject) {<EOL>        const","gt":"value = macrosObject[name];"}
{"input":"<s> export function getPrevPagedQuestions() {<EOL>    return (dispatch, getState) => {<EOL>        const {","gt":"previousPagedQuestions } = getState();"}
{"input":"<s> function toKey<K, U>(item: SortingKey<K, U>): K {<EOL>    return item.","gt":"key;"}
{"input":"<s> function init() {<EOL>    const rootEl = document.querySelector('<STR_LIT>');<EOL>    rootEl.textContent = '<STR_LIT>';<EOL>    tree =","gt":"new TreeComponent(rootEl);"}
{"input":"<s> export function generateOpportunity(seed: number): Opportunity {<EOL>    const res =","gt":"new Opportunity();"}
{"input":"<s> function pairFromNumber(n: number): [<EOL>    number,<EOL>    string<EOL>] {<EOL>    return [","gt":"n, `<STR_LIT>`];"}
{"input":"<s> export function iterateValues<K, V, U>(map: SortedMapStructure<K, V, U>): IterableIterator<V> {<EOL>    return values(map.","gt":"_sorted);"}
{"input":"<s> function getFoo1(): Foo {<EOL>    return {<EOL>        method1(arg) {<EOL>            arg.numProp =","gt":"<NUM_LIT>;"}
{"input":"<s> /** Returns a string that formats the graph of circular modules. */<EOL>function formatMadgeCircularModules(circularModules: string[][]): string {<EOL>    return circularModules.map((modulePaths: string[]) =>","gt":"join('<STR_LIT>')}`<STR_LIT>;"}
{"input":"<s> export function createWatchEvent(filePath: string, fs = nodeFs): IWatchEvent {<EOL>    return {<EOL>        path:","gt":"filePath,"}
{"input":"<s> export function replaceMappedCSSAssetPlaceholders({ stylableBuildData, staticPublicPath, assetsModules, chunkGraph, moduleGraph, runtime, runtimeTemplate, dependencyTemplates, }: ReplaceMappedCSSAssetPlaceholdersOptions) {<EOL>    return replaceCSSAssetPlaceholders(stylableBuildData, staticPublicPath, (resourcePath, publicPath) => {<EOL>        const assetModule = assetsModules.get(resourcePath);<EOL>        if (!assetModule) {<EOL>            throw new Error('<STR_LIT>' + resourcePath);<EOL>        }<EOL>        if (isLoadedWithKnownAssetLoader(assetModule)) {<EOL>            return extractFilenameFromAssetModule(assetModule, publicPath);<EOL>        }<EOL>","gt":"else {"}
{"input":"<s> export function replaceMappedCSSAssetPlaceholders({ stylableBuildData, staticPublicPath, assetsModules, chunkGraph, moduleGraph, runtime, runtimeTemplate, dependencyTemplates, }: ReplaceMappedCSSAssetPlaceholdersOptions) {<EOL>    return replaceCSSAssetPlaceholders(stylableBuildData, staticPublicPath, (resourcePath, publicPath) => {<EOL>        const assetModule = assetsModules.get(resourcePath);<EOL>        if (!assetModule) {<EOL>            throw new Error('<STR_LIT>' + resourcePath);<EOL>        }<EOL>        if (isLoadedWithKnownAssetLoader(assetModule)) {<EOL>            return extractFilenameFromAssetModule(assetModule, publicPath);<EOL>        }<EOL>        else {<EOL>            const data = new Map<string, unknown>();<EOL>            const assetModuleSource = assetModule.generator.generate(assetModule, {<EOL>","gt":"chunkGraph,"}
{"input":"<s> export function replaceMappedCSSAssetPlaceholders({ stylableBuildData, staticPublicPath, assetsModules, chunkGraph, moduleGraph, runtime, runtimeTemplate, dependencyTemplates, }: ReplaceMappedCSSAssetPlaceholdersOptions) {<EOL>    return replaceCSSAssetPlaceholders(stylableBuildData, staticPublicPath, (resourcePath, publicPath) => {<EOL>        const assetModule = assetsModules.get(resourcePath);<EOL>        if (!assetModule) {<EOL>            throw new Error('<STR_LIT>' + resourcePath);<EOL>        }<EOL>        if (isLoadedWithKnownAssetLoader(assetModule)) {<EOL>            return extractFilenameFromAssetModule(assetModule, publicPath);<EOL>        }<EOL>        else {<EOL>            const data = new Map<string, unknown>();<EOL>            const assetModuleSource = assetModule.generator.generate(assetModule, {<EOL>                chunkGraph,<EOL>                moduleGraph,<EOL>                runtime,<EOL>                runtimeRequirements: new","gt":"Set(),"}
{"input":"<s> export function replaceMappedCSSAssetPlaceholders({ stylableBuildData, staticPublicPath, assetsModules, chunkGraph, moduleGraph, runtime, runtimeTemplate, dependencyTemplates, }: ReplaceMappedCSSAssetPlaceholdersOptions) {<EOL>    return replaceCSSAssetPlaceholders(stylableBuildData, staticPublicPath, (resourcePath, publicPath) => {<EOL>        const assetModule = assetsModules.get(resourcePath);<EOL>        if (!assetModule) {<EOL>            throw new Error('<STR_LIT>' + resourcePath);<EOL>        }<EOL>        if (isLoadedWithKnownAssetLoader(assetModule)) {<EOL>            return extractFilenameFromAssetModule(assetModule, publicPath);<EOL>        }<EOL>        else {<EOL>            const data = new Map<string, unknown>();<EOL>            const assetModuleSource = assetModule.generator.generate(assetModule, {<EOL>                chunkGraph,<EOL>                moduleGraph,<EOL>                runtime,<EOL>                runtimeRequirements: new Set(),<EOL>                runtimeTemplate,<EOL>                dependencyTemplates,<EOL>                type: '<STR_LIT>',<EOL>                getData: () => data,<EOL>            });<EOL>            if (assetModule.","gt":"buildInfo.dataUrl) {"}
{"input":"<s> function removeLocationMarkers(value: string): string {<EOL>    return value.","gt":"replace(locationMarker, '<STR_LIT>');"}
{"input":"<s> function error(t0: Type, t1: Type) {<EOL>    currErrs += \"<STR_LIT>\" + t2s(","gt":"t0) + \"<STR_LIT>\" + t2s(t1) + \"<STR_LIT>\";"}
{"input":"<s> function nullContent(o: any) {<EOL>    (Array.isArray(o) ? o : Object.keys(o)).forEach((k) => {<EOL>        if (k === '<STR_LIT>') {<EOL>            o[","gt":"k] = null;"}
{"input":"<s> function listCollaborators(commandName: string, yargs: yargs.Argv): void {<EOL>    isValidCommand = true;<EOL>    yargs.usage(USAGE_PREFIX + \"<STR_LIT>\" + commandName + \"<STR_LIT>\")<EOL>        .demand( <NUM_LIT>,","gt":"<NUM_LIT>)"}
{"input":"<s> /**<EOL> * Parse a JSON string into its value.  This discards the AST and only returns the value itself.<EOL> * @param input The string to parse.<EOL> * @param mode The mode to parse the input with. {@see JsonParseMode}.<EOL> * @returns {JsonValue} The value represented by the JSON string.<EOL> */<EOL>export function parseJson(input: string, mode = JsonParseMode.Default): JsonValue {<EOL>    <EOL>    if (mode == JsonParseMode.Strict) {<EOL>        try {<EOL>            return JSON.","gt":"parse(input);"}
{"input":"<s> export function at<K, V, U>(index: number, map: SortedMapStructure<K, V, U>): [<EOL>    K,<EOL>    V<EOL>] | undefined {<EOL>","gt":"return getItemByIndex(index, map._sorted);"}
{"input":"<s> export function utf8Encode(str: string): string {<EOL>    let encoded = '<STR_LIT>';<EOL>    for (let index = <NUM_LIT>; index < str.length; index++) {<EOL>        let codePoint = str.charCodeAt(index);<EOL>        <EOL>        <EOL>        if (codePoint >= <NUM_LIT> && codePoint <= <NUM_LIT> && str.length > (index + <NUM_LIT>)) {<EOL>            const low = str.charCodeAt(index + <NUM_LIT>);<EOL>","gt":"if (low >= <NUM_LIT> && low <= <NUM_LIT>) {"}
{"input":"<s> export function utf8Encode(str: string): string {<EOL>    let encoded = '<STR_LIT>';<EOL>    for (let index = <NUM_LIT>; index < str.length; index++) {<EOL>        let codePoint = str.charCodeAt(index);<EOL>        <EOL>        <EOL>        if (codePoint >= <NUM_LIT> && codePoint <= <NUM_LIT> && str.length > (index + <NUM_LIT>)) {<EOL>            const low = str.charCodeAt(index + <NUM_LIT>);<EOL>            if (low >= <NUM_LIT> && low <= <NUM_LIT>) {<EOL>                index++;<EOL>                codePoint = ((codePoint - <NUM_LIT>) << <NUM_LIT>) + low - <NUM_LIT> + <NUM_LIT>;<EOL>            }<EOL>        }<EOL>        if (codePoint <= <NUM_LIT>) {<EOL>            encoded += String.fromCharCode(","gt":"codePoint);"}
{"input":"<s> export function utf8Encode(str: string): string {<EOL>    let encoded = '<STR_LIT>';<EOL>    for (let index = <NUM_LIT>; index < str.length; index++) {<EOL>        let codePoint = str.charCodeAt(index);<EOL>        <EOL>        <EOL>        if (codePoint >= <NUM_LIT> && codePoint <= <NUM_LIT> && str.length > (index + <NUM_LIT>)) {<EOL>            const low = str.charCodeAt(index + <NUM_LIT>);<EOL>            if (low >= <NUM_LIT> && low <= <NUM_LIT>) {<EOL>                index++;<EOL>                codePoint = ((codePoint - <NUM_LIT>) << <NUM_LIT>) + low - <NUM_LIT> + <NUM_LIT>;<EOL>            }<EOL>        }<EOL>        if (codePoint <= <NUM_LIT>) {<EOL>            encoded += String.fromCharCode(codePoint);<EOL>        }<EOL>        else if (codePoint <= <NUM_LIT>) {<EOL>            encoded += String.fromCharCode(((codePoint >> <NUM_LIT>) & <NUM_LIT>) | <NUM_LIT>, (codePoint & <NUM_LIT>) | <NUM_LIT>);<EOL>        }<EOL>        else if (codePoint <= <NUM_LIT>) {<EOL>            encoded += String.","gt":"fromCharCode((codePoint >> <NUM_LIT>) | <NUM_LIT>, ((codePoint >> <NUM_LIT>) & <NUM_LIT>) | <NUM_LIT>, (codePoint & <NUM_LIT>) | <NUM_LIT>);"}
{"input":"<s> export function spODataEntityArray<T>(factory: SharePointQueryableConstructor<T>): ODataParser<T[]> {<EOL>","gt":"return new SPODataEntityArrayParserImpl(factory);"}
{"input":"<s> /**<EOL> * @license<EOL> * Copyright Google LLC All Rights Reserved.<EOL> *<EOL> * Use of this source code is governed by an MIT-style license that can be<EOL> * found in the LICENSE file at https://angular.io/license<EOL> */<EOL>/** Coerces a data-bound value (typically a string) to a boolean. */<EOL>export function coerceBooleanProperty(value: any): boolean {<EOL>    return value != null &&","gt":"value}`<STR_LIT>;"}
{"input":"<s> function getNodes(treeElement: Element): Element[] {<EOL>    return [].slice.call(treeElement.querySelectorAll(","gt":"'<STR_LIT>'))!;"}
{"input":"<s> export default function SystemStatusReducer(state: SystemStatus = defaultStatus, action: any = { type: \"<STR_LIT>\" }) {<EOL>    /**<EOL>     *<EOL>     *<EOL>     * DO NOT UNCOMMENTS<EOL>     *     CAUSING INFINITE LOOP<EOL>     *<EOL>     *<EOL>     *<EOL>     *<EOL>     */<EOL>    const newstate = _.clone(state);<EOL>    if (action.type.startsWith(\"<STR_LIT>\")) {<EOL>        newstate.currentAction = action.","gt":"type;"}
{"input":"<s> function fakeOverlayRef(overlayElement: HTMLElement) {<EOL>    return { overlayElement }","gt":"as OverlayRef;"}
{"input":"<s> export function newCache() {<EOL>    return","gt":"new Map<string, number>();"}
{"input":"<s> function isInterestingEditorModel(editor: ICodeEditor): boolean {<EOL>    let model = editor.getModel();<EOL>","gt":"if (!model) {"}
{"input":"<s> function listReducer(state: Array<ListDefinition> = INITIAL_STATE, action: any = { type: \"<STR_LIT>\" }): Array<ListDefinition> {<EOL>    switch (action.type) {<EOL>        case ADD_LIST:<EOL>            <EOL>            let newarray = _.clone(state);<EOL>            newarray.push(action.payload.list);<EOL>            return","gt":"newarray;"}
{"input":"<s> function listReducer(state: Array<ListDefinition> = INITIAL_STATE, action: any = { type: \"<STR_LIT>\" }): Array<ListDefinition> {<EOL>    switch (action.type) {<EOL>        case ADD_LIST:<EOL>            <EOL>            let newarray = _.clone(state);<EOL>            newarray.push(action.payload.list);<EOL>            return newarray;<EOL>        case SAVE_LIST:<EOL>            let newarray2 = _.clone(state);<EOL>            let item = _.find(newarray2, item => item.guid === action.payload.list.guid);<EOL>            item = action.","gt":"payload.list;"}
{"input":"<s> function listReducer(state: Array<ListDefinition> = INITIAL_STATE, action: any = { type: \"<STR_LIT>\" }): Array<ListDefinition> {<EOL>    switch (action.type) {<EOL>        case ADD_LIST:<EOL>            <EOL>            let newarray = _.clone(state);<EOL>            newarray.push(action.payload.list);<EOL>            return newarray;<EOL>        case SAVE_LIST:<EOL>            let newarray2 = _.clone(state);<EOL>            let item = _.find(newarray2, item => item.guid === action.payload.list.guid);<EOL>            item = action.payload.list;<EOL>            return newarray2;<EOL>        case REMOVE_LIST:<EOL>            let newArr = _.filter(state, (o) => { return o.guid !==","gt":"action.payload.list.guid; });"}
{"input":"<s> function listReducer(state: Array<ListDefinition> = INITIAL_STATE, action: any = { type: \"<STR_LIT>\" }): Array<ListDefinition> {<EOL>    switch (action.type) {<EOL>        case ADD_LIST:<EOL>            <EOL>            let newarray = _.clone(state);<EOL>            newarray.push(action.payload.list);<EOL>            return newarray;<EOL>        case SAVE_LIST:<EOL>            let newarray2 = _.clone(state);<EOL>            let item = _.find(newarray2, item => item.guid === action.payload.list.guid);<EOL>            item = action.payload.list;<EOL>            return newarray2;<EOL>        case REMOVE_LIST:<EOL>            let newArr = _.filter(state, (o) => { return o.guid !== action.payload.list.guid; });<EOL>            return newArr;<EOL>        case REMOVE_ALLLISTS:<EOL>            return [];<EOL>","gt":"case ADD_LISTS:"}
{"input":"<s> function listReducer(state: Array<ListDefinition> = INITIAL_STATE, action: any = { type: \"<STR_LIT>\" }): Array<ListDefinition> {<EOL>    switch (action.type) {<EOL>        case ADD_LIST:<EOL>            <EOL>            let newarray = _.clone(state);<EOL>            newarray.push(action.payload.list);<EOL>            return newarray;<EOL>        case SAVE_LIST:<EOL>            let newarray2 = _.clone(state);<EOL>            let item = _.find(newarray2, item => item.guid === action.payload.list.guid);<EOL>            item = action.payload.list;<EOL>            return newarray2;<EOL>        case REMOVE_LIST:<EOL>            let newArr = _.filter(state, (o) => { return o.guid !== action.payload.list.guid; });<EOL>            return newArr;<EOL>        case REMOVE_ALLLISTS:<EOL>            return [];<EOL>        case ADD_LISTS:<EOL>            return _.union(state, action.payload.lists);<EOL>        case REMOVE_COLUMN:<EOL>            let listrefs = _.clone(state);<EOL>            for (const listref of listrefs) {<EOL>                for (let i = listref.columnReferences.length - <NUM_LIT>; i >= <NUM_LIT>; i--) {<EOL>                    if (listref.columnReferences[i].columnDefinitionId === action.payload.column.guid) {<EOL>                        listref.columnReferences.splice(","gt":"i, <NUM_LIT>);"}
{"input":"<s> export function saveOpenFile(filePath: string) {<EOL>    let file = getOpenFile(","gt":"filePath);"}
{"input":"<s> function f3(x: Falsy) {<EOL>    if (x) {<EOL>","gt":"x;"}
{"input":"<s> export default function PageContextReducer(state = {}, action: any = { type: \"<STR_LIT>\" }) {<EOL>    switch (action.type) {<EOL>","gt":"case ADD_PAGECONTEXT:"}
{"input":"<s> function typeScript(): void {<EOL>    let obj = new","gt":"testClass(<NUM_LIT>);"}
{"input":"<s> /** `/asdf/bar/j.ts` => `/asdf/bar` */<EOL>export function getDirectory(filePath: string): string {<EOL>    let directory = filePath.substring(<NUM_LIT>, filePath.lastIndexOf(","gt":"\"<STR_LIT>\"));"}
{"input":"<s> export function deleteFromDisk(data: {<EOL>    files: string[];<EOL>    dirs: string[];<EOL>}) {<EOL>    data.files.forEach(filePath => {<EOL>        var file = getOpenFile(filePath);<EOL>        if (file) {<EOL>","gt":"file.delete();"}
{"input":"<s> export function deleteFromDisk(data: {<EOL>    files: string[];<EOL>    dirs: string[];<EOL>}) {<EOL>    data.files.forEach(filePath => {<EOL>        var file = getOpenFile(filePath);<EOL>        if (file) {<EOL>            file.delete();<EOL>            openFiles = openFiles.filter(f => f.config.filePath !== filePath);<EOL>        }<EOL>","gt":"else {"}
{"input":"<s> export function deleteFromDisk(data: {<EOL>    files: string[];<EOL>    dirs: string[];<EOL>}) {<EOL>    data.files.forEach(filePath => {<EOL>        var file = getOpenFile(filePath);<EOL>        if (file) {<EOL>            file.delete();<EOL>            openFiles = openFiles.filter(f => f.config.filePath !== filePath);<EOL>        }<EOL>        else {<EOL>            fsu.deleteFile(filePath);<EOL>        }<EOL>    });<EOL>    data.dirs.","gt":"forEach(dirPath => {"}
{"input":"<s> export function deleteFromDisk(data: {<EOL>    files: string[];<EOL>    dirs: string[];<EOL>}) {<EOL>    data.files.forEach(filePath => {<EOL>        var file = getOpenFile(filePath);<EOL>        if (file) {<EOL>            file.delete();<EOL>            openFiles = openFiles.filter(f => f.config.filePath !== filePath);<EOL>        }<EOL>        else {<EOL>            fsu.deleteFile(filePath);<EOL>        }<EOL>    });<EOL>    data.dirs.forEach(dirPath => {<EOL>        <EOL>        let toClose = (filePath: string) => {<EOL>            return filePath.startsWith(dirPath);<EOL>        };<EOL>","gt":"openFiles.filter(f => toClose(f.config.filePath)).forEach(f => f.delete());"}
{"input":"<s> /**<EOL> * Always convert to unique list of queries; for iteration in ::registerQuery()<EOL> */<EOL>function normalizeQuery(mediaQuery: string | string[]): string[] {<EOL>    return (typeof","gt":"mediaQuery === '<STR_LIT>') ? [] :"}
{"input":"<s> /**<EOL> * shallow equality of sorted arrays<EOL> */<EOL>export function arraysEqual<T>(a: T[], b: T[]): boolean {<EOL>    if (a === b)<EOL>        return true;<EOL>    if (a == null || b == null)<EOL>        return","gt":"false;"}
{"input":"<s> /**<EOL> * shallow equality of sorted arrays<EOL> */<EOL>export function arraysEqual<T>(a: T[], b: T[]): boolean {<EOL>    if (a === b)<EOL>        return true;<EOL>    if (a == null || b == null)<EOL>        return false;<EOL>    if (a.length !== b.length)<EOL>        return false;<EOL>    for (var i = <NUM_LIT>; i < a.length; ++i) {<EOL>        if (a[i] !== b[i])<EOL>","gt":"return false;"}
{"input":"<s> export function reduce<T, R>(fn: ReduceFn<T, R>, seed: R, set: SortedSetStructure<T>): R {<EOL>    var it = iterateValues(set);<EOL>    var current: IteratorResult<any>;<EOL>    var","gt":"index = <NUM_LIT>;"}
{"input":"<s> export function handleHttpError(error: HttpRequestError): string {<EOL>    switch (error.status) {<EOL>        case <NUM_LIT>:<EOL>            return strings.ErrorMessage_HTTP_BadRequest;<EOL>        case","gt":"<NUM_LIT>:"}
{"input":"<s> export function handleHttpError(error: HttpRequestError): string {<EOL>    switch (error.status) {<EOL>        case <NUM_LIT>:<EOL>            return strings.ErrorMessage_HTTP_BadRequest;<EOL>        case <NUM_LIT>:<EOL>            return strings.ErrorMessage_HTTP_AccessDenied;<EOL>        case <NUM_LIT>:<EOL>            return strings.ErrorMessage_HTTP_NotFound;<EOL>        case undefined:<EOL>            return error.message;<EOL>","gt":"default:"}
{"input":"<s> export function getCaretOffsetAndCleanContent(content: string) {<EOL>    const offset = content.indexOf('<STR_LIT>');<EOL>    if (offset === -<NUM_LIT>) {<EOL>","gt":"throw Error('<STR_LIT>');"}
{"input":"<s> /** Formats the TypeScript diagnostics into a error string. */<EOL>function formatDiagnostics(diagnostics: ts.Diagnostic[], baseDir = '<STR_LIT>'): string {<EOL>    return diagnostics.map(diagnostic => {<EOL>        let res = `<STR_LIT>`;<EOL>        if (diagnostic.file) {<EOL>            const { line, character } = diagnostic.file.","gt":"getLineAndCharacterOfPosition(diagnostic.start!);"}
{"input":"<s> /** Formats the TypeScript diagnostics into a error string. */<EOL>function formatDiagnostics(diagnostics: ts.Diagnostic[], baseDir = '<STR_LIT>'): string {<EOL>    return diagnostics.map(diagnostic => {<EOL>        let res = `<STR_LIT>`;<EOL>        if (diagnostic.file) {<EOL>            const { line, character } = diagnostic.file.getLineAndCharacterOfPosition(diagnostic.start!);<EOL>            const filePath = path.relative(baseDir, diagnostic.file.fileName);<EOL>            res += `<STR_LIT>`;<EOL>        }<EOL>","gt":"res += `<STR_LIT>`;"}
{"input":"<s> function leftOf<K, V>(node: Node<K, V>): Node<K, V> {<EOL>","gt":"return node._left;"}
{"input":"<s> export default function () {<EOL>    return ng('<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>',","gt":"'<STR_LIT>', '<STR_LIT>')"}
{"input":"<s> export default function () {<EOL>    return Promise.resolve()<EOL>        .then(() =>","gt":"ng('<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>'))"}
{"input":"<s> /**<EOL> * Create a word definition regular expression based on default word separators.<EOL> * Optionally provide allowed separators that should be included in words.<EOL> *<EOL> * The default would look like this:<EOL> * /(-?\\d*\\.\\d\\w*)|([^\\`\\~\\!\\@\\#\\$\\%\\^\\&\\*\\(\\)\\-\\=\\+\\[\\{\\]\\}\\\\\\|\\;\\:\\'\\\"\\,\\.\\<\\>\\/\\?\\s]+)/g<EOL> */<EOL>function createWordRegExp(allowInWords: string = '<STR_LIT>'): RegExp {<EOL>    let source = '<STR_LIT>';<EOL>    for (let i = <NUM_LIT>; i < USUAL_WORD_SEPARATORS.length; i++) {<EOL>        if (allowInWords.indexOf(USUAL_WORD_SEPARATORS[i]) >=","gt":"<NUM_LIT>) {"}
{"input":"<s> export function prependValues(list: ListStructure<any>, values: any[], fn?: MapFn<any, any>): ListStructure<any> {<EOL>    TreeWorker.focusHead(list, true);<EOL>    var collector = increaseCapacity(list, values.length, true);<EOL>    if (isUndefined(fn)) {<EOL>        collector.populate(","gt":"values, <NUM_LIT>);"}
{"input":"<s> export function makeAbsoluteUrl(relativeUrl: string) {<EOL>    let { filePath: relativeFilePath, protocol } =","gt":"utils.getFilePathAndProtocolFromUrl(relativeUrl);"}
{"input":"<s> /**<EOL> * Returns a nice conversion of milliseconds into seconds / mintues as needed<EOL> */<EOL>export function formatMilliseconds(ms: number): string {<EOL>    if (ms < <NUM_LIT>)<EOL>        return `<STR_LIT>`;<EOL>    const","gt":"s = ms / <NUM_LIT>;"}
{"input":"<s> function earlyResult([transpiledMutant, sandbox]: [<EOL>    TranspiledMutant,<EOL>    Sandbox<EOL>]): [<EOL>    TranspiledMutant,<EOL>    Sandbox,<EOL>    MutantResult | null<EOL>] {<EOL>    if (transpiledMutant.transpileResult.error) {<EOL>        const result = transpiledMutant.mutant.result(MutantStatus.TranspileError, []);<EOL>        return [transpiledMutant, sandbox, result];<EOL>    }<EOL>    else if (!transpiledMutant.mutant.selectedTests.","gt":"length) {"}
{"input":"<s> function earlyResult([transpiledMutant, sandbox]: [<EOL>    TranspiledMutant,<EOL>    Sandbox<EOL>]): [<EOL>    TranspiledMutant,<EOL>    Sandbox,<EOL>    MutantResult | null<EOL>] {<EOL>    if (transpiledMutant.transpileResult.error) {<EOL>        const result = transpiledMutant.mutant.result(MutantStatus.TranspileError, []);<EOL>        return [transpiledMutant, sandbox, result];<EOL>    }<EOL>    else if (!transpiledMutant.mutant.selectedTests.length) {<EOL>        const result = transpiledMutant.mutant.result(MutantStatus.NoCoverage, []);<EOL>        return [transpiledMutant, sandbox, result];<EOL>    }<EOL>    else if (!transpiledMutant.","gt":"changedAnyTranspiledFiles) {"}
{"input":"<s> function earlyResult([transpiledMutant, sandbox]: [<EOL>    TranspiledMutant,<EOL>    Sandbox<EOL>]): [<EOL>    TranspiledMutant,<EOL>    Sandbox,<EOL>    MutantResult | null<EOL>] {<EOL>    if (transpiledMutant.transpileResult.error) {<EOL>        const result = transpiledMutant.mutant.result(MutantStatus.TranspileError, []);<EOL>        return [transpiledMutant, sandbox, result];<EOL>    }<EOL>    else if (!transpiledMutant.mutant.selectedTests.length) {<EOL>        const result = transpiledMutant.mutant.result(MutantStatus.NoCoverage, []);<EOL>        return [transpiledMutant, sandbox, result];<EOL>    }<EOL>    else if (!transpiledMutant.changedAnyTranspiledFiles) {<EOL>        const result = transpiledMutant.mutant.result(MutantStatus.Survived, []);<EOL>        return [transpiledMutant, sandbox, result];<EOL>    }<EOL>","gt":"else {"}
{"input":"<s> function getComputedColor(page: Page, text: string) {<EOL>    return","gt":"page.$eval('<STR_LIT>' + text, (el) => window.getComputedStyle(el).color);"}
{"input":"<s> export function isEmpty<T>(list: ListStructure<T>): boolean {<EOL>","gt":"return list._size === <NUM_LIT>;"}
{"input":"<s> export function base64Decode(base64EncodedString: string) {<EOL>    return Buffer.from(base64EncodedString,","gt":"'<STR_LIT>').toString('<STR_LIT>');"}
{"input":"<s> export function getWebpackStatsConfig(verbose = false) {<EOL>","gt":"return verbose"}
{"input":"<s> function filterMap<T>(pred: FilterFn<T>) {<EOL>    return function (value: null,","gt":"key: T, index: number): boolean {"}
{"input":"<s> /**<EOL> * Determines whether two trees have equivalent sets of keys and values. Though order of insertion can affect the<EOL> * internal structure of a red black tree, only the actual set of entries and their ordinal positions are considered.<EOL> *<EOL> * @export<EOL> * @template K The type of keys in the tree<EOL> * @template V The type of values in the tree<EOL> * @param {RedBlackTreeStructure<K, V>} tree The input tree<EOL> * @param {RedBlackTreeStructure<K, V>} other Another tree to compare entries with<EOL> * @returns {boolean} True if both trees are of the same size and have equivalent sets of keys and values for each entry<EOL> *   at corresponding indices in each tree, otherwise false.<EOL> */<EOL>export function isEqual<K, V = null>(tree: RedBlackTreeStructure<K, V>, other: RedBlackTreeStructure<K, V>): boolean {<EOL>    if (tree === other)<EOL>        return true;<EOL>    if (size(tree) !== size(other))<EOL>        return","gt":"false;"}
{"input":"<s> /**<EOL> * Determines whether two trees have equivalent sets of keys and values. Though order of insertion can affect the<EOL> * internal structure of a red black tree, only the actual set of entries and their ordinal positions are considered.<EOL> *<EOL> * @export<EOL> * @template K The type of keys in the tree<EOL> * @template V The type of values in the tree<EOL> * @param {RedBlackTreeStructure<K, V>} tree The input tree<EOL> * @param {RedBlackTreeStructure<K, V>} other Another tree to compare entries with<EOL> * @returns {boolean} True if both trees are of the same size and have equivalent sets of keys and values for each entry<EOL> *   at corresponding indices in each tree, otherwise false.<EOL> */<EOL>export function isEqual<K, V = null>(tree: RedBlackTreeStructure<K, V>, other: RedBlackTreeStructure<K, V>): boolean {<EOL>    if (tree === other)<EOL>        return true;<EOL>    if (size(tree) !== size(other))<EOL>        return false;<EOL>    <EOL>    var ita = iterateFromFirst(tree), itb = iterateFromFirst(other);<EOL>    do {<EOL>        var ca = ita.next();<EOL>        var cb = itb.next();<EOL>        if (!equals(ca.value,","gt":"cb.value))"}
{"input":"<s> function _ngProbeTokensToMap(tokens: core.NgProbeToken[]): {<EOL>    [name: string]: any;<EOL>} {<EOL>    return tokens.reduce((prev: any, t: any) => (prev[t.name] =","gt":"t.token, prev), {});"}
{"input":"<s> export function requireMonaco(callback: () => void) {<EOL>    const g = (global as any);<EOL>    const nodeRequire = g.require;<EOL>    const loaderScript = document.createElement(\"<STR_LIT>\");<EOL>    loaderScript.type = \"<STR_LIT>\";<EOL>    loaderScript.src = \"<STR_LIT>\";<EOL>    loaderScript.addEventListener(","gt":"\"<STR_LIT>\", () => {"}
{"input":"<s> export function requireMonaco(callback: () => void) {<EOL>    const g = (global as any);<EOL>    const nodeRequire = g.require;<EOL>    const loaderScript = document.createElement(\"<STR_LIT>\");<EOL>    loaderScript.type = \"<STR_LIT>\";<EOL>    loaderScript.src = \"<STR_LIT>\";<EOL>    loaderScript.addEventListener(\"<STR_LIT>\", () => {<EOL>        const amdRequire = g.require;<EOL>        g.require = nodeRequire;<EOL>        <EOL>        const path = require(\"<STR_LIT>\");<EOL>        function uriFromPath(_path: string) {<EOL>            let pathName = path.resolve(","gt":"_path).replace(/\\\\/g, \"<STR_LIT>\");"}
{"input":"<s> export function requireMonaco(callback: () => void) {<EOL>    const g = (global as any);<EOL>    const nodeRequire = g.require;<EOL>    const loaderScript = document.createElement(\"<STR_LIT>\");<EOL>    loaderScript.type = \"<STR_LIT>\";<EOL>    loaderScript.src = \"<STR_LIT>\";<EOL>    loaderScript.addEventListener(\"<STR_LIT>\", () => {<EOL>        const amdRequire = g.require;<EOL>        g.require = nodeRequire;<EOL>        <EOL>        const path = require(\"<STR_LIT>\");<EOL>        function uriFromPath(_path: string) {<EOL>            let pathName = path.resolve(_path).replace(/\\\\/g, \"<STR_LIT>\");<EOL>            if (pathName.length > <NUM_LIT> && pathName.charAt(<NUM_LIT>) !== \"<STR_LIT>\") {<EOL>                pathName = \"<STR_LIT>\" + pathName;<EOL>            }<EOL>            return encodeURI(\"<STR_LIT>\" + pathName);<EOL>        }<EOL>        amdRequire.config({<EOL>            baseUrl: uriFromPath(path.join(__dirname, \"<STR_LIT>\")),<EOL>        });<EOL>        <EOL>        (self as any).","gt":"module = undefined;"}
{"input":"<s> export function has<K, V, U = any>(key: K, map: SortedMapStructure<K, V, U>): boolean {<EOL>    return","gt":"_has(key, map._indexed);"}
{"input":"<s> /**<EOL> * Prediction API<EOL> *<EOL> * Lets you access a cloud hosted machine learning service that makes it easy to<EOL> * build smart apps<EOL> *<EOL> * @example<EOL> * const google = require('googleapis');<EOL> * const prediction = google.prediction('v1.3');<EOL> *<EOL> * @namespace prediction<EOL> * @type {Function}<EOL> * @version v1.3<EOL> * @variation v1.3<EOL> * @param {object=} options Options for Prediction<EOL> */<EOL>function Prediction(options) {<EOL>    const self = this;<EOL>    self._options = options || {};<EOL>","gt":"self.hostedmodels = {"}
{"input":"<s> /**<EOL> * Prediction API<EOL> *<EOL> * Lets you access a cloud hosted machine learning service that makes it easy to<EOL> * build smart apps<EOL> *<EOL> * @example<EOL> * const google = require('googleapis');<EOL> * const prediction = google.prediction('v1.3');<EOL> *<EOL> * @namespace prediction<EOL> * @type {Function}<EOL> * @version v1.3<EOL> * @variation v1.3<EOL> * @param {object=} options Options for Prediction<EOL> */<EOL>function Prediction(options) {<EOL>    const self = this;<EOL>    self._options = options || {};<EOL>    self.hostedmodels = {<EOL>        /**<EOL>         * prediction.hostedmodels.predict<EOL>         * @desc Submit input and request an output against a hosted model<EOL>         * @alias prediction.hostedmodels.predict<EOL>         * @memberOf! prediction(v1.3)<EOL>         *<EOL>         * @param {object} params Parameters for request<EOL>         * @param {string} params.hostedModelName The name of a hosted model<EOL>         * @param {prediction(v1.3).Input} params.resource Request body data<EOL>         * @param {object} [options] Optionally override request options, such as `url`, `method`, and `encoding`.<EOL>         * @param {callback} callback The callback that handles the response.<EOL>         * @return {object} Request object<EOL>         */<EOL>        predict(params,","gt":"options, callback) {"}
{"input":"<s> /**<EOL> * Prediction API<EOL> *<EOL> * Lets you access a cloud hosted machine learning service that makes it easy to<EOL> * build smart apps<EOL> *<EOL> * @example<EOL> * const google = require('googleapis');<EOL> * const prediction = google.prediction('v1.3');<EOL> *<EOL> * @namespace prediction<EOL> * @type {Function}<EOL> * @version v1.3<EOL> * @variation v1.3<EOL> * @param {object=} options Options for Prediction<EOL> */<EOL>function Prediction(options) {<EOL>    const self = this;<EOL>    self._options = options || {};<EOL>    self.hostedmodels = {<EOL>        /**<EOL>         * prediction.hostedmodels.predict<EOL>         * @desc Submit input and request an output against a hosted model<EOL>         * @alias prediction.hostedmodels.predict<EOL>         * @memberOf! prediction(v1.3)<EOL>         *<EOL>         * @param {object} params Parameters for request<EOL>         * @param {string} params.hostedModelName The name of a hosted model<EOL>         * @param {prediction(v1.3).Input} params.resource Request body data<EOL>         * @param {object} [options] Optionally override request options, such as `url`, `method`, and `encoding`.<EOL>         * @param {callback} callback The callback that handles the response.<EOL>         * @return {object} Request object<EOL>         */<EOL>        predict(params, options, callback) {<EOL>            if (typeof options === '<STR_LIT>') {<EOL>                callback = options;<EOL>                options = {};<EOL>            }<EOL>            options = options || {};<EOL>            const rootUrl = options.","gt":"rootUrl || '<STR_LIT>';"}
{"input":"<s> /**<EOL> * Prediction API<EOL> *<EOL> * Lets you access a cloud hosted machine learning service that makes it easy to<EOL> * build smart apps<EOL> *<EOL> * @example<EOL> * const google = require('googleapis');<EOL> * const prediction = google.prediction('v1.3');<EOL> *<EOL> * @namespace prediction<EOL> * @type {Function}<EOL> * @version v1.3<EOL> * @variation v1.3<EOL> * @param {object=} options Options for Prediction<EOL> */<EOL>function Prediction(options) {<EOL>    const self = this;<EOL>    self._options = options || {};<EOL>    self.hostedmodels = {<EOL>        /**<EOL>         * prediction.hostedmodels.predict<EOL>         * @desc Submit input and request an output against a hosted model<EOL>         * @alias prediction.hostedmodels.predict<EOL>         * @memberOf! prediction(v1.3)<EOL>         *<EOL>         * @param {object} params Parameters for request<EOL>         * @param {string} params.hostedModelName The name of a hosted model<EOL>         * @param {prediction(v1.3).Input} params.resource Request body data<EOL>         * @param {object} [options] Optionally override request options, such as `url`, `method`, and `encoding`.<EOL>         * @param {callback} callback The callback that handles the response.<EOL>         * @return {object} Request object<EOL>         */<EOL>        predict(params, options, callback) {<EOL>            if (typeof options === '<STR_LIT>') {<EOL>                callback = options;<EOL>                options = {};<EOL>            }<EOL>            options = options || {};<EOL>            const rootUrl = options.rootUrl || '<STR_LIT>';<EOL>            const parameters = {<EOL>                options: Object.assign({<EOL>                    url: (rootUrl +<EOL>                        '<STR_LIT>')<EOL>                        .replace(/([^:]\\/)\\/+/g,","gt":"'<STR_LIT>'),"}
{"input":"<s> /**<EOL> * Prediction API<EOL> *<EOL> * Lets you access a cloud hosted machine learning service that makes it easy to<EOL> * build smart apps<EOL> *<EOL> * @example<EOL> * const google = require('googleapis');<EOL> * const prediction = google.prediction('v1.3');<EOL> *<EOL> * @namespace prediction<EOL> * @type {Function}<EOL> * @version v1.3<EOL> * @variation v1.3<EOL> * @param {object=} options Options for Prediction<EOL> */<EOL>function Prediction(options) {<EOL>    const self = this;<EOL>    self._options = options || {};<EOL>    self.hostedmodels = {<EOL>        /**<EOL>         * prediction.hostedmodels.predict<EOL>         * @desc Submit input and request an output against a hosted model<EOL>         * @alias prediction.hostedmodels.predict<EOL>         * @memberOf! prediction(v1.3)<EOL>         *<EOL>         * @param {object} params Parameters for request<EOL>         * @param {string} params.hostedModelName The name of a hosted model<EOL>         * @param {prediction(v1.3).Input} params.resource Request body data<EOL>         * @param {object} [options] Optionally override request options, such as `url`, `method`, and `encoding`.<EOL>         * @param {callback} callback The callback that handles the response.<EOL>         * @return {object} Request object<EOL>         */<EOL>        predict(params, options, callback) {<EOL>            if (typeof options === '<STR_LIT>') {<EOL>                callback = options;<EOL>                options = {};<EOL>            }<EOL>            options = options || {};<EOL>            const rootUrl = options.rootUrl || '<STR_LIT>';<EOL>            const parameters = {<EOL>                options: Object.assign({<EOL>                    url: (rootUrl +<EOL>                        '<STR_LIT>')<EOL>                        .replace(/([^:]\\/)\\/+/g, '<STR_LIT>'),<EOL>                    method: '<STR_LIT>'<EOL>                }, options),<EOL>                params,<EOL>                requiredParams: ['<STR_LIT>'],<EOL>                pathParams: ['<STR_LIT>'],<EOL>                context: self<EOL>            };<EOL>            return","gt":"createAPIRequest(parameters, callback);"}
{"input":"<s> /**<EOL> * Prediction API<EOL> *<EOL> * Lets you access a cloud hosted machine learning service that makes it easy to<EOL> * build smart apps<EOL> *<EOL> * @example<EOL> * const google = require('googleapis');<EOL> * const prediction = google.prediction('v1.3');<EOL> *<EOL> * @namespace prediction<EOL> * @type {Function}<EOL> * @version v1.3<EOL> * @variation v1.3<EOL> * @param {object=} options Options for Prediction<EOL> */<EOL>function Prediction(options) {<EOL>    const self = this;<EOL>    self._options = options || {};<EOL>    self.hostedmodels = {<EOL>        /**<EOL>         * prediction.hostedmodels.predict<EOL>         * @desc Submit input and request an output against a hosted model<EOL>         * @alias prediction.hostedmodels.predict<EOL>         * @memberOf! prediction(v1.3)<EOL>         *<EOL>         * @param {object} params Parameters for request<EOL>         * @param {string} params.hostedModelName The name of a hosted model<EOL>         * @param {prediction(v1.3).Input} params.resource Request body data<EOL>         * @param {object} [options] Optionally override request options, such as `url`, `method`, and `encoding`.<EOL>         * @param {callback} callback The callback that handles the response.<EOL>         * @return {object} Request object<EOL>         */<EOL>        predict(params, options, callback) {<EOL>            if (typeof options === '<STR_LIT>') {<EOL>                callback = options;<EOL>                options = {};<EOL>            }<EOL>            options = options || {};<EOL>            const rootUrl = options.rootUrl || '<STR_LIT>';<EOL>            const parameters = {<EOL>                options: Object.assign({<EOL>                    url: (rootUrl +<EOL>                        '<STR_LIT>')<EOL>                        .replace(/([^:]\\/)\\/+/g, '<STR_LIT>'),<EOL>                    method: '<STR_LIT>'<EOL>                }, options),<EOL>                params,<EOL>                requiredParams: ['<STR_LIT>'],<EOL>                pathParams: ['<STR_LIT>'],<EOL>                context: self<EOL>            };<EOL>            return createAPIRequest(parameters, callback);<EOL>        }<EOL>    };<EOL>    self.training = {<EOL>        /**<EOL>         * prediction.training.delete<EOL>         * @desc Delete a trained model<EOL>         * @alias prediction.training.delete<EOL>         * @memberOf! prediction(v1.3)<EOL>         *<EOL>         * @param {object} params Parameters for request<EOL>         * @param {string} params.data mybucket/mydata resource in Google Storage<EOL>         * @param {object} [options] Optionally override request options, such as `url`, `method`, and `encoding`.<EOL>         * @param {callback} callback The callback that handles the response.<EOL>         * @return {object} Request object<EOL>         */<EOL>        delete(params, options, callback) {<EOL>            if (typeof options === '<STR_LIT>') {<EOL>                callback = options;<EOL>                options = {};<EOL>            }<EOL>            options = options || {};<EOL>            const rootUrl = options.rootUrl || '<STR_LIT>';<EOL>            const parameters = {<EOL>                options: Object.","gt":"assign({"}
{"input":"<s> /**<EOL> * Prediction API<EOL> *<EOL> * Lets you access a cloud hosted machine learning service that makes it easy to<EOL> * build smart apps<EOL> *<EOL> * @example<EOL> * const google = require('googleapis');<EOL> * const prediction = google.prediction('v1.3');<EOL> *<EOL> * @namespace prediction<EOL> * @type {Function}<EOL> * @version v1.3<EOL> * @variation v1.3<EOL> * @param {object=} options Options for Prediction<EOL> */<EOL>function Prediction(options) {<EOL>    const self = this;<EOL>    self._options = options || {};<EOL>    self.hostedmodels = {<EOL>        /**<EOL>         * prediction.hostedmodels.predict<EOL>         * @desc Submit input and request an output against a hosted model<EOL>         * @alias prediction.hostedmodels.predict<EOL>         * @memberOf! prediction(v1.3)<EOL>         *<EOL>         * @param {object} params Parameters for request<EOL>         * @param {string} params.hostedModelName The name of a hosted model<EOL>         * @param {prediction(v1.3).Input} params.resource Request body data<EOL>         * @param {object} [options] Optionally override request options, such as `url`, `method`, and `encoding`.<EOL>         * @param {callback} callback The callback that handles the response.<EOL>         * @return {object} Request object<EOL>         */<EOL>        predict(params, options, callback) {<EOL>            if (typeof options === '<STR_LIT>') {<EOL>                callback = options;<EOL>                options = {};<EOL>            }<EOL>            options = options || {};<EOL>            const rootUrl = options.rootUrl || '<STR_LIT>';<EOL>            const parameters = {<EOL>                options: Object.assign({<EOL>                    url: (rootUrl +<EOL>                        '<STR_LIT>')<EOL>                        .replace(/([^:]\\/)\\/+/g, '<STR_LIT>'),<EOL>                    method: '<STR_LIT>'<EOL>                }, options),<EOL>                params,<EOL>                requiredParams: ['<STR_LIT>'],<EOL>                pathParams: ['<STR_LIT>'],<EOL>                context: self<EOL>            };<EOL>            return createAPIRequest(parameters, callback);<EOL>        }<EOL>    };<EOL>    self.training = {<EOL>        /**<EOL>         * prediction.training.delete<EOL>         * @desc Delete a trained model<EOL>         * @alias prediction.training.delete<EOL>         * @memberOf! prediction(v1.3)<EOL>         *<EOL>         * @param {object} params Parameters for request<EOL>         * @param {string} params.data mybucket/mydata resource in Google Storage<EOL>         * @param {object} [options] Optionally override request options, such as `url`, `method`, and `encoding`.<EOL>         * @param {callback} callback The callback that handles the response.<EOL>         * @return {object} Request object<EOL>         */<EOL>        delete(params, options, callback) {<EOL>            if (typeof options === '<STR_LIT>') {<EOL>                callback = options;<EOL>                options = {};<EOL>            }<EOL>            options = options || {};<EOL>            const rootUrl = options.rootUrl || '<STR_LIT>';<EOL>            const parameters = {<EOL>                options: Object.assign({<EOL>                    url: (rootUrl + '<STR_LIT>')<EOL>                        .replace(/([^:]\\/)\\/+/g,","gt":"'<STR_LIT>'),"}
{"input":"<s> /**<EOL> * Prediction API<EOL> *<EOL> * Lets you access a cloud hosted machine learning service that makes it easy to<EOL> * build smart apps<EOL> *<EOL> * @example<EOL> * const google = require('googleapis');<EOL> * const prediction = google.prediction('v1.3');<EOL> *<EOL> * @namespace prediction<EOL> * @type {Function}<EOL> * @version v1.3<EOL> * @variation v1.3<EOL> * @param {object=} options Options for Prediction<EOL> */<EOL>function Prediction(options) {<EOL>    const self = this;<EOL>    self._options = options || {};<EOL>    self.hostedmodels = {<EOL>        /**<EOL>         * prediction.hostedmodels.predict<EOL>         * @desc Submit input and request an output against a hosted model<EOL>         * @alias prediction.hostedmodels.predict<EOL>         * @memberOf! prediction(v1.3)<EOL>         *<EOL>         * @param {object} params Parameters for request<EOL>         * @param {string} params.hostedModelName The name of a hosted model<EOL>         * @param {prediction(v1.3).Input} params.resource Request body data<EOL>         * @param {object} [options] Optionally override request options, such as `url`, `method`, and `encoding`.<EOL>         * @param {callback} callback The callback that handles the response.<EOL>         * @return {object} Request object<EOL>         */<EOL>        predict(params, options, callback) {<EOL>            if (typeof options === '<STR_LIT>') {<EOL>                callback = options;<EOL>                options = {};<EOL>            }<EOL>            options = options || {};<EOL>            const rootUrl = options.rootUrl || '<STR_LIT>';<EOL>            const parameters = {<EOL>                options: Object.assign({<EOL>                    url: (rootUrl +<EOL>                        '<STR_LIT>')<EOL>                        .replace(/([^:]\\/)\\/+/g, '<STR_LIT>'),<EOL>                    method: '<STR_LIT>'<EOL>                }, options),<EOL>                params,<EOL>                requiredParams: ['<STR_LIT>'],<EOL>                pathParams: ['<STR_LIT>'],<EOL>                context: self<EOL>            };<EOL>            return createAPIRequest(parameters, callback);<EOL>        }<EOL>    };<EOL>    self.training = {<EOL>        /**<EOL>         * prediction.training.delete<EOL>         * @desc Delete a trained model<EOL>         * @alias prediction.training.delete<EOL>         * @memberOf! prediction(v1.3)<EOL>         *<EOL>         * @param {object} params Parameters for request<EOL>         * @param {string} params.data mybucket/mydata resource in Google Storage<EOL>         * @param {object} [options] Optionally override request options, such as `url`, `method`, and `encoding`.<EOL>         * @param {callback} callback The callback that handles the response.<EOL>         * @return {object} Request object<EOL>         */<EOL>        delete(params, options, callback) {<EOL>            if (typeof options === '<STR_LIT>') {<EOL>                callback = options;<EOL>                options = {};<EOL>            }<EOL>            options = options || {};<EOL>            const rootUrl = options.rootUrl || '<STR_LIT>';<EOL>            const parameters = {<EOL>                options: Object.assign({<EOL>                    url: (rootUrl + '<STR_LIT>')<EOL>                        .replace(/([^:]\\/)\\/+/g, '<STR_LIT>'),<EOL>                    method: '<STR_LIT>'<EOL>                }, options),<EOL>                params,<EOL>                requiredParams: ['<STR_LIT>'],<EOL>                pathParams: ['<STR_LIT>'],<EOL>                context:","gt":"self"}
{"input":"<s> /**<EOL> * Prediction API<EOL> *<EOL> * Lets you access a cloud hosted machine learning service that makes it easy to<EOL> * build smart apps<EOL> *<EOL> * @example<EOL> * const google = require('googleapis');<EOL> * const prediction = google.prediction('v1.3');<EOL> *<EOL> * @namespace prediction<EOL> * @type {Function}<EOL> * @version v1.3<EOL> * @variation v1.3<EOL> * @param {object=} options Options for Prediction<EOL> */<EOL>function Prediction(options) {<EOL>    const self = this;<EOL>    self._options = options || {};<EOL>    self.hostedmodels = {<EOL>        /**<EOL>         * prediction.hostedmodels.predict<EOL>         * @desc Submit input and request an output against a hosted model<EOL>         * @alias prediction.hostedmodels.predict<EOL>         * @memberOf! prediction(v1.3)<EOL>         *<EOL>         * @param {object} params Parameters for request<EOL>         * @param {string} params.hostedModelName The name of a hosted model<EOL>         * @param {prediction(v1.3).Input} params.resource Request body data<EOL>         * @param {object} [options] Optionally override request options, such as `url`, `method`, and `encoding`.<EOL>         * @param {callback} callback The callback that handles the response.<EOL>         * @return {object} Request object<EOL>         */<EOL>        predict(params, options, callback) {<EOL>            if (typeof options === '<STR_LIT>') {<EOL>                callback = options;<EOL>                options = {};<EOL>            }<EOL>            options = options || {};<EOL>            const rootUrl = options.rootUrl || '<STR_LIT>';<EOL>            const parameters = {<EOL>                options: Object.assign({<EOL>                    url: (rootUrl +<EOL>                        '<STR_LIT>')<EOL>                        .replace(/([^:]\\/)\\/+/g, '<STR_LIT>'),<EOL>                    method: '<STR_LIT>'<EOL>                }, options),<EOL>                params,<EOL>                requiredParams: ['<STR_LIT>'],<EOL>                pathParams: ['<STR_LIT>'],<EOL>                context: self<EOL>            };<EOL>            return createAPIRequest(parameters, callback);<EOL>        }<EOL>    };<EOL>    self.training = {<EOL>        /**<EOL>         * prediction.training.delete<EOL>         * @desc Delete a trained model<EOL>         * @alias prediction.training.delete<EOL>         * @memberOf! prediction(v1.3)<EOL>         *<EOL>         * @param {object} params Parameters for request<EOL>         * @param {string} params.data mybucket/mydata resource in Google Storage<EOL>         * @param {object} [options] Optionally override request options, such as `url`, `method`, and `encoding`.<EOL>         * @param {callback} callback The callback that handles the response.<EOL>         * @return {object} Request object<EOL>         */<EOL>        delete(params, options, callback) {<EOL>            if (typeof options === '<STR_LIT>') {<EOL>                callback = options;<EOL>                options = {};<EOL>            }<EOL>            options = options || {};<EOL>            const rootUrl = options.rootUrl || '<STR_LIT>';<EOL>            const parameters = {<EOL>                options: Object.assign({<EOL>                    url: (rootUrl + '<STR_LIT>')<EOL>                        .replace(/([^:]\\/)\\/+/g, '<STR_LIT>'),<EOL>                    method: '<STR_LIT>'<EOL>                }, options),<EOL>                params,<EOL>                requiredParams: ['<STR_LIT>'],<EOL>                pathParams: ['<STR_LIT>'],<EOL>                context: self<EOL>            };<EOL>            return createAPIRequest(parameters, callback);<EOL>        },<EOL>        get(params, options, callback) {<EOL>            if (typeof options === '<STR_LIT>') {<EOL>                callback = options;<EOL>                options = {};<EOL>            }<EOL>            options = options || {};<EOL>            const rootUrl = options.rootUrl || '<STR_LIT>';<EOL>            const parameters = {<EOL>                options: Object.assign({<EOL>                    url: (rootUrl + '<STR_LIT>')<EOL>                        .replace(/([^:]\\/)\\/+/g, '<STR_LIT>'),<EOL>                    method: '<STR_LIT>'<EOL>                }, options),<EOL>                params,<EOL>                requiredParams: ['<STR_LIT>'],<EOL>                pathParams: ['<STR_LIT>'],<EOL>                context: self<EOL>            };<EOL>            return createAPIRequest(parameters, callback);<EOL>        },<EOL>        insert(params, options, callback) {<EOL>","gt":"if (typeof options === '<STR_LIT>') {"}
{"input":"<s> /**<EOL> * Prediction API<EOL> *<EOL> * Lets you access a cloud hosted machine learning service that makes it easy to<EOL> * build smart apps<EOL> *<EOL> * @example<EOL> * const google = require('googleapis');<EOL> * const prediction = google.prediction('v1.3');<EOL> *<EOL> * @namespace prediction<EOL> * @type {Function}<EOL> * @version v1.3<EOL> * @variation v1.3<EOL> * @param {object=} options Options for Prediction<EOL> */<EOL>function Prediction(options) {<EOL>    const self = this;<EOL>    self._options = options || {};<EOL>    self.hostedmodels = {<EOL>        /**<EOL>         * prediction.hostedmodels.predict<EOL>         * @desc Submit input and request an output against a hosted model<EOL>         * @alias prediction.hostedmodels.predict<EOL>         * @memberOf! prediction(v1.3)<EOL>         *<EOL>         * @param {object} params Parameters for request<EOL>         * @param {string} params.hostedModelName The name of a hosted model<EOL>         * @param {prediction(v1.3).Input} params.resource Request body data<EOL>         * @param {object} [options] Optionally override request options, such as `url`, `method`, and `encoding`.<EOL>         * @param {callback} callback The callback that handles the response.<EOL>         * @return {object} Request object<EOL>         */<EOL>        predict(params, options, callback) {<EOL>            if (typeof options === '<STR_LIT>') {<EOL>                callback = options;<EOL>                options = {};<EOL>            }<EOL>            options = options || {};<EOL>            const rootUrl = options.rootUrl || '<STR_LIT>';<EOL>            const parameters = {<EOL>                options: Object.assign({<EOL>                    url: (rootUrl +<EOL>                        '<STR_LIT>')<EOL>                        .replace(/([^:]\\/)\\/+/g, '<STR_LIT>'),<EOL>                    method: '<STR_LIT>'<EOL>                }, options),<EOL>                params,<EOL>                requiredParams: ['<STR_LIT>'],<EOL>                pathParams: ['<STR_LIT>'],<EOL>                context: self<EOL>            };<EOL>            return createAPIRequest(parameters, callback);<EOL>        }<EOL>    };<EOL>    self.training = {<EOL>        /**<EOL>         * prediction.training.delete<EOL>         * @desc Delete a trained model<EOL>         * @alias prediction.training.delete<EOL>         * @memberOf! prediction(v1.3)<EOL>         *<EOL>         * @param {object} params Parameters for request<EOL>         * @param {string} params.data mybucket/mydata resource in Google Storage<EOL>         * @param {object} [options] Optionally override request options, such as `url`, `method`, and `encoding`.<EOL>         * @param {callback} callback The callback that handles the response.<EOL>         * @return {object} Request object<EOL>         */<EOL>        delete(params, options, callback) {<EOL>            if (typeof options === '<STR_LIT>') {<EOL>                callback = options;<EOL>                options = {};<EOL>            }<EOL>            options = options || {};<EOL>            const rootUrl = options.rootUrl || '<STR_LIT>';<EOL>            const parameters = {<EOL>                options: Object.assign({<EOL>                    url: (rootUrl + '<STR_LIT>')<EOL>                        .replace(/([^:]\\/)\\/+/g, '<STR_LIT>'),<EOL>                    method: '<STR_LIT>'<EOL>                }, options),<EOL>                params,<EOL>                requiredParams: ['<STR_LIT>'],<EOL>                pathParams: ['<STR_LIT>'],<EOL>                context: self<EOL>            };<EOL>            return createAPIRequest(parameters, callback);<EOL>        },<EOL>        get(params, options, callback) {<EOL>            if (typeof options === '<STR_LIT>') {<EOL>                callback = options;<EOL>                options = {};<EOL>            }<EOL>            options = options || {};<EOL>            const rootUrl = options.rootUrl || '<STR_LIT>';<EOL>            const parameters = {<EOL>                options: Object.assign({<EOL>                    url: (rootUrl + '<STR_LIT>')<EOL>                        .replace(/([^:]\\/)\\/+/g, '<STR_LIT>'),<EOL>                    method: '<STR_LIT>'<EOL>                }, options),<EOL>                params,<EOL>                requiredParams: ['<STR_LIT>'],<EOL>                pathParams: ['<STR_LIT>'],<EOL>                context: self<EOL>            };<EOL>            return createAPIRequest(parameters, callback);<EOL>        },<EOL>        insert(params, options, callback) {<EOL>            if (typeof options === '<STR_LIT>') {<EOL>                callback = options;<EOL>","gt":"options = {};"}
{"input":"<s> /**<EOL> * Prediction API<EOL> *<EOL> * Lets you access a cloud hosted machine learning service that makes it easy to<EOL> * build smart apps<EOL> *<EOL> * @example<EOL> * const google = require('googleapis');<EOL> * const prediction = google.prediction('v1.3');<EOL> *<EOL> * @namespace prediction<EOL> * @type {Function}<EOL> * @version v1.3<EOL> * @variation v1.3<EOL> * @param {object=} options Options for Prediction<EOL> */<EOL>function Prediction(options) {<EOL>    const self = this;<EOL>    self._options = options || {};<EOL>    self.hostedmodels = {<EOL>        /**<EOL>         * prediction.hostedmodels.predict<EOL>         * @desc Submit input and request an output against a hosted model<EOL>         * @alias prediction.hostedmodels.predict<EOL>         * @memberOf! prediction(v1.3)<EOL>         *<EOL>         * @param {object} params Parameters for request<EOL>         * @param {string} params.hostedModelName The name of a hosted model<EOL>         * @param {prediction(v1.3).Input} params.resource Request body data<EOL>         * @param {object} [options] Optionally override request options, such as `url`, `method`, and `encoding`.<EOL>         * @param {callback} callback The callback that handles the response.<EOL>         * @return {object} Request object<EOL>         */<EOL>        predict(params, options, callback) {<EOL>            if (typeof options === '<STR_LIT>') {<EOL>                callback = options;<EOL>                options = {};<EOL>            }<EOL>            options = options || {};<EOL>            const rootUrl = options.rootUrl || '<STR_LIT>';<EOL>            const parameters = {<EOL>                options: Object.assign({<EOL>                    url: (rootUrl +<EOL>                        '<STR_LIT>')<EOL>                        .replace(/([^:]\\/)\\/+/g, '<STR_LIT>'),<EOL>                    method: '<STR_LIT>'<EOL>                }, options),<EOL>                params,<EOL>                requiredParams: ['<STR_LIT>'],<EOL>                pathParams: ['<STR_LIT>'],<EOL>                context: self<EOL>            };<EOL>            return createAPIRequest(parameters, callback);<EOL>        }<EOL>    };<EOL>    self.training = {<EOL>        /**<EOL>         * prediction.training.delete<EOL>         * @desc Delete a trained model<EOL>         * @alias prediction.training.delete<EOL>         * @memberOf! prediction(v1.3)<EOL>         *<EOL>         * @param {object} params Parameters for request<EOL>         * @param {string} params.data mybucket/mydata resource in Google Storage<EOL>         * @param {object} [options] Optionally override request options, such as `url`, `method`, and `encoding`.<EOL>         * @param {callback} callback The callback that handles the response.<EOL>         * @return {object} Request object<EOL>         */<EOL>        delete(params, options, callback) {<EOL>            if (typeof options === '<STR_LIT>') {<EOL>                callback = options;<EOL>                options = {};<EOL>            }<EOL>            options = options || {};<EOL>            const rootUrl = options.rootUrl || '<STR_LIT>';<EOL>            const parameters = {<EOL>                options: Object.assign({<EOL>                    url: (rootUrl + '<STR_LIT>')<EOL>                        .replace(/([^:]\\/)\\/+/g, '<STR_LIT>'),<EOL>                    method: '<STR_LIT>'<EOL>                }, options),<EOL>                params,<EOL>                requiredParams: ['<STR_LIT>'],<EOL>                pathParams: ['<STR_LIT>'],<EOL>                context: self<EOL>            };<EOL>            return createAPIRequest(parameters, callback);<EOL>        },<EOL>        get(params, options, callback) {<EOL>            if (typeof options === '<STR_LIT>') {<EOL>                callback = options;<EOL>                options = {};<EOL>            }<EOL>            options = options || {};<EOL>            const rootUrl = options.rootUrl || '<STR_LIT>';<EOL>            const parameters = {<EOL>                options: Object.assign({<EOL>                    url: (rootUrl + '<STR_LIT>')<EOL>                        .replace(/([^:]\\/)\\/+/g, '<STR_LIT>'),<EOL>                    method: '<STR_LIT>'<EOL>                }, options),<EOL>                params,<EOL>                requiredParams: ['<STR_LIT>'],<EOL>                pathParams: ['<STR_LIT>'],<EOL>                context: self<EOL>            };<EOL>            return createAPIRequest(parameters, callback);<EOL>        },<EOL>        insert(params, options, callback) {<EOL>            if (typeof options === '<STR_LIT>') {<EOL>                callback = options;<EOL>                options = {};<EOL>            }<EOL>            options = options || {};<EOL>            const rootUrl = options.rootUrl || '<STR_LIT>';<EOL>            const parameters = {<EOL>                options:","gt":"Object.assign({"}
{"input":"<s> /**<EOL> * Prediction API<EOL> *<EOL> * Lets you access a cloud hosted machine learning service that makes it easy to<EOL> * build smart apps<EOL> *<EOL> * @example<EOL> * const google = require('googleapis');<EOL> * const prediction = google.prediction('v1.3');<EOL> *<EOL> * @namespace prediction<EOL> * @type {Function}<EOL> * @version v1.3<EOL> * @variation v1.3<EOL> * @param {object=} options Options for Prediction<EOL> */<EOL>function Prediction(options) {<EOL>    const self = this;<EOL>    self._options = options || {};<EOL>    self.hostedmodels = {<EOL>        /**<EOL>         * prediction.hostedmodels.predict<EOL>         * @desc Submit input and request an output against a hosted model<EOL>         * @alias prediction.hostedmodels.predict<EOL>         * @memberOf! prediction(v1.3)<EOL>         *<EOL>         * @param {object} params Parameters for request<EOL>         * @param {string} params.hostedModelName The name of a hosted model<EOL>         * @param {prediction(v1.3).Input} params.resource Request body data<EOL>         * @param {object} [options] Optionally override request options, such as `url`, `method`, and `encoding`.<EOL>         * @param {callback} callback The callback that handles the response.<EOL>         * @return {object} Request object<EOL>         */<EOL>        predict(params, options, callback) {<EOL>            if (typeof options === '<STR_LIT>') {<EOL>                callback = options;<EOL>                options = {};<EOL>            }<EOL>            options = options || {};<EOL>            const rootUrl = options.rootUrl || '<STR_LIT>';<EOL>            const parameters = {<EOL>                options: Object.assign({<EOL>                    url: (rootUrl +<EOL>                        '<STR_LIT>')<EOL>                        .replace(/([^:]\\/)\\/+/g, '<STR_LIT>'),<EOL>                    method: '<STR_LIT>'<EOL>                }, options),<EOL>                params,<EOL>                requiredParams: ['<STR_LIT>'],<EOL>                pathParams: ['<STR_LIT>'],<EOL>                context: self<EOL>            };<EOL>            return createAPIRequest(parameters, callback);<EOL>        }<EOL>    };<EOL>    self.training = {<EOL>        /**<EOL>         * prediction.training.delete<EOL>         * @desc Delete a trained model<EOL>         * @alias prediction.training.delete<EOL>         * @memberOf! prediction(v1.3)<EOL>         *<EOL>         * @param {object} params Parameters for request<EOL>         * @param {string} params.data mybucket/mydata resource in Google Storage<EOL>         * @param {object} [options] Optionally override request options, such as `url`, `method`, and `encoding`.<EOL>         * @param {callback} callback The callback that handles the response.<EOL>         * @return {object} Request object<EOL>         */<EOL>        delete(params, options, callback) {<EOL>            if (typeof options === '<STR_LIT>') {<EOL>                callback = options;<EOL>                options = {};<EOL>            }<EOL>            options = options || {};<EOL>            const rootUrl = options.rootUrl || '<STR_LIT>';<EOL>            const parameters = {<EOL>                options: Object.assign({<EOL>                    url: (rootUrl + '<STR_LIT>')<EOL>                        .replace(/([^:]\\/)\\/+/g, '<STR_LIT>'),<EOL>                    method: '<STR_LIT>'<EOL>                }, options),<EOL>                params,<EOL>                requiredParams: ['<STR_LIT>'],<EOL>                pathParams: ['<STR_LIT>'],<EOL>                context: self<EOL>            };<EOL>            return createAPIRequest(parameters, callback);<EOL>        },<EOL>        get(params, options, callback) {<EOL>            if (typeof options === '<STR_LIT>') {<EOL>                callback = options;<EOL>                options = {};<EOL>            }<EOL>            options = options || {};<EOL>            const rootUrl = options.rootUrl || '<STR_LIT>';<EOL>            const parameters = {<EOL>                options: Object.assign({<EOL>                    url: (rootUrl + '<STR_LIT>')<EOL>                        .replace(/([^:]\\/)\\/+/g, '<STR_LIT>'),<EOL>                    method: '<STR_LIT>'<EOL>                }, options),<EOL>                params,<EOL>                requiredParams: ['<STR_LIT>'],<EOL>                pathParams: ['<STR_LIT>'],<EOL>                context: self<EOL>            };<EOL>            return createAPIRequest(parameters, callback);<EOL>        },<EOL>        insert(params, options, callback) {<EOL>            if (typeof options === '<STR_LIT>') {<EOL>                callback = options;<EOL>                options = {};<EOL>            }<EOL>            options = options || {};<EOL>            const rootUrl = options.rootUrl || '<STR_LIT>';<EOL>            const parameters = {<EOL>                options: Object.assign({<EOL>","gt":"url: (rootUrl + '<STR_LIT>')"}
{"input":"<s> /**<EOL> * Prediction API<EOL> *<EOL> * Lets you access a cloud hosted machine learning service that makes it easy to<EOL> * build smart apps<EOL> *<EOL> * @example<EOL> * const google = require('googleapis');<EOL> * const prediction = google.prediction('v1.3');<EOL> *<EOL> * @namespace prediction<EOL> * @type {Function}<EOL> * @version v1.3<EOL> * @variation v1.3<EOL> * @param {object=} options Options for Prediction<EOL> */<EOL>function Prediction(options) {<EOL>    const self = this;<EOL>    self._options = options || {};<EOL>    self.hostedmodels = {<EOL>        /**<EOL>         * prediction.hostedmodels.predict<EOL>         * @desc Submit input and request an output against a hosted model<EOL>         * @alias prediction.hostedmodels.predict<EOL>         * @memberOf! prediction(v1.3)<EOL>         *<EOL>         * @param {object} params Parameters for request<EOL>         * @param {string} params.hostedModelName The name of a hosted model<EOL>         * @param {prediction(v1.3).Input} params.resource Request body data<EOL>         * @param {object} [options] Optionally override request options, such as `url`, `method`, and `encoding`.<EOL>         * @param {callback} callback The callback that handles the response.<EOL>         * @return {object} Request object<EOL>         */<EOL>        predict(params, options, callback) {<EOL>            if (typeof options === '<STR_LIT>') {<EOL>                callback = options;<EOL>                options = {};<EOL>            }<EOL>            options = options || {};<EOL>            const rootUrl = options.rootUrl || '<STR_LIT>';<EOL>            const parameters = {<EOL>                options: Object.assign({<EOL>                    url: (rootUrl +<EOL>                        '<STR_LIT>')<EOL>                        .replace(/([^:]\\/)\\/+/g, '<STR_LIT>'),<EOL>                    method: '<STR_LIT>'<EOL>                }, options),<EOL>                params,<EOL>                requiredParams: ['<STR_LIT>'],<EOL>                pathParams: ['<STR_LIT>'],<EOL>                context: self<EOL>            };<EOL>            return createAPIRequest(parameters, callback);<EOL>        }<EOL>    };<EOL>    self.training = {<EOL>        /**<EOL>         * prediction.training.delete<EOL>         * @desc Delete a trained model<EOL>         * @alias prediction.training.delete<EOL>         * @memberOf! prediction(v1.3)<EOL>         *<EOL>         * @param {object} params Parameters for request<EOL>         * @param {string} params.data mybucket/mydata resource in Google Storage<EOL>         * @param {object} [options] Optionally override request options, such as `url`, `method`, and `encoding`.<EOL>         * @param {callback} callback The callback that handles the response.<EOL>         * @return {object} Request object<EOL>         */<EOL>        delete(params, options, callback) {<EOL>            if (typeof options === '<STR_LIT>') {<EOL>                callback = options;<EOL>                options = {};<EOL>            }<EOL>            options = options || {};<EOL>            const rootUrl = options.rootUrl || '<STR_LIT>';<EOL>            const parameters = {<EOL>                options: Object.assign({<EOL>                    url: (rootUrl + '<STR_LIT>')<EOL>                        .replace(/([^:]\\/)\\/+/g, '<STR_LIT>'),<EOL>                    method: '<STR_LIT>'<EOL>                }, options),<EOL>                params,<EOL>                requiredParams: ['<STR_LIT>'],<EOL>                pathParams: ['<STR_LIT>'],<EOL>                context: self<EOL>            };<EOL>            return createAPIRequest(parameters, callback);<EOL>        },<EOL>        get(params, options, callback) {<EOL>            if (typeof options === '<STR_LIT>') {<EOL>                callback = options;<EOL>                options = {};<EOL>            }<EOL>            options = options || {};<EOL>            const rootUrl = options.rootUrl || '<STR_LIT>';<EOL>            const parameters = {<EOL>                options: Object.assign({<EOL>                    url: (rootUrl + '<STR_LIT>')<EOL>                        .replace(/([^:]\\/)\\/+/g, '<STR_LIT>'),<EOL>                    method: '<STR_LIT>'<EOL>                }, options),<EOL>                params,<EOL>                requiredParams: ['<STR_LIT>'],<EOL>                pathParams: ['<STR_LIT>'],<EOL>                context: self<EOL>            };<EOL>            return createAPIRequest(parameters, callback);<EOL>        },<EOL>        insert(params, options, callback) {<EOL>            if (typeof options === '<STR_LIT>') {<EOL>                callback = options;<EOL>                options = {};<EOL>            }<EOL>            options = options || {};<EOL>            const rootUrl = options.rootUrl || '<STR_LIT>';<EOL>            const parameters = {<EOL>                options: Object.assign({<EOL>                    url: (rootUrl + '<STR_LIT>')<EOL>                        .replace(/([^:]\\/)\\/+/g, '<STR_LIT>'),<EOL>","gt":"method: '<STR_LIT>'"}
{"input":"<s> /**<EOL> * Prediction API<EOL> *<EOL> * Lets you access a cloud hosted machine learning service that makes it easy to<EOL> * build smart apps<EOL> *<EOL> * @example<EOL> * const google = require('googleapis');<EOL> * const prediction = google.prediction('v1.3');<EOL> *<EOL> * @namespace prediction<EOL> * @type {Function}<EOL> * @version v1.3<EOL> * @variation v1.3<EOL> * @param {object=} options Options for Prediction<EOL> */<EOL>function Prediction(options) {<EOL>    const self = this;<EOL>    self._options = options || {};<EOL>    self.hostedmodels = {<EOL>        /**<EOL>         * prediction.hostedmodels.predict<EOL>         * @desc Submit input and request an output against a hosted model<EOL>         * @alias prediction.hostedmodels.predict<EOL>         * @memberOf! prediction(v1.3)<EOL>         *<EOL>         * @param {object} params Parameters for request<EOL>         * @param {string} params.hostedModelName The name of a hosted model<EOL>         * @param {prediction(v1.3).Input} params.resource Request body data<EOL>         * @param {object} [options] Optionally override request options, such as `url`, `method`, and `encoding`.<EOL>         * @param {callback} callback The callback that handles the response.<EOL>         * @return {object} Request object<EOL>         */<EOL>        predict(params, options, callback) {<EOL>            if (typeof options === '<STR_LIT>') {<EOL>                callback = options;<EOL>                options = {};<EOL>            }<EOL>            options = options || {};<EOL>            const rootUrl = options.rootUrl || '<STR_LIT>';<EOL>            const parameters = {<EOL>                options: Object.assign({<EOL>                    url: (rootUrl +<EOL>                        '<STR_LIT>')<EOL>                        .replace(/([^:]\\/)\\/+/g, '<STR_LIT>'),<EOL>                    method: '<STR_LIT>'<EOL>                }, options),<EOL>                params,<EOL>                requiredParams: ['<STR_LIT>'],<EOL>                pathParams: ['<STR_LIT>'],<EOL>                context: self<EOL>            };<EOL>            return createAPIRequest(parameters, callback);<EOL>        }<EOL>    };<EOL>    self.training = {<EOL>        /**<EOL>         * prediction.training.delete<EOL>         * @desc Delete a trained model<EOL>         * @alias prediction.training.delete<EOL>         * @memberOf! prediction(v1.3)<EOL>         *<EOL>         * @param {object} params Parameters for request<EOL>         * @param {string} params.data mybucket/mydata resource in Google Storage<EOL>         * @param {object} [options] Optionally override request options, such as `url`, `method`, and `encoding`.<EOL>         * @param {callback} callback The callback that handles the response.<EOL>         * @return {object} Request object<EOL>         */<EOL>        delete(params, options, callback) {<EOL>            if (typeof options === '<STR_LIT>') {<EOL>                callback = options;<EOL>                options = {};<EOL>            }<EOL>            options = options || {};<EOL>            const rootUrl = options.rootUrl || '<STR_LIT>';<EOL>            const parameters = {<EOL>                options: Object.assign({<EOL>                    url: (rootUrl + '<STR_LIT>')<EOL>                        .replace(/([^:]\\/)\\/+/g, '<STR_LIT>'),<EOL>                    method: '<STR_LIT>'<EOL>                }, options),<EOL>                params,<EOL>                requiredParams: ['<STR_LIT>'],<EOL>                pathParams: ['<STR_LIT>'],<EOL>                context: self<EOL>            };<EOL>            return createAPIRequest(parameters, callback);<EOL>        },<EOL>        get(params, options, callback) {<EOL>            if (typeof options === '<STR_LIT>') {<EOL>                callback = options;<EOL>                options = {};<EOL>            }<EOL>            options = options || {};<EOL>            const rootUrl = options.rootUrl || '<STR_LIT>';<EOL>            const parameters = {<EOL>                options: Object.assign({<EOL>                    url: (rootUrl + '<STR_LIT>')<EOL>                        .replace(/([^:]\\/)\\/+/g, '<STR_LIT>'),<EOL>                    method: '<STR_LIT>'<EOL>                }, options),<EOL>                params,<EOL>                requiredParams: ['<STR_LIT>'],<EOL>                pathParams: ['<STR_LIT>'],<EOL>                context: self<EOL>            };<EOL>            return createAPIRequest(parameters, callback);<EOL>        },<EOL>        insert(params, options, callback) {<EOL>            if (typeof options === '<STR_LIT>') {<EOL>                callback = options;<EOL>                options = {};<EOL>            }<EOL>            options = options || {};<EOL>            const rootUrl = options.rootUrl || '<STR_LIT>';<EOL>            const parameters = {<EOL>                options: Object.assign({<EOL>                    url: (rootUrl + '<STR_LIT>')<EOL>                        .replace(/([^:]\\/)\\/+/g, '<STR_LIT>'),<EOL>                    method: '<STR_LIT>'<EOL>                }, options),<EOL>                params,<EOL>                requiredParams: [],<EOL>                pathParams: [],<EOL>                context: self<EOL>            };<EOL>            return createAPIRequest(parameters, callback);<EOL>        },<EOL>        predict(params, options, callback) {<EOL>            if (typeof options === '<STR_LIT>') {<EOL>                callback = options;<EOL>                options = {};<EOL>            }<EOL>            options = options || {};<EOL>            const rootUrl = options.rootUrl || '<STR_LIT>';<EOL>","gt":"const parameters = {"}
{"input":"<s> /**<EOL> * Prediction API<EOL> *<EOL> * Lets you access a cloud hosted machine learning service that makes it easy to<EOL> * build smart apps<EOL> *<EOL> * @example<EOL> * const google = require('googleapis');<EOL> * const prediction = google.prediction('v1.3');<EOL> *<EOL> * @namespace prediction<EOL> * @type {Function}<EOL> * @version v1.3<EOL> * @variation v1.3<EOL> * @param {object=} options Options for Prediction<EOL> */<EOL>function Prediction(options) {<EOL>    const self = this;<EOL>    self._options = options || {};<EOL>    self.hostedmodels = {<EOL>        /**<EOL>         * prediction.hostedmodels.predict<EOL>         * @desc Submit input and request an output against a hosted model<EOL>         * @alias prediction.hostedmodels.predict<EOL>         * @memberOf! prediction(v1.3)<EOL>         *<EOL>         * @param {object} params Parameters for request<EOL>         * @param {string} params.hostedModelName The name of a hosted model<EOL>         * @param {prediction(v1.3).Input} params.resource Request body data<EOL>         * @param {object} [options] Optionally override request options, such as `url`, `method`, and `encoding`.<EOL>         * @param {callback} callback The callback that handles the response.<EOL>         * @return {object} Request object<EOL>         */<EOL>        predict(params, options, callback) {<EOL>            if (typeof options === '<STR_LIT>') {<EOL>                callback = options;<EOL>                options = {};<EOL>            }<EOL>            options = options || {};<EOL>            const rootUrl = options.rootUrl || '<STR_LIT>';<EOL>            const parameters = {<EOL>                options: Object.assign({<EOL>                    url: (rootUrl +<EOL>                        '<STR_LIT>')<EOL>                        .replace(/([^:]\\/)\\/+/g, '<STR_LIT>'),<EOL>                    method: '<STR_LIT>'<EOL>                }, options),<EOL>                params,<EOL>                requiredParams: ['<STR_LIT>'],<EOL>                pathParams: ['<STR_LIT>'],<EOL>                context: self<EOL>            };<EOL>            return createAPIRequest(parameters, callback);<EOL>        }<EOL>    };<EOL>    self.training = {<EOL>        /**<EOL>         * prediction.training.delete<EOL>         * @desc Delete a trained model<EOL>         * @alias prediction.training.delete<EOL>         * @memberOf! prediction(v1.3)<EOL>         *<EOL>         * @param {object} params Parameters for request<EOL>         * @param {string} params.data mybucket/mydata resource in Google Storage<EOL>         * @param {object} [options] Optionally override request options, such as `url`, `method`, and `encoding`.<EOL>         * @param {callback} callback The callback that handles the response.<EOL>         * @return {object} Request object<EOL>         */<EOL>        delete(params, options, callback) {<EOL>            if (typeof options === '<STR_LIT>') {<EOL>                callback = options;<EOL>                options = {};<EOL>            }<EOL>            options = options || {};<EOL>            const rootUrl = options.rootUrl || '<STR_LIT>';<EOL>            const parameters = {<EOL>                options: Object.assign({<EOL>                    url: (rootUrl + '<STR_LIT>')<EOL>                        .replace(/([^:]\\/)\\/+/g, '<STR_LIT>'),<EOL>                    method: '<STR_LIT>'<EOL>                }, options),<EOL>                params,<EOL>                requiredParams: ['<STR_LIT>'],<EOL>                pathParams: ['<STR_LIT>'],<EOL>                context: self<EOL>            };<EOL>            return createAPIRequest(parameters, callback);<EOL>        },<EOL>        get(params, options, callback) {<EOL>            if (typeof options === '<STR_LIT>') {<EOL>                callback = options;<EOL>                options = {};<EOL>            }<EOL>            options = options || {};<EOL>            const rootUrl = options.rootUrl || '<STR_LIT>';<EOL>            const parameters = {<EOL>                options: Object.assign({<EOL>                    url: (rootUrl + '<STR_LIT>')<EOL>                        .replace(/([^:]\\/)\\/+/g, '<STR_LIT>'),<EOL>                    method: '<STR_LIT>'<EOL>                }, options),<EOL>                params,<EOL>                requiredParams: ['<STR_LIT>'],<EOL>                pathParams: ['<STR_LIT>'],<EOL>                context: self<EOL>            };<EOL>            return createAPIRequest(parameters, callback);<EOL>        },<EOL>        insert(params, options, callback) {<EOL>            if (typeof options === '<STR_LIT>') {<EOL>                callback = options;<EOL>                options = {};<EOL>            }<EOL>            options = options || {};<EOL>            const rootUrl = options.rootUrl || '<STR_LIT>';<EOL>            const parameters = {<EOL>                options: Object.assign({<EOL>                    url: (rootUrl + '<STR_LIT>')<EOL>                        .replace(/([^:]\\/)\\/+/g, '<STR_LIT>'),<EOL>                    method: '<STR_LIT>'<EOL>                }, options),<EOL>                params,<EOL>                requiredParams: [],<EOL>                pathParams: [],<EOL>                context: self<EOL>            };<EOL>            return createAPIRequest(parameters, callback);<EOL>        },<EOL>        predict(params, options, callback) {<EOL>            if (typeof options === '<STR_LIT>') {<EOL>                callback = options;<EOL>                options = {};<EOL>            }<EOL>            options = options || {};<EOL>            const rootUrl = options.rootUrl || '<STR_LIT>';<EOL>            const parameters = {<EOL>                options: Object.assign({<EOL>","gt":"url: (rootUrl + '<STR_LIT>')"}
{"input":"<s> /**<EOL> * Prediction API<EOL> *<EOL> * Lets you access a cloud hosted machine learning service that makes it easy to<EOL> * build smart apps<EOL> *<EOL> * @example<EOL> * const google = require('googleapis');<EOL> * const prediction = google.prediction('v1.3');<EOL> *<EOL> * @namespace prediction<EOL> * @type {Function}<EOL> * @version v1.3<EOL> * @variation v1.3<EOL> * @param {object=} options Options for Prediction<EOL> */<EOL>function Prediction(options) {<EOL>    const self = this;<EOL>    self._options = options || {};<EOL>    self.hostedmodels = {<EOL>        /**<EOL>         * prediction.hostedmodels.predict<EOL>         * @desc Submit input and request an output against a hosted model<EOL>         * @alias prediction.hostedmodels.predict<EOL>         * @memberOf! prediction(v1.3)<EOL>         *<EOL>         * @param {object} params Parameters for request<EOL>         * @param {string} params.hostedModelName The name of a hosted model<EOL>         * @param {prediction(v1.3).Input} params.resource Request body data<EOL>         * @param {object} [options] Optionally override request options, such as `url`, `method`, and `encoding`.<EOL>         * @param {callback} callback The callback that handles the response.<EOL>         * @return {object} Request object<EOL>         */<EOL>        predict(params, options, callback) {<EOL>            if (typeof options === '<STR_LIT>') {<EOL>                callback = options;<EOL>                options = {};<EOL>            }<EOL>            options = options || {};<EOL>            const rootUrl = options.rootUrl || '<STR_LIT>';<EOL>            const parameters = {<EOL>                options: Object.assign({<EOL>                    url: (rootUrl +<EOL>                        '<STR_LIT>')<EOL>                        .replace(/([^:]\\/)\\/+/g, '<STR_LIT>'),<EOL>                    method: '<STR_LIT>'<EOL>                }, options),<EOL>                params,<EOL>                requiredParams: ['<STR_LIT>'],<EOL>                pathParams: ['<STR_LIT>'],<EOL>                context: self<EOL>            };<EOL>            return createAPIRequest(parameters, callback);<EOL>        }<EOL>    };<EOL>    self.training = {<EOL>        /**<EOL>         * prediction.training.delete<EOL>         * @desc Delete a trained model<EOL>         * @alias prediction.training.delete<EOL>         * @memberOf! prediction(v1.3)<EOL>         *<EOL>         * @param {object} params Parameters for request<EOL>         * @param {string} params.data mybucket/mydata resource in Google Storage<EOL>         * @param {object} [options] Optionally override request options, such as `url`, `method`, and `encoding`.<EOL>         * @param {callback} callback The callback that handles the response.<EOL>         * @return {object} Request object<EOL>         */<EOL>        delete(params, options, callback) {<EOL>            if (typeof options === '<STR_LIT>') {<EOL>                callback = options;<EOL>                options = {};<EOL>            }<EOL>            options = options || {};<EOL>            const rootUrl = options.rootUrl || '<STR_LIT>';<EOL>            const parameters = {<EOL>                options: Object.assign({<EOL>                    url: (rootUrl + '<STR_LIT>')<EOL>                        .replace(/([^:]\\/)\\/+/g, '<STR_LIT>'),<EOL>                    method: '<STR_LIT>'<EOL>                }, options),<EOL>                params,<EOL>                requiredParams: ['<STR_LIT>'],<EOL>                pathParams: ['<STR_LIT>'],<EOL>                context: self<EOL>            };<EOL>            return createAPIRequest(parameters, callback);<EOL>        },<EOL>        get(params, options, callback) {<EOL>            if (typeof options === '<STR_LIT>') {<EOL>                callback = options;<EOL>                options = {};<EOL>            }<EOL>            options = options || {};<EOL>            const rootUrl = options.rootUrl || '<STR_LIT>';<EOL>            const parameters = {<EOL>                options: Object.assign({<EOL>                    url: (rootUrl + '<STR_LIT>')<EOL>                        .replace(/([^:]\\/)\\/+/g, '<STR_LIT>'),<EOL>                    method: '<STR_LIT>'<EOL>                }, options),<EOL>                params,<EOL>                requiredParams: ['<STR_LIT>'],<EOL>                pathParams: ['<STR_LIT>'],<EOL>                context: self<EOL>            };<EOL>            return createAPIRequest(parameters, callback);<EOL>        },<EOL>        insert(params, options, callback) {<EOL>            if (typeof options === '<STR_LIT>') {<EOL>                callback = options;<EOL>                options = {};<EOL>            }<EOL>            options = options || {};<EOL>            const rootUrl = options.rootUrl || '<STR_LIT>';<EOL>            const parameters = {<EOL>                options: Object.assign({<EOL>                    url: (rootUrl + '<STR_LIT>')<EOL>                        .replace(/([^:]\\/)\\/+/g, '<STR_LIT>'),<EOL>                    method: '<STR_LIT>'<EOL>                }, options),<EOL>                params,<EOL>                requiredParams: [],<EOL>                pathParams: [],<EOL>                context: self<EOL>            };<EOL>            return createAPIRequest(parameters, callback);<EOL>        },<EOL>        predict(params, options, callback) {<EOL>            if (typeof options === '<STR_LIT>') {<EOL>                callback = options;<EOL>                options = {};<EOL>            }<EOL>            options = options || {};<EOL>            const rootUrl = options.rootUrl || '<STR_LIT>';<EOL>            const parameters = {<EOL>                options: Object.assign({<EOL>                    url: (rootUrl + '<STR_LIT>')<EOL>                        .replace(/([^:]\\/)\\/+/g, '<STR_LIT>'),<EOL>                    method: '<STR_LIT>'<EOL>                }, options),<EOL>                params,<EOL>                requiredParams: ['<STR_LIT>'],<EOL>                pathParams: [","gt":"'<STR_LIT>'],"}
{"input":"<s> /**<EOL> * Prediction API<EOL> *<EOL> * Lets you access a cloud hosted machine learning service that makes it easy to<EOL> * build smart apps<EOL> *<EOL> * @example<EOL> * const google = require('googleapis');<EOL> * const prediction = google.prediction('v1.3');<EOL> *<EOL> * @namespace prediction<EOL> * @type {Function}<EOL> * @version v1.3<EOL> * @variation v1.3<EOL> * @param {object=} options Options for Prediction<EOL> */<EOL>function Prediction(options) {<EOL>    const self = this;<EOL>    self._options = options || {};<EOL>    self.hostedmodels = {<EOL>        /**<EOL>         * prediction.hostedmodels.predict<EOL>         * @desc Submit input and request an output against a hosted model<EOL>         * @alias prediction.hostedmodels.predict<EOL>         * @memberOf! prediction(v1.3)<EOL>         *<EOL>         * @param {object} params Parameters for request<EOL>         * @param {string} params.hostedModelName The name of a hosted model<EOL>         * @param {prediction(v1.3).Input} params.resource Request body data<EOL>         * @param {object} [options] Optionally override request options, such as `url`, `method`, and `encoding`.<EOL>         * @param {callback} callback The callback that handles the response.<EOL>         * @return {object} Request object<EOL>         */<EOL>        predict(params, options, callback) {<EOL>            if (typeof options === '<STR_LIT>') {<EOL>                callback = options;<EOL>                options = {};<EOL>            }<EOL>            options = options || {};<EOL>            const rootUrl = options.rootUrl || '<STR_LIT>';<EOL>            const parameters = {<EOL>                options: Object.assign({<EOL>                    url: (rootUrl +<EOL>                        '<STR_LIT>')<EOL>                        .replace(/([^:]\\/)\\/+/g, '<STR_LIT>'),<EOL>                    method: '<STR_LIT>'<EOL>                }, options),<EOL>                params,<EOL>                requiredParams: ['<STR_LIT>'],<EOL>                pathParams: ['<STR_LIT>'],<EOL>                context: self<EOL>            };<EOL>            return createAPIRequest(parameters, callback);<EOL>        }<EOL>    };<EOL>    self.training = {<EOL>        /**<EOL>         * prediction.training.delete<EOL>         * @desc Delete a trained model<EOL>         * @alias prediction.training.delete<EOL>         * @memberOf! prediction(v1.3)<EOL>         *<EOL>         * @param {object} params Parameters for request<EOL>         * @param {string} params.data mybucket/mydata resource in Google Storage<EOL>         * @param {object} [options] Optionally override request options, such as `url`, `method`, and `encoding`.<EOL>         * @param {callback} callback The callback that handles the response.<EOL>         * @return {object} Request object<EOL>         */<EOL>        delete(params, options, callback) {<EOL>            if (typeof options === '<STR_LIT>') {<EOL>                callback = options;<EOL>                options = {};<EOL>            }<EOL>            options = options || {};<EOL>            const rootUrl = options.rootUrl || '<STR_LIT>';<EOL>            const parameters = {<EOL>                options: Object.assign({<EOL>                    url: (rootUrl + '<STR_LIT>')<EOL>                        .replace(/([^:]\\/)\\/+/g, '<STR_LIT>'),<EOL>                    method: '<STR_LIT>'<EOL>                }, options),<EOL>                params,<EOL>                requiredParams: ['<STR_LIT>'],<EOL>                pathParams: ['<STR_LIT>'],<EOL>                context: self<EOL>            };<EOL>            return createAPIRequest(parameters, callback);<EOL>        },<EOL>        get(params, options, callback) {<EOL>            if (typeof options === '<STR_LIT>') {<EOL>                callback = options;<EOL>                options = {};<EOL>            }<EOL>            options = options || {};<EOL>            const rootUrl = options.rootUrl || '<STR_LIT>';<EOL>            const parameters = {<EOL>                options: Object.assign({<EOL>                    url: (rootUrl + '<STR_LIT>')<EOL>                        .replace(/([^:]\\/)\\/+/g, '<STR_LIT>'),<EOL>                    method: '<STR_LIT>'<EOL>                }, options),<EOL>                params,<EOL>                requiredParams: ['<STR_LIT>'],<EOL>                pathParams: ['<STR_LIT>'],<EOL>                context: self<EOL>            };<EOL>            return createAPIRequest(parameters, callback);<EOL>        },<EOL>        insert(params, options, callback) {<EOL>            if (typeof options === '<STR_LIT>') {<EOL>                callback = options;<EOL>                options = {};<EOL>            }<EOL>            options = options || {};<EOL>            const rootUrl = options.rootUrl || '<STR_LIT>';<EOL>            const parameters = {<EOL>                options: Object.assign({<EOL>                    url: (rootUrl + '<STR_LIT>')<EOL>                        .replace(/([^:]\\/)\\/+/g, '<STR_LIT>'),<EOL>                    method: '<STR_LIT>'<EOL>                }, options),<EOL>                params,<EOL>                requiredParams: [],<EOL>                pathParams: [],<EOL>                context: self<EOL>            };<EOL>            return createAPIRequest(parameters, callback);<EOL>        },<EOL>        predict(params, options, callback) {<EOL>            if (typeof options === '<STR_LIT>') {<EOL>                callback = options;<EOL>                options = {};<EOL>            }<EOL>            options = options || {};<EOL>            const rootUrl = options.rootUrl || '<STR_LIT>';<EOL>            const parameters = {<EOL>                options: Object.assign({<EOL>                    url: (rootUrl + '<STR_LIT>')<EOL>                        .replace(/([^:]\\/)\\/+/g, '<STR_LIT>'),<EOL>                    method: '<STR_LIT>'<EOL>                }, options),<EOL>                params,<EOL>                requiredParams: ['<STR_LIT>'],<EOL>                pathParams: ['<STR_LIT>'],<EOL>","gt":"context: self"}
{"input":"<s> /**<EOL> * Prediction API<EOL> *<EOL> * Lets you access a cloud hosted machine learning service that makes it easy to<EOL> * build smart apps<EOL> *<EOL> * @example<EOL> * const google = require('googleapis');<EOL> * const prediction = google.prediction('v1.3');<EOL> *<EOL> * @namespace prediction<EOL> * @type {Function}<EOL> * @version v1.3<EOL> * @variation v1.3<EOL> * @param {object=} options Options for Prediction<EOL> */<EOL>function Prediction(options) {<EOL>    const self = this;<EOL>    self._options = options || {};<EOL>    self.hostedmodels = {<EOL>        /**<EOL>         * prediction.hostedmodels.predict<EOL>         * @desc Submit input and request an output against a hosted model<EOL>         * @alias prediction.hostedmodels.predict<EOL>         * @memberOf! prediction(v1.3)<EOL>         *<EOL>         * @param {object} params Parameters for request<EOL>         * @param {string} params.hostedModelName The name of a hosted model<EOL>         * @param {prediction(v1.3).Input} params.resource Request body data<EOL>         * @param {object} [options] Optionally override request options, such as `url`, `method`, and `encoding`.<EOL>         * @param {callback} callback The callback that handles the response.<EOL>         * @return {object} Request object<EOL>         */<EOL>        predict(params, options, callback) {<EOL>            if (typeof options === '<STR_LIT>') {<EOL>                callback = options;<EOL>                options = {};<EOL>            }<EOL>            options = options || {};<EOL>            const rootUrl = options.rootUrl || '<STR_LIT>';<EOL>            const parameters = {<EOL>                options: Object.assign({<EOL>                    url: (rootUrl +<EOL>                        '<STR_LIT>')<EOL>                        .replace(/([^:]\\/)\\/+/g, '<STR_LIT>'),<EOL>                    method: '<STR_LIT>'<EOL>                }, options),<EOL>                params,<EOL>                requiredParams: ['<STR_LIT>'],<EOL>                pathParams: ['<STR_LIT>'],<EOL>                context: self<EOL>            };<EOL>            return createAPIRequest(parameters, callback);<EOL>        }<EOL>    };<EOL>    self.training = {<EOL>        /**<EOL>         * prediction.training.delete<EOL>         * @desc Delete a trained model<EOL>         * @alias prediction.training.delete<EOL>         * @memberOf! prediction(v1.3)<EOL>         *<EOL>         * @param {object} params Parameters for request<EOL>         * @param {string} params.data mybucket/mydata resource in Google Storage<EOL>         * @param {object} [options] Optionally override request options, such as `url`, `method`, and `encoding`.<EOL>         * @param {callback} callback The callback that handles the response.<EOL>         * @return {object} Request object<EOL>         */<EOL>        delete(params, options, callback) {<EOL>            if (typeof options === '<STR_LIT>') {<EOL>                callback = options;<EOL>                options = {};<EOL>            }<EOL>            options = options || {};<EOL>            const rootUrl = options.rootUrl || '<STR_LIT>';<EOL>            const parameters = {<EOL>                options: Object.assign({<EOL>                    url: (rootUrl + '<STR_LIT>')<EOL>                        .replace(/([^:]\\/)\\/+/g, '<STR_LIT>'),<EOL>                    method: '<STR_LIT>'<EOL>                }, options),<EOL>                params,<EOL>                requiredParams: ['<STR_LIT>'],<EOL>                pathParams: ['<STR_LIT>'],<EOL>                context: self<EOL>            };<EOL>            return createAPIRequest(parameters, callback);<EOL>        },<EOL>        get(params, options, callback) {<EOL>            if (typeof options === '<STR_LIT>') {<EOL>                callback = options;<EOL>                options = {};<EOL>            }<EOL>            options = options || {};<EOL>            const rootUrl = options.rootUrl || '<STR_LIT>';<EOL>            const parameters = {<EOL>                options: Object.assign({<EOL>                    url: (rootUrl + '<STR_LIT>')<EOL>                        .replace(/([^:]\\/)\\/+/g, '<STR_LIT>'),<EOL>                    method: '<STR_LIT>'<EOL>                }, options),<EOL>                params,<EOL>                requiredParams: ['<STR_LIT>'],<EOL>                pathParams: ['<STR_LIT>'],<EOL>                context: self<EOL>            };<EOL>            return createAPIRequest(parameters, callback);<EOL>        },<EOL>        insert(params, options, callback) {<EOL>            if (typeof options === '<STR_LIT>') {<EOL>                callback = options;<EOL>                options = {};<EOL>            }<EOL>            options = options || {};<EOL>            const rootUrl = options.rootUrl || '<STR_LIT>';<EOL>            const parameters = {<EOL>                options: Object.assign({<EOL>                    url: (rootUrl + '<STR_LIT>')<EOL>                        .replace(/([^:]\\/)\\/+/g, '<STR_LIT>'),<EOL>                    method: '<STR_LIT>'<EOL>                }, options),<EOL>                params,<EOL>                requiredParams: [],<EOL>                pathParams: [],<EOL>                context: self<EOL>            };<EOL>            return createAPIRequest(parameters, callback);<EOL>        },<EOL>        predict(params, options, callback) {<EOL>            if (typeof options === '<STR_LIT>') {<EOL>                callback = options;<EOL>                options = {};<EOL>            }<EOL>            options = options || {};<EOL>            const rootUrl = options.rootUrl || '<STR_LIT>';<EOL>            const parameters = {<EOL>                options: Object.assign({<EOL>                    url: (rootUrl + '<STR_LIT>')<EOL>                        .replace(/([^:]\\/)\\/+/g, '<STR_LIT>'),<EOL>                    method: '<STR_LIT>'<EOL>                }, options),<EOL>                params,<EOL>                requiredParams: ['<STR_LIT>'],<EOL>                pathParams: ['<STR_LIT>'],<EOL>                context: self<EOL>            };<EOL>            return createAPIRequest(parameters, callback);<EOL>        },<EOL>        update(params, options, callback) {<EOL>            if (typeof options === '<STR_LIT>') {<EOL>                callback =","gt":"options;"}
{"input":"<s> /**<EOL> * Prediction API<EOL> *<EOL> * Lets you access a cloud hosted machine learning service that makes it easy to<EOL> * build smart apps<EOL> *<EOL> * @example<EOL> * const google = require('googleapis');<EOL> * const prediction = google.prediction('v1.3');<EOL> *<EOL> * @namespace prediction<EOL> * @type {Function}<EOL> * @version v1.3<EOL> * @variation v1.3<EOL> * @param {object=} options Options for Prediction<EOL> */<EOL>function Prediction(options) {<EOL>    const self = this;<EOL>    self._options = options || {};<EOL>    self.hostedmodels = {<EOL>        /**<EOL>         * prediction.hostedmodels.predict<EOL>         * @desc Submit input and request an output against a hosted model<EOL>         * @alias prediction.hostedmodels.predict<EOL>         * @memberOf! prediction(v1.3)<EOL>         *<EOL>         * @param {object} params Parameters for request<EOL>         * @param {string} params.hostedModelName The name of a hosted model<EOL>         * @param {prediction(v1.3).Input} params.resource Request body data<EOL>         * @param {object} [options] Optionally override request options, such as `url`, `method`, and `encoding`.<EOL>         * @param {callback} callback The callback that handles the response.<EOL>         * @return {object} Request object<EOL>         */<EOL>        predict(params, options, callback) {<EOL>            if (typeof options === '<STR_LIT>') {<EOL>                callback = options;<EOL>                options = {};<EOL>            }<EOL>            options = options || {};<EOL>            const rootUrl = options.rootUrl || '<STR_LIT>';<EOL>            const parameters = {<EOL>                options: Object.assign({<EOL>                    url: (rootUrl +<EOL>                        '<STR_LIT>')<EOL>                        .replace(/([^:]\\/)\\/+/g, '<STR_LIT>'),<EOL>                    method: '<STR_LIT>'<EOL>                }, options),<EOL>                params,<EOL>                requiredParams: ['<STR_LIT>'],<EOL>                pathParams: ['<STR_LIT>'],<EOL>                context: self<EOL>            };<EOL>            return createAPIRequest(parameters, callback);<EOL>        }<EOL>    };<EOL>    self.training = {<EOL>        /**<EOL>         * prediction.training.delete<EOL>         * @desc Delete a trained model<EOL>         * @alias prediction.training.delete<EOL>         * @memberOf! prediction(v1.3)<EOL>         *<EOL>         * @param {object} params Parameters for request<EOL>         * @param {string} params.data mybucket/mydata resource in Google Storage<EOL>         * @param {object} [options] Optionally override request options, such as `url`, `method`, and `encoding`.<EOL>         * @param {callback} callback The callback that handles the response.<EOL>         * @return {object} Request object<EOL>         */<EOL>        delete(params, options, callback) {<EOL>            if (typeof options === '<STR_LIT>') {<EOL>                callback = options;<EOL>                options = {};<EOL>            }<EOL>            options = options || {};<EOL>            const rootUrl = options.rootUrl || '<STR_LIT>';<EOL>            const parameters = {<EOL>                options: Object.assign({<EOL>                    url: (rootUrl + '<STR_LIT>')<EOL>                        .replace(/([^:]\\/)\\/+/g, '<STR_LIT>'),<EOL>                    method: '<STR_LIT>'<EOL>                }, options),<EOL>                params,<EOL>                requiredParams: ['<STR_LIT>'],<EOL>                pathParams: ['<STR_LIT>'],<EOL>                context: self<EOL>            };<EOL>            return createAPIRequest(parameters, callback);<EOL>        },<EOL>        get(params, options, callback) {<EOL>            if (typeof options === '<STR_LIT>') {<EOL>                callback = options;<EOL>                options = {};<EOL>            }<EOL>            options = options || {};<EOL>            const rootUrl = options.rootUrl || '<STR_LIT>';<EOL>            const parameters = {<EOL>                options: Object.assign({<EOL>                    url: (rootUrl + '<STR_LIT>')<EOL>                        .replace(/([^:]\\/)\\/+/g, '<STR_LIT>'),<EOL>                    method: '<STR_LIT>'<EOL>                }, options),<EOL>                params,<EOL>                requiredParams: ['<STR_LIT>'],<EOL>                pathParams: ['<STR_LIT>'],<EOL>                context: self<EOL>            };<EOL>            return createAPIRequest(parameters, callback);<EOL>        },<EOL>        insert(params, options, callback) {<EOL>            if (typeof options === '<STR_LIT>') {<EOL>                callback = options;<EOL>                options = {};<EOL>            }<EOL>            options = options || {};<EOL>            const rootUrl = options.rootUrl || '<STR_LIT>';<EOL>            const parameters = {<EOL>                options: Object.assign({<EOL>                    url: (rootUrl + '<STR_LIT>')<EOL>                        .replace(/([^:]\\/)\\/+/g, '<STR_LIT>'),<EOL>                    method: '<STR_LIT>'<EOL>                }, options),<EOL>                params,<EOL>                requiredParams: [],<EOL>                pathParams: [],<EOL>                context: self<EOL>            };<EOL>            return createAPIRequest(parameters, callback);<EOL>        },<EOL>        predict(params, options, callback) {<EOL>            if (typeof options === '<STR_LIT>') {<EOL>                callback = options;<EOL>                options = {};<EOL>            }<EOL>            options = options || {};<EOL>            const rootUrl = options.rootUrl || '<STR_LIT>';<EOL>            const parameters = {<EOL>                options: Object.assign({<EOL>                    url: (rootUrl + '<STR_LIT>')<EOL>                        .replace(/([^:]\\/)\\/+/g, '<STR_LIT>'),<EOL>                    method: '<STR_LIT>'<EOL>                }, options),<EOL>                params,<EOL>                requiredParams: ['<STR_LIT>'],<EOL>                pathParams: ['<STR_LIT>'],<EOL>                context: self<EOL>            };<EOL>            return createAPIRequest(parameters, callback);<EOL>        },<EOL>        update(params, options, callback) {<EOL>            if (typeof options === '<STR_LIT>') {<EOL>                callback = options;<EOL>                options = {};<EOL>            }<EOL>","gt":"options = options || {};"}
{"input":"<s> /**<EOL> * Prediction API<EOL> *<EOL> * Lets you access a cloud hosted machine learning service that makes it easy to<EOL> * build smart apps<EOL> *<EOL> * @example<EOL> * const google = require('googleapis');<EOL> * const prediction = google.prediction('v1.3');<EOL> *<EOL> * @namespace prediction<EOL> * @type {Function}<EOL> * @version v1.3<EOL> * @variation v1.3<EOL> * @param {object=} options Options for Prediction<EOL> */<EOL>function Prediction(options) {<EOL>    const self = this;<EOL>    self._options = options || {};<EOL>    self.hostedmodels = {<EOL>        /**<EOL>         * prediction.hostedmodels.predict<EOL>         * @desc Submit input and request an output against a hosted model<EOL>         * @alias prediction.hostedmodels.predict<EOL>         * @memberOf! prediction(v1.3)<EOL>         *<EOL>         * @param {object} params Parameters for request<EOL>         * @param {string} params.hostedModelName The name of a hosted model<EOL>         * @param {prediction(v1.3).Input} params.resource Request body data<EOL>         * @param {object} [options] Optionally override request options, such as `url`, `method`, and `encoding`.<EOL>         * @param {callback} callback The callback that handles the response.<EOL>         * @return {object} Request object<EOL>         */<EOL>        predict(params, options, callback) {<EOL>            if (typeof options === '<STR_LIT>') {<EOL>                callback = options;<EOL>                options = {};<EOL>            }<EOL>            options = options || {};<EOL>            const rootUrl = options.rootUrl || '<STR_LIT>';<EOL>            const parameters = {<EOL>                options: Object.assign({<EOL>                    url: (rootUrl +<EOL>                        '<STR_LIT>')<EOL>                        .replace(/([^:]\\/)\\/+/g, '<STR_LIT>'),<EOL>                    method: '<STR_LIT>'<EOL>                }, options),<EOL>                params,<EOL>                requiredParams: ['<STR_LIT>'],<EOL>                pathParams: ['<STR_LIT>'],<EOL>                context: self<EOL>            };<EOL>            return createAPIRequest(parameters, callback);<EOL>        }<EOL>    };<EOL>    self.training = {<EOL>        /**<EOL>         * prediction.training.delete<EOL>         * @desc Delete a trained model<EOL>         * @alias prediction.training.delete<EOL>         * @memberOf! prediction(v1.3)<EOL>         *<EOL>         * @param {object} params Parameters for request<EOL>         * @param {string} params.data mybucket/mydata resource in Google Storage<EOL>         * @param {object} [options] Optionally override request options, such as `url`, `method`, and `encoding`.<EOL>         * @param {callback} callback The callback that handles the response.<EOL>         * @return {object} Request object<EOL>         */<EOL>        delete(params, options, callback) {<EOL>            if (typeof options === '<STR_LIT>') {<EOL>                callback = options;<EOL>                options = {};<EOL>            }<EOL>            options = options || {};<EOL>            const rootUrl = options.rootUrl || '<STR_LIT>';<EOL>            const parameters = {<EOL>                options: Object.assign({<EOL>                    url: (rootUrl + '<STR_LIT>')<EOL>                        .replace(/([^:]\\/)\\/+/g, '<STR_LIT>'),<EOL>                    method: '<STR_LIT>'<EOL>                }, options),<EOL>                params,<EOL>                requiredParams: ['<STR_LIT>'],<EOL>                pathParams: ['<STR_LIT>'],<EOL>                context: self<EOL>            };<EOL>            return createAPIRequest(parameters, callback);<EOL>        },<EOL>        get(params, options, callback) {<EOL>            if (typeof options === '<STR_LIT>') {<EOL>                callback = options;<EOL>                options = {};<EOL>            }<EOL>            options = options || {};<EOL>            const rootUrl = options.rootUrl || '<STR_LIT>';<EOL>            const parameters = {<EOL>                options: Object.assign({<EOL>                    url: (rootUrl + '<STR_LIT>')<EOL>                        .replace(/([^:]\\/)\\/+/g, '<STR_LIT>'),<EOL>                    method: '<STR_LIT>'<EOL>                }, options),<EOL>                params,<EOL>                requiredParams: ['<STR_LIT>'],<EOL>                pathParams: ['<STR_LIT>'],<EOL>                context: self<EOL>            };<EOL>            return createAPIRequest(parameters, callback);<EOL>        },<EOL>        insert(params, options, callback) {<EOL>            if (typeof options === '<STR_LIT>') {<EOL>                callback = options;<EOL>                options = {};<EOL>            }<EOL>            options = options || {};<EOL>            const rootUrl = options.rootUrl || '<STR_LIT>';<EOL>            const parameters = {<EOL>                options: Object.assign({<EOL>                    url: (rootUrl + '<STR_LIT>')<EOL>                        .replace(/([^:]\\/)\\/+/g, '<STR_LIT>'),<EOL>                    method: '<STR_LIT>'<EOL>                }, options),<EOL>                params,<EOL>                requiredParams: [],<EOL>                pathParams: [],<EOL>                context: self<EOL>            };<EOL>            return createAPIRequest(parameters, callback);<EOL>        },<EOL>        predict(params, options, callback) {<EOL>            if (typeof options === '<STR_LIT>') {<EOL>                callback = options;<EOL>                options = {};<EOL>            }<EOL>            options = options || {};<EOL>            const rootUrl = options.rootUrl || '<STR_LIT>';<EOL>            const parameters = {<EOL>                options: Object.assign({<EOL>                    url: (rootUrl + '<STR_LIT>')<EOL>                        .replace(/([^:]\\/)\\/+/g, '<STR_LIT>'),<EOL>                    method: '<STR_LIT>'<EOL>                }, options),<EOL>                params,<EOL>                requiredParams: ['<STR_LIT>'],<EOL>                pathParams: ['<STR_LIT>'],<EOL>                context: self<EOL>            };<EOL>            return createAPIRequest(parameters, callback);<EOL>        },<EOL>        update(params, options, callback) {<EOL>            if (typeof options === '<STR_LIT>') {<EOL>                callback = options;<EOL>                options = {};<EOL>            }<EOL>            options = options || {};<EOL>            const rootUrl = options.","gt":"rootUrl || '<STR_LIT>';"}
{"input":"<s> /**<EOL> * Prediction API<EOL> *<EOL> * Lets you access a cloud hosted machine learning service that makes it easy to<EOL> * build smart apps<EOL> *<EOL> * @example<EOL> * const google = require('googleapis');<EOL> * const prediction = google.prediction('v1.3');<EOL> *<EOL> * @namespace prediction<EOL> * @type {Function}<EOL> * @version v1.3<EOL> * @variation v1.3<EOL> * @param {object=} options Options for Prediction<EOL> */<EOL>function Prediction(options) {<EOL>    const self = this;<EOL>    self._options = options || {};<EOL>    self.hostedmodels = {<EOL>        /**<EOL>         * prediction.hostedmodels.predict<EOL>         * @desc Submit input and request an output against a hosted model<EOL>         * @alias prediction.hostedmodels.predict<EOL>         * @memberOf! prediction(v1.3)<EOL>         *<EOL>         * @param {object} params Parameters for request<EOL>         * @param {string} params.hostedModelName The name of a hosted model<EOL>         * @param {prediction(v1.3).Input} params.resource Request body data<EOL>         * @param {object} [options] Optionally override request options, such as `url`, `method`, and `encoding`.<EOL>         * @param {callback} callback The callback that handles the response.<EOL>         * @return {object} Request object<EOL>         */<EOL>        predict(params, options, callback) {<EOL>            if (typeof options === '<STR_LIT>') {<EOL>                callback = options;<EOL>                options = {};<EOL>            }<EOL>            options = options || {};<EOL>            const rootUrl = options.rootUrl || '<STR_LIT>';<EOL>            const parameters = {<EOL>                options: Object.assign({<EOL>                    url: (rootUrl +<EOL>                        '<STR_LIT>')<EOL>                        .replace(/([^:]\\/)\\/+/g, '<STR_LIT>'),<EOL>                    method: '<STR_LIT>'<EOL>                }, options),<EOL>                params,<EOL>                requiredParams: ['<STR_LIT>'],<EOL>                pathParams: ['<STR_LIT>'],<EOL>                context: self<EOL>            };<EOL>            return createAPIRequest(parameters, callback);<EOL>        }<EOL>    };<EOL>    self.training = {<EOL>        /**<EOL>         * prediction.training.delete<EOL>         * @desc Delete a trained model<EOL>         * @alias prediction.training.delete<EOL>         * @memberOf! prediction(v1.3)<EOL>         *<EOL>         * @param {object} params Parameters for request<EOL>         * @param {string} params.data mybucket/mydata resource in Google Storage<EOL>         * @param {object} [options] Optionally override request options, such as `url`, `method`, and `encoding`.<EOL>         * @param {callback} callback The callback that handles the response.<EOL>         * @return {object} Request object<EOL>         */<EOL>        delete(params, options, callback) {<EOL>            if (typeof options === '<STR_LIT>') {<EOL>                callback = options;<EOL>                options = {};<EOL>            }<EOL>            options = options || {};<EOL>            const rootUrl = options.rootUrl || '<STR_LIT>';<EOL>            const parameters = {<EOL>                options: Object.assign({<EOL>                    url: (rootUrl + '<STR_LIT>')<EOL>                        .replace(/([^:]\\/)\\/+/g, '<STR_LIT>'),<EOL>                    method: '<STR_LIT>'<EOL>                }, options),<EOL>                params,<EOL>                requiredParams: ['<STR_LIT>'],<EOL>                pathParams: ['<STR_LIT>'],<EOL>                context: self<EOL>            };<EOL>            return createAPIRequest(parameters, callback);<EOL>        },<EOL>        get(params, options, callback) {<EOL>            if (typeof options === '<STR_LIT>') {<EOL>                callback = options;<EOL>                options = {};<EOL>            }<EOL>            options = options || {};<EOL>            const rootUrl = options.rootUrl || '<STR_LIT>';<EOL>            const parameters = {<EOL>                options: Object.assign({<EOL>                    url: (rootUrl + '<STR_LIT>')<EOL>                        .replace(/([^:]\\/)\\/+/g, '<STR_LIT>'),<EOL>                    method: '<STR_LIT>'<EOL>                }, options),<EOL>                params,<EOL>                requiredParams: ['<STR_LIT>'],<EOL>                pathParams: ['<STR_LIT>'],<EOL>                context: self<EOL>            };<EOL>            return createAPIRequest(parameters, callback);<EOL>        },<EOL>        insert(params, options, callback) {<EOL>            if (typeof options === '<STR_LIT>') {<EOL>                callback = options;<EOL>                options = {};<EOL>            }<EOL>            options = options || {};<EOL>            const rootUrl = options.rootUrl || '<STR_LIT>';<EOL>            const parameters = {<EOL>                options: Object.assign({<EOL>                    url: (rootUrl + '<STR_LIT>')<EOL>                        .replace(/([^:]\\/)\\/+/g, '<STR_LIT>'),<EOL>                    method: '<STR_LIT>'<EOL>                }, options),<EOL>                params,<EOL>                requiredParams: [],<EOL>                pathParams: [],<EOL>                context: self<EOL>            };<EOL>            return createAPIRequest(parameters, callback);<EOL>        },<EOL>        predict(params, options, callback) {<EOL>            if (typeof options === '<STR_LIT>') {<EOL>                callback = options;<EOL>                options = {};<EOL>            }<EOL>            options = options || {};<EOL>            const rootUrl = options.rootUrl || '<STR_LIT>';<EOL>            const parameters = {<EOL>                options: Object.assign({<EOL>                    url: (rootUrl + '<STR_LIT>')<EOL>                        .replace(/([^:]\\/)\\/+/g, '<STR_LIT>'),<EOL>                    method: '<STR_LIT>'<EOL>                }, options),<EOL>                params,<EOL>                requiredParams: ['<STR_LIT>'],<EOL>                pathParams: ['<STR_LIT>'],<EOL>                context: self<EOL>            };<EOL>            return createAPIRequest(parameters, callback);<EOL>        },<EOL>        update(params, options, callback) {<EOL>            if (typeof options === '<STR_LIT>') {<EOL>                callback = options;<EOL>                options = {};<EOL>            }<EOL>            options = options || {};<EOL>            const rootUrl = options.rootUrl || '<STR_LIT>';<EOL>            const parameters = {<EOL>                options: Object.assign({<EOL>                    url: (rootUrl +","gt":"'<STR_LIT>')"}
{"input":"<s> function createCallback<T>(callback: BodyResponseCallback<T>) {<EOL>    return typeof callback === '<STR_LIT>' ? callback : (err: Error | null) => {<EOL>        if (","gt":"err) {"}
{"input":"<s> export function registerLayerType(name: string, layerConstructor: UserLayerConstructor) {<EOL>    layerTypes.set(","gt":"name, layerConstructor);"}
{"input":"<s> function isShadowRoot(node: any): boolean {<EOL>    return node instanceof","gt":"DocumentFragment;"}
{"input":"<s> function stringify(buffer: Buffer) {<EOL>    return byte2hex[buffer[<NUM_LIT>]] + byte2hex[buffer[<NUM_LIT>]] +<EOL>        byte2hex[buffer[<NUM_LIT>]] + byte2hex[buffer[<NUM_LIT>]] + \"<STR_LIT>\" +<EOL>        byte2hex[buffer[<NUM_LIT>]] + byte2hex[buffer[","gt":"<NUM_LIT>]] + \"<STR_LIT>\" +"}
{"input":"<s> export function nil(value: any): boolean {<EOL>    return","gt":"value === null;"}
{"input":"<s> function normalizePlatforms(rawPlatforms: Array<string | Platform> | string | Platform | null | undefined): Array<Platform> {<EOL>    const platforms = rawPlatforms == null || Array.isArray(rawPlatforms) ? (rawPlatforms as Array<string | Platform | null | undefined>) : [rawPlatforms];<EOL>    if (platforms as any == null || platforms.length === <NUM_LIT>) {<EOL>        return [Platform.fromString(process.platform)];<EOL>    }<EOL>    else if (platforms[<NUM_LIT>] === \"<STR_LIT>\") {<EOL>        if (process.platform ===","gt":"Platform.MAC.nodeName) {"}
{"input":"<s> function normalizePlatforms(rawPlatforms: Array<string | Platform> | string | Platform | null | undefined): Array<Platform> {<EOL>    const platforms = rawPlatforms == null || Array.isArray(rawPlatforms) ? (rawPlatforms as Array<string | Platform | null | undefined>) : [rawPlatforms];<EOL>    if (platforms as any == null || platforms.length === <NUM_LIT>) {<EOL>        return [Platform.fromString(process.platform)];<EOL>    }<EOL>    else if (platforms[<NUM_LIT>] === \"<STR_LIT>\") {<EOL>        if (process.platform === Platform.MAC.nodeName) {<EOL>            return [Platform.MAC, Platform.LINUX, Platform.WINDOWS];<EOL>        }<EOL>        else if (process.platform === Platform.LINUX.nodeName) {<EOL>            <EOL>            return [","gt":"Platform.LINUX, Platform.WINDOWS];"}
{"input":"<s> function isCustomMapping(stateDefinition: ParsedValue) {<EOL>    return","gt":"stateDefinition.nodes.length === <NUM_LIT> && stateDefinition.nodes[<NUM_LIT>].type === '<STR_LIT>';"}
{"input":"<s> function resolveBooleanState(mappedStates: MappedStates, stateDefinition: ParsedValue) {<EOL>    const currentState = mappedStates[stateDefinition.type];<EOL>    if (!currentState) {<EOL>        mappedStates[stateDefinition.value] =","gt":"null;"}
{"input":"<s> /**<EOL> * Test transformed stylesheets inline expectation comments<EOL> * rule checking (place just before rule)<EOL> *<EOL> * full options:<EOL> * @check(label)[5] .selector {decl: value}<EOL> *<EOL> * basic:<EOL> * @check .selector<EOL> *<EOL> * with declarations (will check full match and order):<EOL> * @check .selector {decl1: value; decl2: value}<EOL> *<EOL> * label for check:<EOL> * @check(label for test) .selector<EOL> *<EOL> * target generated rules (mixin):<EOL> * @check[4] .selector<EOL> *<EOL> * support multi line declarations:<EOL> * @check .selector {<EOL> *     decl1: value;<EOL> *     decl2: value;<EOL> * }<EOL> *<EOL> * support multi checks:<EOL> * @check .selector<EOL> * @check[1] .selector:hover<EOL> *<EOL> * support atrule params (anything between the @atrule and body or semicolon)<EOL> * @check screen and (min-width: 900px)<EOL> */<EOL>export function testInlineExpects(result: postcss.Root | Context, expectedTestInput?: number) {<EOL>    <EOL>    const isDeprecatedInput = isRoot(result);<EOL>    const","gt":"context = isDeprecatedInput"}
{"input":"<s> /**<EOL> * Test transformed stylesheets inline expectation comments<EOL> * rule checking (place just before rule)<EOL> *<EOL> * full options:<EOL> * @check(label)[5] .selector {decl: value}<EOL> *<EOL> * basic:<EOL> * @check .selector<EOL> *<EOL> * with declarations (will check full match and order):<EOL> * @check .selector {decl1: value; decl2: value}<EOL> *<EOL> * label for check:<EOL> * @check(label for test) .selector<EOL> *<EOL> * target generated rules (mixin):<EOL> * @check[4] .selector<EOL> *<EOL> * support multi line declarations:<EOL> * @check .selector {<EOL> *     decl1: value;<EOL> *     decl2: value;<EOL> * }<EOL> *<EOL> * support multi checks:<EOL> * @check .selector<EOL> * @check[1] .selector:hover<EOL> *<EOL> * support atrule params (anything between the @atrule and body or semicolon)<EOL> * @check screen and (min-width: 900px)<EOL> */<EOL>export function testInlineExpects(result: postcss.Root | Context, expectedTestInput?: number) {<EOL>    <EOL>    const isDeprecatedInput = isRoot(result);<EOL>    const context = isDeprecatedInput<EOL>        ? {<EOL>            meta: {<EOL>                outputAst:","gt":"result,"}
{"input":"<s> /**<EOL> * Test transformed stylesheets inline expectation comments<EOL> * rule checking (place just before rule)<EOL> *<EOL> * full options:<EOL> * @check(label)[5] .selector {decl: value}<EOL> *<EOL> * basic:<EOL> * @check .selector<EOL> *<EOL> * with declarations (will check full match and order):<EOL> * @check .selector {decl1: value; decl2: value}<EOL> *<EOL> * label for check:<EOL> * @check(label for test) .selector<EOL> *<EOL> * target generated rules (mixin):<EOL> * @check[4] .selector<EOL> *<EOL> * support multi line declarations:<EOL> * @check .selector {<EOL> *     decl1: value;<EOL> *     decl2: value;<EOL> * }<EOL> *<EOL> * support multi checks:<EOL> * @check .selector<EOL> * @check[1] .selector:hover<EOL> *<EOL> * support atrule params (anything between the @atrule and body or semicolon)<EOL> * @check screen and (min-width: 900px)<EOL> */<EOL>export function testInlineExpects(result: postcss.Root | Context, expectedTestInput?: number) {<EOL>    <EOL>    const isDeprecatedInput = isRoot(result);<EOL>    const context = isDeprecatedInput<EOL>        ? {<EOL>            meta: {<EOL>                outputAst: result,<EOL>                rawAst: result,<EOL>                diagnostics: null as unknown as StylableMeta['<STR_LIT>'],<EOL>                transformDiagnostics:","gt":"null as unknown as StylableMeta['<STR_LIT>'],"}
{"input":"<s> /**<EOL> * Test transformed stylesheets inline expectation comments<EOL> * rule checking (place just before rule)<EOL> *<EOL> * full options:<EOL> * @check(label)[5] .selector {decl: value}<EOL> *<EOL> * basic:<EOL> * @check .selector<EOL> *<EOL> * with declarations (will check full match and order):<EOL> * @check .selector {decl1: value; decl2: value}<EOL> *<EOL> * label for check:<EOL> * @check(label for test) .selector<EOL> *<EOL> * target generated rules (mixin):<EOL> * @check[4] .selector<EOL> *<EOL> * support multi line declarations:<EOL> * @check .selector {<EOL> *     decl1: value;<EOL> *     decl2: value;<EOL> * }<EOL> *<EOL> * support multi checks:<EOL> * @check .selector<EOL> * @check[1] .selector:hover<EOL> *<EOL> * support atrule params (anything between the @atrule and body or semicolon)<EOL> * @check screen and (min-width: 900px)<EOL> */<EOL>export function testInlineExpects(result: postcss.Root | Context, expectedTestInput?: number) {<EOL>    <EOL>    const isDeprecatedInput = isRoot(result);<EOL>    const context = isDeprecatedInput<EOL>        ? {<EOL>            meta: {<EOL>                outputAst: result,<EOL>                rawAst: result,<EOL>                diagnostics: null as unknown as StylableMeta['<STR_LIT>'],<EOL>                transformDiagnostics: null as unknown as StylableMeta['<STR_LIT>'],<EOL>            },<EOL>        }<EOL>        : result;<EOL>    const rootAst = context.meta.","gt":"rawAst;"}
{"input":"<s> /**<EOL> * Test transformed stylesheets inline expectation comments<EOL> * rule checking (place just before rule)<EOL> *<EOL> * full options:<EOL> * @check(label)[5] .selector {decl: value}<EOL> *<EOL> * basic:<EOL> * @check .selector<EOL> *<EOL> * with declarations (will check full match and order):<EOL> * @check .selector {decl1: value; decl2: value}<EOL> *<EOL> * label for check:<EOL> * @check(label for test) .selector<EOL> *<EOL> * target generated rules (mixin):<EOL> * @check[4] .selector<EOL> *<EOL> * support multi line declarations:<EOL> * @check .selector {<EOL> *     decl1: value;<EOL> *     decl2: value;<EOL> * }<EOL> *<EOL> * support multi checks:<EOL> * @check .selector<EOL> * @check[1] .selector:hover<EOL> *<EOL> * support atrule params (anything between the @atrule and body or semicolon)<EOL> * @check screen and (min-width: 900px)<EOL> */<EOL>export function testInlineExpects(result: postcss.Root | Context, expectedTestInput?: number) {<EOL>    <EOL>    const isDeprecatedInput = isRoot(result);<EOL>    const context = isDeprecatedInput<EOL>        ? {<EOL>            meta: {<EOL>                outputAst: result,<EOL>                rawAst: result,<EOL>                diagnostics: null as unknown as StylableMeta['<STR_LIT>'],<EOL>                transformDiagnostics: null as unknown as StylableMeta['<STR_LIT>'],<EOL>            },<EOL>        }<EOL>        : result;<EOL>    const rootAst = context.meta.rawAst;<EOL>    const expectedTestAmount = expectedTestInput ??<EOL>        (rootAst.toString().match(new RegExp(`<STR_LIT>`, `<STR_LIT>`))?.length || <NUM_LIT>);<EOL>    const checks: Test[] = [];<EOL>    const errors: string[] = [];<EOL>    <EOL>    rootAst.walkComments((comment) => {<EOL>        const input = comment.text.split(/@/gm);<EOL>        const testCommentSrc = comment;<EOL>","gt":"const testCommentTarget = isDeprecatedInput"}
{"input":"<s> /**<EOL> * Test transformed stylesheets inline expectation comments<EOL> * rule checking (place just before rule)<EOL> *<EOL> * full options:<EOL> * @check(label)[5] .selector {decl: value}<EOL> *<EOL> * basic:<EOL> * @check .selector<EOL> *<EOL> * with declarations (will check full match and order):<EOL> * @check .selector {decl1: value; decl2: value}<EOL> *<EOL> * label for check:<EOL> * @check(label for test) .selector<EOL> *<EOL> * target generated rules (mixin):<EOL> * @check[4] .selector<EOL> *<EOL> * support multi line declarations:<EOL> * @check .selector {<EOL> *     decl1: value;<EOL> *     decl2: value;<EOL> * }<EOL> *<EOL> * support multi checks:<EOL> * @check .selector<EOL> * @check[1] .selector:hover<EOL> *<EOL> * support atrule params (anything between the @atrule and body or semicolon)<EOL> * @check screen and (min-width: 900px)<EOL> */<EOL>export function testInlineExpects(result: postcss.Root | Context, expectedTestInput?: number) {<EOL>    <EOL>    const isDeprecatedInput = isRoot(result);<EOL>    const context = isDeprecatedInput<EOL>        ? {<EOL>            meta: {<EOL>                outputAst: result,<EOL>                rawAst: result,<EOL>                diagnostics: null as unknown as StylableMeta['<STR_LIT>'],<EOL>                transformDiagnostics: null as unknown as StylableMeta['<STR_LIT>'],<EOL>            },<EOL>        }<EOL>        : result;<EOL>    const rootAst = context.meta.rawAst;<EOL>    const expectedTestAmount = expectedTestInput ??<EOL>        (rootAst.toString().match(new RegExp(`<STR_LIT>`, `<STR_LIT>`))?.length || <NUM_LIT>);<EOL>    const checks: Test[] = [];<EOL>    const errors: string[] = [];<EOL>    <EOL>    rootAst.walkComments((comment) => {<EOL>        const input = comment.text.split(/@/gm);<EOL>        const testCommentSrc = comment;<EOL>        const testCommentTarget = isDeprecatedInput<EOL>            ? comment<EOL>            : getTargetComment(context.meta, comment) || comment;<EOL>        const nodeTarget = testCommentTarget.next() as AST;<EOL>        const nodeSrc = testCommentSrc.next() as AST;<EOL>        const isRemoved = isRemovedFromTarget(nodeTarget, nodeSrc);<EOL>        if (nodeTarget || nodeSrc) {<EOL>            while (input.length) {<EOL>                const next = `<STR_LIT>` +","gt":"input.shift()!;"}
{"input":"<s> /**<EOL> * Test transformed stylesheets inline expectation comments<EOL> * rule checking (place just before rule)<EOL> *<EOL> * full options:<EOL> * @check(label)[5] .selector {decl: value}<EOL> *<EOL> * basic:<EOL> * @check .selector<EOL> *<EOL> * with declarations (will check full match and order):<EOL> * @check .selector {decl1: value; decl2: value}<EOL> *<EOL> * label for check:<EOL> * @check(label for test) .selector<EOL> *<EOL> * target generated rules (mixin):<EOL> * @check[4] .selector<EOL> *<EOL> * support multi line declarations:<EOL> * @check .selector {<EOL> *     decl1: value;<EOL> *     decl2: value;<EOL> * }<EOL> *<EOL> * support multi checks:<EOL> * @check .selector<EOL> * @check[1] .selector:hover<EOL> *<EOL> * support atrule params (anything between the @atrule and body or semicolon)<EOL> * @check screen and (min-width: 900px)<EOL> */<EOL>export function testInlineExpects(result: postcss.Root | Context, expectedTestInput?: number) {<EOL>    <EOL>    const isDeprecatedInput = isRoot(result);<EOL>    const context = isDeprecatedInput<EOL>        ? {<EOL>            meta: {<EOL>                outputAst: result,<EOL>                rawAst: result,<EOL>                diagnostics: null as unknown as StylableMeta['<STR_LIT>'],<EOL>                transformDiagnostics: null as unknown as StylableMeta['<STR_LIT>'],<EOL>            },<EOL>        }<EOL>        : result;<EOL>    const rootAst = context.meta.rawAst;<EOL>    const expectedTestAmount = expectedTestInput ??<EOL>        (rootAst.toString().match(new RegExp(`<STR_LIT>`, `<STR_LIT>`))?.length || <NUM_LIT>);<EOL>    const checks: Test[] = [];<EOL>    const errors: string[] = [];<EOL>    <EOL>    rootAst.walkComments((comment) => {<EOL>        const input = comment.text.split(/@/gm);<EOL>        const testCommentSrc = comment;<EOL>        const testCommentTarget = isDeprecatedInput<EOL>            ? comment<EOL>            : getTargetComment(context.meta, comment) || comment;<EOL>        const nodeTarget = testCommentTarget.next() as AST;<EOL>        const nodeSrc = testCommentSrc.next() as AST;<EOL>        const isRemoved = isRemovedFromTarget(nodeTarget, nodeSrc);<EOL>        if (nodeTarget || nodeSrc) {<EOL>            while (input.length) {<EOL>                const next = `<STR_LIT>` + input.shift()!;<EOL>                const testMatch = next.match(new RegExp(`<STR_LIT>`, `<STR_LIT>`));<EOL>                if (testMatch) {<EOL>                    const testScope = testMatch[<NUM_LIT>] as TestScopes;<EOL>                    let testInput = next.replace(testScope, `<STR_LIT>`);<EOL>                    <EOL>                    while (input.length &&<EOL>                        !(`<STR_LIT>` + input[<NUM_LIT>]).match(new RegExp(`<STR_LIT>`, `<STR_LIT>`))) {<EOL>                        testInput += `<STR_LIT>` + input.","gt":"shift();"}
{"input":"<s> /**<EOL> * Test transformed stylesheets inline expectation comments<EOL> * rule checking (place just before rule)<EOL> *<EOL> * full options:<EOL> * @check(label)[5] .selector {decl: value}<EOL> *<EOL> * basic:<EOL> * @check .selector<EOL> *<EOL> * with declarations (will check full match and order):<EOL> * @check .selector {decl1: value; decl2: value}<EOL> *<EOL> * label for check:<EOL> * @check(label for test) .selector<EOL> *<EOL> * target generated rules (mixin):<EOL> * @check[4] .selector<EOL> *<EOL> * support multi line declarations:<EOL> * @check .selector {<EOL> *     decl1: value;<EOL> *     decl2: value;<EOL> * }<EOL> *<EOL> * support multi checks:<EOL> * @check .selector<EOL> * @check[1] .selector:hover<EOL> *<EOL> * support atrule params (anything between the @atrule and body or semicolon)<EOL> * @check screen and (min-width: 900px)<EOL> */<EOL>export function testInlineExpects(result: postcss.Root | Context, expectedTestInput?: number) {<EOL>    <EOL>    const isDeprecatedInput = isRoot(result);<EOL>    const context = isDeprecatedInput<EOL>        ? {<EOL>            meta: {<EOL>                outputAst: result,<EOL>                rawAst: result,<EOL>                diagnostics: null as unknown as StylableMeta['<STR_LIT>'],<EOL>                transformDiagnostics: null as unknown as StylableMeta['<STR_LIT>'],<EOL>            },<EOL>        }<EOL>        : result;<EOL>    const rootAst = context.meta.rawAst;<EOL>    const expectedTestAmount = expectedTestInput ??<EOL>        (rootAst.toString().match(new RegExp(`<STR_LIT>`, `<STR_LIT>`))?.length || <NUM_LIT>);<EOL>    const checks: Test[] = [];<EOL>    const errors: string[] = [];<EOL>    <EOL>    rootAst.walkComments((comment) => {<EOL>        const input = comment.text.split(/@/gm);<EOL>        const testCommentSrc = comment;<EOL>        const testCommentTarget = isDeprecatedInput<EOL>            ? comment<EOL>            : getTargetComment(context.meta, comment) || comment;<EOL>        const nodeTarget = testCommentTarget.next() as AST;<EOL>        const nodeSrc = testCommentSrc.next() as AST;<EOL>        const isRemoved = isRemovedFromTarget(nodeTarget, nodeSrc);<EOL>        if (nodeTarget || nodeSrc) {<EOL>            while (input.length) {<EOL>                const next = `<STR_LIT>` + input.shift()!;<EOL>                const testMatch = next.match(new RegExp(`<STR_LIT>`, `<STR_LIT>`));<EOL>                if (testMatch) {<EOL>                    const testScope = testMatch[<NUM_LIT>] as TestScopes;<EOL>                    let testInput = next.replace(testScope, `<STR_LIT>`);<EOL>                    <EOL>                    while (input.length &&<EOL>                        !(`<STR_LIT>` + input[<NUM_LIT>]).match(new RegExp(`<STR_LIT>`, `<STR_LIT>`))) {<EOL>                        testInput += `<STR_LIT>` + input.shift();<EOL>                    }<EOL>                    if (testInput) {<EOL>                        if (isDeprecatedInput &&<EOL>                            (","gt":"testScope === `<STR_LIT>` || testScope === `<STR_LIT>`)) {"}
{"input":"<s> /**<EOL> * Test transformed stylesheets inline expectation comments<EOL> * rule checking (place just before rule)<EOL> *<EOL> * full options:<EOL> * @check(label)[5] .selector {decl: value}<EOL> *<EOL> * basic:<EOL> * @check .selector<EOL> *<EOL> * with declarations (will check full match and order):<EOL> * @check .selector {decl1: value; decl2: value}<EOL> *<EOL> * label for check:<EOL> * @check(label for test) .selector<EOL> *<EOL> * target generated rules (mixin):<EOL> * @check[4] .selector<EOL> *<EOL> * support multi line declarations:<EOL> * @check .selector {<EOL> *     decl1: value;<EOL> *     decl2: value;<EOL> * }<EOL> *<EOL> * support multi checks:<EOL> * @check .selector<EOL> * @check[1] .selector:hover<EOL> *<EOL> * support atrule params (anything between the @atrule and body or semicolon)<EOL> * @check screen and (min-width: 900px)<EOL> */<EOL>export function testInlineExpects(result: postcss.Root | Context, expectedTestInput?: number) {<EOL>    <EOL>    const isDeprecatedInput = isRoot(result);<EOL>    const context = isDeprecatedInput<EOL>        ? {<EOL>            meta: {<EOL>                outputAst: result,<EOL>                rawAst: result,<EOL>                diagnostics: null as unknown as StylableMeta['<STR_LIT>'],<EOL>                transformDiagnostics: null as unknown as StylableMeta['<STR_LIT>'],<EOL>            },<EOL>        }<EOL>        : result;<EOL>    const rootAst = context.meta.rawAst;<EOL>    const expectedTestAmount = expectedTestInput ??<EOL>        (rootAst.toString().match(new RegExp(`<STR_LIT>`, `<STR_LIT>`))?.length || <NUM_LIT>);<EOL>    const checks: Test[] = [];<EOL>    const errors: string[] = [];<EOL>    <EOL>    rootAst.walkComments((comment) => {<EOL>        const input = comment.text.split(/@/gm);<EOL>        const testCommentSrc = comment;<EOL>        const testCommentTarget = isDeprecatedInput<EOL>            ? comment<EOL>            : getTargetComment(context.meta, comment) || comment;<EOL>        const nodeTarget = testCommentTarget.next() as AST;<EOL>        const nodeSrc = testCommentSrc.next() as AST;<EOL>        const isRemoved = isRemovedFromTarget(nodeTarget, nodeSrc);<EOL>        if (nodeTarget || nodeSrc) {<EOL>            while (input.length) {<EOL>                const next = `<STR_LIT>` + input.shift()!;<EOL>                const testMatch = next.match(new RegExp(`<STR_LIT>`, `<STR_LIT>`));<EOL>                if (testMatch) {<EOL>                    const testScope = testMatch[<NUM_LIT>] as TestScopes;<EOL>                    let testInput = next.replace(testScope, `<STR_LIT>`);<EOL>                    <EOL>                    while (input.length &&<EOL>                        !(`<STR_LIT>` + input[<NUM_LIT>]).match(new RegExp(`<STR_LIT>`, `<STR_LIT>`))) {<EOL>                        testInput += `<STR_LIT>` + input.shift();<EOL>                    }<EOL>                    if (testInput) {<EOL>                        if (isDeprecatedInput &&<EOL>                            (testScope === `<STR_LIT>` || testScope === `<STR_LIT>`)) {<EOL>                            <EOL>                            const result: Test = {<EOL>","gt":"type: testScope,"}
{"input":"<s> /**<EOL> * Test transformed stylesheets inline expectation comments<EOL> * rule checking (place just before rule)<EOL> *<EOL> * full options:<EOL> * @check(label)[5] .selector {decl: value}<EOL> *<EOL> * basic:<EOL> * @check .selector<EOL> *<EOL> * with declarations (will check full match and order):<EOL> * @check .selector {decl1: value; decl2: value}<EOL> *<EOL> * label for check:<EOL> * @check(label for test) .selector<EOL> *<EOL> * target generated rules (mixin):<EOL> * @check[4] .selector<EOL> *<EOL> * support multi line declarations:<EOL> * @check .selector {<EOL> *     decl1: value;<EOL> *     decl2: value;<EOL> * }<EOL> *<EOL> * support multi checks:<EOL> * @check .selector<EOL> * @check[1] .selector:hover<EOL> *<EOL> * support atrule params (anything between the @atrule and body or semicolon)<EOL> * @check screen and (min-width: 900px)<EOL> */<EOL>export function testInlineExpects(result: postcss.Root | Context, expectedTestInput?: number) {<EOL>    <EOL>    const isDeprecatedInput = isRoot(result);<EOL>    const context = isDeprecatedInput<EOL>        ? {<EOL>            meta: {<EOL>                outputAst: result,<EOL>                rawAst: result,<EOL>                diagnostics: null as unknown as StylableMeta['<STR_LIT>'],<EOL>                transformDiagnostics: null as unknown as StylableMeta['<STR_LIT>'],<EOL>            },<EOL>        }<EOL>        : result;<EOL>    const rootAst = context.meta.rawAst;<EOL>    const expectedTestAmount = expectedTestInput ??<EOL>        (rootAst.toString().match(new RegExp(`<STR_LIT>`, `<STR_LIT>`))?.length || <NUM_LIT>);<EOL>    const checks: Test[] = [];<EOL>    const errors: string[] = [];<EOL>    <EOL>    rootAst.walkComments((comment) => {<EOL>        const input = comment.text.split(/@/gm);<EOL>        const testCommentSrc = comment;<EOL>        const testCommentTarget = isDeprecatedInput<EOL>            ? comment<EOL>            : getTargetComment(context.meta, comment) || comment;<EOL>        const nodeTarget = testCommentTarget.next() as AST;<EOL>        const nodeSrc = testCommentSrc.next() as AST;<EOL>        const isRemoved = isRemovedFromTarget(nodeTarget, nodeSrc);<EOL>        if (nodeTarget || nodeSrc) {<EOL>            while (input.length) {<EOL>                const next = `<STR_LIT>` + input.shift()!;<EOL>                const testMatch = next.match(new RegExp(`<STR_LIT>`, `<STR_LIT>`));<EOL>                if (testMatch) {<EOL>                    const testScope = testMatch[<NUM_LIT>] as TestScopes;<EOL>                    let testInput = next.replace(testScope, `<STR_LIT>`);<EOL>                    <EOL>                    while (input.length &&<EOL>                        !(`<STR_LIT>` + input[<NUM_LIT>]).match(new RegExp(`<STR_LIT>`, `<STR_LIT>`))) {<EOL>                        testInput += `<STR_LIT>` + input.shift();<EOL>                    }<EOL>                    if (testInput) {<EOL>                        if (isDeprecatedInput &&<EOL>                            (testScope === `<STR_LIT>` || testScope === `<STR_LIT>`)) {<EOL>                            <EOL>                            const result: Test = {<EOL>                                type: testScope,<EOL>                                expectation: testInput.trim(),<EOL>                                errors: [<EOL>                                    testInlineExpectsErrors.deprecatedRootInputNotSupported(testScope + testInput),<EOL>                                ],<EOL>                            };<EOL>                            errors.push(...result.errors);<EOL>                            checks.push(","gt":"result);"}
{"input":"<s> /**<EOL> * Test transformed stylesheets inline expectation comments<EOL> * rule checking (place just before rule)<EOL> *<EOL> * full options:<EOL> * @check(label)[5] .selector {decl: value}<EOL> *<EOL> * basic:<EOL> * @check .selector<EOL> *<EOL> * with declarations (will check full match and order):<EOL> * @check .selector {decl1: value; decl2: value}<EOL> *<EOL> * label for check:<EOL> * @check(label for test) .selector<EOL> *<EOL> * target generated rules (mixin):<EOL> * @check[4] .selector<EOL> *<EOL> * support multi line declarations:<EOL> * @check .selector {<EOL> *     decl1: value;<EOL> *     decl2: value;<EOL> * }<EOL> *<EOL> * support multi checks:<EOL> * @check .selector<EOL> * @check[1] .selector:hover<EOL> *<EOL> * support atrule params (anything between the @atrule and body or semicolon)<EOL> * @check screen and (min-width: 900px)<EOL> */<EOL>export function testInlineExpects(result: postcss.Root | Context, expectedTestInput?: number) {<EOL>    <EOL>    const isDeprecatedInput = isRoot(result);<EOL>    const context = isDeprecatedInput<EOL>        ? {<EOL>            meta: {<EOL>                outputAst: result,<EOL>                rawAst: result,<EOL>                diagnostics: null as unknown as StylableMeta['<STR_LIT>'],<EOL>                transformDiagnostics: null as unknown as StylableMeta['<STR_LIT>'],<EOL>            },<EOL>        }<EOL>        : result;<EOL>    const rootAst = context.meta.rawAst;<EOL>    const expectedTestAmount = expectedTestInput ??<EOL>        (rootAst.toString().match(new RegExp(`<STR_LIT>`, `<STR_LIT>`))?.length || <NUM_LIT>);<EOL>    const checks: Test[] = [];<EOL>    const errors: string[] = [];<EOL>    <EOL>    rootAst.walkComments((comment) => {<EOL>        const input = comment.text.split(/@/gm);<EOL>        const testCommentSrc = comment;<EOL>        const testCommentTarget = isDeprecatedInput<EOL>            ? comment<EOL>            : getTargetComment(context.meta, comment) || comment;<EOL>        const nodeTarget = testCommentTarget.next() as AST;<EOL>        const nodeSrc = testCommentSrc.next() as AST;<EOL>        const isRemoved = isRemovedFromTarget(nodeTarget, nodeSrc);<EOL>        if (nodeTarget || nodeSrc) {<EOL>            while (input.length) {<EOL>                const next = `<STR_LIT>` + input.shift()!;<EOL>                const testMatch = next.match(new RegExp(`<STR_LIT>`, `<STR_LIT>`));<EOL>                if (testMatch) {<EOL>                    const testScope = testMatch[<NUM_LIT>] as TestScopes;<EOL>                    let testInput = next.replace(testScope, `<STR_LIT>`);<EOL>                    <EOL>                    while (input.length &&<EOL>                        !(`<STR_LIT>` + input[<NUM_LIT>]).match(new RegExp(`<STR_LIT>`, `<STR_LIT>`))) {<EOL>                        testInput += `<STR_LIT>` + input.shift();<EOL>                    }<EOL>                    if (testInput) {<EOL>                        if (isDeprecatedInput &&<EOL>                            (testScope === `<STR_LIT>` || testScope === `<STR_LIT>`)) {<EOL>                            <EOL>                            const result: Test = {<EOL>                                type: testScope,<EOL>                                expectation: testInput.trim(),<EOL>                                errors: [<EOL>                                    testInlineExpectsErrors.deprecatedRootInputNotSupported(testScope + testInput),<EOL>                                ],<EOL>                            };<EOL>                            errors.push(...result.errors);<EOL>                            checks.push(result);<EOL>                        }<EOL>                        else {<EOL>                            const result = tests[testScope](context, testInput.trim(), isRemoved ? undefined : nodeTarget, nodeSrc);<EOL>                            result.type = testScope;<EOL>                            errors.push(...result.errors);<EOL>                            checks.","gt":"push("}
{"input":"<s> /**<EOL> * Test transformed stylesheets inline expectation comments<EOL> * rule checking (place just before rule)<EOL> *<EOL> * full options:<EOL> * @check(label)[5] .selector {decl: value}<EOL> *<EOL> * basic:<EOL> * @check .selector<EOL> *<EOL> * with declarations (will check full match and order):<EOL> * @check .selector {decl1: value; decl2: value}<EOL> *<EOL> * label for check:<EOL> * @check(label for test) .selector<EOL> *<EOL> * target generated rules (mixin):<EOL> * @check[4] .selector<EOL> *<EOL> * support multi line declarations:<EOL> * @check .selector {<EOL> *     decl1: value;<EOL> *     decl2: value;<EOL> * }<EOL> *<EOL> * support multi checks:<EOL> * @check .selector<EOL> * @check[1] .selector:hover<EOL> *<EOL> * support atrule params (anything between the @atrule and body or semicolon)<EOL> * @check screen and (min-width: 900px)<EOL> */<EOL>export function testInlineExpects(result: postcss.Root | Context, expectedTestInput?: number) {<EOL>    <EOL>    const isDeprecatedInput = isRoot(result);<EOL>    const context = isDeprecatedInput<EOL>        ? {<EOL>            meta: {<EOL>                outputAst: result,<EOL>                rawAst: result,<EOL>                diagnostics: null as unknown as StylableMeta['<STR_LIT>'],<EOL>                transformDiagnostics: null as unknown as StylableMeta['<STR_LIT>'],<EOL>            },<EOL>        }<EOL>        : result;<EOL>    const rootAst = context.meta.rawAst;<EOL>    const expectedTestAmount = expectedTestInput ??<EOL>        (rootAst.toString().match(new RegExp(`<STR_LIT>`, `<STR_LIT>`))?.length || <NUM_LIT>);<EOL>    const checks: Test[] = [];<EOL>    const errors: string[] = [];<EOL>    <EOL>    rootAst.walkComments((comment) => {<EOL>        const input = comment.text.split(/@/gm);<EOL>        const testCommentSrc = comment;<EOL>        const testCommentTarget = isDeprecatedInput<EOL>            ? comment<EOL>            : getTargetComment(context.meta, comment) || comment;<EOL>        const nodeTarget = testCommentTarget.next() as AST;<EOL>        const nodeSrc = testCommentSrc.next() as AST;<EOL>        const isRemoved = isRemovedFromTarget(nodeTarget, nodeSrc);<EOL>        if (nodeTarget || nodeSrc) {<EOL>            while (input.length) {<EOL>                const next = `<STR_LIT>` + input.shift()!;<EOL>                const testMatch = next.match(new RegExp(`<STR_LIT>`, `<STR_LIT>`));<EOL>                if (testMatch) {<EOL>                    const testScope = testMatch[<NUM_LIT>] as TestScopes;<EOL>                    let testInput = next.replace(testScope, `<STR_LIT>`);<EOL>                    <EOL>                    while (input.length &&<EOL>                        !(`<STR_LIT>` + input[<NUM_LIT>]).match(new RegExp(`<STR_LIT>`, `<STR_LIT>`))) {<EOL>                        testInput += `<STR_LIT>` + input.shift();<EOL>                    }<EOL>                    if (testInput) {<EOL>                        if (isDeprecatedInput &&<EOL>                            (testScope === `<STR_LIT>` || testScope === `<STR_LIT>`)) {<EOL>                            <EOL>                            const result: Test = {<EOL>                                type: testScope,<EOL>                                expectation: testInput.trim(),<EOL>                                errors: [<EOL>                                    testInlineExpectsErrors.deprecatedRootInputNotSupported(testScope + testInput),<EOL>                                ],<EOL>                            };<EOL>                            errors.push(...result.errors);<EOL>                            checks.push(result);<EOL>                        }<EOL>                        else {<EOL>                            const result = tests[testScope](context, testInput.trim(), isRemoved ? undefined : nodeTarget, nodeSrc);<EOL>                            result.type = testScope;<EOL>                            errors.push(...result.errors);<EOL>                            checks.push(","gt":"result);"}
{"input":"<s> /** @internal */<EOL>export async function installAppDeps(args: any) {<EOL>    try {<EOL>        log.info({ version: PACKAGE_VERSION }, \"<STR_LIT>\");<EOL>    }<EOL>    catch (e) {<EOL>        <EOL>        if (!(e instanceof ReferenceError)) {<EOL>            throw e;<EOL>        }<EOL>    }<EOL>    const projectDir = process.cwd();<EOL>    const packageMetadata = new Lazy(() => orNullIfFileNotExist(readJson(path.join(projectDir, \"<STR_LIT>\"))));<EOL>    const config = await getConfig(projectDir, null, null, packageMetadata);<EOL>    const","gt":"muonVersion = config.muonVersion;"}
{"input":"<s> /** @internal */<EOL>export async function installAppDeps(args: any) {<EOL>    try {<EOL>        log.info({ version: PACKAGE_VERSION }, \"<STR_LIT>\");<EOL>    }<EOL>    catch (e) {<EOL>        <EOL>        if (!(e instanceof ReferenceError)) {<EOL>            throw e;<EOL>        }<EOL>    }<EOL>    const projectDir = process.cwd();<EOL>    const packageMetadata = new Lazy(() => orNullIfFileNotExist(readJson(path.join(projectDir, \"<STR_LIT>\"))));<EOL>    const config = await getConfig(projectDir, null, null, packageMetadata);<EOL>    const muonVersion = config.muonVersion;<EOL>    const results = await BluebirdPromise.all<string>([<EOL>        computeDefaultAppDirectory(projectDir, use(config.directories, it => it!.app)),<EOL>        muonVersion == null ? getElectronVersion(projectDir, config, packageMetadata) : BluebirdPromise.resolve(muonVersion),<EOL>    ]);<EOL>    <EOL>    await installOrRebuild(","gt":"config, results[<NUM_LIT>], {"}
{"input":"<s> function main() {<EOL>    return installAppDeps(configureInstallAppDepsCommand(yargs).","gt":"argv);"}
{"input":"<s> function toAccelerator(event: KeyboardEvent): string {<EOL>    let parts: string[] = [];<EOL>    if (event.ctrlKey) {<EOL>        parts.push(\"<STR_LIT>\");<EOL>    }<EOL>    if (event.shiftKey) {<EOL>","gt":"parts.push(\"<STR_LIT>\");"}
{"input":"<s> function waitForElement(selector: string) {<EOL>","gt":"const EC = ExpectedConditions;"}
{"input":"<s> /**<EOL> * Passes a mutable instance of a tree to a callback function so that batches of changes can be applied without creating<EOL> * additional intermediate copies of the tree, which would waste resources unnecessarily. If the input tree is mutable,<EOL> * it is modified and returned as-is, instead of being cloned beforehand.<EOL> *<EOL> * @export<EOL> * @template K The type of keys in the tree<EOL> * @template V The type of values in the tree<EOL> * @param {UpdateTreeCallback<K, V>} callback A callback that will be passed a mutable version of the tree<EOL> * @param {RedBlackTreeStructure<K, V>} tree The tree to be updated<EOL> * @returns {RedBlackTreeStructure<K, V>} An updated version of the tree, with changes applied<EOL> */<EOL>export function updateTree<K, V = null>(callback: UpdateTreeCallback<K, V>, tree: RedBlackTreeStructure<K, V>): RedBlackTreeStructure<K, V> {<EOL>","gt":"callback(tree = C.modify(tree));"}
{"input":"<s> export function join<T>(separator: any, list: ListStructure<T>): string {<EOL>    return","gt":"arrayFrom(list).join(separator);"}
{"input":"<s> /**<EOL> * Factory function that determines where to store JSONP callbacks.<EOL> *<EOL> * Ordinarily JSONP callbacks are stored on the `window` object, but this may not exist<EOL> * in test environments. In that case, callbacks are stored on an anonymous object instead.<EOL> *<EOL> * @stable<EOL> */<EOL>export function jsonpCallbackContext(): Object {<EOL>    if (typeof window === '<STR_LIT>') {<EOL>","gt":"return window;"}
{"input":"<s> <EOL>/**<EOL> * 将多个 Observable 组合以创建一个 Observable，该 Observable 的值是由所有输入 Observables 的值按顺序计算而来的。<EOL> *<EOL> * 如果最后一个参数是函数, 这个函数被用来计算最终发出的值.否则, 返回一个顺序包含所有输入值的数组.<EOL> *<EOL> * @example <caption>从不同的源头结合年龄和名称</caption><EOL> *<EOL> * let age$ = Observable.of<number>(27, 25, 29);<EOL> * let name$ = Observable.of<string>('Foo', 'Bar', 'Beer');<EOL> * let isDev$ = Observable.of<boolean>(true, true, false);<EOL> *<EOL> * Observable<EOL> *     .zip(age$,<EOL> *          name$,<EOL> *          isDev$,<EOL> *          (age: number, name: string, isDev: boolean) => ({ age, name, isDev }))<EOL> *     .subscribe(x => console.log(x));<EOL> *<EOL> * // 输出：<EOL> * // { age: 27, name: 'Foo', isDev: true }<EOL> * // { age: 25, name: 'Bar', isDev: true }<EOL> * // { age: 29, name: 'Beer', isDev: false }<EOL> *<EOL> * @param observables<EOL> * @return {Observable<R>}<EOL> * @static true<EOL> * @name zip<EOL> * @owner Observable<EOL> */<EOL>export function zipStatic<T, R>(...observables: Array<ObservableInput<any> | ((...values: Array<any>) => R)>): Observable<R> {<EOL>    const project = <((...ys: Array<any>) => R)>observables[observables.length - <NUM_LIT>];<EOL>","gt":"if (typeof project === '<STR_LIT>') {"}
{"input":"<s> export async function configureTypescript(configurator: WebpackConfigurator) {<EOL>    const hasTsChecker = configurator.hasDevDependency(\"<STR_LIT>\") || configurator.hasDevDependency(\"<STR_LIT>\");<EOL>    if (!(hasTsChecker || configurator.hasDevDependency(\"<STR_LIT>\"))) {<EOL>        return;<EOL>    }<EOL>    <EOL>    configurator.extensions.splice(","gt":"<NUM_LIT>, <NUM_LIT>, \"<STR_LIT>\", \"<STR_LIT>\");"}
{"input":"<s> export async function configureTypescript(configurator: WebpackConfigurator) {<EOL>    const hasTsChecker = configurator.hasDevDependency(\"<STR_LIT>\") || configurator.hasDevDependency(\"<STR_LIT>\");<EOL>    if (!(hasTsChecker || configurator.hasDevDependency(\"<STR_LIT>\"))) {<EOL>        return;<EOL>    }<EOL>    <EOL>    configurator.extensions.splice(<NUM_LIT>, <NUM_LIT>, \"<STR_LIT>\", \"<STR_LIT>\");<EOL>    const isTranspileOnly = configurator.isTest || (hasTsChecker && !configurator.isProduction);<EOL>    const tsConfigFile = await getFirstExistingFile([path.join(configurator.sourceDir, \"<STR_LIT>\"), path.join(configurator.projectDir, \"<STR_LIT>\")], null);<EOL>    <EOL>    if (tsConfigFile ==","gt":"null) {"}
{"input":"<s> export async function configureTypescript(configurator: WebpackConfigurator) {<EOL>    const hasTsChecker = configurator.hasDevDependency(\"<STR_LIT>\") || configurator.hasDevDependency(\"<STR_LIT>\");<EOL>    if (!(hasTsChecker || configurator.hasDevDependency(\"<STR_LIT>\"))) {<EOL>        return;<EOL>    }<EOL>    <EOL>    configurator.extensions.splice(<NUM_LIT>, <NUM_LIT>, \"<STR_LIT>\", \"<STR_LIT>\");<EOL>    const isTranspileOnly = configurator.isTest || (hasTsChecker && !configurator.isProduction);<EOL>    const tsConfigFile = await getFirstExistingFile([path.join(configurator.sourceDir, \"<STR_LIT>\"), path.join(configurator.projectDir, \"<STR_LIT>\")], null);<EOL>    <EOL>    if (tsConfigFile == null) {<EOL>        throw new Error(`<STR_LIT>`);<EOL>    }<EOL>    if (configurator.debug.enabled) {<EOL>        configurator.debug(`<STR_LIT>`);<EOL>    }<EOL>    <EOL>    if (isTranspileOnly && !configurator.isTest) {<EOL>        const ForkTsCheckerWebpackPlugin = require(\"<STR_LIT>\");<EOL>        configurator.plugins.push(new ForkTsCheckerWebpackPlugin({<EOL>            tsconfig: tsConfigFile,<EOL>","gt":"logger: configurator.env.forkTsCheckerLogger || {"}
{"input":"<s> export async function configureTypescript(configurator: WebpackConfigurator) {<EOL>    const hasTsChecker = configurator.hasDevDependency(\"<STR_LIT>\") || configurator.hasDevDependency(\"<STR_LIT>\");<EOL>    if (!(hasTsChecker || configurator.hasDevDependency(\"<STR_LIT>\"))) {<EOL>        return;<EOL>    }<EOL>    <EOL>    configurator.extensions.splice(<NUM_LIT>, <NUM_LIT>, \"<STR_LIT>\", \"<STR_LIT>\");<EOL>    const isTranspileOnly = configurator.isTest || (hasTsChecker && !configurator.isProduction);<EOL>    const tsConfigFile = await getFirstExistingFile([path.join(configurator.sourceDir, \"<STR_LIT>\"), path.join(configurator.projectDir, \"<STR_LIT>\")], null);<EOL>    <EOL>    if (tsConfigFile == null) {<EOL>        throw new Error(`<STR_LIT>`);<EOL>    }<EOL>    if (configurator.debug.enabled) {<EOL>        configurator.debug(`<STR_LIT>`);<EOL>    }<EOL>    <EOL>    if (isTranspileOnly && !configurator.isTest) {<EOL>        const ForkTsCheckerWebpackPlugin = require(\"<STR_LIT>\");<EOL>        configurator.plugins.push(new ForkTsCheckerWebpackPlugin({<EOL>            tsconfig: tsConfigFile,<EOL>            logger: configurator.env.forkTsCheckerLogger || {<EOL>                info: () => {<EOL>                    <EOL>                },<EOL>                warn: console.warn.bind(console),<EOL>                error: console.error.bind(console),<EOL>            }<EOL>        }));<EOL>    }<EOL>    const tsLoaderOptions: any = {<EOL>        <EOL>        <EOL>        transpileOnly: isTranspileOnly,<EOL>        appendTsSuffixTo: [/\\.vue$/],<EOL>        configFile: tsConfigFile,<EOL>    };<EOL>    if (","gt":"configurator.debug.enabled) {"}
{"input":"<s> export async function configureTypescript(configurator: WebpackConfigurator) {<EOL>    const hasTsChecker = configurator.hasDevDependency(\"<STR_LIT>\") || configurator.hasDevDependency(\"<STR_LIT>\");<EOL>    if (!(hasTsChecker || configurator.hasDevDependency(\"<STR_LIT>\"))) {<EOL>        return;<EOL>    }<EOL>    <EOL>    configurator.extensions.splice(<NUM_LIT>, <NUM_LIT>, \"<STR_LIT>\", \"<STR_LIT>\");<EOL>    const isTranspileOnly = configurator.isTest || (hasTsChecker && !configurator.isProduction);<EOL>    const tsConfigFile = await getFirstExistingFile([path.join(configurator.sourceDir, \"<STR_LIT>\"), path.join(configurator.projectDir, \"<STR_LIT>\")], null);<EOL>    <EOL>    if (tsConfigFile == null) {<EOL>        throw new Error(`<STR_LIT>`);<EOL>    }<EOL>    if (configurator.debug.enabled) {<EOL>        configurator.debug(`<STR_LIT>`);<EOL>    }<EOL>    <EOL>    if (isTranspileOnly && !configurator.isTest) {<EOL>        const ForkTsCheckerWebpackPlugin = require(\"<STR_LIT>\");<EOL>        configurator.plugins.push(new ForkTsCheckerWebpackPlugin({<EOL>            tsconfig: tsConfigFile,<EOL>            logger: configurator.env.forkTsCheckerLogger || {<EOL>                info: () => {<EOL>                    <EOL>                },<EOL>                warn: console.warn.bind(console),<EOL>                error: console.error.bind(console),<EOL>            }<EOL>        }));<EOL>    }<EOL>    const tsLoaderOptions: any = {<EOL>        <EOL>        <EOL>        transpileOnly: isTranspileOnly,<EOL>        appendTsSuffixTo: [/\\.vue$/],<EOL>        configFile: tsConfigFile,<EOL>    };<EOL>    if (configurator.debug.enabled) {<EOL>        configurator.debug(`<STR_LIT>`);<EOL>    }<EOL>    configurator.rules.push({<EOL>        test:","gt":"/\\.tsx?$/,"}
{"input":"<s> export function createBooleanStateClassName(stateName: string, namespace: string) {<EOL>    const escapedNamespace =","gt":"cssesc(namespace, { isIdentifier: true });"}
{"input":"<s> export function configureVue(configurator: WebpackConfigurator) {<EOL>    if (!configurator.hasDependency(\"<STR_LIT>\")) {<EOL>        return;<EOL>    }<EOL>    configurator.","gt":"extensions.push(\"<STR_LIT>\");"}
{"input":"<s> export function configureVue(configurator: WebpackConfigurator) {<EOL>    if (!configurator.hasDependency(\"<STR_LIT>\")) {<EOL>        return;<EOL>    }<EOL>    configurator.extensions.push(\"<STR_LIT>\");<EOL>    Object.assign(configurator.config.resolve!!.alias, {<EOL>        vue$: \"<STR_LIT>\",<EOL>        \"<STR_LIT>\": \"<STR_LIT>\",<EOL>    });<EOL>    if (!configurator.isProduction && configurator.","gt":"type === \"<STR_LIT>\") {"}
{"input":"<s> function action(name: string): string {<EOL>    return","gt":"name.toUpperCase()}`<STR_LIT>;"}
{"input":"<s> function wrap(task: (args: any) => Promise<any>) {<EOL>    return (args: any) => {<EOL>        checkIsOutdated();<EOL>        loadEnv(path.join(process.","gt":"cwd(), \"<STR_LIT>\"))"}
{"input":"<s> export async function createConfigurator(type: ConfigurationType, env: ConfigurationEnv | null) {<EOL>    if (env != null) {<EOL>        <EOL>","gt":"const _env: any = env;"}
{"input":"<s> export async function createConfigurator(type: ConfigurationType, env: ConfigurationEnv | null) {<EOL>    if (env != null) {<EOL>        <EOL>        const _env: any = env;<EOL>        for (const name of [\"<STR_LIT>\", \"<STR_LIT>\", \"<STR_LIT>\"]) {<EOL>            if (_env[name] === \"<STR_LIT>\") {<EOL>                _env[","gt":"name] = true;"}
{"input":"<s> export async function createConfigurator(type: ConfigurationType, env: ConfigurationEnv | null) {<EOL>    if (env != null) {<EOL>        <EOL>        const _env: any = env;<EOL>        for (const name of [\"<STR_LIT>\", \"<STR_LIT>\", \"<STR_LIT>\"]) {<EOL>            if (_env[name] === \"<STR_LIT>\") {<EOL>                _env[name] = true;<EOL>            }<EOL>            else if (_env[name] === \"<STR_LIT>\") {<EOL>                _env[name] = false;<EOL>            }<EOL>        }<EOL>    }<EOL>    if (env ==","gt":"null) {"}
{"input":"<s> export async function createConfigurator(type: ConfigurationType, env: ConfigurationEnv | null) {<EOL>    if (env != null) {<EOL>        <EOL>        const _env: any = env;<EOL>        for (const name of [\"<STR_LIT>\", \"<STR_LIT>\", \"<STR_LIT>\"]) {<EOL>            if (_env[name] === \"<STR_LIT>\") {<EOL>                _env[name] = true;<EOL>            }<EOL>            else if (_env[name] === \"<STR_LIT>\") {<EOL>                _env[name] = false;<EOL>            }<EOL>        }<EOL>    }<EOL>    if (env == null) {<EOL>        env = {};<EOL>    }<EOL>    const projectDir = (env.configuration || {}).projectDir || process.cwd();<EOL>    const packageMetadata = await orNullIfFileNotExist(readJson(path.join(projectDir,","gt":"\"<STR_LIT>\")));"}
{"input":"<s> export async function createConfigurator(type: ConfigurationType, env: ConfigurationEnv | null) {<EOL>    if (env != null) {<EOL>        <EOL>        const _env: any = env;<EOL>        for (const name of [\"<STR_LIT>\", \"<STR_LIT>\", \"<STR_LIT>\"]) {<EOL>            if (_env[name] === \"<STR_LIT>\") {<EOL>                _env[name] = true;<EOL>            }<EOL>            else if (_env[name] === \"<STR_LIT>\") {<EOL>                _env[name] = false;<EOL>            }<EOL>        }<EOL>    }<EOL>    if (env == null) {<EOL>        env = {};<EOL>    }<EOL>    const projectDir = (env.configuration || {}).projectDir || process.cwd();<EOL>    const packageMetadata = await orNullIfFileNotExist(readJson(path.join(projectDir, \"<STR_LIT>\")));<EOL>    const electronWebpackConfig = ((await getConfig({<EOL>        packageKey: \"<STR_LIT>\",<EOL>        configFilename: \"<STR_LIT>\",<EOL>        projectDir,<EOL>        packageMetadata: new Lazy(() => BluebirdPromise.resolve(","gt":"packageMetadata))"}
{"input":"<s> export function isImage(extension: string) {<EOL>    return imageExtensions.includes(","gt":"extension);"}
{"input":"<s> function registerCordovaCommands(context: vscode.ExtensionContext): void {<EOL>    context.subscriptions.push(vscode.commands.registerCommand('<STR_LIT>', () => commandWrapper(CordovaCommandHelper.executeCordovaCommand, ['<STR_LIT>'])));<EOL>    context.subscriptions.push(vscode.commands.registerCommand('<STR_LIT>', () => commandWrapper(CordovaCommandHelper.executeCordovaCommand, ['<STR_LIT>'])));<EOL>    context.subscriptions.push(vscode.commands.registerCommand('<STR_LIT>', () => commandWrapper(CordovaCommandHelper.executeCordovaCommand, ['<STR_LIT>'])));<EOL>    context.subscriptions.push(vscode.commands.registerCommand('<STR_LIT>', () => commandWrapper(CordovaCommandHelper.executeCordovaCommand, ['<STR_LIT>', true])));<EOL>    context.subscriptions.push(vscode.commands.registerCommand('<STR_LIT>', () => commandWrapper(CordovaCommandHelper.executeCordovaCommand, ['<STR_LIT>', true])));<EOL>    context.","gt":"subscriptions.push(vscode.commands.registerCommand('<STR_LIT>', () => commandWrapper(CordovaCommandHelper.executeCordovaCommand, ['<STR_LIT>', true])));"}
{"input":"<s> function registerCordovaCommands(context: vscode.ExtensionContext): void {<EOL>    context.subscriptions.push(vscode.commands.registerCommand('<STR_LIT>', () => commandWrapper(CordovaCommandHelper.executeCordovaCommand, ['<STR_LIT>'])));<EOL>    context.subscriptions.push(vscode.commands.registerCommand('<STR_LIT>', () => commandWrapper(CordovaCommandHelper.executeCordovaCommand, ['<STR_LIT>'])));<EOL>    context.subscriptions.push(vscode.commands.registerCommand('<STR_LIT>', () => commandWrapper(CordovaCommandHelper.executeCordovaCommand, ['<STR_LIT>'])));<EOL>    context.subscriptions.push(vscode.commands.registerCommand('<STR_LIT>', () => commandWrapper(CordovaCommandHelper.executeCordovaCommand, ['<STR_LIT>', true])));<EOL>    context.subscriptions.push(vscode.commands.registerCommand('<STR_LIT>', () => commandWrapper(CordovaCommandHelper.executeCordovaCommand, ['<STR_LIT>', true])));<EOL>    context.subscriptions.push(vscode.commands.registerCommand('<STR_LIT>', () => commandWrapper(CordovaCommandHelper.executeCordovaCommand, ['<STR_LIT>', true])));<EOL>    context.subscriptions.push(vscode.commands.registerCommand('<STR_LIT>', () => {<EOL>        return selectProject()<EOL>            .then((project) => {<EOL>            return launchSimulateCommand(project.cordovaProjectRoot, {","gt":"dir: project.folder.uri.fsPath, target: '<STR_LIT>', platform: '<STR_LIT>' });"}
{"input":"<s> function registerCordovaCommands(context: vscode.ExtensionContext): void {<EOL>    context.subscriptions.push(vscode.commands.registerCommand('<STR_LIT>', () => commandWrapper(CordovaCommandHelper.executeCordovaCommand, ['<STR_LIT>'])));<EOL>    context.subscriptions.push(vscode.commands.registerCommand('<STR_LIT>', () => commandWrapper(CordovaCommandHelper.executeCordovaCommand, ['<STR_LIT>'])));<EOL>    context.subscriptions.push(vscode.commands.registerCommand('<STR_LIT>', () => commandWrapper(CordovaCommandHelper.executeCordovaCommand, ['<STR_LIT>'])));<EOL>    context.subscriptions.push(vscode.commands.registerCommand('<STR_LIT>', () => commandWrapper(CordovaCommandHelper.executeCordovaCommand, ['<STR_LIT>', true])));<EOL>    context.subscriptions.push(vscode.commands.registerCommand('<STR_LIT>', () => commandWrapper(CordovaCommandHelper.executeCordovaCommand, ['<STR_LIT>', true])));<EOL>    context.subscriptions.push(vscode.commands.registerCommand('<STR_LIT>', () => commandWrapper(CordovaCommandHelper.executeCordovaCommand, ['<STR_LIT>', true])));<EOL>    context.subscriptions.push(vscode.commands.registerCommand('<STR_LIT>', () => {<EOL>        return selectProject()<EOL>            .then((project) => {<EOL>            return launchSimulateCommand(project.cordovaProjectRoot, { dir: project.folder.uri.fsPath, target: '<STR_LIT>', platform: '<STR_LIT>' });<EOL>        });<EOL>    }));<EOL>    context.subscriptions.push(vscode.commands.registerCommand('<STR_LIT>', () => {<EOL>        return","gt":"selectProject()"}
{"input":"<s> export function provide(provider: AutocompletionProvider): AutocompletionProvider {<EOL>    return","gt":"provider;"}
{"input":"<s> export function withEditorModel(text: string[], callback: (model: TextModel) => void): void {<EOL>    var model = TextModel.createFromString(text.","gt":"join('<STR_LIT>'));"}
{"input":"<s> function canonizeBranchAlias(alias: string) {<EOL>    if (alias[<NUM_LIT>] === \"<STR_LIT>\") {<EOL>        const steps = parseInt(alias.slice(","gt":"<NUM_LIT>), <NUM_LIT>) || <NUM_LIT>;"}
{"input":"<s> function getSetting(key: string) {<EOL>    return localStorage[localStoragePrefix + key] ===","gt":"'<STR_LIT>' ? true : false;"}
{"input":"<s> function dispatchNext(subscriber: DebounceTimeSubscriber<any>) {<EOL>","gt":"subscriber.debouncedNext();"}
{"input":"<s> export async function transformBackgroundFileIfNeed(file: string, tmpDir: TmpDir): Promise<string> {<EOL>    if (file.endsWith(\"<STR_LIT>\") || file.endsWith(\"<STR_LIT>\")) {<EOL>        return file;<EOL>    }<EOL>    const retinaFile = file.","gt":"replace(/\\.([a-z]+)$/, \"<STR_LIT>\");"}
{"input":"<s> export async function transformBackgroundFileIfNeed(file: string, tmpDir: TmpDir): Promise<string> {<EOL>    if (file.endsWith(\"<STR_LIT>\") || file.endsWith(\"<STR_LIT>\")) {<EOL>        return file;<EOL>    }<EOL>    const retinaFile = file.replace(/\\.([a-z]+)$/, \"<STR_LIT>\");<EOL>    if (await exists(retinaFile)) {<EOL>        const tiffFile = await tmpDir.getTempFile({ suffix: \"<STR_LIT>\" });<EOL>        await exec(\"<STR_LIT>\", [\"<STR_LIT>\", file, retinaFile, \"<STR_LIT>\", tiffFile]);<EOL>        return","gt":"tiffFile;"}
{"input":"<s> /** @internal */<EOL>export function serializeString(data: string) {<EOL>    return '<STR_LIT>' + data.","gt":"match(/.{1,32}/g)!!.map(it => it.match(/.{1,4}/g)!!.join(\"<STR_LIT>\")).join('<STR_LIT>') + '<STR_LIT>';"}
{"input":"<s> export async function tsc(root: string, opts?: TscOptions) {<EOL>    let tscOptions: any = [];<EOL>    root = ensureAbsolutePath(root);<EOL>    opts.project = root;<EOL>    for (const key in opts) {<EOL>        if (opts[key] !==","gt":"undefined) {"}
{"input":"<s> export async function tsc(root: string, opts?: TscOptions) {<EOL>    let tscOptions: any = [];<EOL>    root = ensureAbsolutePath(root);<EOL>    opts.project = root;<EOL>    for (const key in opts) {<EOL>        if (opts[key] !== undefined) {<EOL>            if (key === '<STR_LIT>') {<EOL>                tscOptions.push(`<STR_LIT>`);<EOL>            }<EOL>            else {<EOL>                tscOptions.push(`<STR_LIT>`, String(opts[key]));<EOL>            }<EOL>        }<EOL>    }<EOL>    return new Promise((resolve, reject) => {<EOL>        const proc = spawn(\"<STR_LIT>\" + (/^win/.test(process.platform) ? \"<STR_LIT>\" : \"<STR_LIT>\"), tscOptions, {<EOL>            stdio: \"<STR_LIT>\"<EOL>        });<EOL>        proc.on(\"<STR_LIT>\", function (code) {<EOL>","gt":"if (code === <NUM_LIT>) {"}
{"input":"<s> export function processProjects<P extends string>({ projects, presets }: MultipleProjectsConfig<P>, { defaultOptions = createDefaultOptions() }: ProcessProjectsOptions = {}) {<EOL>    const entities: RawProjectEntity[] = [];<EOL>    if (!Array.isArray(projects) && typeof projects !== '<STR_LIT>') {<EOL>        throw new Error('<STR_LIT>');<EOL>    }<EOL>    if (Array.isArray(projects)) {<EOL>        for (const entry","gt":"of projects) {"}
{"input":"<s> export function processProjects<P extends string>({ projects, presets }: MultipleProjectsConfig<P>, { defaultOptions = createDefaultOptions() }: ProcessProjectsOptions = {}) {<EOL>    const entities: RawProjectEntity[] = [];<EOL>    if (!Array.isArray(projects) && typeof projects !== '<STR_LIT>') {<EOL>        throw new Error('<STR_LIT>');<EOL>    }<EOL>    if (Array.isArray(projects)) {<EOL>        for (const entry of projects) {<EOL>            entities.push(resolveProjectEntry(typeof entry === '<STR_LIT>' ? [entry] : entry, defaultOptions, presets));<EOL>        }<EOL>    }<EOL>","gt":"else if (typeof projects === '<STR_LIT>') {"}
{"input":"<s> function doGetBin(name: string, url: string, checksum: string): Promise<string> {<EOL>    const args = [\"<STR_LIT>\", \"<STR_LIT>\", url, \"<STR_LIT>\", name];<EOL>    if (","gt":"checksum != null) {"}
{"input":"<s> export function configureRequestOptionsFromUrl(url: string, options: RequestOptions) {<EOL>    const parsedUrl = parseUrl(url);<EOL>    options.protocol = parsedUrl.protocol;<EOL>    options.hostname = parsedUrl.hostname;<EOL>    if (parsedUrl.","gt":"port == null) {"}
{"input":"<s> export function configureRequestOptionsFromUrl(url: string, options: RequestOptions) {<EOL>    const parsedUrl = parseUrl(url);<EOL>    options.protocol = parsedUrl.protocol;<EOL>    options.hostname = parsedUrl.hostname;<EOL>    if (parsedUrl.port == null) {<EOL>        if (options.port != null) {<EOL>            delete options.port;<EOL>        }<EOL>    }<EOL>    else {<EOL>","gt":"options.port = parsedUrl.port;"}
{"input":"<s> export function reportDiagnostics(log: Log, diagnosticsMessages: DiagnosticMessages, diagnosticsMode?: string) {<EOL>    let message = '<STR_LIT>';<EOL>    for (const [filePath, diagnostics] of diagnosticsMessages.entries()) {<EOL>        message +=","gt":"diagnostics"}
{"input":"<s> export function isAsset(url: string) {<EOL>","gt":"return !isExternal(url);"}
{"input":"<s> /**<EOL> * The (almost) same tests for both.<EOL> * Only change: the way that the first hero is clicked<EOL> */<EOL>function tests(heroClick: Function) {<EOL>    it('<STR_LIT>', () => {<EOL>        expect(comp.heroes.length).toBe(<NUM_LIT>, '<STR_LIT>');<EOL>    });<EOL>    it(","gt":"'<STR_LIT>', () => {"}
{"input":"<s> /**<EOL> * The (almost) same tests for both.<EOL> * Only change: the way that the first hero is clicked<EOL> */<EOL>function tests(heroClick: Function) {<EOL>    it('<STR_LIT>', () => {<EOL>        expect(comp.heroes.length).toBe(<NUM_LIT>, '<STR_LIT>');<EOL>    });<EOL>    it('<STR_LIT>', () => {<EOL>        fixture.","gt":"detectChanges();"}
{"input":"<s> /**<EOL> * The (almost) same tests for both.<EOL> * Only change: the way that the first hero is clicked<EOL> */<EOL>function tests(heroClick: Function) {<EOL>    it('<STR_LIT>', () => {<EOL>        expect(comp.heroes.length).toBe(<NUM_LIT>, '<STR_LIT>');<EOL>    });<EOL>    it('<STR_LIT>', () => {<EOL>        fixture.detectChanges(); <EOL>        expect(comp.heroes.length).toBe(<NUM_LIT>, '<STR_LIT>');<EOL>    });<EOL>    describe('<STR_LIT>', () => {<EOL>        let router: Router;<EOL>        <EOL>        beforeEach(async(() => {<EOL>","gt":"router = fixture.debugElement.injector.get(Router);"}
{"input":"<s> /**<EOL> * The (almost) same tests for both.<EOL> * Only change: the way that the first hero is clicked<EOL> */<EOL>function tests(heroClick: Function) {<EOL>    it('<STR_LIT>', () => {<EOL>        expect(comp.heroes.length).toBe(<NUM_LIT>, '<STR_LIT>');<EOL>    });<EOL>    it('<STR_LIT>', () => {<EOL>        fixture.detectChanges(); <EOL>        expect(comp.heroes.length).toBe(<NUM_LIT>, '<STR_LIT>');<EOL>    });<EOL>    describe('<STR_LIT>', () => {<EOL>        let router: Router;<EOL>        <EOL>        beforeEach(async(() => {<EOL>            router = fixture.debugElement.injector.get(Router);<EOL>            fixture.detectChanges(); <EOL>            fixture.whenStable() <EOL>                .then(() => fixture.detectChanges()); <EOL>        }));<EOL>        it('<STR_LIT>', () => {<EOL>            expect(comp.heroes.length).toBeGreaterThan(<NUM_LIT>, '<STR_LIT>');<EOL>        });<EOL>        it(","gt":"'<STR_LIT>', () => {"}
{"input":"<s> /**<EOL> * The (almost) same tests for both.<EOL> * Only change: the way that the first hero is clicked<EOL> */<EOL>function tests(heroClick: Function) {<EOL>    it('<STR_LIT>', () => {<EOL>        expect(comp.heroes.length).toBe(<NUM_LIT>, '<STR_LIT>');<EOL>    });<EOL>    it('<STR_LIT>', () => {<EOL>        fixture.detectChanges(); <EOL>        expect(comp.heroes.length).toBe(<NUM_LIT>, '<STR_LIT>');<EOL>    });<EOL>    describe('<STR_LIT>', () => {<EOL>        let router: Router;<EOL>        <EOL>        beforeEach(async(() => {<EOL>            router = fixture.debugElement.injector.get(Router);<EOL>            fixture.detectChanges(); <EOL>            fixture.whenStable() <EOL>                .then(() => fixture.detectChanges()); <EOL>        }));<EOL>        it('<STR_LIT>', () => {<EOL>            expect(comp.heroes.length).toBeGreaterThan(<NUM_LIT>, '<STR_LIT>');<EOL>        });<EOL>        it('<STR_LIT>', () => {<EOL>            <EOL>            <EOL>            const heroes = fixture.nativeElement.querySelectorAll('<STR_LIT>');<EOL>            expect(heroes.length).toBe(<NUM_LIT>, '<STR_LIT>');<EOL>        });<EOL>        <EOL>        it('<STR_LIT>', () => {<EOL>","gt":"heroClick();"}
{"input":"<s> function _angularImportsFromNode(node: ts.ImportDeclaration, _sourceFile: ts.SourceFile): {<EOL>    [name: string]: string;<EOL>} {<EOL>    const ms = node.moduleSpecifier;<EOL>    let modulePath: string;<EOL>    switch (ms.kind) {<EOL>","gt":"case ts.SyntaxKind.StringLiteral:"}
{"input":"<s> function _angularImportsFromNode(node: ts.ImportDeclaration, _sourceFile: ts.SourceFile): {<EOL>    [name: string]: string;<EOL>} {<EOL>    const ms = node.moduleSpecifier;<EOL>    let modulePath: string;<EOL>    switch (ms.kind) {<EOL>        case ts.SyntaxKind.StringLiteral:<EOL>            modulePath = (ms as ts.StringLiteral).text;<EOL>","gt":"break;"}
{"input":"<s> function _angularImportsFromNode(node: ts.ImportDeclaration, _sourceFile: ts.SourceFile): {<EOL>    [name: string]: string;<EOL>} {<EOL>    const ms = node.moduleSpecifier;<EOL>    let modulePath: string;<EOL>    switch (ms.kind) {<EOL>        case ts.SyntaxKind.StringLiteral:<EOL>            modulePath = (ms as ts.StringLiteral).text;<EOL>            break;<EOL>        default:<EOL>            return {};<EOL>    }<EOL>    if (!modulePath.startsWith('<STR_LIT>')) {<EOL>        return {};<EOL>    }<EOL>    if (node.importClause) {<EOL>        if (","gt":"node.importClause.name) {"}
{"input":"<s> function _angularImportsFromNode(node: ts.ImportDeclaration, _sourceFile: ts.SourceFile): {<EOL>    [name: string]: string;<EOL>} {<EOL>    const ms = node.moduleSpecifier;<EOL>    let modulePath: string;<EOL>    switch (ms.kind) {<EOL>        case ts.SyntaxKind.StringLiteral:<EOL>            modulePath = (ms as ts.StringLiteral).text;<EOL>            break;<EOL>        default:<EOL>            return {};<EOL>    }<EOL>    if (!modulePath.startsWith('<STR_LIT>')) {<EOL>        return {};<EOL>    }<EOL>    if (node.importClause) {<EOL>        if (node.importClause.name) {<EOL>            <EOL>            return {};<EOL>        }<EOL>        else if (node.importClause.namedBindings) {<EOL>","gt":"const nb = node.importClause.namedBindings;"}
{"input":"<s> function _angularImportsFromNode(node: ts.ImportDeclaration, _sourceFile: ts.SourceFile): {<EOL>    [name: string]: string;<EOL>} {<EOL>    const ms = node.moduleSpecifier;<EOL>    let modulePath: string;<EOL>    switch (ms.kind) {<EOL>        case ts.SyntaxKind.StringLiteral:<EOL>            modulePath = (ms as ts.StringLiteral).text;<EOL>            break;<EOL>        default:<EOL>            return {};<EOL>    }<EOL>    if (!modulePath.startsWith('<STR_LIT>')) {<EOL>        return {};<EOL>    }<EOL>    if (node.importClause) {<EOL>        if (node.importClause.name) {<EOL>            <EOL>            return {};<EOL>        }<EOL>        else if (node.importClause.namedBindings) {<EOL>            const nb = node.importClause.namedBindings;<EOL>            if (nb.kind == ts.SyntaxKind.NamespaceImport) {<EOL>                <EOL>                return {<EOL>                    [(nb as ts.NamespaceImport).name.text + '<STR_LIT>']:","gt":"modulePath,"}
{"input":"<s> function _angularImportsFromNode(node: ts.ImportDeclaration, _sourceFile: ts.SourceFile): {<EOL>    [name: string]: string;<EOL>} {<EOL>    const ms = node.moduleSpecifier;<EOL>    let modulePath: string;<EOL>    switch (ms.kind) {<EOL>        case ts.SyntaxKind.StringLiteral:<EOL>            modulePath = (ms as ts.StringLiteral).text;<EOL>            break;<EOL>        default:<EOL>            return {};<EOL>    }<EOL>    if (!modulePath.startsWith('<STR_LIT>')) {<EOL>        return {};<EOL>    }<EOL>    if (node.importClause) {<EOL>        if (node.importClause.name) {<EOL>            <EOL>            return {};<EOL>        }<EOL>        else if (node.importClause.namedBindings) {<EOL>            const nb = node.importClause.namedBindings;<EOL>            if (nb.kind == ts.SyntaxKind.NamespaceImport) {<EOL>                <EOL>                return {<EOL>                    [(nb as ts.NamespaceImport).name.text + '<STR_LIT>']: modulePath,<EOL>                };<EOL>            }<EOL>            else {<EOL>                <EOL>                const namedImports = nb as ts.NamedImports;<EOL>                return namedImports.elements<EOL>                    .map((is: ts.ImportSpecifier) => is.propertyName ? is.propertyName.text : is.name.text)<EOL>                    .reduce((acc: {<EOL>                    [name: string]: string;<EOL>                }, curr: string) => {<EOL>","gt":"acc[curr] = modulePath;"}
{"input":"<s> function getChannelFilePrefix() {<EOL>    const currentPlatform = getCurrentPlatform();<EOL>    if (currentPlatform === \"<STR_LIT>\") {<EOL>        const arch = process.env.","gt":"TEST_UPDATER_ARCH || process.arch;"}
{"input":"<s> /**<EOL> * Empty directories is never created.<EOL> * Hard links is used if supported and allowed.<EOL> */<EOL>export function copyDir(src: string, destination: string, options: CopyDirOptions = {}): Promise<any> {<EOL>    const fileCopier = new FileCopier(options.isUseHardLink, options.transformer);<EOL>    if (log.isDebugEnabled) {<EOL>        log.debug({ src, destination }, `<STR_LIT>`);<EOL>    }<EOL>    const createdSourceDirs = new","gt":"Set<string>();"}
{"input":"<s> /**<EOL> * Empty directories is never created.<EOL> * Hard links is used if supported and allowed.<EOL> */<EOL>export function copyDir(src: string, destination: string, options: CopyDirOptions = {}): Promise<any> {<EOL>    const fileCopier = new FileCopier(options.isUseHardLink, options.transformer);<EOL>    if (log.isDebugEnabled) {<EOL>        log.debug({ src, destination }, `<STR_LIT>`);<EOL>    }<EOL>    const createdSourceDirs = new Set<string>();<EOL>    const links: Array<Link> = [];<EOL>    return walk(src, options.filter, {<EOL>","gt":"consume: async (file, stat, parent) => {"}
{"input":"<s> /**<EOL> * Empty directories is never created.<EOL> * Hard links is used if supported and allowed.<EOL> */<EOL>export function copyDir(src: string, destination: string, options: CopyDirOptions = {}): Promise<any> {<EOL>    const fileCopier = new FileCopier(options.isUseHardLink, options.transformer);<EOL>    if (log.isDebugEnabled) {<EOL>        log.debug({ src, destination }, `<STR_LIT>`);<EOL>    }<EOL>    const createdSourceDirs = new Set<string>();<EOL>    const links: Array<Link> = [];<EOL>    return walk(src, options.filter, {<EOL>        consume: async (file, stat, parent) => {<EOL>            if (!stat.isFile() && !stat.isSymbolicLink()) {<EOL>                return;<EOL>            }<EOL>            if (!createdSourceDirs.has(parent)) {<EOL>                await ensureDir(parent.replace(src, destination));<EOL>                createdSourceDirs.add(","gt":"parent);"}
{"input":"<s> function clean(version: string) {<EOL>    return version.split(\"<STR_LIT>\").","gt":"length === <NUM_LIT> ? `<STR_LIT>` : version;"}
{"input":"<s> export function assertSyncedModels(text: string, callback: (model: TextModel, assertMirrorModels: () => void) => void, setup: (model: TextModel) => void = null): void {<EOL>    var model = new TextModel(text, TextModel.DEFAULT_CREATION_OPTIONS, null);<EOL>    model.setEOL(EndOfLineSequence.LF);<EOL>    assertLineMapping(model, '<STR_LIT>');<EOL>    if (setup) {<EOL>        setup(","gt":"model);"}
{"input":"<s> export function assertSyncedModels(text: string, callback: (model: TextModel, assertMirrorModels: () => void) => void, setup: (model: TextModel) => void = null): void {<EOL>    var model = new TextModel(text, TextModel.DEFAULT_CREATION_OPTIONS, null);<EOL>    model.setEOL(EndOfLineSequence.LF);<EOL>    assertLineMapping(model, '<STR_LIT>');<EOL>    if (setup) {<EOL>        setup(model);<EOL>        assertLineMapping(model, '<STR_LIT>');<EOL>    }<EOL>    var mirrorModel2 = new MirrorTextModel(null, model.","gt":"getLinesContent(), model.getEOL(), model.getVersionId());"}
{"input":"<s> export function assertSyncedModels(text: string, callback: (model: TextModel, assertMirrorModels: () => void) => void, setup: (model: TextModel) => void = null): void {<EOL>    var model = new TextModel(text, TextModel.DEFAULT_CREATION_OPTIONS, null);<EOL>    model.setEOL(EndOfLineSequence.LF);<EOL>    assertLineMapping(model, '<STR_LIT>');<EOL>    if (setup) {<EOL>        setup(model);<EOL>        assertLineMapping(model, '<STR_LIT>');<EOL>    }<EOL>    var mirrorModel2 = new MirrorTextModel(null, model.getLinesContent(), model.getEOL(), model.getVersionId());<EOL>    var mirrorModel2PrevVersionId = model.getVersionId();<EOL>    model.onDidChangeContent((e: IModelContentChangedEvent) => {<EOL>","gt":"let versionId = e.versionId;"}
{"input":"<s> export function assertSyncedModels(text: string, callback: (model: TextModel, assertMirrorModels: () => void) => void, setup: (model: TextModel) => void = null): void {<EOL>    var model = new TextModel(text, TextModel.DEFAULT_CREATION_OPTIONS, null);<EOL>    model.setEOL(EndOfLineSequence.LF);<EOL>    assertLineMapping(model, '<STR_LIT>');<EOL>    if (setup) {<EOL>        setup(model);<EOL>        assertLineMapping(model, '<STR_LIT>');<EOL>    }<EOL>    var mirrorModel2 = new MirrorTextModel(null, model.getLinesContent(), model.getEOL(), model.getVersionId());<EOL>    var mirrorModel2PrevVersionId = model.getVersionId();<EOL>    model.onDidChangeContent((e: IModelContentChangedEvent) => {<EOL>        let versionId = e.versionId;<EOL>        if (versionId < mirrorModel2PrevVersionId) {<EOL>            console.warn('<STR_LIT>');<EOL>        }<EOL>        mirrorModel2PrevVersionId = versionId;<EOL>        mirrorModel2.onEvents(e);<EOL>    });<EOL>    var assertMirrorModels = () => {<EOL>        assertLineMapping(","gt":"model, '<STR_LIT>');"}
{"input":"<s> async function addDependencies(packageJson: PackageJson, options: Options): Promise<boolean> {<EOL>    let edits = false;<EOL>    const deps: Bag<string> = { '<STR_LIT>': `<STR_LIT>`, '<STR_LIT>': '<STR_LIT>' };<EOL>    if (!packageJson.devDependencies) {<EOL>        packageJson.devDependencies = {};<EOL>    }<EOL>    for (const dep of Object.keys(deps)) {<EOL>        let","gt":"install = true;"}
{"input":"<s> async function addDependencies(packageJson: PackageJson, options: Options): Promise<boolean> {<EOL>    let edits = false;<EOL>    const deps: Bag<string> = { '<STR_LIT>': `<STR_LIT>`, '<STR_LIT>': '<STR_LIT>' };<EOL>    if (!packageJson.devDependencies) {<EOL>        packageJson.devDependencies = {};<EOL>    }<EOL>    for (const dep of Object.keys(deps)) {<EOL>        let install = true;<EOL>        const existing = packageJson.devDependencies[dep];<EOL>        const target = deps[dep];<EOL>        if (existing !== target) {<EOL>            if (existing) {<EOL>","gt":"const message = `<STR_LIT>` +"}
{"input":"<s> async function addDependencies(packageJson: PackageJson, options: Options): Promise<boolean> {<EOL>    let edits = false;<EOL>    const deps: Bag<string> = { '<STR_LIT>': `<STR_LIT>`, '<STR_LIT>': '<STR_LIT>' };<EOL>    if (!packageJson.devDependencies) {<EOL>        packageJson.devDependencies = {};<EOL>    }<EOL>    for (const dep of Object.keys(deps)) {<EOL>        let install = true;<EOL>        const existing = packageJson.devDependencies[dep];<EOL>        const target = deps[dep];<EOL>        if (existing !== target) {<EOL>            if (existing) {<EOL>                const message = `<STR_LIT>` +<EOL>                    `<STR_LIT>`;<EOL>                install = await query(message, '<STR_LIT>', false, options);<EOL>            }<EOL>            if (install) {<EOL>                packageJson.devDependencies[","gt":"dep] = deps[dep];"}
{"input":"<s> function updateLaunchJsonDecorations(editor: vscode.TextEditor | undefined): void {<EOL>    if (!editor || path.basename(editor.document.fileName) !== '<STR_LIT>') {<EOL>        return;<EOL>    }<EOL>    const ranges: vscode.Range[] = [];<EOL>    let addPropertyAndValue = false;<EOL>","gt":"let depthInArray = <NUM_LIT>;"}
{"input":"<s> function updateLaunchJsonDecorations(editor: vscode.TextEditor | undefined): void {<EOL>    if (!editor || path.basename(editor.document.fileName) !== '<STR_LIT>') {<EOL>        return;<EOL>    }<EOL>    const ranges: vscode.Range[] = [];<EOL>    let addPropertyAndValue = false;<EOL>    let depthInArray = <NUM_LIT>;<EOL>    visit(editor.document.getText(), {<EOL>        onObjectProperty: (property, offset, length) => {<EOL>            <EOL>            <EOL>            addPropertyAndValue = property === '<STR_LIT>' || property === '<STR_LIT>' || property === '<STR_LIT>' || property === '<STR_LIT>' || (property === '<STR_LIT>' && depthInArray === <NUM_LIT>);<EOL>","gt":"if (addPropertyAndValue) {"}
{"input":"<s> function updateLaunchJsonDecorations(editor: vscode.TextEditor | undefined): void {<EOL>    if (!editor || path.basename(editor.document.fileName) !== '<STR_LIT>') {<EOL>        return;<EOL>    }<EOL>    const ranges: vscode.Range[] = [];<EOL>    let addPropertyAndValue = false;<EOL>    let depthInArray = <NUM_LIT>;<EOL>    visit(editor.document.getText(), {<EOL>        onObjectProperty: (property, offset, length) => {<EOL>            <EOL>            <EOL>            addPropertyAndValue = property === '<STR_LIT>' || property === '<STR_LIT>' || property === '<STR_LIT>' || property === '<STR_LIT>' || (property === '<STR_LIT>' && depthInArray === <NUM_LIT>);<EOL>            if (addPropertyAndValue) {<EOL>                ranges.push(new vscode.Range(editor.document.positionAt(offset), editor.document.positionAt(offset + length)));<EOL>            }<EOL>        },<EOL>        onLiteralValue: (value, offset, length) => {<EOL>            if (addPropertyAndValue) {<EOL>                ranges.push(new vscode.Range(editor.document.positionAt(offset), editor.document.positionAt(offset + length)));<EOL>            }<EOL>        },<EOL>        onArrayBegin: (offset: number, length: number) => {<EOL>","gt":"depthInArray++;"}
{"input":"<s> <EOL>/**<EOL> * @param due<EOL> * @param withObservable<EOL> * @param scheduler<EOL> * @return {Observable<R>|WebSocketSubject<T>|Observable<T>}<EOL> * @method timeoutWith<EOL> * @owner Observable<EOL> */<EOL>export function timeoutWith<T, R>(this: Observable<T>, due: number | Date, withObservable: ObservableInput<R>, scheduler: IScheduler = async): Observable<T | R> {<EOL>    let absoluteTimeout =","gt":"isDate(due);"}
{"input":"<s> export function createAtImportProps(importObj: Partial<Pick<Imported, '<STR_LIT>' | '<STR_LIT>' | '<STR_LIT>' | '<STR_LIT>'>>): {<EOL>    name: string;<EOL>    params: string;<EOL>} {<EOL>    const named = Object.entries(importObj.named || {});<EOL>    const keyframes = Object.entries(importObj.keyframes || {});<EOL>    let params = '<STR_LIT>';<EOL>    if (importObj.defaultExport) {<EOL>        params += importObj.","gt":"defaultExport;"}
{"input":"<s> export function createAtImportProps(importObj: Partial<Pick<Imported, '<STR_LIT>' | '<STR_LIT>' | '<STR_LIT>' | '<STR_LIT>'>>): {<EOL>    name: string;<EOL>    params: string;<EOL>} {<EOL>    const named = Object.entries(importObj.named || {});<EOL>    const keyframes = Object.entries(importObj.keyframes || {});<EOL>    let params = '<STR_LIT>';<EOL>    if (importObj.defaultExport) {<EOL>        params += importObj.defaultExport;<EOL>    }<EOL>    if (importObj.defaultExport && (named.length || keyframes.length)) {<EOL>","gt":"params += '<STR_LIT>';"}
{"input":"<s> export function createAtImportProps(importObj: Partial<Pick<Imported, '<STR_LIT>' | '<STR_LIT>' | '<STR_LIT>' | '<STR_LIT>'>>): {<EOL>    name: string;<EOL>    params: string;<EOL>} {<EOL>    const named = Object.entries(importObj.named || {});<EOL>    const keyframes = Object.entries(importObj.keyframes || {});<EOL>    let params = '<STR_LIT>';<EOL>    if (importObj.defaultExport) {<EOL>        params += importObj.defaultExport;<EOL>    }<EOL>    if (importObj.defaultExport && (named.length || keyframes.length)) {<EOL>        params += '<STR_LIT>';<EOL>    }<EOL>    if (named.length || keyframes.length) {<EOL>        params += '<STR_LIT>';<EOL>        const namedParts = getNamedImportParts(named);<EOL>        const","gt":"keyFramesParts = getNamedImportParts(keyframes);"}
{"input":"<s> export function createAtImportProps(importObj: Partial<Pick<Imported, '<STR_LIT>' | '<STR_LIT>' | '<STR_LIT>' | '<STR_LIT>'>>): {<EOL>    name: string;<EOL>    params: string;<EOL>} {<EOL>    const named = Object.entries(importObj.named || {});<EOL>    const keyframes = Object.entries(importObj.keyframes || {});<EOL>    let params = '<STR_LIT>';<EOL>    if (importObj.defaultExport) {<EOL>        params += importObj.defaultExport;<EOL>    }<EOL>    if (importObj.defaultExport && (named.length || keyframes.length)) {<EOL>        params += '<STR_LIT>';<EOL>    }<EOL>    if (named.length || keyframes.length) {<EOL>        params += '<STR_LIT>';<EOL>        const namedParts = getNamedImportParts(named);<EOL>        const keyFramesParts = getNamedImportParts(keyframes);<EOL>        params += namedParts.join('<STR_LIT>');<EOL>        if (keyFramesParts.length) {<EOL>            if (namedParts.length) {<EOL>                params += '<STR_LIT>';<EOL>            }<EOL>            params +=","gt":"'<STR_LIT>')})`<STR_LIT>;"}
{"input":"<s> function _transformProvider(provider: CompileProviderMetadata, { useExisting, useValue, deps }: {<EOL>    useExisting: CompileTokenMetadata;<EOL>    useValue: any;<EOL>    deps: CompileDiDependencyMetadata[];<EOL>}) {<EOL>    return {<EOL>        token: provider.token,<EOL>","gt":"useClass: provider.useClass,"}
{"input":"<s> export function createChecker(types: Array<string | string[]>) {<EOL>    return () => {<EOL>        let index = <NUM_LIT>;<EOL>        return (node: SelectorAstNode) => {<EOL>            const matcher = types[index];<EOL>            if (Array.isArray(matcher)) {<EOL>                return matcher.","gt":"includes(node.type);"}
{"input":"<s> export function registerRedrawWhenSegmentationDisplayStateChanged(displayState: SegmentationDisplayState, renderLayer: {<EOL>    redrawNeeded: NullarySignal;<EOL>} & RefCounted) {<EOL>    const dispatchRedrawNeeded = renderLayer.redrawNeeded.dispatch;<EOL>    renderLayer.","gt":"registerDisposer(displayState.segmentColorHash.changed.add(dispatchRedrawNeeded));"}
{"input":"<s> function getOutputPath(inputPath: string, hash: string) {<EOL>    const","gt":"extension = path.extname(inputPath);"}
{"input":"<s> export function compute7zCompressArgs(format: string, options: ArchiveOptions = {}) {<EOL>    let storeOnly = options.compression === \"<STR_LIT>\";<EOL>    const args =","gt":"debug7zArgs(\"<STR_LIT>\");"}
{"input":"<s> export function compute7zCompressArgs(format: string, options: ArchiveOptions = {}) {<EOL>    let storeOnly = options.compression === \"<STR_LIT>\";<EOL>    const args = debug7zArgs(\"<STR_LIT>\");<EOL>    let isLevelSet = false;<EOL>    if (process.env.ELECTRON_BUILDER_COMPRESSION_LEVEL != null) {<EOL>","gt":"storeOnly = false;"}
{"input":"<s> export function compute7zCompressArgs(format: string, options: ArchiveOptions = {}) {<EOL>    let storeOnly = options.compression === \"<STR_LIT>\";<EOL>    const args = debug7zArgs(\"<STR_LIT>\");<EOL>    let isLevelSet = false;<EOL>    if (process.env.ELECTRON_BUILDER_COMPRESSION_LEVEL != null) {<EOL>        storeOnly = false;<EOL>        args.push(`<STR_LIT>`);<EOL>","gt":"isLevelSet = true;"}
{"input":"<s> export function compute7zCompressArgs(format: string, options: ArchiveOptions = {}) {<EOL>    let storeOnly = options.compression === \"<STR_LIT>\";<EOL>    const args = debug7zArgs(\"<STR_LIT>\");<EOL>    let isLevelSet = false;<EOL>    if (process.env.ELECTRON_BUILDER_COMPRESSION_LEVEL != null) {<EOL>        storeOnly = false;<EOL>        args.push(`<STR_LIT>`);<EOL>        isLevelSet = true;<EOL>    }<EOL>    if (format === \"<STR_LIT>\" && options.compression === \"<STR_LIT>\") {<EOL>        <EOL>        args.push(\"<STR_LIT>\", \"<STR_LIT>\");<EOL>    }<EOL>    if (!isLevelSet && !storeOnly) {<EOL>        args.push(\"<STR_LIT>\");<EOL>    }<EOL>    if (options.dictSize !=","gt":"null) {"}
{"input":"<s> export function compute7zCompressArgs(format: string, options: ArchiveOptions = {}) {<EOL>    let storeOnly = options.compression === \"<STR_LIT>\";<EOL>    const args = debug7zArgs(\"<STR_LIT>\");<EOL>    let isLevelSet = false;<EOL>    if (process.env.ELECTRON_BUILDER_COMPRESSION_LEVEL != null) {<EOL>        storeOnly = false;<EOL>        args.push(`<STR_LIT>`);<EOL>        isLevelSet = true;<EOL>    }<EOL>    if (format === \"<STR_LIT>\" && options.compression === \"<STR_LIT>\") {<EOL>        <EOL>        args.push(\"<STR_LIT>\", \"<STR_LIT>\");<EOL>    }<EOL>    if (!isLevelSet && !storeOnly) {<EOL>        args.push(\"<STR_LIT>\");<EOL>    }<EOL>    if (options.dictSize != null) {<EOL>        args.push(`<STR_LIT>`);<EOL>    }<EOL>    <EOL>    <EOL>    <EOL>    <EOL>    if (!options.isRegularFile) {<EOL>        args.push(\"<STR_LIT>\");<EOL>    }<EOL>    if (format === \"<STR_LIT>\" || format.endsWith(\"<STR_LIT>\")) {<EOL>        if (options.solid === false) {<EOL>","gt":"args.push(\"<STR_LIT>\");"}
{"input":"<s> export function compute7zCompressArgs(format: string, options: ArchiveOptions = {}) {<EOL>    let storeOnly = options.compression === \"<STR_LIT>\";<EOL>    const args = debug7zArgs(\"<STR_LIT>\");<EOL>    let isLevelSet = false;<EOL>    if (process.env.ELECTRON_BUILDER_COMPRESSION_LEVEL != null) {<EOL>        storeOnly = false;<EOL>        args.push(`<STR_LIT>`);<EOL>        isLevelSet = true;<EOL>    }<EOL>    if (format === \"<STR_LIT>\" && options.compression === \"<STR_LIT>\") {<EOL>        <EOL>        args.push(\"<STR_LIT>\", \"<STR_LIT>\");<EOL>    }<EOL>    if (!isLevelSet && !storeOnly) {<EOL>        args.push(\"<STR_LIT>\");<EOL>    }<EOL>    if (options.dictSize != null) {<EOL>        args.push(`<STR_LIT>`);<EOL>    }<EOL>    <EOL>    <EOL>    <EOL>    <EOL>    if (!options.isRegularFile) {<EOL>        args.push(\"<STR_LIT>\");<EOL>    }<EOL>    if (format === \"<STR_LIT>\" || format.endsWith(\"<STR_LIT>\")) {<EOL>        if (options.solid === false) {<EOL>            args.push(\"<STR_LIT>\");<EOL>        }<EOL>        if (options.isArchiveHeaderCompressed === false) {<EOL>            args.push(\"<STR_LIT>\");<EOL>        }<EOL>        <EOL>        <EOL>        args.push(\"<STR_LIT>\", \"<STR_LIT>\");<EOL>    }<EOL>    if (options.method != null) {<EOL>        if (options.method !== \"<STR_LIT>\") {<EOL>            args.","gt":"push(`<STR_LIT>`);"}
{"input":"<s> export function compute7zCompressArgs(format: string, options: ArchiveOptions = {}) {<EOL>    let storeOnly = options.compression === \"<STR_LIT>\";<EOL>    const args = debug7zArgs(\"<STR_LIT>\");<EOL>    let isLevelSet = false;<EOL>    if (process.env.ELECTRON_BUILDER_COMPRESSION_LEVEL != null) {<EOL>        storeOnly = false;<EOL>        args.push(`<STR_LIT>`);<EOL>        isLevelSet = true;<EOL>    }<EOL>    if (format === \"<STR_LIT>\" && options.compression === \"<STR_LIT>\") {<EOL>        <EOL>        args.push(\"<STR_LIT>\", \"<STR_LIT>\");<EOL>    }<EOL>    if (!isLevelSet && !storeOnly) {<EOL>        args.push(\"<STR_LIT>\");<EOL>    }<EOL>    if (options.dictSize != null) {<EOL>        args.push(`<STR_LIT>`);<EOL>    }<EOL>    <EOL>    <EOL>    <EOL>    <EOL>    if (!options.isRegularFile) {<EOL>        args.push(\"<STR_LIT>\");<EOL>    }<EOL>    if (format === \"<STR_LIT>\" || format.endsWith(\"<STR_LIT>\")) {<EOL>        if (options.solid === false) {<EOL>            args.push(\"<STR_LIT>\");<EOL>        }<EOL>        if (options.isArchiveHeaderCompressed === false) {<EOL>            args.push(\"<STR_LIT>\");<EOL>        }<EOL>        <EOL>        <EOL>        args.push(\"<STR_LIT>\", \"<STR_LIT>\");<EOL>    }<EOL>    if (options.method != null) {<EOL>        if (options.method !== \"<STR_LIT>\") {<EOL>            args.push(`<STR_LIT>`);<EOL>        }<EOL>    }<EOL>    else if (format === \"<STR_LIT>\" || storeOnly) {<EOL>        args.push(","gt":"\"<STR_LIT>\"}`<STR_LIT>;"}
{"input":"<s> export function compute7zCompressArgs(format: string, options: ArchiveOptions = {}) {<EOL>    let storeOnly = options.compression === \"<STR_LIT>\";<EOL>    const args = debug7zArgs(\"<STR_LIT>\");<EOL>    let isLevelSet = false;<EOL>    if (process.env.ELECTRON_BUILDER_COMPRESSION_LEVEL != null) {<EOL>        storeOnly = false;<EOL>        args.push(`<STR_LIT>`);<EOL>        isLevelSet = true;<EOL>    }<EOL>    if (format === \"<STR_LIT>\" && options.compression === \"<STR_LIT>\") {<EOL>        <EOL>        args.push(\"<STR_LIT>\", \"<STR_LIT>\");<EOL>    }<EOL>    if (!isLevelSet && !storeOnly) {<EOL>        args.push(\"<STR_LIT>\");<EOL>    }<EOL>    if (options.dictSize != null) {<EOL>        args.push(`<STR_LIT>`);<EOL>    }<EOL>    <EOL>    <EOL>    <EOL>    <EOL>    if (!options.isRegularFile) {<EOL>        args.push(\"<STR_LIT>\");<EOL>    }<EOL>    if (format === \"<STR_LIT>\" || format.endsWith(\"<STR_LIT>\")) {<EOL>        if (options.solid === false) {<EOL>            args.push(\"<STR_LIT>\");<EOL>        }<EOL>        if (options.isArchiveHeaderCompressed === false) {<EOL>            args.push(\"<STR_LIT>\");<EOL>        }<EOL>        <EOL>        <EOL>        args.push(\"<STR_LIT>\", \"<STR_LIT>\");<EOL>    }<EOL>    if (options.method != null) {<EOL>        if (options.method !== \"<STR_LIT>\") {<EOL>            args.push(`<STR_LIT>`);<EOL>        }<EOL>    }<EOL>    else if (format === \"<STR_LIT>\" || storeOnly) {<EOL>        args.push(`<STR_LIT>`);<EOL>    }<EOL>    if (format ===","gt":"\"<STR_LIT>\") {"}
{"input":"<s> function getCommonSliceViewerState(viewer: ViewerUIState) {<EOL>    return {<EOL>        ...getCommonViewerState(","gt":"viewer),"}
{"input":"<s> <EOL>function insertWellKnownFilePathIntoAuth(auth: GoogleAuth, filePath: string, mockFilePath: string) {<EOL>    const originalMockWellKnownFilePathFunction = auth._mockWellKnownFilePath;<EOL>    auth._mockWellKnownFilePath = (kfpath: string) => {<EOL>        if (","gt":"kfpath === filePath) {"}
{"input":"<s> async function checkWindowsResult(packager: Packager, checkOptions: AssertPackOptions, artifacts: Array<ArtifactCreated>, nameToTarget: Map<string, Target>) {<EOL>    const appInfo = packager.appInfo;<EOL>    let squirrel = false;<EOL>    for (const target of nameToTarget.keys()) {<EOL>        if (target === \"<STR_LIT>\") {<EOL>            squirrel =","gt":"true;"}
{"input":"<s> async function checkWindowsResult(packager: Packager, checkOptions: AssertPackOptions, artifacts: Array<ArtifactCreated>, nameToTarget: Map<string, Target>) {<EOL>    const appInfo = packager.appInfo;<EOL>    let squirrel = false;<EOL>    for (const target of nameToTarget.keys()) {<EOL>        if (target === \"<STR_LIT>\") {<EOL>            squirrel = true;<EOL>            break;<EOL>        }<EOL>    }<EOL>    if (!squirrel) {<EOL>        return;<EOL>    }<EOL>    const packageFile = artifacts.find(it => it.file!!.endsWith(\"<STR_LIT>\"))!.file!!;<EOL>    const unZipper = new DecompressZip(packageFile!!);<EOL>    const","gt":"fileDescriptors = await unZipper.getFiles();"}
{"input":"<s> async function checkWindowsResult(packager: Packager, checkOptions: AssertPackOptions, artifacts: Array<ArtifactCreated>, nameToTarget: Map<string, Target>) {<EOL>    const appInfo = packager.appInfo;<EOL>    let squirrel = false;<EOL>    for (const target of nameToTarget.keys()) {<EOL>        if (target === \"<STR_LIT>\") {<EOL>            squirrel = true;<EOL>            break;<EOL>        }<EOL>    }<EOL>    if (!squirrel) {<EOL>        return;<EOL>    }<EOL>    const packageFile = artifacts.find(it => it.file!!.endsWith(\"<STR_LIT>\"))!.file!!;<EOL>    const unZipper = new DecompressZip(packageFile!!);<EOL>    const fileDescriptors = await unZipper.getFiles();<EOL>    <EOL>    const files = pathSorter(fileDescriptors.map(it => it.path.replace(/\\\\/g, \"<STR_LIT>\")).filter(it => (!it.startsWith(\"<STR_LIT>\") || it === \"<STR_LIT>\") && !it.endsWith(\"<STR_LIT>\") && !it.endsWith(\"<STR_LIT>\")));<EOL>    expect(files).toMatchSnapshot();<EOL>    if (checkOptions == null) {<EOL>        await unZipper.extractFile(","gt":"fileDescriptors.filter(it => it.path === \"<STR_LIT>\")[<NUM_LIT>], {"}
{"input":"<s> function getType(target: any): string {<EOL>    let what = typeof target;<EOL>    if (","gt":"what === '<STR_LIT>') {"}
{"input":"<s> <EOL><EOL><EOL>function isLexicalScope(node: ts.Node): boolean {<EOL>    switch (node.kind) {<EOL>        case ts.SyntaxKind.ArrowFunction:<EOL>        case ts.SyntaxKind.FunctionExpression:<EOL>        case ts.SyntaxKind.","gt":"FunctionDeclaration:"}
{"input":"<s> <EOL><EOL><EOL>function isLexicalScope(node: ts.Node): boolean {<EOL>    switch (node.kind) {<EOL>        case ts.SyntaxKind.ArrowFunction:<EOL>        case ts.SyntaxKind.FunctionExpression:<EOL>        case ts.SyntaxKind.FunctionDeclaration:<EOL>        case ts.SyntaxKind.ClassExpression:<EOL>        case ts.SyntaxKind.ClassDeclaration:<EOL>        case ts.SyntaxKind.FunctionType:<EOL>        case ts.SyntaxKind.TypeLiteral:<EOL>        case ts.SyntaxKind.ArrayType:<EOL>            return","gt":"true;"}
{"input":"<s> export function createBundleIndexHost<H extends ts.CompilerHost>(ngOptions: CompilerOptions, rootFiles: ReadonlyArray<string>, host: H): {<EOL>    host: H;<EOL>    indexName?: string;<EOL>    errors?: ts.Diagnostic[];<EOL>} {<EOL>    const files = rootFiles.filter(f => !DTS.test(f));<EOL>    if (files.length != <NUM_LIT>) {<EOL>        return {<EOL>            host,<EOL>","gt":"errors: [{"}
{"input":"<s> export function createBundleIndexHost<H extends ts.CompilerHost>(ngOptions: CompilerOptions, rootFiles: ReadonlyArray<string>, host: H): {<EOL>    host: H;<EOL>    indexName?: string;<EOL>    errors?: ts.Diagnostic[];<EOL>} {<EOL>    const files = rootFiles.filter(f => !DTS.test(f));<EOL>    if (files.length != <NUM_LIT>) {<EOL>        return {<EOL>            host,<EOL>            errors: [{<EOL>                    file: null as any as ts.SourceFile,<EOL>                    start: null as any as number,<EOL>                    length:","gt":"null as any as number,"}
{"input":"<s> export function createBundleIndexHost<H extends ts.CompilerHost>(ngOptions: CompilerOptions, rootFiles: ReadonlyArray<string>, host: H): {<EOL>    host: H;<EOL>    indexName?: string;<EOL>    errors?: ts.Diagnostic[];<EOL>} {<EOL>    const files = rootFiles.filter(f => !DTS.test(f));<EOL>    if (files.length != <NUM_LIT>) {<EOL>        return {<EOL>            host,<EOL>            errors: [{<EOL>                    file: null as any as ts.SourceFile,<EOL>                    start: null as any as number,<EOL>                    length: null as any as number,<EOL>                    messageText: '<STR_LIT>',<EOL>                    category: ts.DiagnosticCategory.Error,<EOL>                    code: <NUM_LIT><EOL>                }]<EOL>        };<EOL>    }<EOL>    const file = files[<NUM_LIT>];<EOL>    const indexModule = file.replace(/\\.ts$/, '<STR_LIT>');<EOL>    const bundler = new MetadataBundler(indexModule, ngOptions.flatModuleId, new CompilerHostAdapter(host));<EOL>    const metadataBundle = bundler.getMetadataBundle();<EOL>    const metadata =","gt":"JSON.stringify(metadataBundle.metadata);"}
{"input":"<s> function baselineCopy(subfolder = \"<STR_LIT>\") {<EOL>    return gulp.src([`<STR_LIT>`,","gt":"subfolder}*.delete`<STR_LIT>)"}
{"input":"<s> <EOL>function entries(x: {<EOL>    [key: string]: any;<EOL>}): any {<EOL>    return Object.","gt":"keys(x).map(k => [k, x[k]]);"}
{"input":"<s> export function jwtdecode() {<EOL>    console.","gt":"log(decode);"}
{"input":"<s> export function isRootValid(ast: ImmutableSelectorList) {<EOL>    let isValid = true;<EOL>    walk(ast, (node, index, nodes) => {<EOL>        if (node.type === '<STR_LIT>') {<EOL>            return walk.skipNested;<EOL>        }<EOL>        if (node.type === '<STR_LIT>' && node.value === `<STR_LIT>`) {<EOL>            let isLastScopeGlobal = false;<EOL>            for (let","gt":"i = <NUM_LIT>; i < index; i++) {"}
{"input":"<s> export function isRootValid(ast: ImmutableSelectorList) {<EOL>    let isValid = true;<EOL>    walk(ast, (node, index, nodes) => {<EOL>        if (node.type === '<STR_LIT>') {<EOL>            return walk.skipNested;<EOL>        }<EOL>        if (node.type === '<STR_LIT>' && node.value === `<STR_LIT>`) {<EOL>            let isLastScopeGlobal = false;<EOL>            for (let i = <NUM_LIT>; i < index; i++) {<EOL>                const part = nodes[i];<EOL>                if (isGlobal(part)) {<EOL>                    isLastScopeGlobal = true;<EOL>                }<EOL>                if (","gt":"part.type === '<STR_LIT>' && !isLastScopeGlobal) {"}
{"input":"<s> function parseVertexAttributeInfo(x: any): VertexAttributeInfo {<EOL>    verifyObject(x);<EOL>","gt":"return {"}
{"input":"<s> function isCtorParamsWhitelistedService(exprStmt: ts.ExpressionStatement): boolean {<EOL>    const expr = exprStmt.expression as ts.BinaryExpression;<EOL>    const propAccess =","gt":"expr.left as ts.PropertyAccessExpression;"}
{"input":"<s> /**<EOL> * Custom function to insert a declaration (component, pipe, directive)<EOL> * into NgModule declarations. It also imports the component.<EOL> */<EOL>export function addDeclarationToModule(source: ts.SourceFile, modulePath: string, classifiedName: string, importPath: string): Change[] {<EOL>","gt":"return addSymbolToNgModuleMetadata(source, modulePath, '<STR_LIT>', classifiedName, importPath);"}
{"input":"<s> function handleCyclicValues(context: FeatureTransformContext, passedThrough: string[], refUniqID: string, node: postcss.Node | undefined, value: string, parsedNode: ParsedValue) {<EOL>    if (node) {<EOL>        const cyclicChain = passedThrough.map((variable) => variable || '<STR_LIT>');<EOL>        cyclicChain.","gt":"push(refUniqID);"}
{"input":"<s> export function getRuleScopeSelector(rule: postcss.Rule) {<EOL>","gt":"return ignoreDeprecationWarn(() => (rule as SRule).stScopeSelector);"}
{"input":"<s> export function getVolume(chunkManager: ChunkManager, path: string) {<EOL>    let match = path.match(urlPattern);<EOL>    if (","gt":"match === null) {"}
{"input":"<s> export function addGlobals(meta: StylableMeta, selectorAst: SelectorNode[]) {<EOL>    for (const ast of selectorAst) {<EOL>        walkSelector(ast, (inner) => {<EOL>            if (inner.","gt":"type === '<STR_LIT>') {"}
{"input":"<s> export function getTrackableFragmentMain(value = DEFAULT_FRAGMENT_MAIN) {<EOL>    return new TrackableValue<string>(","gt":"value, verifyString);"}
{"input":"<s> export function computeStackHierarchy(stackInfo: StackInfo, tileSize: number) {<EOL>    let maxBound = <NUM_LIT>;<EOL>    for (let i = <NUM_LIT>; i < <NUM_LIT>; i++) {<EOL>        maxBound < stackInfo.upperVoxelBound[i] ? maxBound = stackInfo.upperVoxelBound[i] :<EOL>            maxBound = maxBound;<EOL>    }<EOL>    if (tileSize >= maxBound) {<EOL>        return <NUM_LIT>;<EOL>    }<EOL>    let counter = <NUM_LIT>;<EOL>    while (maxBound > tileSize) {<EOL>","gt":"maxBound = maxBound / <NUM_LIT>;"}
{"input":"<s> /**<EOL> * Imports File<EOL> * With opt provided it's possible to set:<EOL> *   1) Base directory<EOL> *   2) Target package name<EOL> */<EOL>function $import(name: string, o: any = {}) {<EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    if (name.charCodeAt(<NUM_LIT>) === <NUM_LIT> || name.","gt":"charCodeAt(<NUM_LIT>) === <NUM_LIT>) {"}
{"input":"<s> /**<EOL> * Imports File<EOL> * With opt provided it's possible to set:<EOL> *   1) Base directory<EOL> *   2) Target package name<EOL> */<EOL>function $import(name: string, o: any = {}) {<EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    if (name.charCodeAt(<NUM_LIT>) === <NUM_LIT> || name.charCodeAt(<NUM_LIT>) === <NUM_LIT>) {<EOL>        return $loadURL(name);<EOL>    }<EOL>    let ref = $getRef(name, o);<EOL>    if (ref.server) {<EOL>        return ref.","gt":"server;"}
{"input":"<s> /**<EOL> * Imports File<EOL> * With opt provided it's possible to set:<EOL> *   1) Base directory<EOL> *   2) Target package name<EOL> */<EOL>function $import(name: string, o: any = {}) {<EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    if (name.charCodeAt(<NUM_LIT>) === <NUM_LIT> || name.charCodeAt(<NUM_LIT>) === <NUM_LIT>) {<EOL>        return $loadURL(name);<EOL>    }<EOL>    let ref = $getRef(name, o);<EOL>    if (ref.server) {<EOL>        return ref.server;<EOL>    }<EOL>    let file = ref.file;<EOL>    <EOL>    if (ref.wildcard) {<EOL>        <EOL>        let safeRegEx: RegExp = new RegExp(ref.wildcard<EOL>            .replace(/\\*/g, \"<STR_LIT>\")<EOL>            .replace(/[.?*+^$[\\]\\\\(){}|-]/g, \"<STR_LIT>\")<EOL>            .","gt":"replace(/@@/g, \"<STR_LIT>\")"}
{"input":"<s> /**<EOL> * Imports File<EOL> * With opt provided it's possible to set:<EOL> *   1) Base directory<EOL> *   2) Target package name<EOL> */<EOL>function $import(name: string, o: any = {}) {<EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    if (name.charCodeAt(<NUM_LIT>) === <NUM_LIT> || name.charCodeAt(<NUM_LIT>) === <NUM_LIT>) {<EOL>        return $loadURL(name);<EOL>    }<EOL>    let ref = $getRef(name, o);<EOL>    if (ref.server) {<EOL>        return ref.server;<EOL>    }<EOL>    let file = ref.file;<EOL>    <EOL>    if (ref.wildcard) {<EOL>        <EOL>        let safeRegEx: RegExp = new RegExp(ref.wildcard<EOL>            .replace(/\\*/g, \"<STR_LIT>\")<EOL>            .replace(/[.?*+^$[\\]\\\\(){}|-]/g, \"<STR_LIT>\")<EOL>            .replace(/@@/g, \"<STR_LIT>\")<EOL>            .replace(/@/g, \"<STR_LIT>\"), \"<STR_LIT>\");<EOL>        let pkg = $packages[ref.pkgName];<EOL>        if (pkg) {<EOL>            let batch = {};<EOL>            for (let n in pkg.f) {<EOL>                if (safeRegEx.test(n)) {<EOL>                    batch[n] = $import(`<STR_LIT>`);<EOL>                }<EOL>            }<EOL>            return batch;<EOL>        }<EOL>    }<EOL>    if (!file) {<EOL>        let asyncMode = typeof o === \"<STR_LIT>\";<EOL>        let processStopped = $trigger(\"<STR_LIT>\", [name, o]);<EOL>        if (processStopped === false) {<EOL>            return;<EOL>        }<EOL>        return $async(name, (result) => asyncMode ? o(result) : null, o);<EOL>        <EOL>    }<EOL>    <EOL>    let pkg = ref.pkgName;<EOL>    if (file.locals && file.locals.module)<EOL>","gt":"return file.locals.module.exports;"}
{"input":"<s> /**<EOL> * Imports File<EOL> * With opt provided it's possible to set:<EOL> *   1) Base directory<EOL> *   2) Target package name<EOL> */<EOL>function $import(name: string, o: any = {}) {<EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    if (name.charCodeAt(<NUM_LIT>) === <NUM_LIT> || name.charCodeAt(<NUM_LIT>) === <NUM_LIT>) {<EOL>        return $loadURL(name);<EOL>    }<EOL>    let ref = $getRef(name, o);<EOL>    if (ref.server) {<EOL>        return ref.server;<EOL>    }<EOL>    let file = ref.file;<EOL>    <EOL>    if (ref.wildcard) {<EOL>        <EOL>        let safeRegEx: RegExp = new RegExp(ref.wildcard<EOL>            .replace(/\\*/g, \"<STR_LIT>\")<EOL>            .replace(/[.?*+^$[\\]\\\\(){}|-]/g, \"<STR_LIT>\")<EOL>            .replace(/@@/g, \"<STR_LIT>\")<EOL>            .replace(/@/g, \"<STR_LIT>\"), \"<STR_LIT>\");<EOL>        let pkg = $packages[ref.pkgName];<EOL>        if (pkg) {<EOL>            let batch = {};<EOL>            for (let n in pkg.f) {<EOL>                if (safeRegEx.test(n)) {<EOL>                    batch[n] = $import(`<STR_LIT>`);<EOL>                }<EOL>            }<EOL>            return batch;<EOL>        }<EOL>    }<EOL>    if (!file) {<EOL>        let asyncMode = typeof o === \"<STR_LIT>\";<EOL>        let processStopped = $trigger(\"<STR_LIT>\", [name, o]);<EOL>        if (processStopped === false) {<EOL>            return;<EOL>        }<EOL>        return $async(name, (result) => asyncMode ? o(result) : null, o);<EOL>        <EOL>    }<EOL>    <EOL>    let pkg = ref.pkgName;<EOL>    if (file.locals && file.locals.module)<EOL>        return file.locals.module.exports;<EOL>    let locals: any = file.locals = {};<EOL>    <EOL>    const path = $getDir(ref.validPath);<EOL>    locals.exports = {};<EOL>    locals.module = { exports: locals.exports };<EOL>    locals.require = (name: string, optionalCallback: any) => {<EOL>        const result = $import(name, {<EOL>","gt":"pkg,"}
{"input":"<s> /**<EOL> * Imports File<EOL> * With opt provided it's possible to set:<EOL> *   1) Base directory<EOL> *   2) Target package name<EOL> */<EOL>function $import(name: string, o: any = {}) {<EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    if (name.charCodeAt(<NUM_LIT>) === <NUM_LIT> || name.charCodeAt(<NUM_LIT>) === <NUM_LIT>) {<EOL>        return $loadURL(name);<EOL>    }<EOL>    let ref = $getRef(name, o);<EOL>    if (ref.server) {<EOL>        return ref.server;<EOL>    }<EOL>    let file = ref.file;<EOL>    <EOL>    if (ref.wildcard) {<EOL>        <EOL>        let safeRegEx: RegExp = new RegExp(ref.wildcard<EOL>            .replace(/\\*/g, \"<STR_LIT>\")<EOL>            .replace(/[.?*+^$[\\]\\\\(){}|-]/g, \"<STR_LIT>\")<EOL>            .replace(/@@/g, \"<STR_LIT>\")<EOL>            .replace(/@/g, \"<STR_LIT>\"), \"<STR_LIT>\");<EOL>        let pkg = $packages[ref.pkgName];<EOL>        if (pkg) {<EOL>            let batch = {};<EOL>            for (let n in pkg.f) {<EOL>                if (safeRegEx.test(n)) {<EOL>                    batch[n] = $import(`<STR_LIT>`);<EOL>                }<EOL>            }<EOL>            return batch;<EOL>        }<EOL>    }<EOL>    if (!file) {<EOL>        let asyncMode = typeof o === \"<STR_LIT>\";<EOL>        let processStopped = $trigger(\"<STR_LIT>\", [name, o]);<EOL>        if (processStopped === false) {<EOL>            return;<EOL>        }<EOL>        return $async(name, (result) => asyncMode ? o(result) : null, o);<EOL>        <EOL>    }<EOL>    <EOL>    let pkg = ref.pkgName;<EOL>    if (file.locals && file.locals.module)<EOL>        return file.locals.module.exports;<EOL>    let locals: any = file.locals = {};<EOL>    <EOL>    const path = $getDir(ref.validPath);<EOL>    locals.exports = {};<EOL>    locals.module = { exports: locals.exports };<EOL>    locals.require = (name: string, optionalCallback: any) => {<EOL>        const result = $import(name, {<EOL>            pkg,<EOL>            path,<EOL>            v: ref.versions,<EOL>        });<EOL>        if (FuseBox[\"<STR_LIT>\"]) {<EOL>            syntheticDefaultExportPolyfill(result);<EOL>        }<EOL>        return","gt":"result;"}
{"input":"<s> /**<EOL> * Imports File<EOL> * With opt provided it's possible to set:<EOL> *   1) Base directory<EOL> *   2) Target package name<EOL> */<EOL>function $import(name: string, o: any = {}) {<EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    if (name.charCodeAt(<NUM_LIT>) === <NUM_LIT> || name.charCodeAt(<NUM_LIT>) === <NUM_LIT>) {<EOL>        return $loadURL(name);<EOL>    }<EOL>    let ref = $getRef(name, o);<EOL>    if (ref.server) {<EOL>        return ref.server;<EOL>    }<EOL>    let file = ref.file;<EOL>    <EOL>    if (ref.wildcard) {<EOL>        <EOL>        let safeRegEx: RegExp = new RegExp(ref.wildcard<EOL>            .replace(/\\*/g, \"<STR_LIT>\")<EOL>            .replace(/[.?*+^$[\\]\\\\(){}|-]/g, \"<STR_LIT>\")<EOL>            .replace(/@@/g, \"<STR_LIT>\")<EOL>            .replace(/@/g, \"<STR_LIT>\"), \"<STR_LIT>\");<EOL>        let pkg = $packages[ref.pkgName];<EOL>        if (pkg) {<EOL>            let batch = {};<EOL>            for (let n in pkg.f) {<EOL>                if (safeRegEx.test(n)) {<EOL>                    batch[n] = $import(`<STR_LIT>`);<EOL>                }<EOL>            }<EOL>            return batch;<EOL>        }<EOL>    }<EOL>    if (!file) {<EOL>        let asyncMode = typeof o === \"<STR_LIT>\";<EOL>        let processStopped = $trigger(\"<STR_LIT>\", [name, o]);<EOL>        if (processStopped === false) {<EOL>            return;<EOL>        }<EOL>        return $async(name, (result) => asyncMode ? o(result) : null, o);<EOL>        <EOL>    }<EOL>    <EOL>    let pkg = ref.pkgName;<EOL>    if (file.locals && file.locals.module)<EOL>        return file.locals.module.exports;<EOL>    let locals: any = file.locals = {};<EOL>    <EOL>    const path = $getDir(ref.validPath);<EOL>    locals.exports = {};<EOL>    locals.module = { exports: locals.exports };<EOL>    locals.require = (name: string, optionalCallback: any) => {<EOL>        const result = $import(name, {<EOL>            pkg,<EOL>            path,<EOL>            v: ref.versions,<EOL>        });<EOL>        if (FuseBox[\"<STR_LIT>\"]) {<EOL>            syntheticDefaultExportPolyfill(result);<EOL>        }<EOL>        return result;<EOL>    };<EOL>    if ($isBrowser || !g[\"<STR_LIT>\"].main) {<EOL>        locals.require.main = { filename: \"<STR_LIT>\",","gt":"paths: [] };"}
{"input":"<s> /**<EOL> * Imports File<EOL> * With opt provided it's possible to set:<EOL> *   1) Base directory<EOL> *   2) Target package name<EOL> */<EOL>function $import(name: string, o: any = {}) {<EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    if (name.charCodeAt(<NUM_LIT>) === <NUM_LIT> || name.charCodeAt(<NUM_LIT>) === <NUM_LIT>) {<EOL>        return $loadURL(name);<EOL>    }<EOL>    let ref = $getRef(name, o);<EOL>    if (ref.server) {<EOL>        return ref.server;<EOL>    }<EOL>    let file = ref.file;<EOL>    <EOL>    if (ref.wildcard) {<EOL>        <EOL>        let safeRegEx: RegExp = new RegExp(ref.wildcard<EOL>            .replace(/\\*/g, \"<STR_LIT>\")<EOL>            .replace(/[.?*+^$[\\]\\\\(){}|-]/g, \"<STR_LIT>\")<EOL>            .replace(/@@/g, \"<STR_LIT>\")<EOL>            .replace(/@/g, \"<STR_LIT>\"), \"<STR_LIT>\");<EOL>        let pkg = $packages[ref.pkgName];<EOL>        if (pkg) {<EOL>            let batch = {};<EOL>            for (let n in pkg.f) {<EOL>                if (safeRegEx.test(n)) {<EOL>                    batch[n] = $import(`<STR_LIT>`);<EOL>                }<EOL>            }<EOL>            return batch;<EOL>        }<EOL>    }<EOL>    if (!file) {<EOL>        let asyncMode = typeof o === \"<STR_LIT>\";<EOL>        let processStopped = $trigger(\"<STR_LIT>\", [name, o]);<EOL>        if (processStopped === false) {<EOL>            return;<EOL>        }<EOL>        return $async(name, (result) => asyncMode ? o(result) : null, o);<EOL>        <EOL>    }<EOL>    <EOL>    let pkg = ref.pkgName;<EOL>    if (file.locals && file.locals.module)<EOL>        return file.locals.module.exports;<EOL>    let locals: any = file.locals = {};<EOL>    <EOL>    const path = $getDir(ref.validPath);<EOL>    locals.exports = {};<EOL>    locals.module = { exports: locals.exports };<EOL>    locals.require = (name: string, optionalCallback: any) => {<EOL>        const result = $import(name, {<EOL>            pkg,<EOL>            path,<EOL>            v: ref.versions,<EOL>        });<EOL>        if (FuseBox[\"<STR_LIT>\"]) {<EOL>            syntheticDefaultExportPolyfill(result);<EOL>        }<EOL>        return result;<EOL>    };<EOL>    if ($isBrowser || !g[\"<STR_LIT>\"].main) {<EOL>        locals.require.main = { filename: \"<STR_LIT>\", paths: [] };<EOL>    }<EOL>","gt":"else {"}
{"input":"<s> export async function installOrRebuild(config: Configuration, appDir: string, options: RebuildOptions, forceInstall: boolean = false) {<EOL>    const effectiveOptions = {<EOL>        buildFromSource: config.buildDependenciesFromSource === true,<EOL>        additionalArgs: asArray(config.npmArgs), ...options<EOL>    };<EOL>    if (forceInstall || !(await exists(path.join(appDir, \"<STR_LIT>\")))) {<EOL>        await installDependencies(appDir, effectiveOptions);<EOL>    }<EOL>","gt":"else {"}
{"input":"<s> function getPackageToolPath() {<EOL>    if (process.env.FORCE_YARN === \"<STR_LIT>\") {<EOL>","gt":"return process.platform === \"<STR_LIT>\" ? \"<STR_LIT>\" : \"<STR_LIT>\";"}
{"input":"<s> export function matchesIfStatementProcessEnv(node): string {<EOL>    if (node.type && node.type === \"<STR_LIT>\") {<EOL>        <EOL>        if (node.$parent && node.$parent.type === \"<STR_LIT>\") {<EOL>","gt":"return;"}
{"input":"<s> function createVariableStatementForDeclarations(declarations: Declaration[]): ts.VariableStatement {<EOL>    const","gt":"varDecls = declarations.map(i => ts.createVariableDeclaration(i.name,  undefined, i.node as ts.Expression));"}
{"input":"<s> function onInputEntered(responseText: string): IShowInputPromptResponseBody {<EOL>    if (responseText !== undefined) {<EOL>        return {<EOL>            promptCancelled: false,<EOL>","gt":"responseText,"}
{"input":"<s> function onInputEntered(responseText: string): IShowInputPromptResponseBody {<EOL>    if (responseText !== undefined) {<EOL>        return {<EOL>            promptCancelled: false,<EOL>            responseText,<EOL>        };<EOL>    }<EOL>    else {<EOL>        return {<EOL>            promptCancelled: true,<EOL>","gt":"responseText: undefined,"}
{"input":"<s> export function getWebpackStatsConfig(verbose = false) {<EOL>    return","gt":"verbose"}
{"input":"<s> <EOL><EOL>function expectMap(ctx: EmitterVisitorContext, genLine: number, genCol: number, source: string | null = null, srcLine: number | null = null, srcCol: number | null = null) {<EOL>    const sm = ctx.toSourceMapGenerator('<STR_LIT>').toJSON()!;<EOL>    const genPosition = { line: genLine + <NUM_LIT>,","gt":"column: genCol };"}
{"input":"<s> function comparePaths(a: string, b: string, currentDirectory: string, ignoreCase?: boolean) {<EOL>    if (a === b)<EOL>        return Comparison.EqualTo;<EOL>    if (a === undefined)<EOL>        return Comparison.LessThan;<EOL>    if (b === undefined)<EOL>        return Comparison.","gt":"GreaterThan;"}
{"input":"<s> function comparePaths(a: string, b: string, currentDirectory: string, ignoreCase?: boolean) {<EOL>    if (a === b)<EOL>        return Comparison.EqualTo;<EOL>    if (a === undefined)<EOL>        return Comparison.LessThan;<EOL>    if (b === undefined)<EOL>        return Comparison.GreaterThan;<EOL>    a = removeTrailingDirectorySeparator(a);<EOL>    b = removeTrailingDirectorySeparator(b);<EOL>    const aComponents = getNormalizedPathComponents(a, currentDirectory);<EOL>    const bComponents = getNormalizedPathComponents(b,","gt":"currentDirectory);"}
{"input":"<s> function comparePaths(a: string, b: string, currentDirectory: string, ignoreCase?: boolean) {<EOL>    if (a === b)<EOL>        return Comparison.EqualTo;<EOL>    if (a === undefined)<EOL>        return Comparison.LessThan;<EOL>    if (b === undefined)<EOL>        return Comparison.GreaterThan;<EOL>    a = removeTrailingDirectorySeparator(a);<EOL>    b = removeTrailingDirectorySeparator(b);<EOL>    const aComponents = getNormalizedPathComponents(a, currentDirectory);<EOL>    const bComponents = getNormalizedPathComponents(b, currentDirectory);<EOL>    const sharedLength = Math.min(aComponents.length, bComponents.length);<EOL>    for (let i = <NUM_LIT>; i < sharedLength; i++) {<EOL>        const result = compareStrings(aComponents[i], bComponents[i], ignoreCase);<EOL>        if (","gt":"result !== Comparison.EqualTo) {"}
{"input":"<s> export function getAppModulePath(host: Tree, app: AppConfig) {<EOL>    const mainPath = normalize(`<STR_LIT>`);<EOL>","gt":"const moduleRelativePath = findBootstrapModulePath(host, mainPath);"}
{"input":"<s> export function registerSingleMeshVertexAttributesFactory(name: string, factory: SingleMeshVertexAttributesFactory) {<EOL>    singleMeshVertexAttributesFactories.set(name,","gt":"factory);"}
{"input":"<s> /**<EOL> * Helper function that is exported for unit tests only.<EOL> * Returns undefined if the process doesn't exist with that pid.<EOL> */<EOL>export function getProcessStartTime(pid: number): string | undefined {<EOL>    let args: string[];<EOL>    if (process.platform === '<STR_LIT>') {<EOL>        args = [`<STR_LIT>`, '<STR_LIT>'];<EOL>    }<EOL>    else if (","gt":"process.platform === '<STR_LIT>') {"}
{"input":"<s> /**<EOL> * Helper function that is exported for unit tests only.<EOL> * Returns undefined if the process doesn't exist with that pid.<EOL> */<EOL>export function getProcessStartTime(pid: number): string | undefined {<EOL>    let args: string[];<EOL>    if (process.platform === '<STR_LIT>') {<EOL>        args = [`<STR_LIT>`, '<STR_LIT>'];<EOL>    }<EOL>    else if (process.platform === '<STR_LIT>') {<EOL>        args = ['<STR_LIT>', pid.toString(), '<STR_LIT>', '<STR_LIT>'];<EOL>    }<EOL>    else {<EOL>        throw","gt":"new Error(`<STR_LIT>`);"}
{"input":"<s> /**<EOL> * Helper function that is exported for unit tests only.<EOL> * Returns undefined if the process doesn't exist with that pid.<EOL> */<EOL>export function getProcessStartTime(pid: number): string | undefined {<EOL>    let args: string[];<EOL>    if (process.platform === '<STR_LIT>') {<EOL>        args = [`<STR_LIT>`, '<STR_LIT>'];<EOL>    }<EOL>    else if (process.platform === '<STR_LIT>') {<EOL>        args = ['<STR_LIT>', pid.toString(), '<STR_LIT>', '<STR_LIT>'];<EOL>    }<EOL>    else {<EOL>        throw new Error(`<STR_LIT>`);<EOL>    }<EOL>    const psResult: string = child_process.spawnSync('<STR_LIT>', args).stdout.toString();<EOL>    <EOL>    if (!psResult) {<EOL>        throw new Error(`<STR_LIT>`);<EOL>    }<EOL>    const psSplit: string[] = psResult.split('<STR_LIT>');<EOL>    <EOL>    if (psSplit[<NUM_LIT>] === '<STR_LIT>') {<EOL>        return undefined;<EOL>    }<EOL>    if (","gt":"psSplit[<NUM_LIT>]) {"}
{"input":"<s> export function _localeFactory(locale?: string): string {<EOL>    return locale ||","gt":"'<STR_LIT>';"}
{"input":"<s> /**<EOL> * All valid chunks are in the range [lowerBound, upperBound).<EOL> *<EOL> * @param lowerBound Output parameter for lowerBound.<EOL> * @param upperBound Output parameter for upperBound.<EOL> * @param sources Sources for which to compute the chunk bounds.<EOL> */<EOL>function computeSourcesChunkBounds(sourcesLowerBound: vec3, sourcesUpperBound: vec3, sources: Iterable<SliceViewChunkSource>) {<EOL>    for (let i = <NUM_LIT>; i < <NUM_LIT>; ++i) {<EOL>        sourcesLowerBound[i] = Number.POSITIVE_INFINITY;<EOL>        sourcesUpperBound[i] = Number.NEGATIVE_INFINITY;<EOL>    }<EOL>    for (let source of sources) {<EOL>        let { spec } = source;<EOL>        let { lowerChunkBound, upperChunkBound } = spec;<EOL>        for (let i = <NUM_LIT>; i < <NUM_LIT>; ++i) {<EOL>            sourcesLowerBound[i] = Math.min(sourcesLowerBound[i], lowerChunkBound[i]);<EOL>            sourcesUpperBound[i] = Math.max(","gt":"sourcesUpperBound[i], upperChunkBound[i]);"}
{"input":"<s> function getWebglDataType(dataType: DataType) {<EOL>    switch (dataType) {<EOL>","gt":"case DataType.FLOAT32:"}
{"input":"<s> export function decodeSwcSkeletonChunk(chunk: SkeletonChunk, swcStr: string) {<EOL>    let swcObjects: Array<PointObj> = parseSwc(swcStr);<EOL>    if (swcObjects.length < <NUM_LIT>) {<EOL>        throw new Error(`<STR_LIT>`);<EOL>    }<EOL>    let glVertices = new Float32Array(<NUM_LIT> * (swcObjects.length));<EOL>    let glIndices =","gt":"new Uint32Array(<NUM_LIT> * (swcObjects.length - <NUM_LIT>));"}
{"input":"<s> export function decodeSwcSkeletonChunk(chunk: SkeletonChunk, swcStr: string) {<EOL>    let swcObjects: Array<PointObj> = parseSwc(swcStr);<EOL>    if (swcObjects.length < <NUM_LIT>) {<EOL>        throw new Error(`<STR_LIT>`);<EOL>    }<EOL>    let glVertices = new Float32Array(<NUM_LIT> * (swcObjects.length));<EOL>    let glIndices = new Uint32Array(<NUM_LIT> * (swcObjects.length - <NUM_LIT>));<EOL>    swcObjects.forEach(function (swc_obj, i) {<EOL>        glVertices[<NUM_LIT> * i] = swc_obj.z;<EOL>        glVertices[<NUM_LIT> * i + <NUM_LIT>] = swc_obj.y;<EOL>        glVertices[<NUM_LIT> * i +","gt":"<NUM_LIT>] = swc_obj.x;"}
{"input":"<s> export function decodeSwcSkeletonChunk(chunk: SkeletonChunk, swcStr: string) {<EOL>    let swcObjects: Array<PointObj> = parseSwc(swcStr);<EOL>    if (swcObjects.length < <NUM_LIT>) {<EOL>        throw new Error(`<STR_LIT>`);<EOL>    }<EOL>    let glVertices = new Float32Array(<NUM_LIT> * (swcObjects.length));<EOL>    let glIndices = new Uint32Array(<NUM_LIT> * (swcObjects.length - <NUM_LIT>));<EOL>    swcObjects.forEach(function (swc_obj, i) {<EOL>        glVertices[<NUM_LIT> * i] = swc_obj.z;<EOL>        glVertices[<NUM_LIT> * i + <NUM_LIT>] = swc_obj.y;<EOL>        glVertices[<NUM_LIT> * i + <NUM_LIT>] = swc_obj.x;<EOL>        if (swc_obj.parent !== -<NUM_LIT>) {<EOL>            glIndices[<NUM_LIT> * (i - <NUM_LIT>)] = i;<EOL>            glIndices[<NUM_LIT> * i - <NUM_LIT>] =","gt":"swc_obj.parent;"}
{"input":"<s> export function getDefaultPerspectivePanelBindings() {<EOL>    if (defaultPerspectivePanelBindings === undefined) {<EOL>        defaultPerspectivePanelBindings = EventActionMap.fromObject({<EOL>            '<STR_LIT>': { action:","gt":"'<STR_LIT>', stopPropagation: true },"}
{"input":"<s> function set_scale(url, options) {<EOL>    if (options.y1 && options.y1.scale) {<EOL>        switch (options.y1.scale) {<EOL>","gt":"case AxisScale.LOG:"}
{"input":"<s> /**<EOL> * Add a new query to the dashboard and UI.<EOL> */<EOL>export function add_query(dashboard: Dashboard, name: string, target?): Query {<EOL>    log.debug('<STR_LIT>');<EOL>    let query = new Query({ name: name, targets: target });<EOL>","gt":"manager.without_updates(() => {"}
{"input":"<s> export function openSearchView(viewletService: IViewletService, panelService: IPanelService, focus?: boolean): TPromise<SearchView> {<EOL>    if (viewletService.getViewlets().filter(v => v.id === VIEW_ID).length) {<EOL>        return viewletService.openViewlet(","gt":"VIEW_ID, focus).then(viewlet => <SearchView>viewlet);"}
{"input":"<s> function extractStyle(styleList) {<EOL>    var rv = { scoped: '<STR_LIT>', global: '<STR_LIT>', some: false };<EOL>    if (styleList)<EOL>        for (let s in styleList) {<EOL>            let","gt":"style = styleList[s], content = style.content;"}
{"input":"<s> function _simpleAsString(modifiers: Modifiers, key: string, labels: ModifierLabels): string {<EOL>    if (key === null) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    let","gt":"result: string[] = [];"}
{"input":"<s> function _simpleAsString(modifiers: Modifiers, key: string, labels: ModifierLabels): string {<EOL>    if (key === null) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    let result: string[] = [];<EOL>    <EOL>    if (modifiers.ctrlKey) {<EOL>","gt":"result.push(labels.ctrlKey);"}
{"input":"<s> function _simpleAsString(modifiers: Modifiers, key: string, labels: ModifierLabels): string {<EOL>    if (key === null) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    let result: string[] = [];<EOL>    <EOL>    if (modifiers.ctrlKey) {<EOL>        result.push(labels.ctrlKey);<EOL>    }<EOL>    if (modifiers.shiftKey) {<EOL>        result.push(labels.shiftKey);<EOL>    }<EOL>    if (modifiers.altKey) {<EOL>        result.push(labels.altKey);<EOL>    }<EOL>    if (modifiers.metaKey) {<EOL>","gt":"result.push(labels.metaKey);"}
{"input":"<s> export function provideReferences(model: ITextModel, position: Position): TPromise<Location[]> {<EOL>    <EOL>    const promises = ReferenceProviderRegistry.ordered(model).map(provider => {<EOL>        return asWinJsPromise((token) => {<EOL>            return provider.provideReferences(model, position, { includeDeclaration: true }, token);<EOL>        }).then(","gt":"result => {"}
{"input":"<s> export function provideReferences(model: ITextModel, position: Position): TPromise<Location[]> {<EOL>    <EOL>    const promises = ReferenceProviderRegistry.ordered(model).map(provider => {<EOL>        return asWinJsPromise((token) => {<EOL>            return provider.provideReferences(model, position, { includeDeclaration: true }, token);<EOL>        }).then(result => {<EOL>            if (Array.isArray(result)) {<EOL>                return <","gt":"Location[]>result;"}
{"input":"<s> export function provideReferences(model: ITextModel, position: Position): TPromise<Location[]> {<EOL>    <EOL>    const promises = ReferenceProviderRegistry.ordered(model).map(provider => {<EOL>        return asWinJsPromise((token) => {<EOL>            return provider.provideReferences(model, position, { includeDeclaration: true }, token);<EOL>        }).then(result => {<EOL>            if (Array.isArray(result)) {<EOL>                return <Location[]>result;<EOL>            }<EOL>            return undefined;<EOL>        }, err => {<EOL>            onUnexpectedExternalError(err);<EOL>        });<EOL>    });<EOL>    return TPromise.join(promises).then(references => {<EOL>        let result: Location[] = [];<EOL>        for (let ref of references) {<EOL>            if (","gt":"ref) {"}
{"input":"<s> export function setup() {<EOL>    describe('<STR_LIT>', () => {<EOL>        before(async function () {<EOL>            this.app.suiteName = '<STR_LIT>';<EOL>","gt":"const app = this.app as SpectronApplication;"}
{"input":"<s> export function setup() {<EOL>    describe('<STR_LIT>', () => {<EOL>        before(async function () {<EOL>            this.app.suiteName = '<STR_LIT>';<EOL>            const app = this.app as SpectronApplication;<EOL>            <EOL>            <EOL>            await app.restart({ workspaceOrFolder: app.","gt":"workspaceFilePath, extraArgs: ['<STR_LIT>'] });"}
{"input":"<s> export function setup() {<EOL>    describe('<STR_LIT>', () => {<EOL>        before(async function () {<EOL>            this.app.suiteName = '<STR_LIT>';<EOL>            const app = this.app as SpectronApplication;<EOL>            <EOL>            <EOL>            await app.restart({ workspaceOrFolder: app.workspaceFilePath, extraArgs: ['<STR_LIT>'] });<EOL>        });<EOL>        it('<STR_LIT>', async function () {<EOL>            const app = this.app as SpectronApplication;<EOL>            await app.workbench.quickopen.openQuickOpen('<STR_LIT>');<EOL>","gt":"await app.workbench.quickopen.waitForQuickOpenElements(names => names.length === <NUM_LIT>);"}
{"input":"<s> export function setup() {<EOL>    describe('<STR_LIT>', () => {<EOL>        before(async function () {<EOL>            this.app.suiteName = '<STR_LIT>';<EOL>            const app = this.app as SpectronApplication;<EOL>            <EOL>            <EOL>            await app.restart({ workspaceOrFolder: app.workspaceFilePath, extraArgs: ['<STR_LIT>'] });<EOL>        });<EOL>        it('<STR_LIT>', async function () {<EOL>            const app = this.app as SpectronApplication;<EOL>            await app.workbench.quickopen.openQuickOpen('<STR_LIT>');<EOL>            await app.workbench.quickopen.waitForQuickOpenElements(names => names.length === <NUM_LIT>);<EOL>            await app.workbench.quickopen.closeQuickOpen();<EOL>        });<EOL>        it('<STR_LIT>', async function () {<EOL>            const app = this.app","gt":"as SpectronApplication;"}
{"input":"<s> export function mapEvent<I, O>(event: Event<I>, map: (i: I) => O): Event<O> {<EOL>    return (listener, thisArgs = null, disposables?) => event(i => listener.","gt":"call(thisArgs, map(i)), null, disposables);"}
{"input":"<s> function getBodyUTF8(res: Response<Buffer | string>): string {<EOL>","gt":"return res.getBody('<STR_LIT>');"}
{"input":"<s> /**<EOL> * Custom function to insert an export into NgModule. It also imports it.<EOL> */<EOL>export function addBootstrapToModule(source: ts.SourceFile, modulePath: string, classifiedName: string, importPath: string): Change[] {<EOL>    return addSymbolToNgModuleMetadata(source,","gt":"modulePath, '<STR_LIT>', classifiedName, importPath);"}
{"input":"<s> export function makeDefaultViewer(options?: Partial<ViewerOptions>) {<EOL>    disableContextMenu();<EOL>    disableWheel();<EOL>    try {<EOL>","gt":"let display = new DisplayContext(document.getElementById('<STR_LIT>')!);"}
{"input":"<s> export function makeDefaultViewer(options?: Partial<ViewerOptions>) {<EOL>    disableContextMenu();<EOL>    disableWheel();<EOL>    try {<EOL>        let display = new DisplayContext(document.getElementById('<STR_LIT>')!);<EOL>        return new Viewer(display, options);<EOL>    }<EOL>    catch (error) {<EOL>","gt":"StatusMessage.showMessage(`<STR_LIT>`);"}
{"input":"<s> function addToArray(arr: any[], index: number, value: any) {<EOL>    <EOL>    if (index >= arr.length) {<EOL>        arr.","gt":"push(value);"}
{"input":"<s> function getRandomInt(min: number, max: number): number {<EOL>    return","gt":"Math.floor(Math.random() * (max - min + <NUM_LIT>)) + min;"}
{"input":"<s> /**<EOL> * 在周期时间间隔内发出源 Observable 发出的最新值。<EOL> *<EOL> * <span class=\"informal\">在周期时间间隔内取样源 Observable ， 发出取样的。</span><EOL> *<EOL> * <img src=\"./img/sampleTime.png\" width=\"100%\"><EOL> *<EOL> * `sampleTime` 周期性的查看源 Observable 并且发出上次取样后发出的最新的值， 除非上次取样后<EOL> * 就没有再发出数据了。 取样在每个周期毫秒(或者时间单位由可选的调度器参数决定)内定期发生。 只要<EOL> * 输出 Observable 被订阅取样就开始。<EOL> *<EOL> * @example <caption>每秒， 发出最近的一个点击</caption><EOL> * var clicks = Rx.Observable.fromEvent(document, 'click');<EOL> * var result = clicks.sampleTime(1000);<EOL> * result.subscribe(x => console.log(x));<EOL> *<EOL> * @see {@link auditTime}<EOL> * @see {@link debounceTime}<EOL> * @see {@link delay}<EOL> * @see {@link sample}<EOL> * @see {@link throttleTime}<EOL> *<EOL> * @param {number} period 用毫秒或者由可选的调度器参数决定的时间单位表示的取样周期。<EOL> * @param {Scheduler} [scheduler=async] {@link IScheduler}用来管理取样的时间。<EOL> * @return {Observable<T>} Observable，该 Observable 发出特定的时间周期从源 Observable<EOL> * 取样的最新值。<EOL> * @method sampleTime<EOL> * @owner Observable<EOL> */<EOL>export function sampleTime<T>(this: Observable<T>, period: number, scheduler: IScheduler = async): Observable<T> {<EOL>    return","gt":"this.lift(new SampleTimeOperator(period, scheduler));"}
{"input":"<s> function is_line_chart(item: Chart): boolean {<EOL>    return ((item","gt":"instanceof StandardTimeSeries)"}
{"input":"<s> /**<EOL> * The locale id for the chosen locale (e.g `en-GB`).<EOL> *<EOL> * @experimental i18n support is experimental.<EOL> */<EOL>export function getLocaleId(locale: string): string {<EOL>    return findLocaleData(locale)[LocaleDataIndex.","gt":"LocaleId];"}
{"input":"<s> export function bindDefaultCopyHandler(viewer: Viewer) {<EOL>    viewer.registerEventListener(document, '<STR_LIT>', (event: ClipboardEvent) => {<EOL>        if (eventHasInputTextTarget(event)) {<EOL>","gt":"return;"}
{"input":"<s> <EOL><EOL>export function packageChunkSort(appConfig: any) {<EOL>    const entryPoints = generateEntryPoints(appConfig);<EOL>    function sort(left: any, right: any) {<EOL>        let leftIndex = entryPoints.indexOf(left.names[<NUM_LIT>]);<EOL>        let rightindex = entryPoints.indexOf(right.names[<NUM_LIT>]);<EOL>        if (leftIndex > rightindex) {<EOL>            return","gt":"<NUM_LIT>;"}
{"input":"<s> /**<EOL> * 将源 Observable 的值分支成多个嵌套的 Observable ，每个嵌套的 Observable 最多发出 windowSize 个值。<EOL> *<EOL> * <span class=\"informal\">就像是 {@link bufferCount}, 但是返回嵌套的 Observable 而不是数组。</span><EOL> *<EOL> * <img src=\"./img/windowCount.png\" width=\"100%\"><EOL><EOL> * 返回的 Observable 发出从源 Observable 收集到的项的窗口。<EOL> * 输出 Observable 每M(M = startWindowEvery)个项发出新窗口，每个窗口包含的项数不得超过N个(N = windowSize)。<EOL> * 当源 Observable 完成或者遇到错误,输出 Observable 发出当前窗口并且传播从源 Observable 收到的通知。<EOL> * 如果没有提供 startWindowEvery ，那么在源 Observable 的起始处立即开启新窗口，并且当每个窗口的大小达到 windowSize 时完成。<EOL> *<EOL> * @example <caption>从第一个点击事件开始，忽略第3N次点击</caption><EOL> * var clicks = Rx.Observable.fromEvent(document, 'click');<EOL> * var result = clicks.windowCount(3)<EOL> *   .map(win => win.skip(1)) // 跳过每三个点击中的第一个<EOL> *   .mergeAll(); // 打平高阶 Observable<EOL> * result.subscribe(x => console.log(x));<EOL> *<EOL> * @example <caption>从第三个点击事件开始，忽略第3N次点击</caption><EOL> * var clicks = Rx.Observable.fromEvent(document, 'click');<EOL> * var result = clicks.windowCount(2, 3)<EOL> *   .mergeAll(); // 打平高阶 Observable<EOL> * result.subscribe(x => console.log(x));<EOL> *<EOL> * @see {@link window}<EOL> * @see {@link windowTime}<EOL> * @see {@link windowToggle}<EOL> * @see {@link windowWhen}<EOL> * @see {@link bufferCount}<EOL> *<EOL> * @param {number} windowSize 每个窗口最多可以发送的个数。<EOL> * @param {number} [startWindowEvery] 开启新窗口的间隔。<EOL> * 比如，如果 `startWindowEvery` 是 `2`, 新窗口会在源中每个第二个值开启。默认情况下，新窗口是在源 Observable 的起始处开启的。<EOL> * @return {Observable<Observable<T>>} 窗口的 Observable，每个窗口又是值的 Observable 。(译者注：其实就是高阶 Observable )<EOL> * @method windowCount<EOL> * @owner Observable<EOL> */<EOL>export function windowCount<T>(this: Observable<T>, windowSize: number, startWindowEvery: number = <NUM_LIT>): Observable<Observable<T>> {<EOL>","gt":"return this.lift(new WindowCountOperator<T>(windowSize, startWindowEvery));"}
{"input":"<s> export function encodeBytesToFloat32(x: ArrayBufferView) {<EOL>    let xBytes = new Uint8Array(x.buffer, x.byteOffset, x.byteLength);<EOL>    let length = xBytes.length;<EOL>    let","gt":"result = new Float32Array(length);"}
{"input":"<s> export function readFile(filePath: string, encoding: string): Q.Promise<string> {<EOL>    return","gt":"Q.nfcall<string>(fs.readFile, filePath, encoding);"}
{"input":"<s> /**<EOL> *<EOL> * 使用指定的调度器来重新发出源 Observable 的所有通知。<EOL> *<EOL> * <span class=\"informal\">确保从 Observable 的外部使用特定的调度器。</span><EOL> *<EOL> * `observeOn` 操作符接收一个 scheduler 作为第一个参数，它将用于重新安排源 Observable 所发送的通知。如果你不能控制<EOL> * 给定 Observable 的内部调度器，但是想要控制何时发出值，那么这个操作符可能是有用的。<EOL> *<EOL> * 返回的 Observable 发出与源 Observable 相同的通知(`next`、`complete` 和 `error`)，但是使用提供的调度器进行了重新安排。<EOL> * 注意，这并不意味着源 Observables 的内部调度器会以任何形式被替换。原始的调度器仍然会被使用，但是当源 Observable 发出<EOL> * 通知时，它会立即重新安排(这时候使用传给 `observeOn` 的调度器)。在同步地发出大量的值的 Observalbe 上调用 `observeOn`<EOL> * 是一种反模式，这会将 Observable 的发送分解成异步块。为了实现这一点，调度器必须直接传递给源 Observable (通常是创建它的操作符)。<EOL> * `observeOn` 只是简单地像通知延迟一些，以确保这些通知在预期的时间点发出。<EOL> *<EOL> * 事实上，`observeOn` 接收第二个参数，它以毫秒为单位指定延迟通知的发送时间。`observeOn` 与 {@link delay}<EOL> * 操作符最主要的区别是它会延迟所有通知，包括错误通知，而 `delay` 会当源 Observable 发出错误时立即通过错误。<EOL> * 通常来说，对于想延迟流中的任何值，强烈推荐使用 `delay` 操作符，而使用 `observeOn` 时，用来指定应该使用<EOL> * 哪个调度器来进行通知发送。<EOL> *<EOL> * @example <caption>确保在浏览器重绘前调用订阅中的值。</caption><EOL> * const intervals = Rx.Observable.interval(10); // 默认情况下，interval 使用异步调度器进行调度<EOL> *<EOL> * intervals<EOL> * .observeOn(Rx.Scheduler.animationFrame)       // 但我们将在 animationFrame 调度器上进行观察，<EOL> * .subscribe(val => {                           // 以确保动画的流畅性。<EOL> *   someDiv.style.height = val + 'px';<EOL> * });<EOL> *<EOL> * @see {@link delay}<EOL> *<EOL> * @param {IScheduler} scheduler 用于重新安排源 Observable 的通知的调度器。<EOL> * @param {number} [delay] 应该重新安排的每个通知的延迟时间的毫秒数。<EOL> * @return {Observable<T>} 该 Observable 发出与源 Observale 同样的通知，但是使用了提供的调度器。<EOL> *<EOL> * @method observeOn<EOL> * @owner Observable<EOL> */<EOL>export function observeOn<T>(this: Observable<T>, scheduler: IScheduler, delay: number = <NUM_LIT>): Observable<T> {<EOL>    return this.lift(new","gt":"ObserveOnOperator(scheduler, delay));"}
{"input":"<s> export function removeSignalBinding<T extends Function>(signal: Signal<T>, handler: T) {<EOL>    signal.remove(","gt":"handler);"}
{"input":"<s> export function addSignalBinding<T extends Function>(signal: Signal<T>, handler: T) {<EOL>    signal.","gt":"add(handler);"}
{"input":"<s> export function _window(): PrebootWindow {<EOL>    return {<EOL>        prebootData: (window as any)[","gt":"'<STR_LIT>'],"}
{"input":"<s> <EOL>/**<EOL> * 将每个源值投射成同一个 Observable ，该 Observable 会使用 {@link switch} 多次被打平<EOL> * 到输出 Observable 中。<EOL> *<EOL> * <span class=\"informal\">它很像 {@link switchMap}，但永远将每个值映射到同一个内部<EOL> + * Observable 。</span><EOL> *<EOL> * <img src=\"./img/switchMapTo.png\" width=\"100%\"><EOL> *<EOL> * 将每个源值映射成给定的 Observable ：`innerObservable` ，而无论源值是什么，然后<EOL> * 将这些结果 Observables 合并到单个的 Observable ，也就是输出 Observable 。<EOL> * 输出 Observables 只会发出 `innerObservable` 实例最新发出的值。<EOL> *<EOL> * @example <caption>每次点击返回一个 interval Observable</caption><EOL> * var clicks = Rx.Observable.fromEvent(document, 'click');<EOL> * var result = clicks.switchMapTo(Rx.Observable.interval(1000));<EOL> * result.subscribe(x => console.log(x));<EOL> *<EOL> * @see {@link concatMapTo}<EOL> * @see {@link switch}<EOL> * @see {@link switchMap}<EOL> * @see {@link mergeMapTo}<EOL> *<EOL> * @param {ObservableInput} innerObservable 用来替换源 Observable 中的每个值<EOL> * 的 Observable 。<EOL> * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]<EOL> * 函数，它用于产生基于值的输出 Observable 和源(外部)发送和内部 Observable 发送的索引。<EOL> * 传递给这个函数参数有：<EOL> * - `outerValue`: 来自源的值<EOL> * - `innerValue`: 来自投射的 Observable 的值<EOL> * - `outerIndex`: 来自源的值的 \"index\"<EOL> * - `innerIndex`: 来自投射的 Observable 的值的 \"index\"<EOL> * @return {Observable} 每次源 Observable 发出值时，该 Observable 发出来自<EOL> * 给定 `innerObservable` (和通过 `resultSelector` 的可选的转换)的项，<EOL> * 并只接收最新投射的内部 Observable 的值。<EOL> * @method switchMapTo<EOL> * @owner Observable<EOL> */<EOL>export function switchMapTo<T, I, R>(this: Observable<T>, innerObservable: Observable<I>, resultSelector?: (outerValue: T, innerValue: I, outerIndex: number, innerIndex: number) => R): Observable<I | R> {<EOL>    return this.lift(new SwitchMapToOperator(innerObservable,","gt":"resultSelector));"}
{"input":"<s> function cursorCommandAndTokenize(model: TextModel, cursor: Cursor, command: string, extraData?: any, overwriteSource?: string) {<EOL>    cursor.trigger(","gt":"overwriteSource || '<STR_LIT>', command, extraData);"}
{"input":"<s> /**<EOL> * Setups pipes to the chosen context.<EOL> * When the `@UsePipes()` is used on the controller level:<EOL> * - Pipe will be set up to every handler (every method)<EOL> *<EOL> * When the `@UsePipes()` is used on the handle level:<EOL> * - Pipe will be set up only to specified method<EOL> *<EOL> * @param  {PipeTransform[]} ...pipes (instances)<EOL> */<EOL>export function UsePipes(...pipes: PipeTransform<any>[]) {<EOL>    return (target: object, key?, descriptor?) => {<EOL>        if (descriptor) {<EOL>            Reflect.","gt":"defineMetadata(PIPES_METADATA, pipes, descriptor.value);"}
{"input":"<s> export function withModule(moduleDef: TestModuleMetadata, fn?: Function | null): (() => any) | InjectSetupWrapper {<EOL>    if (fn) {<EOL>        <EOL>        return function () {<EOL>            const testBed =","gt":"getTestBed();"}
{"input":"<s> export function make(data: any, init?: any): any {<EOL>    if (data instanceof DashboardItem) {<EOL>        return data;<EOL>    }<EOL>    if ((typeof (data) === '<STR_LIT>') &&","gt":"constructors.has(data)) {"}
{"input":"<s> export function isNewline(code: number): boolean {<EOL>    switch (code) {<EOL>        case chars.$FF:<EOL>        case chars.","gt":"$CR:"}
{"input":"<s> <EOL>export function parseArray<T>(x: any, parseElement: (x: any, index: number) => T): T[] {<EOL>    if (!Array.isArray(x)) {<EOL>        throw new","gt":"Error(`<STR_LIT>`);"}
{"input":"<s> export function openShardedHttpRequest(baseUrls: string | string[], path: string, method = '<STR_LIT>') {<EOL>    let xhr = new XMLHttpRequest();<EOL>    const url =","gt":"pickShard(baseUrls, path);"}
{"input":"<s> function assertAggregatedLevelEqual(level: CumulativePriceLevel, expected: any) {<EOL>    assert.ok(level.price.eq(expected.price), `<STR_LIT>`);<EOL>    assert.ok(level.totalSize.eq(expected.totalSize), '<STR_LIT>');<EOL>","gt":"assert.ok(level.value.eq(expected.value), '<STR_LIT>');"}
{"input":"<s> function hasLifecycleHook(hook: Hooks, directive: any): boolean {<EOL>    return hasLifecycleHookImpl(new","gt":"JitReflector(), hook, directive);"}
{"input":"<s> function _flattenGroupPlayersRecur(players: AnimationPlayer[], finalPlayers: AnimationPlayer[]) {<EOL>    for (let i = <NUM_LIT>; i < players.length; i++) {<EOL>        const player = players[i];<EOL>        if (player","gt":"instanceof AnimationGroupPlayer) {"}
{"input":"<s> function _visitJsonRecursive<ContextT>(json: JsonValue, visitor: JsonVisitor, ptr: JsonPointer, schema?: JsonObject, refResolver?: ReferenceResolver<ContextT>, context?: ContextT, <EOL>root?: JsonObject | JsonArray): Observable<JsonValue | undefined> {<EOL>    if (schema && schema.hasOwnProperty('<STR_LIT>') && typeof schema['<STR_LIT>'] == '<STR_LIT>') {<EOL>        if (refResolver) {<EOL>            const resolved = refResolver(schema['<STR_LIT>'] as string, context);<EOL>            schema = resolved.schema;<EOL>            context = resolved.","gt":"context;"}
{"input":"<s> function _visitJsonRecursive<ContextT>(json: JsonValue, visitor: JsonVisitor, ptr: JsonPointer, schema?: JsonObject, refResolver?: ReferenceResolver<ContextT>, context?: ContextT, <EOL>root?: JsonObject | JsonArray): Observable<JsonValue | undefined> {<EOL>    if (schema && schema.hasOwnProperty('<STR_LIT>') && typeof schema['<STR_LIT>'] == '<STR_LIT>') {<EOL>        if (refResolver) {<EOL>            const resolved = refResolver(schema['<STR_LIT>'] as string, context);<EOL>            schema = resolved.schema;<EOL>            context = resolved.context;<EOL>        }<EOL>    }<EOL>    const value = visitor(json,","gt":"ptr, schema, root);"}
{"input":"<s> function _visitJsonRecursive<ContextT>(json: JsonValue, visitor: JsonVisitor, ptr: JsonPointer, schema?: JsonObject, refResolver?: ReferenceResolver<ContextT>, context?: ContextT, <EOL>root?: JsonObject | JsonArray): Observable<JsonValue | undefined> {<EOL>    if (schema && schema.hasOwnProperty('<STR_LIT>') && typeof schema['<STR_LIT>'] == '<STR_LIT>') {<EOL>        if (refResolver) {<EOL>            const resolved = refResolver(schema['<STR_LIT>'] as string, context);<EOL>            schema = resolved.schema;<EOL>            context = resolved.context;<EOL>        }<EOL>    }<EOL>    const value = visitor(json, ptr, schema, root);<EOL>    return ((typeof value == '<STR_LIT>' && value != null && observable in value)<EOL>        ? value as Observable<JsonValue | undefined><EOL>        : observableOf(value as JsonValue | undefined)).pipe(concatMap((","gt":"value: JsonValue | undefined) => {"}
{"input":"<s> function _visitJsonRecursive<ContextT>(json: JsonValue, visitor: JsonVisitor, ptr: JsonPointer, schema?: JsonObject, refResolver?: ReferenceResolver<ContextT>, context?: ContextT, <EOL>root?: JsonObject | JsonArray): Observable<JsonValue | undefined> {<EOL>    if (schema && schema.hasOwnProperty('<STR_LIT>') && typeof schema['<STR_LIT>'] == '<STR_LIT>') {<EOL>        if (refResolver) {<EOL>            const resolved = refResolver(schema['<STR_LIT>'] as string, context);<EOL>            schema = resolved.schema;<EOL>            context = resolved.context;<EOL>        }<EOL>    }<EOL>    const value = visitor(json, ptr, schema, root);<EOL>    return ((typeof value == '<STR_LIT>' && value != null && observable in value)<EOL>        ? value as Observable<JsonValue | undefined><EOL>        : observableOf(value as JsonValue | undefined)).pipe(concatMap((value: JsonValue | undefined) => {<EOL>        if (Array.isArray(value)) {<EOL>            return from(value).pipe(mergeMap((item, i) => {<EOL>                return _visitJsonRecursive(item, visitor, joinJsonPointer(ptr, '<STR_LIT>' + i), _getObjectSubSchema(schema, '<STR_LIT>' + i), refResolver,","gt":"context, root || value).pipe(tap<JsonValue>(x => value[i] = x));"}
{"input":"<s> function _visitJsonRecursive<ContextT>(json: JsonValue, visitor: JsonVisitor, ptr: JsonPointer, schema?: JsonObject, refResolver?: ReferenceResolver<ContextT>, context?: ContextT, <EOL>root?: JsonObject | JsonArray): Observable<JsonValue | undefined> {<EOL>    if (schema && schema.hasOwnProperty('<STR_LIT>') && typeof schema['<STR_LIT>'] == '<STR_LIT>') {<EOL>        if (refResolver) {<EOL>            const resolved = refResolver(schema['<STR_LIT>'] as string, context);<EOL>            schema = resolved.schema;<EOL>            context = resolved.context;<EOL>        }<EOL>    }<EOL>    const value = visitor(json, ptr, schema, root);<EOL>    return ((typeof value == '<STR_LIT>' && value != null && observable in value)<EOL>        ? value as Observable<JsonValue | undefined><EOL>        : observableOf(value as JsonValue | undefined)).pipe(concatMap((value: JsonValue | undefined) => {<EOL>        if (Array.isArray(value)) {<EOL>            return from(value).pipe(mergeMap((item, i) => {<EOL>                return _visitJsonRecursive(item, visitor, joinJsonPointer(ptr, '<STR_LIT>' + i), _getObjectSubSchema(schema, '<STR_LIT>' + i), refResolver, context, root || value).pipe(tap<JsonValue>(x => value[i] = x));<EOL>            }), ignoreElements(), concat(observableOf(value)));<EOL>        }<EOL>        else if (typeof value == '<STR_LIT>' && value !== null) {<EOL>            return from(Object.getOwnPropertyNames(value)).pipe(mergeMap(key => {<EOL>                return _visitJsonRecursive(value[key], visitor, joinJsonPointer(ptr, key), _getObjectSubSchema(schema, key), refResolver,","gt":"context, root || value).pipe(tap<JsonValue>(x => value[key] = x));"}
{"input":"<s> <EOL>/**<EOL> * Thrown when a multi provider and a regular provider are bound to the same token.<EOL> *<EOL> * ### Example<EOL> *<EOL> * ```typescript<EOL> * expect(() => Injector.resolveAndCreate([<EOL> *   { provide: \"Strings\", useValue: \"string1\", multi: true},<EOL> *   { provide: \"Strings\", useValue: \"string2\", multi: false}<EOL> * ])).toThrowError();<EOL> * ```<EOL> */<EOL>export function mixingMultiProvidersWithRegularProvidersError(provider1: any, provider2: any): Error {<EOL>    return Error(","gt":"provider2}`<STR_LIT>;"}
{"input":"<s> /**<EOL> * @deprecated This symbol has moved. Please Import from @angular/animations instead!<EOL> */<EOL>export function state(name: string, styles: AnimationStyleMetadata): AnimationStateMetadata {<EOL>    return","gt":"_state(name, styles);"}
{"input":"<s> function expectEntries(locationMarker: string, info: ts.CompletionInfo, ...names: string[]) {<EOL>    let entries: {<EOL>        [name: string]: boolean;<EOL>    } = {};<EOL>    if (!info) {<EOL>        throw new","gt":"Error(`<STR_LIT>`);"}
{"input":"<s> function expectEntries(locationMarker: string, info: ts.CompletionInfo, ...names: string[]) {<EOL>    let entries: {<EOL>        [name: string]: boolean;<EOL>    } = {};<EOL>    if (!info) {<EOL>        throw new Error(`<STR_LIT>`);<EOL>    }<EOL>    else {<EOL>        for (let entry","gt":"of info.entries) {"}
{"input":"<s> function expectEntries(locationMarker: string, info: ts.CompletionInfo, ...names: string[]) {<EOL>    let entries: {<EOL>        [name: string]: boolean;<EOL>    } = {};<EOL>    if (!info) {<EOL>        throw new Error(`<STR_LIT>`);<EOL>    }<EOL>    else {<EOL>        for (let entry of info.entries) {<EOL>            entries[entry.name] = true;<EOL>        }<EOL>        let shouldContains = names.filter(name => !name.startsWith('<STR_LIT>'));<EOL>        let shouldNotContain = names.filter(name => name.startsWith('<STR_LIT>'));<EOL>        let missing =","gt":"shouldContains.filter(name => !entries[name]);"}
{"input":"<s> function generateRandomBook(n: number): RandomBook {<EOL>    const result = {<EOL>        orders: [] as Level3Order[],<EOL>        totalBids: ZERO,<EOL>        totalAsks: ZERO,<EOL>","gt":"totalBidValue: ZERO,"}
{"input":"<s> function generateRandomBook(n: number): RandomBook {<EOL>    const result = {<EOL>        orders: [] as Level3Order[],<EOL>        totalBids: ZERO,<EOL>        totalAsks: ZERO,<EOL>        totalBidValue: ZERO,<EOL>        totalAsksValue: ZERO<EOL>    };<EOL>    for (let i = <NUM_LIT>; i < n; i++) {<EOL>        const side = Math.random() >= <NUM_LIT> ? '<STR_LIT>' :","gt":"'<STR_LIT>';"}
{"input":"<s> function generateRandomBook(n: number): RandomBook {<EOL>    const result = {<EOL>        orders: [] as Level3Order[],<EOL>        totalBids: ZERO,<EOL>        totalAsks: ZERO,<EOL>        totalBidValue: ZERO,<EOL>        totalAsksValue: ZERO<EOL>    };<EOL>    for (let i = <NUM_LIT>; i < n; i++) {<EOL>        const side = Math.random() >= <NUM_LIT> ? '<STR_LIT>' : '<STR_LIT>';<EOL>        const size = Big(String(Math.random() * <NUM_LIT>)).round(<NUM_LIT>);<EOL>        const price = side === '<STR_LIT>' ? Big(String(<NUM_LIT> - Math.random() * <NUM_LIT>)).round(<NUM_LIT>) : Big(String(<NUM_LIT> + Math.random() * <NUM_LIT>)).round(<NUM_LIT>);<EOL>        result.","gt":"orders.push({"}
{"input":"<s> function generateRandomBook(n: number): RandomBook {<EOL>    const result = {<EOL>        orders: [] as Level3Order[],<EOL>        totalBids: ZERO,<EOL>        totalAsks: ZERO,<EOL>        totalBidValue: ZERO,<EOL>        totalAsksValue: ZERO<EOL>    };<EOL>    for (let i = <NUM_LIT>; i < n; i++) {<EOL>        const side = Math.random() >= <NUM_LIT> ? '<STR_LIT>' : '<STR_LIT>';<EOL>        const size = Big(String(Math.random() * <NUM_LIT>)).round(<NUM_LIT>);<EOL>        const price = side === '<STR_LIT>' ? Big(String(<NUM_LIT> - Math.random() * <NUM_LIT>)).round(<NUM_LIT>) : Big(String(<NUM_LIT> + Math.random() * <NUM_LIT>)).round(<NUM_LIT>);<EOL>        result.orders.push({<EOL>            id: `<STR_LIT>`,<EOL>            side: side,<EOL>","gt":"size: size,"}
{"input":"<s> export function mixin(mixinClass) {<EOL>    this.offset = this.offset ? ++this.offset : Math.random() * <NUM_LIT>;<EOL>","gt":"Object.defineProperty(mixinClass, '<STR_LIT>', {"}
{"input":"<s> function rejectWithError(msg: string, error: any): Promise<never> {<EOL>    const","gt":"err = new GTTError(`<STR_LIT>`, error);"}
{"input":"<s> function _certificateHasSubjectAltName(certificateData: string): boolean {<EOL>    const certificate: IForgeCertificate = forge.pki.certificateFromPem(","gt":"certificateData);"}
{"input":"<s> function validateSingle(document: TextDocument, publishDiagnostics: boolean = true): Thenable<void> {<EOL>    <EOL>    <EOL>    if (!documents.get(document.uri)) {<EOL>        return Promise.resolve(undefined);<EOL>    }<EOL>    return resolveSettings(document).then((settings) => {<EOL>        if (!settings.validate) {<EOL>","gt":"return;"}
{"input":"<s> function validateSingle(document: TextDocument, publishDiagnostics: boolean = true): Thenable<void> {<EOL>    <EOL>    <EOL>    if (!documents.get(document.uri)) {<EOL>        return Promise.resolve(undefined);<EOL>    }<EOL>    return resolveSettings(document).then((settings) => {<EOL>        if (!settings.validate) {<EOL>            return;<EOL>        }<EOL>        try {<EOL>            validate(document,","gt":"settings, publishDiagnostics);"}
{"input":"<s> function validateSingle(document: TextDocument, publishDiagnostics: boolean = true): Thenable<void> {<EOL>    <EOL>    <EOL>    if (!documents.get(document.uri)) {<EOL>        return Promise.resolve(undefined);<EOL>    }<EOL>    return resolveSettings(document).then((settings) => {<EOL>        if (!settings.validate) {<EOL>            return;<EOL>        }<EOL>        try {<EOL>            validate(document, settings, publishDiagnostics);<EOL>            connection.sendNotification(StatusNotification.type, { state: Status.ok });<EOL>        }<EOL>","gt":"catch (err) {"}
{"input":"<s> /**<EOL> * Date format that depends on the locale.<EOL> *<EOL> * There are four basic date formats:<EOL> * - `full` should contain long-weekday (EEEE), year (y), long-month (MMMM), day (d).<EOL> *<EOL> *  For example, English uses `EEEE, MMMM d, y`, corresponding to a date like<EOL> *  \"Tuesday, September 14, 1999\".<EOL> *<EOL> * - `long` should contain year, long-month, day.<EOL> *<EOL> *  For example, `MMMM d, y`, corresponding to a date like \"September 14, 1999\".<EOL> *<EOL> * - `medium` should contain year, abbreviated-month (MMM), day.<EOL> *<EOL> *  For example, `MMM d, y`, corresponding to a date like \"Sep 14, 1999\".<EOL> *  For languages that do not use abbreviated months, use the numeric month (MM/M). For example,<EOL> *  `y/MM/dd`, corresponding to a date like \"1999/09/14\".<EOL> *<EOL> * - `short` should contain year, numeric-month (MM/M), and day.<EOL> *<EOL> *  For example, `M/d/yy`, corresponding to a date like \"9/14/99\".<EOL> *<EOL> * @experimental i18n support is experimental.<EOL> */<EOL>export function getLocaleDateFormat(locale: string, width: FormatWidth): string {<EOL>","gt":"const data = findLocaleData(locale);"}
{"input":"<s> export default function (options: ParsedArgs, logger: logging.Logger) {<EOL>    _buildRules(logger);<EOL>    const lintOptions: ILinterOptions = {<EOL>        fix: options.","gt":"fix,"}
{"input":"<s> export default function (options: ParsedArgs, logger: logging.Logger) {<EOL>    _buildRules(logger);<EOL>    const lintOptions: ILinterOptions = {<EOL>        fix: options.fix,<EOL>    };<EOL>    const program = Linter.createProgram(path.join(__dirname, '<STR_LIT>'));<EOL>    const linter = new Linter(","gt":"lintOptions, program);"}
{"input":"<s> export default function (options: ParsedArgs, logger: logging.Logger) {<EOL>    _buildRules(logger);<EOL>    const lintOptions: ILinterOptions = {<EOL>        fix: options.fix,<EOL>    };<EOL>    const program = Linter.createProgram(path.join(__dirname, '<STR_LIT>'));<EOL>    const linter = new Linter(lintOptions, program);<EOL>    const tsLintPath = path.join(__dirname, '<STR_LIT>');<EOL>    const tsLintConfig = Configuration.loadConfigurationFromPath(tsLintPath);<EOL>    program.getRootFileNames().forEach(fileName => {<EOL>        linter.lint(fileName, ts.sys.readFile(fileName) ||","gt":"'<STR_LIT>', tsLintConfig);"}
{"input":"<s> export default function (options: ParsedArgs, logger: logging.Logger) {<EOL>    _buildRules(logger);<EOL>    const lintOptions: ILinterOptions = {<EOL>        fix: options.fix,<EOL>    };<EOL>    const program = Linter.createProgram(path.join(__dirname, '<STR_LIT>'));<EOL>    const linter = new Linter(lintOptions, program);<EOL>    const tsLintPath = path.join(__dirname, '<STR_LIT>');<EOL>    const tsLintConfig = Configuration.loadConfigurationFromPath(tsLintPath);<EOL>    program.getRootFileNames().forEach(fileName => {<EOL>        linter.lint(fileName, ts.sys.readFile(fileName) || '<STR_LIT>', tsLintConfig);<EOL>    });<EOL>    const result = linter.getResult();<EOL>","gt":"const Formatter = findFormatter('<STR_LIT>');"}
{"input":"<s> export default function (options: ParsedArgs, logger: logging.Logger) {<EOL>    _buildRules(logger);<EOL>    const lintOptions: ILinterOptions = {<EOL>        fix: options.fix,<EOL>    };<EOL>    const program = Linter.createProgram(path.join(__dirname, '<STR_LIT>'));<EOL>    const linter = new Linter(lintOptions, program);<EOL>    const tsLintPath = path.join(__dirname, '<STR_LIT>');<EOL>    const tsLintConfig = Configuration.loadConfigurationFromPath(tsLintPath);<EOL>    program.getRootFileNames().forEach(fileName => {<EOL>        linter.lint(fileName, ts.sys.readFile(fileName) || '<STR_LIT>', tsLintConfig);<EOL>    });<EOL>    const result = linter.getResult();<EOL>    const Formatter = findFormatter('<STR_LIT>');<EOL>    if (!Formatter) {<EOL>        throw new Error('<STR_LIT>');<EOL>    }<EOL>    const formatter =","gt":"new Formatter();"}
{"input":"<s> function getNgZone(ngZoneOption?: NgZone | '<STR_LIT>' | '<STR_LIT>'): NgZone {<EOL>    let ngZone: NgZone;<EOL>    if (ngZoneOption === '<STR_LIT>') {<EOL>        ngZone = new","gt":"NoopNgZone();"}
{"input":"<s> /**<EOL> * @internal<EOL> */<EOL>export function isResourceFileEdit(thing: any): thing is ResourceFileEdit {<EOL>    return isObject(thing) && (Boolean((<ResourceFileEdit>thing).newUri) || Boolean((<ResourceFileEdit>","gt":"thing).oldUri));"}
{"input":"<s> export function unwrapValue(view: ViewData, nodeIdx: number, bindingIdx: number, value: any): any {<EOL>    if (WrappedValue.isWrapped(value)) {<EOL>        value = WrappedValue.unwrap(value);<EOL>        const globalBindingIdx = view.def.nodes[","gt":"nodeIdx].bindingIndex + bindingIdx;"}
{"input":"<s> export function PriceLevelFactory(price: number, size: number, side: string): PriceLevelWithOrders {<EOL>    const p: BigJS = Big(price);<EOL>    const s: BigJS = Big(size);<EOL>    return {<EOL>        price:","gt":"p,"}
{"input":"<s> export function PriceLevelFactory(price: number, size: number, side: string): PriceLevelWithOrders {<EOL>    const p: BigJS = Big(price);<EOL>    const s: BigJS = Big(size);<EOL>    return {<EOL>        price: p,<EOL>        totalSize: s,<EOL>        orders: [{<EOL>                id: p.toString(),<EOL>                price: p,<EOL>                size: s,<EOL>                side:","gt":"side"}
{"input":"<s> /**<EOL> * Apply each argument in arr to iteratorFn in parallel, and return all results. If any of the<EOL> * promises reject, the process will continue, with the promises that failed returning an Error.<EOL> */<EOL>export function eachParallelAndFinish<T, U>(arr: T[], iteratorFn: (arg: T) => Promise<U>): Promise<(U | Error)[]> {<EOL>    const result: (U | Error)[] = [];<EOL>    let itemsLeft = arr.length;<EOL>    return new Promise((resolve) => {<EOL>        arr.forEach((item: T, i: number) => {<EOL>            iteratorFn(item).then((val: U) => {<EOL>                result[i] =","gt":"val;"}
{"input":"<s> /**<EOL> * Apply each argument in arr to iteratorFn in parallel, and return all results. If any of the<EOL> * promises reject, the process will continue, with the promises that failed returning an Error.<EOL> */<EOL>export function eachParallelAndFinish<T, U>(arr: T[], iteratorFn: (arg: T) => Promise<U>): Promise<(U | Error)[]> {<EOL>    const result: (U | Error)[] = [];<EOL>    let itemsLeft = arr.length;<EOL>    return new Promise((resolve) => {<EOL>        arr.forEach((item: T, i: number) => {<EOL>            iteratorFn(item).then((val: U) => {<EOL>                result[i] = val;<EOL>                if (--itemsLeft === <NUM_LIT>) {<EOL>                    return resolve(result);<EOL>                }<EOL>            }).catch((","gt":"err: Error) => {"}
{"input":"<s> /**<EOL> * Apply each argument in arr to iteratorFn in parallel, and return all results. If any of the<EOL> * promises reject, the process will continue, with the promises that failed returning an Error.<EOL> */<EOL>export function eachParallelAndFinish<T, U>(arr: T[], iteratorFn: (arg: T) => Promise<U>): Promise<(U | Error)[]> {<EOL>    const result: (U | Error)[] = [];<EOL>    let itemsLeft = arr.length;<EOL>    return new Promise((resolve) => {<EOL>        arr.forEach((item: T, i: number) => {<EOL>            iteratorFn(item).then((val: U) => {<EOL>                result[i] = val;<EOL>                if (--itemsLeft === <NUM_LIT>) {<EOL>                    return resolve(result);<EOL>                }<EOL>            }).catch((err: Error) => {<EOL>                result[i] = err;<EOL>                if (--itemsLeft === <NUM_LIT>) {<EOL>","gt":"return resolve(result);"}
{"input":"<s> export default function (options: RandomOptions): Source {<EOL>    return () => {<EOL>        const root = ('<STR_LIT>' in options) ? options.root : '<STR_LIT>';<EOL>        const map = new VirtualTree();<EOL>        const nbFiles = ('<STR_LIT>' in options)<EOL>            ? (typeof","gt":"options.multiFiles == '<STR_LIT>' ? options.multiFiles : random(<NUM_LIT>, <NUM_LIT>))"}
{"input":"<s> export default function (options: RandomOptions): Source {<EOL>    return () => {<EOL>        const root = ('<STR_LIT>' in options) ? options.root : '<STR_LIT>';<EOL>        const map = new VirtualTree();<EOL>        const nbFiles = ('<STR_LIT>' in options)<EOL>            ? (typeof options.multiFiles == '<STR_LIT>' ? options.multiFiles : random(<NUM_LIT>, <NUM_LIT>))<EOL>            : <NUM_LIT>;<EOL>        for (let i = <NUM_LIT>; i < nbFiles; i++) {<EOL>            const path = '<STR_LIT>'.slice(Math.random() * <NUM_LIT>);<EOL>            const fileName = generateStringOfLength(<NUM_LIT>);<EOL>            const content = generateStringOfLength(<NUM_LIT>);<EOL>","gt":"map.create(root + '<STR_LIT>' + path + '<STR_LIT>' + fileName, content);"}
{"input":"<s> export function fallbackCompare<T>(itemA: T, itemB: T, query: IPreparedQuery, accessor: IItemAccessor<T>): number {<EOL>    <EOL>    const labelA = accessor.getItemLabel(itemA);<EOL>","gt":"const labelB = accessor.getItemLabel(itemB);"}
{"input":"<s> export function fallbackCompare<T>(itemA: T, itemB: T, query: IPreparedQuery, accessor: IItemAccessor<T>): number {<EOL>    <EOL>    const labelA = accessor.getItemLabel(itemA);<EOL>    const labelB = accessor.getItemLabel(itemB);<EOL>    const descriptionA = accessor.getItemDescription(itemA);<EOL>    const descriptionB = accessor.getItemDescription(itemB);<EOL>    const labelDescriptionALength = labelA.","gt":"length + (descriptionA ? descriptionA.length : <NUM_LIT>);"}
{"input":"<s> export function fallbackCompare<T>(itemA: T, itemB: T, query: IPreparedQuery, accessor: IItemAccessor<T>): number {<EOL>    <EOL>    const labelA = accessor.getItemLabel(itemA);<EOL>    const labelB = accessor.getItemLabel(itemB);<EOL>    const descriptionA = accessor.getItemDescription(itemA);<EOL>    const descriptionB = accessor.getItemDescription(itemB);<EOL>    const labelDescriptionALength = labelA.length + (descriptionA ? descriptionA.length : <NUM_LIT>);<EOL>    const labelDescriptionBLength = labelB.length + (descriptionB ? descriptionB.length : <NUM_LIT>);<EOL>    if (labelDescriptionALength !== labelDescriptionBLength) {<EOL>        return labelDescriptionALength - labelDescriptionBLength;<EOL>    }<EOL>    <EOL>    const pathA = accessor.getItemPath(itemA);<EOL>","gt":"const pathB = accessor.getItemPath(itemB);"}
{"input":"<s> export function fallbackCompare<T>(itemA: T, itemB: T, query: IPreparedQuery, accessor: IItemAccessor<T>): number {<EOL>    <EOL>    const labelA = accessor.getItemLabel(itemA);<EOL>    const labelB = accessor.getItemLabel(itemB);<EOL>    const descriptionA = accessor.getItemDescription(itemA);<EOL>    const descriptionB = accessor.getItemDescription(itemB);<EOL>    const labelDescriptionALength = labelA.length + (descriptionA ? descriptionA.length : <NUM_LIT>);<EOL>    const labelDescriptionBLength = labelB.length + (descriptionB ? descriptionB.length : <NUM_LIT>);<EOL>    if (labelDescriptionALength !== labelDescriptionBLength) {<EOL>        return labelDescriptionALength - labelDescriptionBLength;<EOL>    }<EOL>    <EOL>    const pathA = accessor.getItemPath(itemA);<EOL>    const pathB = accessor.getItemPath(itemB);<EOL>    if (pathA && pathB && pathA.length !== pathB.length) {<EOL>        return pathA.length - pathB.length;<EOL>    }<EOL>    <EOL>    <EOL>    if (labelA !== labelB) {<EOL>        return compareAnything(labelA, labelB, query.value);<EOL>    }<EOL>    <EOL>    if (descriptionA && descriptionB && descriptionA !== descriptionB) {<EOL>","gt":"return compareAnything(descriptionA, descriptionB, query.value);"}
{"input":"<s> <EOL><EOL><EOL><EOL><EOL><EOL>export function elideImports(sourceFile: ts.SourceFile, removedNodes: ts.Node[], getTypeChecker: () => ts.TypeChecker): TransformOperation[] {<EOL>    const ops: TransformOperation[] = [];<EOL>    if (removedNodes.length === <NUM_LIT>) {<EOL>","gt":"return [];"}
{"input":"<s> <EOL><EOL><EOL><EOL><EOL><EOL>export function elideImports(sourceFile: ts.SourceFile, removedNodes: ts.Node[], getTypeChecker: () => ts.TypeChecker): TransformOperation[] {<EOL>    const ops: TransformOperation[] = [];<EOL>    if (removedNodes.length === <NUM_LIT>) {<EOL>        return [];<EOL>    }<EOL>    const typeChecker = getTypeChecker();<EOL>    <EOL>    const","gt":"specialCaseNames = new Set<string>();"}
{"input":"<s> <EOL><EOL><EOL><EOL><EOL><EOL>export function elideImports(sourceFile: ts.SourceFile, removedNodes: ts.Node[], getTypeChecker: () => ts.TypeChecker): TransformOperation[] {<EOL>    const ops: TransformOperation[] = [];<EOL>    if (removedNodes.length === <NUM_LIT>) {<EOL>        return [];<EOL>    }<EOL>    const typeChecker = getTypeChecker();<EOL>    <EOL>    const specialCaseNames = new Set<string>();<EOL>    const usedSymbols = new Set<ts.Symbol>();<EOL>    const imports = new Array<ts.ImportDeclaration>();<EOL>    ts.forEachChild(","gt":"sourceFile, function visit(node) {"}
{"input":"<s> <EOL><EOL><EOL><EOL><EOL><EOL>export function elideImports(sourceFile: ts.SourceFile, removedNodes: ts.Node[], getTypeChecker: () => ts.TypeChecker): TransformOperation[] {<EOL>    const ops: TransformOperation[] = [];<EOL>    if (removedNodes.length === <NUM_LIT>) {<EOL>        return [];<EOL>    }<EOL>    const typeChecker = getTypeChecker();<EOL>    <EOL>    const specialCaseNames = new Set<string>();<EOL>    const usedSymbols = new Set<ts.Symbol>();<EOL>    const imports = new Array<ts.ImportDeclaration>();<EOL>    ts.forEachChild(sourceFile, function visit(node) {<EOL>        <EOL>        if (removedNodes.includes(node)) {<EOL>            return;<EOL>        }<EOL>        <EOL>        if (ts.","gt":"isImportDeclaration(node)) {"}
{"input":"<s> <EOL><EOL><EOL><EOL><EOL><EOL>export function elideImports(sourceFile: ts.SourceFile, removedNodes: ts.Node[], getTypeChecker: () => ts.TypeChecker): TransformOperation[] {<EOL>    const ops: TransformOperation[] = [];<EOL>    if (removedNodes.length === <NUM_LIT>) {<EOL>        return [];<EOL>    }<EOL>    const typeChecker = getTypeChecker();<EOL>    <EOL>    const specialCaseNames = new Set<string>();<EOL>    const usedSymbols = new Set<ts.Symbol>();<EOL>    const imports = new Array<ts.ImportDeclaration>();<EOL>    ts.forEachChild(sourceFile, function visit(node) {<EOL>        <EOL>        if (removedNodes.includes(node)) {<EOL>            return;<EOL>        }<EOL>        <EOL>        if (ts.isImportDeclaration(node)) {<EOL>            imports.push(node);<EOL>            return;<EOL>        }<EOL>        if (ts.isIdentifier(node)) {<EOL>            usedSymbols.add(typeChecker.getSymbolAtLocation(node));<EOL>        }<EOL>        else if (ts.isExportSpecifier(node)) {<EOL>            <EOL>            <EOL>            specialCaseNames.add((node.propertyName || node.name).text);<EOL>            return;<EOL>        }<EOL>        else if (ts.isShorthandPropertyAssignment(node)) {<EOL>            <EOL>            specialCaseNames.add(node.name.text);<EOL>        }<EOL>        ts.","gt":"forEachChild(node, visit);"}
{"input":"<s> <EOL><EOL><EOL><EOL><EOL><EOL>export function elideImports(sourceFile: ts.SourceFile, removedNodes: ts.Node[], getTypeChecker: () => ts.TypeChecker): TransformOperation[] {<EOL>    const ops: TransformOperation[] = [];<EOL>    if (removedNodes.length === <NUM_LIT>) {<EOL>        return [];<EOL>    }<EOL>    const typeChecker = getTypeChecker();<EOL>    <EOL>    const specialCaseNames = new Set<string>();<EOL>    const usedSymbols = new Set<ts.Symbol>();<EOL>    const imports = new Array<ts.ImportDeclaration>();<EOL>    ts.forEachChild(sourceFile, function visit(node) {<EOL>        <EOL>        if (removedNodes.includes(node)) {<EOL>            return;<EOL>        }<EOL>        <EOL>        if (ts.isImportDeclaration(node)) {<EOL>            imports.push(node);<EOL>            return;<EOL>        }<EOL>        if (ts.isIdentifier(node)) {<EOL>            usedSymbols.add(typeChecker.getSymbolAtLocation(node));<EOL>        }<EOL>        else if (ts.isExportSpecifier(node)) {<EOL>            <EOL>            <EOL>            specialCaseNames.add((node.propertyName || node.name).text);<EOL>            return;<EOL>        }<EOL>        else if (ts.isShorthandPropertyAssignment(node)) {<EOL>            <EOL>            specialCaseNames.add(node.name.text);<EOL>        }<EOL>        ts.forEachChild(node, visit);<EOL>    });<EOL>    if (imports.length === <NUM_LIT>) {<EOL>        return [];<EOL>    }<EOL>    const isUnused = (node: ts.Identifier) => {<EOL>        if (specialCaseNames.has(node.text)) {<EOL>            return false;<EOL>        }<EOL>        const symbol =","gt":"typeChecker.getSymbolAtLocation(node);"}
{"input":"<s> <EOL><EOL><EOL><EOL><EOL><EOL>export function elideImports(sourceFile: ts.SourceFile, removedNodes: ts.Node[], getTypeChecker: () => ts.TypeChecker): TransformOperation[] {<EOL>    const ops: TransformOperation[] = [];<EOL>    if (removedNodes.length === <NUM_LIT>) {<EOL>        return [];<EOL>    }<EOL>    const typeChecker = getTypeChecker();<EOL>    <EOL>    const specialCaseNames = new Set<string>();<EOL>    const usedSymbols = new Set<ts.Symbol>();<EOL>    const imports = new Array<ts.ImportDeclaration>();<EOL>    ts.forEachChild(sourceFile, function visit(node) {<EOL>        <EOL>        if (removedNodes.includes(node)) {<EOL>            return;<EOL>        }<EOL>        <EOL>        if (ts.isImportDeclaration(node)) {<EOL>            imports.push(node);<EOL>            return;<EOL>        }<EOL>        if (ts.isIdentifier(node)) {<EOL>            usedSymbols.add(typeChecker.getSymbolAtLocation(node));<EOL>        }<EOL>        else if (ts.isExportSpecifier(node)) {<EOL>            <EOL>            <EOL>            specialCaseNames.add((node.propertyName || node.name).text);<EOL>            return;<EOL>        }<EOL>        else if (ts.isShorthandPropertyAssignment(node)) {<EOL>            <EOL>            specialCaseNames.add(node.name.text);<EOL>        }<EOL>        ts.forEachChild(node, visit);<EOL>    });<EOL>    if (imports.length === <NUM_LIT>) {<EOL>        return [];<EOL>    }<EOL>    const isUnused = (node: ts.Identifier) => {<EOL>        if (specialCaseNames.has(node.text)) {<EOL>            return false;<EOL>        }<EOL>        const symbol = typeChecker.getSymbolAtLocation(node);<EOL>        return symbol && !usedSymbols.has(symbol);<EOL>    };<EOL>    for (const node of imports) {<EOL>        if (!node.importClause) {<EOL>            <EOL>            continue;<EOL>        }<EOL>        if (node.importClause.name) {<EOL>            <EOL>            if (isUnused(node.importClause.name)) {<EOL>                ops.push(new RemoveNodeOperation(sourceFile, node));<EOL>            }<EOL>        }<EOL>        else if (ts.isNamespaceImport(node.importClause.namedBindings)) {<EOL>            <EOL>            if (isUnused(node.importClause.namedBindings.name)) {<EOL>                ops.push(new RemoveNodeOperation(","gt":"sourceFile, node));"}
{"input":"<s> <EOL><EOL><EOL><EOL><EOL><EOL>export function elideImports(sourceFile: ts.SourceFile, removedNodes: ts.Node[], getTypeChecker: () => ts.TypeChecker): TransformOperation[] {<EOL>    const ops: TransformOperation[] = [];<EOL>    if (removedNodes.length === <NUM_LIT>) {<EOL>        return [];<EOL>    }<EOL>    const typeChecker = getTypeChecker();<EOL>    <EOL>    const specialCaseNames = new Set<string>();<EOL>    const usedSymbols = new Set<ts.Symbol>();<EOL>    const imports = new Array<ts.ImportDeclaration>();<EOL>    ts.forEachChild(sourceFile, function visit(node) {<EOL>        <EOL>        if (removedNodes.includes(node)) {<EOL>            return;<EOL>        }<EOL>        <EOL>        if (ts.isImportDeclaration(node)) {<EOL>            imports.push(node);<EOL>            return;<EOL>        }<EOL>        if (ts.isIdentifier(node)) {<EOL>            usedSymbols.add(typeChecker.getSymbolAtLocation(node));<EOL>        }<EOL>        else if (ts.isExportSpecifier(node)) {<EOL>            <EOL>            <EOL>            specialCaseNames.add((node.propertyName || node.name).text);<EOL>            return;<EOL>        }<EOL>        else if (ts.isShorthandPropertyAssignment(node)) {<EOL>            <EOL>            specialCaseNames.add(node.name.text);<EOL>        }<EOL>        ts.forEachChild(node, visit);<EOL>    });<EOL>    if (imports.length === <NUM_LIT>) {<EOL>        return [];<EOL>    }<EOL>    const isUnused = (node: ts.Identifier) => {<EOL>        if (specialCaseNames.has(node.text)) {<EOL>            return false;<EOL>        }<EOL>        const symbol = typeChecker.getSymbolAtLocation(node);<EOL>        return symbol && !usedSymbols.has(symbol);<EOL>    };<EOL>    for (const node of imports) {<EOL>        if (!node.importClause) {<EOL>            <EOL>            continue;<EOL>        }<EOL>        if (node.importClause.name) {<EOL>            <EOL>            if (isUnused(node.importClause.name)) {<EOL>                ops.push(new RemoveNodeOperation(sourceFile, node));<EOL>            }<EOL>        }<EOL>        else if (ts.isNamespaceImport(node.importClause.namedBindings)) {<EOL>            <EOL>            if (isUnused(node.importClause.namedBindings.name)) {<EOL>                ops.push(new RemoveNodeOperation(sourceFile, node));<EOL>            }<EOL>        }<EOL>        else if (ts.isNamedImports(node.importClause.namedBindings)) {<EOL>            <EOL>","gt":"const specifierOps = [];"}
{"input":"<s> <EOL><EOL><EOL><EOL><EOL><EOL>export function elideImports(sourceFile: ts.SourceFile, removedNodes: ts.Node[], getTypeChecker: () => ts.TypeChecker): TransformOperation[] {<EOL>    const ops: TransformOperation[] = [];<EOL>    if (removedNodes.length === <NUM_LIT>) {<EOL>        return [];<EOL>    }<EOL>    const typeChecker = getTypeChecker();<EOL>    <EOL>    const specialCaseNames = new Set<string>();<EOL>    const usedSymbols = new Set<ts.Symbol>();<EOL>    const imports = new Array<ts.ImportDeclaration>();<EOL>    ts.forEachChild(sourceFile, function visit(node) {<EOL>        <EOL>        if (removedNodes.includes(node)) {<EOL>            return;<EOL>        }<EOL>        <EOL>        if (ts.isImportDeclaration(node)) {<EOL>            imports.push(node);<EOL>            return;<EOL>        }<EOL>        if (ts.isIdentifier(node)) {<EOL>            usedSymbols.add(typeChecker.getSymbolAtLocation(node));<EOL>        }<EOL>        else if (ts.isExportSpecifier(node)) {<EOL>            <EOL>            <EOL>            specialCaseNames.add((node.propertyName || node.name).text);<EOL>            return;<EOL>        }<EOL>        else if (ts.isShorthandPropertyAssignment(node)) {<EOL>            <EOL>            specialCaseNames.add(node.name.text);<EOL>        }<EOL>        ts.forEachChild(node, visit);<EOL>    });<EOL>    if (imports.length === <NUM_LIT>) {<EOL>        return [];<EOL>    }<EOL>    const isUnused = (node: ts.Identifier) => {<EOL>        if (specialCaseNames.has(node.text)) {<EOL>            return false;<EOL>        }<EOL>        const symbol = typeChecker.getSymbolAtLocation(node);<EOL>        return symbol && !usedSymbols.has(symbol);<EOL>    };<EOL>    for (const node of imports) {<EOL>        if (!node.importClause) {<EOL>            <EOL>            continue;<EOL>        }<EOL>        if (node.importClause.name) {<EOL>            <EOL>            if (isUnused(node.importClause.name)) {<EOL>                ops.push(new RemoveNodeOperation(sourceFile, node));<EOL>            }<EOL>        }<EOL>        else if (ts.isNamespaceImport(node.importClause.namedBindings)) {<EOL>            <EOL>            if (isUnused(node.importClause.namedBindings.name)) {<EOL>                ops.push(new RemoveNodeOperation(sourceFile, node));<EOL>            }<EOL>        }<EOL>        else if (ts.isNamedImports(node.importClause.namedBindings)) {<EOL>            <EOL>            const specifierOps = [];<EOL>            for (","gt":"const specifier of node.importClause.namedBindings.elements) {"}
{"input":"<s> export function getPipesTable(source: ts.SourceFile, program: ts.Program, checker: ts.TypeChecker, pipes: CompilePipeSummary[]): SymbolTable {<EOL>    return new PipesTable(pipes, {","gt":"program, checker, node: source });"}
{"input":"<s> function uniqueElements<T>(a: T[], b: T[]): T[] {<EOL>    const s = new Set<T>();<EOL>    for (const aItem of a) {<EOL>        s.add(aItem);<EOL>    }<EOL>    const result: T[] = [];<EOL>    const reported = new Set<T>();<EOL>    for (const bItem of b) {<EOL>        if (!s.has(bItem) && !reported.has(bItem)) {<EOL>            reported.add(bItem);<EOL>            result.","gt":"push(bItem);"}
{"input":"<s> function updateControl(control: FormControl, dir: NgControl): void {<EOL>    if (control._pendingDirty)<EOL>","gt":"control.markAsDirty();"}
{"input":"<s> export default function () {<EOL>    const modulePath = join('<STR_LIT>', '<STR_LIT>', '<STR_LIT>');<EOL>","gt":"return ng('<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>')"}
{"input":"<s> /**<EOL> * Creates a new price trigger. The feed and product specify which Ticker messages to watch for. priceThreshold is<EOL> * the price which triggers the action when it is crossed. The first price tick after this trigger is created determines<EOL> * whether it is a low- or high- price trigger.<EOL> */<EOL>export function createPriceTrigger(feed: ExchangeFeed, product: string, priceThreshold: Biglike): Trigger<TickerMessage> {<EOL>    let initialPrice: BigJS = null;<EOL>    const targetPrice = Big(priceThreshold);<EOL>    const trigger = new Trigger<TickerMessage>(feed);<EOL>    const triggerCondition: TriggerFilter = (msg: StreamMessage) => {<EOL>","gt":"if (msg.type !== '<STR_LIT>') {"}
{"input":"<s> /**<EOL> * Creates a new price trigger. The feed and product specify which Ticker messages to watch for. priceThreshold is<EOL> * the price which triggers the action when it is crossed. The first price tick after this trigger is created determines<EOL> * whether it is a low- or high- price trigger.<EOL> */<EOL>export function createPriceTrigger(feed: ExchangeFeed, product: string, priceThreshold: Biglike): Trigger<TickerMessage> {<EOL>    let initialPrice: BigJS = null;<EOL>    const targetPrice = Big(priceThreshold);<EOL>    const trigger = new Trigger<TickerMessage>(feed);<EOL>    const triggerCondition: TriggerFilter = (msg: StreamMessage) => {<EOL>        if (msg.type !== '<STR_LIT>') {<EOL>            return;<EOL>        }<EOL>        const","gt":"ticker = msg as TickerMessage;"}
{"input":"<s> /**<EOL> * Creates a new price trigger. The feed and product specify which Ticker messages to watch for. priceThreshold is<EOL> * the price which triggers the action when it is crossed. The first price tick after this trigger is created determines<EOL> * whether it is a low- or high- price trigger.<EOL> */<EOL>export function createPriceTrigger(feed: ExchangeFeed, product: string, priceThreshold: Biglike): Trigger<TickerMessage> {<EOL>    let initialPrice: BigJS = null;<EOL>    const targetPrice = Big(priceThreshold);<EOL>    const trigger = new Trigger<TickerMessage>(feed);<EOL>    const triggerCondition: TriggerFilter = (msg: StreamMessage) => {<EOL>        if (msg.type !== '<STR_LIT>') {<EOL>            return;<EOL>        }<EOL>        const ticker = msg as TickerMessage;<EOL>        if (ticker.productId !== product) {<EOL>            return;<EOL>        }<EOL>        if (initialPrice === null) {<EOL>            initialPrice = ticker.","gt":"price;"}
{"input":"<s> export function typedArray<T>(value: any, check: (value: any) => boolean): value is T[] {<EOL>    return Array.isArray(value) && (<any[]>","gt":"value).every(check);"}
{"input":"<s> function getWin32IPCHandle(userDataPath: string, type: string): string {<EOL>    const","gt":"scope = crypto.createHash('<STR_LIT>').update(userDataPath).digest('<STR_LIT>');"}
{"input":"<s> <EOL>function authRequest(auth: ExchangeAuthConfig, options: any): Promise<Response> {<EOL>    <EOL>    const payload = {<EOL>        request: options.path,<EOL>        nonce: Date.now().toString()<EOL>    };<EOL>    if (options.fields) {<EOL>        Object.assign(payload, options.fields);<EOL>        <EOL>        delete options.fields;<EOL>    }<EOL>    const b64Payload = new Buffer(JSON.stringify(payload)).toString('<STR_LIT>');<EOL>    <EOL>    const sig = getSignature(","gt":"auth, b64Payload, '<STR_LIT>');"}
{"input":"<s> <EOL>function authRequest(auth: ExchangeAuthConfig, options: any): Promise<Response> {<EOL>    <EOL>    const payload = {<EOL>        request: options.path,<EOL>        nonce: Date.now().toString()<EOL>    };<EOL>    if (options.fields) {<EOL>        Object.assign(payload, options.fields);<EOL>        <EOL>        delete options.fields;<EOL>    }<EOL>    const b64Payload = new Buffer(JSON.stringify(payload)).toString('<STR_LIT>');<EOL>    <EOL>    const sig = getSignature(auth, b64Payload, '<STR_LIT>');<EOL>    <EOL>    const headers = {<EOL>        '<STR_LIT>': auth.key,<EOL>        '<STR_LIT>': b64Payload,<EOL>","gt":"'<STR_LIT>': sig"}
{"input":"<s> export function contentTemplate<T extends TemplateOptions>(options: T): Rule {<EOL>    return","gt":"forEach(applyContentTemplate(options));"}
{"input":"<s> function createOptions(multiCursorModifier: '<STR_LIT>' | '<STR_LIT>' | '<STR_LIT>'): ClickLinkOptions {<EOL>    if (multiCursorModifier === '<STR_LIT>') {<EOL>        if (platform.isMacintosh) {<EOL>            return new ClickLinkOptions(KeyCode.Meta, '<STR_LIT>', KeyCode.Alt, '<STR_LIT>');<EOL>        }<EOL>        return new ClickLinkOptions(KeyCode.Ctrl, '<STR_LIT>', KeyCode.Alt, '<STR_LIT>');<EOL>    }<EOL>    if (platform.isMacintosh) {<EOL>        return new ClickLinkOptions(KeyCode.Alt, '<STR_LIT>',","gt":"KeyCode.Meta, '<STR_LIT>');"}
{"input":"<s> /**<EOL> * Clears out the shared fake async zone for a test.<EOL> * To be called in a global `beforeEach`.<EOL> *<EOL> * @experimental<EOL> */<EOL>export function resetFakeAsyncZone() {<EOL>","gt":"_fakeAsyncTestZoneSpec = null;"}
{"input":"<s> export function isMetadataSymbolicPrefixExpression(value: any): value is MetadataSymbolicPrefixExpression {<EOL>","gt":"return value && value.__symbolic === '<STR_LIT>';"}
{"input":"<s> /**<EOL> * This is a straightforward wrapper around getSubscribedFeeds using the Factory pattern with the most commonly used<EOL> * defaults. For customised feeds, use getSubscribedFeeds instead. It's really not adding much, but we keep it here<EOL> * to maintain a consistent method naming strategy amongst all the exchanges<EOL> *<EOL> * It is assumed that your API keys are stored in the BITTREX_KEY and BITTREX_SECRET envars<EOL> */<EOL>export function FeedFactory(logger: Logger, productIds: string[], auth?: ExchangeAuthConfig): Promise<BittrexFeed> {<EOL>    auth = auth || {<EOL>","gt":"key: process.env.BITTREX_KEY,"}
{"input":"<s> export function getLastActiveWindow<W extends ISimpleWindow>(windows: W[]): W {<EOL>    const","gt":"lastFocusedDate = Math.max.apply(Math, windows.map(window => window.lastFocusTime));"}
{"input":"<s> export function generateTokensCSSForColorMap(colorMap: Color[]): string {<EOL>    let rules: string[] = [];<EOL>    for (let i = <NUM_LIT>, len = colorMap.length; i < len; i++) {<EOL>        let color =","gt":"colorMap[i];"}
{"input":"<s> async function bar2() {<EOL>    delete","gt":"await <NUM_LIT>;"}
{"input":"<s> /**<EOL> * Registers an IExecutable to gulp so that it can be called from the command line<EOL> * @param taskName - the name of the task, can be called from the command line (e.g. \"gulp <taskName>\")<EOL> * @param taskExecutable - the executable to execute when the task is invoked<EOL> * @returns the task parameter<EOL> * @public<EOL> */<EOL>export function task(taskName: string, taskExecutable: IExecutable): IExecutable {<EOL>    taskExecutable = serial(cleanFlag, taskExecutable);<EOL>","gt":"_taskMap[taskName] = taskExecutable;"}
{"input":"<s> export function overrideOptions(original: any[], overrides: any[]) {<EOL>    let copy = cloneDeep(original);<EOL>    overrides.forEach(override => {<EOL>        const","gt":"option = copy.find((opt: any) => opt.name == override.name);"}
{"input":"<s> function binarySubdivide(aX: number, aA: number, aB: number, mX1: number, mX2: number) {<EOL>    var currentX: number, currentT: number, i: number = <NUM_LIT>;<EOL>    do {<EOL>        currentT = aA + (aB - aA) / <NUM_LIT>;<EOL>        currentX =","gt":"calcBezier(currentT, mX1, mX2) - aX;"}
{"input":"<s> <EOL>function byteStringToDecString(str: string): string {<EOL>    let decimal = '<STR_LIT>';<EOL>    let toThePower = '<STR_LIT>';<EOL>    for (let i = str.length - <NUM_LIT>; i >= <NUM_LIT>;","gt":"i--) {"}
{"input":"<s> function extractName(type: Function): string | null {<EOL>    let name = type['<STR_LIT>'];<EOL>    switch (name) {<EOL>        <EOL>        <EOL>        case","gt":"'<STR_LIT>':"}
{"input":"<s> function extractName(type: Function): string | null {<EOL>    let name = type['<STR_LIT>'];<EOL>    switch (name) {<EOL>        <EOL>        <EOL>        case '<STR_LIT>':<EOL>            return ELEMENT_IF;<EOL>        case '<STR_LIT>':<EOL>            return","gt":"HTMLELEMENT_IF;"}
{"input":"<s> function extractName(type: Function): string | null {<EOL>    let name = type['<STR_LIT>'];<EOL>    switch (name) {<EOL>        <EOL>        <EOL>        case '<STR_LIT>':<EOL>            return ELEMENT_IF;<EOL>        case '<STR_LIT>':<EOL>            return HTMLELEMENT_IF;<EOL>        case '<STR_LIT>':<EOL>            return '<STR_LIT>';<EOL>        case '<STR_LIT>':<EOL>","gt":"return '<STR_LIT>';"}
{"input":"<s> function extractName(type: Function): string | null {<EOL>    let name = type['<STR_LIT>'];<EOL>    switch (name) {<EOL>        <EOL>        <EOL>        case '<STR_LIT>':<EOL>            return ELEMENT_IF;<EOL>        case '<STR_LIT>':<EOL>            return HTMLELEMENT_IF;<EOL>        case '<STR_LIT>':<EOL>            return '<STR_LIT>';<EOL>        case '<STR_LIT>':<EOL>            return '<STR_LIT>';<EOL>        case '<STR_LIT>':<EOL>            return '<STR_LIT>';<EOL>        case '<STR_LIT>':<EOL>            return '<STR_LIT>';<EOL>        case '<STR_LIT>':<EOL>            return '<STR_LIT>';<EOL>","gt":"case '<STR_LIT>':"}
{"input":"<s> function extractName(type: Function): string | null {<EOL>    let name = type['<STR_LIT>'];<EOL>    switch (name) {<EOL>        <EOL>        <EOL>        case '<STR_LIT>':<EOL>            return ELEMENT_IF;<EOL>        case '<STR_LIT>':<EOL>            return HTMLELEMENT_IF;<EOL>        case '<STR_LIT>':<EOL>            return '<STR_LIT>';<EOL>        case '<STR_LIT>':<EOL>            return '<STR_LIT>';<EOL>        case '<STR_LIT>':<EOL>            return '<STR_LIT>';<EOL>        case '<STR_LIT>':<EOL>            return '<STR_LIT>';<EOL>        case '<STR_LIT>':<EOL>            return '<STR_LIT>';<EOL>        case '<STR_LIT>':<EOL>            return '<STR_LIT>';<EOL>        case '<STR_LIT>':<EOL>            return '<STR_LIT>';<EOL>        case '<STR_LIT>':<EOL>            return '<STR_LIT>';<EOL>","gt":"case '<STR_LIT>':"}
{"input":"<s> function extractName(type: Function): string | null {<EOL>    let name = type['<STR_LIT>'];<EOL>    switch (name) {<EOL>        <EOL>        <EOL>        case '<STR_LIT>':<EOL>            return ELEMENT_IF;<EOL>        case '<STR_LIT>':<EOL>            return HTMLELEMENT_IF;<EOL>        case '<STR_LIT>':<EOL>            return '<STR_LIT>';<EOL>        case '<STR_LIT>':<EOL>            return '<STR_LIT>';<EOL>        case '<STR_LIT>':<EOL>            return '<STR_LIT>';<EOL>        case '<STR_LIT>':<EOL>            return '<STR_LIT>';<EOL>        case '<STR_LIT>':<EOL>            return '<STR_LIT>';<EOL>        case '<STR_LIT>':<EOL>            return '<STR_LIT>';<EOL>        case '<STR_LIT>':<EOL>            return '<STR_LIT>';<EOL>        case '<STR_LIT>':<EOL>            return '<STR_LIT>';<EOL>        case '<STR_LIT>':<EOL>            return '<STR_LIT>';<EOL>        case '<STR_LIT>':<EOL>            return '<STR_LIT>';<EOL>        case '<STR_LIT>':<EOL>            return '<STR_LIT>';<EOL>        case '<STR_LIT>':<EOL>            return","gt":"'<STR_LIT>';"}
{"input":"<s> function extractName(type: Function): string | null {<EOL>    let name = type['<STR_LIT>'];<EOL>    switch (name) {<EOL>        <EOL>        <EOL>        case '<STR_LIT>':<EOL>            return ELEMENT_IF;<EOL>        case '<STR_LIT>':<EOL>            return HTMLELEMENT_IF;<EOL>        case '<STR_LIT>':<EOL>            return '<STR_LIT>';<EOL>        case '<STR_LIT>':<EOL>            return '<STR_LIT>';<EOL>        case '<STR_LIT>':<EOL>            return '<STR_LIT>';<EOL>        case '<STR_LIT>':<EOL>            return '<STR_LIT>';<EOL>        case '<STR_LIT>':<EOL>            return '<STR_LIT>';<EOL>        case '<STR_LIT>':<EOL>            return '<STR_LIT>';<EOL>        case '<STR_LIT>':<EOL>            return '<STR_LIT>';<EOL>        case '<STR_LIT>':<EOL>            return '<STR_LIT>';<EOL>        case '<STR_LIT>':<EOL>            return '<STR_LIT>';<EOL>        case '<STR_LIT>':<EOL>            return '<STR_LIT>';<EOL>        case '<STR_LIT>':<EOL>            return '<STR_LIT>';<EOL>        case '<STR_LIT>':<EOL>            return '<STR_LIT>';<EOL>        case '<STR_LIT>':<EOL>            return '<STR_LIT>';<EOL>        case '<STR_LIT>':<EOL>            return","gt":"'<STR_LIT>';"}
{"input":"<s> function extractName(type: Function): string | null {<EOL>    let name = type['<STR_LIT>'];<EOL>    switch (name) {<EOL>        <EOL>        <EOL>        case '<STR_LIT>':<EOL>            return ELEMENT_IF;<EOL>        case '<STR_LIT>':<EOL>            return HTMLELEMENT_IF;<EOL>        case '<STR_LIT>':<EOL>            return '<STR_LIT>';<EOL>        case '<STR_LIT>':<EOL>            return '<STR_LIT>';<EOL>        case '<STR_LIT>':<EOL>            return '<STR_LIT>';<EOL>        case '<STR_LIT>':<EOL>            return '<STR_LIT>';<EOL>        case '<STR_LIT>':<EOL>            return '<STR_LIT>';<EOL>        case '<STR_LIT>':<EOL>            return '<STR_LIT>';<EOL>        case '<STR_LIT>':<EOL>            return '<STR_LIT>';<EOL>        case '<STR_LIT>':<EOL>            return '<STR_LIT>';<EOL>        case '<STR_LIT>':<EOL>            return '<STR_LIT>';<EOL>        case '<STR_LIT>':<EOL>            return '<STR_LIT>';<EOL>        case '<STR_LIT>':<EOL>            return '<STR_LIT>';<EOL>        case '<STR_LIT>':<EOL>            return '<STR_LIT>';<EOL>        case '<STR_LIT>':<EOL>            return '<STR_LIT>';<EOL>        case '<STR_LIT>':<EOL>            return '<STR_LIT>';<EOL>        case '<STR_LIT>':<EOL>","gt":"return '<STR_LIT>';"}
{"input":"<s> function extractName(type: Function): string | null {<EOL>    let name = type['<STR_LIT>'];<EOL>    switch (name) {<EOL>        <EOL>        <EOL>        case '<STR_LIT>':<EOL>            return ELEMENT_IF;<EOL>        case '<STR_LIT>':<EOL>            return HTMLELEMENT_IF;<EOL>        case '<STR_LIT>':<EOL>            return '<STR_LIT>';<EOL>        case '<STR_LIT>':<EOL>            return '<STR_LIT>';<EOL>        case '<STR_LIT>':<EOL>            return '<STR_LIT>';<EOL>        case '<STR_LIT>':<EOL>            return '<STR_LIT>';<EOL>        case '<STR_LIT>':<EOL>            return '<STR_LIT>';<EOL>        case '<STR_LIT>':<EOL>            return '<STR_LIT>';<EOL>        case '<STR_LIT>':<EOL>            return '<STR_LIT>';<EOL>        case '<STR_LIT>':<EOL>            return '<STR_LIT>';<EOL>        case '<STR_LIT>':<EOL>            return '<STR_LIT>';<EOL>        case '<STR_LIT>':<EOL>            return '<STR_LIT>';<EOL>        case '<STR_LIT>':<EOL>            return '<STR_LIT>';<EOL>        case '<STR_LIT>':<EOL>            return '<STR_LIT>';<EOL>        case '<STR_LIT>':<EOL>            return '<STR_LIT>';<EOL>        case '<STR_LIT>':<EOL>            return '<STR_LIT>';<EOL>        case '<STR_LIT>':<EOL>            return '<STR_LIT>';<EOL>        case '<STR_LIT>':<EOL>            return SVG_PREFIX + '<STR_LIT>';<EOL>        case '<STR_LIT>':<EOL>            return SVG_PREFIX + '<STR_LIT>';<EOL>        case '<STR_LIT>':<EOL>            return SVG_PREFIX + '<STR_LIT>';<EOL>        case","gt":"'<STR_LIT>':"}
{"input":"<s> function extractName(type: Function): string | null {<EOL>    let name = type['<STR_LIT>'];<EOL>    switch (name) {<EOL>        <EOL>        <EOL>        case '<STR_LIT>':<EOL>            return ELEMENT_IF;<EOL>        case '<STR_LIT>':<EOL>            return HTMLELEMENT_IF;<EOL>        case '<STR_LIT>':<EOL>            return '<STR_LIT>';<EOL>        case '<STR_LIT>':<EOL>            return '<STR_LIT>';<EOL>        case '<STR_LIT>':<EOL>            return '<STR_LIT>';<EOL>        case '<STR_LIT>':<EOL>            return '<STR_LIT>';<EOL>        case '<STR_LIT>':<EOL>            return '<STR_LIT>';<EOL>        case '<STR_LIT>':<EOL>            return '<STR_LIT>';<EOL>        case '<STR_LIT>':<EOL>            return '<STR_LIT>';<EOL>        case '<STR_LIT>':<EOL>            return '<STR_LIT>';<EOL>        case '<STR_LIT>':<EOL>            return '<STR_LIT>';<EOL>        case '<STR_LIT>':<EOL>            return '<STR_LIT>';<EOL>        case '<STR_LIT>':<EOL>            return '<STR_LIT>';<EOL>        case '<STR_LIT>':<EOL>            return '<STR_LIT>';<EOL>        case '<STR_LIT>':<EOL>            return '<STR_LIT>';<EOL>        case '<STR_LIT>':<EOL>            return '<STR_LIT>';<EOL>        case '<STR_LIT>':<EOL>            return '<STR_LIT>';<EOL>        case '<STR_LIT>':<EOL>            return SVG_PREFIX + '<STR_LIT>';<EOL>        case '<STR_LIT>':<EOL>            return SVG_PREFIX + '<STR_LIT>';<EOL>        case '<STR_LIT>':<EOL>            return SVG_PREFIX + '<STR_LIT>';<EOL>        case '<STR_LIT>':<EOL>            return SVG_PREFIX + '<STR_LIT>';<EOL>        default:<EOL>            const isSVG = name.startsWith('<STR_LIT>');<EOL>            if (name.startsWith('<STR_LIT>') || isSVG) {<EOL>                name =","gt":"name.replace('<STR_LIT>', '<STR_LIT>').replace('<STR_LIT>', '<STR_LIT>').replace('<STR_LIT>', '<STR_LIT>');"}
{"input":"<s> export function convertSimple2RegExpPattern(pattern: string): string {<EOL>    return pattern.replace(/[\\-\\\\\\{\\}\\+\\?\\|\\^\\$\\.\\,\\[\\]\\(\\)\\#\\s]/g, '<STR_LIT>').replace(","gt":"/[\\*]/g, '<STR_LIT>');"}
{"input":"<s> export function stripGeneratedFileSuffix(filePath: string): string {<EOL>    return filePath.replace(GENERATED_FILE,","gt":"'<STR_LIT>');"}
{"input":"<s> function shrink(span: Span, offset?: number) {<EOL>    if (offset ==","gt":"null)"}
{"input":"<s> export function digest(message: i18n.Message): string {<EOL>    return message.id || sha1(serializeNodes(message.","gt":"nodes).join('<STR_LIT>') + `<STR_LIT>`);"}
{"input":"<s> function getPerformanceImpl(): Performance {<EOL>    const g = typeof global !== '<STR_LIT>' ? global : undefined;<EOL>    const w = typeof window !== '<STR_LIT>' ? window : undefined;<EOL>    const { performance } = (g || w || {}) as any;<EOL>    if (performance &&","gt":"performance.mark && performance.measure) {"}
{"input":"<s> function getPerformanceImpl(): Performance {<EOL>    const g = typeof global !== '<STR_LIT>' ? global : undefined;<EOL>    const w = typeof window !== '<STR_LIT>' ? window : undefined;<EOL>    const { performance } = (g || w || {}) as any;<EOL>    if (performance && performance.mark && performance.measure) {<EOL>        return performance;<EOL>    }<EOL>    return {<EOL>        mark:","gt":"_.noop,"}
{"input":"<s> function testLStaticData(tagName: string, attrs: string[] | null): TNode {<EOL>    return {<EOL>        tagName,<EOL>","gt":"attrs,"}
{"input":"<s> export function merge(base: any, add: any, overwrite: boolean): void {<EOL>    Object.keys(add).forEach(key => {<EOL>        if (key in base) {<EOL>            if (types.isObject(base[key]) && types.isObject(add[key])) {<EOL>                merge(base[","gt":"key], add[key], overwrite);"}
{"input":"<s> export function merge(base: any, add: any, overwrite: boolean): void {<EOL>    Object.keys(add).forEach(key => {<EOL>        if (key in base) {<EOL>            if (types.isObject(base[key]) && types.isObject(add[key])) {<EOL>                merge(base[key], add[key], overwrite);<EOL>            }<EOL>            else if (overwrite) {<EOL>                base[key] = add[key];<EOL>            }<EOL>        }<EOL>","gt":"else {"}
{"input":"<s> <EOL>function toPercent(parsedNumber: ParsedNumber): ParsedNumber {<EOL>    <EOL>    if (parsedNumber.digits[<NUM_LIT>] === <NUM_LIT>) {<EOL>        return parsedNumber;<EOL>    }<EOL>    <EOL>    const fractionLen = parsedNumber.digits.","gt":"length - parsedNumber.integerLen;"}
{"input":"<s> <EOL>function toPercent(parsedNumber: ParsedNumber): ParsedNumber {<EOL>    <EOL>    if (parsedNumber.digits[<NUM_LIT>] === <NUM_LIT>) {<EOL>        return parsedNumber;<EOL>    }<EOL>    <EOL>    const fractionLen = parsedNumber.digits.length - parsedNumber.integerLen;<EOL>    if (parsedNumber.exponent) {<EOL>        parsedNumber.exponent += <NUM_LIT>;<EOL>    }<EOL>    else {<EOL>","gt":"if (fractionLen === <NUM_LIT>) {"}
{"input":"<s> <EOL>function toPercent(parsedNumber: ParsedNumber): ParsedNumber {<EOL>    <EOL>    if (parsedNumber.digits[<NUM_LIT>] === <NUM_LIT>) {<EOL>        return parsedNumber;<EOL>    }<EOL>    <EOL>    const fractionLen = parsedNumber.digits.length - parsedNumber.integerLen;<EOL>    if (parsedNumber.exponent) {<EOL>        parsedNumber.exponent += <NUM_LIT>;<EOL>    }<EOL>    else {<EOL>        if (fractionLen === <NUM_LIT>) {<EOL>            parsedNumber.digits.push(<NUM_LIT>, <NUM_LIT>);<EOL>        }<EOL>        else if (fractionLen === <NUM_LIT>) {<EOL>            parsedNumber.digits.","gt":"push(<NUM_LIT>);"}
{"input":"<s> export function done<T>(promise: Promise<T>): Promise<void> {<EOL>    return promise.then<void>(() => void <NUM_LIT>, () => void","gt":"<NUM_LIT>);"}
{"input":"<s> function tokenizeWithoutErrors(input: string, tokenizeExpansionForms: boolean = false, interpolationConfig?: InterpolationConfig): lex.Token[] {<EOL>    const tokenizeResult = lex.tokenize(input, '<STR_LIT>', getHtmlTagDefinition, tokenizeExpansionForms, interpolationConfig);<EOL>    if (","gt":"tokenizeResult.errors.length > <NUM_LIT>) {"}
{"input":"<s> function isSignatureCheck(statement: Statement) {<EOL>    return (statement.type === \"<STR_LIT>\" ||<EOL>        (","gt":"statement.type === \"<STR_LIT>\" &&"}
{"input":"<s> /**<EOL> * @license<EOL> * Copyright Google Inc. All Rights Reserved.<EOL> *<EOL> * Use of this source code is governed by an MIT-style license that can be<EOL> * found in the LICENSE file at https://angular.io/license<EOL> */<EOL><EOL><EOL>function plural(n: number): number {<EOL>    return","gt":"<NUM_LIT>;"}
{"input":"<s> /** Creates files necessary for a secondary entry-point. */<EOL>function createFilesForSecondaryEntryPoint(buildPackage: BuildPackage, releasePath: string) {<EOL>    const { name } = buildPackage;<EOL>    const packageOut = buildPackage.outputDir;<EOL>    buildPackage.secondaryEntryPoints.forEach(entryPointName => {<EOL>        <EOL>        <EOL>        <EOL>        <EOL>        const entryPointDir = join(releasePath, entryPointName);<EOL>        const importAsName = `<STR_LIT>`;<EOL>        mkdirpSync(entryPointDir);<EOL>        createEntryPointPackageJson(entryPointDir, name, entryPointName);<EOL>        <EOL>        copyFiles(join(packageOut, entryPointName), '<STR_LIT>', join(entryPointDir, '<STR_LIT>'));<EOL>        <EOL>        <EOL>        createTypingsReexportFile(entryPointDir, `<STR_LIT>`, '<STR_LIT>');<EOL>        createMetadataReexportFile(entryPointDir, `<STR_LIT>`, '<STR_LIT>',","gt":"importAsName);"}
{"input":"<s> <EOL>export function getWinnerFromBoard(board: Rows): string {<EOL>    const allWinningLists = [].concat(board, <EOL>","gt":"zip(board),"}
{"input":"<s> /** Copies the stylesheets for secondary entry-points that generate one to the release output. */<EOL>function copySecondaryEntryPointStylesheets(buildPackage: BuildPackage, releasePath: string) {<EOL>    buildPackage.secondaryEntryPoints.forEach(entryPointName => {<EOL>        const entryPointDir = join(","gt":"buildPackage.outputDir, entryPointName);"}
{"input":"<s> export function testPrefixClasses(content: string) {<EOL>    const exportVarSetter = /(?:export )?(?:var|const)\\s+(\\S+)\\s*=\\s*/;<EOL>    const multiLineComment = /\\s*(?:\\/\\*[\\s\\S]*?\\*\\/)?\\s*/;<EOL>    const newLine = /\\s*\\r?\\n\\s*/;<EOL>","gt":"const regexes = ["}
{"input":"<s> export function testPrefixClasses(content: string) {<EOL>    const exportVarSetter = /(?:export )?(?:var|const)\\s+(\\S+)\\s*=\\s*/;<EOL>    const multiLineComment = /\\s*(?:\\/\\*[\\s\\S]*?\\*\\/)?\\s*/;<EOL>    const newLine = /\\s*\\r?\\n\\s*/;<EOL>    const regexes = [<EOL>        [<EOL>            /^/,<EOL>            exportVarSetter,","gt":"multiLineComment,"}
{"input":"<s> export function testPrefixClasses(content: string) {<EOL>    const exportVarSetter = /(?:export )?(?:var|const)\\s+(\\S+)\\s*=\\s*/;<EOL>    const multiLineComment = /\\s*(?:\\/\\*[\\s\\S]*?\\*\\/)?\\s*/;<EOL>    const newLine = /\\s*\\r?\\n\\s*/;<EOL>    const regexes = [<EOL>        [<EOL>            /^/,<EOL>            exportVarSetter, multiLineComment,<EOL>            /\\(/, multiLineComment,<EOL>            /\\s*function \\(\\) {/, newLine,<EOL>            multiLineComment,<EOL>            /function \\1\\([^\\)]*\\) \\{/, newLine,<EOL>        ],<EOL>        [<EOL>            /^/,<EOL>            exportVarSetter, multiLineComment,<EOL>","gt":"/\\(/, multiLineComment,"}
{"input":"<s> function trimLongName(name: string): string {<EOL>    if (name && name.length > <NUM_LIT>) {<EOL>        return","gt":"<NUM_LIT>, <NUM_LIT>)}...`<STR_LIT>;"}
{"input":"<s> function tickAndDetect(fixture: ComponentFixture<any>) {<EOL>","gt":"tick();"}
{"input":"<s> function add32to64(a: number, b: number): [<EOL>    number,<EOL>    number<EOL>] {<EOL>    const low = (a & <NUM_LIT>) + (","gt":"b & <NUM_LIT>);"}
{"input":"<s> /**<EOL> * Set the {@link GetTestability} implementation used by the Angular testing framework.<EOL> * @experimental<EOL> */<EOL>export function setTestabilityGetter(getter: GetTestability): void {<EOL>","gt":"_testabilityGetter = getter;"}
{"input":"<s> function foo(): any {<EOL>    var","gt":"a;"}
{"input":"<s> function f<T>(a: T) {<EOL>","gt":"x = a;"}
{"input":"<s> export function createTypeSignature(inputs: Type[], output: Type): TypeSignature {<EOL>    return {<EOL>","gt":"type: \"<STR_LIT>\","}
{"input":"<s> export default function nextId(id?: string) {<EOL>    return id !== undefined ? `<STR_LIT>` :","gt":"'<STR_LIT>';"}
{"input":"<s> export function startPlayback(payload: StartPlaybackPayload) {<EOL>    return (dispatch: Dispatch<any>) => {<EOL>        dispatch(","gt":"DagHistoryActions.jumpToState(payload.stateId));"}
{"input":"<s> function shouldUseVstsNuGetPush(isInternalFeed: boolean, conflictsAllowed: boolean, nugetExePath: string): boolean {<EOL>    if (tl.osType() !== '<STR_LIT>') {<EOL>        tl.debug('<STR_LIT>');<EOL>        if (conflictsAllowed) {<EOL>","gt":"tl.warning(tl.loc(\"<STR_LIT>\"));"}
{"input":"<s> function shouldUseVstsNuGetPush(isInternalFeed: boolean, conflictsAllowed: boolean, nugetExePath: string): boolean {<EOL>    if (tl.osType() !== '<STR_LIT>') {<EOL>        tl.debug('<STR_LIT>');<EOL>        if (conflictsAllowed) {<EOL>            tl.warning(tl.loc(\"<STR_LIT>\"));<EOL>        }<EOL>","gt":"return false;"}
{"input":"<s> function shouldUseVstsNuGetPush(isInternalFeed: boolean, conflictsAllowed: boolean, nugetExePath: string): boolean {<EOL>    if (tl.osType() !== '<STR_LIT>') {<EOL>        tl.debug('<STR_LIT>');<EOL>        if (conflictsAllowed) {<EOL>            tl.warning(tl.loc(\"<STR_LIT>\"));<EOL>        }<EOL>        return false;<EOL>    }<EOL>","gt":"if (!isInternalFeed) {"}
{"input":"<s> function shouldUseVstsNuGetPush(isInternalFeed: boolean, conflictsAllowed: boolean, nugetExePath: string): boolean {<EOL>    if (tl.osType() !== '<STR_LIT>') {<EOL>        tl.debug('<STR_LIT>');<EOL>        if (conflictsAllowed) {<EOL>            tl.warning(tl.loc(\"<STR_LIT>\"));<EOL>        }<EOL>        return false;<EOL>    }<EOL>    if (!isInternalFeed) {<EOL>        tl.debug('<STR_LIT>');<EOL>        return false;<EOL>    }<EOL>    if (commandHelper.isOnPremisesTfs()) {<EOL>        tl.debug('<STR_LIT>');<EOL>","gt":"if (conflictsAllowed) {"}
{"input":"<s> function shouldUseVstsNuGetPush(isInternalFeed: boolean, conflictsAllowed: boolean, nugetExePath: string): boolean {<EOL>    if (tl.osType() !== '<STR_LIT>') {<EOL>        tl.debug('<STR_LIT>');<EOL>        if (conflictsAllowed) {<EOL>            tl.warning(tl.loc(\"<STR_LIT>\"));<EOL>        }<EOL>        return false;<EOL>    }<EOL>    if (!isInternalFeed) {<EOL>        tl.debug('<STR_LIT>');<EOL>        return false;<EOL>    }<EOL>    if (commandHelper.isOnPremisesTfs()) {<EOL>        tl.debug('<STR_LIT>');<EOL>        if (conflictsAllowed) {<EOL>            tl.warning(tl.loc(\"<STR_LIT>\"));<EOL>        }<EOL>        return false;<EOL>    }<EOL>    const nugetOverrideFlag = tl.getVariable(\"<STR_LIT>\");<EOL>    if (nugetOverrideFlag === \"<STR_LIT>\") {<EOL>        tl.debug(\"<STR_LIT>\");<EOL>        if (conflictsAllowed) {<EOL>            tl.warning(tl.loc(\"<STR_LIT>\"));<EOL>        }<EOL>        return false;<EOL>    }<EOL>    if (nugetOverrideFlag === \"<STR_LIT>\") {<EOL>        tl.debug(\"<STR_LIT>\");<EOL>        return true;<EOL>    }<EOL>    const vstsNuGetPushOverrideFlag = tl.getVariable(\"<STR_LIT>\");<EOL>    if (vstsNuGetPushOverrideFlag === \"<STR_LIT>\") {<EOL>","gt":"tl.debug(\"<STR_LIT>\");"}
{"input":"<s> function shouldUseVstsNuGetPush(isInternalFeed: boolean, conflictsAllowed: boolean, nugetExePath: string): boolean {<EOL>    if (tl.osType() !== '<STR_LIT>') {<EOL>        tl.debug('<STR_LIT>');<EOL>        if (conflictsAllowed) {<EOL>            tl.warning(tl.loc(\"<STR_LIT>\"));<EOL>        }<EOL>        return false;<EOL>    }<EOL>    if (!isInternalFeed) {<EOL>        tl.debug('<STR_LIT>');<EOL>        return false;<EOL>    }<EOL>    if (commandHelper.isOnPremisesTfs()) {<EOL>        tl.debug('<STR_LIT>');<EOL>        if (conflictsAllowed) {<EOL>            tl.warning(tl.loc(\"<STR_LIT>\"));<EOL>        }<EOL>        return false;<EOL>    }<EOL>    const nugetOverrideFlag = tl.getVariable(\"<STR_LIT>\");<EOL>    if (nugetOverrideFlag === \"<STR_LIT>\") {<EOL>        tl.debug(\"<STR_LIT>\");<EOL>        if (conflictsAllowed) {<EOL>            tl.warning(tl.loc(\"<STR_LIT>\"));<EOL>        }<EOL>        return false;<EOL>    }<EOL>    if (nugetOverrideFlag === \"<STR_LIT>\") {<EOL>        tl.debug(\"<STR_LIT>\");<EOL>        return true;<EOL>    }<EOL>    const vstsNuGetPushOverrideFlag = tl.getVariable(\"<STR_LIT>\");<EOL>    if (vstsNuGetPushOverrideFlag === \"<STR_LIT>\") {<EOL>        tl.debug(\"<STR_LIT>\");<EOL>        return true;<EOL>    }<EOL>    if (","gt":"vstsNuGetPushOverrideFlag === \"<STR_LIT>\") {"}
{"input":"<s> export function __createInputTransfer() {<EOL>    const $inputs = __getInputValues();<EOL>","gt":"return function restoreInputValues() {"}
{"input":"<s> export function InsertModeExecute(key: string, editor: IEditor) {<EOL>    editor.InsertCharactorAtCurrentPosition(","gt":"key);"}
{"input":"<s> export function GetCharClass(charCode: number): CharGroup {<EOL>    if (charCode <= <NUM_LIT>) {<EOL>        <EOL>        return CharGroup.","gt":"Spaces;"}
{"input":"<s> export function GetCharClass(charCode: number): CharGroup {<EOL>    if (charCode <= <NUM_LIT>) {<EOL>        <EOL>        return CharGroup.Spaces;<EOL>    }<EOL>    if (charCode <= <NUM_LIT>) {<EOL>        <EOL>        return CharGroup.Marks;<EOL>    }<EOL>    if (charCode <= <NUM_LIT>) {<EOL>        <EOL>        return CharGroup.AlphabetAndNumber;<EOL>    }<EOL>    if (","gt":"charCode <= <NUM_LIT>) {"}
{"input":"<s> export function GetCharClass(charCode: number): CharGroup {<EOL>    if (charCode <= <NUM_LIT>) {<EOL>        <EOL>        return CharGroup.Spaces;<EOL>    }<EOL>    if (charCode <= <NUM_LIT>) {<EOL>        <EOL>        return CharGroup.Marks;<EOL>    }<EOL>    if (charCode <= <NUM_LIT>) {<EOL>        <EOL>        return CharGroup.AlphabetAndNumber;<EOL>    }<EOL>    if (charCode <= <NUM_LIT>) {<EOL>        <EOL>        return CharGroup.Marks;<EOL>    }<EOL>    if (charCode <= <NUM_LIT>) {<EOL>        <EOL>        return CharGroup.AlphabetAndNumber;<EOL>    }<EOL>    if (charCode <= <NUM_LIT>) {<EOL>        <EOL>        return CharGroup.Marks;<EOL>    }<EOL>    if (charCode === <NUM_LIT>) {<EOL>        <EOL>        return","gt":"CharGroup.AlphabetAndNumber;"}
{"input":"<s> export function GetCharClass(charCode: number): CharGroup {<EOL>    if (charCode <= <NUM_LIT>) {<EOL>        <EOL>        return CharGroup.Spaces;<EOL>    }<EOL>    if (charCode <= <NUM_LIT>) {<EOL>        <EOL>        return CharGroup.Marks;<EOL>    }<EOL>    if (charCode <= <NUM_LIT>) {<EOL>        <EOL>        return CharGroup.AlphabetAndNumber;<EOL>    }<EOL>    if (charCode <= <NUM_LIT>) {<EOL>        <EOL>        return CharGroup.Marks;<EOL>    }<EOL>    if (charCode <= <NUM_LIT>) {<EOL>        <EOL>        return CharGroup.AlphabetAndNumber;<EOL>    }<EOL>    if (charCode <= <NUM_LIT>) {<EOL>        <EOL>        return CharGroup.Marks;<EOL>    }<EOL>    if (charCode === <NUM_LIT>) {<EOL>        <EOL>        return CharGroup.AlphabetAndNumber;<EOL>    }<EOL>    if (charCode === <NUM_LIT>) {<EOL>        <EOL>        return CharGroup.Marks;<EOL>    }<EOL>    if (charCode <= <NUM_LIT>) {<EOL>        <EOL>        return","gt":"CharGroup.AlphabetAndNumber;"}
{"input":"<s> export function GetCharClass(charCode: number): CharGroup {<EOL>    if (charCode <= <NUM_LIT>) {<EOL>        <EOL>        return CharGroup.Spaces;<EOL>    }<EOL>    if (charCode <= <NUM_LIT>) {<EOL>        <EOL>        return CharGroup.Marks;<EOL>    }<EOL>    if (charCode <= <NUM_LIT>) {<EOL>        <EOL>        return CharGroup.AlphabetAndNumber;<EOL>    }<EOL>    if (charCode <= <NUM_LIT>) {<EOL>        <EOL>        return CharGroup.Marks;<EOL>    }<EOL>    if (charCode <= <NUM_LIT>) {<EOL>        <EOL>        return CharGroup.AlphabetAndNumber;<EOL>    }<EOL>    if (charCode <= <NUM_LIT>) {<EOL>        <EOL>        return CharGroup.Marks;<EOL>    }<EOL>    if (charCode === <NUM_LIT>) {<EOL>        <EOL>        return CharGroup.AlphabetAndNumber;<EOL>    }<EOL>    if (charCode === <NUM_LIT>) {<EOL>        <EOL>        return CharGroup.Marks;<EOL>    }<EOL>    if (charCode <= <NUM_LIT>) {<EOL>        <EOL>        return CharGroup.AlphabetAndNumber;<EOL>    }<EOL>    if (charCode <= <NUM_LIT>) {<EOL>        <EOL>","gt":"return CharGroup.Marks;"}
{"input":"<s> export function GetCharClass(charCode: number): CharGroup {<EOL>    if (charCode <= <NUM_LIT>) {<EOL>        <EOL>        return CharGroup.Spaces;<EOL>    }<EOL>    if (charCode <= <NUM_LIT>) {<EOL>        <EOL>        return CharGroup.Marks;<EOL>    }<EOL>    if (charCode <= <NUM_LIT>) {<EOL>        <EOL>        return CharGroup.AlphabetAndNumber;<EOL>    }<EOL>    if (charCode <= <NUM_LIT>) {<EOL>        <EOL>        return CharGroup.Marks;<EOL>    }<EOL>    if (charCode <= <NUM_LIT>) {<EOL>        <EOL>        return CharGroup.AlphabetAndNumber;<EOL>    }<EOL>    if (charCode <= <NUM_LIT>) {<EOL>        <EOL>        return CharGroup.Marks;<EOL>    }<EOL>    if (charCode === <NUM_LIT>) {<EOL>        <EOL>        return CharGroup.AlphabetAndNumber;<EOL>    }<EOL>    if (charCode === <NUM_LIT>) {<EOL>        <EOL>        return CharGroup.Marks;<EOL>    }<EOL>    if (charCode <= <NUM_LIT>) {<EOL>        <EOL>        return CharGroup.AlphabetAndNumber;<EOL>    }<EOL>    if (charCode <= <NUM_LIT>) {<EOL>        <EOL>        return CharGroup.Marks;<EOL>    }<EOL>    if (charCode ===","gt":"<NUM_LIT>) {"}
{"input":"<s> export function GetCharClass(charCode: number): CharGroup {<EOL>    if (charCode <= <NUM_LIT>) {<EOL>        <EOL>        return CharGroup.Spaces;<EOL>    }<EOL>    if (charCode <= <NUM_LIT>) {<EOL>        <EOL>        return CharGroup.Marks;<EOL>    }<EOL>    if (charCode <= <NUM_LIT>) {<EOL>        <EOL>        return CharGroup.AlphabetAndNumber;<EOL>    }<EOL>    if (charCode <= <NUM_LIT>) {<EOL>        <EOL>        return CharGroup.Marks;<EOL>    }<EOL>    if (charCode <= <NUM_LIT>) {<EOL>        <EOL>        return CharGroup.AlphabetAndNumber;<EOL>    }<EOL>    if (charCode <= <NUM_LIT>) {<EOL>        <EOL>        return CharGroup.Marks;<EOL>    }<EOL>    if (charCode === <NUM_LIT>) {<EOL>        <EOL>        return CharGroup.AlphabetAndNumber;<EOL>    }<EOL>    if (charCode === <NUM_LIT>) {<EOL>        <EOL>        return CharGroup.Marks;<EOL>    }<EOL>    if (charCode <= <NUM_LIT>) {<EOL>        <EOL>        return CharGroup.AlphabetAndNumber;<EOL>    }<EOL>    if (charCode <= <NUM_LIT>) {<EOL>        <EOL>        return CharGroup.Marks;<EOL>    }<EOL>    if (charCode === <NUM_LIT>) {<EOL>        <EOL>        return CharGroup.Spaces;<EOL>    }<EOL>    if (charCode < <NUM_LIT>) {<EOL>        <EOL>        return CharGroup.Other;<EOL>    }<EOL>    if (","gt":"charCode === <NUM_LIT>) {"}
{"input":"<s> export function GetCharClass(charCode: number): CharGroup {<EOL>    if (charCode <= <NUM_LIT>) {<EOL>        <EOL>        return CharGroup.Spaces;<EOL>    }<EOL>    if (charCode <= <NUM_LIT>) {<EOL>        <EOL>        return CharGroup.Marks;<EOL>    }<EOL>    if (charCode <= <NUM_LIT>) {<EOL>        <EOL>        return CharGroup.AlphabetAndNumber;<EOL>    }<EOL>    if (charCode <= <NUM_LIT>) {<EOL>        <EOL>        return CharGroup.Marks;<EOL>    }<EOL>    if (charCode <= <NUM_LIT>) {<EOL>        <EOL>        return CharGroup.AlphabetAndNumber;<EOL>    }<EOL>    if (charCode <= <NUM_LIT>) {<EOL>        <EOL>        return CharGroup.Marks;<EOL>    }<EOL>    if (charCode === <NUM_LIT>) {<EOL>        <EOL>        return CharGroup.AlphabetAndNumber;<EOL>    }<EOL>    if (charCode === <NUM_LIT>) {<EOL>        <EOL>        return CharGroup.Marks;<EOL>    }<EOL>    if (charCode <= <NUM_LIT>) {<EOL>        <EOL>        return CharGroup.AlphabetAndNumber;<EOL>    }<EOL>    if (charCode <= <NUM_LIT>) {<EOL>        <EOL>        return CharGroup.Marks;<EOL>    }<EOL>    if (charCode === <NUM_LIT>) {<EOL>        <EOL>        return CharGroup.Spaces;<EOL>    }<EOL>    if (charCode < <NUM_LIT>) {<EOL>        <EOL>        return CharGroup.Other;<EOL>    }<EOL>    if (charCode === <NUM_LIT>) {<EOL>        <EOL>        return CharGroup.Spaces;<EOL>    }<EOL>    if (charCode <= <NUM_LIT>) {<EOL>        <EOL>        return CharGroup.Marks;<EOL>    }<EOL>    if (","gt":"charCode <= <NUM_LIT>) {"}
{"input":"<s> function isEventTarget() {<EOL>","gt":"return isBrowser;"}
{"input":"<s> function wordAt(str: string, index: number, endian: Endian): number {<EOL>    let word = <NUM_LIT>;<EOL>    if (endian === Endian.Big) {<EOL>        for (let i = <NUM_LIT>; i < <NUM_LIT>; i++) {<EOL>","gt":"word += byteAt(str, index + i) << (<NUM_LIT> - <NUM_LIT> * i);"}
{"input":"<s> export function Intersect(...intersectees: Runtype[]): any {<EOL>    return create(x => {<EOL>        for (const { check } of","gt":"intersectees)"}
{"input":"<s> <EOL>function isToken(value: any): value is ts.Token<any> {<EOL>    return value != null && typeof value ===","gt":"'<STR_LIT>' && value.kind >= ts.SyntaxKind.FirstToken &&"}
{"input":"<s> function extractCharChangeRepresentation(change: ICharChange, expectedChange: ICharChange): ICharChange {<EOL>    var hasOriginal = expectedChange && expectedChange.originalStartLineNumber > <NUM_LIT>;<EOL>    var hasModified = expectedChange && expectedChange.modifiedStartLineNumber > <NUM_LIT>;<EOL>    return {<EOL>        originalStartLineNumber: hasOriginal ?","gt":"change.originalStartLineNumber : <NUM_LIT>,"}
{"input":"<s> function extractCharChangeRepresentation(change: ICharChange, expectedChange: ICharChange): ICharChange {<EOL>    var hasOriginal = expectedChange && expectedChange.originalStartLineNumber > <NUM_LIT>;<EOL>    var hasModified = expectedChange && expectedChange.modifiedStartLineNumber > <NUM_LIT>;<EOL>    return {<EOL>        originalStartLineNumber: hasOriginal ? change.originalStartLineNumber : <NUM_LIT>,<EOL>        originalStartColumn: hasOriginal ? change.originalStartColumn : <NUM_LIT>,<EOL>        originalEndLineNumber: hasOriginal ? change.originalEndLineNumber : <NUM_LIT>,<EOL>        originalEndColumn: hasOriginal ? change.originalEndColumn : <NUM_LIT>,<EOL>        modifiedStartLineNumber: hasModified ? change.modifiedStartLineNumber : <NUM_LIT>,<EOL>        modifiedStartColumn: hasModified ? change.modifiedStartColumn : <NUM_LIT>,<EOL>","gt":"modifiedEndLineNumber: hasModified ? change.modifiedEndLineNumber : <NUM_LIT>,"}
{"input":"<s> <EOL>export function logOnce(...thingsToLog: any[]) {<EOL>    if (!shouldLog()) {<EOL>","gt":"return;"}
{"input":"<s> /**<EOL> * Parses the command-line arguments, extracting the tsickle settings and<EOL> * the arguments to pass on to tsc.<EOL> */<EOL>function loadSettingsFromArgs(args: string[]): {<EOL>    settings: Settings;<EOL>    tscArgs: string[];<EOL>} {<EOL>    const settings: Settings = {};<EOL>    const parsedArgs = minimist(args);<EOL>    for (const flag of","gt":"Object.keys(parsedArgs)) {"}
{"input":"<s> /**<EOL> * Parses the command-line arguments, extracting the tsickle settings and<EOL> * the arguments to pass on to tsc.<EOL> */<EOL>function loadSettingsFromArgs(args: string[]): {<EOL>    settings: Settings;<EOL>    tscArgs: string[];<EOL>} {<EOL>    const settings: Settings = {};<EOL>    const parsedArgs = minimist(args);<EOL>    for (const flag of Object.keys(parsedArgs)) {<EOL>        switch (flag) {<EOL>            case '<STR_LIT>':<EOL>            case '<STR_LIT>':<EOL>","gt":"usage();"}
{"input":"<s> /**<EOL> * Parses the command-line arguments, extracting the tsickle settings and<EOL> * the arguments to pass on to tsc.<EOL> */<EOL>function loadSettingsFromArgs(args: string[]): {<EOL>    settings: Settings;<EOL>    tscArgs: string[];<EOL>} {<EOL>    const settings: Settings = {};<EOL>    const parsedArgs = minimist(args);<EOL>    for (const flag of Object.keys(parsedArgs)) {<EOL>        switch (flag) {<EOL>            case '<STR_LIT>':<EOL>            case '<STR_LIT>':<EOL>                usage();<EOL>                process.exit(<NUM_LIT>);<EOL>                break;<EOL>            case '<STR_LIT>':<EOL>                settings.externsPath = parsedArgs[","gt":"flag];"}
{"input":"<s> /**<EOL> * Parses the command-line arguments, extracting the tsickle settings and<EOL> * the arguments to pass on to tsc.<EOL> */<EOL>function loadSettingsFromArgs(args: string[]): {<EOL>    settings: Settings;<EOL>    tscArgs: string[];<EOL>} {<EOL>    const settings: Settings = {};<EOL>    const parsedArgs = minimist(args);<EOL>    for (const flag of Object.keys(parsedArgs)) {<EOL>        switch (flag) {<EOL>            case '<STR_LIT>':<EOL>            case '<STR_LIT>':<EOL>                usage();<EOL>                process.exit(<NUM_LIT>);<EOL>                break;<EOL>            case '<STR_LIT>':<EOL>                settings.externsPath = parsedArgs[flag];<EOL>                break;<EOL>            case '<STR_LIT>':<EOL>                settings.isTyped =","gt":"true;"}
{"input":"<s> /**<EOL> * Parses the command-line arguments, extracting the tsickle settings and<EOL> * the arguments to pass on to tsc.<EOL> */<EOL>function loadSettingsFromArgs(args: string[]): {<EOL>    settings: Settings;<EOL>    tscArgs: string[];<EOL>} {<EOL>    const settings: Settings = {};<EOL>    const parsedArgs = minimist(args);<EOL>    for (const flag of Object.keys(parsedArgs)) {<EOL>        switch (flag) {<EOL>            case '<STR_LIT>':<EOL>            case '<STR_LIT>':<EOL>                usage();<EOL>                process.exit(<NUM_LIT>);<EOL>                break;<EOL>            case '<STR_LIT>':<EOL>                settings.externsPath = parsedArgs[flag];<EOL>                break;<EOL>            case '<STR_LIT>':<EOL>                settings.isTyped = true;<EOL>                break;<EOL>            case '<STR_LIT>':<EOL>                settings.verbose =","gt":"true;"}
{"input":"<s> /**<EOL> * Parses the command-line arguments, extracting the tsickle settings and<EOL> * the arguments to pass on to tsc.<EOL> */<EOL>function loadSettingsFromArgs(args: string[]): {<EOL>    settings: Settings;<EOL>    tscArgs: string[];<EOL>} {<EOL>    const settings: Settings = {};<EOL>    const parsedArgs = minimist(args);<EOL>    for (const flag of Object.keys(parsedArgs)) {<EOL>        switch (flag) {<EOL>            case '<STR_LIT>':<EOL>            case '<STR_LIT>':<EOL>                usage();<EOL>                process.exit(<NUM_LIT>);<EOL>                break;<EOL>            case '<STR_LIT>':<EOL>                settings.externsPath = parsedArgs[flag];<EOL>                break;<EOL>            case '<STR_LIT>':<EOL>                settings.isTyped = true;<EOL>                break;<EOL>            case '<STR_LIT>':<EOL>                settings.verbose = true;<EOL>                break;<EOL>            case '<STR_LIT>':<EOL>                settings.disableAutoQuoting = true;<EOL>                break;<EOL>            case '<STR_LIT>':<EOL>                <EOL>","gt":"break;"}
{"input":"<s> <EOL>async function openAttachment(attachment, source, uri) {<EOL>    switch (source) {<EOL>        case ATTACHMENT_SOURCE_LOCAL:<EOL>            try {<EOL>                open(uri);<EOL>            }<EOL>","gt":"catch (err) {"}
{"input":"<s> <EOL>async function openAttachment(attachment, source, uri) {<EOL>    switch (source) {<EOL>        case ATTACHMENT_SOURCE_LOCAL:<EOL>            try {<EOL>                open(uri);<EOL>            }<EOL>            catch (err) {<EOL>                wrapError(err);<EOL>            }<EOL>","gt":"break;"}
{"input":"<s> <EOL>async function openAttachment(attachment, source, uri) {<EOL>    switch (source) {<EOL>        case ATTACHMENT_SOURCE_LOCAL:<EOL>            try {<EOL>                open(uri);<EOL>            }<EOL>            catch (err) {<EOL>                wrapError(err);<EOL>            }<EOL>            break;<EOL>        case ATTACHMENT_SOURCE_SERVER:<EOL>            const resource = await client.getResource(attachment.guid);<EOL>            const fileName = resource.","gt":"attributes.fileName;"}
{"input":"<s> <EOL>async function openAttachment(attachment, source, uri) {<EOL>    switch (source) {<EOL>        case ATTACHMENT_SOURCE_LOCAL:<EOL>            try {<EOL>                open(uri);<EOL>            }<EOL>            catch (err) {<EOL>                wrapError(err);<EOL>            }<EOL>            break;<EOL>        case ATTACHMENT_SOURCE_SERVER:<EOL>            const resource = await client.getResource(attachment.guid);<EOL>            const fileName = resource.attributes.fileName;<EOL>            const data = resource.data.body;<EOL>            try {<EOL>                const isExist = await fs.exsit(","gt":"ATTACHMENT_FOLDER_PATH);"}
{"input":"<s> <EOL>async function openAttachment(attachment, source, uri) {<EOL>    switch (source) {<EOL>        case ATTACHMENT_SOURCE_LOCAL:<EOL>            try {<EOL>                open(uri);<EOL>            }<EOL>            catch (err) {<EOL>                wrapError(err);<EOL>            }<EOL>            break;<EOL>        case ATTACHMENT_SOURCE_SERVER:<EOL>            const resource = await client.getResource(attachment.guid);<EOL>            const fileName = resource.attributes.fileName;<EOL>            const data = resource.data.body;<EOL>            try {<EOL>                const isExist = await fs.exsit(ATTACHMENT_FOLDER_PATH);<EOL>                if (!isExist) {<EOL>                    await fs.mkdirAsync(ATTACHMENT_FOLDER_PATH);<EOL>                }<EOL>                const tmpDir = await fs.mkdtempAsync(path.join(ATTACHMENT_FOLDER_PATH, \"<STR_LIT>\"));<EOL>                const filepath = path.join(tmpDir, fileName);<EOL>                await fs.writeFileAsync(filepath, data);<EOL>","gt":"open(filepath);"}
{"input":"<s> <EOL>async function createNote(meta, content, resources) {<EOL>    try {<EOL>        let tagNames = meta[\"<STR_LIT>\"];<EOL>        let title = meta[\"<STR_LIT>\"];<EOL>        let notebook =","gt":"meta[\"<STR_LIT>\"];"}
{"input":"<s> <EOL>async function createNote(meta, content, resources) {<EOL>    try {<EOL>        let tagNames = meta[\"<STR_LIT>\"];<EOL>        let title = meta[\"<STR_LIT>\"];<EOL>        let notebook = meta[\"<STR_LIT>\"];<EOL>        const notebookGuid = await getNotebookGuid(notebook);<EOL>        return client.createNote(title, notebookGuid, content, tagNames, resources);<EOL>    }<EOL>","gt":"catch (err) {"}
{"input":"<s> function main(args: string[]): number {<EOL>    const { settings, tscArgs } = loadSettingsFromArgs(args);<EOL>    const config = loadTscConfig(tscArgs);<EOL>    if (config.errors.length) {<EOL>        console.error(tsickle.formatDiagnostics(config.errors));<EOL>        return","gt":"<NUM_LIT>;"}
{"input":"<s> function main(args: string[]): number {<EOL>    const { settings, tscArgs } = loadSettingsFromArgs(args);<EOL>    const config = loadTscConfig(tscArgs);<EOL>    if (config.errors.length) {<EOL>        console.error(tsickle.formatDiagnostics(config.errors));<EOL>        return <NUM_LIT>;<EOL>    }<EOL>    if (config.options.module !== ts.ModuleKind.CommonJS) {<EOL>        <EOL>        <EOL>        console.error('<STR_LIT>' +<EOL>            '<STR_LIT>');<EOL>","gt":"return <NUM_LIT>;"}
{"input":"<s> function main(args: string[]): number {<EOL>    const { settings, tscArgs } = loadSettingsFromArgs(args);<EOL>    const config = loadTscConfig(tscArgs);<EOL>    if (config.errors.length) {<EOL>        console.error(tsickle.formatDiagnostics(config.errors));<EOL>        return <NUM_LIT>;<EOL>    }<EOL>    if (config.options.module !== ts.ModuleKind.CommonJS) {<EOL>        <EOL>        <EOL>        console.error('<STR_LIT>' +<EOL>            '<STR_LIT>');<EOL>        return <NUM_LIT>;<EOL>    }<EOL>    <EOL>","gt":"const result = toClosureJS(config.options, config.fileNames, settings, (filePath: string, contents: string) => {"}
{"input":"<s> function main(args: string[]): number {<EOL>    const { settings, tscArgs } = loadSettingsFromArgs(args);<EOL>    const config = loadTscConfig(tscArgs);<EOL>    if (config.errors.length) {<EOL>        console.error(tsickle.formatDiagnostics(config.errors));<EOL>        return <NUM_LIT>;<EOL>    }<EOL>    if (config.options.module !== ts.ModuleKind.CommonJS) {<EOL>        <EOL>        <EOL>        console.error('<STR_LIT>' +<EOL>            '<STR_LIT>');<EOL>        return <NUM_LIT>;<EOL>    }<EOL>    <EOL>    const result = toClosureJS(config.options, config.fileNames, settings, (filePath: string, contents: string) => {<EOL>        mkdirp.sync(path.dirname(filePath));<EOL>        fs.writeFileSync(filePath, contents, { encoding: '<STR_LIT>' });<EOL>    });<EOL>    if (result.diagnostics.length) {<EOL>        console.error(tsickle.formatDiagnostics(result.diagnostics));<EOL>","gt":"return <NUM_LIT>;"}
{"input":"<s> export function unhide() {<EOL>    driver.","gt":"unhide();"}
{"input":"<s> function addEventHandlers() {<EOL>    for (const id of ['<STR_LIT>', '<STR_LIT>']) {<EOL>        const node = document.getElementById(id);<EOL>        if (!node)<EOL>            break;<EOL>        if (reset && (id ===","gt":"'<STR_LIT>')) {"}
{"input":"<s> function addEventHandlers() {<EOL>    for (const id of ['<STR_LIT>', '<STR_LIT>']) {<EOL>        const node = document.getElementById(id);<EOL>        if (!node)<EOL>            break;<EOL>        if (reset && (id === '<STR_LIT>')) {<EOL>            node.checked = false;<EOL>            reset = false;<EOL>            node.setAttribute('<STR_LIT>', Zotero.BetterBibTeX.getString('<STR_LIT>'));<EOL>        }<EOL>        if (node.getAttribute('<STR_LIT>'))<EOL>            return;<EOL>","gt":"debug('<STR_LIT>', id);"}
{"input":"<s> function null2Undefined<T>(value: T | null): T | undefined {<EOL>    if (value === null) {<EOL>        return","gt":"void <NUM_LIT>;"}
{"input":"<s> function tokenExpr(ctx: OutputContext, tokenMeta: CompileTokenMetadata): o.Expression {<EOL>","gt":"return tokenMeta.identifier ? ctx.importExpr(tokenMeta.identifier.reference) :"}
{"input":"<s> /**<EOL> * Determines if fileName refers to a builtin lib.d.ts file.<EOL> * This is a terrible hack but it mirrors a similar thing done in Clutz.<EOL> */<EOL>export function isBuiltinLibDTS(fileName: string): boolean {<EOL>    return fileName.","gt":"match(/\\blib\\.(?:[^/]+\\.)?d\\.ts$/) != null;"}
{"input":"<s> /**<EOL> * .<EOL> */<EOL>export function RepeatLastChange() {<EOL>    return new","gt":"RepeatLastChangeAction();"}
{"input":"<s> function containsSegmentGroupHelper(container: UrlSegmentGroup, containee: UrlSegmentGroup, containeePaths: UrlSegment[]): boolean {<EOL>    if (container.segments.length > containeePaths.length) {<EOL>        const current = container.segments.slice(<NUM_LIT>, containeePaths.length);<EOL>        if (!equalPath(current, containeePaths))<EOL>            return false;<EOL>        if (containee.hasChildren())<EOL>            return","gt":"false;"}
{"input":"<s> function containsSegmentGroupHelper(container: UrlSegmentGroup, containee: UrlSegmentGroup, containeePaths: UrlSegment[]): boolean {<EOL>    if (container.segments.length > containeePaths.length) {<EOL>        const current = container.segments.slice(<NUM_LIT>, containeePaths.length);<EOL>        if (!equalPath(current, containeePaths))<EOL>            return false;<EOL>        if (containee.hasChildren())<EOL>            return false;<EOL>        return true;<EOL>    }<EOL>    else if (container.segments.length ===","gt":"containeePaths.length) {"}
{"input":"<s> function containsSegmentGroupHelper(container: UrlSegmentGroup, containee: UrlSegmentGroup, containeePaths: UrlSegment[]): boolean {<EOL>    if (container.segments.length > containeePaths.length) {<EOL>        const current = container.segments.slice(<NUM_LIT>, containeePaths.length);<EOL>        if (!equalPath(current, containeePaths))<EOL>            return false;<EOL>        if (containee.hasChildren())<EOL>            return false;<EOL>        return true;<EOL>    }<EOL>    else if (container.segments.length === containeePaths.length) {<EOL>        if (!equalPath(container.segments, containeePaths))<EOL>            return false;<EOL>        for (","gt":"const c in containee.children) {"}
{"input":"<s> function containsSegmentGroupHelper(container: UrlSegmentGroup, containee: UrlSegmentGroup, containeePaths: UrlSegment[]): boolean {<EOL>    if (container.segments.length > containeePaths.length) {<EOL>        const current = container.segments.slice(<NUM_LIT>, containeePaths.length);<EOL>        if (!equalPath(current, containeePaths))<EOL>            return false;<EOL>        if (containee.hasChildren())<EOL>            return false;<EOL>        return true;<EOL>    }<EOL>    else if (container.segments.length === containeePaths.length) {<EOL>        if (!equalPath(container.segments, containeePaths))<EOL>            return false;<EOL>        for (const c in containee.children) {<EOL>            if (!container.children[c])<EOL>                return false;<EOL>            if (!containsSegmentGroup(container.children[c], containee.","gt":"children[c]))"}
{"input":"<s> function containsSegmentGroupHelper(container: UrlSegmentGroup, containee: UrlSegmentGroup, containeePaths: UrlSegment[]): boolean {<EOL>    if (container.segments.length > containeePaths.length) {<EOL>        const current = container.segments.slice(<NUM_LIT>, containeePaths.length);<EOL>        if (!equalPath(current, containeePaths))<EOL>            return false;<EOL>        if (containee.hasChildren())<EOL>            return false;<EOL>        return true;<EOL>    }<EOL>    else if (container.segments.length === containeePaths.length) {<EOL>        if (!equalPath(container.segments, containeePaths))<EOL>            return false;<EOL>        for (const c in containee.children) {<EOL>            if (!container.children[c])<EOL>                return false;<EOL>            if (!containsSegmentGroup(container.children[c], containee.children[c]))<EOL>                return false;<EOL>        }<EOL>        return true;<EOL>    }<EOL>    else {<EOL>        const current = containeePaths.slice(<NUM_LIT>, container.segments.length);<EOL>        const next = containeePaths.","gt":"slice(container.segments.length);"}
{"input":"<s> export function createFileSystemPreferences(preferences: PreferenceService): FileSystemPreferences {<EOL>    return createPreferenceProxy(preferences,","gt":"filesystemPreferenceSchema);"}
{"input":"<s> /**<EOL> * Specifies that this property should be treated as an ObjectID, with the requisite validator and transforms.<EOL> *<EOL> * This decorator applies an ObjectID validator to the property, which ensures that values sent to the database<EOL> * are instances of the MongoDB ObjectID type, as well as applying a transform operation which converts ObjectIDs<EOL> * to strings for your application, and then converts strings back to ObjectIDs for the database.<EOL> */<EOL>export function ObjectID(target: Instance<any, any>, name: string) {<EOL>    Property(MongoDB.ObjectID)(","gt":"target, name);"}
{"input":"<s> function needsAdditionalRootNode(astNodes: TemplateAst[]): boolean {<EOL>    const lastAstNode = astNodes[astNodes.length - <NUM_LIT>];<EOL>    if (lastAstNode instanceof EmbeddedTemplateAst) {<EOL>        return lastAstNode.hasViewContainer;<EOL>    }<EOL>    if (lastAstNode instanceof ElementAst) {<EOL>        if (isNgContainer(lastAstNode.name) && lastAstNode.children.length) {<EOL>            return needsAdditionalRootNode(lastAstNode.children);<EOL>        }<EOL>        return","gt":"lastAstNode.hasViewContainer;"}
{"input":"<s> function escapeBlocks(input: string): StringWithEscapedBlocks {<EOL>    const inputParts = input.split(_curlyRe);<EOL>    const resultParts: string[] = [];<EOL>    const","gt":"escapedBlocks: string[] = [];"}
{"input":"<s> function escapeBlocks(input: string): StringWithEscapedBlocks {<EOL>    const inputParts = input.split(_curlyRe);<EOL>    const resultParts: string[] = [];<EOL>    const escapedBlocks: string[] = [];<EOL>    let bracketCount = <NUM_LIT>;<EOL>    let currentBlockParts: string[] = [];<EOL>","gt":"for (let partIndex = <NUM_LIT>; partIndex < inputParts.length; partIndex++) {"}
{"input":"<s> function escapeBlocks(input: string): StringWithEscapedBlocks {<EOL>    const inputParts = input.split(_curlyRe);<EOL>    const resultParts: string[] = [];<EOL>    const escapedBlocks: string[] = [];<EOL>    let bracketCount = <NUM_LIT>;<EOL>    let currentBlockParts: string[] = [];<EOL>    for (let partIndex = <NUM_LIT>; partIndex < inputParts.length; partIndex++) {<EOL>        const part = inputParts[partIndex];<EOL>        if (part == CLOSE_CURLY) {<EOL>            bracketCount--;<EOL>        }<EOL>        if (bracketCount > <NUM_LIT>) {<EOL>            currentBlockParts.push(part);<EOL>        }<EOL>        else {<EOL>            if (currentBlockParts.length > <NUM_LIT>) {<EOL>                escapedBlocks.push(currentBlockParts.join('<STR_LIT>'));<EOL>","gt":"resultParts.push(BLOCK_PLACEHOLDER);"}
{"input":"<s> export function deps(args: string[]) {<EOL>    args.forEach((arg) => {<EOL>        var req = <TDev.DepsRequest>{ script:","gt":"fs.readFileSync(arg, \"<STR_LIT>\") };"}
{"input":"<s> export function checkAndUpdateElementInline(view: ViewData, def: NodeDef, v0: any, v1: any, v2: any, v3: any, v4: any, v5: any, v6: any, v7: any, v8: any, v9: any): boolean {<EOL>    const bindLen = def.bindings.length;<EOL>    let changed = false;<EOL>    if (bindLen > <NUM_LIT> && checkAndUpdateElementValue(view, def, <NUM_LIT>, v0))<EOL>        changed = true;<EOL>    if (bindLen > <NUM_LIT> &&","gt":"checkAndUpdateElementValue(view, def, <NUM_LIT>, v1))"}
{"input":"<s> export function checkAndUpdateElementInline(view: ViewData, def: NodeDef, v0: any, v1: any, v2: any, v3: any, v4: any, v5: any, v6: any, v7: any, v8: any, v9: any): boolean {<EOL>    const bindLen = def.bindings.length;<EOL>    let changed = false;<EOL>    if (bindLen > <NUM_LIT> && checkAndUpdateElementValue(view, def, <NUM_LIT>, v0))<EOL>        changed = true;<EOL>    if (bindLen > <NUM_LIT> && checkAndUpdateElementValue(view, def, <NUM_LIT>, v1))<EOL>        changed = true;<EOL>    if (bindLen > <NUM_LIT> && checkAndUpdateElementValue(view, def, <NUM_LIT>, v2))<EOL>        changed =","gt":"true;"}
{"input":"<s> export function checkAndUpdateElementInline(view: ViewData, def: NodeDef, v0: any, v1: any, v2: any, v3: any, v4: any, v5: any, v6: any, v7: any, v8: any, v9: any): boolean {<EOL>    const bindLen = def.bindings.length;<EOL>    let changed = false;<EOL>    if (bindLen > <NUM_LIT> && checkAndUpdateElementValue(view, def, <NUM_LIT>, v0))<EOL>        changed = true;<EOL>    if (bindLen > <NUM_LIT> && checkAndUpdateElementValue(view, def, <NUM_LIT>, v1))<EOL>        changed = true;<EOL>    if (bindLen > <NUM_LIT> && checkAndUpdateElementValue(view, def, <NUM_LIT>, v2))<EOL>        changed = true;<EOL>    if (bindLen > <NUM_LIT> && checkAndUpdateElementValue(view, def, <NUM_LIT>, v3))<EOL>        changed = true;<EOL>    if (bindLen > <NUM_LIT> && checkAndUpdateElementValue(view, def, <NUM_LIT>, v4))<EOL>        changed = true;<EOL>","gt":"if (bindLen > <NUM_LIT> && checkAndUpdateElementValue(view, def, <NUM_LIT>, v5))"}
{"input":"<s> export function checkAndUpdateElementInline(view: ViewData, def: NodeDef, v0: any, v1: any, v2: any, v3: any, v4: any, v5: any, v6: any, v7: any, v8: any, v9: any): boolean {<EOL>    const bindLen = def.bindings.length;<EOL>    let changed = false;<EOL>    if (bindLen > <NUM_LIT> && checkAndUpdateElementValue(view, def, <NUM_LIT>, v0))<EOL>        changed = true;<EOL>    if (bindLen > <NUM_LIT> && checkAndUpdateElementValue(view, def, <NUM_LIT>, v1))<EOL>        changed = true;<EOL>    if (bindLen > <NUM_LIT> && checkAndUpdateElementValue(view, def, <NUM_LIT>, v2))<EOL>        changed = true;<EOL>    if (bindLen > <NUM_LIT> && checkAndUpdateElementValue(view, def, <NUM_LIT>, v3))<EOL>        changed = true;<EOL>    if (bindLen > <NUM_LIT> && checkAndUpdateElementValue(view, def, <NUM_LIT>, v4))<EOL>        changed = true;<EOL>    if (bindLen > <NUM_LIT> && checkAndUpdateElementValue(view, def, <NUM_LIT>, v5))<EOL>        changed = true;<EOL>    if (bindLen > <NUM_LIT> && checkAndUpdateElementValue(view, def, <NUM_LIT>, v6))<EOL>        changed = true;<EOL>    if (bindLen > <NUM_LIT> && checkAndUpdateElementValue(view, def, <NUM_LIT>, v7))<EOL>","gt":"changed = true;"}
{"input":"<s> /**<EOL> * @license<EOL> * Copyright Google Inc. All Rights Reserved.<EOL> *<EOL> * Use of this source code is governed by an MIT-style license that can be<EOL> * found in the LICENSE file at https://angular.io/license<EOL> */<EOL><EOL><EOL>function plural(n: number): number {<EOL>","gt":"if (n === <NUM_LIT>)"}
{"input":"<s> function normalize_edtf(date) {<EOL>    let year, month, day;<EOL>    switch (date.type) {<EOL>        case '<STR_LIT>':<EOL>            [year, month, day] = date.values;<EOL>            if (typeof","gt":"month === '<STR_LIT>')"}
{"input":"<s> function normalize_edtf(date) {<EOL>    let year, month, day;<EOL>    switch (date.type) {<EOL>        case '<STR_LIT>':<EOL>            [year, month, day] = date.values;<EOL>            if (typeof month === '<STR_LIT>')<EOL>                month += <NUM_LIT>;<EOL>            return doubt({ type: '<STR_LIT>', year, month, day }, { approximate: date.approximate || date.unspecified, uncertain: date.uncertain });<EOL>","gt":"case '<STR_LIT>':"}
{"input":"<s> function normalize_edtf(date) {<EOL>    let year, month, day;<EOL>    switch (date.type) {<EOL>        case '<STR_LIT>':<EOL>            [year, month, day] = date.values;<EOL>            if (typeof month === '<STR_LIT>')<EOL>                month += <NUM_LIT>;<EOL>            return doubt({ type: '<STR_LIT>', year, month, day }, { approximate: date.approximate || date.unspecified, uncertain: date.uncertain });<EOL>        case '<STR_LIT>':<EOL>            <EOL>            if (date.values.length !== <NUM_LIT>)<EOL>                throw new Error(JSON.stringify(date));<EOL>            const from = date.values[<NUM_LIT>] ? normalize_edtf(date.values[<NUM_LIT>]) : { type: '<STR_LIT>' };<EOL>","gt":"const to = date.values[<NUM_LIT>] ? normalize_edtf(date.values[<NUM_LIT>]) : { type: '<STR_LIT>' };"}
{"input":"<s> function normalize_edtf(date) {<EOL>    let year, month, day;<EOL>    switch (date.type) {<EOL>        case '<STR_LIT>':<EOL>            [year, month, day] = date.values;<EOL>            if (typeof month === '<STR_LIT>')<EOL>                month += <NUM_LIT>;<EOL>            return doubt({ type: '<STR_LIT>', year, month, day }, { approximate: date.approximate || date.unspecified, uncertain: date.uncertain });<EOL>        case '<STR_LIT>':<EOL>            <EOL>            if (date.values.length !== <NUM_LIT>)<EOL>                throw new Error(JSON.stringify(date));<EOL>            const from = date.values[<NUM_LIT>] ? normalize_edtf(date.values[<NUM_LIT>]) : { type: '<STR_LIT>' };<EOL>            const to = date.values[<NUM_LIT>] ? normalize_edtf(date.values[<NUM_LIT>]) : { type: '<STR_LIT>' };<EOL>            return { type: '<STR_LIT>', from, to };<EOL>        case '<STR_LIT>':<EOL>            [year, month] = date.values;<EOL>            if (month < SPRING || month > WINTER)<EOL>                throw new Error(`<STR_LIT>`);<EOL>            return seasonize({ type: '<STR_LIT>',","gt":"year, month });"}
{"input":"<s> function foo2() {<EOL>    let x: string | number | boolean = <NUM_LIT>;<EOL>    x; <EOL>    while (cond) {<EOL>","gt":"x;"}
{"input":"<s> export function registerTypes(serviceManager: IServiceManager) {<EOL>    serviceManager.addSingleton<IApplicationShell>(IApplicationShell, ApplicationShell);<EOL>    serviceManager.addSingleton<ICommandManager>(","gt":"ICommandManager, CommandManager);"}
{"input":"<s> export function isIdentifierStartChar(ch: number) {<EOL>    switch (ch) {<EOL>        <EOL>        case Char.Underscore:<EOL>            return true;<EOL>        <EOL>","gt":"case <NUM_LIT>:"}
{"input":"<s> export function isIdentifierStartChar(ch: number) {<EOL>    switch (ch) {<EOL>        <EOL>        case Char.Underscore:<EOL>            return true;<EOL>        <EOL>        case <NUM_LIT>:<EOL>        case <NUM_LIT>:<EOL>        case <NUM_LIT>:<EOL>        case","gt":"<NUM_LIT>:"}
{"input":"<s> export function isIdentifierStartChar(ch: number) {<EOL>    switch (ch) {<EOL>        <EOL>        case Char.Underscore:<EOL>            return true;<EOL>        <EOL>        case <NUM_LIT>:<EOL>        case <NUM_LIT>:<EOL>        case <NUM_LIT>:<EOL>        case <NUM_LIT>:<EOL>        case <NUM_LIT>:<EOL>        case <NUM_LIT>:<EOL>            return","gt":"true;"}
{"input":"<s> export function isIdentifierStartChar(ch: number) {<EOL>    switch (ch) {<EOL>        <EOL>        case Char.Underscore:<EOL>            return true;<EOL>        <EOL>        case <NUM_LIT>:<EOL>        case <NUM_LIT>:<EOL>        case <NUM_LIT>:<EOL>        case <NUM_LIT>:<EOL>        case <NUM_LIT>:<EOL>        case <NUM_LIT>:<EOL>            return true;<EOL>        default:<EOL>            break;<EOL>    }<EOL>","gt":"const cat = getUnicodeCategory(ch);"}
{"input":"<s> export function isIdentifierStartChar(ch: number) {<EOL>    switch (ch) {<EOL>        <EOL>        case Char.Underscore:<EOL>            return true;<EOL>        <EOL>        case <NUM_LIT>:<EOL>        case <NUM_LIT>:<EOL>        case <NUM_LIT>:<EOL>        case <NUM_LIT>:<EOL>        case <NUM_LIT>:<EOL>        case <NUM_LIT>:<EOL>            return true;<EOL>        default:<EOL>            break;<EOL>    }<EOL>    const cat = getUnicodeCategory(ch);<EOL>    switch (cat) {<EOL>        <EOL>        case UnicodeCategory.UppercaseLetter:<EOL>        case UnicodeCategory.LowercaseLetter:<EOL>        case UnicodeCategory.TitlecaseLetter:<EOL>","gt":"case UnicodeCategory.ModifierLetter:"}
{"input":"<s> export function injectableDef(scope: any, factory: () => any): InjectableDef {<EOL>","gt":"return {"}
{"input":"<s> /**<EOL> * Inserts a span at the tail of an existing span<EOL> * [=============] <-- existing<EOL> *          [++++] <-- new<EOL> * becomes<EOL> *<EOL> * [=======][++++] <-- pruned existing + new<EOL> */<EOL>function insertSpanAtTail(spans: Span[], newSpan: Span, i: number) {<EOL>    const span = spans[i];<EOL>    return","gt":"spans"}
{"input":"<s> /**<EOL> * V<EOL> */<EOL>export function StartVisualLineMode(num: number): IAction {<EOL>    return new","gt":"StartVisualLineModeAction();"}
{"input":"<s> function load() {<EOL>    init();<EOL>    const itemBox = document.getElementById('<STR_LIT>');<EOL>    const citekeyBox = document.","gt":"getElementById('<STR_LIT>');"}
{"input":"<s> /**<EOL> * vc;<EOL> */<EOL>export function AddVisualGotoRepeartCharacterMotion(num: number, action: IAction) {<EOL>    let m: FindCharacterMotion;<EOL>    m =","gt":"new FindCharacterMotion(null);"}
{"input":"<s> export function extractInlineSourceMap(source: string): string {<EOL>    const inlineSourceMapRegex = getInlineSourceMapRegex();<EOL>    let previousResult: RegExpExecArray | null = null;<EOL>    let result: RegExpExecArray | null = null;<EOL>    <EOL>    <EOL>    <EOL>    <EOL>    do {<EOL>        previousResult = result;<EOL>        result = inlineSourceMapRegex.exec(","gt":"source);"}
{"input":"<s> /**<EOL>* Orders import groups by matching precedence (regex first).  This is used internally by<EOL>* `ImportManager` when assigning imports to groups, so regex groups can appear later than<EOL>* keyword groups yet capture relevant imports nonetheless.<EOL>*<EOL>* @export<EOL>* @param {ImportGroup[]} importGroups The original import groups (as per extension configuration)<EOL>* @returns {ImportGroup[]} The same list, with Regex import groups appearing first.<EOL>*/<EOL>export function importGroupSortForPrecedence(importGroups: ImportGroup[]): ImportGroup[] {<EOL>    const regexGroups: ImportGroup[] = [];<EOL>    const","gt":"otherGroups: ImportGroup[] = [];"}
{"input":"<s> /**<EOL> * Gets secondary entry-points for a given package in the order they should be built.<EOL> *<EOL> * This currently assumes that every directory under a package should be an entry-point except for<EOL> * specifically black-listed directories.<EOL> *<EOL> * @param pkg The package for which to get entry points, e.g., 'theme'.<EOL> * @returns An array of secondary entry-points names<EOL> */<EOL>export function getSecondaryEntryPointsForPackage(pkg: BuildPackage) {<EOL>    const packageName = pkg.name;<EOL>    const packageDir = pkg.sourceDir;<EOL>    <EOL>    <EOL>    const","gt":"entryPoints = getSubdirectoryNames(packageDir)"}
{"input":"<s> /**<EOL> * Gets secondary entry-points for a given package in the order they should be built.<EOL> *<EOL> * This currently assumes that every directory under a package should be an entry-point except for<EOL> * specifically black-listed directories.<EOL> *<EOL> * @param pkg The package for which to get entry points, e.g., 'theme'.<EOL> * @returns An array of secondary entry-points names<EOL> */<EOL>export function getSecondaryEntryPointsForPackage(pkg: BuildPackage) {<EOL>    const packageName = pkg.name;<EOL>    const packageDir = pkg.sourceDir;<EOL>    <EOL>    <EOL>    const entryPoints = getSubdirectoryNames(packageDir)<EOL>        .filter(d => existsSync(join(packageDir, d, '<STR_LIT>')));<EOL>    <EOL>    const buildNodes: BuildNode[] = entryPoints.map(p => ({ name: p, deps: [], depth: <NUM_LIT> }));<EOL>    <EOL>    const nodeLookup = buildNodes.reduce((lookup, node) => {<EOL>","gt":"return lookup.set(node.name, node);"}
{"input":"<s> /**<EOL> * Gets secondary entry-points for a given package in the order they should be built.<EOL> *<EOL> * This currently assumes that every directory under a package should be an entry-point except for<EOL> * specifically black-listed directories.<EOL> *<EOL> * @param pkg The package for which to get entry points, e.g., 'theme'.<EOL> * @returns An array of secondary entry-points names<EOL> */<EOL>export function getSecondaryEntryPointsForPackage(pkg: BuildPackage) {<EOL>    const packageName = pkg.name;<EOL>    const packageDir = pkg.sourceDir;<EOL>    <EOL>    <EOL>    const entryPoints = getSubdirectoryNames(packageDir)<EOL>        .filter(d => existsSync(join(packageDir, d, '<STR_LIT>')));<EOL>    <EOL>    const buildNodes: BuildNode[] = entryPoints.map(p => ({ name: p, deps: [], depth: <NUM_LIT> }));<EOL>    <EOL>    const nodeLookup = buildNodes.reduce((lookup, node) => {<EOL>        return lookup.set(node.name, node);<EOL>    }, new Map<string, BuildNode>());<EOL>    <EOL>    <EOL>    const","gt":"importRegex = new RegExp(`<STR_LIT>`);"}
{"input":"<s> /**<EOL> * Gets secondary entry-points for a given package in the order they should be built.<EOL> *<EOL> * This currently assumes that every directory under a package should be an entry-point except for<EOL> * specifically black-listed directories.<EOL> *<EOL> * @param pkg The package for which to get entry points, e.g., 'theme'.<EOL> * @returns An array of secondary entry-points names<EOL> */<EOL>export function getSecondaryEntryPointsForPackage(pkg: BuildPackage) {<EOL>    const packageName = pkg.name;<EOL>    const packageDir = pkg.sourceDir;<EOL>    <EOL>    <EOL>    const entryPoints = getSubdirectoryNames(packageDir)<EOL>        .filter(d => existsSync(join(packageDir, d, '<STR_LIT>')));<EOL>    <EOL>    const buildNodes: BuildNode[] = entryPoints.map(p => ({ name: p, deps: [], depth: <NUM_LIT> }));<EOL>    <EOL>    const nodeLookup = buildNodes.reduce((lookup, node) => {<EOL>        return lookup.set(node.name, node);<EOL>    }, new Map<string, BuildNode>());<EOL>    <EOL>    <EOL>    const importRegex = new RegExp(`<STR_LIT>`);<EOL>    <EOL>    buildNodes.forEach(node => {<EOL>        const importStatementFindCommand = buildPackageImportStatementFindCommand(join(packageDir, node.name), packageName);<EOL>        <EOL>        <EOL>        node.deps = spawnSync(importStatementFindCommand.binary, importStatementFindCommand.args)<EOL>            .stdout<EOL>            .toString()<EOL>            .split('<STR_LIT>')<EOL>            .filter(n => n)<EOL>            .map(importStatement => importStatement.match(importRegex)![<NUM_LIT>])<EOL>            .filter(n => nodeLookup.","gt":"has(n) && n !== node.name)"}
{"input":"<s> /**<EOL>* Locale-sensitive (\"Human-compatible\") String-Sort function.<EOL>*<EOL>* @param {string} strA<EOL>* @param {string} strB<EOL>* @param {('asc' | 'desc')} [order='asc']<EOL>* @returns {number}<EOL>*/<EOL>function localeStringSort(strA: string, strB: string, order: '<STR_LIT>' | '<STR_LIT>' = '<STR_LIT>'): number {<EOL>    let result: number = strA.localeCompare(strB);<EOL>    if (","gt":"order === '<STR_LIT>') {"}
{"input":"<s> /**<EOL> * Sets the source map inline in the file.  If there's an existing inline source<EOL> * map, it clobbers it.<EOL> */<EOL>export function setInlineSourceMap(source: string, sourceMap: string): string {<EOL>    const encodedSourceMap = Buffer.from(sourceMap, '<STR_LIT>').toString('<STR_LIT>');<EOL>    if (containsInlineSourceMap(source)) {<EOL>        return source.replace(","gt":"getInlineSourceMapRegex(), `<STR_LIT>`);"}
{"input":"<s> function extend(dest, src) {<EOL>    for (let key in src) {<EOL>        dest[key] = src[","gt":"key];"}
{"input":"<s> export default function create_templates() {<EOL>    const template = fs.readFileSync(`<STR_LIT>`, '<STR_LIT>');<EOL>    const index = template.indexOf('<STR_LIT>');<EOL>    if (index !== -<NUM_LIT>) {<EOL>        <EOL>        const { line, column } = locate(template, index, { offsetLine: <NUM_LIT> });<EOL>        const frame = framer(template, line, column);<EOL>","gt":"error({"}
{"input":"<s> export default function create_templates() {<EOL>    const template = fs.readFileSync(`<STR_LIT>`, '<STR_LIT>');<EOL>    const index = template.indexOf('<STR_LIT>');<EOL>    if (index !== -<NUM_LIT>) {<EOL>        <EOL>        const { line, column } = locate(template, index, { offsetLine: <NUM_LIT> });<EOL>        const frame = framer(template, line, column);<EOL>        error({<EOL>            title: `<STR_LIT>`,<EOL>            body: `<STR_LIT>`,<EOL>            url: '<STR_LIT>',<EOL>","gt":"frame"}
{"input":"<s> export default function create_templates() {<EOL>    const template = fs.readFileSync(`<STR_LIT>`, '<STR_LIT>');<EOL>    const index = template.indexOf('<STR_LIT>');<EOL>    if (index !== -<NUM_LIT>) {<EOL>        <EOL>        const { line, column } = locate(template, index, { offsetLine: <NUM_LIT> });<EOL>        const frame = framer(template, line, column);<EOL>        error({<EOL>            title: `<STR_LIT>`,<EOL>            body: `<STR_LIT>`,<EOL>            url: '<STR_LIT>',<EOL>            frame<EOL>        });<EOL>    }<EOL>    return {<EOL>        render: (data: Record<string, string>) => {<EOL>            return template.replace(/%sapper\\.(\\w+)%/g, (","gt":"match, key) => {"}
{"input":"<s> function _callFactory(ngModule: NgModuleData, factory: any, deps: DepDef[]): any {<EOL>    const len = deps.length;<EOL>    switch (len) {<EOL>        case <NUM_LIT>:<EOL>            return factory();<EOL>        case <NUM_LIT>:<EOL>            return factory(resolveNgModuleDep(ngModule, deps[","gt":"<NUM_LIT>]));"}
{"input":"<s> function _callFactory(ngModule: NgModuleData, factory: any, deps: DepDef[]): any {<EOL>    const len = deps.length;<EOL>    switch (len) {<EOL>        case <NUM_LIT>:<EOL>            return factory();<EOL>        case <NUM_LIT>:<EOL>            return factory(resolveNgModuleDep(ngModule, deps[<NUM_LIT>]));<EOL>        case <NUM_LIT>:<EOL>            return factory(resolveNgModuleDep(ngModule, deps[<NUM_LIT>]), resolveNgModuleDep(ngModule, deps[<NUM_LIT>]));<EOL>        case <NUM_LIT>:<EOL>            return factory(resolveNgModuleDep(ngModule, deps[<NUM_LIT>]), resolveNgModuleDep(ngModule, deps[","gt":"<NUM_LIT>]), resolveNgModuleDep(ngModule, deps[<NUM_LIT>]));"}
{"input":"<s> function _callFactory(ngModule: NgModuleData, factory: any, deps: DepDef[]): any {<EOL>    const len = deps.length;<EOL>    switch (len) {<EOL>        case <NUM_LIT>:<EOL>            return factory();<EOL>        case <NUM_LIT>:<EOL>            return factory(resolveNgModuleDep(ngModule, deps[<NUM_LIT>]));<EOL>        case <NUM_LIT>:<EOL>            return factory(resolveNgModuleDep(ngModule, deps[<NUM_LIT>]), resolveNgModuleDep(ngModule, deps[<NUM_LIT>]));<EOL>        case <NUM_LIT>:<EOL>            return factory(resolveNgModuleDep(ngModule, deps[<NUM_LIT>]), resolveNgModuleDep(ngModule, deps[<NUM_LIT>]), resolveNgModuleDep(ngModule, deps[<NUM_LIT>]));<EOL>        default:<EOL>            const depValues = Array(len);<EOL>            for (let i =","gt":"<NUM_LIT>; i < len; i++) {"}
{"input":"<s> export function applySourceSpanToStatementIfNeeded(stmt: Statement, sourceSpan: ParseSourceSpan | null): Statement {<EOL>    if (!sourceSpan) {<EOL>        return","gt":"stmt;"}
{"input":"<s> function createAndInitializeWorkspaceService(configuration: IWindowConfiguration, environmentService: EnvironmentService): TPromise<WorkspaceService> {<EOL>    return validateSingleFolderPath(configuration).then(() => {<EOL>","gt":"const workspaceService = new WorkspaceService(environmentService);"}
{"input":"<s> export default function () {<EOL>    return Promise.","gt":"resolve()"}
{"input":"<s> /**<EOL> * Handles updating a setting given the parsed form contents.<EOL> * @param formData the form data parsed from the incoming http request.<EOL> * @param request the incoming http request.<EOL> * @param response the outgoing http response.<EOL> */<EOL>function formHandler(userId: string, formData: any, request: http.ServerRequest, response: http.ServerResponse): void {<EOL>    if (!(('<STR_LIT>' in formData) && ('<STR_LIT>' in formData))) {<EOL>        response.writeHead(<NUM_LIT>, { '<STR_LIT>': '<STR_LIT>' });<EOL>        response.end('<STR_LIT>');<EOL>","gt":"return;"}
{"input":"<s> /**<EOL> * Handles updating a setting given the parsed form contents.<EOL> * @param formData the form data parsed from the incoming http request.<EOL> * @param request the incoming http request.<EOL> * @param response the outgoing http response.<EOL> */<EOL>function formHandler(userId: string, formData: any, request: http.ServerRequest, response: http.ServerResponse): void {<EOL>    if (!(('<STR_LIT>' in formData) && ('<STR_LIT>' in formData))) {<EOL>        response.writeHead(<NUM_LIT>, { '<STR_LIT>': '<STR_LIT>' });<EOL>        response.end('<STR_LIT>');<EOL>        return;<EOL>    }<EOL>    var key = formData['<STR_LIT>'];<EOL>    var value = formData['<STR_LIT>'];<EOL>    if (","gt":"key == IDLE_TIMEOUT_KEY) {"}
{"input":"<s> /**<EOL> * Handles updating a setting given the parsed form contents.<EOL> * @param formData the form data parsed from the incoming http request.<EOL> * @param request the incoming http request.<EOL> * @param response the outgoing http response.<EOL> */<EOL>function formHandler(userId: string, formData: any, request: http.ServerRequest, response: http.ServerResponse): void {<EOL>    if (!(('<STR_LIT>' in formData) && ('<STR_LIT>' in formData))) {<EOL>        response.writeHead(<NUM_LIT>, { '<STR_LIT>': '<STR_LIT>' });<EOL>        response.end('<STR_LIT>');<EOL>        return;<EOL>    }<EOL>    var key = formData['<STR_LIT>'];<EOL>    var value = formData['<STR_LIT>'];<EOL>    if (key == IDLE_TIMEOUT_KEY) {<EOL>        if (value) {<EOL>            const { seconds, errorMessage } = idleTimeout.parseAndValidateInterval(value);<EOL>            if (errorMessage) {<EOL>                response.","gt":"writeHead(<NUM_LIT>, { '<STR_LIT>': '<STR_LIT>' });"}
{"input":"<s> /**<EOL> * Handles updating a setting given the parsed form contents.<EOL> * @param formData the form data parsed from the incoming http request.<EOL> * @param request the incoming http request.<EOL> * @param response the outgoing http response.<EOL> */<EOL>function formHandler(userId: string, formData: any, request: http.ServerRequest, response: http.ServerResponse): void {<EOL>    if (!(('<STR_LIT>' in formData) && ('<STR_LIT>' in formData))) {<EOL>        response.writeHead(<NUM_LIT>, { '<STR_LIT>': '<STR_LIT>' });<EOL>        response.end('<STR_LIT>');<EOL>        return;<EOL>    }<EOL>    var key = formData['<STR_LIT>'];<EOL>    var value = formData['<STR_LIT>'];<EOL>    if (key == IDLE_TIMEOUT_KEY) {<EOL>        if (value) {<EOL>            const { seconds, errorMessage } = idleTimeout.parseAndValidateInterval(value);<EOL>            if (errorMessage) {<EOL>                response.writeHead(<NUM_LIT>, { '<STR_LIT>': '<STR_LIT>' });<EOL>                response.end(errorMessage);<EOL>                return;<EOL>            }<EOL>        }<EOL>    }<EOL>    <EOL>    if ('<STR_LIT>' in formData) {<EOL>        response.writeHead(<NUM_LIT>, { '<STR_LIT>': '<STR_LIT>' });<EOL>        response.end(","gt":"'<STR_LIT>');"}
{"input":"<s> function getContentProjection(asts: TemplateAst[], ngContentSelectors: string[]) {<EOL>    const projectIndexMap = new Map<NgContentAst, NgContentInfo>();<EOL>    const","gt":"visitor = new ContentProjectionVisitor(projectIndexMap, ngContentSelectors);"}
{"input":"<s> export default function () {<EOL>    return ng('<STR_LIT>', '<STR_LIT>')<EOL>        .then(() => expectFileToExist('<STR_LIT>'))<EOL>        .then(() => ng(","gt":"'<STR_LIT>', '<STR_LIT>'))"}
{"input":"<s> /**<EOL> * Serializes a Tag into a string usable in a comment.<EOL> * Returns a string like \" @foo {bar} baz\" (note the whitespace).<EOL> */<EOL>function tagToString(tag: Tag, escapeExtraTags = new Set<string>()): string {<EOL>    let out = '<STR_LIT>';<EOL>    if (tag.tagName) {<EOL>        if (!JSDOC_TAGS_WHITELIST.has(tag.tagName) || escapeExtraTags.has(tag.tagName)) {<EOL>            <EOL>            <EOL>            <EOL>            <EOL>            <EOL>            <EOL>            <EOL>            <EOL>            <EOL>            <EOL>            <EOL>            out += `<STR_LIT>`;<EOL>        }<EOL>        else {<EOL>            out += `<STR_LIT>`;<EOL>        }<EOL>    }<EOL>    if (tag.","gt":"type) {"}
{"input":"<s> export function templateSourceUrl(ngModuleType: CompileIdentifierMetadata, compMeta: {<EOL>    type: CompileIdentifierMetadata;<EOL>}, templateMeta: {<EOL>    isInline: boolean;<EOL>    templateUrl: string | null;<EOL>}) {<EOL>    let url: string;<EOL>    if (templateMeta.isInline) {<EOL>        if (compMeta.type.reference instanceof StaticSymbol) {<EOL>            <EOL>            <EOL>            url = `<STR_LIT>`;<EOL>        }<EOL>        else {<EOL>            url =","gt":"type)}.html`<STR_LIT>;"}
{"input":"<s> export function templateSourceUrl(ngModuleType: CompileIdentifierMetadata, compMeta: {<EOL>    type: CompileIdentifierMetadata;<EOL>}, templateMeta: {<EOL>    isInline: boolean;<EOL>    templateUrl: string | null;<EOL>}) {<EOL>    let url: string;<EOL>    if (templateMeta.isInline) {<EOL>        if (compMeta.type.reference instanceof StaticSymbol) {<EOL>            <EOL>            <EOL>            url = `<STR_LIT>`;<EOL>        }<EOL>        else {<EOL>            url = `<STR_LIT>`;<EOL>        }<EOL>    }<EOL>","gt":"else {"}
{"input":"<s> /** Serializes a Comment out to a string usable in source code. */<EOL>export function toString(tags: Tag[], escapeExtraTags = new Set<string>()): string {<EOL>    return serialize(tags,","gt":"true, escapeExtraTags);"}
{"input":"<s> export function createOutputPreferences(preferences: PreferenceService): OutputPreferences {<EOL>    return createPreferenceProxy(preferences,","gt":"OutputConfigSchema);"}
{"input":"<s> export function isNumber(str: any): str is number {<EOL>    return str.constructor ===","gt":"Number;"}
{"input":"<s> /**<EOL> * 查找并创建<EOL> */<EOL>export function add(el: any, selector: string = '<STR_LIT>', tagName: string = '<STR_LIT>', className: string = '<STR_LIT>', cssText: string = '<STR_LIT>'): HTMLElement {<EOL>    let ret = el.querySelector(selector) as HTMLElement;<EOL>    if (!ret) {<EOL>        ret = document.createElement(tagName);<EOL>        ret.className =","gt":"className;"}
{"input":"<s> /**<EOL> * 查找并创建<EOL> */<EOL>export function add(el: any, selector: string = '<STR_LIT>', tagName: string = '<STR_LIT>', className: string = '<STR_LIT>', cssText: string = '<STR_LIT>'): HTMLElement {<EOL>    let ret = el.querySelector(selector) as HTMLElement;<EOL>    if (!ret) {<EOL>        ret = document.createElement(tagName);<EOL>        ret.className = className;<EOL>        if (cssText) {<EOL>            ret.style.cssText = cssText;<EOL>        }<EOL>","gt":"el.appendChild(ret);"}
{"input":"<s> export function fn(params: FnParam[], body: Statement[], type?: Type | null, sourceSpan?: ParseSourceSpan | null, name?: string | null): FunctionExpr {<EOL>    return new FunctionExpr(params,","gt":"body, type, sourceSpan, name);"}
{"input":"<s> export function fromMarketplace(extensionName: string, version: string): Stream {<EOL>    const filterType = <NUM_LIT>;<EOL>    const value = extensionName;<EOL>    const criterium = {","gt":"filterType, value };"}
{"input":"<s> export function fromMarketplace(extensionName: string, version: string): Stream {<EOL>    const filterType = <NUM_LIT>;<EOL>    const value = extensionName;<EOL>    const criterium = { filterType, value };<EOL>    const criteria = [criterium];<EOL>    const pageNumber = <NUM_LIT>;<EOL>","gt":"const pageSize = <NUM_LIT>;"}
{"input":"<s> export function fromMarketplace(extensionName: string, version: string): Stream {<EOL>    const filterType = <NUM_LIT>;<EOL>    const value = extensionName;<EOL>    const criterium = { filterType, value };<EOL>    const criteria = [criterium];<EOL>    const pageNumber = <NUM_LIT>;<EOL>    const pageSize = <NUM_LIT>;<EOL>    const sortBy = <NUM_LIT>;<EOL>    const sortOrder = <NUM_LIT>;<EOL>    const","gt":"flags = <NUM_LIT> | <NUM_LIT> | <NUM_LIT>;"}
{"input":"<s> export function fromMarketplace(extensionName: string, version: string): Stream {<EOL>    const filterType = <NUM_LIT>;<EOL>    const value = extensionName;<EOL>    const criterium = { filterType, value };<EOL>    const criteria = [criterium];<EOL>    const pageNumber = <NUM_LIT>;<EOL>    const pageSize = <NUM_LIT>;<EOL>    const sortBy = <NUM_LIT>;<EOL>    const sortOrder = <NUM_LIT>;<EOL>    const flags = <NUM_LIT> | <NUM_LIT> | <NUM_LIT>;<EOL>    const assetTypes = ['<STR_LIT>'];<EOL>    const filters = [{ criteria, pageNumber, pageSize, sortBy, sortOrder }];<EOL>    const body = JSON.stringify({ filters, assetTypes, flags });<EOL>    const headers:","gt":"any = assign({}, baseHeaders, {"}
{"input":"<s> export function fromMarketplace(extensionName: string, version: string): Stream {<EOL>    const filterType = <NUM_LIT>;<EOL>    const value = extensionName;<EOL>    const criterium = { filterType, value };<EOL>    const criteria = [criterium];<EOL>    const pageNumber = <NUM_LIT>;<EOL>    const pageSize = <NUM_LIT>;<EOL>    const sortBy = <NUM_LIT>;<EOL>    const sortOrder = <NUM_LIT>;<EOL>    const flags = <NUM_LIT> | <NUM_LIT> | <NUM_LIT>;<EOL>    const assetTypes = ['<STR_LIT>'];<EOL>    const filters = [{ criteria, pageNumber, pageSize, sortBy, sortOrder }];<EOL>    const body = JSON.stringify({ filters, assetTypes, flags });<EOL>    const headers: any = assign({}, baseHeaders, {<EOL>        '<STR_LIT>':","gt":"'<STR_LIT>',"}
{"input":"<s> export function fromMarketplace(extensionName: string, version: string): Stream {<EOL>    const filterType = <NUM_LIT>;<EOL>    const value = extensionName;<EOL>    const criterium = { filterType, value };<EOL>    const criteria = [criterium];<EOL>    const pageNumber = <NUM_LIT>;<EOL>    const pageSize = <NUM_LIT>;<EOL>    const sortBy = <NUM_LIT>;<EOL>    const sortOrder = <NUM_LIT>;<EOL>    const flags = <NUM_LIT> | <NUM_LIT> | <NUM_LIT>;<EOL>    const assetTypes = ['<STR_LIT>'];<EOL>    const filters = [{ criteria, pageNumber, pageSize, sortBy, sortOrder }];<EOL>    const body = JSON.stringify({ filters, assetTypes, flags });<EOL>    const headers: any = assign({}, baseHeaders, {<EOL>        '<STR_LIT>': '<STR_LIT>',<EOL>        '<STR_LIT>': '<STR_LIT>',<EOL>        '<STR_LIT>': body.length<EOL>    });<EOL>    const options = {<EOL>        base: '<STR_LIT>',<EOL>","gt":"requestOptions: {"}
{"input":"<s> export function fromMarketplace(extensionName: string, version: string): Stream {<EOL>    const filterType = <NUM_LIT>;<EOL>    const value = extensionName;<EOL>    const criterium = { filterType, value };<EOL>    const criteria = [criterium];<EOL>    const pageNumber = <NUM_LIT>;<EOL>    const pageSize = <NUM_LIT>;<EOL>    const sortBy = <NUM_LIT>;<EOL>    const sortOrder = <NUM_LIT>;<EOL>    const flags = <NUM_LIT> | <NUM_LIT> | <NUM_LIT>;<EOL>    const assetTypes = ['<STR_LIT>'];<EOL>    const filters = [{ criteria, pageNumber, pageSize, sortBy, sortOrder }];<EOL>    const body = JSON.stringify({ filters, assetTypes, flags });<EOL>    const headers: any = assign({}, baseHeaders, {<EOL>        '<STR_LIT>': '<STR_LIT>',<EOL>        '<STR_LIT>': '<STR_LIT>',<EOL>        '<STR_LIT>': body.length<EOL>    });<EOL>    const options = {<EOL>        base: '<STR_LIT>',<EOL>        requestOptions: {<EOL>            method: '<STR_LIT>',<EOL>            gzip: true,<EOL>            headers,<EOL>            body: body<EOL>        }<EOL>    };<EOL>    return remote('<STR_LIT>',","gt":"options)"}
{"input":"<s> export function fromMarketplace(extensionName: string, version: string): Stream {<EOL>    const filterType = <NUM_LIT>;<EOL>    const value = extensionName;<EOL>    const criterium = { filterType, value };<EOL>    const criteria = [criterium];<EOL>    const pageNumber = <NUM_LIT>;<EOL>    const pageSize = <NUM_LIT>;<EOL>    const sortBy = <NUM_LIT>;<EOL>    const sortOrder = <NUM_LIT>;<EOL>    const flags = <NUM_LIT> | <NUM_LIT> | <NUM_LIT>;<EOL>    const assetTypes = ['<STR_LIT>'];<EOL>    const filters = [{ criteria, pageNumber, pageSize, sortBy, sortOrder }];<EOL>    const body = JSON.stringify({ filters, assetTypes, flags });<EOL>    const headers: any = assign({}, baseHeaders, {<EOL>        '<STR_LIT>': '<STR_LIT>',<EOL>        '<STR_LIT>': '<STR_LIT>',<EOL>        '<STR_LIT>': body.length<EOL>    });<EOL>    const options = {<EOL>        base: '<STR_LIT>',<EOL>        requestOptions: {<EOL>            method: '<STR_LIT>',<EOL>            gzip: true,<EOL>            headers,<EOL>            body: body<EOL>        }<EOL>    };<EOL>    return remote('<STR_LIT>', options)<EOL>        .pipe(flatmap((stream, f) => {<EOL>        const rawResult = f.contents.toString('<STR_LIT>');<EOL>        const result = JSON.parse(rawResult);<EOL>        const extension = result.results[<NUM_LIT>].extensions[<NUM_LIT>];<EOL>        if (!extension) {<EOL>            return error(`<STR_LIT>`);<EOL>        }<EOL>        const metadata = {<EOL>            id:","gt":"extension.extensionId,"}
{"input":"<s> export function fromMarketplace(extensionName: string, version: string): Stream {<EOL>    const filterType = <NUM_LIT>;<EOL>    const value = extensionName;<EOL>    const criterium = { filterType, value };<EOL>    const criteria = [criterium];<EOL>    const pageNumber = <NUM_LIT>;<EOL>    const pageSize = <NUM_LIT>;<EOL>    const sortBy = <NUM_LIT>;<EOL>    const sortOrder = <NUM_LIT>;<EOL>    const flags = <NUM_LIT> | <NUM_LIT> | <NUM_LIT>;<EOL>    const assetTypes = ['<STR_LIT>'];<EOL>    const filters = [{ criteria, pageNumber, pageSize, sortBy, sortOrder }];<EOL>    const body = JSON.stringify({ filters, assetTypes, flags });<EOL>    const headers: any = assign({}, baseHeaders, {<EOL>        '<STR_LIT>': '<STR_LIT>',<EOL>        '<STR_LIT>': '<STR_LIT>',<EOL>        '<STR_LIT>': body.length<EOL>    });<EOL>    const options = {<EOL>        base: '<STR_LIT>',<EOL>        requestOptions: {<EOL>            method: '<STR_LIT>',<EOL>            gzip: true,<EOL>            headers,<EOL>            body: body<EOL>        }<EOL>    };<EOL>    return remote('<STR_LIT>', options)<EOL>        .pipe(flatmap((stream, f) => {<EOL>        const rawResult = f.contents.toString('<STR_LIT>');<EOL>        const result = JSON.parse(rawResult);<EOL>        const extension = result.results[<NUM_LIT>].extensions[<NUM_LIT>];<EOL>        if (!extension) {<EOL>            return error(`<STR_LIT>`);<EOL>        }<EOL>        const metadata = {<EOL>            id: extension.extensionId,<EOL>            publisherId: extension.publisher,<EOL>            publisherDisplayName: extension.publisher.displayName<EOL>        };<EOL>        const extensionVersion = extension.versions.filter(v => v.version === version)[<NUM_LIT>];<EOL>","gt":"if (!extensionVersion) {"}
{"input":"<s> export function fromMarketplace(extensionName: string, version: string): Stream {<EOL>    const filterType = <NUM_LIT>;<EOL>    const value = extensionName;<EOL>    const criterium = { filterType, value };<EOL>    const criteria = [criterium];<EOL>    const pageNumber = <NUM_LIT>;<EOL>    const pageSize = <NUM_LIT>;<EOL>    const sortBy = <NUM_LIT>;<EOL>    const sortOrder = <NUM_LIT>;<EOL>    const flags = <NUM_LIT> | <NUM_LIT> | <NUM_LIT>;<EOL>    const assetTypes = ['<STR_LIT>'];<EOL>    const filters = [{ criteria, pageNumber, pageSize, sortBy, sortOrder }];<EOL>    const body = JSON.stringify({ filters, assetTypes, flags });<EOL>    const headers: any = assign({}, baseHeaders, {<EOL>        '<STR_LIT>': '<STR_LIT>',<EOL>        '<STR_LIT>': '<STR_LIT>',<EOL>        '<STR_LIT>': body.length<EOL>    });<EOL>    const options = {<EOL>        base: '<STR_LIT>',<EOL>        requestOptions: {<EOL>            method: '<STR_LIT>',<EOL>            gzip: true,<EOL>            headers,<EOL>            body: body<EOL>        }<EOL>    };<EOL>    return remote('<STR_LIT>', options)<EOL>        .pipe(flatmap((stream, f) => {<EOL>        const rawResult = f.contents.toString('<STR_LIT>');<EOL>        const result = JSON.parse(rawResult);<EOL>        const extension = result.results[<NUM_LIT>].extensions[<NUM_LIT>];<EOL>        if (!extension) {<EOL>            return error(`<STR_LIT>`);<EOL>        }<EOL>        const metadata = {<EOL>            id: extension.extensionId,<EOL>            publisherId: extension.publisher,<EOL>            publisherDisplayName: extension.publisher.displayName<EOL>        };<EOL>        const extensionVersion = extension.versions.filter(v => v.version === version)[<NUM_LIT>];<EOL>        if (!extensionVersion) {<EOL>            return error(`<STR_LIT>`);<EOL>        }<EOL>        const asset = extensionVersion.files.filter(f => f.assetType === '<STR_LIT>')[<NUM_LIT>];<EOL>        if (!asset) {<EOL>            return error(`<STR_LIT>`);<EOL>        }<EOL>        util.log('<STR_LIT>', util.colors.yellow(`<STR_LIT>`), '<STR_LIT>');<EOL>        const options = {<EOL>            base: asset.source,<EOL>","gt":"requestOptions: {"}
{"input":"<s> export function fromMarketplace(extensionName: string, version: string): Stream {<EOL>    const filterType = <NUM_LIT>;<EOL>    const value = extensionName;<EOL>    const criterium = { filterType, value };<EOL>    const criteria = [criterium];<EOL>    const pageNumber = <NUM_LIT>;<EOL>    const pageSize = <NUM_LIT>;<EOL>    const sortBy = <NUM_LIT>;<EOL>    const sortOrder = <NUM_LIT>;<EOL>    const flags = <NUM_LIT> | <NUM_LIT> | <NUM_LIT>;<EOL>    const assetTypes = ['<STR_LIT>'];<EOL>    const filters = [{ criteria, pageNumber, pageSize, sortBy, sortOrder }];<EOL>    const body = JSON.stringify({ filters, assetTypes, flags });<EOL>    const headers: any = assign({}, baseHeaders, {<EOL>        '<STR_LIT>': '<STR_LIT>',<EOL>        '<STR_LIT>': '<STR_LIT>',<EOL>        '<STR_LIT>': body.length<EOL>    });<EOL>    const options = {<EOL>        base: '<STR_LIT>',<EOL>        requestOptions: {<EOL>            method: '<STR_LIT>',<EOL>            gzip: true,<EOL>            headers,<EOL>            body: body<EOL>        }<EOL>    };<EOL>    return remote('<STR_LIT>', options)<EOL>        .pipe(flatmap((stream, f) => {<EOL>        const rawResult = f.contents.toString('<STR_LIT>');<EOL>        const result = JSON.parse(rawResult);<EOL>        const extension = result.results[<NUM_LIT>].extensions[<NUM_LIT>];<EOL>        if (!extension) {<EOL>            return error(`<STR_LIT>`);<EOL>        }<EOL>        const metadata = {<EOL>            id: extension.extensionId,<EOL>            publisherId: extension.publisher,<EOL>            publisherDisplayName: extension.publisher.displayName<EOL>        };<EOL>        const extensionVersion = extension.versions.filter(v => v.version === version)[<NUM_LIT>];<EOL>        if (!extensionVersion) {<EOL>            return error(`<STR_LIT>`);<EOL>        }<EOL>        const asset = extensionVersion.files.filter(f => f.assetType === '<STR_LIT>')[<NUM_LIT>];<EOL>        if (!asset) {<EOL>            return error(`<STR_LIT>`);<EOL>        }<EOL>        util.log('<STR_LIT>', util.colors.yellow(`<STR_LIT>`), '<STR_LIT>');<EOL>        const options = {<EOL>            base: asset.source,<EOL>            requestOptions: {<EOL>                gzip: true,<EOL>                headers: baseHeaders<EOL>            }<EOL>        };<EOL>        return remote('<STR_LIT>', options)<EOL>            .","gt":"pipe(flatmap(stream => {"}
{"input":"<s> export function fromMarketplace(extensionName: string, version: string): Stream {<EOL>    const filterType = <NUM_LIT>;<EOL>    const value = extensionName;<EOL>    const criterium = { filterType, value };<EOL>    const criteria = [criterium];<EOL>    const pageNumber = <NUM_LIT>;<EOL>    const pageSize = <NUM_LIT>;<EOL>    const sortBy = <NUM_LIT>;<EOL>    const sortOrder = <NUM_LIT>;<EOL>    const flags = <NUM_LIT> | <NUM_LIT> | <NUM_LIT>;<EOL>    const assetTypes = ['<STR_LIT>'];<EOL>    const filters = [{ criteria, pageNumber, pageSize, sortBy, sortOrder }];<EOL>    const body = JSON.stringify({ filters, assetTypes, flags });<EOL>    const headers: any = assign({}, baseHeaders, {<EOL>        '<STR_LIT>': '<STR_LIT>',<EOL>        '<STR_LIT>': '<STR_LIT>',<EOL>        '<STR_LIT>': body.length<EOL>    });<EOL>    const options = {<EOL>        base: '<STR_LIT>',<EOL>        requestOptions: {<EOL>            method: '<STR_LIT>',<EOL>            gzip: true,<EOL>            headers,<EOL>            body: body<EOL>        }<EOL>    };<EOL>    return remote('<STR_LIT>', options)<EOL>        .pipe(flatmap((stream, f) => {<EOL>        const rawResult = f.contents.toString('<STR_LIT>');<EOL>        const result = JSON.parse(rawResult);<EOL>        const extension = result.results[<NUM_LIT>].extensions[<NUM_LIT>];<EOL>        if (!extension) {<EOL>            return error(`<STR_LIT>`);<EOL>        }<EOL>        const metadata = {<EOL>            id: extension.extensionId,<EOL>            publisherId: extension.publisher,<EOL>            publisherDisplayName: extension.publisher.displayName<EOL>        };<EOL>        const extensionVersion = extension.versions.filter(v => v.version === version)[<NUM_LIT>];<EOL>        if (!extensionVersion) {<EOL>            return error(`<STR_LIT>`);<EOL>        }<EOL>        const asset = extensionVersion.files.filter(f => f.assetType === '<STR_LIT>')[<NUM_LIT>];<EOL>        if (!asset) {<EOL>            return error(`<STR_LIT>`);<EOL>        }<EOL>        util.log('<STR_LIT>', util.colors.yellow(`<STR_LIT>`), '<STR_LIT>');<EOL>        const options = {<EOL>            base: asset.source,<EOL>            requestOptions: {<EOL>                gzip: true,<EOL>                headers: baseHeaders<EOL>            }<EOL>        };<EOL>        return remote('<STR_LIT>', options)<EOL>            .pipe(flatmap(stream => {<EOL>            const packageJsonFilter = filter('<STR_LIT>', { restore: true });<EOL>            return stream<EOL>                .pipe(","gt":"vzip.src())"}
{"input":"<s> function parseNotebookListItem(item: string) {<EOL>    if (!item.trim().startsWith('<STR_LIT>')) {<EOL>        return;<EOL>    }<EOL>    let parts = item.split('<STR_LIT>').filter(part => part !== '<STR_LIT>').map(part => part.trim());<EOL>    let url = parts.shift();<EOL>    let startupFolder = item.indexOf(","gt":"'<STR_LIT>') > <NUM_LIT> ? parts[<NUM_LIT>].trim() : null;"}
{"input":"<s> function parseNotebookListItem(item: string) {<EOL>    if (!item.trim().startsWith('<STR_LIT>')) {<EOL>        return;<EOL>    }<EOL>    let parts = item.split('<STR_LIT>').filter(part => part !== '<STR_LIT>').map(part => part.trim());<EOL>    let url = parts.shift();<EOL>    let startupFolder = item.indexOf('<STR_LIT>') > <NUM_LIT> ? parts[<NUM_LIT>].trim() : null;<EOL>    let token = '<STR_LIT>';<EOL>    let urlOnly = url;<EOL>    if (url.indexOf('<STR_LIT>') > <NUM_LIT>) {<EOL>        token = url.","gt":"split('<STR_LIT>')[<NUM_LIT>].trim();"}
{"input":"<s> function parseNotebookListItem(item: string) {<EOL>    if (!item.trim().startsWith('<STR_LIT>')) {<EOL>        return;<EOL>    }<EOL>    let parts = item.split('<STR_LIT>').filter(part => part !== '<STR_LIT>').map(part => part.trim());<EOL>    let url = parts.shift();<EOL>    let startupFolder = item.indexOf('<STR_LIT>') > <NUM_LIT> ? parts[<NUM_LIT>].trim() : null;<EOL>    let token = '<STR_LIT>';<EOL>    let urlOnly = url;<EOL>    if (url.indexOf('<STR_LIT>') > <NUM_LIT>) {<EOL>        token = url.split('<STR_LIT>')[<NUM_LIT>].trim();<EOL>        urlOnly = url.split('<STR_LIT>')[<NUM_LIT>].trim();<EOL>    }<EOL>","gt":"return <Notebook>{"}
{"input":"<s> export function extractBetweenDelimiters(content: string, startDelimiter: string, endDelimiter: string): string {<EOL>    content = content.substring(content.indexOf(","gt":"startDelimiter) + startDelimiter.length);"}
{"input":"<s> export function resolveDep(view: ViewData, elDef: NodeDef, allowPrivateServices: boolean, depDef: DepDef, notFoundValue: any = Injector.THROW_IF_NOT_FOUND): any {<EOL>    if (depDef.flags & DepFlags.Value) {<EOL>        return depDef.token;<EOL>    }<EOL>    const startView = view;<EOL>    if (depDef.flags & DepFlags.Optional) {<EOL>        notFoundValue = null;<EOL>    }<EOL>    const tokenKey = depDef.tokenKey;<EOL>    if (tokenKey === ChangeDetectorRefTokenKey) {<EOL>        <EOL>        <EOL>        allowPrivateServices = !!(elDef && elDef.element!.componentView);<EOL>    }<EOL>    if (elDef && (depDef.","gt":"flags & DepFlags.SkipSelf)) {"}
{"input":"<s> export function resolveDep(view: ViewData, elDef: NodeDef, allowPrivateServices: boolean, depDef: DepDef, notFoundValue: any = Injector.THROW_IF_NOT_FOUND): any {<EOL>    if (depDef.flags & DepFlags.Value) {<EOL>        return depDef.token;<EOL>    }<EOL>    const startView = view;<EOL>    if (depDef.flags & DepFlags.Optional) {<EOL>        notFoundValue = null;<EOL>    }<EOL>    const tokenKey = depDef.tokenKey;<EOL>    if (tokenKey === ChangeDetectorRefTokenKey) {<EOL>        <EOL>        <EOL>        allowPrivateServices = !!(elDef && elDef.element!.componentView);<EOL>    }<EOL>    if (elDef && (depDef.flags & DepFlags.SkipSelf)) {<EOL>","gt":"allowPrivateServices = false;"}
{"input":"<s> export function resolveDep(view: ViewData, elDef: NodeDef, allowPrivateServices: boolean, depDef: DepDef, notFoundValue: any = Injector.THROW_IF_NOT_FOUND): any {<EOL>    if (depDef.flags & DepFlags.Value) {<EOL>        return depDef.token;<EOL>    }<EOL>    const startView = view;<EOL>    if (depDef.flags & DepFlags.Optional) {<EOL>        notFoundValue = null;<EOL>    }<EOL>    const tokenKey = depDef.tokenKey;<EOL>    if (tokenKey === ChangeDetectorRefTokenKey) {<EOL>        <EOL>        <EOL>        allowPrivateServices = !!(elDef && elDef.element!.componentView);<EOL>    }<EOL>    if (elDef && (depDef.flags & DepFlags.SkipSelf)) {<EOL>        allowPrivateServices = false;<EOL>        elDef = elDef.parent!;<EOL>    }<EOL>    let searchView: ViewData | null = view;<EOL>    while (searchView) {<EOL>        if (elDef) {<EOL>            switch (tokenKey) {<EOL>                case RendererV1TokenKey: {<EOL>                    const compView = findCompView(searchView, elDef, allowPrivateServices);<EOL>                    return createRendererV1(","gt":"compView);"}
{"input":"<s> export function resolveDep(view: ViewData, elDef: NodeDef, allowPrivateServices: boolean, depDef: DepDef, notFoundValue: any = Injector.THROW_IF_NOT_FOUND): any {<EOL>    if (depDef.flags & DepFlags.Value) {<EOL>        return depDef.token;<EOL>    }<EOL>    const startView = view;<EOL>    if (depDef.flags & DepFlags.Optional) {<EOL>        notFoundValue = null;<EOL>    }<EOL>    const tokenKey = depDef.tokenKey;<EOL>    if (tokenKey === ChangeDetectorRefTokenKey) {<EOL>        <EOL>        <EOL>        allowPrivateServices = !!(elDef && elDef.element!.componentView);<EOL>    }<EOL>    if (elDef && (depDef.flags & DepFlags.SkipSelf)) {<EOL>        allowPrivateServices = false;<EOL>        elDef = elDef.parent!;<EOL>    }<EOL>    let searchView: ViewData | null = view;<EOL>    while (searchView) {<EOL>        if (elDef) {<EOL>            switch (tokenKey) {<EOL>                case RendererV1TokenKey: {<EOL>                    const compView = findCompView(searchView, elDef, allowPrivateServices);<EOL>                    return createRendererV1(compView);<EOL>                }<EOL>                case Renderer2TokenKey: {<EOL>                    const compView = findCompView(searchView, elDef, allowPrivateServices);<EOL>                    return compView.renderer;<EOL>                }<EOL>                case ElementRefTokenKey:<EOL>                    return new ElementRef(asElementData(searchView, elDef.nodeIndex).renderElement);<EOL>                case","gt":"ViewContainerRefTokenKey:"}
{"input":"<s> export function resolveDep(view: ViewData, elDef: NodeDef, allowPrivateServices: boolean, depDef: DepDef, notFoundValue: any = Injector.THROW_IF_NOT_FOUND): any {<EOL>    if (depDef.flags & DepFlags.Value) {<EOL>        return depDef.token;<EOL>    }<EOL>    const startView = view;<EOL>    if (depDef.flags & DepFlags.Optional) {<EOL>        notFoundValue = null;<EOL>    }<EOL>    const tokenKey = depDef.tokenKey;<EOL>    if (tokenKey === ChangeDetectorRefTokenKey) {<EOL>        <EOL>        <EOL>        allowPrivateServices = !!(elDef && elDef.element!.componentView);<EOL>    }<EOL>    if (elDef && (depDef.flags & DepFlags.SkipSelf)) {<EOL>        allowPrivateServices = false;<EOL>        elDef = elDef.parent!;<EOL>    }<EOL>    let searchView: ViewData | null = view;<EOL>    while (searchView) {<EOL>        if (elDef) {<EOL>            switch (tokenKey) {<EOL>                case RendererV1TokenKey: {<EOL>                    const compView = findCompView(searchView, elDef, allowPrivateServices);<EOL>                    return createRendererV1(compView);<EOL>                }<EOL>                case Renderer2TokenKey: {<EOL>                    const compView = findCompView(searchView, elDef, allowPrivateServices);<EOL>                    return compView.renderer;<EOL>                }<EOL>                case ElementRefTokenKey:<EOL>                    return new ElementRef(asElementData(searchView, elDef.nodeIndex).renderElement);<EOL>                case ViewContainerRefTokenKey:<EOL>                    return asElementData(searchView, elDef.nodeIndex).viewContainer;<EOL>                case TemplateRefTokenKey: {<EOL>                    if (elDef.element!.template) {<EOL>                        return asElementData(searchView, elDef.nodeIndex).template;<EOL>                    }<EOL>                    break;<EOL>                }<EOL>                case ChangeDetectorRefTokenKey: {<EOL>                    let cdView = findCompView(","gt":"searchView, elDef, allowPrivateServices);"}
{"input":"<s> export function resolveDep(view: ViewData, elDef: NodeDef, allowPrivateServices: boolean, depDef: DepDef, notFoundValue: any = Injector.THROW_IF_NOT_FOUND): any {<EOL>    if (depDef.flags & DepFlags.Value) {<EOL>        return depDef.token;<EOL>    }<EOL>    const startView = view;<EOL>    if (depDef.flags & DepFlags.Optional) {<EOL>        notFoundValue = null;<EOL>    }<EOL>    const tokenKey = depDef.tokenKey;<EOL>    if (tokenKey === ChangeDetectorRefTokenKey) {<EOL>        <EOL>        <EOL>        allowPrivateServices = !!(elDef && elDef.element!.componentView);<EOL>    }<EOL>    if (elDef && (depDef.flags & DepFlags.SkipSelf)) {<EOL>        allowPrivateServices = false;<EOL>        elDef = elDef.parent!;<EOL>    }<EOL>    let searchView: ViewData | null = view;<EOL>    while (searchView) {<EOL>        if (elDef) {<EOL>            switch (tokenKey) {<EOL>                case RendererV1TokenKey: {<EOL>                    const compView = findCompView(searchView, elDef, allowPrivateServices);<EOL>                    return createRendererV1(compView);<EOL>                }<EOL>                case Renderer2TokenKey: {<EOL>                    const compView = findCompView(searchView, elDef, allowPrivateServices);<EOL>                    return compView.renderer;<EOL>                }<EOL>                case ElementRefTokenKey:<EOL>                    return new ElementRef(asElementData(searchView, elDef.nodeIndex).renderElement);<EOL>                case ViewContainerRefTokenKey:<EOL>                    return asElementData(searchView, elDef.nodeIndex).viewContainer;<EOL>                case TemplateRefTokenKey: {<EOL>                    if (elDef.element!.template) {<EOL>                        return asElementData(searchView, elDef.nodeIndex).template;<EOL>                    }<EOL>                    break;<EOL>                }<EOL>                case ChangeDetectorRefTokenKey: {<EOL>                    let cdView = findCompView(searchView, elDef, allowPrivateServices);<EOL>                    return createChangeDetectorRef(cdView);<EOL>                }<EOL>                case InjectorRefTokenKey:<EOL>                    return","gt":"createInjector(searchView, elDef);"}
{"input":"<s> export function resolveDep(view: ViewData, elDef: NodeDef, allowPrivateServices: boolean, depDef: DepDef, notFoundValue: any = Injector.THROW_IF_NOT_FOUND): any {<EOL>    if (depDef.flags & DepFlags.Value) {<EOL>        return depDef.token;<EOL>    }<EOL>    const startView = view;<EOL>    if (depDef.flags & DepFlags.Optional) {<EOL>        notFoundValue = null;<EOL>    }<EOL>    const tokenKey = depDef.tokenKey;<EOL>    if (tokenKey === ChangeDetectorRefTokenKey) {<EOL>        <EOL>        <EOL>        allowPrivateServices = !!(elDef && elDef.element!.componentView);<EOL>    }<EOL>    if (elDef && (depDef.flags & DepFlags.SkipSelf)) {<EOL>        allowPrivateServices = false;<EOL>        elDef = elDef.parent!;<EOL>    }<EOL>    let searchView: ViewData | null = view;<EOL>    while (searchView) {<EOL>        if (elDef) {<EOL>            switch (tokenKey) {<EOL>                case RendererV1TokenKey: {<EOL>                    const compView = findCompView(searchView, elDef, allowPrivateServices);<EOL>                    return createRendererV1(compView);<EOL>                }<EOL>                case Renderer2TokenKey: {<EOL>                    const compView = findCompView(searchView, elDef, allowPrivateServices);<EOL>                    return compView.renderer;<EOL>                }<EOL>                case ElementRefTokenKey:<EOL>                    return new ElementRef(asElementData(searchView, elDef.nodeIndex).renderElement);<EOL>                case ViewContainerRefTokenKey:<EOL>                    return asElementData(searchView, elDef.nodeIndex).viewContainer;<EOL>                case TemplateRefTokenKey: {<EOL>                    if (elDef.element!.template) {<EOL>                        return asElementData(searchView, elDef.nodeIndex).template;<EOL>                    }<EOL>                    break;<EOL>                }<EOL>                case ChangeDetectorRefTokenKey: {<EOL>                    let cdView = findCompView(searchView, elDef, allowPrivateServices);<EOL>                    return createChangeDetectorRef(cdView);<EOL>                }<EOL>                case InjectorRefTokenKey:<EOL>                    return createInjector(searchView, elDef);<EOL>                default:<EOL>                    const providerDef = (allowPrivateServices ? elDef.element!.allProviders :<EOL>                        elDef.","gt":"element!.publicProviders)![tokenKey];"}
{"input":"<s> export function resolveDep(view: ViewData, elDef: NodeDef, allowPrivateServices: boolean, depDef: DepDef, notFoundValue: any = Injector.THROW_IF_NOT_FOUND): any {<EOL>    if (depDef.flags & DepFlags.Value) {<EOL>        return depDef.token;<EOL>    }<EOL>    const startView = view;<EOL>    if (depDef.flags & DepFlags.Optional) {<EOL>        notFoundValue = null;<EOL>    }<EOL>    const tokenKey = depDef.tokenKey;<EOL>    if (tokenKey === ChangeDetectorRefTokenKey) {<EOL>        <EOL>        <EOL>        allowPrivateServices = !!(elDef && elDef.element!.componentView);<EOL>    }<EOL>    if (elDef && (depDef.flags & DepFlags.SkipSelf)) {<EOL>        allowPrivateServices = false;<EOL>        elDef = elDef.parent!;<EOL>    }<EOL>    let searchView: ViewData | null = view;<EOL>    while (searchView) {<EOL>        if (elDef) {<EOL>            switch (tokenKey) {<EOL>                case RendererV1TokenKey: {<EOL>                    const compView = findCompView(searchView, elDef, allowPrivateServices);<EOL>                    return createRendererV1(compView);<EOL>                }<EOL>                case Renderer2TokenKey: {<EOL>                    const compView = findCompView(searchView, elDef, allowPrivateServices);<EOL>                    return compView.renderer;<EOL>                }<EOL>                case ElementRefTokenKey:<EOL>                    return new ElementRef(asElementData(searchView, elDef.nodeIndex).renderElement);<EOL>                case ViewContainerRefTokenKey:<EOL>                    return asElementData(searchView, elDef.nodeIndex).viewContainer;<EOL>                case TemplateRefTokenKey: {<EOL>                    if (elDef.element!.template) {<EOL>                        return asElementData(searchView, elDef.nodeIndex).template;<EOL>                    }<EOL>                    break;<EOL>                }<EOL>                case ChangeDetectorRefTokenKey: {<EOL>                    let cdView = findCompView(searchView, elDef, allowPrivateServices);<EOL>                    return createChangeDetectorRef(cdView);<EOL>                }<EOL>                case InjectorRefTokenKey:<EOL>                    return createInjector(searchView, elDef);<EOL>                default:<EOL>                    const providerDef = (allowPrivateServices ? elDef.element!.allProviders :<EOL>                        elDef.element!.publicProviders)![tokenKey];<EOL>                    if (providerDef) {<EOL>                        let providerData = asProviderData(searchView, providerDef.nodeIndex);<EOL>                        if (!providerData) {<EOL>                            providerData = { instance: _createProviderInstance(searchView, providerDef) };<EOL>                            searchView.nodes[providerDef.nodeIndex] = providerData as any;<EOL>                        }<EOL>                        return providerData.instance;<EOL>                    }<EOL>            }<EOL>        }<EOL>        allowPrivateServices = isComponentView(searchView);<EOL>        elDef = viewParentEl(searchView)!;<EOL>        searchView = searchView.parent!;<EOL>","gt":"if (depDef.flags & DepFlags.Self) {"}
{"input":"<s> export function resolveDep(view: ViewData, elDef: NodeDef, allowPrivateServices: boolean, depDef: DepDef, notFoundValue: any = Injector.THROW_IF_NOT_FOUND): any {<EOL>    if (depDef.flags & DepFlags.Value) {<EOL>        return depDef.token;<EOL>    }<EOL>    const startView = view;<EOL>    if (depDef.flags & DepFlags.Optional) {<EOL>        notFoundValue = null;<EOL>    }<EOL>    const tokenKey = depDef.tokenKey;<EOL>    if (tokenKey === ChangeDetectorRefTokenKey) {<EOL>        <EOL>        <EOL>        allowPrivateServices = !!(elDef && elDef.element!.componentView);<EOL>    }<EOL>    if (elDef && (depDef.flags & DepFlags.SkipSelf)) {<EOL>        allowPrivateServices = false;<EOL>        elDef = elDef.parent!;<EOL>    }<EOL>    let searchView: ViewData | null = view;<EOL>    while (searchView) {<EOL>        if (elDef) {<EOL>            switch (tokenKey) {<EOL>                case RendererV1TokenKey: {<EOL>                    const compView = findCompView(searchView, elDef, allowPrivateServices);<EOL>                    return createRendererV1(compView);<EOL>                }<EOL>                case Renderer2TokenKey: {<EOL>                    const compView = findCompView(searchView, elDef, allowPrivateServices);<EOL>                    return compView.renderer;<EOL>                }<EOL>                case ElementRefTokenKey:<EOL>                    return new ElementRef(asElementData(searchView, elDef.nodeIndex).renderElement);<EOL>                case ViewContainerRefTokenKey:<EOL>                    return asElementData(searchView, elDef.nodeIndex).viewContainer;<EOL>                case TemplateRefTokenKey: {<EOL>                    if (elDef.element!.template) {<EOL>                        return asElementData(searchView, elDef.nodeIndex).template;<EOL>                    }<EOL>                    break;<EOL>                }<EOL>                case ChangeDetectorRefTokenKey: {<EOL>                    let cdView = findCompView(searchView, elDef, allowPrivateServices);<EOL>                    return createChangeDetectorRef(cdView);<EOL>                }<EOL>                case InjectorRefTokenKey:<EOL>                    return createInjector(searchView, elDef);<EOL>                default:<EOL>                    const providerDef = (allowPrivateServices ? elDef.element!.allProviders :<EOL>                        elDef.element!.publicProviders)![tokenKey];<EOL>                    if (providerDef) {<EOL>                        let providerData = asProviderData(searchView, providerDef.nodeIndex);<EOL>                        if (!providerData) {<EOL>                            providerData = { instance: _createProviderInstance(searchView, providerDef) };<EOL>                            searchView.nodes[providerDef.nodeIndex] = providerData as any;<EOL>                        }<EOL>                        return providerData.instance;<EOL>                    }<EOL>            }<EOL>        }<EOL>        allowPrivateServices = isComponentView(searchView);<EOL>        elDef = viewParentEl(searchView)!;<EOL>        searchView = searchView.parent!;<EOL>        if (depDef.flags & DepFlags.Self) {<EOL>","gt":"searchView = null;"}
{"input":"<s> export function resolveDep(view: ViewData, elDef: NodeDef, allowPrivateServices: boolean, depDef: DepDef, notFoundValue: any = Injector.THROW_IF_NOT_FOUND): any {<EOL>    if (depDef.flags & DepFlags.Value) {<EOL>        return depDef.token;<EOL>    }<EOL>    const startView = view;<EOL>    if (depDef.flags & DepFlags.Optional) {<EOL>        notFoundValue = null;<EOL>    }<EOL>    const tokenKey = depDef.tokenKey;<EOL>    if (tokenKey === ChangeDetectorRefTokenKey) {<EOL>        <EOL>        <EOL>        allowPrivateServices = !!(elDef && elDef.element!.componentView);<EOL>    }<EOL>    if (elDef && (depDef.flags & DepFlags.SkipSelf)) {<EOL>        allowPrivateServices = false;<EOL>        elDef = elDef.parent!;<EOL>    }<EOL>    let searchView: ViewData | null = view;<EOL>    while (searchView) {<EOL>        if (elDef) {<EOL>            switch (tokenKey) {<EOL>                case RendererV1TokenKey: {<EOL>                    const compView = findCompView(searchView, elDef, allowPrivateServices);<EOL>                    return createRendererV1(compView);<EOL>                }<EOL>                case Renderer2TokenKey: {<EOL>                    const compView = findCompView(searchView, elDef, allowPrivateServices);<EOL>                    return compView.renderer;<EOL>                }<EOL>                case ElementRefTokenKey:<EOL>                    return new ElementRef(asElementData(searchView, elDef.nodeIndex).renderElement);<EOL>                case ViewContainerRefTokenKey:<EOL>                    return asElementData(searchView, elDef.nodeIndex).viewContainer;<EOL>                case TemplateRefTokenKey: {<EOL>                    if (elDef.element!.template) {<EOL>                        return asElementData(searchView, elDef.nodeIndex).template;<EOL>                    }<EOL>                    break;<EOL>                }<EOL>                case ChangeDetectorRefTokenKey: {<EOL>                    let cdView = findCompView(searchView, elDef, allowPrivateServices);<EOL>                    return createChangeDetectorRef(cdView);<EOL>                }<EOL>                case InjectorRefTokenKey:<EOL>                    return createInjector(searchView, elDef);<EOL>                default:<EOL>                    const providerDef = (allowPrivateServices ? elDef.element!.allProviders :<EOL>                        elDef.element!.publicProviders)![tokenKey];<EOL>                    if (providerDef) {<EOL>                        let providerData = asProviderData(searchView, providerDef.nodeIndex);<EOL>                        if (!providerData) {<EOL>                            providerData = { instance: _createProviderInstance(searchView, providerDef) };<EOL>                            searchView.nodes[providerDef.nodeIndex] = providerData as any;<EOL>                        }<EOL>                        return providerData.instance;<EOL>                    }<EOL>            }<EOL>        }<EOL>        allowPrivateServices = isComponentView(searchView);<EOL>        elDef = viewParentEl(searchView)!;<EOL>        searchView = searchView.parent!;<EOL>        if (depDef.flags & DepFlags.Self) {<EOL>            searchView = null;<EOL>        }<EOL>    }<EOL>    const value = startView.root.","gt":"injector.get(depDef.token, NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR);"}
{"input":"<s> export function resolveDep(view: ViewData, elDef: NodeDef, allowPrivateServices: boolean, depDef: DepDef, notFoundValue: any = Injector.THROW_IF_NOT_FOUND): any {<EOL>    if (depDef.flags & DepFlags.Value) {<EOL>        return depDef.token;<EOL>    }<EOL>    const startView = view;<EOL>    if (depDef.flags & DepFlags.Optional) {<EOL>        notFoundValue = null;<EOL>    }<EOL>    const tokenKey = depDef.tokenKey;<EOL>    if (tokenKey === ChangeDetectorRefTokenKey) {<EOL>        <EOL>        <EOL>        allowPrivateServices = !!(elDef && elDef.element!.componentView);<EOL>    }<EOL>    if (elDef && (depDef.flags & DepFlags.SkipSelf)) {<EOL>        allowPrivateServices = false;<EOL>        elDef = elDef.parent!;<EOL>    }<EOL>    let searchView: ViewData | null = view;<EOL>    while (searchView) {<EOL>        if (elDef) {<EOL>            switch (tokenKey) {<EOL>                case RendererV1TokenKey: {<EOL>                    const compView = findCompView(searchView, elDef, allowPrivateServices);<EOL>                    return createRendererV1(compView);<EOL>                }<EOL>                case Renderer2TokenKey: {<EOL>                    const compView = findCompView(searchView, elDef, allowPrivateServices);<EOL>                    return compView.renderer;<EOL>                }<EOL>                case ElementRefTokenKey:<EOL>                    return new ElementRef(asElementData(searchView, elDef.nodeIndex).renderElement);<EOL>                case ViewContainerRefTokenKey:<EOL>                    return asElementData(searchView, elDef.nodeIndex).viewContainer;<EOL>                case TemplateRefTokenKey: {<EOL>                    if (elDef.element!.template) {<EOL>                        return asElementData(searchView, elDef.nodeIndex).template;<EOL>                    }<EOL>                    break;<EOL>                }<EOL>                case ChangeDetectorRefTokenKey: {<EOL>                    let cdView = findCompView(searchView, elDef, allowPrivateServices);<EOL>                    return createChangeDetectorRef(cdView);<EOL>                }<EOL>                case InjectorRefTokenKey:<EOL>                    return createInjector(searchView, elDef);<EOL>                default:<EOL>                    const providerDef = (allowPrivateServices ? elDef.element!.allProviders :<EOL>                        elDef.element!.publicProviders)![tokenKey];<EOL>                    if (providerDef) {<EOL>                        let providerData = asProviderData(searchView, providerDef.nodeIndex);<EOL>                        if (!providerData) {<EOL>                            providerData = { instance: _createProviderInstance(searchView, providerDef) };<EOL>                            searchView.nodes[providerDef.nodeIndex] = providerData as any;<EOL>                        }<EOL>                        return providerData.instance;<EOL>                    }<EOL>            }<EOL>        }<EOL>        allowPrivateServices = isComponentView(searchView);<EOL>        elDef = viewParentEl(searchView)!;<EOL>        searchView = searchView.parent!;<EOL>        if (depDef.flags & DepFlags.Self) {<EOL>            searchView = null;<EOL>        }<EOL>    }<EOL>    const value = startView.root.injector.get(depDef.token, NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR);<EOL>","gt":"if (value !== NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR ||"}
{"input":"<s> /**<EOL> * Returns the inherited params, data, and resolve for a given route.<EOL> * By default, this only inherits values up to the nearest path-less or component-less route.<EOL> * @internal<EOL> */<EOL>export function inheritedParamsDataResolve(route: ActivatedRouteSnapshot, paramsInheritanceStrategy: ParamsInheritanceStrategy = '<STR_LIT>'): Inherited {<EOL>    const pathFromRoot = route.pathFromRoot;<EOL>    let inheritingStartingFrom = <NUM_LIT>;<EOL>    if (paramsInheritanceStrategy !== '<STR_LIT>') {<EOL>        inheritingStartingFrom = pathFromRoot.","gt":"length - <NUM_LIT>;"}
{"input":"<s> /**<EOL> * Returns the inherited params, data, and resolve for a given route.<EOL> * By default, this only inherits values up to the nearest path-less or component-less route.<EOL> * @internal<EOL> */<EOL>export function inheritedParamsDataResolve(route: ActivatedRouteSnapshot, paramsInheritanceStrategy: ParamsInheritanceStrategy = '<STR_LIT>'): Inherited {<EOL>    const pathFromRoot = route.pathFromRoot;<EOL>    let inheritingStartingFrom = <NUM_LIT>;<EOL>    if (paramsInheritanceStrategy !== '<STR_LIT>') {<EOL>        inheritingStartingFrom = pathFromRoot.length - <NUM_LIT>;<EOL>        while (inheritingStartingFrom >= <NUM_LIT>) {<EOL>            const current = pathFromRoot[inheritingStartingFrom];<EOL>            const parent = pathFromRoot[inheritingStartingFrom -","gt":"<NUM_LIT>];"}
{"input":"<s> /**<EOL> * Returns the inherited params, data, and resolve for a given route.<EOL> * By default, this only inherits values up to the nearest path-less or component-less route.<EOL> * @internal<EOL> */<EOL>export function inheritedParamsDataResolve(route: ActivatedRouteSnapshot, paramsInheritanceStrategy: ParamsInheritanceStrategy = '<STR_LIT>'): Inherited {<EOL>    const pathFromRoot = route.pathFromRoot;<EOL>    let inheritingStartingFrom = <NUM_LIT>;<EOL>    if (paramsInheritanceStrategy !== '<STR_LIT>') {<EOL>        inheritingStartingFrom = pathFromRoot.length - <NUM_LIT>;<EOL>        while (inheritingStartingFrom >= <NUM_LIT>) {<EOL>            const current = pathFromRoot[inheritingStartingFrom];<EOL>            const parent = pathFromRoot[inheritingStartingFrom - <NUM_LIT>];<EOL>            <EOL>            if (current.routeConfig && current.routeConfig.path === '<STR_LIT>') {<EOL>                inheritingStartingFrom--;<EOL>                <EOL>            }<EOL>            else if (!parent.component) {<EOL>                inheritingStartingFrom--;<EOL>            }<EOL>","gt":"else {"}
{"input":"<s> <EOL><EOL><EOL>/**<EOL> * Create DOM element. The instruction must later be followed by `elementEnd()` call.<EOL> *<EOL> * @param index Index of the element in the data array<EOL> * @param nameOrComponentType Name of the DOM Node or `ComponentType` to create.<EOL> * @param attrs Statically bound set of attributes to be written into the DOM element on creation.<EOL> * @param directiveTypes A set of directives declared on this element.<EOL> * @param localRefs A set of local reference bindings on the element.<EOL> *<EOL> * Attributes and localRefs are passed as an array of strings where elements with an even index<EOL> * hold an attribute name and elements with an odd index hold an attribute value, ex.:<EOL> * ['id', 'warning5', 'class', 'alert']<EOL> */<EOL>export function elementStart(index: number, nameOrComponentType?: string | ComponentType<any>, attrs?: string[] | null, directiveTypes?: DirectiveType<any>[] | null, localRefs?: string[] | null): RElement {<EOL>    let node: LElementNode;<EOL>    let native: RElement;<EOL>    if (nameOrComponentType == null) {<EOL>        <EOL>","gt":"const node = data[index]!;"}
{"input":"<s> <EOL><EOL><EOL>/**<EOL> * Create DOM element. The instruction must later be followed by `elementEnd()` call.<EOL> *<EOL> * @param index Index of the element in the data array<EOL> * @param nameOrComponentType Name of the DOM Node or `ComponentType` to create.<EOL> * @param attrs Statically bound set of attributes to be written into the DOM element on creation.<EOL> * @param directiveTypes A set of directives declared on this element.<EOL> * @param localRefs A set of local reference bindings on the element.<EOL> *<EOL> * Attributes and localRefs are passed as an array of strings where elements with an even index<EOL> * hold an attribute name and elements with an odd index hold an attribute value, ex.:<EOL> * ['id', 'warning5', 'class', 'alert']<EOL> */<EOL>export function elementStart(index: number, nameOrComponentType?: string | ComponentType<any>, attrs?: string[] | null, directiveTypes?: DirectiveType<any>[] | null, localRefs?: string[] | null): RElement {<EOL>    let node: LElementNode;<EOL>    let native: RElement;<EOL>    if (nameOrComponentType == null) {<EOL>        <EOL>        const node = data[index]!;<EOL>        native = node && (node as LElementNode).native;<EOL>    }<EOL>    else {<EOL>        ngDevMode &&<EOL>            assertNull(","gt":"currentView.bindingStartIndex, '<STR_LIT>');"}
{"input":"<s> <EOL><EOL><EOL>/**<EOL> * Create DOM element. The instruction must later be followed by `elementEnd()` call.<EOL> *<EOL> * @param index Index of the element in the data array<EOL> * @param nameOrComponentType Name of the DOM Node or `ComponentType` to create.<EOL> * @param attrs Statically bound set of attributes to be written into the DOM element on creation.<EOL> * @param directiveTypes A set of directives declared on this element.<EOL> * @param localRefs A set of local reference bindings on the element.<EOL> *<EOL> * Attributes and localRefs are passed as an array of strings where elements with an even index<EOL> * hold an attribute name and elements with an odd index hold an attribute value, ex.:<EOL> * ['id', 'warning5', 'class', 'alert']<EOL> */<EOL>export function elementStart(index: number, nameOrComponentType?: string | ComponentType<any>, attrs?: string[] | null, directiveTypes?: DirectiveType<any>[] | null, localRefs?: string[] | null): RElement {<EOL>    let node: LElementNode;<EOL>    let native: RElement;<EOL>    if (nameOrComponentType == null) {<EOL>        <EOL>        const node = data[index]!;<EOL>        native = node && (node as LElementNode).native;<EOL>    }<EOL>    else {<EOL>        ngDevMode &&<EOL>            assertNull(currentView.bindingStartIndex, '<STR_LIT>');<EOL>        const isHostElement = typeof","gt":"nameOrComponentType !== '<STR_LIT>';"}
{"input":"<s> <EOL><EOL><EOL>/**<EOL> * Create DOM element. The instruction must later be followed by `elementEnd()` call.<EOL> *<EOL> * @param index Index of the element in the data array<EOL> * @param nameOrComponentType Name of the DOM Node or `ComponentType` to create.<EOL> * @param attrs Statically bound set of attributes to be written into the DOM element on creation.<EOL> * @param directiveTypes A set of directives declared on this element.<EOL> * @param localRefs A set of local reference bindings on the element.<EOL> *<EOL> * Attributes and localRefs are passed as an array of strings where elements with an even index<EOL> * hold an attribute name and elements with an odd index hold an attribute value, ex.:<EOL> * ['id', 'warning5', 'class', 'alert']<EOL> */<EOL>export function elementStart(index: number, nameOrComponentType?: string | ComponentType<any>, attrs?: string[] | null, directiveTypes?: DirectiveType<any>[] | null, localRefs?: string[] | null): RElement {<EOL>    let node: LElementNode;<EOL>    let native: RElement;<EOL>    if (nameOrComponentType == null) {<EOL>        <EOL>        const node = data[index]!;<EOL>        native = node && (node as LElementNode).native;<EOL>    }<EOL>    else {<EOL>        ngDevMode &&<EOL>            assertNull(currentView.bindingStartIndex, '<STR_LIT>');<EOL>        const isHostElement = typeof nameOrComponentType !== '<STR_LIT>';<EOL>        <EOL>        <EOL>        <EOL>        <EOL>        <EOL>        <EOL>        const hostComponentDef = isHostElement ? (nameOrComponentType as ComponentType<any>).ngComponentDef : null;<EOL>        const name = isHostElement ? hostComponentDef!.tag : nameOrComponentType as string;<EOL>        if (name === null) {<EOL>            <EOL>","gt":"throw '<STR_LIT>';"}
{"input":"<s> <EOL><EOL><EOL>/**<EOL> * Create DOM element. The instruction must later be followed by `elementEnd()` call.<EOL> *<EOL> * @param index Index of the element in the data array<EOL> * @param nameOrComponentType Name of the DOM Node or `ComponentType` to create.<EOL> * @param attrs Statically bound set of attributes to be written into the DOM element on creation.<EOL> * @param directiveTypes A set of directives declared on this element.<EOL> * @param localRefs A set of local reference bindings on the element.<EOL> *<EOL> * Attributes and localRefs are passed as an array of strings where elements with an even index<EOL> * hold an attribute name and elements with an odd index hold an attribute value, ex.:<EOL> * ['id', 'warning5', 'class', 'alert']<EOL> */<EOL>export function elementStart(index: number, nameOrComponentType?: string | ComponentType<any>, attrs?: string[] | null, directiveTypes?: DirectiveType<any>[] | null, localRefs?: string[] | null): RElement {<EOL>    let node: LElementNode;<EOL>    let native: RElement;<EOL>    if (nameOrComponentType == null) {<EOL>        <EOL>        const node = data[index]!;<EOL>        native = node && (node as LElementNode).native;<EOL>    }<EOL>    else {<EOL>        ngDevMode &&<EOL>            assertNull(currentView.bindingStartIndex, '<STR_LIT>');<EOL>        const isHostElement = typeof nameOrComponentType !== '<STR_LIT>';<EOL>        <EOL>        <EOL>        <EOL>        <EOL>        <EOL>        <EOL>        const hostComponentDef = isHostElement ? (nameOrComponentType as ComponentType<any>).ngComponentDef : null;<EOL>        const name = isHostElement ? hostComponentDef!.tag : nameOrComponentType as string;<EOL>        if (name === null) {<EOL>            <EOL>            throw '<STR_LIT>';<EOL>        }<EOL>        else {<EOL>            native = renderer.createElement(name);<EOL>            let componentView: LView | null = null;<EOL>            if (isHostElement) {<EOL>                const tView = getOrCreateTView(hostComponentDef!.template);<EOL>                const hostView = createLView(-<NUM_LIT>, rendererFactory.createRenderer(native,","gt":"hostComponentDef!.rendererType), tView, null, null, hostComponentDef!.onPush ? LViewFlags.Dirty : LViewFlags.CheckAlways);"}
{"input":"<s> <EOL><EOL><EOL>/**<EOL> * Create DOM element. The instruction must later be followed by `elementEnd()` call.<EOL> *<EOL> * @param index Index of the element in the data array<EOL> * @param nameOrComponentType Name of the DOM Node or `ComponentType` to create.<EOL> * @param attrs Statically bound set of attributes to be written into the DOM element on creation.<EOL> * @param directiveTypes A set of directives declared on this element.<EOL> * @param localRefs A set of local reference bindings on the element.<EOL> *<EOL> * Attributes and localRefs are passed as an array of strings where elements with an even index<EOL> * hold an attribute name and elements with an odd index hold an attribute value, ex.:<EOL> * ['id', 'warning5', 'class', 'alert']<EOL> */<EOL>export function elementStart(index: number, nameOrComponentType?: string | ComponentType<any>, attrs?: string[] | null, directiveTypes?: DirectiveType<any>[] | null, localRefs?: string[] | null): RElement {<EOL>    let node: LElementNode;<EOL>    let native: RElement;<EOL>    if (nameOrComponentType == null) {<EOL>        <EOL>        const node = data[index]!;<EOL>        native = node && (node as LElementNode).native;<EOL>    }<EOL>    else {<EOL>        ngDevMode &&<EOL>            assertNull(currentView.bindingStartIndex, '<STR_LIT>');<EOL>        const isHostElement = typeof nameOrComponentType !== '<STR_LIT>';<EOL>        <EOL>        <EOL>        <EOL>        <EOL>        <EOL>        <EOL>        const hostComponentDef = isHostElement ? (nameOrComponentType as ComponentType<any>).ngComponentDef : null;<EOL>        const name = isHostElement ? hostComponentDef!.tag : nameOrComponentType as string;<EOL>        if (name === null) {<EOL>            <EOL>            throw '<STR_LIT>';<EOL>        }<EOL>        else {<EOL>            native = renderer.createElement(name);<EOL>            let componentView: LView | null = null;<EOL>            if (isHostElement) {<EOL>                const tView = getOrCreateTView(hostComponentDef!.template);<EOL>                const hostView = createLView(-<NUM_LIT>, rendererFactory.createRenderer(native, hostComponentDef!.rendererType), tView, null, null, hostComponentDef!.onPush ? LViewFlags.Dirty : LViewFlags.CheckAlways);<EOL>                componentView = addToViewTree(hostView);<EOL>            }<EOL>            <EOL>            <EOL>            node = createLNode(index, LNodeFlags.Element, native, componentView);<EOL>            <EOL>            const queryName: string | null = hack_findQueryName(hostComponentDef, localRefs, '<STR_LIT>');<EOL>            if (node.tNode == null) {<EOL>                ngDevMode && assertDataInRange(index - <NUM_LIT>);<EOL>                node.tNode = tData[","gt":"index] ="}
{"input":"<s> <EOL><EOL><EOL>/**<EOL> * Create DOM element. The instruction must later be followed by `elementEnd()` call.<EOL> *<EOL> * @param index Index of the element in the data array<EOL> * @param nameOrComponentType Name of the DOM Node or `ComponentType` to create.<EOL> * @param attrs Statically bound set of attributes to be written into the DOM element on creation.<EOL> * @param directiveTypes A set of directives declared on this element.<EOL> * @param localRefs A set of local reference bindings on the element.<EOL> *<EOL> * Attributes and localRefs are passed as an array of strings where elements with an even index<EOL> * hold an attribute name and elements with an odd index hold an attribute value, ex.:<EOL> * ['id', 'warning5', 'class', 'alert']<EOL> */<EOL>export function elementStart(index: number, nameOrComponentType?: string | ComponentType<any>, attrs?: string[] | null, directiveTypes?: DirectiveType<any>[] | null, localRefs?: string[] | null): RElement {<EOL>    let node: LElementNode;<EOL>    let native: RElement;<EOL>    if (nameOrComponentType == null) {<EOL>        <EOL>        const node = data[index]!;<EOL>        native = node && (node as LElementNode).native;<EOL>    }<EOL>    else {<EOL>        ngDevMode &&<EOL>            assertNull(currentView.bindingStartIndex, '<STR_LIT>');<EOL>        const isHostElement = typeof nameOrComponentType !== '<STR_LIT>';<EOL>        <EOL>        <EOL>        <EOL>        <EOL>        <EOL>        <EOL>        const hostComponentDef = isHostElement ? (nameOrComponentType as ComponentType<any>).ngComponentDef : null;<EOL>        const name = isHostElement ? hostComponentDef!.tag : nameOrComponentType as string;<EOL>        if (name === null) {<EOL>            <EOL>            throw '<STR_LIT>';<EOL>        }<EOL>        else {<EOL>            native = renderer.createElement(name);<EOL>            let componentView: LView | null = null;<EOL>            if (isHostElement) {<EOL>                const tView = getOrCreateTView(hostComponentDef!.template);<EOL>                const hostView = createLView(-<NUM_LIT>, rendererFactory.createRenderer(native, hostComponentDef!.rendererType), tView, null, null, hostComponentDef!.onPush ? LViewFlags.Dirty : LViewFlags.CheckAlways);<EOL>                componentView = addToViewTree(hostView);<EOL>            }<EOL>            <EOL>            <EOL>            node = createLNode(index, LNodeFlags.Element, native, componentView);<EOL>            <EOL>            const queryName: string | null = hack_findQueryName(hostComponentDef, localRefs, '<STR_LIT>');<EOL>            if (node.tNode == null) {<EOL>                ngDevMode && assertDataInRange(index - <NUM_LIT>);<EOL>                node.tNode = tData[index] =<EOL>                    createTNode(name, attrs || null, null, hostComponentDef ? null : queryName);<EOL>            }<EOL>            if (attrs)<EOL>                setUpAttributes(native, attrs);<EOL>            appendChild(node.","gt":"parent!, native, currentView);"}
{"input":"<s> export function createText(view: ViewData, renderHost: any, def: NodeDef): TextData {<EOL>    let renderNode: any;<EOL>    const renderer = view.renderer;<EOL>    renderNode =","gt":"renderer.createText(def.text!.prefix);"}
{"input":"<s> /**<EOL> * Returns true iff the request should be served by the reverse proxy.<EOL> */<EOL>export function isReverseProxyRequest(request: http.ServerRequest) {<EOL>    var urlpath = url.","gt":"parse(request.url, true).pathname;"}
{"input":"<s> /**<EOL> * Get user id from request. User Id is typically an email address.<EOL> */<EOL>export function getUserId(request: http.ServerRequest): string {<EOL>    if (appSettings.supportUserOverride) {<EOL>        <EOL>        if (request.headers.cookie) {<EOL>            var cookies =","gt":"request.headers.cookie.split('<STR_LIT>');"}
{"input":"<s> function createProdServices() {<EOL>    return {<EOL>        setCurrentNode: () => { },<EOL>        createRootView: createProdRootView,<EOL>        createEmbeddedView: createEmbeddedView,<EOL>        createComponentView: createComponentView,<EOL>","gt":"createNgModuleRef: createNgModuleRef,"}
{"input":"<s> function createProdServices() {<EOL>    return {<EOL>        setCurrentNode: () => { },<EOL>        createRootView: createProdRootView,<EOL>        createEmbeddedView: createEmbeddedView,<EOL>        createComponentView: createComponentView,<EOL>        createNgModuleRef: createNgModuleRef,<EOL>        overrideProvider: NOOP,<EOL>        overrideComponentView: NOOP,<EOL>        clearOverrides: NOOP,<EOL>        checkAndUpdateView: checkAndUpdateView,<EOL>        checkNoChangesView:","gt":"checkNoChangesView,"}
{"input":"<s> function createProdServices() {<EOL>    return {<EOL>        setCurrentNode: () => { },<EOL>        createRootView: createProdRootView,<EOL>        createEmbeddedView: createEmbeddedView,<EOL>        createComponentView: createComponentView,<EOL>        createNgModuleRef: createNgModuleRef,<EOL>        overrideProvider: NOOP,<EOL>        overrideComponentView: NOOP,<EOL>        clearOverrides: NOOP,<EOL>        checkAndUpdateView: checkAndUpdateView,<EOL>        checkNoChangesView: checkNoChangesView,<EOL>        destroyView: destroyView,<EOL>        createDebugContext: (view: ViewData, nodeIndex: number) => new DebugContext_(view, nodeIndex),<EOL>        handleEvent: (view: ViewData, nodeIndex: number, eventName: string, event: any) => view.def.handleEvent(view, nodeIndex, eventName, event),<EOL>        updateDirectives: (view: ViewData, checkType: CheckType) => view.def.updateDirectives(checkType ===","gt":"CheckType.CheckAndUpdate ? prodCheckAndUpdateNode :"}
{"input":"<s> function mergeTextTokens(srcTokens: Token[]): Token[] {<EOL>    const dstTokens: Token[] = [];<EOL>    let lastDstToken: Token | undefined = undefined;<EOL>    for (let i = <NUM_LIT>; i < srcTokens.length; i++) {<EOL>        const token = srcTokens[i];<EOL>        if (","gt":"lastDstToken && lastDstToken.type == TokenType.TEXT && token.type == TokenType.TEXT) {"}
{"input":"<s> function mergeTextTokens(srcTokens: Token[]): Token[] {<EOL>    const dstTokens: Token[] = [];<EOL>    let lastDstToken: Token | undefined = undefined;<EOL>    for (let i = <NUM_LIT>; i < srcTokens.length; i++) {<EOL>        const token = srcTokens[i];<EOL>        if (lastDstToken && lastDstToken.type == TokenType.TEXT && token.type == TokenType.TEXT) {<EOL>            lastDstToken.parts[<NUM_LIT>] += token.parts[<NUM_LIT>];<EOL>            lastDstToken.sourceSpan.end = token.sourceSpan.end;<EOL>        }<EOL>        else {<EOL>            lastDstToken = token;<EOL>            dstTokens.","gt":"push(lastDstToken);"}
{"input":"<s> function debugCreateRootView(elInjector: Injector, projectableNodes: any[][], rootSelectorOrNode: string | any, def: ViewDefinition, ngModule: NgModuleRef<any>, context?: any): ViewData {<EOL>    const rendererFactory: RendererFactory2 = ngModule.injector.get(RendererFactory2);<EOL>    const root =","gt":"createRootData(elInjector, ngModule, new DebugRendererFactory2(rendererFactory), projectableNodes, rootSelectorOrNode);"}
{"input":"<s> /** Builds the command that will be executed to find all import statements for a package. */<EOL>function buildPackageImportStatementFindCommand(searchDirectory: string, packageName: string) {<EOL>    if (platform() === '<STR_LIT>') {<EOL>        return {<EOL>            binary: '<STR_LIT>',<EOL>            args: [","gt":"'<STR_LIT>', `<STR_LIT>`, `<STR_LIT>`]"}
{"input":"<s> /** Builds the command that will be executed to find all import statements for a package. */<EOL>function buildPackageImportStatementFindCommand(searchDirectory: string, packageName: string) {<EOL>    if (platform() === '<STR_LIT>') {<EOL>        return {<EOL>            binary: '<STR_LIT>',<EOL>            args: ['<STR_LIT>', `<STR_LIT>`, `<STR_LIT>`]<EOL>        };<EOL>    }<EOL>    else {<EOL>        return {<EOL>            binary: '<STR_LIT>',<EOL>            args: ['<STR_LIT>', '<STR_LIT>', '<STR_LIT>', `<STR_LIT>`,","gt":"searchDirectory]"}
{"input":"<s> function notRecorded(...args: NwSafeAny[]): boolean {<EOL>    const asRecord = args.reduce((acc, c) => acc + c.toString(), '<STR_LIT>');<EOL>    if (record[asRecord]) {<EOL>        return","gt":"false;"}
{"input":"<s> /**<EOL> * @license<EOL> * Copyright Google Inc. All Rights Reserved.<EOL> *<EOL> * Use of this source code is governed by an MIT-style license that can be<EOL> * found in the LICENSE file at https://angular.io/license<EOL> */<EOL><EOL><EOL>function plural(n: number): number {<EOL>    let i = Math.floor(Math.abs(n)), v = n.toString().replace(/^[^.]*\\.?/, '<STR_LIT>').length;<EOL>","gt":"if (i === <NUM_LIT> && v === <NUM_LIT>)"}
{"input":"<s> <EOL>/**<EOL> * Refreshes the directive, triggering init and content hooks.<EOL> *<EOL> * When it is a component, it also enters the component's view and processes it to update bindings,<EOL> * queries, etc.<EOL> *<EOL> * @param directiveIndex<EOL> * @param elementIndex<EOL> */<EOL>export function directiveRefresh<T>(directiveIndex: number, elementIndex: number): void {<EOL>    executeInitHooks(currentView, currentView.tView, creationMode);<EOL>    executeContentHooks(currentView, currentView.tView, creationMode);<EOL>    const template = (tData[directiveIndex] as ComponentDef<T>).template;<EOL>    if (template != null) {<EOL>","gt":"ngDevMode && assertDataInRange(elementIndex);"}
{"input":"<s> <EOL>/**<EOL> * Refreshes the directive, triggering init and content hooks.<EOL> *<EOL> * When it is a component, it also enters the component's view and processes it to update bindings,<EOL> * queries, etc.<EOL> *<EOL> * @param directiveIndex<EOL> * @param elementIndex<EOL> */<EOL>export function directiveRefresh<T>(directiveIndex: number, elementIndex: number): void {<EOL>    executeInitHooks(currentView, currentView.tView, creationMode);<EOL>    executeContentHooks(currentView, currentView.tView, creationMode);<EOL>    const template = (tData[directiveIndex] as ComponentDef<T>).template;<EOL>    if (template != null) {<EOL>        ngDevMode && assertDataInRange(elementIndex);<EOL>        const element = data![elementIndex] as LElementNode;<EOL>        ngDevMode && assertNodeType(element, LNodeFlags.Element);<EOL>","gt":"ngDevMode &&"}
{"input":"<s> <EOL>/**<EOL> * Refreshes the directive, triggering init and content hooks.<EOL> *<EOL> * When it is a component, it also enters the component's view and processes it to update bindings,<EOL> * queries, etc.<EOL> *<EOL> * @param directiveIndex<EOL> * @param elementIndex<EOL> */<EOL>export function directiveRefresh<T>(directiveIndex: number, elementIndex: number): void {<EOL>    executeInitHooks(currentView, currentView.tView, creationMode);<EOL>    executeContentHooks(currentView, currentView.tView, creationMode);<EOL>    const template = (tData[directiveIndex] as ComponentDef<T>).template;<EOL>    if (template != null) {<EOL>        ngDevMode && assertDataInRange(elementIndex);<EOL>        const element = data![elementIndex] as LElementNode;<EOL>        ngDevMode && assertNodeType(element, LNodeFlags.Element);<EOL>        ngDevMode &&<EOL>            assertNotNull(element.data, `<STR_LIT>`);<EOL>        const hostView = element.data!;<EOL>        <EOL>        if (hostView.flags & (LViewFlags.CheckAlways | LViewFlags.Dirty)) {<EOL>            ngDevMode && assertDataInRange(","gt":"directiveIndex);"}
{"input":"<s> <EOL>/**<EOL> * Refreshes the directive, triggering init and content hooks.<EOL> *<EOL> * When it is a component, it also enters the component's view and processes it to update bindings,<EOL> * queries, etc.<EOL> *<EOL> * @param directiveIndex<EOL> * @param elementIndex<EOL> */<EOL>export function directiveRefresh<T>(directiveIndex: number, elementIndex: number): void {<EOL>    executeInitHooks(currentView, currentView.tView, creationMode);<EOL>    executeContentHooks(currentView, currentView.tView, creationMode);<EOL>    const template = (tData[directiveIndex] as ComponentDef<T>).template;<EOL>    if (template != null) {<EOL>        ngDevMode && assertDataInRange(elementIndex);<EOL>        const element = data![elementIndex] as LElementNode;<EOL>        ngDevMode && assertNodeType(element, LNodeFlags.Element);<EOL>        ngDevMode &&<EOL>            assertNotNull(element.data, `<STR_LIT>`);<EOL>        const hostView = element.data!;<EOL>        <EOL>        if (hostView.flags & (LViewFlags.CheckAlways | LViewFlags.Dirty)) {<EOL>            ngDevMode && assertDataInRange(directiveIndex);<EOL>            const directive = getDirectiveInstance<T>(data[directiveIndex]);<EOL>            const oldView = enterView(hostView, element);<EOL>            try {<EOL>                template(directive, creationMode);<EOL>            }<EOL>","gt":"finally {"}
{"input":"<s> export function getCurrentDebugContext(): DebugContext | null {<EOL>    return _currentView ? new DebugContext_(_currentView,","gt":"_currentNodeIndex) : null;"}
{"input":"<s> /** Creates a task that runs the TypeScript compiler */<EOL>export function tsBuildTask(tsConfigPath: string) {<EOL>    return","gt":"execNodeTask('<STR_LIT>', '<STR_LIT>', ['<STR_LIT>', tsConfigPath]);"}
{"input":"<s> /**<EOL> * @license<EOL> * Copyright Google Inc. All Rights Reserved.<EOL> *<EOL> * Use of this source code is governed by an MIT-style license that can be<EOL> * found in the LICENSE file at https://angular.io/license<EOL> */<EOL><EOL><EOL>function plural(n: number): number {<EOL>    if (n === Math.floor(n) && n >= <NUM_LIT> && n <= <NUM_LIT> || n === Math.floor(n) &&","gt":"n >= <NUM_LIT> && n <= <NUM_LIT>)"}
{"input":"<s> export function createRootView(root: RootData, def: ViewDefinition, context?: any): ViewData {<EOL>    const view = createView(root, root.renderer, null, null, def);<EOL>    initView(","gt":"view, context, context);"}
{"input":"<s> export function checkAndUpdateView(view: ViewData) {<EOL>    if (view.state & ViewState.BeforeFirstCheck) {<EOL>        view.state &= ~ViewState.BeforeFirstCheck;<EOL>        view.state |= ViewState.FirstCheck;<EOL>    }<EOL>","gt":"else {"}
{"input":"<s> export function checkAndUpdateView(view: ViewData) {<EOL>    if (view.state & ViewState.BeforeFirstCheck) {<EOL>        view.state &= ~ViewState.BeforeFirstCheck;<EOL>        view.state |= ViewState.FirstCheck;<EOL>    }<EOL>    else {<EOL>        view.state &= ~ViewState.FirstCheck;<EOL>    }<EOL>    shiftInitState(view,","gt":"ViewState.InitState_BeforeInit, ViewState.InitState_CallingOnInit);"}
{"input":"<s> export function checkAndUpdateView(view: ViewData) {<EOL>    if (view.state & ViewState.BeforeFirstCheck) {<EOL>        view.state &= ~ViewState.BeforeFirstCheck;<EOL>        view.state |= ViewState.FirstCheck;<EOL>    }<EOL>    else {<EOL>        view.state &= ~ViewState.FirstCheck;<EOL>    }<EOL>    shiftInitState(view, ViewState.InitState_BeforeInit, ViewState.InitState_CallingOnInit);<EOL>    markProjectedViewsForCheck(view);<EOL>    Services.updateDirectives(view, CheckType.CheckAndUpdate);<EOL>    execEmbeddedViewsAction(view, ViewAction.CheckAndUpdate);<EOL>    execQueriesAction(view, NodeFlags.TypeContentQuery, NodeFlags.DynamicQuery, CheckType.CheckAndUpdate);<EOL>    let callInit = shiftInitState(view,","gt":"ViewState.InitState_CallingOnInit, ViewState.InitState_CallingAfterContentInit);"}
{"input":"<s> export function checkAndUpdateView(view: ViewData) {<EOL>    if (view.state & ViewState.BeforeFirstCheck) {<EOL>        view.state &= ~ViewState.BeforeFirstCheck;<EOL>        view.state |= ViewState.FirstCheck;<EOL>    }<EOL>    else {<EOL>        view.state &= ~ViewState.FirstCheck;<EOL>    }<EOL>    shiftInitState(view, ViewState.InitState_BeforeInit, ViewState.InitState_CallingOnInit);<EOL>    markProjectedViewsForCheck(view);<EOL>    Services.updateDirectives(view, CheckType.CheckAndUpdate);<EOL>    execEmbeddedViewsAction(view, ViewAction.CheckAndUpdate);<EOL>    execQueriesAction(view, NodeFlags.TypeContentQuery, NodeFlags.DynamicQuery, CheckType.CheckAndUpdate);<EOL>    let callInit = shiftInitState(view, ViewState.InitState_CallingOnInit, ViewState.InitState_CallingAfterContentInit);<EOL>    callLifecycleHooksChildrenFirst(view, NodeFlags.AfterContentChecked | (callInit ? NodeFlags.AfterContentInit : <NUM_LIT>));<EOL>    Services.updateRenderer(view, CheckType.CheckAndUpdate);<EOL>    execComponentViewsAction(view, ViewAction.CheckAndUpdate);<EOL>    execQueriesAction(view, NodeFlags.TypeViewQuery, NodeFlags.DynamicQuery, CheckType.CheckAndUpdate);<EOL>    callInit = shiftInitState(view, ViewState.InitState_CallingAfterContentInit, ViewState.InitState_CallingAfterViewInit);<EOL>    callLifecycleHooksChildrenFirst(view, NodeFlags.AfterViewChecked | (callInit ? NodeFlags.AfterViewInit :","gt":"<NUM_LIT>));"}
{"input":"<s> function checkAndUpdateNodeDynamic(view: ViewData, nodeDef: NodeDef, values: any[]): boolean {<EOL>    switch (nodeDef.flags & NodeFlags.Types) {<EOL>        case NodeFlags.TypeElement:<EOL>            return checkAndUpdateElementDynamic(view, nodeDef, values);<EOL>        case NodeFlags.TypeText:<EOL>            return","gt":"checkAndUpdateTextDynamic(view, nodeDef, values);"}
{"input":"<s> function checkAndUpdateNodeDynamic(view: ViewData, nodeDef: NodeDef, values: any[]): boolean {<EOL>    switch (nodeDef.flags & NodeFlags.Types) {<EOL>        case NodeFlags.TypeElement:<EOL>            return checkAndUpdateElementDynamic(view, nodeDef, values);<EOL>        case NodeFlags.TypeText:<EOL>            return checkAndUpdateTextDynamic(view, nodeDef, values);<EOL>        case NodeFlags.TypeDirective:<EOL>            return checkAndUpdateDirectiveDynamic(view, nodeDef, values);<EOL>        case NodeFlags.TypePureArray:<EOL>        case NodeFlags.TypePureObject:<EOL>        case NodeFlags.TypePurePipe:<EOL>            return checkAndUpdatePureExpressionDynamic(view, nodeDef,","gt":"values);"}
{"input":"<s> function checkNoChangesNodeDynamic(view: ViewData, nodeDef: NodeDef, values: any[]): void {<EOL>    for (","gt":"let i = <NUM_LIT>; i < values.length; i++) {"}
{"input":"<s> /** Creates a task that runs the Angular Compiler CLI. */<EOL>export function ngcBuildTask(tsConfigPath: string) {<EOL>    return execNodeTask('<STR_LIT>',","gt":"'<STR_LIT>', ['<STR_LIT>', tsConfigPath]);"}
{"input":"<s> export function convertFileToPackage(filePath: string): string {<EOL>    const","gt":"lastIndex = filePath.lastIndexOf('<STR_LIT>');"}
{"input":"<s> export function generateDoc(data: any, tpl: string, path: string) {<EOL>    const","gt":"content = mustache.render(tpl, data);"}
{"input":"<s> export function expressionChangedAfterItHasBeenCheckedError(context: DebugContext, oldValue: any, currValue: any, isFirstCheck: boolean): Error {<EOL>    let msg = `<STR_LIT>`;<EOL>    if (isFirstCheck) {<EOL>","gt":"msg +="}
{"input":"<s> function fixAngular(html: string): string {<EOL>    return html.replace(/<code>(.*?)<\\/code>/gim, (fullWord: string, content: string) => {<EOL>","gt":"if (~content.indexOf('<STR_LIT>')) {"}
{"input":"<s> function explicitStructural(this: {<EOL>    y: number;<EOL>}, x: number): number {<EOL>    return","gt":"x + this.y;"}
{"input":"<s> <EOL><EOL><EOL>export function checkValidValues(object: {<EOL>    someProperty: any;<EOL>}, values: any[], done: Function, validatorOptions?: ValidatorOptions) {<EOL>    const validator = new Validator();<EOL>    const promises = values.map(value => {<EOL>        object.","gt":"someProperty = value;"}
{"input":"<s> /**<EOL> * @license<EOL> * Copyright Google Inc. All Rights Reserved.<EOL> *<EOL> * Use of this source code is governed by an MIT-style license that can be<EOL> * found in the LICENSE file at https://angular.io/license<EOL> */<EOL><EOL><EOL>function plural(n: number): number {<EOL>    let i = Math.floor(Math.abs(n));<EOL>","gt":"if (i === Math.floor(i) && i >= <NUM_LIT> && i <= <NUM_LIT>)"}
{"input":"<s> export function checkInvalidValues(object: {<EOL>    someProperty: any;<EOL>}, values: any[], done: Function, validatorOptions?: ValidatorOptions) {<EOL>    const validator = new Validator();<EOL>    const promises = values.map(value => {<EOL>        object.","gt":"someProperty = value;"}
{"input":"<s> function isName(literal: string, specialCharacterFlag: boolean): boolean {<EOL>    return literal[<NUM_LIT>] === '<STR_LIT>' && !specialCharacterFlag &&","gt":"isNaN(Number(literal));"}
{"input":"<s> /** Loads the specified resource file and drops line-breaks of the content. */<EOL>function loadResourceFile(filePath: string): string {<EOL>    return readFileSync(","gt":"filePath, '<STR_LIT>')"}
{"input":"<s> export function getTemplates(): TaskEntry[] {<EOL>    if (!_templates) {<EOL>        _templates = [dotnetBuild, msbuild, maven].sort((a, b) => {<EOL>            return (a.sort || a.label).","gt":"localeCompare(b.sort || b.label);"}
{"input":"<s> function addMatch(query: LQuery<any>, matchingValue: any): void {<EOL>","gt":"query.values.push(matchingValue);"}
{"input":"<s> /**<EOL> * @license<EOL> * Copyright Google Inc. All Rights Reserved.<EOL> *<EOL> * Use of this source code is governed by an MIT-style license that can be<EOL> * found in the LICENSE file at https://angular.io/license<EOL> */<EOL><EOL><EOL>function plural(n: number): number {<EOL>    return","gt":"<NUM_LIT>;"}
{"input":"<s> /**<EOL> * 生成可预览的图像地址<EOL> */<EOL>export function genImageUrl(file: File): string {<EOL>    if (!isSSR && isImage(file)) {<EOL>        return window.","gt":"URL.createObjectURL(file);"}
{"input":"<s> /**<EOL> * Sends a static 'custom.css' file located within the user's config directory.<EOL> *<EOL> * @param userId the ID of the current user.<EOL> * @param response the out-going response associated with the current HTTP request.<EOL> */<EOL>function sendUserCustomTheme(userId: string, response: http.ServerResponse): void {<EOL>    var customThemePath =","gt":"path.join(settings.getUserConfigDir(userId), CUSTOM_THEME_FILE);"}
{"input":"<s> /**<EOL> * Swallows exceptions thrown by a function. Function must return either a void or a promise that resolves to a void.<EOL> * @export<EOL> * @param {string} [scopeName] Scope for the error message to be logged along with the error.<EOL> * @returns void<EOL> */<EOL>export function swallowExceptions(scopeName: string) {<EOL>    <EOL>    return function (_target: any, propertyName: string, descriptor: TypedPropertyDescriptor<VoidAction> | TypedPropertyDescriptor<AsyncVoidAction>) {<EOL>        const originalMethod = descriptor.value!;<EOL>        const errorMessage = `<STR_LIT>`;<EOL>        <EOL>","gt":"descriptor.value = function (...args: any[]) {"}
{"input":"<s> /**<EOL> * Swallows exceptions thrown by a function. Function must return either a void or a promise that resolves to a void.<EOL> * @export<EOL> * @param {string} [scopeName] Scope for the error message to be logged along with the error.<EOL> * @returns void<EOL> */<EOL>export function swallowExceptions(scopeName: string) {<EOL>    <EOL>    return function (_target: any, propertyName: string, descriptor: TypedPropertyDescriptor<VoidAction> | TypedPropertyDescriptor<AsyncVoidAction>) {<EOL>        const originalMethod = descriptor.value!;<EOL>        const errorMessage = `<STR_LIT>`;<EOL>        <EOL>        descriptor.value = function (...args: any[]) {<EOL>            try {<EOL>                <EOL>                const result = originalMethod.apply(this, args);<EOL>                <EOL>                if (result && typeof result.then ===","gt":"'<STR_LIT>' && typeof result.catch === '<STR_LIT>') {"}
{"input":"<s> /**<EOL> * Swallows exceptions thrown by a function. Function must return either a void or a promise that resolves to a void.<EOL> * @export<EOL> * @param {string} [scopeName] Scope for the error message to be logged along with the error.<EOL> * @returns void<EOL> */<EOL>export function swallowExceptions(scopeName: string) {<EOL>    <EOL>    return function (_target: any, propertyName: string, descriptor: TypedPropertyDescriptor<VoidAction> | TypedPropertyDescriptor<AsyncVoidAction>) {<EOL>        const originalMethod = descriptor.value!;<EOL>        const errorMessage = `<STR_LIT>`;<EOL>        <EOL>        descriptor.value = function (...args: any[]) {<EOL>            try {<EOL>                <EOL>                const result = originalMethod.apply(this, args);<EOL>                <EOL>                if (result && typeof result.then === '<STR_LIT>' && typeof result.catch === '<STR_LIT>') {<EOL>                    return (result as Promise<void>).catch(error => console.error(errorMessage, error));<EOL>                }<EOL>            }<EOL>            catch (","gt":"error) {"}
{"input":"<s> /**<EOL> * @license<EOL> * Copyright Google Inc. All Rights Reserved.<EOL> *<EOL> * Use of this source code is governed by an MIT-style license that can be<EOL> * found in the LICENSE file at https://angular.io/license<EOL> */<EOL><EOL><EOL>function plural(n: number): number {<EOL>","gt":"if (n === <NUM_LIT>)"}
{"input":"<s> /**<EOL> * @license<EOL> * Copyright Google Inc. All Rights Reserved.<EOL> *<EOL> * Use of this source code is governed by an MIT-style license that can be<EOL> * found in the LICENSE file at https://angular.io/license<EOL> */<EOL><EOL><EOL>function plural(n: number): number {<EOL>    let i = Math.floor(Math.abs(n)), v = n.toString().replace(/^[^.]*\\.?/, '<STR_LIT>').length, f = parseInt(n.toString().replace(/^[^.]*\\.?/, '<STR_LIT>'), <NUM_LIT>) || <NUM_LIT>;<EOL>    if (v === <NUM_LIT> && i % <NUM_LIT> === <NUM_LIT> || f % <NUM_LIT> === <NUM_LIT>)<EOL>        return","gt":"<NUM_LIT>;"}
{"input":"<s> export function disable() {<EOL>    enabled =","gt":"false;"}
{"input":"<s> async function submitIdentityToServer(idty: any, toServer: any, notify: boolean, logger: any) {<EOL>    try {<EOL>        const obj = parsers.parseIdentity.syncWrite(idty);<EOL>        await toServer.writeIdentity(obj,","gt":"notify);"}
{"input":"<s> async function main(options: {<EOL>    hostname: string;<EOL>    port?: number;<EOL>}): Promise<void> {<EOL>    const key = await getSecret(Secret.GITHUB_SECRET);<EOL>    const body = JSON.stringify({ ref: `<STR_LIT>` });<EOL>    console.log(await new Fetcher().fetch({<EOL>","gt":"hostname: options.hostname,"}
{"input":"<s> async function main(options: {<EOL>    hostname: string;<EOL>    port?: number;<EOL>}): Promise<void> {<EOL>    const key = await getSecret(Secret.GITHUB_SECRET);<EOL>    const body = JSON.stringify({ ref: `<STR_LIT>` });<EOL>    console.log(await new Fetcher().fetch({<EOL>        hostname: options.hostname,<EOL>        port: options.port,<EOL>        path: \"<STR_LIT>\",<EOL>        method: \"<STR_LIT>\",<EOL>","gt":"body,"}
{"input":"<s> function checkBunchOfTransactions(transactions: TransactionDTO[], done: any = undefined) {<EOL>    const block: any = { transactions };<EOL>    return (async () => {<EOL>        try {<EOL>            let local_rule = LOCAL_RULES_FUNCTIONS;<EOL>            await local_rule.checkTxLen(block);<EOL>            await local_rule.checkTxIssuers(","gt":"block);"}
{"input":"<s> function checkBunchOfTransactions(transactions: TransactionDTO[], done: any = undefined) {<EOL>    const block: any = { transactions };<EOL>    return (async () => {<EOL>        try {<EOL>            let local_rule = LOCAL_RULES_FUNCTIONS;<EOL>            await local_rule.checkTxLen(block);<EOL>            await local_rule.checkTxIssuers(block);<EOL>            await local_rule.checkTxSources(block);<EOL>            await local_rule.checkTxRecipients(block);<EOL>            await local_rule.checkTxAmounts(block);<EOL>            await","gt":"local_rule.checkTxSignature(block);"}
{"input":"<s> function checkBunchOfTransactions(transactions: TransactionDTO[], done: any = undefined) {<EOL>    const block: any = { transactions };<EOL>    return (async () => {<EOL>        try {<EOL>            let local_rule = LOCAL_RULES_FUNCTIONS;<EOL>            await local_rule.checkTxLen(block);<EOL>            await local_rule.checkTxIssuers(block);<EOL>            await local_rule.checkTxSources(block);<EOL>            await local_rule.checkTxRecipients(block);<EOL>            await local_rule.checkTxAmounts(block);<EOL>            await local_rule.checkTxSignature(block);<EOL>            done && done();<EOL>        }<EOL>        catch (err) {<EOL>            if (","gt":"done)"}
{"input":"<s> /**<EOL> * Creates the static content request handler.<EOL> * @param settings configuration settings for the application.<EOL> * @returns the request handler to handle static requests.<EOL> */<EOL>export function createHandler(settings: common.AppSettings): http.RequestHandler {<EOL>    appSettings =","gt":"settings;"}
{"input":"<s> export function getTotalListenerCount(): number {<EOL>    return","gt":"_listenerCountEstimate;"}
{"input":"<s> function getModifiedEndLineNumber(change: IChange): number {<EOL>    if (change.modifiedEndLineNumber === <NUM_LIT>) {<EOL>        return change.modifiedStartLineNumber === <NUM_LIT> ? <NUM_LIT> : change.","gt":"modifiedStartLineNumber;"}
{"input":"<s> function checkLocal(contract: (block: BlockDTO, conf: ConfDTO, index: IndexEntry[]) => Promise<void>) {<EOL>    return async (b: BlockDTO, conf: ConfDTO, index: IndexEntry[], done: any = undefined) => {<EOL>        try {<EOL>            const block = BlockDTO.fromJSONObject(b);<EOL>            await contract(","gt":"block, conf, index);"}
{"input":"<s> function checkLocal(contract: (block: BlockDTO, conf: ConfDTO, index: IndexEntry[]) => Promise<void>) {<EOL>    return async (b: BlockDTO, conf: ConfDTO, index: IndexEntry[], done: any = undefined) => {<EOL>        try {<EOL>            const block = BlockDTO.fromJSONObject(b);<EOL>            await contract(block, conf, index);<EOL>            done && done();<EOL>        }<EOL>        catch (err) {<EOL>            if (done)<EOL>                return done(err);<EOL>            throw","gt":"err;"}
{"input":"<s> <EOL>/**<EOL> * Searches the specified array of doubles for the specified value using<EOL> * the binary search algorithm.  The array must be sorted<EOL> * (as by the {@link #sort(double[])} method) prior to making this call.<EOL> * If it is not sorted, the results are undefined.  If the array contains<EOL> * multiple elements with the specified value, there is no guarantee which<EOL> * one will be found.  This method considers all NaN values to be<EOL> * equivalent and equal.<EOL> *<EOL> * @param a the array to be searched<EOL> * @param key the value to be searched for<EOL> * @return index of the search key, if it is contained in the array;<EOL> *         otherwise, <tt>(-(<i>insertion point</i>) - 1)</tt>.  The<EOL> *         <i>insertion point</i> is defined as the point at which the<EOL> *         key would be inserted into the array: the index of the first<EOL> *         element greater than the key, or <tt>a.length</tt> if all<EOL> *         elements in the array are less than the specified key.  Note<EOL> *         that this guarantees that the return value will be &gt;= 0 if<EOL> *         and only if the key is found.<EOL> */<EOL>export function binarySearch(a: Array<number>, key: number) {<EOL>    let fromIndex: number = <NUM_LIT>;<EOL>    let toIndex: number = a.length;<EOL>    let low = fromIndex;<EOL>    let high = toIndex - <NUM_LIT>;<EOL>    while (low <= high) {<EOL>        let mid = (low + high) >>>","gt":"<NUM_LIT>;"}
{"input":"<s> <EOL>/**<EOL> * Searches the specified array of doubles for the specified value using<EOL> * the binary search algorithm.  The array must be sorted<EOL> * (as by the {@link #sort(double[])} method) prior to making this call.<EOL> * If it is not sorted, the results are undefined.  If the array contains<EOL> * multiple elements with the specified value, there is no guarantee which<EOL> * one will be found.  This method considers all NaN values to be<EOL> * equivalent and equal.<EOL> *<EOL> * @param a the array to be searched<EOL> * @param key the value to be searched for<EOL> * @return index of the search key, if it is contained in the array;<EOL> *         otherwise, <tt>(-(<i>insertion point</i>) - 1)</tt>.  The<EOL> *         <i>insertion point</i> is defined as the point at which the<EOL> *         key would be inserted into the array: the index of the first<EOL> *         element greater than the key, or <tt>a.length</tt> if all<EOL> *         elements in the array are less than the specified key.  Note<EOL> *         that this guarantees that the return value will be &gt;= 0 if<EOL> *         and only if the key is found.<EOL> */<EOL>export function binarySearch(a: Array<number>, key: number) {<EOL>    let fromIndex: number = <NUM_LIT>;<EOL>    let toIndex: number = a.length;<EOL>    let low = fromIndex;<EOL>    let high = toIndex - <NUM_LIT>;<EOL>    while (low <= high) {<EOL>        let mid = (low + high) >>> <NUM_LIT>;<EOL>        let midVal = a[mid];<EOL>        if (midVal < key) {<EOL>            low = mid + <NUM_LIT>; <EOL>        }<EOL>        else if (midVal > key) {<EOL>            high = mid - <NUM_LIT>; <EOL>        }<EOL>","gt":"else {"}
{"input":"<s> function urlMatch(request: Request, expectedUrl: RegExp, expectedMethod: RequestMethod): boolean {<EOL>    return request.url &&<EOL>        request.","gt":"method === expectedMethod &&"}
{"input":"<s> function deploymentHistory(commandName: string, yargs: yargs.Argv): void {<EOL>    isValidCommand = true;<EOL>    yargs.usage(USAGE_PREFIX + \"<STR_LIT>\" + commandName + \"<STR_LIT>\")<EOL>        .demand( <NUM_LIT>,","gt":"<NUM_LIT>)"}
{"input":"<s> function tryLoadPreviewStyles(contributes: any, contentProvider: MDDocumentContentProvider, extension: vscode.Extension<any>) {<EOL>    const styles = contributes['<STR_LIT>'];<EOL>    if (styles && Array.isArray(styles)) {<EOL>        for (const style of styles) {<EOL>","gt":"try {"}
{"input":"<s> /**<EOL> * @license<EOL> * Copyright Google Inc. All Rights Reserved.<EOL> *<EOL> * Use of this source code is governed by an MIT-style license that can be<EOL> * found in the LICENSE file at https://angular.io/license<EOL> */<EOL><EOL><EOL>function plural(n: number): number {<EOL>    let i = Math.floor(Math.abs(n)), v = n.toString().replace(/^[^.]*\\.?/, '<STR_LIT>').length;<EOL>","gt":"if (i === <NUM_LIT> && v === <NUM_LIT>)"}
{"input":"<s> /**<EOL> * @license<EOL> * Copyright Google Inc. All Rights Reserved.<EOL> *<EOL> * Use of this source code is governed by an MIT-style license that can be<EOL> * found in the LICENSE file at https://angular.io/license<EOL> */<EOL><EOL><EOL>function plural(n: number): number {<EOL>    if (n === <NUM_LIT>)<EOL>        return <NUM_LIT>;<EOL>    if (n === <NUM_LIT>)<EOL>","gt":"return <NUM_LIT>;"}
{"input":"<s> /**<EOL> * @license<EOL> * Copyright Google Inc. All Rights Reserved.<EOL> *<EOL> * Use of this source code is governed by an MIT-style license that can be<EOL> * found in the LICENSE file at https://angular.io/license<EOL> */<EOL><EOL><EOL>function plural(n: number): number {<EOL>    if (n === <NUM_LIT>)<EOL>        return <NUM_LIT>;<EOL>    if (n === <NUM_LIT>)<EOL>        return <NUM_LIT>;<EOL>    if (n === <NUM_LIT>)<EOL>        return <NUM_LIT>;<EOL>    if (n % <NUM_LIT> === Math.floor(n % <NUM_LIT>) && n % <NUM_LIT> >= <NUM_LIT> && n % <NUM_LIT> <= <NUM_LIT>)<EOL>        return <NUM_LIT>;<EOL>    if (n % <NUM_LIT> === Math.floor(","gt":"n % <NUM_LIT>) && n % <NUM_LIT> >= <NUM_LIT> && n % <NUM_LIT> <= <NUM_LIT>)"}
{"input":"<s> export function filterSame(locations: Location[], definition: Location): Location[] {<EOL>","gt":"return locations.filter(candidate => candidate.uri !== definition.uri"}
{"input":"<s> /**<EOL> * Registers all loaded actions in your application using selected driver.<EOL> */<EOL>export function createServer<T extends BaseDriver>(driver: T, options?: RoutingControllersOptions): any {<EOL>    createExecutor(","gt":"driver, options);"}
{"input":"<s> export function toDecimal(value: number, decimal: number): number {<EOL>    return Math.round(","gt":"value * Math.pow(<NUM_LIT>, decimal)) / Math.pow(<NUM_LIT>, decimal);"}
{"input":"<s> export function rightPad(str: string, len: number = <NUM_LIT>, ch: any = '<STR_LIT>') {<EOL>    str = String(str);<EOL>    ch = toString(ch);<EOL>","gt":"let i = -<NUM_LIT>;"}
{"input":"<s> function Http2RawMembership(req: any) {<EOL>    if (!(req.body && req.body.membership)) {<EOL>        throw BMAConstants.ERRORS.HTTP_PARAM_MEMBERSHIP_REQUIRED;<EOL>    }<EOL>    let ms = req.","gt":"body.membership;"}
{"input":"<s> /**<EOL> * Checks if a value is a number.<EOL> */<EOL>export function IsNumber(options: IsNumberOptions = {}, validationOptions?: ValidationOptions) {<EOL>    return function (object: Object, propertyName: string) {<EOL>        const args: ValidationMetadataArgs = {<EOL>            type: ValidationTypes.IS_NUMBER,<EOL>            target: object.","gt":"constructor,"}
{"input":"<s> export function toggleConfiguration(): ToggleConfigurationAction {<EOL>","gt":"return { type: ActionType.ToggleConfiguration };"}
{"input":"<s> function f3(a: Choice.Yes, b: UnknownYesNo) {<EOL>    var x = a + b;<EOL>    var x = a - b;<EOL>    var x = a * b;<EOL>    var x = a / b;<EOL>    var x = a % b;<EOL>    var x = a |","gt":"b;"}
{"input":"<s> function f3(a: Choice.Yes, b: UnknownYesNo) {<EOL>    var x = a + b;<EOL>    var x = a - b;<EOL>    var x = a * b;<EOL>    var x = a / b;<EOL>    var x = a % b;<EOL>    var x = a | b;<EOL>    var x = a & b;<EOL>    var x = a ^ b;<EOL>    var x = -b;<EOL>    var x = ~b;<EOL>    var y =","gt":"a == b;"}
{"input":"<s> function f3(a: Choice.Yes, b: UnknownYesNo) {<EOL>    var x = a + b;<EOL>    var x = a - b;<EOL>    var x = a * b;<EOL>    var x = a / b;<EOL>    var x = a % b;<EOL>    var x = a | b;<EOL>    var x = a & b;<EOL>    var x = a ^ b;<EOL>    var x = -b;<EOL>    var x = ~b;<EOL>    var y = a == b;<EOL>    var y = a != b;<EOL>    var y = a === b;<EOL>    var y = a !== b;<EOL>    var","gt":"y = a > b;"}
{"input":"<s> /**<EOL> * @license<EOL> * Copyright Google Inc. All Rights Reserved.<EOL> *<EOL> * Use of this source code is governed by an MIT-style license that can be<EOL> * found in the LICENSE file at https://angular.io/license<EOL> */<EOL><EOL><EOL>function plural(n: number): number {<EOL>    let i = Math.floor(Math.abs(n)), v = n.toString().replace(/^[^.]*\\.?/, '<STR_LIT>').length;<EOL>    if (i === <NUM_LIT> && v ===","gt":"<NUM_LIT>)"}
{"input":"<s> function requestCompileLlvmIr(): CompileLlvmIrRequestAction {<EOL>    return { type: ActionType.","gt":"CompileLlvmIrRequest };"}
{"input":"<s> export function editCode(code) {<EOL>","gt":"return { type: EDIT_CODE, code };"}
{"input":"<s> /**<EOL> * @license<EOL> * Copyright Google Inc. All Rights Reserved.<EOL> *<EOL> * Use of this source code is governed by an MIT-style license that can be<EOL> * found in the LICENSE file at https://angular.io/license<EOL> */<EOL><EOL><EOL>function plural(n: number): number {<EOL>    let i = Math.floor(Math.abs(n));<EOL>    if (i === <NUM_LIT> ||","gt":"i === <NUM_LIT>)"}
{"input":"<s> /**<EOL> * @license<EOL> * Copyright Google Inc. All Rights Reserved.<EOL> *<EOL> * Use of this source code is governed by an MIT-style license that can be<EOL> * found in the LICENSE file at https://angular.io/license<EOL> */<EOL><EOL><EOL>function plural(n: number): number {<EOL>    let i = Math.floor(Math.abs(n));<EOL>    if (","gt":"i === <NUM_LIT> || n === <NUM_LIT>)"}
{"input":"<s> /**<EOL> * @license<EOL> * Copyright Google Inc. All Rights Reserved.<EOL> *<EOL> * Use of this source code is governed by an MIT-style license that can be<EOL> * found in the LICENSE file at https://angular.io/license<EOL> */<EOL><EOL><EOL>function plural(n: number): number {<EOL>    if (","gt":"n === <NUM_LIT>)"}
{"input":"<s> export function bindGit(bind: interfaces.Bind, bindingOptions: GitBindingOptions = GitBindingOptions.Default): void {<EOL>    bindingOptions.bindManager(bind(GitRepositoryManager));<EOL>    bind(GitRepositoryWatcherFactory).toFactory(ctx => (options: GitRepositoryWatcherOptions) => {<EOL>        const child = new Container({ defaultScope: '<STR_LIT>' });<EOL>        child.parent = ctx.container;<EOL>        child.","gt":"bind(GitRepositoryWatcher).toSelf();"}
{"input":"<s> export function bindGit(bind: interfaces.Bind, bindingOptions: GitBindingOptions = GitBindingOptions.Default): void {<EOL>    bindingOptions.bindManager(bind(GitRepositoryManager));<EOL>    bind(GitRepositoryWatcherFactory).toFactory(ctx => (options: GitRepositoryWatcherOptions) => {<EOL>        const child = new Container({ defaultScope: '<STR_LIT>' });<EOL>        child.parent = ctx.container;<EOL>        child.bind(GitRepositoryWatcher).toSelf();<EOL>        child.bind(GitRepositoryWatcherOptions).toConstantValue(options);<EOL>        return child.get(GitRepositoryWatcher);<EOL>    });<EOL>    if (cluster.isMaster) {<EOL>        bind(GitLocator).toDynamicValue(ctx => {<EOL>","gt":"const logger = ctx.container.get<ILogger>(ILogger);"}
{"input":"<s> export function bindGit(bind: interfaces.Bind, bindingOptions: GitBindingOptions = GitBindingOptions.Default): void {<EOL>    bindingOptions.bindManager(bind(GitRepositoryManager));<EOL>    bind(GitRepositoryWatcherFactory).toFactory(ctx => (options: GitRepositoryWatcherOptions) => {<EOL>        const child = new Container({ defaultScope: '<STR_LIT>' });<EOL>        child.parent = ctx.container;<EOL>        child.bind(GitRepositoryWatcher).toSelf();<EOL>        child.bind(GitRepositoryWatcherOptions).toConstantValue(options);<EOL>        return child.get(GitRepositoryWatcher);<EOL>    });<EOL>    if (cluster.isMaster) {<EOL>        bind(GitLocator).toDynamicValue(ctx => {<EOL>            const logger = ctx.container.get<ILogger>(ILogger);<EOL>            return new GitLocatorImpl({<EOL>                info: (message, ...args) => logger.info(message, ...args),<EOL>                error: (message, ...args) =>","gt":"logger.error(message, ...args)"}
{"input":"<s> export function bindGit(bind: interfaces.Bind, bindingOptions: GitBindingOptions = GitBindingOptions.Default): void {<EOL>    bindingOptions.bindManager(bind(GitRepositoryManager));<EOL>    bind(GitRepositoryWatcherFactory).toFactory(ctx => (options: GitRepositoryWatcherOptions) => {<EOL>        const child = new Container({ defaultScope: '<STR_LIT>' });<EOL>        child.parent = ctx.container;<EOL>        child.bind(GitRepositoryWatcher).toSelf();<EOL>        child.bind(GitRepositoryWatcherOptions).toConstantValue(options);<EOL>        return child.get(GitRepositoryWatcher);<EOL>    });<EOL>    if (cluster.isMaster) {<EOL>        bind(GitLocator).toDynamicValue(ctx => {<EOL>            const logger = ctx.container.get<ILogger>(ILogger);<EOL>            return new GitLocatorImpl({<EOL>                info: (message, ...args) => logger.info(message, ...args),<EOL>                error: (message, ...args) => logger.error(message, ...args)<EOL>            });<EOL>        });<EOL>    }<EOL>    else {<EOL>        bind(","gt":"GitLocator).to(GitLocatorClient);"}
{"input":"<s> /**<EOL> * @license<EOL> * Copyright Google Inc. All Rights Reserved.<EOL> *<EOL> * Use of this source code is governed by an MIT-style license that can be<EOL> * found in the LICENSE file at https://angular.io/license<EOL> */<EOL><EOL><EOL>function plural(n: number): number {<EOL>    if (n ===","gt":"<NUM_LIT>)"}
{"input":"<s> export function altGlyphDef(className?: string): VNode<SVGElementProps | null, SVGElement> {<EOL>    return new VNode(VNodeFlags.Element | VNodeFlags.SvgElement, \"<STR_LIT>\",","gt":"null, className === undefined ? null : className, null);"}
{"input":"<s> function updateTsFile(tsFilePath: string, tsFileContents: string, majorMinor: string, patch: string, nightlyPatch: string): string {<EOL>    const majorMinorRgx = /export const versionMajorMinor = \"(\\d+\\.\\d+)\"/;<EOL>    const majorMinorMatch = majorMinorRgx.exec(tsFileContents);<EOL>    ts.Debug.assert(majorMinorMatch !== null, \"<STR_LIT>\", () => `<STR_LIT>`);<EOL>    const parsedMajorMinor = majorMinorMatch[","gt":"<NUM_LIT>];"}
{"input":"<s> function updateTsFile(tsFilePath: string, tsFileContents: string, majorMinor: string, patch: string, nightlyPatch: string): string {<EOL>    const majorMinorRgx = /export const versionMajorMinor = \"(\\d+\\.\\d+)\"/;<EOL>    const majorMinorMatch = majorMinorRgx.exec(tsFileContents);<EOL>    ts.Debug.assert(majorMinorMatch !== null, \"<STR_LIT>\", () => `<STR_LIT>`);<EOL>    const parsedMajorMinor = majorMinorMatch[<NUM_LIT>];<EOL>    ts.Debug.assert(parsedMajorMinor === majorMinor, \"<STR_LIT>\", () => `<STR_LIT>`);<EOL>    const versionRgx = /export const version = `\\$\\{versionMajorMinor\\}\\.(\\d)(-dev)?`;/;<EOL>    const patchMatch = versionRgx.exec(tsFileContents);<EOL>    ts.Debug.assert(patchMatch !== null, \"<STR_LIT>\", () => versionRgx.toString());<EOL>    const parsedPatch = patchMatch[<NUM_LIT>];<EOL>","gt":"if (parsedPatch !== patch) {"}
{"input":"<s> /**<EOL> * @license<EOL> * Copyright Google Inc. All Rights Reserved.<EOL> *<EOL> * Use of this source code is governed by an MIT-style license that can be<EOL> * found in the LICENSE file at https://angular.io/license<EOL> */<EOL><EOL><EOL>function plural(n: number): number {<EOL>    if (","gt":"n === <NUM_LIT>)"}
{"input":"<s> /**<EOL> * @license<EOL> * Copyright Google Inc. All Rights Reserved.<EOL> *<EOL> * Use of this source code is governed by an MIT-style license that can be<EOL> * found in the LICENSE file at https://angular.io/license<EOL> */<EOL><EOL><EOL>function plural(n: number): number {<EOL>    if (","gt":"n === <NUM_LIT>)"}
{"input":"<s> /** USE CASE: You have a `string?` type that you are *certain*<EOL> *            is an `ExecutableType`. But the type checker is<EOL> *            complaining.<EOL> *<EOL> *  PROBLEM:  `as ExecutableType` results in less type safety and<EOL> *            makes bugs harder to pin point in production.<EOL> *<EOL> * SOLUTION:  Run a user defined type guard (`x is ExecutableType`)<EOL> *            and raise a runtime error with the offending string<EOL> */<EOL>export function executableType(input?: string): ExecutableType {<EOL>    if (isExecutableType(input)) {<EOL>        return","gt":"input;"}
{"input":"<s> export function address(className?: string): VNode<HTMLElementProps | null> {<EOL>    return new VNode(VNodeFlags.Element,","gt":"\"<STR_LIT>\", null, className === undefined ? null : className, null, \"<STR_LIT>\");"}
{"input":"<s> export function addVisibilityObserver(observer: (visible: boolean) => void): void {<EOL>    if ((_flags & SchedulerFlags.VisibilityObserversCOW) !== <NUM_LIT>) {<EOL>","gt":"_visibilityObservers = _visibilityObservers.slice();"}
{"input":"<s> export function matrixRowViewGet(v: MatrixRowView, i: number): number {<EOL>    return v.items![i + v.","gt":"offset];"}
{"input":"<s> /**<EOL> * Checks if the string is a fully qualified domain name (e.g. domain.com).<EOL> */<EOL>export function IsFQDN(options?: IsFQDNOptions, validationOptions?: ValidationOptions) {<EOL>    return function (object: Object, propertyName: string) {<EOL>        const args: ValidationMetadataArgs = {<EOL>            type: ValidationTypes.IS_FQDN,<EOL>            target: object.","gt":"constructor,"}
{"input":"<s> export function animateMotion(className?: string): VNode<SVGElementProps | null, SVGElement> {<EOL>    return new VNode(VNodeFlags.Element | VNodeFlags.SvgElement, \"<STR_LIT>\", null,","gt":"className === undefined ? null : className, null);"}
{"input":"<s> /**<EOL> * @license<EOL> * Copyright Google Inc. All Rights Reserved.<EOL> *<EOL> * Use of this source code is governed by an MIT-style license that can be<EOL> * found in the LICENSE file at https://angular.io/license<EOL> */<EOL><EOL><EOL>function plural(n: number): number {<EOL>    let i = Math.floor(Math.abs(n));<EOL>","gt":"if (i === <NUM_LIT> || i === <NUM_LIT>)"}
{"input":"<s> function simpleInteger(question: string, property: any, conf: any, done: any) {<EOL>    simpleValue(question, property,","gt":"conf[property], conf, function (input: any) {"}
{"input":"<s> /**<EOL> * Checks if the string is a valid ISO 8601 date.<EOL> */<EOL>export function IsISO8601(validationOptions?: ValidationOptions) {<EOL>    return function (object: Object, propertyName: string) {<EOL>        const args: ValidationMetadataArgs = {<EOL>            type: ValidationTypes.","gt":"IS_ISO8601,"}
{"input":"<s> /**<EOL> * Checks if the string is a mobile phone number (locale is one of ['zh-CN', 'zh-TW', 'en-ZA', 'en-AU', 'en-HK',<EOL> * 'pt-PT', 'fr-FR', 'el-GR', 'en-GB', 'en-US', 'en-ZM', 'ru-RU', 'nb-NO', 'nn-NO', 'vi-VN', 'en-NZ']).<EOL> */<EOL>export function IsMobilePhone(locale: string, validationOptions?: ValidationOptions) {<EOL>    return function (object: Object, propertyName: string) {<EOL>        const args: ValidationMetadataArgs = {<EOL>            type: ValidationTypes.IS_MOBILE_PHONE,<EOL>","gt":"target: object.constructor,"}
{"input":"<s> /**<EOL> * Checks if the string is uppercase.<EOL> */<EOL>export function IsUppercase(validationOptions?: ValidationOptions) {<EOL>    return function (object: Object, propertyName: string) {<EOL>        const args: ValidationMetadataArgs = {<EOL>","gt":"type: ValidationTypes.IS_UPPERCASE,"}
{"input":"<s> /**<EOL> * Checks if array does not contain any of the given values.<EOL> */<EOL>export function ArrayNotContains(values: any[], validationOptions?: ValidationOptions) {<EOL>    return function (object: Object, propertyName: string) {<EOL>        const args: ValidationMetadataArgs = {<EOL>            type: ValidationTypes.ARRAY_NOT_CONTAINS,<EOL>            target: object.","gt":"constructor,"}
{"input":"<s> /**<EOL> * Checks if given array is not empty.<EOL> */<EOL>export function ArrayNotEmpty(validationOptions?: ValidationOptions) {<EOL>    return function (object: Object, propertyName: string) {<EOL>        const args: ValidationMetadataArgs = {<EOL>            type: ValidationTypes.","gt":"ARRAY_NOT_EMPTY,"}
{"input":"<s> function findUniversalExcludes(folderQueries: IFolderSearch[]): Set<string> {<EOL>    if (folderQueries.length < <NUM_LIT>) {<EOL>        <EOL>        return null;<EOL>    }<EOL>","gt":"const firstFolder = folderQueries[<NUM_LIT>];"}
{"input":"<s> function findUniversalExcludes(folderQueries: IFolderSearch[]): Set<string> {<EOL>    if (folderQueries.length < <NUM_LIT>) {<EOL>        <EOL>        return null;<EOL>    }<EOL>    const firstFolder = folderQueries[<NUM_LIT>];<EOL>    if (!firstFolder.excludePattern) {<EOL>        return null;<EOL>    }<EOL>","gt":"const universalExcludes = new Set<string>();"}
{"input":"<s> function findUniversalExcludes(folderQueries: IFolderSearch[]): Set<string> {<EOL>    if (folderQueries.length < <NUM_LIT>) {<EOL>        <EOL>        return null;<EOL>    }<EOL>    const firstFolder = folderQueries[<NUM_LIT>];<EOL>    if (!firstFolder.excludePattern) {<EOL>        return null;<EOL>    }<EOL>    const universalExcludes = new Set<string>();<EOL>    Object.keys(firstFolder.excludePattern).forEach(key => {<EOL>        if (strings.startsWith(key, '<STR_LIT>') && folderQueries.every(q => q.excludePattern && q.excludePattern[key] === true)) {<EOL>            universalExcludes.add(","gt":"key);"}
{"input":"<s> /**<EOL> * @license<EOL> * Copyright Google Inc. All Rights Reserved.<EOL> *<EOL> * Use of this source code is governed by an MIT-style license that can be<EOL> * found in the LICENSE file at https://angular.io/license<EOL> */<EOL><EOL><EOL>function plural(n: number): number {<EOL>    let i = Math.floor(Math.abs(n));<EOL>    if (i === <NUM_LIT> || i ===","gt":"<NUM_LIT>)"}
{"input":"<s> /**<EOL> * @license<EOL> * Copyright Google Inc. All Rights Reserved.<EOL> *<EOL> * Use of this source code is governed by an MIT-style license that can be<EOL> * found in the LICENSE file at https://angular.io/license<EOL> */<EOL><EOL><EOL>function plural(n: number): number {<EOL>","gt":"if (n === <NUM_LIT>)"}
{"input":"<s> /**<EOL> * @license<EOL> * Copyright Google Inc. All Rights Reserved.<EOL> *<EOL> * Use of this source code is governed by an MIT-style license that can be<EOL> * found in the LICENSE file at https://angular.io/license<EOL> */<EOL><EOL><EOL>function plural(n: number): number {<EOL>    let i = Math.floor(Math.abs(n)), v = n.toString().replace(/^[^.]*\\.?/, '<STR_LIT>').length;<EOL>    if (i === <NUM_LIT> &&","gt":"v === <NUM_LIT>)"}
{"input":"<s> /**<EOL> * @license<EOL> * Copyright Google Inc. All Rights Reserved.<EOL> *<EOL> * Use of this source code is governed by an MIT-style license that can be<EOL> * found in the LICENSE file at https://angular.io/license<EOL> */<EOL><EOL><EOL>function plural(n: number): number {<EOL>    let i = Math.floor(Math.abs(n)), v = n.toString().replace(/^[^.]*\\.?/, '<STR_LIT>').length;<EOL>    if (i === <NUM_LIT> && v ===","gt":"<NUM_LIT>)"}
{"input":"<s> function getBestLocalIPv4() {<EOL>    return","gt":"getBestLocal('<STR_LIT>');"}
{"input":"<s> export function setDirty(widget: Widget, dirty: boolean): void {<EOL>    const dirtyClass = `<STR_LIT>`;<EOL>","gt":"widget.title.className = widget.title.className.replace(dirtyClass, '<STR_LIT>');"}
{"input":"<s> export function debounceEvent<T>(event: Event<T>, delay: number): Event<T> {<EOL>    return (listener, thisArgs = null, disposables?) => {<EOL>        let timer: NodeJS.Timer;<EOL>","gt":"return event(e => {"}
{"input":"<s> function buildTree(maxDepth, values, curDepth) {<EOL>    if (curDepth === <NUM_LIT>) {<EOL>        nodes = <NUM_LIT>;<EOL>    }<EOL>    else {<EOL>","gt":"nodes++;"}
{"input":"<s> function buildTree(maxDepth, values, curDepth) {<EOL>    if (curDepth === <NUM_LIT>) {<EOL>        nodes = <NUM_LIT>;<EOL>    }<EOL>    else {<EOL>        nodes++;<EOL>    }<EOL>    if (maxDepth === curDepth) {<EOL>        return new TreeNode(\"<STR_LIT>\", null, null);<EOL>    }<EOL>    let result = new TreeNode(values[curDepth], buildTree(maxDepth, values, curDepth + <NUM_LIT>), buildTree(maxDepth, values, curDepth + <NUM_LIT>));<EOL>    if (curDepth ===","gt":"<NUM_LIT>) {"}
{"input":"<s> export function getMapSize(gridSize: AxisNumberProperty, gridOffset: AxisNumberProperty): AxisNumberProperty {<EOL>    return {<EOL>","gt":"x: gridSize.x + gridOffset.x * <NUM_LIT>,"}
{"input":"<s> /**<EOL> * @license<EOL> * Copyright Google Inc. All Rights Reserved.<EOL> *<EOL> * Use of this source code is governed by an MIT-style license that can be<EOL> * found in the LICENSE file at https://angular.io/license<EOL> */<EOL><EOL><EOL>function plural(n: number): number {<EOL>","gt":"return <NUM_LIT>;"}
{"input":"<s> export function doubleTapAction(args: gestures.GestureEventData) {<EOL>","gt":"console.log(\"<STR_LIT>\");"}
{"input":"<s> /**<EOL> * getDOMInstanceFromVNode retrieves a reference to a DOM node from a VNode object.<EOL> *<EOL> * @param node VNode which contains reference to a DOM node.<EOL> * @returns null if VNode doesn't have a reference to a DOM node.<EOL> */<EOL>export function getDOMInstanceFromVNode<T extends Node>(node: VNode<any, T>): T | null {<EOL>    if ((node._flags & VNodeFlags.Component) !== <NUM_LIT>) {<EOL>        return getDOMInstanceFromVNode<T>(","gt":"node._children as VNode<any, T>);"}
{"input":"<s> export function vec2Distance(v: Vec2): number {<EOL>    return Math.sqrt(v.x * v.","gt":"x + v.y * v.y);"}
{"input":"<s> export function toResource(editor: IEditorInput, options?: IResourceOptions): URI {<EOL>    if (!editor) {<EOL>        return null;<EOL>    }<EOL>    <EOL>    if (options && options.supportSideBySide && editor instanceof SideBySideEditorInput) {<EOL>","gt":"editor = editor.master;"}
{"input":"<s> export function toResource(editor: IEditorInput, options?: IResourceOptions): URI {<EOL>    if (!editor) {<EOL>        return null;<EOL>    }<EOL>    <EOL>    if (options && options.supportSideBySide && editor instanceof SideBySideEditorInput) {<EOL>        editor = editor.master;<EOL>    }<EOL>    const resource = editor.getResource();<EOL>    if (!options || !options.filter) {<EOL>        return","gt":"resource;"}
{"input":"<s> export function toResource(editor: IEditorInput, options?: IResourceOptions): URI {<EOL>    if (!editor) {<EOL>        return null;<EOL>    }<EOL>    <EOL>    if (options && options.supportSideBySide && editor instanceof SideBySideEditorInput) {<EOL>        editor = editor.master;<EOL>    }<EOL>    const resource = editor.getResource();<EOL>    if (!options || !options.filter) {<EOL>        return resource; <EOL>    }<EOL>    if (!resource) {<EOL>","gt":"return null;"}
{"input":"<s> export function toResource(editor: IEditorInput, options?: IResourceOptions): URI {<EOL>    if (!editor) {<EOL>        return null;<EOL>    }<EOL>    <EOL>    if (options && options.supportSideBySide && editor instanceof SideBySideEditorInput) {<EOL>        editor = editor.master;<EOL>    }<EOL>    const resource = editor.getResource();<EOL>    if (!options || !options.filter) {<EOL>        return resource; <EOL>    }<EOL>    if (!resource) {<EOL>        return null;<EOL>    }<EOL>    let includeFiles: boolean;<EOL>    let includeUntitled: boolean;<EOL>    if (Array.isArray(options.","gt":"filter)) {"}
{"input":"<s> export function big(className?: string): VNode<HTMLElementProps | null> {<EOL>    return new VNode(VNodeFlags.Element, \"<STR_LIT>\", null, className === undefined ? null :","gt":"className, null, \"<STR_LIT>\");"}
{"input":"<s> export function elementSetAttributeNS(el: Element, namespace: string, name: string, value: any): void {<EOL>    if (DEV) {<EOL>        el.","gt":"setAttributeNS(namespace, name, value);"}
{"input":"<s> /**<EOL> * Makes documentation string from symbol display part array returned by TS<EOL> */<EOL>export function docstring(parts: ts.SymbolDisplayPart[]): string {<EOL>","gt":"return ts.displayPartsToString(parts);"}
{"input":"<s> export function isJSTSFile(filename: string): boolean {<EOL>    return","gt":"jstsPattern.test(filename);"}
{"input":"<s> export function isConfigFile(filename: string): boolean {<EOL>    return jstsConfigPattern.test(","gt":"filename);"}
{"input":"<s> <EOL><EOL><EOL><EOL><EOL><EOL>export function isGlobalTSFile(filename: string): boolean {<EOL>    for (const globalTSPattern of globalTSPatterns) {<EOL>","gt":"if (globalTSPattern.test(filename)) {"}
{"input":"<s> export async function sleep(timeout: number) {<EOL>    return new Promise(resolve => setTimeout(","gt":"resolve, timeout));"}
{"input":"<s> /**<EOL> * @license<EOL> * Copyright Google Inc. All Rights Reserved.<EOL> *<EOL> * Use of this source code is governed by an MIT-style license that can be<EOL> * found in the LICENSE file at https://angular.io/license<EOL> */<EOL><EOL><EOL>function plural(n: number): number {<EOL>    let i = Math.floor(Math.abs(n)), v = n.toString().replace(/^[^.]*\\.?/, '<STR_LIT>').length;<EOL>    if (i === <NUM_LIT> && v ===","gt":"<NUM_LIT>)"}
{"input":"<s> /**<EOL> * Walks a NaviationTree and emits items with a node and its parent node (if exists)<EOL> */<EOL>export function* walkNavigationTree(tree: ts.NavigationTree, parent?: ts.NavigationTree): IterableIterator<{<EOL>    tree: ts.NavigationTree;<EOL>    parent?: ts.NavigationTree;<EOL>}> {<EOL>    yield { tree, parent };<EOL>    for (const childItem of tree.","gt":"childItems || []) {"}
{"input":"<s> export function checkCancelled(token?: CancellationToken): void {<EOL>","gt":"if (!!token && token.isCancellationRequested) {"}
{"input":"<s> /**<EOL> * @license<EOL> * Copyright Google Inc. All Rights Reserved.<EOL> *<EOL> * Use of this source code is governed by an MIT-style license that can be<EOL> * found in the LICENSE file at https://angular.io/license<EOL> */<EOL><EOL><EOL>function plural(n: number): number {<EOL>    let f = parseInt(n.toString().replace(/^[^.]*\\.?/, '<STR_LIT>'), <NUM_LIT>) || <NUM_LIT>;<EOL>    if (n % <NUM_LIT> === <NUM_LIT> && !(n % <NUM_LIT> >= <NUM_LIT> && n % <NUM_LIT> <= <NUM_LIT>))<EOL>        return","gt":"<NUM_LIT>;"}
{"input":"<s> export function test_isRunning_withReentrancy() {<EOL>    resetProfiles();<EOL>    const name = \"<STR_LIT>\";<EOL>    assertFalse(isRunning(name), \"<STR_LIT>\");<EOL>    start(","gt":"name);"}
{"input":"<s> export function test_isRunning_withReentrancy() {<EOL>    resetProfiles();<EOL>    const name = \"<STR_LIT>\";<EOL>    assertFalse(isRunning(name), \"<STR_LIT>\");<EOL>    start(name);<EOL>    assertTrue(isRunning(name), \"<STR_LIT>\");<EOL>    start(name);<EOL>    assertTrue(isRunning(name), \"<STR_LIT>\");<EOL>    stop(name);<EOL>","gt":"assertTrue(isRunning(name), \"<STR_LIT>\");"}
{"input":"<s> /**<EOL> * HISTORICAL CONTEXT: We once stored user settings (like map zoom level) in localStorage and<EOL> *    would retrieve values via `Session.getBool(\"zoom_level\")`<EOL> *<EOL> * PROBLEM: localStorage is no longer used. Many parts of the app were accessing<EOL> *          values in places that did not have access to the Redux store.<EOL> *<EOL> * SOLUTION: Create a temporary shim that will \"cheat\" and directly call Redux<EOL> *           store without a lot of boilerplate props passing.<EOL> *<EOL> * WHY NOT JUST INLINE THESE FUNCTIONS?: It's easier to stub out calls in tests<EOL> *                                       that already exist.<EOL> */<EOL>/** Avoid using this function in new places. Pass props instead. */<EOL>export function getBoolViaRedux(key: BooleanConfigKey): boolean | undefined {<EOL>    const conf = getWebAppConfig(store.getState().resources.","gt":"index);"}
{"input":"<s> export function test_Transitions() {<EOL>    const topmost = topmostFrame();<EOL>    const mainTestPage = topmost.currentPage;<EOL>    const mainPageFactory = function (): Page {<EOL>        return mainTestPage;<EOL>    };<EOL>    helper.navigate(() => {<EOL>        const page = new Page();<EOL>        page.id = \"<STR_LIT>\";<EOL>        page.style.backgroundColor = new Color(<NUM_LIT>, Math.round(Math.random() * <NUM_LIT>),","gt":"Math.round(Math.random() * <NUM_LIT>), Math.round(Math.random() * <NUM_LIT>));"}
{"input":"<s> export function test_Transitions() {<EOL>    const topmost = topmostFrame();<EOL>    const mainTestPage = topmost.currentPage;<EOL>    const mainPageFactory = function (): Page {<EOL>        return mainTestPage;<EOL>    };<EOL>    helper.navigate(() => {<EOL>        const page = new Page();<EOL>        page.id = \"<STR_LIT>\";<EOL>        page.style.backgroundColor = new Color(<NUM_LIT>, Math.round(Math.random() * <NUM_LIT>), Math.round(Math.random() * <NUM_LIT>), Math.round(Math.random() * <NUM_LIT>));<EOL>        return page;<EOL>    });<EOL>","gt":"var transitions;"}
{"input":"<s> export function discard(className?: string): VNode<SVGElementProps | null, SVGElement> {<EOL>    return new VNode(VNodeFlags.Element | VNodeFlags.","gt":"SvgElement, \"<STR_LIT>\", null, className === undefined ? null : className, null);"}
{"input":"<s> /**<EOL> * linkBlueprint links blueprint to a component factory.<EOL> *<EOL> * Linked blueprint will be automatically for rendering components produced from this factory.<EOL> *<EOL> * @param componentFactory Component factory.<EOL> * @param blueprint Blueprint node.<EOL> */<EOL>export function linkBlueprint<P>(componentFactory: (props?: P) => VNode<P>, blueprint: BlueprintNode): void {<EOL>    (componentFactory","gt":"as any).linkBlueprint(blueprint);"}
{"input":"<s> function addFrameTaskUpdate(frame: FrameTasksGroup): void {<EOL>    frame.flags |=","gt":"FrameTasksGroupFlags.Update;"}
{"input":"<s> <EOL>export function saveZoomLevelIndex(index: number) {<EOL>    const payload =","gt":"index - zoomLevel1Index + <NUM_LIT>;"}
{"input":"<s> function addFrameTaskRead(frame: FrameTasksGroup, task: () => void): void {<EOL>    frame.flags |= FrameTasksGroupFlags.","gt":"Read;"}
{"input":"<s> export function pushWeek() {<EOL>    return {<EOL>        type: Actions.","gt":"PUSH_WEEK,"}
{"input":"<s> export function CreatePythonThread(id: number, isWorker: boolean, process: IPythonProcess, name: string = '<STR_LIT>', int32Id: number = <NUM_LIT>): IPythonThread {<EOL>    return {<EOL>        IsWorkerThread: isWorker,<EOL>","gt":"Process: process,"}
{"input":"<s> export function CreateLaunchDebugClient(launchRequestOptions: LaunchRequestArguments, debugSession: DebugSession, canLaunchTerminal: boolean): DebugClient<{}> {<EOL>    if (launchRequestOptions.noDebug === true) {<EOL>        return new NonDebugClient(launchRequestOptions, debugSession, canLaunchTerminal, new","gt":"NoDebugLauncherScriptProvider());"}
{"input":"<s> export function Optional(name?: string): Function {<EOL>","gt":"return (target: any, propertyKey: string, descriptor: PropertyDescriptor) => {"}
{"input":"<s> export function onTap(args) {<EOL>    const view = args.object as View;<EOL>    const page =","gt":"view.page;"}
{"input":"<s> /**<EOL> * firstLeaf finds a first leaf node.<EOL> *<EOL> * @param node DOM Node.<EOL> * @return A leaf node.<EOL> */<EOL>export function firstLeaf(node: Node): Node {<EOL>    while (node !== null) {<EOL>        const next = node.firstChild;<EOL>        if (next === null) {<EOL>","gt":"break;"}
{"input":"<s> export async function throws(testContext, func, error) {<EOL>    try {<EOL>        await func();<EOL>","gt":"testContext.fail('<STR_LIT>');"}
{"input":"<s> function shouldSupport(t, userAgent: BrowserUserAgent) {<EOL>","gt":"setUserAgent(userAgent);"}
{"input":"<s> /**<EOL> * @license<EOL> * Copyright Google Inc. All Rights Reserved.<EOL> *<EOL> * Use of this source code is governed by an MIT-style license that can be<EOL> * found in the LICENSE file at https://angular.io/license<EOL> */<EOL><EOL><EOL>function plural(n: number): number {<EOL>","gt":"if (n === <NUM_LIT>)"}
{"input":"<s> function replaceWildCardCharacterFiles(match: string) {<EOL>    return","gt":"replaceWildcardCharacter(match, singleAsteriskRegexFragmentFiles);"}
{"input":"<s> function deployAr(ar: ApiRequest, isScript: boolean) {<EOL>    var final = (err, resp) => {<EOL>        if (err)<EOL>            ar.ok({","gt":"status: \"<STR_LIT>\", message: err + \"<STR_LIT>\" });"}
{"input":"<s> function deployAr(ar: ApiRequest, isScript: boolean) {<EOL>    var final = (err, resp) => {<EOL>        if (err)<EOL>            ar.ok({ status: \"<STR_LIT>\", message: err + \"<STR_LIT>\" });<EOL>        else<EOL>            ar.ok(resp);<EOL>    };<EOL>    if (isScript && blobChannel) {<EOL>        var n = Math.round((Date.now() / <NUM_LIT>));<EOL>        var did = crypto.randomBytes(<NUM_LIT>).toString(\"<STR_LIT>\");<EOL>","gt":"var id = (<NUM_LIT> - n) + \"<STR_LIT>\" + crypto.randomBytes(<NUM_LIT>).toString(\"<STR_LIT>\");"}
{"input":"<s> function deployAr(ar: ApiRequest, isScript: boolean) {<EOL>    var final = (err, resp) => {<EOL>        if (err)<EOL>            ar.ok({ status: \"<STR_LIT>\", message: err + \"<STR_LIT>\" });<EOL>        else<EOL>            ar.ok(resp);<EOL>    };<EOL>    if (isScript && blobChannel) {<EOL>        var n = Math.round((Date.now() / <NUM_LIT>));<EOL>        var did = crypto.randomBytes(<NUM_LIT>).toString(\"<STR_LIT>\");<EOL>        var id = (<NUM_LIT> - n) + \"<STR_LIT>\" + crypto.randomBytes(<NUM_LIT>).toString(\"<STR_LIT>\");<EOL>        setBlobJson(id, ar.data, err => {<EOL>            if (err)<EOL>                ar.exception(err);<EOL>            else<EOL>                setBlobJson(\"<STR_LIT>\" + blobChannel, {<EOL>                    blob: id,<EOL>                    time: n,<EOL>                    did:","gt":"did,"}
{"input":"<s> /**<EOL> * Converts a diagnostic category to an LSP DiagnosticSeverity<EOL> *<EOL> * @param category The Typescript DiagnosticCategory<EOL> */<EOL>function convertDiagnosticCategory(category: ts.DiagnosticCategory): DiagnosticSeverity {<EOL>    switch (category) {<EOL>        case ts.DiagnosticCategory.Error:<EOL>            return DiagnosticSeverity.","gt":"Error;"}
{"input":"<s> /**<EOL> * @license<EOL> * Copyright Google Inc. All Rights Reserved.<EOL> *<EOL> * Use of this source code is governed by an MIT-style license that can be<EOL> * found in the LICENSE file at https://angular.io/license<EOL> */<EOL><EOL><EOL>function plural(n: number): number {<EOL>","gt":"return <NUM_LIT>;"}
{"input":"<s> export function setSequence(uuid: string): ReduxAction<string> {<EOL>","gt":"assertUuid(\"<STR_LIT>\", uuid);"}
{"input":"<s> function velocityEstimate(pixelsPerSecond: Vec2, confidence: number, duration: number, offset: Vec2): VelocityEstimate {<EOL>    return { pixelsPerSecond, confidence,","gt":"duration, offset };"}
{"input":"<s> /**<EOL> * Used for VAPID, converts a browser-provided ArrayBuffer of the applicationServerKey back to its string form.<EOL> */<EOL>export function arrayBufferToBase64(arrayBuffer: ArrayBuffer): string {<EOL>    var base64 = '<STR_LIT>';<EOL>    var encodings = '<STR_LIT>';<EOL>    var bytes = new Uint8Array(arrayBuffer);<EOL>    var byteLength =","gt":"bytes.byteLength;"}
{"input":"<s> /**<EOL> * Used for VAPID, converts a browser-provided ArrayBuffer of the applicationServerKey back to its string form.<EOL> */<EOL>export function arrayBufferToBase64(arrayBuffer: ArrayBuffer): string {<EOL>    var base64 = '<STR_LIT>';<EOL>    var encodings = '<STR_LIT>';<EOL>    var bytes = new Uint8Array(arrayBuffer);<EOL>    var byteLength = bytes.byteLength;<EOL>    var","gt":"byteRemainder = byteLength % <NUM_LIT>;"}
{"input":"<s> /**<EOL> * Used for VAPID, converts a browser-provided ArrayBuffer of the applicationServerKey back to its string form.<EOL> */<EOL>export function arrayBufferToBase64(arrayBuffer: ArrayBuffer): string {<EOL>    var base64 = '<STR_LIT>';<EOL>    var encodings = '<STR_LIT>';<EOL>    var bytes = new Uint8Array(arrayBuffer);<EOL>    var byteLength = bytes.byteLength;<EOL>    var byteRemainder = byteLength % <NUM_LIT>;<EOL>    var mainLength = byteLength - byteRemainder;<EOL>    var a, b,","gt":"c, d;"}
{"input":"<s> /**<EOL> * Used for VAPID, converts a browser-provided ArrayBuffer of the applicationServerKey back to its string form.<EOL> */<EOL>export function arrayBufferToBase64(arrayBuffer: ArrayBuffer): string {<EOL>    var base64 = '<STR_LIT>';<EOL>    var encodings = '<STR_LIT>';<EOL>    var bytes = new Uint8Array(arrayBuffer);<EOL>    var byteLength = bytes.byteLength;<EOL>    var byteRemainder = byteLength % <NUM_LIT>;<EOL>    var mainLength = byteLength - byteRemainder;<EOL>    var a, b, c, d;<EOL>    var chunk;<EOL>    <EOL>    for (var i = <NUM_LIT>; i < mainLength; i = i + <NUM_LIT>) {<EOL>        <EOL>        chunk = (bytes[i] <<","gt":"<NUM_LIT>) | (bytes[i + <NUM_LIT>] << <NUM_LIT>) | bytes[i + <NUM_LIT>];"}
{"input":"<s> /**<EOL> * Used for VAPID, converts a browser-provided ArrayBuffer of the applicationServerKey back to its string form.<EOL> */<EOL>export function arrayBufferToBase64(arrayBuffer: ArrayBuffer): string {<EOL>    var base64 = '<STR_LIT>';<EOL>    var encodings = '<STR_LIT>';<EOL>    var bytes = new Uint8Array(arrayBuffer);<EOL>    var byteLength = bytes.byteLength;<EOL>    var byteRemainder = byteLength % <NUM_LIT>;<EOL>    var mainLength = byteLength - byteRemainder;<EOL>    var a, b, c, d;<EOL>    var chunk;<EOL>    <EOL>    for (var i = <NUM_LIT>; i < mainLength; i = i + <NUM_LIT>) {<EOL>        <EOL>        chunk = (bytes[i] << <NUM_LIT>) | (bytes[i + <NUM_LIT>] << <NUM_LIT>) | bytes[i + <NUM_LIT>];<EOL>        <EOL>        a = (chunk & <NUM_LIT>) >> <NUM_LIT>; <EOL>        b = (chunk & <NUM_LIT>) >> <NUM_LIT>; <EOL>","gt":"c = (chunk & <NUM_LIT>) >> <NUM_LIT>;"}
{"input":"<s> /**<EOL> * Used for VAPID, converts a browser-provided ArrayBuffer of the applicationServerKey back to its string form.<EOL> */<EOL>export function arrayBufferToBase64(arrayBuffer: ArrayBuffer): string {<EOL>    var base64 = '<STR_LIT>';<EOL>    var encodings = '<STR_LIT>';<EOL>    var bytes = new Uint8Array(arrayBuffer);<EOL>    var byteLength = bytes.byteLength;<EOL>    var byteRemainder = byteLength % <NUM_LIT>;<EOL>    var mainLength = byteLength - byteRemainder;<EOL>    var a, b, c, d;<EOL>    var chunk;<EOL>    <EOL>    for (var i = <NUM_LIT>; i < mainLength; i = i + <NUM_LIT>) {<EOL>        <EOL>        chunk = (bytes[i] << <NUM_LIT>) | (bytes[i + <NUM_LIT>] << <NUM_LIT>) | bytes[i + <NUM_LIT>];<EOL>        <EOL>        a = (chunk & <NUM_LIT>) >> <NUM_LIT>; <EOL>        b = (chunk & <NUM_LIT>) >> <NUM_LIT>; <EOL>        c = (chunk & <NUM_LIT>) >> <NUM_LIT>; <EOL>        d = chunk & <NUM_LIT>; <EOL>        <EOL>        base64 += encodings[a] + encodings[b] + encodings[c] + encodings[","gt":"d];"}
{"input":"<s> export function print(name: string): TimerInfo {<EOL>    const info = timers[name];<EOL>","gt":"if (!info) {"}
{"input":"<s> /**<EOL> * isTextVNode returns `true` when VNode is a Text node.<EOL> *<EOL> * @param node VNode.<EOL> * @returns `true` when VNode is a Text node.<EOL> */<EOL>export function isTextVNode(node: VNode<any>): boolean {<EOL>    return (","gt":"node._flags & VNodeFlags.Text) !== <NUM_LIT>;"}
{"input":"<s> export function dl(className?: string): VNode<HTMLDListElementProps | null, HTMLDListElement> {<EOL>    return new VNode(VNodeFlags.Element, \"<STR_LIT>\",","gt":"null, className === undefined ? null : className, null);"}
{"input":"<s> export function big(className?: string): VNode<HTMLElementProps | null, HTMLElement> {<EOL>    return new","gt":"VNode(VNodeFlags.Element, \"<STR_LIT>\", null, className === undefined ? null : className, null);"}
{"input":"<s> <EOL>/**<EOL> * Get function name.<EOL> *<EOL> * @param fn Function.<EOL> * @returns Function name.<EOL> */<EOL>export function getFunctionName(fn: Function): string {<EOL>    return fn.displayName ||","gt":"fn.name || \"<STR_LIT>\";"}
{"input":"<s> /**<EOL> * isComponentVNode returns `true` when VNode is a Component node.<EOL> *<EOL> * @param node VNode.<EOL> * @returns `true` when VNode is a Component node.<EOL> */<EOL>export function isComponentVNode(node: VNode<any>): boolean {<EOL>    return (node.","gt":"_flags & VNodeFlags.Component) !== <NUM_LIT>;"}
{"input":"<s> export function feOffset(className?: string): VNode<SVGFEOffsetElementProps | null> {<EOL>    return new VNode(VNodeFlags.Element | VNodeFlags.SvgElement,","gt":"\"<STR_LIT>\", null, className === undefined ? null : className, null, \"<STR_LIT>\");"}
{"input":"<s> function plural_en_CA(n: number): number {<EOL>    let i = Math.floor(Math.abs(n)), v = n.toString().replace(/^[^.]*\\.?/, '<STR_LIT>').length;<EOL>    if (i ===","gt":"<NUM_LIT> && v === <NUM_LIT>)"}
{"input":"<s> function plural_sk(n: number): number {<EOL>    let i = Math.floor(Math.abs(n)), v = n.toString().replace(/^[^.]*\\.?/, '<STR_LIT>').length;<EOL>    if (i === <NUM_LIT> && v === <NUM_LIT>)<EOL>","gt":"return <NUM_LIT>;"}
{"input":"<s> export function setColorWithParents(counts: Array<number>, parent: LayoutBase): string {<EOL>    let result = `<STR_LIT>`;<EOL>    const style = parent.style;<EOL>    counts.forEach((count) => {<EOL>        if (count > <NUM_LIT>) {<EOL>            result +=","gt":"setResultTime(noValue);"}
{"input":"<s> export function setColorWithParents(counts: Array<number>, parent: LayoutBase): string {<EOL>    let result = `<STR_LIT>`;<EOL>    const style = parent.style;<EOL>    counts.forEach((count) => {<EOL>        if (count > <NUM_LIT>) {<EOL>            result += setResultTime(noValue);<EOL>            return;<EOL>        }<EOL>        setupParents(parent);<EOL>        const time =","gt":"executeTest(() => {"}
{"input":"<s> function submitJob(taskOptions: TaskOptions): Q.Promise<string> {<EOL>    const defer: Q.Deferred<string> = Q.defer<string>();<EOL>    tl.debug('<STR_LIT>' + JSON.stringify(taskOptions));<EOL>    function addCrumb(json: any): any {<EOL>        if (taskOptions.","gt":"crumb && taskOptions.crumb != taskOptions.NO_CRUMB) {"}
{"input":"<s> function submitJob(taskOptions: TaskOptions): Q.Promise<string> {<EOL>    const defer: Q.Deferred<string> = Q.defer<string>();<EOL>    tl.debug('<STR_LIT>' + JSON.stringify(taskOptions));<EOL>    function addCrumb(json: any): any {<EOL>        if (taskOptions.crumb && taskOptions.crumb != taskOptions.NO_CRUMB) {<EOL>            json.headers = {};<EOL>            const splitIndex: number = taskOptions.crumb.indexOf('<STR_LIT>');<EOL>            const crumbName: string = taskOptions.","gt":"crumb.substr(<NUM_LIT>, splitIndex);"}
{"input":"<s> function submitJob(taskOptions: TaskOptions): Q.Promise<string> {<EOL>    const defer: Q.Deferred<string> = Q.defer<string>();<EOL>    tl.debug('<STR_LIT>' + JSON.stringify(taskOptions));<EOL>    function addCrumb(json: any): any {<EOL>        if (taskOptions.crumb && taskOptions.crumb != taskOptions.NO_CRUMB) {<EOL>            json.headers = {};<EOL>            const splitIndex: number = taskOptions.crumb.indexOf('<STR_LIT>');<EOL>            const crumbName: string = taskOptions.crumb.substr(<NUM_LIT>, splitIndex);<EOL>            const crumbValue: string = taskOptions.crumb.slice(splitIndex + <NUM_LIT>);<EOL>            json.headers[crumbName] = crumbValue;<EOL>        }<EOL>        return json;<EOL>    }<EOL>    const teamBuildPostData: any = addCrumb({<EOL>        url: taskOptions.teamJobQueueUrl,<EOL>","gt":"form: {"}
{"input":"<s> function submitJob(taskOptions: TaskOptions): Q.Promise<string> {<EOL>    const defer: Q.Deferred<string> = Q.defer<string>();<EOL>    tl.debug('<STR_LIT>' + JSON.stringify(taskOptions));<EOL>    function addCrumb(json: any): any {<EOL>        if (taskOptions.crumb && taskOptions.crumb != taskOptions.NO_CRUMB) {<EOL>            json.headers = {};<EOL>            const splitIndex: number = taskOptions.crumb.indexOf('<STR_LIT>');<EOL>            const crumbName: string = taskOptions.crumb.substr(<NUM_LIT>, splitIndex);<EOL>            const crumbValue: string = taskOptions.crumb.slice(splitIndex + <NUM_LIT>);<EOL>            json.headers[crumbName] = crumbValue;<EOL>        }<EOL>        return json;<EOL>    }<EOL>    const teamBuildPostData: any = addCrumb({<EOL>        url: taskOptions.teamJobQueueUrl,<EOL>        form: {<EOL>","gt":"json: JSON.stringify({"}
{"input":"<s> function submitJob(taskOptions: TaskOptions): Q.Promise<string> {<EOL>    const defer: Q.Deferred<string> = Q.defer<string>();<EOL>    tl.debug('<STR_LIT>' + JSON.stringify(taskOptions));<EOL>    function addCrumb(json: any): any {<EOL>        if (taskOptions.crumb && taskOptions.crumb != taskOptions.NO_CRUMB) {<EOL>            json.headers = {};<EOL>            const splitIndex: number = taskOptions.crumb.indexOf('<STR_LIT>');<EOL>            const crumbName: string = taskOptions.crumb.substr(<NUM_LIT>, splitIndex);<EOL>            const crumbValue: string = taskOptions.crumb.slice(splitIndex + <NUM_LIT>);<EOL>            json.headers[crumbName] = crumbValue;<EOL>        }<EOL>        return json;<EOL>    }<EOL>    const teamBuildPostData: any = addCrumb({<EOL>        url: taskOptions.teamJobQueueUrl,<EOL>        form: {<EOL>            json: JSON.stringify({<EOL>                '<STR_LIT>': getTeamParameters(taskOptions),<EOL>                '<STR_LIT>': parseJobParametersTeamBuild(taskOptions.jobParameters)<EOL>            })<EOL>        },<EOL>        strictSSL: taskOptions.strictSSL<EOL>    });<EOL>    tl.debug('<STR_LIT>' + JSON.stringify(teamBuildPostData));<EOL>    <EOL>    request.","gt":"post(teamBuildPostData, function teamBuildRequestCallback(err, httpResponse, body) {"}
{"input":"<s> function submitJob(taskOptions: TaskOptions): Q.Promise<string> {<EOL>    const defer: Q.Deferred<string> = Q.defer<string>();<EOL>    tl.debug('<STR_LIT>' + JSON.stringify(taskOptions));<EOL>    function addCrumb(json: any): any {<EOL>        if (taskOptions.crumb && taskOptions.crumb != taskOptions.NO_CRUMB) {<EOL>            json.headers = {};<EOL>            const splitIndex: number = taskOptions.crumb.indexOf('<STR_LIT>');<EOL>            const crumbName: string = taskOptions.crumb.substr(<NUM_LIT>, splitIndex);<EOL>            const crumbValue: string = taskOptions.crumb.slice(splitIndex + <NUM_LIT>);<EOL>            json.headers[crumbName] = crumbValue;<EOL>        }<EOL>        return json;<EOL>    }<EOL>    const teamBuildPostData: any = addCrumb({<EOL>        url: taskOptions.teamJobQueueUrl,<EOL>        form: {<EOL>            json: JSON.stringify({<EOL>                '<STR_LIT>': getTeamParameters(taskOptions),<EOL>                '<STR_LIT>': parseJobParametersTeamBuild(taskOptions.jobParameters)<EOL>            })<EOL>        },<EOL>        strictSSL: taskOptions.strictSSL<EOL>    });<EOL>    tl.debug('<STR_LIT>' + JSON.stringify(teamBuildPostData));<EOL>    <EOL>    request.post(teamBuildPostData, function teamBuildRequestCallback(err, httpResponse, body) {<EOL>        tl.debug('<STR_LIT>');<EOL>        if (err) {<EOL>            if (err.code == '<STR_LIT>') {<EOL>                tl.debug(err);<EOL>                defer.resolve(null);<EOL>            }<EOL>            else {<EOL>                defer.reject(err);<EOL>            }<EOL>        }<EOL>        else if (httpResponse.statusCode === <NUM_LIT>) { <EOL>            console.log('<STR_LIT>' + taskOptions.teamPluginUrl);<EOL>            taskOptions.teamBuildPluginAvailable = false;<EOL>            tl.debug('<STR_LIT>' + JSON.stringify(httpResponse));<EOL>            const jobQueuePostData: any = addCrumb(taskOptions.parameterizedJob ?<EOL>                {<EOL>                    url: taskOptions.jobQueueUrl,<EOL>                    formData: parseJobParameters(taskOptions.","gt":"jobParameters),"}
{"input":"<s> function submitJob(taskOptions: TaskOptions): Q.Promise<string> {<EOL>    const defer: Q.Deferred<string> = Q.defer<string>();<EOL>    tl.debug('<STR_LIT>' + JSON.stringify(taskOptions));<EOL>    function addCrumb(json: any): any {<EOL>        if (taskOptions.crumb && taskOptions.crumb != taskOptions.NO_CRUMB) {<EOL>            json.headers = {};<EOL>            const splitIndex: number = taskOptions.crumb.indexOf('<STR_LIT>');<EOL>            const crumbName: string = taskOptions.crumb.substr(<NUM_LIT>, splitIndex);<EOL>            const crumbValue: string = taskOptions.crumb.slice(splitIndex + <NUM_LIT>);<EOL>            json.headers[crumbName] = crumbValue;<EOL>        }<EOL>        return json;<EOL>    }<EOL>    const teamBuildPostData: any = addCrumb({<EOL>        url: taskOptions.teamJobQueueUrl,<EOL>        form: {<EOL>            json: JSON.stringify({<EOL>                '<STR_LIT>': getTeamParameters(taskOptions),<EOL>                '<STR_LIT>': parseJobParametersTeamBuild(taskOptions.jobParameters)<EOL>            })<EOL>        },<EOL>        strictSSL: taskOptions.strictSSL<EOL>    });<EOL>    tl.debug('<STR_LIT>' + JSON.stringify(teamBuildPostData));<EOL>    <EOL>    request.post(teamBuildPostData, function teamBuildRequestCallback(err, httpResponse, body) {<EOL>        tl.debug('<STR_LIT>');<EOL>        if (err) {<EOL>            if (err.code == '<STR_LIT>') {<EOL>                tl.debug(err);<EOL>                defer.resolve(null);<EOL>            }<EOL>            else {<EOL>                defer.reject(err);<EOL>            }<EOL>        }<EOL>        else if (httpResponse.statusCode === <NUM_LIT>) { <EOL>            console.log('<STR_LIT>' + taskOptions.teamPluginUrl);<EOL>            taskOptions.teamBuildPluginAvailable = false;<EOL>            tl.debug('<STR_LIT>' + JSON.stringify(httpResponse));<EOL>            const jobQueuePostData: any = addCrumb(taskOptions.parameterizedJob ?<EOL>                {<EOL>                    url: taskOptions.jobQueueUrl,<EOL>                    formData: parseJobParameters(taskOptions.jobParameters),<EOL>                    strictSSL: taskOptions.strictSSL<EOL>                } :<EOL>                {<EOL>                    url: taskOptions.jobQueueUrl,<EOL>","gt":"strictSSL: taskOptions.strictSSL"}
{"input":"<s> function submitJob(taskOptions: TaskOptions): Q.Promise<string> {<EOL>    const defer: Q.Deferred<string> = Q.defer<string>();<EOL>    tl.debug('<STR_LIT>' + JSON.stringify(taskOptions));<EOL>    function addCrumb(json: any): any {<EOL>        if (taskOptions.crumb && taskOptions.crumb != taskOptions.NO_CRUMB) {<EOL>            json.headers = {};<EOL>            const splitIndex: number = taskOptions.crumb.indexOf('<STR_LIT>');<EOL>            const crumbName: string = taskOptions.crumb.substr(<NUM_LIT>, splitIndex);<EOL>            const crumbValue: string = taskOptions.crumb.slice(splitIndex + <NUM_LIT>);<EOL>            json.headers[crumbName] = crumbValue;<EOL>        }<EOL>        return json;<EOL>    }<EOL>    const teamBuildPostData: any = addCrumb({<EOL>        url: taskOptions.teamJobQueueUrl,<EOL>        form: {<EOL>            json: JSON.stringify({<EOL>                '<STR_LIT>': getTeamParameters(taskOptions),<EOL>                '<STR_LIT>': parseJobParametersTeamBuild(taskOptions.jobParameters)<EOL>            })<EOL>        },<EOL>        strictSSL: taskOptions.strictSSL<EOL>    });<EOL>    tl.debug('<STR_LIT>' + JSON.stringify(teamBuildPostData));<EOL>    <EOL>    request.post(teamBuildPostData, function teamBuildRequestCallback(err, httpResponse, body) {<EOL>        tl.debug('<STR_LIT>');<EOL>        if (err) {<EOL>            if (err.code == '<STR_LIT>') {<EOL>                tl.debug(err);<EOL>                defer.resolve(null);<EOL>            }<EOL>            else {<EOL>                defer.reject(err);<EOL>            }<EOL>        }<EOL>        else if (httpResponse.statusCode === <NUM_LIT>) { <EOL>            console.log('<STR_LIT>' + taskOptions.teamPluginUrl);<EOL>            taskOptions.teamBuildPluginAvailable = false;<EOL>            tl.debug('<STR_LIT>' + JSON.stringify(httpResponse));<EOL>            const jobQueuePostData: any = addCrumb(taskOptions.parameterizedJob ?<EOL>                {<EOL>                    url: taskOptions.jobQueueUrl,<EOL>                    formData: parseJobParameters(taskOptions.jobParameters),<EOL>                    strictSSL: taskOptions.strictSSL<EOL>                } :<EOL>                {<EOL>                    url: taskOptions.jobQueueUrl,<EOL>                    strictSSL: taskOptions.strictSSL<EOL>                });<EOL>            tl.debug('<STR_LIT>' + JSON.stringify(jobQueuePostData));<EOL>            request.post(jobQueuePostData, function jobQueueRequestCallback(err,","gt":"httpResponse, body) {"}
{"input":"<s> function submitJob(taskOptions: TaskOptions): Q.Promise<string> {<EOL>    const defer: Q.Deferred<string> = Q.defer<string>();<EOL>    tl.debug('<STR_LIT>' + JSON.stringify(taskOptions));<EOL>    function addCrumb(json: any): any {<EOL>        if (taskOptions.crumb && taskOptions.crumb != taskOptions.NO_CRUMB) {<EOL>            json.headers = {};<EOL>            const splitIndex: number = taskOptions.crumb.indexOf('<STR_LIT>');<EOL>            const crumbName: string = taskOptions.crumb.substr(<NUM_LIT>, splitIndex);<EOL>            const crumbValue: string = taskOptions.crumb.slice(splitIndex + <NUM_LIT>);<EOL>            json.headers[crumbName] = crumbValue;<EOL>        }<EOL>        return json;<EOL>    }<EOL>    const teamBuildPostData: any = addCrumb({<EOL>        url: taskOptions.teamJobQueueUrl,<EOL>        form: {<EOL>            json: JSON.stringify({<EOL>                '<STR_LIT>': getTeamParameters(taskOptions),<EOL>                '<STR_LIT>': parseJobParametersTeamBuild(taskOptions.jobParameters)<EOL>            })<EOL>        },<EOL>        strictSSL: taskOptions.strictSSL<EOL>    });<EOL>    tl.debug('<STR_LIT>' + JSON.stringify(teamBuildPostData));<EOL>    <EOL>    request.post(teamBuildPostData, function teamBuildRequestCallback(err, httpResponse, body) {<EOL>        tl.debug('<STR_LIT>');<EOL>        if (err) {<EOL>            if (err.code == '<STR_LIT>') {<EOL>                tl.debug(err);<EOL>                defer.resolve(null);<EOL>            }<EOL>            else {<EOL>                defer.reject(err);<EOL>            }<EOL>        }<EOL>        else if (httpResponse.statusCode === <NUM_LIT>) { <EOL>            console.log('<STR_LIT>' + taskOptions.teamPluginUrl);<EOL>            taskOptions.teamBuildPluginAvailable = false;<EOL>            tl.debug('<STR_LIT>' + JSON.stringify(httpResponse));<EOL>            const jobQueuePostData: any = addCrumb(taskOptions.parameterizedJob ?<EOL>                {<EOL>                    url: taskOptions.jobQueueUrl,<EOL>                    formData: parseJobParameters(taskOptions.jobParameters),<EOL>                    strictSSL: taskOptions.strictSSL<EOL>                } :<EOL>                {<EOL>                    url: taskOptions.jobQueueUrl,<EOL>                    strictSSL: taskOptions.strictSSL<EOL>                });<EOL>            tl.debug('<STR_LIT>' + JSON.stringify(jobQueuePostData));<EOL>            request.post(jobQueuePostData, function jobQueueRequestCallback(err, httpResponse, body) {<EOL>                tl.debug('<STR_LIT>');<EOL>                if (err) {<EOL>                    if (err.code == '<STR_LIT>') {<EOL>                        tl.debug(err);<EOL>                        defer.resolve(null);<EOL>                    }<EOL>                    else {<EOL>                        defer.reject(","gt":"err);"}
{"input":"<s> function submitJob(taskOptions: TaskOptions): Q.Promise<string> {<EOL>    const defer: Q.Deferred<string> = Q.defer<string>();<EOL>    tl.debug('<STR_LIT>' + JSON.stringify(taskOptions));<EOL>    function addCrumb(json: any): any {<EOL>        if (taskOptions.crumb && taskOptions.crumb != taskOptions.NO_CRUMB) {<EOL>            json.headers = {};<EOL>            const splitIndex: number = taskOptions.crumb.indexOf('<STR_LIT>');<EOL>            const crumbName: string = taskOptions.crumb.substr(<NUM_LIT>, splitIndex);<EOL>            const crumbValue: string = taskOptions.crumb.slice(splitIndex + <NUM_LIT>);<EOL>            json.headers[crumbName] = crumbValue;<EOL>        }<EOL>        return json;<EOL>    }<EOL>    const teamBuildPostData: any = addCrumb({<EOL>        url: taskOptions.teamJobQueueUrl,<EOL>        form: {<EOL>            json: JSON.stringify({<EOL>                '<STR_LIT>': getTeamParameters(taskOptions),<EOL>                '<STR_LIT>': parseJobParametersTeamBuild(taskOptions.jobParameters)<EOL>            })<EOL>        },<EOL>        strictSSL: taskOptions.strictSSL<EOL>    });<EOL>    tl.debug('<STR_LIT>' + JSON.stringify(teamBuildPostData));<EOL>    <EOL>    request.post(teamBuildPostData, function teamBuildRequestCallback(err, httpResponse, body) {<EOL>        tl.debug('<STR_LIT>');<EOL>        if (err) {<EOL>            if (err.code == '<STR_LIT>') {<EOL>                tl.debug(err);<EOL>                defer.resolve(null);<EOL>            }<EOL>            else {<EOL>                defer.reject(err);<EOL>            }<EOL>        }<EOL>        else if (httpResponse.statusCode === <NUM_LIT>) { <EOL>            console.log('<STR_LIT>' + taskOptions.teamPluginUrl);<EOL>            taskOptions.teamBuildPluginAvailable = false;<EOL>            tl.debug('<STR_LIT>' + JSON.stringify(httpResponse));<EOL>            const jobQueuePostData: any = addCrumb(taskOptions.parameterizedJob ?<EOL>                {<EOL>                    url: taskOptions.jobQueueUrl,<EOL>                    formData: parseJobParameters(taskOptions.jobParameters),<EOL>                    strictSSL: taskOptions.strictSSL<EOL>                } :<EOL>                {<EOL>                    url: taskOptions.jobQueueUrl,<EOL>                    strictSSL: taskOptions.strictSSL<EOL>                });<EOL>            tl.debug('<STR_LIT>' + JSON.stringify(jobQueuePostData));<EOL>            request.post(jobQueuePostData, function jobQueueRequestCallback(err, httpResponse, body) {<EOL>                tl.debug('<STR_LIT>');<EOL>                if (err) {<EOL>                    if (err.code == '<STR_LIT>') {<EOL>                        tl.debug(err);<EOL>                        defer.resolve(null);<EOL>                    }<EOL>                    else {<EOL>                        defer.reject(err);<EOL>                    }<EOL>                }<EOL>                else if (httpResponse.statusCode != <NUM_LIT>) {<EOL>                    defer.reject(getFullErrorMessage(httpResponse, '<STR_LIT>'));<EOL>                }<EOL>                else {<EOL>","gt":"const queueUri: string = addUrlSegment(httpResponse.headers.location,"}
{"input":"<s> function submitJob(taskOptions: TaskOptions): Q.Promise<string> {<EOL>    const defer: Q.Deferred<string> = Q.defer<string>();<EOL>    tl.debug('<STR_LIT>' + JSON.stringify(taskOptions));<EOL>    function addCrumb(json: any): any {<EOL>        if (taskOptions.crumb && taskOptions.crumb != taskOptions.NO_CRUMB) {<EOL>            json.headers = {};<EOL>            const splitIndex: number = taskOptions.crumb.indexOf('<STR_LIT>');<EOL>            const crumbName: string = taskOptions.crumb.substr(<NUM_LIT>, splitIndex);<EOL>            const crumbValue: string = taskOptions.crumb.slice(splitIndex + <NUM_LIT>);<EOL>            json.headers[crumbName] = crumbValue;<EOL>        }<EOL>        return json;<EOL>    }<EOL>    const teamBuildPostData: any = addCrumb({<EOL>        url: taskOptions.teamJobQueueUrl,<EOL>        form: {<EOL>            json: JSON.stringify({<EOL>                '<STR_LIT>': getTeamParameters(taskOptions),<EOL>                '<STR_LIT>': parseJobParametersTeamBuild(taskOptions.jobParameters)<EOL>            })<EOL>        },<EOL>        strictSSL: taskOptions.strictSSL<EOL>    });<EOL>    tl.debug('<STR_LIT>' + JSON.stringify(teamBuildPostData));<EOL>    <EOL>    request.post(teamBuildPostData, function teamBuildRequestCallback(err, httpResponse, body) {<EOL>        tl.debug('<STR_LIT>');<EOL>        if (err) {<EOL>            if (err.code == '<STR_LIT>') {<EOL>                tl.debug(err);<EOL>                defer.resolve(null);<EOL>            }<EOL>            else {<EOL>                defer.reject(err);<EOL>            }<EOL>        }<EOL>        else if (httpResponse.statusCode === <NUM_LIT>) { <EOL>            console.log('<STR_LIT>' + taskOptions.teamPluginUrl);<EOL>            taskOptions.teamBuildPluginAvailable = false;<EOL>            tl.debug('<STR_LIT>' + JSON.stringify(httpResponse));<EOL>            const jobQueuePostData: any = addCrumb(taskOptions.parameterizedJob ?<EOL>                {<EOL>                    url: taskOptions.jobQueueUrl,<EOL>                    formData: parseJobParameters(taskOptions.jobParameters),<EOL>                    strictSSL: taskOptions.strictSSL<EOL>                } :<EOL>                {<EOL>                    url: taskOptions.jobQueueUrl,<EOL>                    strictSSL: taskOptions.strictSSL<EOL>                });<EOL>            tl.debug('<STR_LIT>' + JSON.stringify(jobQueuePostData));<EOL>            request.post(jobQueuePostData, function jobQueueRequestCallback(err, httpResponse, body) {<EOL>                tl.debug('<STR_LIT>');<EOL>                if (err) {<EOL>                    if (err.code == '<STR_LIT>') {<EOL>                        tl.debug(err);<EOL>                        defer.resolve(null);<EOL>                    }<EOL>                    else {<EOL>                        defer.reject(err);<EOL>                    }<EOL>                }<EOL>                else if (httpResponse.statusCode != <NUM_LIT>) {<EOL>                    defer.reject(getFullErrorMessage(httpResponse, '<STR_LIT>'));<EOL>                }<EOL>                else {<EOL>                    const queueUri: string = addUrlSegment(httpResponse.headers.location,","gt":"'<STR_LIT>');"}
{"input":"<s> function submitJob(taskOptions: TaskOptions): Q.Promise<string> {<EOL>    const defer: Q.Deferred<string> = Q.defer<string>();<EOL>    tl.debug('<STR_LIT>' + JSON.stringify(taskOptions));<EOL>    function addCrumb(json: any): any {<EOL>        if (taskOptions.crumb && taskOptions.crumb != taskOptions.NO_CRUMB) {<EOL>            json.headers = {};<EOL>            const splitIndex: number = taskOptions.crumb.indexOf('<STR_LIT>');<EOL>            const crumbName: string = taskOptions.crumb.substr(<NUM_LIT>, splitIndex);<EOL>            const crumbValue: string = taskOptions.crumb.slice(splitIndex + <NUM_LIT>);<EOL>            json.headers[crumbName] = crumbValue;<EOL>        }<EOL>        return json;<EOL>    }<EOL>    const teamBuildPostData: any = addCrumb({<EOL>        url: taskOptions.teamJobQueueUrl,<EOL>        form: {<EOL>            json: JSON.stringify({<EOL>                '<STR_LIT>': getTeamParameters(taskOptions),<EOL>                '<STR_LIT>': parseJobParametersTeamBuild(taskOptions.jobParameters)<EOL>            })<EOL>        },<EOL>        strictSSL: taskOptions.strictSSL<EOL>    });<EOL>    tl.debug('<STR_LIT>' + JSON.stringify(teamBuildPostData));<EOL>    <EOL>    request.post(teamBuildPostData, function teamBuildRequestCallback(err, httpResponse, body) {<EOL>        tl.debug('<STR_LIT>');<EOL>        if (err) {<EOL>            if (err.code == '<STR_LIT>') {<EOL>                tl.debug(err);<EOL>                defer.resolve(null);<EOL>            }<EOL>            else {<EOL>                defer.reject(err);<EOL>            }<EOL>        }<EOL>        else if (httpResponse.statusCode === <NUM_LIT>) { <EOL>            console.log('<STR_LIT>' + taskOptions.teamPluginUrl);<EOL>            taskOptions.teamBuildPluginAvailable = false;<EOL>            tl.debug('<STR_LIT>' + JSON.stringify(httpResponse));<EOL>            const jobQueuePostData: any = addCrumb(taskOptions.parameterizedJob ?<EOL>                {<EOL>                    url: taskOptions.jobQueueUrl,<EOL>                    formData: parseJobParameters(taskOptions.jobParameters),<EOL>                    strictSSL: taskOptions.strictSSL<EOL>                } :<EOL>                {<EOL>                    url: taskOptions.jobQueueUrl,<EOL>                    strictSSL: taskOptions.strictSSL<EOL>                });<EOL>            tl.debug('<STR_LIT>' + JSON.stringify(jobQueuePostData));<EOL>            request.post(jobQueuePostData, function jobQueueRequestCallback(err, httpResponse, body) {<EOL>                tl.debug('<STR_LIT>');<EOL>                if (err) {<EOL>                    if (err.code == '<STR_LIT>') {<EOL>                        tl.debug(err);<EOL>                        defer.resolve(null);<EOL>                    }<EOL>                    else {<EOL>                        defer.reject(err);<EOL>                    }<EOL>                }<EOL>                else if (httpResponse.statusCode != <NUM_LIT>) {<EOL>                    defer.reject(getFullErrorMessage(httpResponse, '<STR_LIT>'));<EOL>                }<EOL>                else {<EOL>                    const queueUri: string = addUrlSegment(httpResponse.headers.location, '<STR_LIT>');<EOL>                    defer.resolve(queueUri);<EOL>                }<EOL>            }).auth(taskOptions.username, taskOptions.password, true);<EOL>        }<EOL>","gt":"else if (httpResponse.statusCode != <NUM_LIT>) {"}
{"input":"<s> export function test_start_stop() {<EOL>    resetProfiles();<EOL>    const","gt":"name = \"<STR_LIT>\";"}
{"input":"<s> export function lazy<T>(getValue: () => T): Lazy<T> {<EOL>    return new LazyValue<T>(","gt":"getValue);"}
{"input":"<s> /**<EOL> * @license<EOL> * Copyright Google Inc. All Rights Reserved.<EOL> *<EOL> * Use of this source code is governed by an MIT-style license that can be<EOL> * found in the LICENSE file at https://angular.io/license<EOL> */<EOL><EOL><EOL>function plural(n: number): number {<EOL>    if (n ===","gt":"<NUM_LIT>)"}
{"input":"<s> export function fakeSequence(): TaggedSequence {<EOL>    return fakeResource(\"<STR_LIT>\", {<EOL>        args: {<EOL>            version: <NUM_LIT>,<EOL>            label:","gt":"\"<STR_LIT>\","}
{"input":"<s> export function fakeSequence(): TaggedSequence {<EOL>    return fakeResource(\"<STR_LIT>\", {<EOL>        args: {<EOL>            version: <NUM_LIT>,<EOL>            label: \"<STR_LIT>\",<EOL>            locals: { kind: \"<STR_LIT>\", args: {} },<EOL>        },<EOL>        id: <NUM_LIT>,<EOL>        color: \"<STR_LIT>\",<EOL>        name: \"<STR_LIT>\",<EOL>        kind:","gt":"\"<STR_LIT>\","}
{"input":"<s> export function feSpotLight(className?: string): VNode<SVGFESpotLightElementProps | null> {<EOL>    return new VNode(VNodeFlags.Element | VNodeFlags.","gt":"SvgElement, \"<STR_LIT>\", null, className === undefined ? null : className, null, \"<STR_LIT>\");"}
{"input":"<s> function HTTPIconFetch(slug: string) {<EOL>    const url = BASE + slug;<EOL>    if (promiseCache[url]) {<EOL>        return promiseCache[url];<EOL>    }<EOL>    else {<EOL>        promiseCache[url] = axios<EOL>            .get(url)<EOL>            .then(cacheTheIcon(slug),","gt":"cacheTheIcon(slug));"}
{"input":"<s> export function feTile(className?: string): VNode<SVGFETileElementProps | null, SVGFETileElement> {<EOL>    return new VNode(VNodeFlags.Element | VNodeFlags.SvgElement, \"<STR_LIT>\", null, className === undefined ? null : className,","gt":"null);"}
{"input":"<s> export function figure(className?: string): VNode<HTMLElementProps | null, HTMLElement> {<EOL>    return","gt":"new VNode(VNodeFlags.Element, \"<STR_LIT>\", null, className === undefined ? null : className, null);"}
{"input":"<s> export function font(className?: string): VNode<HTMLFontElementProps | null> {<EOL>    return new VNode(VNodeFlags.Element, \"<STR_LIT>\", null, className === undefined ? null : className, null,","gt":"\"<STR_LIT>\");"}
{"input":"<s> export function generateI18nConfig(lang: string): InitOptions {<EOL>    const translation = require(\"<STR_LIT>\" + lang + \"<STR_LIT>\");<EOL>    return {<EOL>","gt":"nsSeparator: \"<STR_LIT>\","}
{"input":"<s> export function refreshNO(payload: GeneralizedError): ReduxAction<GeneralizedError> {<EOL>    return { type:","gt":"Actions.REFRESH_RESOURCE_NO, payload };"}
{"input":"<s> export function moveRelative(props: MoveRelProps) {<EOL>    return","gt":"getDevice()"}
{"input":"<s> /**<EOL> * Helper method for public APIs that waits until OneSignal is initialized, rejects if push notifications are<EOL> * not supported, and wraps these tasks in a Promise.<EOL> */<EOL>export function awaitOneSignalInitAndSupported() {<EOL>    return new Promise(resolve => {<EOL>        if (!OneSignal.initialized) {<EOL>            OneSignal.once(OneSignal.EVENTS.SDK_INITIALIZED,","gt":"resolve);"}
{"input":"<s> export function h1(className?: string): VNode<HTMLHeadingElementProps | null, HTMLHeadingElement> {<EOL>    return new VNode(VNodeFlags.Element, \"<STR_LIT>\",","gt":"null, className === undefined ? null : className, null);"}
{"input":"<s> export function datalist(className?: string): VNode<HTMLDataListElementProps | null, HTMLDataListElement> {<EOL>    return","gt":"new VNode(VNodeFlags.Element, \"<STR_LIT>\", null, className === undefined ? null : className, null);"}
{"input":"<s> /**<EOL> * serializeState serializes javascript state into string and performs escaping to prevent from XSS attacks.<EOL> *<EOL> * @param data State.<EOL> * @returns Serialized state.<EOL> */<EOL>export function serializeState(data: any): string {<EOL>","gt":"return escapeJavascript(JSON.stringify(data));"}
{"input":"<s> export function saveAll(input: TaggedResource[], callback: () => void = _.noop, errBack: (err: UnsafeError) => void = _.noop) {<EOL>    return function (dispatch: Function, getState: GetState) {<EOL>        const p = input<EOL>            .filter(x => x.specialStatus === SpecialStatus.DIRTY)<EOL>            .","gt":"map(tts => tts.uuid)"}
{"input":"<s> async function setEmailTest(t: TestContext & Context<any>, testData: SetEmailTestData) {<EOL>    await TestEnvironment.initialize();<EOL>    if (testData.existingEmailAddress) {<EOL>        const emailProfile = await Database.getEmailProfile();<EOL>        emailProfile.emailAddress = testData.existingEmailAddress;<EOL>        await Database.setEmailProfile(","gt":"emailProfile);"}
{"input":"<s> async function setEmailTest(t: TestContext & Context<any>, testData: SetEmailTestData) {<EOL>    await TestEnvironment.initialize();<EOL>    if (testData.existingEmailAddress) {<EOL>        const emailProfile = await Database.getEmailProfile();<EOL>        emailProfile.emailAddress = testData.existingEmailAddress;<EOL>        await Database.setEmailProfile(emailProfile);<EOL>    }<EOL>    <EOL>    if (testData.existingPushDeviceId) {<EOL>        const subscription = await Database.getSubscription();<EOL>        subscription.deviceId =","gt":"testData.existingPushDeviceId;"}
{"input":"<s> async function setEmailTest(t: TestContext & Context<any>, testData: SetEmailTestData) {<EOL>    await TestEnvironment.initialize();<EOL>    if (testData.existingEmailAddress) {<EOL>        const emailProfile = await Database.getEmailProfile();<EOL>        emailProfile.emailAddress = testData.existingEmailAddress;<EOL>        await Database.setEmailProfile(emailProfile);<EOL>    }<EOL>    <EOL>    if (testData.existingPushDeviceId) {<EOL>        const subscription = await Database.getSubscription();<EOL>        subscription.deviceId = testData.existingPushDeviceId;<EOL>","gt":"await Database.setSubscription(subscription);"}
{"input":"<s> async function setEmailTest(t: TestContext & Context<any>, testData: SetEmailTestData) {<EOL>    await TestEnvironment.initialize();<EOL>    if (testData.existingEmailAddress) {<EOL>        const emailProfile = await Database.getEmailProfile();<EOL>        emailProfile.emailAddress = testData.existingEmailAddress;<EOL>        await Database.setEmailProfile(emailProfile);<EOL>    }<EOL>    <EOL>    if (testData.existingPushDeviceId) {<EOL>        const subscription = await Database.getSubscription();<EOL>        subscription.deviceId = testData.existingPushDeviceId;<EOL>        await Database.setSubscription(subscription);<EOL>    }<EOL>    if (testData.requireEmailAuth) {<EOL>        const appConfig = await Database.getAppConfig();<EOL>        appConfig.emailAuthRequired = true;<EOL>        await Database.setAppConfig(appConfig);<EOL>    }<EOL>    <EOL>    if (testData.emailAuthHash) {<EOL>        const emailProfile = await Database.getEmailProfile();<EOL>        emailProfile.emailAuthHash = testData.emailAuthHash;<EOL>        await Database.setEmailProfile(","gt":"emailProfile);"}
{"input":"<s> async function setEmailTest(t: TestContext & Context<any>, testData: SetEmailTestData) {<EOL>    await TestEnvironment.initialize();<EOL>    if (testData.existingEmailAddress) {<EOL>        const emailProfile = await Database.getEmailProfile();<EOL>        emailProfile.emailAddress = testData.existingEmailAddress;<EOL>        await Database.setEmailProfile(emailProfile);<EOL>    }<EOL>    <EOL>    if (testData.existingPushDeviceId) {<EOL>        const subscription = await Database.getSubscription();<EOL>        subscription.deviceId = testData.existingPushDeviceId;<EOL>        await Database.setSubscription(subscription);<EOL>    }<EOL>    if (testData.requireEmailAuth) {<EOL>        const appConfig = await Database.getAppConfig();<EOL>        appConfig.emailAuthRequired = true;<EOL>        await Database.setAppConfig(appConfig);<EOL>    }<EOL>    <EOL>    if (testData.emailAuthHash) {<EOL>        const emailProfile = await Database.getEmailProfile();<EOL>        emailProfile.emailAuthHash = testData.emailAuthHash;<EOL>        await Database.setEmailProfile(emailProfile);<EOL>    }<EOL>    if (testData.existingEmailId) {<EOL>        const emailProfile = await Database.getEmailProfile();<EOL>        emailProfile.emailId = testData.existingEmailId;<EOL>        await Database.setEmailProfile(emailProfile);<EOL>    }<EOL>    <EOL>    const isUpdateRequest = testData.emailAuthHash && testData.existingEmailId;<EOL>    if (isUpdateRequest) {<EOL>        <EOL>        expectEmailRecordUpdateRequest(t, testData.existingEmailId, testData.newEmailAddress, testData.existingPushDeviceId, testData.emailAuthHash, testData.newEmailId);<EOL>    }<EOL>    else {<EOL>        <EOL>        expectEmailRecordCreationRequest(t, testData.newEmailAddress, testData.existingPushDeviceId, testData.emailAuthHash, testData.newEmailId);<EOL>    }<EOL>    if (testData.existingPushDeviceId &&<EOL>        !(testData.","gt":"existingEmailId === testData.newEmailId &&"}
{"input":"<s> async function setEmailTest(t: TestContext & Context<any>, testData: SetEmailTestData) {<EOL>    await TestEnvironment.initialize();<EOL>    if (testData.existingEmailAddress) {<EOL>        const emailProfile = await Database.getEmailProfile();<EOL>        emailProfile.emailAddress = testData.existingEmailAddress;<EOL>        await Database.setEmailProfile(emailProfile);<EOL>    }<EOL>    <EOL>    if (testData.existingPushDeviceId) {<EOL>        const subscription = await Database.getSubscription();<EOL>        subscription.deviceId = testData.existingPushDeviceId;<EOL>        await Database.setSubscription(subscription);<EOL>    }<EOL>    if (testData.requireEmailAuth) {<EOL>        const appConfig = await Database.getAppConfig();<EOL>        appConfig.emailAuthRequired = true;<EOL>        await Database.setAppConfig(appConfig);<EOL>    }<EOL>    <EOL>    if (testData.emailAuthHash) {<EOL>        const emailProfile = await Database.getEmailProfile();<EOL>        emailProfile.emailAuthHash = testData.emailAuthHash;<EOL>        await Database.setEmailProfile(emailProfile);<EOL>    }<EOL>    if (testData.existingEmailId) {<EOL>        const emailProfile = await Database.getEmailProfile();<EOL>        emailProfile.emailId = testData.existingEmailId;<EOL>        await Database.setEmailProfile(emailProfile);<EOL>    }<EOL>    <EOL>    const isUpdateRequest = testData.emailAuthHash && testData.existingEmailId;<EOL>    if (isUpdateRequest) {<EOL>        <EOL>        expectEmailRecordUpdateRequest(t, testData.existingEmailId, testData.newEmailAddress, testData.existingPushDeviceId, testData.emailAuthHash, testData.newEmailId);<EOL>    }<EOL>    else {<EOL>        <EOL>        expectEmailRecordCreationRequest(t, testData.newEmailAddress, testData.existingPushDeviceId, testData.emailAuthHash, testData.newEmailId);<EOL>    }<EOL>    if (testData.existingPushDeviceId &&<EOL>        !(testData.existingEmailId === testData.newEmailId &&<EOL>            testData.existingEmailAddress === testData.newEmailAddress)) {<EOL>        <EOL>        expectPushRecordUpdateRequest(t, testData.existingPushDeviceId, testData.newEmailId, testData.newEmailAddress, Uuid.generate());<EOL>    }<EOL>    await OneSignal.setEmail(testData.newEmailAddress, testData.emailAuthHash ?<EOL>        { emailAuthHash: testData.emailAuthHash } :<EOL>","gt":"undefined);"}
{"input":"<s> function testForExclusionPattern(path: string, pattern: string): boolean {<EOL>    return minimatch(path, pattern, { dot:","gt":"true });"}
{"input":"<s> export function fromObjectRecursive(source: any): Observable {<EOL>    let observable =","gt":"new ObservableFromObject();"}
{"input":"<s> function fakeBot(): Farmbot {<EOL>    const fb: Partial<Farmbot> = {<EOL>        setState: jest.fn(),<EOL>        publish: jest.","gt":"fn(),"}
{"input":"<s> export function linearGradient(className?: string): VNode<SVGLinearGradientElementProps | null, SVGLinearGradientElement> {<EOL>    return new","gt":"VNode(VNodeFlags.Element | VNodeFlags.SvgElement, \"<STR_LIT>\", null, className === undefined ? null : className, null);"}
{"input":"<s> export function Listener(eventName?: string): Function {<EOL>    return listenerFunc.bind(","gt":"this, eventName);"}
{"input":"<s> export function onButtonTap(args) {<EOL>","gt":"applyNextStyle(args);"}
{"input":"<s> export function onGoBack(args: EventData) {<EOL>","gt":"const view = args.object as View;"}
{"input":"<s> export function simpleHttpRequest(params: SimpleHttpRequestParams): Promise<any> {<EOL>    return new Promise<any>(resolve => {<EOL>        let httpRequest = new XMLHttpRequest();<EOL>        httpRequest.open('<STR_LIT>', params.url);<EOL>","gt":"httpRequest.send();"}
{"input":"<s> /** Given a half-formed set of ENV vars, makes a best effort attempt to find<EOL> * the corresponding value. When lookup fails, provide a sane default value. */<EOL>export function envGet(key: WDENVKey, env: Partial<WD_ENV>): number {<EOL>    return betterParseNum(JSON.stringify(isNumber(env[key]) ? env[key] : \"<STR_LIT>\"),","gt":"DEFAULTS[key]);"}
{"input":"<s> function addFrameTaskAfter(frame: FrameTasksGroup, task: () => void): void {<EOL>    frame.","gt":"flags |= FrameTasksGroupFlags.After;"}
{"input":"<s> export function fakeWebAppConfig(): TaggedWebAppConfig {<EOL>    return fakeResource(\"<STR_LIT>\", {<EOL>        id: <NUM_LIT>,<EOL>        device_id: <NUM_LIT>,<EOL>        created_at:","gt":"\"<STR_LIT>\","}
{"input":"<s> export function fakeWebAppConfig(): TaggedWebAppConfig {<EOL>    return fakeResource(\"<STR_LIT>\", {<EOL>        id: <NUM_LIT>,<EOL>        device_id: <NUM_LIT>,<EOL>        created_at: \"<STR_LIT>\",<EOL>","gt":"updated_at: \"<STR_LIT>\","}
{"input":"<s> export function fakeWebAppConfig(): TaggedWebAppConfig {<EOL>    return fakeResource(\"<STR_LIT>\", {<EOL>        id: <NUM_LIT>,<EOL>        device_id: <NUM_LIT>,<EOL>        created_at: \"<STR_LIT>\",<EOL>        updated_at: \"<STR_LIT>\",<EOL>        confirm_step_deletion: false,<EOL>        disable_animations: false,<EOL>","gt":"disable_i18n: false,"}
{"input":"<s> export function fakeWebAppConfig(): TaggedWebAppConfig {<EOL>    return fakeResource(\"<STR_LIT>\", {<EOL>        id: <NUM_LIT>,<EOL>        device_id: <NUM_LIT>,<EOL>        created_at: \"<STR_LIT>\",<EOL>        updated_at: \"<STR_LIT>\",<EOL>        confirm_step_deletion: false,<EOL>        disable_animations: false,<EOL>        disable_i18n: false,<EOL>        display_trail: false,<EOL>        dynamic_map: false,<EOL>        encoder_figure: false,<EOL>","gt":"hide_webcam_widget: false,"}
{"input":"<s> export function fakeWebAppConfig(): TaggedWebAppConfig {<EOL>    return fakeResource(\"<STR_LIT>\", {<EOL>        id: <NUM_LIT>,<EOL>        device_id: <NUM_LIT>,<EOL>        created_at: \"<STR_LIT>\",<EOL>        updated_at: \"<STR_LIT>\",<EOL>        confirm_step_deletion: false,<EOL>        disable_animations: false,<EOL>        disable_i18n: false,<EOL>        display_trail: false,<EOL>        dynamic_map: false,<EOL>        encoder_figure: false,<EOL>        hide_webcam_widget: false,<EOL>        legend_menu_open: false,<EOL>        map_xl: false,<EOL>        raw_encoders: true,<EOL>        scaled_encoders: true,<EOL>","gt":"show_spread: false,"}
{"input":"<s> export function fakeWebAppConfig(): TaggedWebAppConfig {<EOL>    return fakeResource(\"<STR_LIT>\", {<EOL>        id: <NUM_LIT>,<EOL>        device_id: <NUM_LIT>,<EOL>        created_at: \"<STR_LIT>\",<EOL>        updated_at: \"<STR_LIT>\",<EOL>        confirm_step_deletion: false,<EOL>        disable_animations: false,<EOL>        disable_i18n: false,<EOL>        display_trail: false,<EOL>        dynamic_map: false,<EOL>        encoder_figure: false,<EOL>        hide_webcam_widget: false,<EOL>        legend_menu_open: false,<EOL>        map_xl: false,<EOL>        raw_encoders: true,<EOL>        scaled_encoders: true,<EOL>        show_spread: false,<EOL>        show_farmbot: true,<EOL>        show_images: false,<EOL>        show_plants: true,<EOL>","gt":"show_points: true,"}
{"input":"<s> export function fakeWebAppConfig(): TaggedWebAppConfig {<EOL>    return fakeResource(\"<STR_LIT>\", {<EOL>        id: <NUM_LIT>,<EOL>        device_id: <NUM_LIT>,<EOL>        created_at: \"<STR_LIT>\",<EOL>        updated_at: \"<STR_LIT>\",<EOL>        confirm_step_deletion: false,<EOL>        disable_animations: false,<EOL>        disable_i18n: false,<EOL>        display_trail: false,<EOL>        dynamic_map: false,<EOL>        encoder_figure: false,<EOL>        hide_webcam_widget: false,<EOL>        legend_menu_open: false,<EOL>        map_xl: false,<EOL>        raw_encoders: true,<EOL>        scaled_encoders: true,<EOL>        show_spread: false,<EOL>        show_farmbot: true,<EOL>        show_images: false,<EOL>        show_plants: true,<EOL>        show_points: true,<EOL>        x_axis_inverted: false,<EOL>        y_axis_inverted: false,<EOL>        z_axis_inverted: true,<EOL>        bot_origin_quadrant: <NUM_LIT>,<EOL>        zoom_level: -<NUM_LIT>,<EOL>        success_log: <NUM_LIT>,<EOL>        busy_log: <NUM_LIT>,<EOL>        warn_log:","gt":"<NUM_LIT>,"}
{"input":"<s> export function meta(className?: string): VNode<HTMLMetaElementProps | null> {<EOL>    return new VNode(VNodeFlags.Element | VNodeFlags.VoidElement,","gt":"\"<STR_LIT>\", null, className === undefined ? null : className, null, null);"}
{"input":"<s> function g(t?: {<EOL>    a: number;<EOL>} | null): void {<EOL>    let b = { ...","gt":"t };"}
{"input":"<s> /** Picks a color that is compliant with sequence / regimen color codes */<EOL>export function randomColor(): Color {<EOL>    return _.","gt":"sample(colors) || \"<STR_LIT>\";"}
{"input":"<s> export function onPointerDown(handler: (ev: SyntheticPointerEvent) => void, capture = false): EventHandler<SyntheticPointerEvent> {<EOL>    return","gt":"createEventHandler<SyntheticPointerEvent>(EventSourcePointerDown.eventSource, handler, capture);"}
{"input":"<s> export function tref(className?: string): VNode<SVGElementProps | null, SVGElement> {<EOL>    return new VNode(VNodeFlags.","gt":"Element | VNodeFlags.SvgElement, \"<STR_LIT>\", null, className === undefined ? null : className, null);"}
{"input":"<s> export function link(className?: string): VNode<HTMLLinkElementProps | null, HTMLLinkElement> {<EOL>    return new VNode(VNodeFlags.Element | VNodeFlags.VoidElement, \"<STR_LIT>\",","gt":"null, className === undefined ? null : className, null);"}
{"input":"<s> export function pre(className?: string): VNode<HTMLPreElementProps | null, HTMLPreElement> {<EOL>    return new VNode(","gt":"VNodeFlags.Element, \"<STR_LIT>\", null, className === undefined ? null : className, null);"}
{"input":"<s> /** Fancy debug */<EOL>export function fancyDebug<T extends {}>(d: T): T {<EOL>    console.log(Object<EOL>        .keys(d)<EOL>        .map(key => [key, (d as Dictionary<string>)[key]])<EOL>        .map((","gt":"x) => {"}
{"input":"<s> /**<EOL> * Update root nodes.<EOL> */<EOL>function _update() {<EOL>    if (_pendingUpdate) {<EOL>        _pendingUpdate = false;<EOL>","gt":"for (let i = <NUM_LIT>; i < ROOTS.length; ++i) {"}
{"input":"<s> /**<EOL> * Update root nodes.<EOL> */<EOL>function _update() {<EOL>    if (_pendingUpdate) {<EOL>        _pendingUpdate = false;<EOL>        for (let i = <NUM_LIT>; i < ROOTS.length; ++i) {<EOL>            const root = ROOTS[i];<EOL>            const container = root.container;<EOL>            const currentVNode = root.currentVNode;<EOL>","gt":"if (root.invalidated) {"}
{"input":"<s> /**<EOL> * Update root nodes.<EOL> */<EOL>function _update() {<EOL>    if (_pendingUpdate) {<EOL>        _pendingUpdate = false;<EOL>        for (let i = <NUM_LIT>; i < ROOTS.length; ++i) {<EOL>            const root = ROOTS[i];<EOL>            const container = root.container;<EOL>            const currentVNode = root.currentVNode;<EOL>            if (root.invalidated) {<EOL>                let newVNode = root.newVNode;<EOL>                if (newVNode) {<EOL>                    if (newVNode.constructor !== VNode) {<EOL>                        newVNode =","gt":"new VNode(VNodeFlags.Text, null, null, null, \"<STR_LIT>\");"}
{"input":"<s> /**<EOL> * Update root nodes.<EOL> */<EOL>function _update() {<EOL>    if (_pendingUpdate) {<EOL>        _pendingUpdate = false;<EOL>        for (let i = <NUM_LIT>; i < ROOTS.length; ++i) {<EOL>            const root = ROOTS[i];<EOL>            const container = root.container;<EOL>            const currentVNode = root.currentVNode;<EOL>            if (root.invalidated) {<EOL>                let newVNode = root.newVNode;<EOL>                if (newVNode) {<EOL>                    if (newVNode.constructor !== VNode) {<EOL>                        newVNode = new VNode(VNodeFlags.Text, null, null, null, \"<STR_LIT>\");<EOL>                    }<EOL>                    if (currentVNode) {<EOL>                        syncVNode(container, currentVNode, newVNode, EMPTY_CONTEXT, SyncFlags.Attached);<EOL>                    }<EOL>                    else {<EOL>                        renderVNode(container, null, newVNode!, EMPTY_CONTEXT);<EOL>                        iOSFixEventBubbling(container);<EOL>                    }<EOL>","gt":"root.currentVNode = newVNode;"}
{"input":"<s> export function initializeTemporaryCommandRegistrar(): void {<EOL>    tempCommandRegistrar = new","gt":"TemporaryCommandRegistrar();"}
{"input":"<s> function verify(key: string) {<EOL>    common.","gt":"checkKey(key);"}
{"input":"<s> /**<EOL> * Render VNode into container on the next frame.<EOL> *<EOL> * @param node VNode to render.<EOL> * @param container DOM Node that will contain rendered node.<EOL> */<EOL>export function renderNextFrame(node: VNode | null, container: Element): void {<EOL>    if (DEV) {<EOL>        if (container === document.body) {<EOL>            throw new Error(\"<STR_LIT>\" +<EOL>                \"<STR_LIT>\");<EOL>        }<EOL>        if (!document.","gt":"body.contains(container)) {"}
{"input":"<s> /**<EOL> * Render VNode into container on the next frame.<EOL> *<EOL> * @param node VNode to render.<EOL> * @param container DOM Node that will contain rendered node.<EOL> */<EOL>export function renderNextFrame(node: VNode | null, container: Element): void {<EOL>    if (DEV) {<EOL>        if (container === document.body) {<EOL>            throw new Error(\"<STR_LIT>\" +<EOL>                \"<STR_LIT>\");<EOL>        }<EOL>        if (!document.body.contains(container)) {<EOL>            throw new Error(\"<STR_LIT>\");<EOL>        }<EOL>    }<EOL>    const root = findRoot(container);<EOL>    if (root) {<EOL>        root.","gt":"newVNode = node;"}
{"input":"<s> /**<EOL> * Render VNode into container on the next frame.<EOL> *<EOL> * @param node VNode to render.<EOL> * @param container DOM Node that will contain rendered node.<EOL> */<EOL>export function renderNextFrame(node: VNode | null, container: Element): void {<EOL>    if (DEV) {<EOL>        if (container === document.body) {<EOL>            throw new Error(\"<STR_LIT>\" +<EOL>                \"<STR_LIT>\");<EOL>        }<EOL>        if (!document.body.contains(container)) {<EOL>            throw new Error(\"<STR_LIT>\");<EOL>        }<EOL>    }<EOL>    const root = findRoot(container);<EOL>    if (root) {<EOL>        root.newVNode = node;<EOL>        root.invalidated = true;<EOL>    }<EOL>","gt":"else {"}
{"input":"<s> /**<EOL> * Render VNode into container on the next frame.<EOL> *<EOL> * @param node VNode to render.<EOL> * @param container DOM Node that will contain rendered node.<EOL> */<EOL>export function renderNextFrame(node: VNode | null, container: Element): void {<EOL>    if (DEV) {<EOL>        if (container === document.body) {<EOL>            throw new Error(\"<STR_LIT>\" +<EOL>                \"<STR_LIT>\");<EOL>        }<EOL>        if (!document.body.contains(container)) {<EOL>            throw new Error(\"<STR_LIT>\");<EOL>        }<EOL>    }<EOL>    const root = findRoot(container);<EOL>    if (root) {<EOL>        root.newVNode = node;<EOL>        root.invalidated = true;<EOL>    }<EOL>    else {<EOL>        ROOTS.push({<EOL>            container: container,<EOL>            currentVNode: null,<EOL>            newVNode: node,<EOL>            invalidated: true,<EOL>        });<EOL>","gt":"if (DEV) {"}
{"input":"<s> function ensure<T, K extends keyof T>(target: T, key: K): T[K] {<EOL>    if (target[key] === void <NUM_LIT>) {<EOL>        target[","gt":"key] = {} as any;"}
{"input":"<s> function parsePathArg(arg: string, process: NodeJS.Process): string {<EOL>    if (!arg) {<EOL>        return undefined;<EOL>    }<EOL>    <EOL>    <EOL>    const resolved = path.resolve(arg);<EOL>    if (path.normalize(arg) === resolved) {<EOL>        return resolved;<EOL>    }<EOL>","gt":"else {"}
{"input":"<s> export function span(className?: string): VNode<HTMLSpanElementProps | null> {<EOL>    return new VNode(VNodeFlags.Element, \"<STR_LIT>\", null, className === undefined ? null :","gt":"className, null, \"<STR_LIT>\");"}
{"input":"<s> export function onVolumeChange(handler: (ev: SyntheticNativeEvent<Event>) => void, capture = false): EventHandler<SyntheticNativeEvent<Event>> {<EOL>    return","gt":"createEventHandler<SyntheticNativeEvent<Event>>(EventSourceVolumeChange.eventSource, handler, capture);"}
{"input":"<s> export function sup(className?: string): VNode<HTMLElementProps | null> {<EOL>    return new","gt":"VNode(VNodeFlags.Element, \"<STR_LIT>\", null, className === undefined ? null : className, null, \"<STR_LIT>\");"}
{"input":"<s> export function time(className?: string): VNode<HTMLElementProps | null, HTMLElement> {<EOL>    return new VNode(VNodeFlags.Element, \"<STR_LIT>\", null, className ===","gt":"undefined ? null : className, null);"}
{"input":"<s> export function u(className?: string): VNode<HTMLElementProps | null, HTMLElement> {<EOL>    return new VNode(VNodeFlags.Element, \"<STR_LIT>\", null, className === undefined ?","gt":"null : className, null);"}
{"input":"<s> export function style(className?: string): VNode<HTMLStyleElementProps | null, HTMLStyleElement> {<EOL>    return","gt":"new VNode(VNodeFlags.Element, \"<STR_LIT>\", null, className === undefined ? null : className, null);"}
{"input":"<s> export function fecomponenttransfer(className?: string): VNode<SVGFEComponentTransferElementProps | null, SVGFEComponentTransferElement> {<EOL>    return new VNode(VNodeFlags.Element | VNodeFlags.SvgElement, \"<STR_LIT>\", null,","gt":"className === undefined ? null : className, null);"}
{"input":"<s> export function inputDatetimeLocal(className?: string): VNode<HTMLInputElementProps | null> {<EOL>    return new VNode(VNodeFlags.Element | VNodeFlags.InputElement | VNodeFlags.","gt":"VoidElement, `<STR_LIT>`, null, className === undefined ? null : className, null, null);"}
{"input":"<s> export function fecomposite(className?: string): VNode<SVGFECompositeElementProps | null, SVGFECompositeElement> {<EOL>    return new VNode(VNodeFlags.Element | VNodeFlags.SvgElement, \"<STR_LIT>\", null,","gt":"className === undefined ? null : className, null);"}
{"input":"<s> export function feoffset(className?: string): VNode<SVGFEOffsetElementProps | null, SVGFEOffsetElement> {<EOL>    return new VNode(VNodeFlags.Element |","gt":"VNodeFlags.SvgElement, \"<STR_LIT>\", null, className === undefined ? null : className, null);"}
{"input":"<s> export function feblend(className?: string): VNode<SVGFEBlendElementProps | null, SVGFEBlendElement> {<EOL>    return","gt":"new VNode(VNodeFlags.Element | VNodeFlags.SvgElement, \"<STR_LIT>\", null, className === undefined ? null : className, null);"}
{"input":"<s> <EOL>export function audio(className?: string): VNode<HTMLAudioElementProps | null> {<EOL>","gt":"return new VNode(VNodeFlags.Element | VNodeFlags.MediaElement, \"<STR_LIT>\", null, className === undefined ? null : className, null, \"<STR_LIT>\");"}
{"input":"<s> export function video(className?: string): VNode<HTMLVideoElementProps | null> {<EOL>    return new VNode(VNodeFlags.Element | VNodeFlags.MediaElement,","gt":"\"<STR_LIT>\", null, className === undefined ? null : className, null, \"<STR_LIT>\");"}
{"input":"<s> export function fedisplacementmap(className?: string): VNode<SVGFEDisplacementMapElementProps | null, SVGFEDisplacementMapElement> {<EOL>    return new VNode(VNodeFlags.Element | VNodeFlags.","gt":"SvgElement, \"<STR_LIT>\", null, className === undefined ? null : className, null);"}
{"input":"<s> export function polyline(className?: string): VNode<SVGPolylineElementProps | null, SVGPolylineElement> {<EOL>    return new VNode(VNodeFlags.Element | VNodeFlags.SvgElement, \"<STR_LIT>\",","gt":"null, className === undefined ? null : className, null);"}
{"input":"<s> export function fepointlight(className?: string): VNode<SVGFEPointLightElementProps | null, SVGFEPointLightElement> {<EOL>    return new VNode(VNodeFlags.","gt":"Element | VNodeFlags.SvgElement, \"<STR_LIT>\", null, className === undefined ? null : className, null);"}
{"input":"<s> export function drawerClosed(args) {<EOL>    var drawer =","gt":"args.object;"}
{"input":"<s> export function fetile(className?: string): VNode<SVGFETileElementProps | null, SVGFETileElement> {<EOL>    return new VNode(VNodeFlags.Element | VNodeFlags.SvgElement, \"<STR_LIT>\",","gt":"null, className === undefined ? null : className, null);"}
{"input":"<s> export function feturbulence(className?: string): VNode<SVGFETurbulenceElementProps | null, SVGFETurbulenceElement> {<EOL>    return new","gt":"VNode(VNodeFlags.Element | VNodeFlags.SvgElement, \"<STR_LIT>\", null, className === undefined ? null : className, null);"}
{"input":"<s> export function foreignobject(className?: string): VNode<SVGForeignObjectElementProps | null, SVGForeignObjectElement> {<EOL>    return new VNode(VNodeFlags.Element | VNodeFlags.SvgElement, \"<STR_LIT>\", null, className === undefined ? null :","gt":"className, null);"}
{"input":"<s> export function shortRevision() {<EOL>    return (globalConfig.SHORT_REVISION ||","gt":"\"<STR_LIT>\").slice(<NUM_LIT>, <NUM_LIT>);"}
{"input":"<s> export function path(className?: string): VNode<SVGPathElementProps | null, SVGPathElement> {<EOL>","gt":"return new VNode(VNodeFlags.Element | VNodeFlags.SvgElement, \"<STR_LIT>\", null, className === undefined ? null : className, null);"}
{"input":"<s> export function polygon(className?: string): VNode<SVGPolygonElementProps | null, SVGPolygonElement> {<EOL>    return new VNode(VNodeFlags.Element | VNodeFlags.SvgElement,","gt":"\"<STR_LIT>\", null, className === undefined ? null : className, null);"}
{"input":"<s> export function inputMonth(className?: string): VNode<HTMLInputElementProps | null, HTMLInputElement> {<EOL>    return new VNode(VNodeFlags.Element | VNodeFlags.InputElement | VNodeFlags.","gt":"VoidElement, \"<STR_LIT>\", null, className === undefined ? null : className, null);"}
{"input":"<s> export function inputSearch(className?: string): VNode<HTMLInputElementProps | null, HTMLInputElement> {<EOL>    return new VNode(VNodeFlags.Element | VNodeFlags.InputElement | VNodeFlags.VoidElement, \"<STR_LIT>\", null, className === undefined ? null : className,","gt":"null);"}
{"input":"<s> <EOL>export function textarea(className?: string): VNode<HTMLTextAreaElementProps | null, HTMLTextAreaElement> {<EOL>    return new VNode(VNodeFlags.Element | VNodeFlags.TextAreaElement,","gt":"\"<STR_LIT>\", null, className === undefined ? null : className, null);"}
{"input":"<s> export function inputTel(className?: string): VNode<HTMLInputElementProps | null, HTMLInputElement> {<EOL>    return new VNode(VNodeFlags.Element |","gt":"VNodeFlags.InputElement | VNodeFlags.VoidElement, \"<STR_LIT>\", null, className === undefined ? null : className, null);"}
{"input":"<s> export function inputDatetimeLocal(className?: string): VNode<HTMLInputElementProps | null, HTMLInputElement> {<EOL>    return","gt":"new VNode(VNodeFlags.Element | VNodeFlags.InputElement | VNodeFlags.VoidElement, \"<STR_LIT>\", null, className === undefined ? null : className, null);"}
{"input":"<s> export function inputHidden(className?: string): VNode<HTMLInputElementProps | null, HTMLInputElement> {<EOL>    return new VNode(VNodeFlags.Element | VNodeFlags.InputElement | VNodeFlags.","gt":"VoidElement, \"<STR_LIT>\", null, className === undefined ? null : className, null);"}
{"input":"<s> export function inputNumber(className?: string): VNode<HTMLInputElementProps | null, HTMLInputElement> {<EOL>    return new VNode(VNodeFlags.Element | VNodeFlags.InputElement | VNodeFlags.VoidElement,","gt":"\"<STR_LIT>\", null, className === undefined ? null : className, null);"}
{"input":"<s> /** Return the UTC offset of current bot if possible. If not, use UTC (0). */<EOL>export function maybeGetTimeOffset(index: ResourceIndex): number {<EOL>","gt":"const dev = maybeGetDevice(index);"}
{"input":"<s> export function getStatus(cs: ConnectionStatus | undefined): \"<STR_LIT>\" | \"<STR_LIT>\" {<EOL>    return (cs &&","gt":"cs.state) || \"<STR_LIT>\";"}
{"input":"<s> export function validateConstraints(args: any[], constraints: TypeConstraint[]): void {<EOL>    const len = Math.min(args.length, constraints.length);<EOL>    for (let i = <NUM_LIT>;","gt":"i < len; i++) {"}
{"input":"<s> /**<EOL> * Folds all regions for which the lines start with a given regex<EOL> * @param foldingModel the folding model<EOL> */<EOL>export function setCollapseStateForMatchingLines(foldingModel: FoldingModel, regExp: RegExp, doCollapse: boolean): void {<EOL>    let editorModel = foldingModel.textModel;<EOL>    let regions = foldingModel.regions;<EOL>    let toToggle = [];<EOL>","gt":"for (let i = regions.length - <NUM_LIT>; i >= <NUM_LIT>; i--) {"}
{"input":"<s> function foo(isAll, startTime, endTime) {<EOL>    const timeRange = isAll ?","gt":"'<STR_LIT>' : `<STR_LIT>`;"}
{"input":"<s> function copyFolderRecursivelySync(src, dest) {<EOL>    if (!directoryExistsSync(src)) {<EOL>        return;<EOL>    }<EOL>    if (!directoryExistsSync(dest)) {<EOL>        mkdirRecursivelySync(dest);<EOL>    }<EOL>    const items = fs.readdirSync(src);<EOL>    for (const item of items) {<EOL>        const fullPath = path.join(src, item);<EOL>        const targetPath = path.join(dest,","gt":"item);"}
{"input":"<s> /**<EOL> * Create query name out of the class name<EOL> */<EOL>export function createQueryName(name: string): string {<EOL>    return lowercaseFirstLetter(removeSuffix(","gt":"name, '<STR_LIT>'));"}
{"input":"<s> export function getWorkspaceEditsFromPatch(filePatches: string[], workspaceRoot?: string): WorkspaceEdit {<EOL>    const workspaceEdit = new WorkspaceEdit();<EOL>    filePatches.forEach(patch => {<EOL>","gt":"const indexOfAtAt = patch.indexOf('<STR_LIT>');"}
{"input":"<s> export function getWorkspaceEditsFromPatch(filePatches: string[], workspaceRoot?: string): WorkspaceEdit {<EOL>    const workspaceEdit = new WorkspaceEdit();<EOL>    filePatches.forEach(patch => {<EOL>        const indexOfAtAt = patch.indexOf('<STR_LIT>');<EOL>        if (indexOfAtAt === -<NUM_LIT>) {<EOL>","gt":"return;"}
{"input":"<s> export function getWorkspaceEditsFromPatch(filePatches: string[], workspaceRoot?: string): WorkspaceEdit {<EOL>    const workspaceEdit = new WorkspaceEdit();<EOL>    filePatches.forEach(patch => {<EOL>        const indexOfAtAt = patch.indexOf('<STR_LIT>');<EOL>        if (indexOfAtAt === -<NUM_LIT>) {<EOL>            return;<EOL>        }<EOL>        const fileNameLines = patch.substring(<NUM_LIT>, indexOfAtAt).split(/\\r?\\n/g)<EOL>            .","gt":"map(line => line.trim())"}
{"input":"<s> export function getWorkspaceEditsFromPatch(filePatches: string[], workspaceRoot?: string): WorkspaceEdit {<EOL>    const workspaceEdit = new WorkspaceEdit();<EOL>    filePatches.forEach(patch => {<EOL>        const indexOfAtAt = patch.indexOf('<STR_LIT>');<EOL>        if (indexOfAtAt === -<NUM_LIT>) {<EOL>            return;<EOL>        }<EOL>        const fileNameLines = patch.substring(<NUM_LIT>, indexOfAtAt).split(/\\r?\\n/g)<EOL>            .map(line => line.trim())<EOL>            .filter(line => line.length > <NUM_LIT> &&<EOL>            line.toLowerCase().endsWith('<STR_LIT>') &&<EOL>            line.indexOf('<STR_LIT>') > <NUM_LIT>);<EOL>        if (","gt":"patch.startsWith('<STR_LIT>')) {"}
{"input":"<s> export function getWorkspaceEditsFromPatch(filePatches: string[], workspaceRoot?: string): WorkspaceEdit {<EOL>    const workspaceEdit = new WorkspaceEdit();<EOL>    filePatches.forEach(patch => {<EOL>        const indexOfAtAt = patch.indexOf('<STR_LIT>');<EOL>        if (indexOfAtAt === -<NUM_LIT>) {<EOL>            return;<EOL>        }<EOL>        const fileNameLines = patch.substring(<NUM_LIT>, indexOfAtAt).split(/\\r?\\n/g)<EOL>            .map(line => line.trim())<EOL>            .filter(line => line.length > <NUM_LIT> &&<EOL>            line.toLowerCase().endsWith('<STR_LIT>') &&<EOL>            line.indexOf('<STR_LIT>') > <NUM_LIT>);<EOL>        if (patch.startsWith('<STR_LIT>')) {<EOL>            <EOL>            patch = patch.substring(indexOfAtAt);<EOL>        }<EOL>        if (patch.length === <NUM_LIT>) {<EOL>            return;<EOL>        }<EOL>        <EOL>        if (fileNameLines.length === <NUM_LIT>) {<EOL>            return;<EOL>        }<EOL>        let fileName = fileNameLines[<NUM_LIT>].substring(fileNameLines[<NUM_LIT>].indexOf('<STR_LIT>') + <NUM_LIT>).trim();<EOL>        fileName = workspaceRoot && !path.isAbsolute(fileName) ? path.resolve(workspaceRoot, fileName) :","gt":"fileName;"}
{"input":"<s> export function getWorkspaceEditsFromPatch(filePatches: string[], workspaceRoot?: string): WorkspaceEdit {<EOL>    const workspaceEdit = new WorkspaceEdit();<EOL>    filePatches.forEach(patch => {<EOL>        const indexOfAtAt = patch.indexOf('<STR_LIT>');<EOL>        if (indexOfAtAt === -<NUM_LIT>) {<EOL>            return;<EOL>        }<EOL>        const fileNameLines = patch.substring(<NUM_LIT>, indexOfAtAt).split(/\\r?\\n/g)<EOL>            .map(line => line.trim())<EOL>            .filter(line => line.length > <NUM_LIT> &&<EOL>            line.toLowerCase().endsWith('<STR_LIT>') &&<EOL>            line.indexOf('<STR_LIT>') > <NUM_LIT>);<EOL>        if (patch.startsWith('<STR_LIT>')) {<EOL>            <EOL>            patch = patch.substring(indexOfAtAt);<EOL>        }<EOL>        if (patch.length === <NUM_LIT>) {<EOL>            return;<EOL>        }<EOL>        <EOL>        if (fileNameLines.length === <NUM_LIT>) {<EOL>            return;<EOL>        }<EOL>        let fileName = fileNameLines[<NUM_LIT>].substring(fileNameLines[<NUM_LIT>].indexOf('<STR_LIT>') + <NUM_LIT>).trim();<EOL>        fileName = workspaceRoot && !path.isAbsolute(fileName) ? path.resolve(workspaceRoot, fileName) : fileName;<EOL>        if (!fs.existsSync(fileName)) {<EOL>            return;<EOL>        }<EOL>        <EOL>        <EOL>        patch = patch.replace(/\\\\ No newline at end of file[\\r\\n]/, '<STR_LIT>');<EOL>        const d = new dmp.diff_match_patch();<EOL>        const patches = patch_fromText.call(d,","gt":"patch);"}
{"input":"<s> export function getWorkspaceEditsFromPatch(filePatches: string[], workspaceRoot?: string): WorkspaceEdit {<EOL>    const workspaceEdit = new WorkspaceEdit();<EOL>    filePatches.forEach(patch => {<EOL>        const indexOfAtAt = patch.indexOf('<STR_LIT>');<EOL>        if (indexOfAtAt === -<NUM_LIT>) {<EOL>            return;<EOL>        }<EOL>        const fileNameLines = patch.substring(<NUM_LIT>, indexOfAtAt).split(/\\r?\\n/g)<EOL>            .map(line => line.trim())<EOL>            .filter(line => line.length > <NUM_LIT> &&<EOL>            line.toLowerCase().endsWith('<STR_LIT>') &&<EOL>            line.indexOf('<STR_LIT>') > <NUM_LIT>);<EOL>        if (patch.startsWith('<STR_LIT>')) {<EOL>            <EOL>            patch = patch.substring(indexOfAtAt);<EOL>        }<EOL>        if (patch.length === <NUM_LIT>) {<EOL>            return;<EOL>        }<EOL>        <EOL>        if (fileNameLines.length === <NUM_LIT>) {<EOL>            return;<EOL>        }<EOL>        let fileName = fileNameLines[<NUM_LIT>].substring(fileNameLines[<NUM_LIT>].indexOf('<STR_LIT>') + <NUM_LIT>).trim();<EOL>        fileName = workspaceRoot && !path.isAbsolute(fileName) ? path.resolve(workspaceRoot, fileName) : fileName;<EOL>        if (!fs.existsSync(fileName)) {<EOL>            return;<EOL>        }<EOL>        <EOL>        <EOL>        patch = patch.replace(/\\\\ No newline at end of file[\\r\\n]/, '<STR_LIT>');<EOL>        const d = new dmp.diff_match_patch();<EOL>        const patches = patch_fromText.call(d, patch);<EOL>        if (!Array.isArray(patches) || patches.length === <NUM_LIT>) {<EOL>            throw new Error('<STR_LIT>');<EOL>        }<EOL>        const fileSource =","gt":"fs.readFileSync(fileName).toString('<STR_LIT>');"}
{"input":"<s> export function getWorkspaceEditsFromPatch(filePatches: string[], workspaceRoot?: string): WorkspaceEdit {<EOL>    const workspaceEdit = new WorkspaceEdit();<EOL>    filePatches.forEach(patch => {<EOL>        const indexOfAtAt = patch.indexOf('<STR_LIT>');<EOL>        if (indexOfAtAt === -<NUM_LIT>) {<EOL>            return;<EOL>        }<EOL>        const fileNameLines = patch.substring(<NUM_LIT>, indexOfAtAt).split(/\\r?\\n/g)<EOL>            .map(line => line.trim())<EOL>            .filter(line => line.length > <NUM_LIT> &&<EOL>            line.toLowerCase().endsWith('<STR_LIT>') &&<EOL>            line.indexOf('<STR_LIT>') > <NUM_LIT>);<EOL>        if (patch.startsWith('<STR_LIT>')) {<EOL>            <EOL>            patch = patch.substring(indexOfAtAt);<EOL>        }<EOL>        if (patch.length === <NUM_LIT>) {<EOL>            return;<EOL>        }<EOL>        <EOL>        if (fileNameLines.length === <NUM_LIT>) {<EOL>            return;<EOL>        }<EOL>        let fileName = fileNameLines[<NUM_LIT>].substring(fileNameLines[<NUM_LIT>].indexOf('<STR_LIT>') + <NUM_LIT>).trim();<EOL>        fileName = workspaceRoot && !path.isAbsolute(fileName) ? path.resolve(workspaceRoot, fileName) : fileName;<EOL>        if (!fs.existsSync(fileName)) {<EOL>            return;<EOL>        }<EOL>        <EOL>        <EOL>        patch = patch.replace(/\\\\ No newline at end of file[\\r\\n]/, '<STR_LIT>');<EOL>        const d = new dmp.diff_match_patch();<EOL>        const patches = patch_fromText.call(d, patch);<EOL>        if (!Array.isArray(patches) || patches.length === <NUM_LIT>) {<EOL>            throw new Error('<STR_LIT>');<EOL>        }<EOL>        const fileSource = fs.readFileSync(fileName).toString('<STR_LIT>');<EOL>        const fileUri = vscode.Uri.file(fileName);<EOL>        <EOL>        patches.forEach(p => {<EOL>            p.diffs.forEach(diff => {<EOL>                diff[<NUM_LIT>] += EOL;<EOL>            });<EOL>            getTextEditsInternal(fileSource, p.diffs, p.start1).forEach(edit => {<EOL>                switch (edit.action) {<EOL>","gt":"case EditAction.Delete:"}
{"input":"<s> export function navigatedTo(args: NavigatedData) {<EOL>    console.log(","gt":"args.isBackNavigation}`<STR_LIT>;"}
{"input":"<s> function getExports(instance: ViewBase): any {<EOL>    const isView = !!instance._domId;<EOL>    if (!isView) {<EOL>        return (<any>instance).exports || instance;<EOL>    }<EOL>    let exportObject = (<any>instance).exports;<EOL>    let parent = instance.parent;<EOL>    while (exportObject === undefined && parent) {<EOL>        exportObject = (<any>parent).exports;<EOL>","gt":"parent = parent.parent;"}
{"input":"<s> function subscribeForScrollNotifications(view: View) {<EOL>    if (view.nativeViewProtected instanceof UIScrollView) {<EOL>","gt":"view.on(\"<STR_LIT>\", onScroll);"}
{"input":"<s> export default function canPatchAssigneeToJavaScript(node: Node, isTopLevel: boolean = true): boolean {<EOL>    if (node instanceof Identifier || node instanceof MemberAccessOp ||<EOL>        node instanceof SoakedMemberAccessOp || node instanceof ProtoMemberAccessOp ||<EOL>        node instanceof DynamicMemberAccessOp || node instanceof SoakedDynamicMemberAccessOp ||<EOL>        node","gt":"instanceof SoakedProtoMemberAccessOp) {"}
{"input":"<s> export default function canPatchAssigneeToJavaScript(node: Node, isTopLevel: boolean = true): boolean {<EOL>    if (node instanceof Identifier || node instanceof MemberAccessOp ||<EOL>        node instanceof SoakedMemberAccessOp || node instanceof ProtoMemberAccessOp ||<EOL>        node instanceof DynamicMemberAccessOp || node instanceof SoakedDynamicMemberAccessOp ||<EOL>        node instanceof SoakedProtoMemberAccessOp) {<EOL>        return true;<EOL>    }<EOL>    if (node instanceof ArrayInitialiser) {<EOL>        <EOL>        <EOL>        if (!isTopLevel) {<EOL>            return false;<EOL>        }<EOL>        <EOL>        <EOL>        if (node.members.length === <NUM_LIT>) {<EOL>            return false;<EOL>        }<EOL>        return node.members.every((","gt":"member, i) => {"}
{"input":"<s> export default function canPatchAssigneeToJavaScript(node: Node, isTopLevel: boolean = true): boolean {<EOL>    if (node instanceof Identifier || node instanceof MemberAccessOp ||<EOL>        node instanceof SoakedMemberAccessOp || node instanceof ProtoMemberAccessOp ||<EOL>        node instanceof DynamicMemberAccessOp || node instanceof SoakedDynamicMemberAccessOp ||<EOL>        node instanceof SoakedProtoMemberAccessOp) {<EOL>        return true;<EOL>    }<EOL>    if (node instanceof ArrayInitialiser) {<EOL>        <EOL>        <EOL>        if (!isTopLevel) {<EOL>            return false;<EOL>        }<EOL>        <EOL>        <EOL>        if (node.members.length === <NUM_LIT>) {<EOL>            return false;<EOL>        }<EOL>        return node.members.every((member, i) => {<EOL>            let isInFinalPosition = i === node.members.length - <NUM_LIT>;<EOL>            if (isInFinalPosition && member instanceof Expansion) {<EOL>                return true;<EOL>            }<EOL>","gt":"if (isInFinalPosition &&"}
{"input":"<s> export default function canPatchAssigneeToJavaScript(node: Node, isTopLevel: boolean = true): boolean {<EOL>    if (node instanceof Identifier || node instanceof MemberAccessOp ||<EOL>        node instanceof SoakedMemberAccessOp || node instanceof ProtoMemberAccessOp ||<EOL>        node instanceof DynamicMemberAccessOp || node instanceof SoakedDynamicMemberAccessOp ||<EOL>        node instanceof SoakedProtoMemberAccessOp) {<EOL>        return true;<EOL>    }<EOL>    if (node instanceof ArrayInitialiser) {<EOL>        <EOL>        <EOL>        if (!isTopLevel) {<EOL>            return false;<EOL>        }<EOL>        <EOL>        <EOL>        if (node.members.length === <NUM_LIT>) {<EOL>            return false;<EOL>        }<EOL>        return node.members.every((member, i) => {<EOL>            let isInFinalPosition = i === node.members.length - <NUM_LIT>;<EOL>            if (isInFinalPosition && member instanceof Expansion) {<EOL>                return true;<EOL>            }<EOL>            if (isInFinalPosition &&<EOL>                (member instanceof Spread || member instanceof Rest) &&<EOL>                canPatchAssigneeToJavaScript(member.expression)) {<EOL>                return true;<EOL>            }<EOL>            return canPatchAssigneeToJavaScript(member, false);<EOL>        });<EOL>    }<EOL>    if (node instanceof ObjectInitialiser) {<EOL>        <EOL>        <EOL>        if (node.members.length === <NUM_LIT>) {<EOL>            return","gt":"false;"}
{"input":"<s> export default function formatCoffeeScriptLexerTokens(tokens: Array<Token>, context: CodeContext): string {<EOL>    let resultLines = tokens.map(([tag, value, locationData]) =>","gt":"value)}`<STR_LIT>;"}
{"input":"<s> export default function getCompareOperator(operator: string, negated: boolean): string {<EOL>    switch (operator) {<EOL>        case '<STR_LIT>':<EOL>        case '<STR_LIT>':<EOL>            return negated ? '<STR_LIT>' : '<STR_LIT>';<EOL>        case '<STR_LIT>':<EOL>","gt":"case '<STR_LIT>':"}
{"input":"<s> export default function getCompareOperator(operator: string, negated: boolean): string {<EOL>    switch (operator) {<EOL>        case '<STR_LIT>':<EOL>        case '<STR_LIT>':<EOL>            return negated ? '<STR_LIT>' : '<STR_LIT>';<EOL>        case '<STR_LIT>':<EOL>        case '<STR_LIT>':<EOL>            return negated ? '<STR_LIT>' : '<STR_LIT>';<EOL>        case '<STR_LIT>':<EOL>            return negated ? '<STR_LIT>' : '<STR_LIT>';<EOL>","gt":"case '<STR_LIT>':"}
{"input":"<s> export default function getCompareOperator(operator: string, negated: boolean): string {<EOL>    switch (operator) {<EOL>        case '<STR_LIT>':<EOL>        case '<STR_LIT>':<EOL>            return negated ? '<STR_LIT>' : '<STR_LIT>';<EOL>        case '<STR_LIT>':<EOL>        case '<STR_LIT>':<EOL>            return negated ? '<STR_LIT>' : '<STR_LIT>';<EOL>        case '<STR_LIT>':<EOL>            return negated ? '<STR_LIT>' : '<STR_LIT>';<EOL>        case '<STR_LIT>':<EOL>            return negated ? '<STR_LIT>' : '<STR_LIT>';<EOL>        case '<STR_LIT>':<EOL>            return negated ? '<STR_LIT>' : '<STR_LIT>';<EOL>        case","gt":"'<STR_LIT>':"}
{"input":"<s> export function setFontWeightWithParents(counts: Array<number>, parent: LayoutBase): string {<EOL>    let result = `<STR_LIT>`;<EOL>    const style = parent.style;<EOL>    counts.forEach((count) => {<EOL>        if (count > <NUM_LIT>) {<EOL>            result += setResultTime(","gt":"noValue);"}
{"input":"<s> export function setFontWeightWithParents(counts: Array<number>, parent: LayoutBase): string {<EOL>    let result = `<STR_LIT>`;<EOL>    const style = parent.style;<EOL>    counts.forEach((count) => {<EOL>        if (count > <NUM_LIT>) {<EOL>            result += setResultTime(noValue);<EOL>            return;<EOL>        }<EOL>        setupParents(parent);<EOL>        const","gt":"time = executeTest(() => {"}
{"input":"<s> /**<EOL> * Determines whether a node represents a function, i.e. `->` or `=>`.<EOL> */<EOL>export function isFunction(node: Node, allowBound: boolean = true): boolean {<EOL>    return node.type === '<STR_LIT>' || node.type ===","gt":"'<STR_LIT>' ||"}
{"input":"<s> /**<EOL> * Gets the indent string for the line containing offset.<EOL> */<EOL>export default function getIndent(source: string, offset: number): string {<EOL>    let startOfLine = getStartOfLine(source, offset);<EOL>    let indentOffset = startOfLine;<EOL>    let indentCharacter;<EOL>    switch (source[indentOffset]) {<EOL>","gt":"case '<STR_LIT>':"}
{"input":"<s> /**<EOL> * Gets the indent string for the line containing offset.<EOL> */<EOL>export default function getIndent(source: string, offset: number): string {<EOL>    let startOfLine = getStartOfLine(source, offset);<EOL>    let indentOffset = startOfLine;<EOL>    let indentCharacter;<EOL>    switch (source[indentOffset]) {<EOL>        case '<STR_LIT>':<EOL>        case '<STR_LIT>':<EOL>            indentCharacter = source[indentOffset];<EOL>            break;<EOL>","gt":"default:"}
{"input":"<s> /**<EOL> * Gets the indent string for the line containing offset.<EOL> */<EOL>export default function getIndent(source: string, offset: number): string {<EOL>    let startOfLine = getStartOfLine(source, offset);<EOL>    let indentOffset = startOfLine;<EOL>    let indentCharacter;<EOL>    switch (source[indentOffset]) {<EOL>        case '<STR_LIT>':<EOL>        case '<STR_LIT>':<EOL>            indentCharacter = source[indentOffset];<EOL>            break;<EOL>        default:<EOL>            return '<STR_LIT>';<EOL>    }<EOL>    while (source[indentOffset] ===","gt":"indentCharacter) {"}
{"input":"<s> /**<EOL> * Supported parameter types: boolean, string, choice, password<EOL> *<EOL> * - If a parameter is not defined by Jenkins it is fine to pass it anyway<EOL> * - Anything passed to a boolean parameter other than 'true' (case insenstive) becomes false.<EOL> * - Invalid choice parameters result in a 500 response.<EOL> *<EOL> */<EOL>function parseJobParameters(jobParameters: string[]): any {<EOL>    let formData: any = {};<EOL>    for (let i: number = <NUM_LIT>; i < jobParameters.length; i++) {<EOL>        const paramLine: string = jobParameters[i].trim();<EOL>        const splitIndex: number = paramLine.indexOf(","gt":"'<STR_LIT>');"}
{"input":"<s> /**<EOL> * Supported parameter types: boolean, string, choice, password<EOL> *<EOL> * - If a parameter is not defined by Jenkins it is fine to pass it anyway<EOL> * - Anything passed to a boolean parameter other than 'true' (case insenstive) becomes false.<EOL> * - Invalid choice parameters result in a 500 response.<EOL> *<EOL> */<EOL>function parseJobParameters(jobParameters: string[]): any {<EOL>    let formData: any = {};<EOL>    for (let i: number = <NUM_LIT>; i < jobParameters.length; i++) {<EOL>        const paramLine: string = jobParameters[i].trim();<EOL>        const splitIndex: number = paramLine.indexOf('<STR_LIT>');<EOL>        if (splitIndex <= <NUM_LIT>) { <EOL>            throw '<STR_LIT>' + jobParameters[i];<EOL>        }<EOL>        const paramName: string = paramLine.substr(<NUM_LIT>, splitIndex).trim();<EOL>        const paramValue: string = paramLine.slice(splitIndex + <NUM_LIT>).trim();<EOL>        formData[","gt":"paramName] = paramValue;"}
{"input":"<s> export function buttonTap(args: observable.EventData) {<EOL>    count++;<EOL>    obj.set(\"<STR_LIT>\", obj.get(\"<STR_LIT>\") + <NUM_LIT>);<EOL>    subObj.set(\"<STR_LIT>\", subObj.get(\"<STR_LIT>\") + <NUM_LIT>);<EOL>    var parent = (<view.View>args.object).parent;<EOL>","gt":"if (parent) {"}
{"input":"<s> function getMemoryUsage(args: EventData) {<EOL>    var mi = new android.app.ActivityManager.MemoryInfo();<EOL>    var activityManager = application.android.context.getSystemService(android.content.Context.ACTIVITY_SERVICE);<EOL>    activityManager.","gt":"getMemoryInfo(mi);"}
{"input":"<s> async function bar3() {<EOL>    void await","gt":"<NUM_LIT>;"}
{"input":"<s> <EOL>async function* f17() {<EOL>    await","gt":"<NUM_LIT>;"}
{"input":"<s> function foo<T extends Foo, U extends Foo>(t: T, u: U) {<EOL>    var a: T;<EOL>    var b: U;<EOL>","gt":"t = a;"}
{"input":"<s> export function pageLoaded(args: EventData) {<EOL>    const","gt":"page = <Page>args.object;"}
{"input":"<s> export function feedbackTap(args) {<EOL>    console.","gt":"log(\"<STR_LIT>\");"}
{"input":"<s> export function testNativeFields() {<EOL>    const img = imageSource.fromFile(imagePath);<EOL>    if (app.android) {<EOL>        TKUnit.","gt":"assert(img.android != null, \"<STR_LIT>\");"}
{"input":"<s> function g(x: string): number {<EOL>","gt":"return <NUM_LIT>;"}
{"input":"<s> export function testBase64Encode_PNG() {<EOL>    <EOL>    const","gt":"img = imageSource.fromFile(smallImagePath);"}
{"input":"<s> export function setBindingContext(counts: Array<number>, parent?: LayoutBase): string {<EOL>    let result = `<STR_LIT>`;<EOL>    counts.forEach((count) => {<EOL>        const lbl = setup(parent);<EOL>","gt":"const time = executeTest(() => {"}
{"input":"<s> export function setBindingContext(counts: Array<number>, parent?: LayoutBase): string {<EOL>    let result = `<STR_LIT>`;<EOL>    counts.forEach((count) => {<EOL>        const lbl = setup(parent);<EOL>        const time = executeTest(() => {<EOL>            for (let i = <NUM_LIT>; i < count; i++) {<EOL>                lbl.bindingContext = colors[i % <NUM_LIT>];<EOL>            }<EOL>        });<EOL>","gt":"result += setResultTime(time);"}
{"input":"<s> function f6() {<EOL>    let x = new Mixed5();<EOL>    x.","gt":"p;"}
{"input":"<s> <EOL><EOL><EOL><EOL>/**<EOL> * @param {T} a<EOL> * @template T<EOL> */<EOL>function f(a) {<EOL>    return () =>","gt":"a;"}
{"input":"<s> function time(): number {<EOL>    if (global.android) {<EOL>","gt":"return (<any>global).java.lang.System.nanoTime() / <NUM_LIT>;"}
{"input":"<s> export function getSystemInfo(info: IMainProcessInfo): SystemInfo {<EOL>    const MB = <NUM_LIT> * <NUM_LIT>;<EOL>    const GB = <NUM_LIT> * MB;<EOL>    const systemInfo: SystemInfo = {<EOL>        '<STR_LIT>': `<STR_LIT>`,<EOL>","gt":"VM: `<STR_LIT>`,"}
{"input":"<s> export function getSystemInfo(info: IMainProcessInfo): SystemInfo {<EOL>    const MB = <NUM_LIT> * <NUM_LIT>;<EOL>    const GB = <NUM_LIT> * MB;<EOL>    const systemInfo: SystemInfo = {<EOL>        '<STR_LIT>': `<STR_LIT>`,<EOL>        VM: `<STR_LIT>`,<EOL>        '<STR_LIT>': `<STR_LIT>`,<EOL>        '<STR_LIT>': `<STR_LIT>`<EOL>    };<EOL>    const cpus = os.","gt":"cpus();"}
{"input":"<s> export function getSystemInfo(info: IMainProcessInfo): SystemInfo {<EOL>    const MB = <NUM_LIT> * <NUM_LIT>;<EOL>    const GB = <NUM_LIT> * MB;<EOL>    const systemInfo: SystemInfo = {<EOL>        '<STR_LIT>': `<STR_LIT>`,<EOL>        VM: `<STR_LIT>`,<EOL>        '<STR_LIT>': `<STR_LIT>`,<EOL>        '<STR_LIT>': `<STR_LIT>`<EOL>    };<EOL>    const cpus = os.cpus();<EOL>    if (cpus && cpus.length > <NUM_LIT>) {<EOL>        systemInfo.CPUs = `<STR_LIT>`;<EOL>    }<EOL>","gt":"if (!isWindows) {"}
{"input":"<s> export function onModalFrame(args: EventData) {<EOL>    const view = args.","gt":"object as View;"}
{"input":"<s> export function selectFile(args: observable.EventData) {<EOL>    var vm = <codePageVM.CodePageViewModel>(<view.View>args.object).bindingContext;<EOL>    var options = vm.files.map((file) => file.name);<EOL>    dialogs.action({<EOL>        cancelButtonText:","gt":"\"<STR_LIT>\","}
{"input":"<s> export function selectFile(args: observable.EventData) {<EOL>    var vm = <codePageVM.CodePageViewModel>(<view.View>args.object).bindingContext;<EOL>    var options = vm.files.map((file) => file.name);<EOL>    dialogs.action({<EOL>        cancelButtonText: \"<STR_LIT>\",<EOL>        actions: vm.files.map((file) => file.name),<EOL>    }).then((selectedFile) => {<EOL>        vm.selectFile(selectedFile);<EOL>    }, (","gt":"error) => {"}
{"input":"<s> export function onItemWidthItemHeight(args: {<EOL>    eventName: string;<EOL>    object: any;<EOL>}) {<EOL>    var layout =","gt":"args.object.parent;"}
{"input":"<s> export function tileTouch(args: gestures.TouchGestureEventData) {<EOL>","gt":"grayTouch(args);"}
{"input":"<s> export function createMessageConnection(input: MessageReader | NodeJS.ReadableStream, output: MessageWriter | NodeJS.WritableStream, logger?: Logger, strategy?: ConnectionStrategy): MessageConnection {<EOL>    if (!logger) {<EOL>        logger =","gt":"NullLogger;"}
{"input":"<s> export function getSingleViewRecursive(nodes: Array<any>, nestLevel: number): View {<EOL>    const actualNodes = nodes.filter(node => !(node instanceof InvisibleNode));<EOL>    if (actualNodes.length === <NUM_LIT>) {<EOL>        throw new Error(`<STR_LIT>` +<EOL>            `<STR_LIT>`);<EOL>    }<EOL>    else if (","gt":"actualNodes.length > <NUM_LIT>) {"}
{"input":"<s> export function getSingleViewRecursive(nodes: Array<any>, nestLevel: number): View {<EOL>    const actualNodes = nodes.filter(node => !(node instanceof InvisibleNode));<EOL>    if (actualNodes.length === <NUM_LIT>) {<EOL>        throw new Error(`<STR_LIT>` +<EOL>            `<STR_LIT>`);<EOL>    }<EOL>    else if (actualNodes.length > <NUM_LIT>) {<EOL>        throw new Error(`<STR_LIT>` +<EOL>            `<STR_LIT>`);<EOL>    }<EOL>    const rootLayout =","gt":"actualNodes[<NUM_LIT>];"}
{"input":"<s> export function getSingleViewRecursive(nodes: Array<any>, nestLevel: number): View {<EOL>    const actualNodes = nodes.filter(node => !(node instanceof InvisibleNode));<EOL>    if (actualNodes.length === <NUM_LIT>) {<EOL>        throw new Error(`<STR_LIT>` +<EOL>            `<STR_LIT>`);<EOL>    }<EOL>    else if (actualNodes.length > <NUM_LIT>) {<EOL>        throw new Error(`<STR_LIT>` +<EOL>            `<STR_LIT>`);<EOL>    }<EOL>    const rootLayout = actualNodes[<NUM_LIT>];<EOL>    if (!rootLayout) {<EOL>        return getSingleViewRecursive(rootLayout.children, nestLevel + <NUM_LIT>);<EOL>    }<EOL>","gt":"const parentLayout = rootLayout.parent;"}
{"input":"<s> function setResultTime(time: string) {<EOL>    return","gt":"time}`<STR_LIT>;"}
{"input":"<s> function toggleDrawerState() {<EOL>    var instance = sideDrawer();<EOL>","gt":"if (instance) {"}
{"input":"<s> function setLaunched() {<EOL>    launched =","gt":"true;"}
{"input":"<s> export function onUpdateButtonTapped(args: EventData) {<EOL>","gt":"notify(\"<STR_LIT>\");"}
{"input":"<s> <EOL><EOL><EOL>function f1() {<EOL>    if (true) {<EOL>","gt":"return <NUM_LIT>;"}
{"input":"<s> export function attachDOMInspectorCommandCallbacks(DOMDomainBackend: InspectorCommands) {<EOL>    DOMDomainBackend.getDocument =","gt":"getDocument;"}
{"input":"<s> export function memoize<T extends (...args: any[]) => any>(func: T, resolver?: (...args: any[]) => any): T {<EOL>    return _.memoize(","gt":"func, resolver);"}
{"input":"<s> export function findCommonParent(list: string[]): string {<EOL>    tl.debug(\"<STR_LIT>\");<EOL>    function cutTail(list: string[], n: number) {<EOL>        while (n-- > <NUM_LIT>) {<EOL>            list.","gt":"pop();"}
{"input":"<s> export function findCommonParent(list: string[]): string {<EOL>    tl.debug(\"<STR_LIT>\");<EOL>    function cutTail(list: string[], n: number) {<EOL>        while (n-- > <NUM_LIT>) {<EOL>            list.pop();<EOL>        }<EOL>    }<EOL>    if (!list) {<EOL>","gt":"return null;"}
{"input":"<s> export function findCommonParent(list: string[]): string {<EOL>    tl.debug(\"<STR_LIT>\");<EOL>    function cutTail(list: string[], n: number) {<EOL>        while (n-- > <NUM_LIT>) {<EOL>            list.pop();<EOL>        }<EOL>    }<EOL>    if (!list) {<EOL>        return null;<EOL>    }<EOL>    let commonSegments: string[] = [];<EOL>    let parentPath: string = null;<EOL>    list.forEach((","gt":"nextPath, idx) => {"}
{"input":"<s> export function findCommonParent(list: string[]): string {<EOL>    tl.debug(\"<STR_LIT>\");<EOL>    function cutTail(list: string[], n: number) {<EOL>        while (n-- > <NUM_LIT>) {<EOL>            list.pop();<EOL>        }<EOL>    }<EOL>    if (!list) {<EOL>        return null;<EOL>    }<EOL>    let commonSegments: string[] = [];<EOL>    let parentPath: string = null;<EOL>    list.forEach((nextPath, idx) => {<EOL>        tl.debug(`<STR_LIT>`);<EOL>        if (idx === <NUM_LIT>) {<EOL>            <EOL>            commonSegments = nextPath.split(\"<STR_LIT>\");<EOL>        }<EOL>        else if (commonSegments.length === <NUM_LIT>) {<EOL>            <EOL>            <EOL>","gt":"return null;"}
{"input":"<s> function isDefined(object: any): boolean {<EOL>    return object !== undefined && object !==","gt":"null;"}
{"input":"<s> function compareChanges(a: IChange, b: IChange): number {<EOL>    let result = a.modifiedStartLineNumber - b.modifiedStartLineNumber;<EOL>    if (result !== <NUM_LIT>) {<EOL>        return result;<EOL>    }<EOL>    result = a.modifiedEndLineNumber - b.modifiedEndLineNumber;<EOL>    if (result !== <NUM_LIT>) {<EOL>        return result;<EOL>    }<EOL>    result = a.originalStartLineNumber - b.originalStartLineNumber;<EOL>    if (result !==","gt":"<NUM_LIT>) {"}
{"input":"<s> export function createPage() {<EOL>    var page = new pages.Page();<EOL>    var stack = new stackModule.StackLayout();<EOL>    var btn = new button.Button();<EOL>    btn.text = \"<STR_LIT>\";<EOL>    btn.on(button.Button.","gt":"tapEvent, function () {"}
{"input":"<s> export function createPage() {<EOL>    var page = new pages.Page();<EOL>    var stack = new stackModule.StackLayout();<EOL>    var btn = new button.Button();<EOL>    btn.text = \"<STR_LIT>\";<EOL>    btn.on(button.Button.tapEvent, function () {<EOL>        var nextPage = \"<STR_LIT>\";<EOL>        frame.topmost().navigate(nextPage);<EOL>    });<EOL>    stack.addChild(btn);<EOL>    var txt = new text.TextField();<EOL>    txt.text =","gt":"\"<STR_LIT>\";"}
{"input":"<s> /**<EOL> * @deprecated use getReq instead<EOL> *<EOL> * Gets a movie by id<EOL> *<EOL> * @param imdbid id to search for<EOL> * @param opts options that modify a search<EOL> * @param cb optional callback to execute after finding results<EOL> *<EOL> * @return a promise yielding a movie<EOL> */<EOL>export function getById(imdbid: string, opts: MovieOpts, cb?: (err: Error, data: Movie) => any): Promise<Movie> {<EOL>","gt":"return getReq({ id: imdbid, opts, name: undefined }, cb);"}
{"input":"<s> function modelHasDecorations(model: Model, decorations: ILightWeightDecoration2[]) {<EOL>    let modelDecorations: ILightWeightDecoration2[] = [];<EOL>    let actualDecorations = model.getAllDecorations();<EOL>    for (let i = <NUM_LIT>, len = actualDecorations.length; i < len; i++) {<EOL>        modelDecorations.","gt":"push({"}
{"input":"<s> export function testPage(layout: StackLayout): string {<EOL>","gt":"return test(layout, () => new Page(), count);"}
{"input":"<s> <EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL>export function pageLoaded(args) {<EOL>    let page = args.object;<EOL>","gt":"let obj = new observable.Observable();"}
{"input":"<s> export function createPage() {<EOL>    var stackLayout = new stackLayoutModule.StackLayout();<EOL>    var label = new labelModule.Label();<EOL>    label.text = \"<STR_LIT>\";<EOL>    var","gt":"textView = new textViewModule.TextView();"}
{"input":"<s> export function createPage() {<EOL>    var stackLayout = new stackLayoutModule.StackLayout();<EOL>    var label = new labelModule.Label();<EOL>    label.text = \"<STR_LIT>\";<EOL>    var textView = new textViewModule.TextView();<EOL>    textView.text = \"<STR_LIT>\";<EOL>    stackLayout.addChild(label);<EOL>    stackLayout.addChild(textView);<EOL>    var page = new pageModule.Page();<EOL>    page.on(pageModule.Page.loadedEvent, function () {<EOL>","gt":"pageLoaded();"}
{"input":"<s> export function goBack(args) {<EOL>","gt":"navigator.navigateBackFromExample();"}
{"input":"<s> export function setupEditorTable(editor) {<EOL>    hideSeparator(editor);<EOL>    hideBackground(editor);<EOL>    var pickerDelegate = UIPickerViewDelegateImplementation.","gt":"new().initWithOwner(editor);"}
{"input":"<s> export default function redo<T>(history: DagHistory<T>): DagHistory<T> {<EOL>    const { graph } = history;<EOL>    const reader = new DagGraph(graph);<EOL>    const children = reader<EOL>        .","gt":"childrenOf(reader.currentStateId)"}
{"input":"<s> function isConnected(): boolean {<EOL>    return this.","gt":"connection.isConnected();"}
{"input":"<s> export function createCheckNodeRule<TOptions>(checkNode: CheckNodeFunction<TOptions>, failureString: string, <EOL><EOL>parseOptions: (ruleArguments: any[]) => TOptions = defaultParseOptions<EOL><EOL>): any {<EOL>    return class Rule extends Lint.Rules.AbstractRule {<EOL>","gt":"public apply(sourceFile: ts.SourceFile): Lint.RuleFailure[] {"}
{"input":"<s> function ensureAppRootPath() {<EOL>    if (!applicationRootPath) {<EOL>        applicationRootPath = knownFolders.","gt":"currentApp().path;"}
{"input":"<s> function getGridObjectSizeModifiers(size, isOffset) {<EOL>    return Object.keys(size).reduce((acc, key) => {<EOL>        if (key ===","gt":"'<STR_LIT>')"}
{"input":"<s> function getServerInfo(): Promise<GetServerInfoResponse> {<EOL>    return common.","gt":"serverInfo.getServerInfo(this.connection);"}
{"input":"<s> export function test_watch_listerer_is_removed_at_onDetach() {<EOL>    if (platform.isAndroid) {<EOL>        helper.buildUIAndRunTest(_createTextViewFunc(), (views: Array<viewModule.View>) => {<EOL>            let tv = <textViewModule.TextView>views[<NUM_LIT>];<EOL>            let","gt":"page = <pagesModule.Page>tv.page;"}
{"input":"<s> export function test_watch_listerer_is_removed_at_onDetach() {<EOL>    if (platform.isAndroid) {<EOL>        helper.buildUIAndRunTest(_createTextViewFunc(), (views: Array<viewModule.View>) => {<EOL>            let tv = <textViewModule.TextView>views[<NUM_LIT>];<EOL>            let page = <pagesModule.Page>tv.page;<EOL>            let editText = tv.android;<EOL>            editText.setText(\"<STR_LIT>\");<EOL>            page.content = null;<EOL>            editText.setText(","gt":"\"<STR_LIT>\");"}
{"input":"<s> function setupDefaultAnimations(entry: ExpandedEntry, transition: Transition): void {<EOL>    const listener = getAnimationListener();<EOL>    const enterAnimator = <ExpandedAnimator>transition.createAndroidAnimator(AndroidTransitionType.enter);<EOL>    enterAnimator.transitionType = AndroidTransitionType.enter;<EOL>","gt":"enterAnimator.entry = entry;"}
{"input":"<s> function setupDefaultAnimations(entry: ExpandedEntry, transition: Transition): void {<EOL>    const listener = getAnimationListener();<EOL>    const enterAnimator = <ExpandedAnimator>transition.createAndroidAnimator(AndroidTransitionType.enter);<EOL>    enterAnimator.transitionType = AndroidTransitionType.enter;<EOL>    enterAnimator.entry = entry;<EOL>    enterAnimator.addListener(listener);<EOL>    entry.defaultEnterAnimator = enterAnimator;<EOL>    const exitAnimator = <ExpandedAnimator>transition.createAndroidAnimator(AndroidTransitionType.exit);<EOL>    exitAnimator.transitionType = AndroidTransitionType.exit;<EOL>    exitAnimator.entry =","gt":"entry;"}
{"input":"<s> /**<EOL> * Determine if a ts.HeritageClause is React HeritageClause<EOL> *<EOL> * @example `extends React.Component<{}, {}>` is a React HeritageClause<EOL> *<EOL> * @todo: this is lazy. Use the typeChecker instead<EOL> * @param clause<EOL> */<EOL>export function isReactHeritageClause(clause: ts.HeritageClause) {<EOL>    return (clause.token === ts.SyntaxKind.ExtendsKeyword &&<EOL>        clause.","gt":"types.length === <NUM_LIT> &&"}
{"input":"<s> export function navigatingTo(args) {<EOL>    args.object.","gt":"bindingContext = firebase.viewModel;"}
{"input":"<s> function pathExistsAsync(path: string) {<EOL>    return","gt":"statAsync(path)"}
{"input":"<s> <EOL>function shuffleArray(array) {<EOL>    for (var i = array.length - <NUM_LIT>; i > <NUM_LIT>; i--) {<EOL>        var j = Math.floor(Math.random() * (i + <NUM_LIT>));<EOL>        var temp =","gt":"array[i];"}
{"input":"<s> export function test_parse_ShouldResolveExportsFromCodeFile() {<EOL>    var page = builder.parse(","gt":"\"<STR_LIT>\");"}
{"input":"<s> export function onChangeText(args) {<EOL>    const page = <Page>args.object.page;<EOL>    const lblElelemtn = <Label>page.getViewById(\"<STR_LIT>\");<EOL>    const btnElement = <Button>page.getViewById(\"<STR_LIT>\");<EOL>    const textFieldElement = <TextField>page.getViewById(","gt":"\"<STR_LIT>\");"}
{"input":"<s> export function onChangeText(args) {<EOL>    const page = <Page>args.object.page;<EOL>    const lblElelemtn = <Label>page.getViewById(\"<STR_LIT>\");<EOL>    const btnElement = <Button>page.getViewById(\"<STR_LIT>\");<EOL>    const textFieldElement = <TextField>page.getViewById(\"<STR_LIT>\");<EOL>    const textViewElement = <TextView>page.getViewById(\"<STR_LIT>\");<EOL>    if (lblElelemtn.text === \"<STR_LIT>\") {<EOL>        lblElelemtn.text = btnElement.text = textFieldElement.text = textViewElement.text = \"<STR_LIT>\";<EOL>    }<EOL>","gt":"else {"}
{"input":"<s> export function getNativeBackgroundColor(button: buttonModule.Button): colorModule.Color {<EOL>    var bkg = <any>button.android.getBackground();<EOL>    if (bkg instanceof org.nativescript.widgets.BorderDrawable) {<EOL>        return new","gt":"colorModule.Color((<org.nativescript.widgets.BorderDrawable>bkg).getBackgroundColor());"}
{"input":"<s> export function ignore_test_DummyTestForSnippetOnly3() {<EOL>    <EOL>    const navigationEntry: NavigationEntry = {<EOL>","gt":"moduleName: \"<STR_LIT>\","}
{"input":"<s> function formatBalances(options, balances) {<EOL>    const result = balances.trustlines.map(getTrustlineBalanceAmount);<EOL>    if (!(options.counterparty ||<EOL>        (options.currency && options.currency !== '<STR_LIT>'))) {<EOL>        const xrpBalance = {<EOL>","gt":"currency: '<STR_LIT>',"}
{"input":"<s> function formatBalances(options, balances) {<EOL>    const result = balances.trustlines.map(getTrustlineBalanceAmount);<EOL>    if (!(options.counterparty ||<EOL>        (options.currency && options.currency !== '<STR_LIT>'))) {<EOL>        const xrpBalance = {<EOL>            currency: '<STR_LIT>',<EOL>            value: balances.xrp<EOL>        };<EOL>        result.unshift(xrpBalance);<EOL>    }<EOL>    if (options.limit && result.length > options.limit) {<EOL>","gt":"const toRemove = result.length - options.limit;"}
{"input":"<s> export function createPage() {<EOL>    var page = new pages.Page();<EOL>    var stack = new stackModule.StackLayout();<EOL>    var btn = new button.Button();<EOL>    btn.text =","gt":"\"<STR_LIT>\";"}
{"input":"<s> export function createPage() {<EOL>    var page = new pages.Page();<EOL>    var stack = new stackModule.StackLayout();<EOL>    var btn = new button.Button();<EOL>    btn.text = \"<STR_LIT>\";<EOL>    btn.on(button.Button.tapEvent, function () {<EOL>        var nextPage = \"<STR_LIT>\";<EOL>        frame.","gt":"topmost().navigate(nextPage);"}
{"input":"<s> export function createPage() {<EOL>    var page = new pages.Page();<EOL>    var stack = new stackModule.StackLayout();<EOL>    var btn = new button.Button();<EOL>    btn.text = \"<STR_LIT>\";<EOL>    btn.on(button.Button.tapEvent, function () {<EOL>        var nextPage = \"<STR_LIT>\";<EOL>        frame.topmost().navigate(nextPage);<EOL>    });<EOL>    stack.addChild(btn);<EOL>    var backBtn = new button.Button();<EOL>    backBtn.","gt":"text = \"<STR_LIT>\";"}
{"input":"<s> export function createPage() {<EOL>    var page = new pages.Page();<EOL>    var stack = new stackModule.StackLayout();<EOL>    var btn = new button.Button();<EOL>    btn.text = \"<STR_LIT>\";<EOL>    btn.on(button.Button.tapEvent, function () {<EOL>        var nextPage = \"<STR_LIT>\";<EOL>        frame.topmost().navigate(nextPage);<EOL>    });<EOL>    stack.addChild(btn);<EOL>    var backBtn = new button.Button();<EOL>    backBtn.text = \"<STR_LIT>\";<EOL>    backBtn.on(button.Button.tapEvent, function () {<EOL>        frame.topmost().goBack();<EOL>    });<EOL>    stack.addChild(backBtn);<EOL>    var txt = new text.","gt":"TextField();"}
{"input":"<s> function f(x: string): void {<EOL>","gt":"return;"}
{"input":"<s> export function error(message: any, ...args: any[]) {<EOL>    LogView.add(Severity.error, message, ...","gt":"args);"}
{"input":"<s> export function applySeparatorOffset(editor, value) {<EOL>    editor.","gt":"style.separatorLeadingSpace = value;"}
{"input":"<s> function schemaValidate(schemaName: string, object: any): void {<EOL>    <EOL>    const schema = schemaValidator.getSchema('<STR_LIT>' + schemaName);<EOL>","gt":"if (schema === undefined) {"}
{"input":"<s> function toShortString(nativeTransition: android.transition.Transition): string {<EOL>    return","gt":"nativeTransition.hashCode().toString(<NUM_LIT>)}`<STR_LIT>;"}
{"input":"<s> function _test_NavigationEvents_WithBackstackVisibile_False_Forward_Back(transition?: NavigationTransition) {<EOL>    const topmost = topmostFrame();<EOL>    const mainTestPage = topmost.currentPage;<EOL>    let actualSecondPageEvents = new Array<string>();<EOL>    let secondPageFactory = function (): Page {<EOL>        const secondPage =","gt":"new Page();"}
{"input":"<s> function _test_NavigationEvents_WithBackstackVisibile_False_Forward_Back(transition?: NavigationTransition) {<EOL>    const topmost = topmostFrame();<EOL>    const mainTestPage = topmost.currentPage;<EOL>    let actualSecondPageEvents = new Array<string>();<EOL>    let secondPageFactory = function (): Page {<EOL>        const secondPage = new Page();<EOL>        secondPage.actionBarHidden = true;<EOL>        secondPage.id = \"<STR_LIT>\";<EOL>","gt":"attachEventListeners(secondPage, actualSecondPageEvents);"}
{"input":"<s> function _test_NavigationEvents_WithBackstackVisibile_False_Forward_Back(transition?: NavigationTransition) {<EOL>    const topmost = topmostFrame();<EOL>    const mainTestPage = topmost.currentPage;<EOL>    let actualSecondPageEvents = new Array<string>();<EOL>    let secondPageFactory = function (): Page {<EOL>        const secondPage = new Page();<EOL>        secondPage.actionBarHidden = true;<EOL>        secondPage.id = \"<STR_LIT>\";<EOL>        attachEventListeners(secondPage, actualSecondPageEvents);<EOL>        secondPage.style.backgroundColor = new Color(<NUM_LIT>, Math.round(Math.random() * <NUM_LIT>), Math.round(Math.random() * <NUM_LIT>), Math.round(Math.random() * <NUM_LIT>));<EOL>        return secondPage;<EOL>    };<EOL>    <EOL>    helper.","gt":"navigateWithEntry({ create: secondPageFactory, transition: transition, animated: !!transition, backstackVisible: false });"}
{"input":"<s> function expand(pattern: string): string[] {<EOL>    if (pattern.match(/\\*\\*|[\\[\\]]/))<EOL>        throw new Error(`<STR_LIT>`);<EOL>    assert(pattern === '<STR_LIT>' || pattern.match(/{[^{}]*}|.[^{]*/g)!.join('<STR_LIT>') === pattern);<EOL>    return pattern === '<STR_LIT>'<EOL>        ? [","gt":"pattern]"}
{"input":"<s> function expand(pattern: string): string[] {<EOL>    if (pattern.match(/\\*\\*|[\\[\\]]/))<EOL>        throw new Error(`<STR_LIT>`);<EOL>    assert(pattern === '<STR_LIT>' || pattern.match(/{[^{}]*}|.[^{]*/g)!.join('<STR_LIT>') === pattern);<EOL>    return pattern === '<STR_LIT>'<EOL>        ? [pattern]<EOL>        : Sequence.from(pattern.match(/{[^{}]*}|.[^{]*/g)!)<EOL>            .map(p => p.match(/^{[^{}]*}$/)<EOL>            ? p.slice(<NUM_LIT>, -<NUM_LIT>).split('<STR_LIT>')<EOL>            : [","gt":"p])"}
{"input":"<s> function expand(pattern: string): string[] {<EOL>    if (pattern.match(/\\*\\*|[\\[\\]]/))<EOL>        throw new Error(`<STR_LIT>`);<EOL>    assert(pattern === '<STR_LIT>' || pattern.match(/{[^{}]*}|.[^{]*/g)!.join('<STR_LIT>') === pattern);<EOL>    return pattern === '<STR_LIT>'<EOL>        ? [pattern]<EOL>        : Sequence.from(pattern.match(/{[^{}]*}|.[^{]*/g)!)<EOL>            .map(p => p.match(/^{[^{}]*}$/)<EOL>            ? p.slice(<NUM_LIT>, -<NUM_LIT>).split('<STR_LIT>')<EOL>            : [p])<EOL>            .mapM(Sequence.from)<EOL>            .map(ps => ps.join('<STR_LIT>'))<EOL>            .bind(p => p === pattern<EOL>            ?","gt":"Sequence.from([p])"}
{"input":"<s> function collectSyntaxRanges(providers: FoldingProvider[], model: ITextModel): TPromise<IFoldingRangeData[]> {<EOL>    const rangeData: IFoldingRangeData[] = [];<EOL>    let promises = providers.map((provider, rank) => asWinJsPromise(token => provider.provideFoldingRanges(model, token)).then(list => {<EOL>        if (list && Array.isArray(list.ranges)) {<EOL>            let nLines = model.getLineCount();<EOL>            for (","gt":"let r of list.ranges) {"}
{"input":"<s> function collectSyntaxRanges(providers: FoldingProvider[], model: ITextModel): TPromise<IFoldingRangeData[]> {<EOL>    const rangeData: IFoldingRangeData[] = [];<EOL>    let promises = providers.map((provider, rank) => asWinJsPromise(token => provider.provideFoldingRanges(model, token)).then(list => {<EOL>        if (list && Array.isArray(list.ranges)) {<EOL>            let nLines = model.getLineCount();<EOL>            for (let r of list.ranges) {<EOL>                if (r.startLineNumber > <NUM_LIT> && r.endLineNumber > r.startLineNumber && r.endLineNumber <= nLines) {<EOL>                    rangeData.push({ startLineNumber: r.startLineNumber, endLineNumber: r.endLineNumber, rank, type: r.type });<EOL>                }<EOL>            }<EOL>        }<EOL>    },","gt":"onUnexpectedExternalError));"}
{"input":"<s> function parseAccountTxTransaction(tx) {<EOL>    const _tx = tx.tx_blob ? parseBinaryTransaction(","gt":"tx) : tx;"}
{"input":"<s> function orderFilter(options: TransactionsOptions, tx: TransactionType) {<EOL>","gt":"return !options.startTx || (options.earliestFirst ?"}
{"input":"<s> function systemjsConfigJsCode() {<EOL>","gt":"return `<STR_LIT>`"}
{"input":"<s> export function getEmmetConfiguration(syntax: string) {<EOL>    const emmetConfig = vscode.workspace.getConfiguration('<STR_LIT>');<EOL>    const syntaxProfiles = Object.assign({}, emmetConfig['<STR_LIT>'] || {});<EOL>    <EOL>    if (syntax ===","gt":"'<STR_LIT>' || syntax === '<STR_LIT>' || syntax === '<STR_LIT>') {"}
{"input":"<s> export function getEmmetConfiguration(syntax: string) {<EOL>    const emmetConfig = vscode.workspace.getConfiguration('<STR_LIT>');<EOL>    const syntaxProfiles = Object.assign({}, emmetConfig['<STR_LIT>'] || {});<EOL>    <EOL>    if (syntax === '<STR_LIT>' || syntax === '<STR_LIT>' || syntax === '<STR_LIT>') {<EOL>        syntaxProfiles[syntax] = syntaxProfiles[syntax] || {};<EOL>        if (typeof syntaxProfiles[syntax] === '<STR_LIT>'<EOL>            && !syntaxProfiles[","gt":"syntax].hasOwnProperty('<STR_LIT>')"}
{"input":"<s> export function getEmmetConfiguration(syntax: string) {<EOL>    const emmetConfig = vscode.workspace.getConfiguration('<STR_LIT>');<EOL>    const syntaxProfiles = Object.assign({}, emmetConfig['<STR_LIT>'] || {});<EOL>    <EOL>    if (syntax === '<STR_LIT>' || syntax === '<STR_LIT>' || syntax === '<STR_LIT>') {<EOL>        syntaxProfiles[syntax] = syntaxProfiles[syntax] || {};<EOL>        if (typeof syntaxProfiles[syntax] === '<STR_LIT>'<EOL>            && !syntaxProfiles[syntax].hasOwnProperty('<STR_LIT>') <EOL>            && !syntaxProfiles[syntax].hasOwnProperty('<STR_LIT>') <EOL>        ) {<EOL>            syntaxProfiles[syntax]['<STR_LIT>'] = '<STR_LIT>';<EOL>        }<EOL>    }<EOL>    return {<EOL>        preferences: emmetConfig['<STR_LIT>'],<EOL>        showExpandedAbbreviation: emmetConfig['<STR_LIT>'],<EOL>        showAbbreviationSuggestions:","gt":"emmetConfig['<STR_LIT>'],"}
{"input":"<s> function registerNode(domNode: DOMNode) {<EOL>    registeredDomNodes[domNode.nodeId] =","gt":"domNode;"}
{"input":"<s> export function navigateToGroupInfo(context: examplesVM.ExampleGroup) {<EOL>    frame.topmost().navigate({<EOL>        animated:","gt":"true,"}
{"input":"<s> export function navigateToHome() {<EOL>    var topmost = frame.topmost();<EOL>    if (topmost.currentEntry.","gt":"moduleName !== \"<STR_LIT>\") {"}
{"input":"<s> export function getNativeFontSize(textView: textViewModule.TextView): number {<EOL>    var density = utilsModule.layout.","gt":"getDisplayDensity();"}
{"input":"<s> export function test_NavigationEvents_WithBackstackVisibile_False_Forward_Forward() {<EOL>","gt":"_test_NavigationEvents_WithBackstackVisibile_False_Forward_Forward();"}
{"input":"<s> function generateData(firstTime = false) {<EOL>    if (!firstTime) {<EOL>        <EOL>        state.seed = Math.random().toFixed(<NUM_LIT>);<EOL>        state.","gt":"serialize();"}
{"input":"<s> function generateData(firstTime = false) {<EOL>    if (!firstTime) {<EOL>        <EOL>        state.seed = Math.random().toFixed(<NUM_LIT>);<EOL>        state.serialize();<EOL>        userHasInteracted();<EOL>    }<EOL>    Math.seedrandom(state.","gt":"seed);"}
{"input":"<s> function generateData(firstTime = false) {<EOL>    if (!firstTime) {<EOL>        <EOL>        state.seed = Math.random().toFixed(<NUM_LIT>);<EOL>        state.serialize();<EOL>        userHasInteracted();<EOL>    }<EOL>    Math.seedrandom(state.seed);<EOL>    let numSamples = (state.problem === Problem.REGRESSION) ?<EOL>        NUM_SAMPLES_REGRESS : NUM_SAMPLES_CLASSIFY;<EOL>    let generator = state.problem === Problem.CLASSIFICATION ?<EOL>        state.dataset : state.","gt":"regDataset;"}
{"input":"<s> function generateData(firstTime = false) {<EOL>    if (!firstTime) {<EOL>        <EOL>        state.seed = Math.random().toFixed(<NUM_LIT>);<EOL>        state.serialize();<EOL>        userHasInteracted();<EOL>    }<EOL>    Math.seedrandom(state.seed);<EOL>    let numSamples = (state.problem === Problem.REGRESSION) ?<EOL>        NUM_SAMPLES_REGRESS : NUM_SAMPLES_CLASSIFY;<EOL>    let generator = state.problem === Problem.CLASSIFICATION ?<EOL>        state.dataset : state.regDataset;<EOL>    let data = generator(numSamples, state.noise / <NUM_LIT>);<EOL>    <EOL>    shuffle(data);<EOL>    <EOL>    let splitIndex = Math.floor(data.length * state.percTrainData /","gt":"<NUM_LIT>);"}
{"input":"<s> function _applyIconTheme(data: FileIconThemeData, onApply: (theme: FileIconThemeData) => TPromise<IFileIconTheme>): TPromise<IFileIconTheme> {<EOL>    _applyRules(data.styleSheetContent,","gt":"iconThemeRulesClassName);"}
{"input":"<s> export function classifyTwoGaussData(numSamples: number, noise: number): Example2D[] {<EOL>    let points: Example2D[] = [];<EOL>    let varianceScale = d3.scale.linear().domain([<NUM_LIT>, <NUM_LIT>]).range([<NUM_LIT>, <NUM_LIT>]);<EOL>    let variance = varianceScale(noise);<EOL>    function genGauss(cx: number, cy: number,","gt":"label: number) {"}
{"input":"<s> /** Returns the eucledian distance between two points in space. */<EOL>function dist(a: Point, b: Point): number {<EOL>    let dx =","gt":"a.x - b.x;"}
{"input":"<s> export function test_CorrectEventArgsWhenWrappedValueIsUsed() {<EOL>    let testArray = [<NUM_LIT>];<EOL>    let testObservable = fromObject({ \"<STR_LIT>\": testArray });<EOL>    let actualArgsValue;<EOL>","gt":"let propertyChangeHandler = function (args) {"}
{"input":"<s> export function test_CorrectEventArgsWhenWrappedValueIsUsed() {<EOL>    let testArray = [<NUM_LIT>];<EOL>    let testObservable = fromObject({ \"<STR_LIT>\": testArray });<EOL>    let actualArgsValue;<EOL>    let propertyChangeHandler = function (args) {<EOL>        actualArgsValue = args.value;<EOL>    };<EOL>    testObservable.on(Observable.propertyChangeEvent, propertyChangeHandler);<EOL>    testArray.push(<NUM_LIT>);<EOL>    let wrappedArray =","gt":"WrappedValue.wrap(testArray);"}
{"input":"<s> /**<EOL> * 划分数据集 Partition dataset<EOL> *<EOL> * @param {array} dataSet 原始数据集 Raw data set<EOL> * @param {number} axis 划分特征 which feature to partition<EOL> * @param {any} value 特征值 the value of the feature to partition<EOL> * @returns {array} 划分后的数据集 the partition result.<EOL> */<EOL>function splitDataSet(dataSet: Array<Array<any>>, axis: number, value: any): Array<Array<any>> {<EOL>    let retDataSet = dataSet.reduce((pre, cur) => {<EOL>        let curList = List(cur);<EOL>","gt":"if (cur[axis] === value) {"}
{"input":"<s> export function navigateBackWithContext(context: any) {<EOL>    var topmostFrame = frame.topmost();<EOL>    var backstackEntry =","gt":"topmostFrame.backStack[topmostFrame.backStack.length - <NUM_LIT>];"}
{"input":"<s> export function cordovaStartCommand(args: string[], cordovaRootPath: string): child_process.ChildProcess {<EOL>    const command = CordovaProjectHelper.getCliCommand(cordovaRootPath);<EOL>    const isIonic = CordovaProjectHelper.isIonicProject(cordovaRootPath);<EOL>    const isIonicServe: boolean = args.indexOf('<STR_LIT>') >= <NUM_LIT>;<EOL>    if (isIonic && !isIonicServe) {<EOL>        const isIonicCliVersionGte3 = CordovaProjectHelper.isIonicCliVersionGte3(","gt":"cordovaRootPath);"}
{"input":"<s> export function cordovaStartCommand(args: string[], cordovaRootPath: string): child_process.ChildProcess {<EOL>    const command = CordovaProjectHelper.getCliCommand(cordovaRootPath);<EOL>    const isIonic = CordovaProjectHelper.isIonicProject(cordovaRootPath);<EOL>    const isIonicServe: boolean = args.indexOf('<STR_LIT>') >= <NUM_LIT>;<EOL>    if (isIonic && !isIonicServe) {<EOL>        const isIonicCliVersionGte3 = CordovaProjectHelper.isIonicCliVersionGte3(cordovaRootPath);<EOL>        if (isIonicCliVersionGte3) {<EOL>            args.unshift('<STR_LIT>');<EOL>        }<EOL>    }<EOL>    if (isIonic) {<EOL>        args.push('<STR_LIT>');<EOL>    }<EOL>","gt":"else {"}
{"input":"<s> function parseOutcome(tx: any): any | undefined {<EOL>    const metadata = tx.meta || tx.metaData;<EOL>    if (!metadata) {<EOL>        return undefined;<EOL>    }<EOL>    const balanceChanges = transactionParser.parseBalanceChanges(metadata);<EOL>    const orderbookChanges =","gt":"transactionParser.parseOrderbookChanges(metadata);"}
{"input":"<s> function parseOutcome(tx: any): any | undefined {<EOL>    const metadata = tx.meta || tx.metaData;<EOL>    if (!metadata) {<EOL>        return undefined;<EOL>    }<EOL>    const balanceChanges = transactionParser.parseBalanceChanges(metadata);<EOL>    const orderbookChanges = transactionParser.parseOrderbookChanges(metadata);<EOL>    removeEmptyCounterpartyInBalanceChanges(balanceChanges);<EOL>    removeEmptyCounterpartyInOrderbookChanges(orderbookChanges);<EOL>    return common.removeUndefined({<EOL>        result:","gt":"tx.meta.TransactionResult,"}
{"input":"<s> function parseOutcome(tx: any): any | undefined {<EOL>    const metadata = tx.meta || tx.metaData;<EOL>    if (!metadata) {<EOL>        return undefined;<EOL>    }<EOL>    const balanceChanges = transactionParser.parseBalanceChanges(metadata);<EOL>    const orderbookChanges = transactionParser.parseOrderbookChanges(metadata);<EOL>    removeEmptyCounterpartyInBalanceChanges(balanceChanges);<EOL>    removeEmptyCounterpartyInOrderbookChanges(orderbookChanges);<EOL>    return common.removeUndefined({<EOL>        result: tx.meta.TransactionResult,<EOL>        timestamp: parseTimestamp(tx.date),<EOL>        fee: common.dropsToXrp(tx.Fee),<EOL>        balanceChanges: balanceChanges,<EOL>        orderbookChanges:","gt":"orderbookChanges,"}
{"input":"<s> function removeGenericCounterparty(amount, address) {<EOL>    return amount.counterparty ===","gt":"address ?"}
{"input":"<s> function fix(doc: Document): void {<EOL>","gt":"void fixNoscript(doc)"}
{"input":"<s> export function test_DependencyObservable_get_set_AreOverriden() {<EOL>    var dO = new TestDO();<EOL>","gt":"dO.test = true;"}
{"input":"<s> export function test_findFileMatch_os_fallback() {<EOL>    var candidates: Array<string> = [<EOL>","gt":"\"<STR_LIT>\","}
{"input":"<s> export function test_percent_margin_set_to_page_support() {<EOL>    let topFrame = frameModule.topmost();<EOL>    let currentPage = topFrame.currentPage;<EOL>    currentPage.margin = \"<STR_LIT>\";<EOL>    TKUnit.waitUntilReady(() => {<EOL>        return","gt":"currentPage.isLayoutValid;"}
{"input":"<s> export function test_percent_margin_set_to_page_support() {<EOL>    let topFrame = frameModule.topmost();<EOL>    let currentPage = topFrame.currentPage;<EOL>    currentPage.margin = \"<STR_LIT>\";<EOL>    TKUnit.waitUntilReady(() => {<EOL>        return currentPage.isLayoutValid;<EOL>    }, <NUM_LIT>);<EOL>    let topFrameWidth = topFrame.getMeasuredWidth();<EOL>    let","gt":"topFrameHeight = topFrame.getMeasuredHeight();"}
{"input":"<s> export function test_percent_margin_set_to_page_support() {<EOL>    let topFrame = frameModule.topmost();<EOL>    let currentPage = topFrame.currentPage;<EOL>    currentPage.margin = \"<STR_LIT>\";<EOL>    TKUnit.waitUntilReady(() => {<EOL>        return currentPage.isLayoutValid;<EOL>    }, <NUM_LIT>);<EOL>    let topFrameWidth = topFrame.getMeasuredWidth();<EOL>    let topFrameHeight = topFrame.getMeasuredHeight();<EOL>    let currentPageWidth = currentPage.getMeasuredWidth();<EOL>    let currentPageHeight = currentPage.getMeasuredHeight();<EOL>    let marginLeft = topFrameWidth * <NUM_LIT>;<EOL>    let marginTop = topFrameHeight * <NUM_LIT>;<EOL>    let","gt":"bounds = currentPage._getCurrentLayoutBounds();"}
{"input":"<s> export function openLink(view: any) {<EOL>    var url = view.tag;<EOL>    if (url) {<EOL>        if (isIOS) {<EOL>            var nsUrl = NSURL.URLWithString(url);<EOL>            var","gt":"sharedApp = utils.ios.getter(UIApplication, UIApplication.sharedApplication);"}
{"input":"<s> export function openLink(view: any) {<EOL>    var url = view.tag;<EOL>    if (url) {<EOL>        if (isIOS) {<EOL>            var nsUrl = NSURL.URLWithString(url);<EOL>            var sharedApp = utils.ios.getter(UIApplication, UIApplication.sharedApplication);<EOL>            if (sharedApp.canOpenURL(nsUrl)) {<EOL>                sharedApp.openURL(nsUrl);<EOL>            }<EOL>        }<EOL>        else if (isAndroid) {<EOL>            var intent = new android.content.Intent(android.content.Intent.ACTION_VIEW, android.net.Uri.parse(url));<EOL>","gt":"var activity = frame.topmost().android.activity;"}
{"input":"<s> function parseEscrowCancellation(tx: any): Object {<EOL>    assert(tx.TransactionType === '<STR_LIT>');<EOL>","gt":"return removeUndefined({"}
{"input":"<s> function parseFeeUpdate(tx: any) {<EOL>    const baseFeeDrops = (new BigNumber(tx.BaseFee, <NUM_LIT>)).toString();<EOL>    return {<EOL>        baseFeeXRP:","gt":"dropsToXrp(baseFeeDrops),"}
{"input":"<s> function interesting(i) {<EOL>    return","gt":"true;"}
{"input":"<s> export function test_get_set_on_observables_fromObject_without_property_in_json() {<EOL>    const array = new ObservableArray<any>();<EOL>    const vm = fromObject({});<EOL>    vm.","gt":"set(\"<STR_LIT>\", array);"}
{"input":"<s> export function test_parse_ShouldParseBooleanPropertiesIgnoreCase() {<EOL>    var p = <Page>builder.parse(","gt":"\"<STR_LIT>\");"}
{"input":"<s> export function editorHasToApplyValue(args) {<EOL>    buttonEditorHelper.","gt":"updateEditorValue(args.view, args.value);"}
{"input":"<s> export function onPageLoaded(args) {<EOL>    var page = args.object;<EOL>","gt":"vm.set(\"<STR_LIT>\", \"<STR_LIT>\");"}
{"input":"<s> export function test_findFileMatch_minW_best_value() {<EOL>    var candidates: Array<string> = [<EOL>        \"<STR_LIT>\",<EOL>","gt":"\"<STR_LIT>\","}
{"input":"<s> export function getProdConfig(config: BuildConfig = {}): webpack.Configuration {<EOL>    const srcdir = config.srcdir || defaultSrcDir;<EOL>    const outdir = config.outdir || defaultBuildDir;<EOL>","gt":"return {"}
{"input":"<s> export function getProdConfig(config: BuildConfig = {}): webpack.Configuration {<EOL>    const srcdir = config.srcdir || defaultSrcDir;<EOL>    const outdir = config.outdir || defaultBuildDir;<EOL>    return {<EOL>        devtool: '<STR_LIT>',<EOL>","gt":"entry: `<STR_LIT>`,"}
{"input":"<s> export function getProdConfig(config: BuildConfig = {}): webpack.Configuration {<EOL>    const srcdir = config.srcdir || defaultSrcDir;<EOL>    const outdir = config.outdir || defaultBuildDir;<EOL>    return {<EOL>        devtool: '<STR_LIT>',<EOL>        entry: `<STR_LIT>`,<EOL>        module: {<EOL>","gt":"rules: ["}
{"input":"<s> export function getProdConfig(config: BuildConfig = {}): webpack.Configuration {<EOL>    const srcdir = config.srcdir || defaultSrcDir;<EOL>    const outdir = config.outdir || defaultBuildDir;<EOL>    return {<EOL>        devtool: '<STR_LIT>',<EOL>        entry: `<STR_LIT>`,<EOL>        module: {<EOL>            rules: [<EOL>                {<EOL>                    test: /\\.tsx?$/,<EOL>                    use: [<EOL>","gt":"'<STR_LIT>', '<STR_LIT>',"}
{"input":"<s> export function getProdConfig(config: BuildConfig = {}): webpack.Configuration {<EOL>    const srcdir = config.srcdir || defaultSrcDir;<EOL>    const outdir = config.outdir || defaultBuildDir;<EOL>    return {<EOL>        devtool: '<STR_LIT>',<EOL>        entry: `<STR_LIT>`,<EOL>        module: {<EOL>            rules: [<EOL>                {<EOL>                    test: /\\.tsx?$/,<EOL>                    use: [<EOL>                        '<STR_LIT>', '<STR_LIT>',<EOL>                    ],<EOL>                    include: srcdir<EOL>                },<EOL>                {<EOL>                    test: /\\.(sass|css)$/,<EOL>                    use: ['<STR_LIT>', '<STR_LIT>',","gt":"'<STR_LIT>']"}
{"input":"<s> export function getProdConfig(config: BuildConfig = {}): webpack.Configuration {<EOL>    const srcdir = config.srcdir || defaultSrcDir;<EOL>    const outdir = config.outdir || defaultBuildDir;<EOL>    return {<EOL>        devtool: '<STR_LIT>',<EOL>        entry: `<STR_LIT>`,<EOL>        module: {<EOL>            rules: [<EOL>                {<EOL>                    test: /\\.tsx?$/,<EOL>                    use: [<EOL>                        '<STR_LIT>', '<STR_LIT>',<EOL>                    ],<EOL>                    include: srcdir<EOL>                },<EOL>                {<EOL>                    test: /\\.(sass|css)$/,<EOL>                    use: ['<STR_LIT>', '<STR_LIT>', '<STR_LIT>']<EOL>                },<EOL>                {<EOL>                    test: /\\.(svg|woff|woff2|ttf|eot)(\\?.*$|$)/,<EOL>                    use: ['<STR_LIT>']<EOL>                },<EOL>            ]<EOL>        },<EOL>        output: {<EOL>            filename: '<STR_LIT>',<EOL>            path: outdir,<EOL>            publicPath: publicPath<EOL>        },<EOL>        plugins: [<EOL>            new webpack.","gt":"DefinePlugin({"}
{"input":"<s> export function getProdConfig(config: BuildConfig = {}): webpack.Configuration {<EOL>    const srcdir = config.srcdir || defaultSrcDir;<EOL>    const outdir = config.outdir || defaultBuildDir;<EOL>    return {<EOL>        devtool: '<STR_LIT>',<EOL>        entry: `<STR_LIT>`,<EOL>        module: {<EOL>            rules: [<EOL>                {<EOL>                    test: /\\.tsx?$/,<EOL>                    use: [<EOL>                        '<STR_LIT>', '<STR_LIT>',<EOL>                    ],<EOL>                    include: srcdir<EOL>                },<EOL>                {<EOL>                    test: /\\.(sass|css)$/,<EOL>                    use: ['<STR_LIT>', '<STR_LIT>', '<STR_LIT>']<EOL>                },<EOL>                {<EOL>                    test: /\\.(svg|woff|woff2|ttf|eot)(\\?.*$|$)/,<EOL>                    use: ['<STR_LIT>']<EOL>                },<EOL>            ]<EOL>        },<EOL>        output: {<EOL>            filename: '<STR_LIT>',<EOL>            path: outdir,<EOL>            publicPath: publicPath<EOL>        },<EOL>        plugins: [<EOL>            new webpack.DefinePlugin({<EOL>                '<STR_LIT>': {<EOL>                    '<STR_LIT>': JSON.stringify('<STR_LIT>')<EOL>                },<EOL>                '<STR_LIT>': JSON.stringify(config.server_config || {}),<EOL>            }),<EOL>            new webpack.optimize.UglifyJsPlugin({<EOL>                compress: {<EOL>                    warnings: false<EOL>                }<EOL>            }),<EOL>            new webpack.LoaderOptionsPlugin({<EOL>","gt":"options: {"}
{"input":"<s> export function getProdConfig(config: BuildConfig = {}): webpack.Configuration {<EOL>    const srcdir = config.srcdir || defaultSrcDir;<EOL>    const outdir = config.outdir || defaultBuildDir;<EOL>    return {<EOL>        devtool: '<STR_LIT>',<EOL>        entry: `<STR_LIT>`,<EOL>        module: {<EOL>            rules: [<EOL>                {<EOL>                    test: /\\.tsx?$/,<EOL>                    use: [<EOL>                        '<STR_LIT>', '<STR_LIT>',<EOL>                    ],<EOL>                    include: srcdir<EOL>                },<EOL>                {<EOL>                    test: /\\.(sass|css)$/,<EOL>                    use: ['<STR_LIT>', '<STR_LIT>', '<STR_LIT>']<EOL>                },<EOL>                {<EOL>                    test: /\\.(svg|woff|woff2|ttf|eot)(\\?.*$|$)/,<EOL>                    use: ['<STR_LIT>']<EOL>                },<EOL>            ]<EOL>        },<EOL>        output: {<EOL>            filename: '<STR_LIT>',<EOL>            path: outdir,<EOL>            publicPath: publicPath<EOL>        },<EOL>        plugins: [<EOL>            new webpack.DefinePlugin({<EOL>                '<STR_LIT>': {<EOL>                    '<STR_LIT>': JSON.stringify('<STR_LIT>')<EOL>                },<EOL>                '<STR_LIT>': JSON.stringify(config.server_config || {}),<EOL>            }),<EOL>            new webpack.optimize.UglifyJsPlugin({<EOL>                compress: {<EOL>                    warnings: false<EOL>                }<EOL>            }),<EOL>            new webpack.LoaderOptionsPlugin({<EOL>                options: {<EOL>                    tslint: {<EOL>                        emitErrors: true,<EOL>                        failOnHint: true<EOL>                    },<EOL>","gt":"css: {"}
{"input":"<s> export function test_IntegrationTest_Transform_Decoration_Spacing_WithoutFormattedText_DoesNotCrash() {<EOL>    let view = new buttonModule.Button();<EOL>    helper.buildUIAndRunTest(view, function (views: Array<viewModule.View>) {<EOL>        view.","gt":"text = \"<STR_LIT>\";"}
{"input":"<s> export function registerContextItem<T>(name: string, callback: (context: OmnisharpEditorContext, editor: IOmnisharpTextEditor) => T) {<EOL>    contextItems.set(","gt":"name, callback);"}
{"input":"<s> function addMedias(videos, medias) {<EOL>    const allVideoIds = videos.map(video => video.id);<EOL>    const newVideos = [];<EOL>","gt":"medias.forEach(media => {"}
{"input":"<s> export function updateTriggeredFlag(scroll, scrollState: IScrollState, triggered: boolean, isScrollingDown: boolean) {<EOL>    if (isScrollingDown) {<EOL>        scrollState.","gt":"triggered.down = scroll;"}
{"input":"<s> export function user(state = initialUserState, action: UnsafeAction): IUserProfile {<EOL>    switch (action.type) {<EOL>        case UserProfileActions.ADD_PLAYLISTS:<EOL>            return { ...state, playlists: [...state.playlists, ...action.payload] };<EOL>        case UserProfileActions.UPDATE_TOKEN:<EOL>            return { ...state, access_token: action.payload, playlists: [] };<EOL>        case","gt":"UserProfileActions.USER_SIGNOUT_SUCCESS:"}
{"input":"<s> export function user(state = initialUserState, action: UnsafeAction): IUserProfile {<EOL>    switch (action.type) {<EOL>        case UserProfileActions.ADD_PLAYLISTS:<EOL>            return { ...state, playlists: [...state.playlists, ...action.payload] };<EOL>        case UserProfileActions.UPDATE_TOKEN:<EOL>            return { ...state, access_token: action.payload, playlists: [] };<EOL>        case UserProfileActions.USER_SIGNOUT_SUCCESS:<EOL>            return { ...initialUserState };<EOL>        case UserProfileActions.UPDATE:<EOL>            return { ...state, data: action.payload };<EOL>","gt":"case UserProfileActions.UPDATE_NEXT_PAGE_TOKEN:"}
{"input":"<s> export function user(state = initialUserState, action: UnsafeAction): IUserProfile {<EOL>    switch (action.type) {<EOL>        case UserProfileActions.ADD_PLAYLISTS:<EOL>            return { ...state, playlists: [...state.playlists, ...action.payload] };<EOL>        case UserProfileActions.UPDATE_TOKEN:<EOL>            return { ...state, access_token: action.payload, playlists: [] };<EOL>        case UserProfileActions.USER_SIGNOUT_SUCCESS:<EOL>            return { ...initialUserState };<EOL>        case UserProfileActions.UPDATE:<EOL>            return { ...state, data: action.payload };<EOL>        case UserProfileActions.UPDATE_NEXT_PAGE_TOKEN:<EOL>            return { ...state, nextPageToken: action.payload };<EOL>        case UserProfileActions.UPDATE_USER_PROFILE:<EOL>            return { ...state, profile: action.payload };<EOL>        case UserProfileActions.","gt":"VIEWED_PLAYLIST:"}
{"input":"<s> function fileCoverageWithLowerCaseWindowsDriveLetter(fileCoverage: FileCoverage) {<EOL>    const newFilePath = withLowerCaseWindowsDriveLetter(fileCoverage.path);<EOL>    if (newFilePath) {<EOL>","gt":"return {"}
{"input":"<s> export function shouldTriggerEvents(alwaysCallback: boolean, shouldFireScrollEvent: boolean, isTriggeredCurrentTotal: boolean) {<EOL>    return (alwaysCallback ||","gt":"shouldFireScrollEvent) && !isTriggeredCurrentTotal;"}
{"input":"<s> function parser(str: string) {<EOL>    const length = str.length;<EOL>    const result: ParsedWSMessage = {<EOL>","gt":"method: '<STR_LIT>',"}
{"input":"<s> function parser(str: string) {<EOL>    const length = str.length;<EOL>    const result: ParsedWSMessage = {<EOL>        method: '<STR_LIT>',<EOL>        id: '<STR_LIT>',<EOL>        type: '<STR_LIT>',<EOL>","gt":"data: null"}
{"input":"<s> function parser(str: string) {<EOL>    const length = str.length;<EOL>    const result: ParsedWSMessage = {<EOL>        method: '<STR_LIT>',<EOL>        id: '<STR_LIT>',<EOL>        type: '<STR_LIT>',<EOL>        data: null<EOL>    };<EOL>    let state = BEGIN_STATE;<EOL>    let i = -<NUM_LIT>;<EOL>    while (++i <","gt":"length) {"}
{"input":"<s> function parser(str: string) {<EOL>    const length = str.length;<EOL>    const result: ParsedWSMessage = {<EOL>        method: '<STR_LIT>',<EOL>        id: '<STR_LIT>',<EOL>        type: '<STR_LIT>',<EOL>        data: null<EOL>    };<EOL>    let state = BEGIN_STATE;<EOL>    let i = -<NUM_LIT>;<EOL>    while (++i < length) {<EOL>        const substr = str[i];<EOL>        const pos = tokens.indexOf(substr);<EOL>        switch (","gt":"pos) {"}
{"input":"<s> function parser(str: string) {<EOL>    const length = str.length;<EOL>    const result: ParsedWSMessage = {<EOL>        method: '<STR_LIT>',<EOL>        id: '<STR_LIT>',<EOL>        type: '<STR_LIT>',<EOL>        data: null<EOL>    };<EOL>    let state = BEGIN_STATE;<EOL>    let i = -<NUM_LIT>;<EOL>    while (++i < length) {<EOL>        const substr = str[i];<EOL>        const pos = tokens.indexOf(substr);<EOL>        switch (pos) {<EOL>            case -<NUM_LIT>:<EOL>                readToken(result, substr, state);<EOL>","gt":"break;"}
{"input":"<s> function parser(str: string) {<EOL>    const length = str.length;<EOL>    const result: ParsedWSMessage = {<EOL>        method: '<STR_LIT>',<EOL>        id: '<STR_LIT>',<EOL>        type: '<STR_LIT>',<EOL>        data: null<EOL>    };<EOL>    let state = BEGIN_STATE;<EOL>    let i = -<NUM_LIT>;<EOL>    while (++i < length) {<EOL>        const substr = str[i];<EOL>        const pos = tokens.indexOf(substr);<EOL>        switch (pos) {<EOL>            case -<NUM_LIT>:<EOL>                readToken(result, substr, state);<EOL>                break;<EOL>            case <NUM_LIT>:<EOL>                if (state === BEGIN_STATE) {<EOL>                    state = METHOD_STATE;<EOL>                }<EOL>                else if (state === METHOD_STATE) {<EOL>                    state =","gt":"TYPE_STATE;"}
{"input":"<s> function f1<T>(x: Required<T>, y: T, z: Partial<T>) {<EOL>    x = x;<EOL>    x = y; <EOL>    x =","gt":"z;"}
{"input":"<s> function GetWindowsWSLLaunchJSONWithArrayArgsAndDebuggerCommand() {<EOL>    return {<EOL>","gt":"pipeCwd: \"<STR_LIT>\","}
{"input":"<s> /**<EOL> * Determines if the specified character is a string quote.<EOL> * @param  {string}  ch<EOL> * @return {Boolean}<EOL> */<EOL>function isStringQuote(ch: string) {<EOL>    switch (ch) {<EOL>        case \"<STR_LIT>\":<EOL>","gt":"case '<STR_LIT>':"}
{"input":"<s> export function pagination(count: number, page: number) {<EOL>    return {<EOL>        limit:","gt":"count,"}
{"input":"<s> export function chain<T>(event: Event<T>): IChainableEvent<T> {<EOL>    return new","gt":"ChainableEvent(event);"}
{"input":"<s> export function createPackageJSONFileService(): IPackageJSONService {<EOL>    return {<EOL>        readPackageFile: async (filePath) => {<EOL>            const contents = await readFileContents(filePath);<EOL>            return JSON.parse(contents) as IPackageFile;<EOL>        },<EOL>        writePackageFile: async (filePath, fileContent) => {<EOL>            const contents = await readFileContents(filePath);<EOL>            const { indent } = detectIndent(contents);<EOL>            const trailingNewline =","gt":"contents.length"}
{"input":"<s> export function createPackageJSONFileService(): IPackageJSONService {<EOL>    return {<EOL>        readPackageFile: async (filePath) => {<EOL>            const contents = await readFileContents(filePath);<EOL>            return JSON.parse(contents) as IPackageFile;<EOL>        },<EOL>        writePackageFile: async (filePath, fileContent) => {<EOL>            const contents = await readFileContents(filePath);<EOL>            const { indent } = detectIndent(contents);<EOL>            const trailingNewline = contents.length<EOL>                ? contents[contents.length - <NUM_LIT>] === '<STR_LIT>'<EOL>                : false;<EOL>            const data = JSON.stringify(fileContent,","gt":"null, indent  || '<STR_LIT>');"}
{"input":"<s> export function failedSuiteCount(diagnostics: vscode.DiagnosticCollection): number {<EOL>","gt":"let sum = <NUM_LIT>;"}
{"input":"<s> export default function initialize() {<EOL>","gt":"return shell(`<STR_LIT>`"}
{"input":"<s> export default function initialize() {<EOL>    return","gt":"shell(`<STR_LIT>`"}
{"input":"<s> function testFunc(notDisposer: {}): TestFunc {<EOL>    return {<EOL>","gt":"destroy() {"}
{"input":"<s> function explicitStructural(this: {<EOL>    y: number;<EOL>}, x: number): number {<EOL>    return","gt":"x + this.y;"}
{"input":"<s> function f20(component: Component<Shape>) {<EOL>    let name = component.getProperty(\"<STR_LIT>\"); <EOL>","gt":"let widthOrHeight = component.getProperty(cond ? \"<STR_LIT>\" : \"<STR_LIT>\");"}
{"input":"<s> export function getAllProjectPosts(this: SDK, _projectId: ProjectId, query?: GetPostsQuery<'<STR_LIT>'>): QueryToken<PostSchema> {<EOL>    const queryPair = normPagingQuery(query);<EOL>    const urlQuery = queryPair.forUrl as GetPostsUrlQuery<'<STR_LIT>'>;<EOL>    const { skip, limit } = queryPair.forSql;<EOL>","gt":"const selectStmt: Query<PostSchema> = {"}
{"input":"<s> export function getAllProjectPosts(this: SDK, _projectId: ProjectId, query?: GetPostsQuery<'<STR_LIT>'>): QueryToken<PostSchema> {<EOL>    const queryPair = normPagingQuery(query);<EOL>    const urlQuery = queryPair.forUrl as GetPostsUrlQuery<'<STR_LIT>'>;<EOL>    const { skip, limit } = queryPair.forSql;<EOL>    const selectStmt: Query<PostSchema> = {<EOL>        where: {<EOL>            _projectId,<EOL>            isArchived:","gt":"false,"}
{"input":"<s> export function getAllProjectPosts(this: SDK, _projectId: ProjectId, query?: GetPostsQuery<'<STR_LIT>'>): QueryToken<PostSchema> {<EOL>    const queryPair = normPagingQuery(query);<EOL>    const urlQuery = queryPair.forUrl as GetPostsUrlQuery<'<STR_LIT>'>;<EOL>    const { skip, limit } = queryPair.forSql;<EOL>    const selectStmt: Query<PostSchema> = {<EOL>        where: {<EOL>            _projectId,<EOL>            isArchived: false,<EOL>        },<EOL>        skip,<EOL>        limit,<EOL>        ...(query && query.orderBy ? { orderBy: query.orderBy } : {})<EOL>    };<EOL>    return this.lift<PostSchema>({<EOL>        request: this.fetch.getPosts(_projectId, urlQuery),<EOL>        query: selectStmt,<EOL>        tableName:","gt":"'<STR_LIT>',"}
{"input":"<s> export function navigatingTo(args: EventData) {<EOL>","gt":"console.log(\"<STR_LIT>\");"}
{"input":"<s> function convertDOMStringListToArray(list: any): any[] {<EOL>    var length = list.length;<EOL>","gt":"var array: any[] = [];"}
{"input":"<s> export function spawnRipgrepCmd(config: IRawSearch, folderQuery: IFolderSearch, includePattern: glob.IExpression, excludePattern: glob.IExpression) {<EOL>    const rgArgs = getRgArgs(config, folderQuery, includePattern, excludePattern);<EOL>    const cwd = folderQuery.folder;<EOL>","gt":"return {"}
{"input":"<s> export function counterReducer(state: number = INITIAL_STATE, action: any) {<EOL>    switch (action.type) {<EOL>        case CounterActions.INCREMENT_COUNTER:<EOL>            return state + <NUM_LIT>;<EOL>        case","gt":"CounterActions.DECREMENT_COUNTER:"}
{"input":"<s> export function counterReducer(state: number = INITIAL_STATE, action: any) {<EOL>    switch (action.type) {<EOL>        case CounterActions.INCREMENT_COUNTER:<EOL>            return state + <NUM_LIT>;<EOL>        case CounterActions.DECREMENT_COUNTER:<EOL>            return state - <NUM_LIT>;<EOL>        case CounterActions.RESET_COUNTER:<EOL>            return <NUM_LIT>;<EOL>","gt":"default:"}
{"input":"<s> export function pageNavigatingFrom(args: observable.EventData) {<EOL>    var page = <pages.Page>args.","gt":"object;"}
{"input":"<s> function makeNumberBuckets(centerAround: number, count: number, coarse?: boolean): Granularity[] {<EOL>    var granularities: Granularity[] = [];<EOL>    var logTen = Math.log(centerAround) / Math.LN10;<EOL>    var digits = getNumberOfWholeDigits(centerAround);<EOL>    while (granularities.length <= count) {<EOL>","gt":"if (!coarse) {"}
{"input":"<s> function makeNumberBuckets(centerAround: number, count: number, coarse?: boolean): Granularity[] {<EOL>    var granularities: Granularity[] = [];<EOL>    var logTen = Math.log(centerAround) / Math.LN10;<EOL>    var digits = getNumberOfWholeDigits(centerAround);<EOL>    while (granularities.length <= count) {<EOL>        if (!coarse) {<EOL>            var halfStep = toSignificantDigits(<NUM_LIT> * Math.pow(<NUM_LIT>, logTen - <NUM_LIT>), digits);<EOL>            granularities.push(granularityFromJS(halfStep));<EOL>        }<EOL>        if (","gt":"granularities.length >= count)"}
{"input":"<s> function makeNumberBuckets(centerAround: number, count: number, coarse?: boolean): Granularity[] {<EOL>    var granularities: Granularity[] = [];<EOL>    var logTen = Math.log(centerAround) / Math.LN10;<EOL>    var digits = getNumberOfWholeDigits(centerAround);<EOL>    while (granularities.length <= count) {<EOL>        if (!coarse) {<EOL>            var halfStep = toSignificantDigits(<NUM_LIT> * Math.pow(<NUM_LIT>, logTen - <NUM_LIT>), digits);<EOL>            granularities.push(granularityFromJS(halfStep));<EOL>        }<EOL>        if (granularities.length >= count)<EOL>            break;<EOL>        var wholeStep = toSignificantDigits(Math.pow(<NUM_LIT>, logTen), digits);<EOL>        granularities.push(","gt":"granularityFromJS(wholeStep));"}
{"input":"<s> export function viewUtilLog(msg): void {<EOL>    write(msg,","gt":"viewUtilCategory);"}
{"input":"<s> function truncateStringReverse(str: string, maxLength = <NUM_LIT>) {<EOL>    const reversedString = toArray(","gt":"str).reverse().join('<STR_LIT>');"}
{"input":"<s> <EOL>function lookup(name: string) {<EOL>","gt":"const username = '<STR_LIT>';"}
{"input":"<s> export function getNativeFontSize(textField: textFieldModule.TextField): number {<EOL>","gt":"return textField.ios.font.pointSize;"}
{"input":"<s> function markAllAsRead() {<EOL>    let readArticles = loadReadArticles();<EOL>    viewModel.news.filter(n => n && n.","gt":"id).forEach(n => readArticles[n.id] = true);"}
{"input":"<s> export default function registerCommands(server: OmniSharpServer, reporter: TelemetryReporter, channel: vscode.OutputChannel) {<EOL>    let d1 = vscode.commands.registerCommand('<STR_LIT>', () => restartOmniSharp(server));<EOL>    let d2 = vscode.commands.registerCommand('<STR_LIT>', () => pickProjectAndStart(server));<EOL>    let d3 = vscode.commands.registerCommand('<STR_LIT>', () => server.getChannel().show(vscode.ViewColumn.Three));<EOL>    let d4 = vscode.commands.registerCommand('<STR_LIT>', () => dotnetRestoreAllProjects(server));<EOL>    <EOL>    <EOL>    let d5 = vscode.commands.registerCommand('<STR_LIT>', () => { });<EOL>    <EOL>    let attachItemsProvider = DotNetAttachItemsProviderFactory.Get();<EOL>    let attacher = new AttachPicker(attachItemsProvider);<EOL>    let","gt":"d6 = vscode.commands.registerCommand('<STR_LIT>', () => attacher.ShowAttachEntries());"}
{"input":"<s> export default function registerCommands(server: OmniSharpServer, reporter: TelemetryReporter, channel: vscode.OutputChannel) {<EOL>    let d1 = vscode.commands.registerCommand('<STR_LIT>', () => restartOmniSharp(server));<EOL>    let d2 = vscode.commands.registerCommand('<STR_LIT>', () => pickProjectAndStart(server));<EOL>    let d3 = vscode.commands.registerCommand('<STR_LIT>', () => server.getChannel().show(vscode.ViewColumn.Three));<EOL>    let d4 = vscode.commands.registerCommand('<STR_LIT>', () => dotnetRestoreAllProjects(server));<EOL>    <EOL>    <EOL>    let d5 = vscode.commands.registerCommand('<STR_LIT>', () => { });<EOL>    <EOL>    let attachItemsProvider = DotNetAttachItemsProviderFactory.Get();<EOL>    let attacher = new AttachPicker(attachItemsProvider);<EOL>    let d6 = vscode.commands.registerCommand('<STR_LIT>', () => attacher.ShowAttachEntries());<EOL>    <EOL>    let d7 = vscode.commands.registerCommand('<STR_LIT>', () => generateAssets(server));<EOL>    <EOL>    let d8 = vscode.commands.","gt":"registerCommand('<STR_LIT>', (args) => RemoteAttachPicker.ShowAttachEntries(args));"}
{"input":"<s> function getInstallFilePath(type: InstallFileType): string {<EOL>    let","gt":"installFile = '<STR_LIT>' + InstallFileType[type];"}
{"input":"<s> export function createPage() {<EOL>    return","gt":"new TestPageModule();"}
{"input":"<s> export function repeaterItemTap(args: gestures.GestureEventData) {<EOL>    var item = args.","gt":"view.bindingContext;"}
{"input":"<s> export function collect(wait: number, fn: Fn): Fn {<EOL>    var timeout: any;<EOL>    var later = function () {<EOL>        timeout = null;<EOL>","gt":"fn();"}
{"input":"<s> export function collect(wait: number, fn: Fn): Fn {<EOL>    var timeout: any;<EOL>    var later = function () {<EOL>        timeout = null;<EOL>        fn();<EOL>    };<EOL>    return function () {<EOL>        if (!timeout) {<EOL>            timeout = setTimeout(later,","gt":"wait);"}
{"input":"<s> function days(count: number) {<EOL>    return count *","gt":"day.canonicalLength;"}
{"input":"<s> <EOL>export function monthToWeeks(firstDayOfMonth: Date, timezone: Timezone, locale: Locale): Date[][] {<EOL>    const weeks: Date[][] = [];<EOL>    const firstDayNextMonth = month.shift(firstDayOfMonth, timezone, <NUM_LIT>);<EOL>    let week: Date[] = [];<EOL>    let currentPointer = day.floor(firstDayOfMonth, timezone);<EOL>    while (currentPointer < firstDayNextMonth) {<EOL>        var","gt":"wallTime = WallTime.UTCToWallTime(currentPointer, timezone.toString());"}
{"input":"<s> function checkFixture(id: string) {<EOL>    const filePath = path.resolve(","gt":"__dirname, `<STR_LIT>`);"}
{"input":"<s> <EOL>export function test_actionItem_inherit_bindingContext() {<EOL>    let page: Page;<EOL>    let label: Label;<EOL>    const context = { text: \"<STR_LIT>\" };<EOL>    const pageFactory = function (): Page {<EOL>        page = new Page();<EOL>        page.bindingContext =","gt":"context;"}
{"input":"<s> <EOL>export function test_actionItem_inherit_bindingContext() {<EOL>    let page: Page;<EOL>    let label: Label;<EOL>    const context = { text: \"<STR_LIT>\" };<EOL>    const pageFactory = function (): Page {<EOL>        page = new Page();<EOL>        page.bindingContext = context;<EOL>        const actionItem = new actionBarModule.ActionItem();<EOL>        actionItem.bind({<EOL>            sourceProperty: \"<STR_LIT>\",<EOL>            targetProperty: \"<STR_LIT>\"<EOL>        });<EOL>        page.actionBar.actionItems.addItem(actionItem);<EOL>        label = new Label();<EOL>        label.text = \"<STR_LIT>\";<EOL>        page.content =","gt":"label;"}
{"input":"<s> function process(sourceText: string, sourcePath: string) {<EOL>    return","gt":"stringify(sourceText)};"}
{"input":"<s> export function pageLoaded(args) {<EOL>    var strArr: string[] = [\"<STR_LIT>\", \"<STR_LIT>\", \"<STR_LIT>\"];<EOL>    var numArr: number[] = [-<NUM_LIT>,","gt":"<NUM_LIT>, <NUM_LIT>];"}
{"input":"<s> <EOL>export function reportServerStatus(server: OmniSharpServer): vscode.Disposable {<EOL>    function appendLine(value: string = '<STR_LIT>') {<EOL>        server.getChannel().appendLine(value);<EOL>    }<EOL>    let d0 =","gt":"server.onServerError(err => {"}
{"input":"<s> <EOL>export function reportServerStatus(server: OmniSharpServer): vscode.Disposable {<EOL>    function appendLine(value: string = '<STR_LIT>') {<EOL>        server.getChannel().appendLine(value);<EOL>    }<EOL>    let d0 = server.onServerError(err => {<EOL>        appendLine('<STR_LIT>' + err);<EOL>    });<EOL>    let d1 = server.onError(message => {<EOL>        if (message.FileName) {<EOL>            appendLine(","gt":"Line},${message.Column})`<STR_LIT>;"}
{"input":"<s> <EOL>export function reportServerStatus(server: OmniSharpServer): vscode.Disposable {<EOL>    function appendLine(value: string = '<STR_LIT>') {<EOL>        server.getChannel().appendLine(value);<EOL>    }<EOL>    let d0 = server.onServerError(err => {<EOL>        appendLine('<STR_LIT>' + err);<EOL>    });<EOL>    let d1 = server.onError(message => {<EOL>        if (message.FileName) {<EOL>            appendLine(`<STR_LIT>`);<EOL>        }<EOL>        appendLine(message.Text);<EOL>        appendLine();<EOL>        showMessageSoon();<EOL>    });<EOL>    let d2 = server.onMsBuildProjectDiagnostics(message => {<EOL>        function asErrorMessage(message: protocol.MSBuildDiagnosticsMessage) {<EOL>            let value = `<STR_LIT>`;<EOL>            appendLine(value);<EOL>        }<EOL>        function asWarningMessage(message: protocol.MSBuildDiagnosticsMessage) {<EOL>            let value = `<STR_LIT>`;<EOL>            appendLine(value);<EOL>        }<EOL>        if (message.Errors.length > <NUM_LIT> || message.Warnings.length > <NUM_LIT>) {<EOL>            appendLine(","gt":"message.FileName);"}
{"input":"<s> <EOL>export function reportServerStatus(server: OmniSharpServer): vscode.Disposable {<EOL>    function appendLine(value: string = '<STR_LIT>') {<EOL>        server.getChannel().appendLine(value);<EOL>    }<EOL>    let d0 = server.onServerError(err => {<EOL>        appendLine('<STR_LIT>' + err);<EOL>    });<EOL>    let d1 = server.onError(message => {<EOL>        if (message.FileName) {<EOL>            appendLine(`<STR_LIT>`);<EOL>        }<EOL>        appendLine(message.Text);<EOL>        appendLine();<EOL>        showMessageSoon();<EOL>    });<EOL>    let d2 = server.onMsBuildProjectDiagnostics(message => {<EOL>        function asErrorMessage(message: protocol.MSBuildDiagnosticsMessage) {<EOL>            let value = `<STR_LIT>`;<EOL>            appendLine(value);<EOL>        }<EOL>        function asWarningMessage(message: protocol.MSBuildDiagnosticsMessage) {<EOL>            let value = `<STR_LIT>`;<EOL>            appendLine(value);<EOL>        }<EOL>        if (message.Errors.length > <NUM_LIT> || message.Warnings.length > <NUM_LIT>) {<EOL>            appendLine(message.FileName);<EOL>            message.Errors.forEach(error => asErrorMessage);<EOL>            message.Warnings.forEach(warning => asWarningMessage);<EOL>            appendLine();<EOL>            if (message.Errors.length > <NUM_LIT>) {<EOL>                showMessageSoon();<EOL>            }<EOL>        }<EOL>    });<EOL>    let d3 = server.","gt":"onUnresolvedDependencies(message => {"}
{"input":"<s> <EOL>export function reportServerStatus(server: OmniSharpServer): vscode.Disposable {<EOL>    function appendLine(value: string = '<STR_LIT>') {<EOL>        server.getChannel().appendLine(value);<EOL>    }<EOL>    let d0 = server.onServerError(err => {<EOL>        appendLine('<STR_LIT>' + err);<EOL>    });<EOL>    let d1 = server.onError(message => {<EOL>        if (message.FileName) {<EOL>            appendLine(`<STR_LIT>`);<EOL>        }<EOL>        appendLine(message.Text);<EOL>        appendLine();<EOL>        showMessageSoon();<EOL>    });<EOL>    let d2 = server.onMsBuildProjectDiagnostics(message => {<EOL>        function asErrorMessage(message: protocol.MSBuildDiagnosticsMessage) {<EOL>            let value = `<STR_LIT>`;<EOL>            appendLine(value);<EOL>        }<EOL>        function asWarningMessage(message: protocol.MSBuildDiagnosticsMessage) {<EOL>            let value = `<STR_LIT>`;<EOL>            appendLine(value);<EOL>        }<EOL>        if (message.Errors.length > <NUM_LIT> || message.Warnings.length > <NUM_LIT>) {<EOL>            appendLine(message.FileName);<EOL>            message.Errors.forEach(error => asErrorMessage);<EOL>            message.Warnings.forEach(warning => asWarningMessage);<EOL>            appendLine();<EOL>            if (message.Errors.length > <NUM_LIT>) {<EOL>                showMessageSoon();<EOL>            }<EOL>        }<EOL>    });<EOL>    let d3 = server.onUnresolvedDependencies(message => {<EOL>        let csharpConfig = vscode.workspace.getConfiguration('<STR_LIT>');<EOL>        if (!csharpConfig.get<boolean>('<STR_LIT>')) {<EOL>            let info = `<STR_LIT>`;<EOL>            return vscode.window.showInformationMessage(","gt":"info, '<STR_LIT>').then(value => {"}
{"input":"<s> <EOL>export function reportServerStatus(server: OmniSharpServer): vscode.Disposable {<EOL>    function appendLine(value: string = '<STR_LIT>') {<EOL>        server.getChannel().appendLine(value);<EOL>    }<EOL>    let d0 = server.onServerError(err => {<EOL>        appendLine('<STR_LIT>' + err);<EOL>    });<EOL>    let d1 = server.onError(message => {<EOL>        if (message.FileName) {<EOL>            appendLine(`<STR_LIT>`);<EOL>        }<EOL>        appendLine(message.Text);<EOL>        appendLine();<EOL>        showMessageSoon();<EOL>    });<EOL>    let d2 = server.onMsBuildProjectDiagnostics(message => {<EOL>        function asErrorMessage(message: protocol.MSBuildDiagnosticsMessage) {<EOL>            let value = `<STR_LIT>`;<EOL>            appendLine(value);<EOL>        }<EOL>        function asWarningMessage(message: protocol.MSBuildDiagnosticsMessage) {<EOL>            let value = `<STR_LIT>`;<EOL>            appendLine(value);<EOL>        }<EOL>        if (message.Errors.length > <NUM_LIT> || message.Warnings.length > <NUM_LIT>) {<EOL>            appendLine(message.FileName);<EOL>            message.Errors.forEach(error => asErrorMessage);<EOL>            message.Warnings.forEach(warning => asWarningMessage);<EOL>            appendLine();<EOL>            if (message.Errors.length > <NUM_LIT>) {<EOL>                showMessageSoon();<EOL>            }<EOL>        }<EOL>    });<EOL>    let d3 = server.onUnresolvedDependencies(message => {<EOL>        let csharpConfig = vscode.workspace.getConfiguration('<STR_LIT>');<EOL>        if (!csharpConfig.get<boolean>('<STR_LIT>')) {<EOL>            let info = `<STR_LIT>`;<EOL>            return vscode.window.showInformationMessage(info, '<STR_LIT>').then(value => {<EOL>                if (value) {<EOL>                    dotnetRestoreForProject(","gt":"server, message.FileName);"}
{"input":"<s> function flatten<T>(array: MultiDimensionArray<T>, result: T[] = []): T[] {<EOL>    for (let i = <NUM_LIT>; i < array.length; i++) {<EOL>        if (Array.isArray(array[i])) {<EOL>            flatten(array[i] as T[],","gt":"result);"}
{"input":"<s> function defaultWorkspacePath(contextService: IWorkspaceContextService, historyService: IHistoryService, environmentService: IEnvironmentService): string {<EOL>    <EOL>    if (contextService.getWorkbenchState() === WorkbenchState.WORKSPACE && !isUntitledWorkspace(contextService.","gt":"getWorkspace().configuration.fsPath, environmentService)) {"}
{"input":"<s> export function verifyUrlSafeName(name: string): void {<EOL>    if (typeof name !== '<STR_LIT>')<EOL>        throw new TypeError('<STR_LIT>');<EOL>","gt":"if (!name.length)"}
{"input":"<s> function getFontFamilyRespectingGenericFonts(fontFamily: string): string {<EOL>    if (!fontFamily) {<EOL>        return fontFamily;<EOL>    }<EOL>    switch (fontFamily.","gt":"toLowerCase()) {"}
{"input":"<s> function getFontFamilyRespectingGenericFonts(fontFamily: string): string {<EOL>    if (!fontFamily) {<EOL>        return fontFamily;<EOL>    }<EOL>    switch (fontFamily.toLowerCase()) {<EOL>        case genericFontFamilies.serif:<EOL>            return DEFAULT_SERIF;<EOL>        case genericFontFamilies.monospace:<EOL>            return DEFAULT_MONOSPACE;<EOL>","gt":"default:"}
{"input":"<s> export function navigate(args) {<EOL>    frame.topmost().","gt":"navigate(\"<STR_LIT>\");"}
{"input":"<s> export function test_removeWeakEventListener_StopsListeningForEvent() {<EOL>    const source = new Observable();<EOL>    const","gt":"target = new Target();"}
{"input":"<s> export function isDotNetCoreProject(project: MSBuildProject): Boolean {<EOL>","gt":"return findNetCoreAppTargetFramework(project) !== undefined ||"}
{"input":"<s> function pluck<T, K extends keyof T>(array: T[], key: K) {<EOL>    return","gt":"array.map(x => x[key]);"}
{"input":"<s> export function test_setting_backgroundRepeat_property_from_CSS_is_applied_to_Style() {<EOL>    test_property_from_CSS_is_applied_to_style(\"<STR_LIT>\", \"<STR_LIT>\",","gt":"\"<STR_LIT>\");"}
{"input":"<s> function getTextView(bar: android.widget.SearchView): android.widget.TextView {<EOL>    if (bar) {<EOL>        const pkgName = bar.getContext().getPackageName();<EOL>        var id = bar.getContext().getResources().getIdentifier(\"<STR_LIT>\",","gt":"\"<STR_LIT>\", pkgName);"}
{"input":"<s> export function listen<T extends keyof HTMLElementEventMap>(element: HTMLElement, event: T, selector: string, callback: (event: HTMLElementEventMap[T]) => void): Disposable {<EOL>    const bound = (evt: Event) => {<EOL>        const sel = (evt.target as HTMLElement).closest(selector);<EOL>        if (sel && element.contains(sel)) {<EOL>            callback(","gt":"evt);"}
{"input":"<s> export function listen<T extends keyof HTMLElementEventMap>(element: HTMLElement, event: T, selector: string, callback: (event: HTMLElementEventMap[T]) => void): Disposable {<EOL>    const bound = (evt: Event) => {<EOL>        const sel = (evt.target as HTMLElement).closest(selector);<EOL>        if (sel && element.contains(sel)) {<EOL>            callback(evt);<EOL>        }<EOL>    };<EOL>    element.addEventListener(event, bound);<EOL>","gt":"return new Disposable(() => {"}
{"input":"<s> function makeGuard(guard: string): Handler {<EOL>    return (req: SwivRequest, res: Response, next: Function) => {<EOL>        const user = req.user;<EOL>        if (!user) {<EOL>            next(new Error('<STR_LIT>'));<EOL>            return;<EOL>        }<EOL>        const { allow } = user;<EOL>        if (!allow) {<EOL>            next(new Error('<STR_LIT>'));<EOL>","gt":"return;"}
{"input":"<s> function makeGuard(guard: string): Handler {<EOL>    return (req: SwivRequest, res: Response, next: Function) => {<EOL>        const user = req.user;<EOL>        if (!user) {<EOL>            next(new Error('<STR_LIT>'));<EOL>            return;<EOL>        }<EOL>        const { allow } = user;<EOL>        if (!allow) {<EOL>            next(new Error('<STR_LIT>'));<EOL>            return;<EOL>        }<EOL>        if (!allow[guard]) {<EOL>","gt":"next(new Error('<STR_LIT>'));"}
{"input":"<s> function log10(n: number) {<EOL>    return Math.","gt":"log(n) * Math.LOG10E;"}
{"input":"<s> /**<EOL> * HELPER find the node that is \"furthest down\" the<EOL> *        node hiearchy, i.e. which's start-, end-position contains the<EOL> *        cursorLine AND is smallest.<EOL> * @param  {NavigationTreeViewModel} node<EOL> *                  the HTML element from which to start searching<EOL> * @param  {Number} cursorLine the cursor line<EOL> * @return {HTMLElement|null} the node's HTML representation which matches cursorLine<EOL> *                            (i.e. which' start-, end-position contain cursorLine while<EOL> *                             having the smallest distance to cursorLine), or NULL if no<EOL> *                            matching node can be found<EOL> */<EOL>export function findNodeAt(startLine: number, endLine: number, node: NavigationTreeViewModel): NavigationTreeViewModel | null {<EOL>    if (!node.childItems) {<EOL>        return null;<EOL>    }<EOL>    for (const elem of node.childItems) {<EOL>        const start: number = getNodeStartLine(elem);<EOL>        const","gt":"end: number = getNodeEndLine(elem);"}
{"input":"<s> /**<EOL> * HELPER find the node that is \"furthest down\" the<EOL> *        node hiearchy, i.e. which's start-, end-position contains the<EOL> *        cursorLine AND is smallest.<EOL> * @param  {NavigationTreeViewModel} node<EOL> *                  the HTML element from which to start searching<EOL> * @param  {Number} cursorLine the cursor line<EOL> * @return {HTMLElement|null} the node's HTML representation which matches cursorLine<EOL> *                            (i.e. which' start-, end-position contain cursorLine while<EOL> *                             having the smallest distance to cursorLine), or NULL if no<EOL> *                            matching node can be found<EOL> */<EOL>export function findNodeAt(startLine: number, endLine: number, node: NavigationTreeViewModel): NavigationTreeViewModel | null {<EOL>    if (!node.childItems) {<EOL>        return null;<EOL>    }<EOL>    for (const elem of node.childItems) {<EOL>        const start: number = getNodeStartLine(elem);<EOL>        const end: number = getNodeEndLine(elem);<EOL>        if (isFinite(start) && isFinite(end)) {<EOL>            if (startLine >= start && endLine <= end) {<EOL>                const selected = findNodeAt(startLine, endLine, elem);<EOL>                if (","gt":"selected) {"}
{"input":"<s> /**<EOL> * HELPER find the node that is \"furthest down\" the<EOL> *        node hiearchy, i.e. which's start-, end-position contains the<EOL> *        cursorLine AND is smallest.<EOL> * @param  {NavigationTreeViewModel} node<EOL> *                  the HTML element from which to start searching<EOL> * @param  {Number} cursorLine the cursor line<EOL> * @return {HTMLElement|null} the node's HTML representation which matches cursorLine<EOL> *                            (i.e. which' start-, end-position contain cursorLine while<EOL> *                             having the smallest distance to cursorLine), or NULL if no<EOL> *                            matching node can be found<EOL> */<EOL>export function findNodeAt(startLine: number, endLine: number, node: NavigationTreeViewModel): NavigationTreeViewModel | null {<EOL>    if (!node.childItems) {<EOL>        return null;<EOL>    }<EOL>    for (const elem of node.childItems) {<EOL>        const start: number = getNodeStartLine(elem);<EOL>        const end: number = getNodeEndLine(elem);<EOL>        if (isFinite(start) && isFinite(end)) {<EOL>            if (startLine >= start && endLine <= end) {<EOL>                const selected = findNodeAt(startLine, endLine, elem);<EOL>                if (selected) {<EOL>                    return selected;<EOL>                }<EOL>","gt":"else {"}
{"input":"<s> /**<EOL> * HELPER find the node that is \"furthest down\" the<EOL> *        node hiearchy, i.e. which's start-, end-position contains the<EOL> *        cursorLine AND is smallest.<EOL> * @param  {NavigationTreeViewModel} node<EOL> *                  the HTML element from which to start searching<EOL> * @param  {Number} cursorLine the cursor line<EOL> * @return {HTMLElement|null} the node's HTML representation which matches cursorLine<EOL> *                            (i.e. which' start-, end-position contain cursorLine while<EOL> *                             having the smallest distance to cursorLine), or NULL if no<EOL> *                            matching node can be found<EOL> */<EOL>export function findNodeAt(startLine: number, endLine: number, node: NavigationTreeViewModel): NavigationTreeViewModel | null {<EOL>    if (!node.childItems) {<EOL>        return null;<EOL>    }<EOL>    for (const elem of node.childItems) {<EOL>        const start: number = getNodeStartLine(elem);<EOL>        const end: number = getNodeEndLine(elem);<EOL>        if (isFinite(start) && isFinite(end)) {<EOL>            if (startLine >= start && endLine <= end) {<EOL>                const selected = findNodeAt(startLine, endLine, elem);<EOL>                if (selected) {<EOL>                    return selected;<EOL>                }<EOL>                else {<EOL>                    return elem;<EOL>                }<EOL>            }<EOL>            else if (isFinite(end) &&","gt":"endLine < end) {"}
{"input":"<s> /**<EOL> * HELPER find the node that is \"furthest down\" the<EOL> *        node hiearchy, i.e. which's start-, end-position contains the<EOL> *        cursorLine AND is smallest.<EOL> * @param  {NavigationTreeViewModel} node<EOL> *                  the HTML element from which to start searching<EOL> * @param  {Number} cursorLine the cursor line<EOL> * @return {HTMLElement|null} the node's HTML representation which matches cursorLine<EOL> *                            (i.e. which' start-, end-position contain cursorLine while<EOL> *                             having the smallest distance to cursorLine), or NULL if no<EOL> *                            matching node can be found<EOL> */<EOL>export function findNodeAt(startLine: number, endLine: number, node: NavigationTreeViewModel): NavigationTreeViewModel | null {<EOL>    if (!node.childItems) {<EOL>        return null;<EOL>    }<EOL>    for (const elem of node.childItems) {<EOL>        const start: number = getNodeStartLine(elem);<EOL>        const end: number = getNodeEndLine(elem);<EOL>        if (isFinite(start) && isFinite(end)) {<EOL>            if (startLine >= start && endLine <= end) {<EOL>                const selected = findNodeAt(startLine, endLine, elem);<EOL>                if (selected) {<EOL>                    return selected;<EOL>                }<EOL>                else {<EOL>                    return elem;<EOL>                }<EOL>            }<EOL>            else if (isFinite(end) && endLine < end) {<EOL>                break;<EOL>            }<EOL>        }<EOL>        const selectedChild = findNodeAt(startLine, endLine, elem);<EOL>        if (selectedChild) {<EOL>            return","gt":"selectedChild;"}
{"input":"<s> export function launchOmniSharp(cwd: string, args: string[], launchPath: string): Promise<LaunchResult> {<EOL>    return new Promise<LaunchResult>((resolve, reject) => {<EOL>        launch(cwd, args, launchPath)<EOL>            .then(result => {<EOL>            <EOL>            result.process.on(","gt":"'<STR_LIT>', err => {"}
{"input":"<s> export function launchOmniSharp(cwd: string, args: string[], launchPath: string): Promise<LaunchResult> {<EOL>    return new Promise<LaunchResult>((resolve, reject) => {<EOL>        launch(cwd, args, launchPath)<EOL>            .then(result => {<EOL>            <EOL>            result.process.on('<STR_LIT>', err => {<EOL>                reject(err);<EOL>            });<EOL>            <EOL>            setTimeout(function () {<EOL>                resolve(result);<EOL>            },","gt":"<NUM_LIT>);"}
{"input":"<s> function setNativeValue(mySwitch: switchModule.Switch, value: boolean) {<EOL>    if (platform.isAndroid) {<EOL>        const nativeView: android.widget.Switch = mySwitch.nativeViewProtected;<EOL>        nativeView.","gt":"setChecked(value);"}
{"input":"<s> function wallTimeHelper(wallTime: any) {<EOL>","gt":"return wallTime['<STR_LIT>'];"}
{"input":"<s> function cleanISOString(input: string) {<EOL>    return input.replace(/(\\.\\d\\d\\d)?Z?$/,","gt":"'<STR_LIT>');"}
{"input":"<s> /**<EOL> * Tests if the given message is a notification message<EOL> */<EOL>export function isNotificationMessage(message: Message | undefined): message is NotificationMessage {<EOL>    let","gt":"candidate = <NotificationMessage>message;"}
{"input":"<s> function calculateNodeStyling(node: Element, useCache: boolean = false): {<EOL>    sizingStyle: string;<EOL>    paddingSize: number;<EOL>    borderSize: number;<EOL>    boxSizing: string;<EOL>} {<EOL>    const nodeRef = (node.getAttribute('<STR_LIT>') ||<EOL>        node.getAttribute('<STR_LIT>') ||<EOL>        node.getAttribute('<STR_LIT>'));<EOL>    if (useCache && computedStyleCache[nodeRef]) {<EOL>        return","gt":"computedStyleCache[nodeRef];"}
{"input":"<s> function calculateNodeStyling(node: Element, useCache: boolean = false): {<EOL>    sizingStyle: string;<EOL>    paddingSize: number;<EOL>    borderSize: number;<EOL>    boxSizing: string;<EOL>} {<EOL>    const nodeRef = (node.getAttribute('<STR_LIT>') ||<EOL>        node.getAttribute('<STR_LIT>') ||<EOL>        node.getAttribute('<STR_LIT>'));<EOL>    if (useCache && computedStyleCache[nodeRef]) {<EOL>        return computedStyleCache[nodeRef];<EOL>    }<EOL>    const style = window.getComputedStyle(node);<EOL>    const boxSizing = (style.getPropertyValue('<STR_LIT>') ||<EOL>","gt":"style.getPropertyValue('<STR_LIT>') ||"}
{"input":"<s> function calculateNodeStyling(node: Element, useCache: boolean = false): {<EOL>    sizingStyle: string;<EOL>    paddingSize: number;<EOL>    borderSize: number;<EOL>    boxSizing: string;<EOL>} {<EOL>    const nodeRef = (node.getAttribute('<STR_LIT>') ||<EOL>        node.getAttribute('<STR_LIT>') ||<EOL>        node.getAttribute('<STR_LIT>'));<EOL>    if (useCache && computedStyleCache[nodeRef]) {<EOL>        return computedStyleCache[nodeRef];<EOL>    }<EOL>    const style = window.getComputedStyle(node);<EOL>    const boxSizing = (style.getPropertyValue('<STR_LIT>') ||<EOL>        style.getPropertyValue('<STR_LIT>') ||<EOL>        style.getPropertyValue('<STR_LIT>'));<EOL>    const paddingSize = (parseFloat(style.getPropertyValue('<STR_LIT>')) +<EOL>        parseFloat(style.","gt":"getPropertyValue('<STR_LIT>')));"}
{"input":"<s> function calculateNodeStyling(node: Element, useCache: boolean = false): {<EOL>    sizingStyle: string;<EOL>    paddingSize: number;<EOL>    borderSize: number;<EOL>    boxSizing: string;<EOL>} {<EOL>    const nodeRef = (node.getAttribute('<STR_LIT>') ||<EOL>        node.getAttribute('<STR_LIT>') ||<EOL>        node.getAttribute('<STR_LIT>'));<EOL>    if (useCache && computedStyleCache[nodeRef]) {<EOL>        return computedStyleCache[nodeRef];<EOL>    }<EOL>    const style = window.getComputedStyle(node);<EOL>    const boxSizing = (style.getPropertyValue('<STR_LIT>') ||<EOL>        style.getPropertyValue('<STR_LIT>') ||<EOL>        style.getPropertyValue('<STR_LIT>'));<EOL>    const paddingSize = (parseFloat(style.getPropertyValue('<STR_LIT>')) +<EOL>        parseFloat(style.getPropertyValue('<STR_LIT>')));<EOL>    const borderSize = (parseFloat(style.getPropertyValue('<STR_LIT>')) +<EOL>        parseFloat(style.getPropertyValue('<STR_LIT>')));<EOL>","gt":"const sizingStyle = SIZING_STYLE"}
{"input":"<s> function calculateNodeStyling(node: Element, useCache: boolean = false): {<EOL>    sizingStyle: string;<EOL>    paddingSize: number;<EOL>    borderSize: number;<EOL>    boxSizing: string;<EOL>} {<EOL>    const nodeRef = (node.getAttribute('<STR_LIT>') ||<EOL>        node.getAttribute('<STR_LIT>') ||<EOL>        node.getAttribute('<STR_LIT>'));<EOL>    if (useCache && computedStyleCache[nodeRef]) {<EOL>        return computedStyleCache[nodeRef];<EOL>    }<EOL>    const style = window.getComputedStyle(node);<EOL>    const boxSizing = (style.getPropertyValue('<STR_LIT>') ||<EOL>        style.getPropertyValue('<STR_LIT>') ||<EOL>        style.getPropertyValue('<STR_LIT>'));<EOL>    const paddingSize = (parseFloat(style.getPropertyValue('<STR_LIT>')) +<EOL>        parseFloat(style.getPropertyValue('<STR_LIT>')));<EOL>    const borderSize = (parseFloat(style.getPropertyValue('<STR_LIT>')) +<EOL>        parseFloat(style.getPropertyValue('<STR_LIT>')));<EOL>    const sizingStyle = SIZING_STYLE<EOL>        .map(name => `<STR_LIT>`)<EOL>        .join('<STR_LIT>');<EOL>    const nodeInfo = {<EOL>        sizingStyle,<EOL>","gt":"paddingSize,"}
{"input":"<s> export function NZ_LOCALE_SERVICE_PROVIDER_FACTORY(exist: NzLocaleService, locale: NzLocale, logger: LoggerService): NzLocaleService {<EOL>    return exist ||","gt":"new NzLocaleService(locale, logger);"}
{"input":"<s> <EOL>function getEditorPosition(editor: Atom.TextEditor): Location {<EOL>    const pos = editor.getCursorBufferPosition();<EOL>","gt":"return {"}
{"input":"<s> /**<EOL> * Create a hash of the current configuration.<EOL> */<EOL>function getCompilerDigest(obj: object) {<EOL>    return crypto.createHash('<STR_LIT>').","gt":"update(JSON.stringify(obj), '<STR_LIT>').digest('<STR_LIT>');"}
{"input":"<s> export function pointToLocation(point: Atom.PointLike): Location {<EOL>","gt":"return { line: point.row + <NUM_LIT>, offset: point.column + <NUM_LIT> };"}
{"input":"<s> export function spanToRange(span: TextSpan): Atom.Range {<EOL>    return locationsToRange(span.start,","gt":"span.end);"}
{"input":"<s> export function updateBucketSize(existing: Granularity, newInput: Granularity): Granularity {<EOL>    if (newInput instanceof TimeBucketAction) {<EOL>        return new TimeBucketAction({<EOL>            duration: (newInput as TimeBucketAction).duration,<EOL>            timezone: (existing as TimeBucketAction).","gt":"timezone"}
{"input":"<s> export function updateBucketSize(existing: Granularity, newInput: Granularity): Granularity {<EOL>    if (newInput instanceof TimeBucketAction) {<EOL>        return new TimeBucketAction({<EOL>            duration: (newInput as TimeBucketAction).duration,<EOL>            timezone: (existing as TimeBucketAction).timezone<EOL>        });<EOL>    }<EOL>    else if (newInput instanceof NumberBucketAction) {<EOL>        var value: ActionValue = { size: (newInput as NumberBucketAction).size };<EOL>        if ((existing as NumberBucketAction).offset)<EOL>            value.offset = (","gt":"existing as NumberBucketAction).offset;"}
{"input":"<s> export function findSymbols(server: OmniSharpServer, request: protocol.FindSymbolsRequest, token: vscode.CancellationToken) {<EOL>    return","gt":"server.makeRequest<protocol.FindSymbolsResponse>(protocol.Requests.FindSymbols, request, token);"}
{"input":"<s> export function test_set_max_min_value() {<EOL>    const slider = new Slider();<EOL>    slider.maxValue = MAX_TEST_VALUE;<EOL>    slider.minValue =","gt":"MIN_TEST_VALUE;"}
{"input":"<s> export function getCurrentPage(): Page {<EOL>","gt":"return frame.topmost().currentPage;"}
{"input":"<s> export function instantiateRendererFactory(renderer: NativeScriptRendererFactory, engine: AnimationEngine, zone: NgZone) {<EOL>    return new AnimationRendererFactory(","gt":"renderer, engine, zone);"}
{"input":"<s> export function test_setting_borderWidth_property_from_CSS_is_applied_to_Style() {<EOL>","gt":"test_property_from_CSS_is_applied_to_style(\"<STR_LIT>\", \"<STR_LIT>\", <NUM_LIT>, \"<STR_LIT>\", true);"}
{"input":"<s> function registerCustomFonts() {<EOL>    const appDir = fs.knownFolders.currentApp().path;<EOL>    const fontsDir = fs.path.","gt":"join(appDir, \"<STR_LIT>\");"}
{"input":"<s> export function initChart(highchartsService: HighchartsService, userOpts, baseOpts, type: string) {<EOL>    const Highcharts = highchartsService.getHighchartsStatic();<EOL>    if (!Highcharts) {<EOL>        throw new Error('<STR_LIT>');<EOL>    }<EOL>    if (!Highcharts[","gt":"type]) {"}
{"input":"<s> export function initChart(highchartsService: HighchartsService, userOpts, baseOpts, type: string) {<EOL>    const Highcharts = highchartsService.getHighchartsStatic();<EOL>    if (!Highcharts) {<EOL>        throw new Error('<STR_LIT>');<EOL>    }<EOL>    if (!Highcharts[type]) {<EOL>        throw new Error(`<STR_LIT>`);<EOL>    }<EOL>    <EOL>    if (Array.isArray(","gt":"userOpts.xAxis)) {"}
{"input":"<s> export function initChart(highchartsService: HighchartsService, userOpts, baseOpts, type: string) {<EOL>    const Highcharts = highchartsService.getHighchartsStatic();<EOL>    if (!Highcharts) {<EOL>        throw new Error('<STR_LIT>');<EOL>    }<EOL>    if (!Highcharts[type]) {<EOL>        throw new Error(`<STR_LIT>`);<EOL>    }<EOL>    <EOL>    if (Array.isArray(userOpts.xAxis)) {<EOL>        baseOpts.xAxis = [baseOpts.xAxis];<EOL>    }<EOL>    if (Array.isArray(userOpts.yAxis)) {<EOL>","gt":"baseOpts.yAxis = [baseOpts.yAxis];"}
{"input":"<s> function addListenerWithSource(source: Observable) {<EOL>","gt":"const target = new Target();"}
{"input":"<s> export function test_setting_borderColorRGBA_property_from_CSS_is_applied_to_Style() {<EOL>    test_property_from_CSS_is_applied_to_style(","gt":"\"<STR_LIT>\", \"<STR_LIT>\", new Color(\"<STR_LIT>\"), \"<STR_LIT>\");"}
{"input":"<s> export function goBack() {<EOL>    waitUntilNavigatedFrom(() => frame.topmost().","gt":"goBack());"}
{"input":"<s> function assignKey(to, from, key) {<EOL>    var val = from[key];<EOL>    if (val === undefined || val === null) {<EOL>        return;<EOL>    }<EOL>    if (hasOwnProperty.call(","gt":"to, key)) {"}
{"input":"<s> export function test_ItemTemplateFactoryFunction() {<EOL>    var repeater = new repeaterModule.Repeater();<EOL>    function testAction(views: Array<viewModule.View>) {<EOL>        repeater.itemTemplate = () => {<EOL>            var label = new Label();<EOL>            label.id =","gt":"\"<STR_LIT>\";"}
{"input":"<s> export function test_ItemTemplateFactoryFunction() {<EOL>    var repeater = new repeaterModule.Repeater();<EOL>    function testAction(views: Array<viewModule.View>) {<EOL>        repeater.itemTemplate = () => {<EOL>            var label = new Label();<EOL>            label.id = \"<STR_LIT>\";<EOL>            label.bind({ sourceProperty: \"<STR_LIT>\", targetProperty: \"<STR_LIT>\", twoWay: false });<EOL>            return label;<EOL>        };<EOL>        repeater.items = [<NUM_LIT>,","gt":"<NUM_LIT>, <NUM_LIT>];"}
{"input":"<s> export function test_ItemTemplateFactoryFunction() {<EOL>    var repeater = new repeaterModule.Repeater();<EOL>    function testAction(views: Array<viewModule.View>) {<EOL>        repeater.itemTemplate = () => {<EOL>            var label = new Label();<EOL>            label.id = \"<STR_LIT>\";<EOL>            label.bind({ sourceProperty: \"<STR_LIT>\", targetProperty: \"<STR_LIT>\", twoWay: false });<EOL>            return label;<EOL>        };<EOL>        repeater.items = [<NUM_LIT>, <NUM_LIT>, <NUM_LIT>];<EOL>        TKUnit.waitUntilReady(() => repeater.isLayoutValid);<EOL>        TKUnit.assertEqual(getChildAtText(repeater, <NUM_LIT>), \"<STR_LIT>\", \"<STR_LIT>\");<EOL>        TKUnit.assertEqual(getChildAtText(","gt":"repeater, <NUM_LIT>), \"<STR_LIT>\", \"<STR_LIT>\");"}
{"input":"<s> export function extHostNamedCustomer<T extends IDisposable>(id: ProxyIdentifier<T>) {<EOL>","gt":"return function (ctor: IExtHostCustomerCtor<T>): void {"}
{"input":"<s> function isNumeric(n) {<EOL>","gt":"return !isNaN(parseFloat(n)) && isFinite(n);"}
{"input":"<s> export function test_correct_layout_top_bottom_edges_does_not_span_scrollable_flat() {<EOL>    test_correct_layout_top_bottom_edges_does_not_span_options(true,","gt":"true);"}
{"input":"<s> export function extHostCustomer<T extends IDisposable>(ctor: IExtHostCustomerCtor<T>): void {<EOL>    ExtHostCustomersRegistryImpl.","gt":"INSTANCE.registerCustomer(ctor);"}
{"input":"<s> export function test_setting_textAlignment_property_from_CSS_is_applied_to_Style() {<EOL>","gt":"test_property_from_CSS_is_applied_to_style(\"<STR_LIT>\", \"<STR_LIT>\", \"<STR_LIT>\");"}
{"input":"<s> export function test_MoreThanOneBindables_BindToASameSourceAndProperty() {<EOL>    const model = new Observable();<EOL>    const bindingOptions: BindingOptions = {<EOL>        sourceProperty: \"<STR_LIT>\",<EOL>","gt":"targetProperty: \"<STR_LIT>\""}
{"input":"<s> export function test_MoreThanOneBindables_BindToASameSourceAndProperty() {<EOL>    const model = new Observable();<EOL>    const bindingOptions: BindingOptions = {<EOL>        sourceProperty: \"<STR_LIT>\",<EOL>        targetProperty: \"<STR_LIT>\"<EOL>    };<EOL>    const obj1 = new Label();<EOL>    obj1.bind(bindingOptions, model);<EOL>    const obj2 = new Label();<EOL>    obj2.bind(bindingOptions, model);<EOL>    model.set(","gt":"\"<STR_LIT>\", \"<STR_LIT>\");"}
{"input":"<s> export function test_property_changed_event_when_setting_maxValue_no_adjust() {<EOL>    const slider = new Slider();<EOL>    slider.maxValue = <NUM_LIT>;<EOL>    slider.value = <NUM_LIT>;<EOL>","gt":"slider.minValue = <NUM_LIT>;"}
{"input":"<s> export function test_property_changed_event_when_setting_maxValue_no_adjust() {<EOL>    const slider = new Slider();<EOL>    slider.maxValue = <NUM_LIT>;<EOL>    slider.value = <NUM_LIT>;<EOL>    slider.minValue = <NUM_LIT>;<EOL>    function testAction(views: Array<View>) {<EOL>        const changedProperties = {};<EOL>        let","gt":"allChanges = <NUM_LIT>;"}
{"input":"<s> export function test_property_changed_event_when_setting_maxValue_no_adjust() {<EOL>    const slider = new Slider();<EOL>    slider.maxValue = <NUM_LIT>;<EOL>    slider.value = <NUM_LIT>;<EOL>    slider.minValue = <NUM_LIT>;<EOL>    function testAction(views: Array<View>) {<EOL>        const changedProperties = {};<EOL>        let allChanges = <NUM_LIT>;<EOL>        attachValueChangedEvents(slider, (data: PropertyChangeData) => {<EOL>            allChanges++;<EOL>            changedProperties[data.propertyName] = true;<EOL>        });<EOL>        <EOL>        slider.maxValue = <NUM_LIT>;<EOL>        detachValueChangedEvents(slider);<EOL>        <EOL>","gt":"TKUnit.assert(changedProperties[\"<STR_LIT>\"], \"<STR_LIT>\");"}
{"input":"<s> function printTNSInfo() {<EOL>    console.log(\"<STR_LIT>\" + platform.device.model);<EOL>    console.log(\"<STR_LIT>\" + platform.device.os);<EOL>    console.log(\"<STR_LIT>\" + platform.device.osVersion);<EOL>","gt":"console.log(\"<STR_LIT>\" + platform.device.sdkVersion);"}
{"input":"<s> function printTNSInfo() {<EOL>    console.log(\"<STR_LIT>\" + platform.device.model);<EOL>    console.log(\"<STR_LIT>\" + platform.device.os);<EOL>    console.log(\"<STR_LIT>\" + platform.device.osVersion);<EOL>    console.log(\"<STR_LIT>\" + platform.device.sdkVersion);<EOL>    console.log(\"<STR_LIT>\" + platform.device.deviceType);<EOL>    console.log(\"<STR_LIT>\" + platform.screen.mainScreen.widthDIPs);<EOL>    console.log(\"<STR_LIT>\" + platform.screen.mainScreen.heightDIPs);<EOL>    console.","gt":"log(\"<STR_LIT>\" + platform.screen.mainScreen.scale);"}
{"input":"<s> function createNewCacheSnapshot(cacheContext: CacheContext) {<EOL>    const snapshot = createGraphSnapshot({<EOL>        one: {<EOL>            two: [<EOL>                {<EOL>","gt":"three: {"}
{"input":"<s> function createNewCacheSnapshot(cacheContext: CacheContext) {<EOL>    const snapshot = createGraphSnapshot({<EOL>        one: {<EOL>            two: [<EOL>                {<EOL>                    three: {<EOL>                        id: <NUM_LIT>,<EOL>                        four: { five: <NUM_LIT> },<EOL>                        color:","gt":"'<STR_LIT>',"}
{"input":"<s> function createNewCacheSnapshot(cacheContext: CacheContext) {<EOL>    const snapshot = createGraphSnapshot({<EOL>        one: {<EOL>            two: [<EOL>                {<EOL>                    three: {<EOL>                        id: <NUM_LIT>,<EOL>                        four: { five: <NUM_LIT> },<EOL>                        color: '<STR_LIT>',<EOL>                        __typename: '<STR_LIT>',<EOL>                    },<EOL>                },<EOL>                {<EOL>","gt":"three: {"}
{"input":"<s> export function test_Bindable_BindingContext_Number_DoesNotThrow() {<EOL>    const obj = new","gt":"Label();"}
{"input":"<s> export function getNativeBackgroundColor(textField: textFieldModule.TextField): colorModule.Color {<EOL>    var bkg = <any>textField.android.getBackground();<EOL>    if (bkg instanceof org.nativescript.widgets.BorderDrawable) {<EOL>        return new","gt":"colorModule.Color((<org.nativescript.widgets.BorderDrawable>bkg).getBackgroundColor());"}
{"input":"<s> function ts(files: string[]) {<EOL>    var t = fs.readFileSync(files[<NUM_LIT>], \"<STR_LIT>\");<EOL>","gt":"var opts = td2tsOpts();"}
{"input":"<s> export function test_parseSpansDirectlyToFormattedString() {<EOL>    var p = <Page>builder.parse('<STR_LIT>');<EOL>    function testAction(views: Array<viewModule.View>) {<EOL>        var page = <Page>","gt":"views[<NUM_LIT>];"}
{"input":"<s> export function base64Encode(inputStr: string) {<EOL>    var b64 = '<STR_LIT>';<EOL>    var outputStr = '<STR_LIT>';<EOL>    var i = <NUM_LIT>;<EOL>    while (i < inputStr.length) {<EOL>        <EOL>        <EOL>        var byte1 = inputStr.charCodeAt(i++) & <NUM_LIT>;<EOL>        var byte2 = inputStr.charCodeAt(i++) & <NUM_LIT>;<EOL>","gt":"var byte3 = inputStr.charCodeAt(i++) & <NUM_LIT>;"}
{"input":"<s> export function base64Encode(inputStr: string) {<EOL>    var b64 = '<STR_LIT>';<EOL>    var outputStr = '<STR_LIT>';<EOL>    var i = <NUM_LIT>;<EOL>    while (i < inputStr.length) {<EOL>        <EOL>        <EOL>        var byte1 = inputStr.charCodeAt(i++) & <NUM_LIT>;<EOL>        var byte2 = inputStr.charCodeAt(i++) & <NUM_LIT>;<EOL>        var byte3 = inputStr.charCodeAt(i++) & <NUM_LIT>;<EOL>        var enc1 = byte1 >> <NUM_LIT>;<EOL>        var enc2 = ((byte1 & <NUM_LIT>) << <NUM_LIT>) | (byte2 >> <NUM_LIT>);<EOL>        var","gt":"enc3, enc4;"}
{"input":"<s> export function base64Encode(inputStr: string) {<EOL>    var b64 = '<STR_LIT>';<EOL>    var outputStr = '<STR_LIT>';<EOL>    var i = <NUM_LIT>;<EOL>    while (i < inputStr.length) {<EOL>        <EOL>        <EOL>        var byte1 = inputStr.charCodeAt(i++) & <NUM_LIT>;<EOL>        var byte2 = inputStr.charCodeAt(i++) & <NUM_LIT>;<EOL>        var byte3 = inputStr.charCodeAt(i++) & <NUM_LIT>;<EOL>        var enc1 = byte1 >> <NUM_LIT>;<EOL>        var enc2 = ((byte1 & <NUM_LIT>) << <NUM_LIT>) | (byte2 >> <NUM_LIT>);<EOL>        var enc3, enc4;<EOL>        if (isNaN(byte2)) {<EOL>            enc3 = enc4 = <NUM_LIT>;<EOL>        }<EOL>        else {<EOL>            enc3 = ((byte2 & <NUM_LIT>) << <NUM_LIT>) | (byte3 >> <NUM_LIT>);<EOL>            if (isNaN(byte3)) {<EOL>                enc4 = <NUM_LIT>;<EOL>            }<EOL>","gt":"else {"}
{"input":"<s> export function test_getBindableOptionsFromStringShortFormatExpression() {<EOL>    const bindingExpression = \"<STR_LIT>\";<EOL>    const","gt":"bindOptions = bindingBuilder.getBindingOptions(\"<STR_LIT>\", bindingExpression);"}
{"input":"<s> export function resolveFileNameFromUrl(url: string, appDirectory: string, fileExists: (name: string) => boolean): string {<EOL>    let fileName: string = typeof url === \"<STR_LIT>\" ? url.trim() : \"<STR_LIT>\";<EOL>    if (fileName.indexOf(\"<STR_LIT>\") === <NUM_LIT>) {<EOL>        fileName = fileName.replace(\"<STR_LIT>\", \"<STR_LIT>\");<EOL>    }<EOL>    const isAbsolutePath = fileName.indexOf(\"<STR_LIT>\") === <NUM_LIT>;<EOL>","gt":"const absolutePath = isAbsolutePath ? fileName : path.join(appDirectory, fileName);"}
{"input":"<s> export function resolveFileNameFromUrl(url: string, appDirectory: string, fileExists: (name: string) => boolean): string {<EOL>    let fileName: string = typeof url === \"<STR_LIT>\" ? url.trim() : \"<STR_LIT>\";<EOL>    if (fileName.indexOf(\"<STR_LIT>\") === <NUM_LIT>) {<EOL>        fileName = fileName.replace(\"<STR_LIT>\", \"<STR_LIT>\");<EOL>    }<EOL>    const isAbsolutePath = fileName.indexOf(\"<STR_LIT>\") === <NUM_LIT>;<EOL>    const absolutePath = isAbsolutePath ? fileName : path.join(appDirectory, fileName);<EOL>    if (fileExists(absolutePath)) {<EOL>        return absolutePath;<EOL>    }<EOL>    if (!isAbsolutePath) {<EOL>        if (fileName[<NUM_LIT>] === \"<STR_LIT>\" && fileName[","gt":"<NUM_LIT>] !== \"<STR_LIT>\" && fileName[<NUM_LIT>] !== \"<STR_LIT>\") {"}
{"input":"<s> export function resolveFileNameFromUrl(url: string, appDirectory: string, fileExists: (name: string) => boolean): string {<EOL>    let fileName: string = typeof url === \"<STR_LIT>\" ? url.trim() : \"<STR_LIT>\";<EOL>    if (fileName.indexOf(\"<STR_LIT>\") === <NUM_LIT>) {<EOL>        fileName = fileName.replace(\"<STR_LIT>\", \"<STR_LIT>\");<EOL>    }<EOL>    const isAbsolutePath = fileName.indexOf(\"<STR_LIT>\") === <NUM_LIT>;<EOL>    const absolutePath = isAbsolutePath ? fileName : path.join(appDirectory, fileName);<EOL>    if (fileExists(absolutePath)) {<EOL>        return absolutePath;<EOL>    }<EOL>    if (!isAbsolutePath) {<EOL>        if (fileName[<NUM_LIT>] === \"<STR_LIT>\" && fileName[<NUM_LIT>] !== \"<STR_LIT>\" && fileName[<NUM_LIT>] !== \"<STR_LIT>\") {<EOL>            fileName = fileName.substr(<NUM_LIT>);<EOL>        }<EOL>        const external = path.join(appDirectory, \"<STR_LIT>\", fileName);<EOL>        if (fileExists(","gt":"external)) {"}
{"input":"<s> <EOL><EOL><EOL>function changeNewLineCharacter(input: string): string {<EOL>    return input ? input.","gt":"replace(/\\r?\\n/g, EOL) : input;"}
{"input":"<s> function createNewCacheSnapshot(cacheContext: CacheContext) {<EOL>    const snapshot = createGraphSnapshot({<EOL>        foo: <NUM_LIT>,<EOL>        bar: '<STR_LIT>',<EOL>","gt":"viewer: {"}
{"input":"<s> export function test_NonExistingElementError() {<EOL>    var basePath = \"<STR_LIT>\";<EOL>    var expectedErrorStart = \"<STR_LIT>\" + basePath + \"<STR_LIT>\" +<EOL>        \"<STR_LIT>\";<EOL>    var","gt":"message;"}
{"input":"<s> export function test_NonExistingElementError() {<EOL>    var basePath = \"<STR_LIT>\";<EOL>    var expectedErrorStart = \"<STR_LIT>\" + basePath + \"<STR_LIT>\" +<EOL>        \"<STR_LIT>\";<EOL>    var message;<EOL>    try {<EOL>        builder.load(__dirname + \"<STR_LIT>\");<EOL>    }<EOL>    catch (e) {<EOL>        message =","gt":"e.message;"}
{"input":"<s> export function test_EventInTemplate() {<EOL>    var pageCode = require(\"<STR_LIT>\");<EOL>    var notified = false;<EOL>    pageCode.test = (args) => {<EOL>        notified = true;<EOL>    };<EOL>    var page = builder.load(__dirname +","gt":"\"<STR_LIT>\", pageCode);"}
{"input":"<s> export function test_EventInTemplate() {<EOL>    var pageCode = require(\"<STR_LIT>\");<EOL>    var notified = false;<EOL>    pageCode.test = (args) => {<EOL>        notified = true;<EOL>    };<EOL>    var page = builder.load(__dirname + \"<STR_LIT>\", pageCode);<EOL>    TKUnit.assert(view, \"<STR_LIT>\");<EOL>    var templateView = <TemplateView>page.getViewById(\"<STR_LIT>\");<EOL>    TKUnit.assert(templateView, \"<STR_LIT>\");<EOL>","gt":"templateView.parseTemplate();"}
{"input":"<s> export function test_EventInTemplate() {<EOL>    var pageCode = require(\"<STR_LIT>\");<EOL>    var notified = false;<EOL>    pageCode.test = (args) => {<EOL>        notified = true;<EOL>    };<EOL>    var page = builder.load(__dirname + \"<STR_LIT>\", pageCode);<EOL>    TKUnit.assert(view, \"<STR_LIT>\");<EOL>    var templateView = <TemplateView>page.getViewById(\"<STR_LIT>\");<EOL>    TKUnit.assert(templateView, \"<STR_LIT>\");<EOL>    templateView.parseTemplate();<EOL>    TKUnit.assertEqual(templateView.getChildrenCount(), <NUM_LIT>, \"<STR_LIT>\");<EOL>    var childTemplateView = <TemplateView>templateView.getChildAt(<NUM_LIT>);<EOL>    TKUnit.assert(childTemplateView, \"<STR_LIT>\");<EOL>    childTemplateView.","gt":"notify({"}
{"input":"<s> function loadFontFromFile(fontFamily: string): android.graphics.Typeface {<EOL>    appAssets = appAssets || application.android.context.getAssets();<EOL>    if (!appAssets) {<EOL>","gt":"return null;"}
{"input":"<s> function loadFontFromFile(fontFamily: string): android.graphics.Typeface {<EOL>    appAssets = appAssets || application.android.context.getAssets();<EOL>    if (!appAssets) {<EOL>        return null;<EOL>    }<EOL>    let","gt":"result = typefaceCache.get(fontFamily);"}
{"input":"<s> function loadFontFromFile(fontFamily: string): android.graphics.Typeface {<EOL>    appAssets = appAssets || application.android.context.getAssets();<EOL>    if (!appAssets) {<EOL>        return null;<EOL>    }<EOL>    let result = typefaceCache.get(fontFamily);<EOL>    <EOL>    if (result ===","gt":"undefined) {"}
{"input":"<s> function loadFontFromFile(fontFamily: string): android.graphics.Typeface {<EOL>    appAssets = appAssets || application.android.context.getAssets();<EOL>    if (!appAssets) {<EOL>        return null;<EOL>    }<EOL>    let result = typefaceCache.get(fontFamily);<EOL>    <EOL>    if (result === undefined) {<EOL>        result = null;<EOL>        let fontAssetPath: string;<EOL>        const basePath = fs.path.join(fs.knownFolders.currentApp().path, \"<STR_LIT>\", fontFamily);<EOL>        if (","gt":"fs.File.exists(basePath + \"<STR_LIT>\")) {"}
{"input":"<s> function loadFontFromFile(fontFamily: string): android.graphics.Typeface {<EOL>    appAssets = appAssets || application.android.context.getAssets();<EOL>    if (!appAssets) {<EOL>        return null;<EOL>    }<EOL>    let result = typefaceCache.get(fontFamily);<EOL>    <EOL>    if (result === undefined) {<EOL>        result = null;<EOL>        let fontAssetPath: string;<EOL>        const basePath = fs.path.join(fs.knownFolders.currentApp().path, \"<STR_LIT>\", fontFamily);<EOL>        if (fs.File.exists(basePath + \"<STR_LIT>\")) {<EOL>            fontAssetPath = FONTS_BASE_PATH + fontFamily + \"<STR_LIT>\";<EOL>        }<EOL>        else if (fs.File.exists(basePath + \"<STR_LIT>\")) {<EOL>            fontAssetPath =","gt":"FONTS_BASE_PATH + fontFamily + \"<STR_LIT>\";"}
{"input":"<s> function loadFontFromFile(fontFamily: string): android.graphics.Typeface {<EOL>    appAssets = appAssets || application.android.context.getAssets();<EOL>    if (!appAssets) {<EOL>        return null;<EOL>    }<EOL>    let result = typefaceCache.get(fontFamily);<EOL>    <EOL>    if (result === undefined) {<EOL>        result = null;<EOL>        let fontAssetPath: string;<EOL>        const basePath = fs.path.join(fs.knownFolders.currentApp().path, \"<STR_LIT>\", fontFamily);<EOL>        if (fs.File.exists(basePath + \"<STR_LIT>\")) {<EOL>            fontAssetPath = FONTS_BASE_PATH + fontFamily + \"<STR_LIT>\";<EOL>        }<EOL>        else if (fs.File.exists(basePath + \"<STR_LIT>\")) {<EOL>            fontAssetPath = FONTS_BASE_PATH + fontFamily + \"<STR_LIT>\";<EOL>        }<EOL>        else {<EOL>            if (traceEnabled()) {<EOL>                traceWrite(\"<STR_LIT>\" + fontFamily,","gt":"traceCategories.Error, traceMessageType.error);"}
{"input":"<s> function loadFontFromFile(fontFamily: string): android.graphics.Typeface {<EOL>    appAssets = appAssets || application.android.context.getAssets();<EOL>    if (!appAssets) {<EOL>        return null;<EOL>    }<EOL>    let result = typefaceCache.get(fontFamily);<EOL>    <EOL>    if (result === undefined) {<EOL>        result = null;<EOL>        let fontAssetPath: string;<EOL>        const basePath = fs.path.join(fs.knownFolders.currentApp().path, \"<STR_LIT>\", fontFamily);<EOL>        if (fs.File.exists(basePath + \"<STR_LIT>\")) {<EOL>            fontAssetPath = FONTS_BASE_PATH + fontFamily + \"<STR_LIT>\";<EOL>        }<EOL>        else if (fs.File.exists(basePath + \"<STR_LIT>\")) {<EOL>            fontAssetPath = FONTS_BASE_PATH + fontFamily + \"<STR_LIT>\";<EOL>        }<EOL>        else {<EOL>            if (traceEnabled()) {<EOL>                traceWrite(\"<STR_LIT>\" + fontFamily, traceCategories.Error, traceMessageType.error);<EOL>            }<EOL>        }<EOL>        if (fontAssetPath) {<EOL>            try {<EOL>                fontAssetPath = fs.path.join(fs.knownFolders.currentApp().path, fontAssetPath);<EOL>                result = android.graphics.Typeface.createFromFile(fontAssetPath);<EOL>            }<EOL>","gt":"catch (e) {"}
{"input":"<s> export function assertMeasure(view: def.MeasuredView, width: number, height: number, name?: string) {<EOL>    name =","gt":"name ? \"<STR_LIT>\" + name + \"<STR_LIT>\" : \"<STR_LIT>\";"}
{"input":"<s> export function getCommand(args: string[]): TfCommand<ExtensionArguments, void> {<EOL>    return new","gt":"ExtensionBase<void>(args);"}
{"input":"<s> export function a1ProjectionContentsDirective() {<EOL>    return {<EOL>        restrict: '<STR_LIT>',<EOL>","gt":"scope: {},"}
{"input":"<s> export function test_width_property_is_synced_in_style_and_view() {<EOL>    test_property_is_synced_in_style_and_view(","gt":"\"<STR_LIT>\", <NUM_LIT>);"}
{"input":"<s> export function test_ReadTranslateSingle() {<EOL>    const animation = createAnimationFromCSS(\"<STR_LIT>\", \"<STR_LIT>\");<EOL>    const { translate, rotate } = getTransforms(animation.keyframes[<NUM_LIT>].","gt":"declarations);"}
{"input":"<s> export function test_WhenPageIsLoadedFrameCurrentPageIsNotYetTheSameAsThePage() {<EOL>    let page: Page;<EOL>    const loadedEventHandler = function (args) {<EOL>        TKUnit.assertNotEqual(topmost().currentPage, args.object, \"<STR_LIT>\");<EOL>    };<EOL>    const","gt":"pageFactory = function (): Page {"}
{"input":"<s> export function test_WhenPageIsLoadedFrameCurrentPageIsNotYetTheSameAsThePage() {<EOL>    let page: Page;<EOL>    const loadedEventHandler = function (args) {<EOL>        TKUnit.assertNotEqual(topmost().currentPage, args.object, \"<STR_LIT>\");<EOL>    };<EOL>    const pageFactory = function (): Page {<EOL>        page = new Page();<EOL>        page.id = \"<STR_LIT>\";<EOL>        page.on(Label.loadedEvent, loadedEventHandler);<EOL>        const label =","gt":"new Label();"}
{"input":"<s> export function test_WhenPageIsLoadedFrameCurrentPageIsNotYetTheSameAsThePage() {<EOL>    let page: Page;<EOL>    const loadedEventHandler = function (args) {<EOL>        TKUnit.assertNotEqual(topmost().currentPage, args.object, \"<STR_LIT>\");<EOL>    };<EOL>    const pageFactory = function (): Page {<EOL>        page = new Page();<EOL>        page.id = \"<STR_LIT>\";<EOL>        page.on(Label.loadedEvent, loadedEventHandler);<EOL>        const label = new Label();<EOL>        label.text = \"<STR_LIT>\";<EOL>        page.content = label;<EOL>","gt":"return page;"}
{"input":"<s> export function test_NestedPropertiesBindingTwoTargets() {<EOL>    const expectedText = \"<STR_LIT>\";<EOL>    const expectedFirstName = \"<STR_LIT>\";<EOL>    const expectedLastName = \"<STR_LIT>\";<EOL>    const viewModel = new Observable();<EOL>    viewModel.set(\"<STR_LIT>\", new","gt":"Activity(expectedText, expectedFirstName, expectedLastName));"}
{"input":"<s> export function test_NestedPropertiesBindingTwoTargets() {<EOL>    const expectedText = \"<STR_LIT>\";<EOL>    const expectedFirstName = \"<STR_LIT>\";<EOL>    const expectedLastName = \"<STR_LIT>\";<EOL>    const viewModel = new Observable();<EOL>    viewModel.set(\"<STR_LIT>\", new Activity(expectedText, expectedFirstName, expectedLastName));<EOL>    const target1 = new Label();<EOL>    target1.bind({<EOL>        sourceProperty:","gt":"\"<STR_LIT>\","}
{"input":"<s> export function test_NestedPropertiesBindingTwoTargets() {<EOL>    const expectedText = \"<STR_LIT>\";<EOL>    const expectedFirstName = \"<STR_LIT>\";<EOL>    const expectedLastName = \"<STR_LIT>\";<EOL>    const viewModel = new Observable();<EOL>    viewModel.set(\"<STR_LIT>\", new Activity(expectedText, expectedFirstName, expectedLastName));<EOL>    const target1 = new Label();<EOL>    target1.bind({<EOL>        sourceProperty: \"<STR_LIT>\",<EOL>        targetProperty: \"<STR_LIT>\",<EOL>        twoWay: true<EOL>    },","gt":"viewModel);"}
{"input":"<s> export function test_NestedPropertiesBindingTwoTargets() {<EOL>    const expectedText = \"<STR_LIT>\";<EOL>    const expectedFirstName = \"<STR_LIT>\";<EOL>    const expectedLastName = \"<STR_LIT>\";<EOL>    const viewModel = new Observable();<EOL>    viewModel.set(\"<STR_LIT>\", new Activity(expectedText, expectedFirstName, expectedLastName));<EOL>    const target1 = new Label();<EOL>    target1.bind({<EOL>        sourceProperty: \"<STR_LIT>\",<EOL>        targetProperty: \"<STR_LIT>\",<EOL>        twoWay: true<EOL>    }, viewModel);<EOL>    const target2 = new Label();<EOL>    target2.bind({<EOL>","gt":"sourceProperty: \"<STR_LIT>\","}
{"input":"<s> export function test_NestedPropertiesBindingTwoTargets() {<EOL>    const expectedText = \"<STR_LIT>\";<EOL>    const expectedFirstName = \"<STR_LIT>\";<EOL>    const expectedLastName = \"<STR_LIT>\";<EOL>    const viewModel = new Observable();<EOL>    viewModel.set(\"<STR_LIT>\", new Activity(expectedText, expectedFirstName, expectedLastName));<EOL>    const target1 = new Label();<EOL>    target1.bind({<EOL>        sourceProperty: \"<STR_LIT>\",<EOL>        targetProperty: \"<STR_LIT>\",<EOL>        twoWay: true<EOL>    }, viewModel);<EOL>    const target2 = new Label();<EOL>    target2.bind({<EOL>        sourceProperty: \"<STR_LIT>\",<EOL>        targetProperty: \"<STR_LIT>\",<EOL>        twoWay: true<EOL>    }, viewModel);<EOL>    TKUnit.assertEqual(target1.get(\"<STR_LIT>\"), expectedText);<EOL>    TKUnit.assertEqual(target2.get(\"<STR_LIT>\"), expectedFirstName);<EOL>","gt":"const newExpectedText = \"<STR_LIT>\";"}
{"input":"<s> export function test_$ValueSupportWithinExpression() {<EOL>    const model = fromObject({<EOL>        \"<STR_LIT>\": \"<STR_LIT>\",<EOL>        \"<STR_LIT>\": function () {<EOL>            return this.get(\"<STR_LIT>\") === \"<STR_LIT>\";<EOL>        }<EOL>    });<EOL>    const bindableObj = new Label();<EOL>    bindableObj.bind({<EOL>        \"<STR_LIT>\": \"<STR_LIT>\",<EOL>","gt":"\"<STR_LIT>\": \"<STR_LIT>\","}
{"input":"<s> export function test_$ValueSupportWithinExpression() {<EOL>    const model = fromObject({<EOL>        \"<STR_LIT>\": \"<STR_LIT>\",<EOL>        \"<STR_LIT>\": function () {<EOL>            return this.get(\"<STR_LIT>\") === \"<STR_LIT>\";<EOL>        }<EOL>    });<EOL>    const bindableObj = new Label();<EOL>    bindableObj.bind({<EOL>        \"<STR_LIT>\": \"<STR_LIT>\",<EOL>        \"<STR_LIT>\": \"<STR_LIT>\",<EOL>        \"<STR_LIT>\": \"<STR_LIT>\"<EOL>    }, model);<EOL>    model.set(","gt":"\"<STR_LIT>\", \"<STR_LIT>\");"}
{"input":"<s> export function test_binding_marginBottom() {<EOL>","gt":"property_binding_test(\"<STR_LIT>\", <NUM_LIT>, <NUM_LIT>);"}
{"input":"<s> export function test_paddingBottom_property_is_synced_in_style_and_view() {<EOL>    test_property_is_synced_in_style_and_layout_view(","gt":"\"<STR_LIT>\", <NUM_LIT>);"}
{"input":"<s> export function test_binding_style_horizontalAlignment() {<EOL>","gt":"property_binding_style_test(\"<STR_LIT>\", \"<STR_LIT>\", \"<STR_LIT>\");"}
{"input":"<s> export function test_binding_style_opacity() {<EOL>","gt":"property_binding_style_test(\"<STR_LIT>\", <NUM_LIT>, <NUM_LIT>);"}
{"input":"<s> <EOL>function isVoid<a>(value: void | a): value is void {<EOL>","gt":"return undefined;"}
{"input":"<s> export function test_setting_label_whiteSpace_normal_sets_native() {<EOL>    const testView = new Label();<EOL>    testView.style.whiteSpace = \"<STR_LIT>\";<EOL>    helper.buildUIAndRunTest(testView, function (views: Array<View>) {<EOL>        if (","gt":"isAndroid) {"}
{"input":"<s> export function test_setting_label_whiteSpace_normal_sets_native() {<EOL>    const testView = new Label();<EOL>    testView.style.whiteSpace = \"<STR_LIT>\";<EOL>    helper.buildUIAndRunTest(testView, function (views: Array<View>) {<EOL>        if (isAndroid) {<EOL>            TKUnit.assertNull((<android.widget.TextView>testView.android).getEllipsize(), null);<EOL>        }<EOL>        else if (isIOS) {<EOL>            TKUnit.assertEqual((<UILabel>testView.ios).lineBreakMode, NSLineBreakMode.ByWordWrapping);<EOL>            TKUnit.assertEqual((<UILabel>testView.ios).numberOfLines,","gt":"<NUM_LIT>);"}
{"input":"<s> export function test_setting_button_whiteSpace_normal_sets_native() {<EOL>    const testView = new Button();<EOL>    testView.style.whiteSpace = \"<STR_LIT>\";<EOL>    helper.buildUIAndRunTest(testView, function (views: Array<View>) {<EOL>        if (","gt":"isAndroid) {"}
{"input":"<s> export function test_setting_button_whiteSpace_normal_sets_native() {<EOL>    const testView = new Button();<EOL>    testView.style.whiteSpace = \"<STR_LIT>\";<EOL>    helper.buildUIAndRunTest(testView, function (views: Array<View>) {<EOL>        if (isAndroid) {<EOL>            TKUnit.assertNull((<android.widget.Button>testView.android).getEllipsize(), null);<EOL>        }<EOL>        else if (isIOS) {<EOL>            TKUnit.assertEqual((<UIButton>testView.ios).titleLabel.lineBreakMode, NSLineBreakMode.ByWordWrapping);<EOL>            TKUnit.","gt":"assertEqual((<UIButton>testView.ios).titleLabel.numberOfLines, <NUM_LIT>);"}
{"input":"<s> export function test_css_is_applied_to_special_properties() {<EOL>    const stack = new stackModule.StackLayout();<EOL>    helper.buildUIAndRunTest(stack, function (views: Array<viewModule.View>) {<EOL>        const page = <pageModule.Page>","gt":"views[<NUM_LIT>];"}
{"input":"<s> export function test_id_selector() {<EOL>    let page = helper.getClearCurrentPage();<EOL>    page.style.color = unsetValue;<EOL>    let btnWithId: buttonModule.Button;<EOL>    let btnWithNoId: buttonModule.Button;<EOL>    <EOL>","gt":"page.css = \"<STR_LIT>\";"}
{"input":"<s> export function test_id_selector() {<EOL>    let page = helper.getClearCurrentPage();<EOL>    page.style.color = unsetValue;<EOL>    let btnWithId: buttonModule.Button;<EOL>    let btnWithNoId: buttonModule.Button;<EOL>    <EOL>    page.css = \"<STR_LIT>\";<EOL>    <EOL>    btnWithId = new buttonModule.Button();<EOL>    btnWithId.id = \"<STR_LIT>\";<EOL>    <EOL>    btnWithNoId = new buttonModule.Button();<EOL>    <EOL>    const stack = new stackModule.StackLayout();<EOL>","gt":"page.content = stack;"}
{"input":"<s> export function test_styles_are_updated_when_cssClass_is_changed() {<EOL>    const testStack = new stackModule.StackLayout();<EOL>    const btn = new buttonModule.Button();<EOL>    btn.className = \"<STR_LIT>\";<EOL>    const btn2 = new buttonModule.Button();<EOL>","gt":"testStack.addChild(btn);"}
{"input":"<s> export function test_styles_are_updated_when_cssClass_is_changed() {<EOL>    const testStack = new stackModule.StackLayout();<EOL>    const btn = new buttonModule.Button();<EOL>    btn.className = \"<STR_LIT>\";<EOL>    const btn2 = new buttonModule.Button();<EOL>    testStack.addChild(btn);<EOL>    testStack.addChild(btn2);<EOL>    const testFunc = () => {<EOL>        helper.assertViewBackgroundColor(btn, \"<STR_LIT>\");<EOL>        helper.assertViewBackgroundColor(btn2, \"<STR_LIT>\");<EOL>        btn.className = \"<STR_LIT>\";<EOL>","gt":"helper.assertViewBackgroundColor(btn, \"<STR_LIT>\");"}
{"input":"<s> export function test_selector_priorities_6() {<EOL>    testSelectorsPrioritiesTemplate(","gt":"idSelector + classSelector + typeSelector);"}
{"input":"<s> export function test_basic_hierarchical_direct_child_selectors() {<EOL>    let stack = new stackModule.StackLayout();<EOL>    let testButton1 = new buttonModule.Button();<EOL>    testButton1.text = \"<STR_LIT>\";<EOL>    testButton1.id = \"<STR_LIT>\";<EOL>    let wrap = new wrapModule.WrapLayout();<EOL>    let testButton2 = new","gt":"buttonModule.Button();"}
{"input":"<s> export function test_basic_hierarchical_direct_child_selectors() {<EOL>    let stack = new stackModule.StackLayout();<EOL>    let testButton1 = new buttonModule.Button();<EOL>    testButton1.text = \"<STR_LIT>\";<EOL>    testButton1.id = \"<STR_LIT>\";<EOL>    let wrap = new wrapModule.WrapLayout();<EOL>    let testButton2 = new buttonModule.Button();<EOL>    testButton2.text = \"<STR_LIT>\";<EOL>    testButton2.id = \"<STR_LIT>\";<EOL>    wrap.addChild(testButton2);<EOL>    stack.addChild(","gt":"testButton1);"}
{"input":"<s> export function test_basic_hierarchical_direct_child_selectors() {<EOL>    let stack = new stackModule.StackLayout();<EOL>    let testButton1 = new buttonModule.Button();<EOL>    testButton1.text = \"<STR_LIT>\";<EOL>    testButton1.id = \"<STR_LIT>\";<EOL>    let wrap = new wrapModule.WrapLayout();<EOL>    let testButton2 = new buttonModule.Button();<EOL>    testButton2.text = \"<STR_LIT>\";<EOL>    testButton2.id = \"<STR_LIT>\";<EOL>    wrap.addChild(testButton2);<EOL>    stack.addChild(testButton1);<EOL>    stack.addChild(wrap);<EOL>    let testCss = \"<STR_LIT>\";<EOL>    let testFunc = function (views: Array<viewModule.View>) {<EOL>        helper.assertViewBackgroundColor(stack.getViewById(\"<STR_LIT>\"),","gt":"\"<STR_LIT>\");"}
{"input":"<s> export function test_pipe_attr_selector_correct_syntax() {<EOL>    let testButton = new buttonModule.Button();<EOL>    testButton[\"<STR_LIT>\"] = \"<STR_LIT>\";<EOL>","gt":"let testCss = \"<STR_LIT>\";"}
{"input":"<s> export function test_pipe_attr_selector_incorrect_syntax1() {<EOL>    let testButton = new buttonModule.Button();<EOL>    testButton[\"<STR_LIT>\"] = \"<STR_LIT>\";<EOL>    let testCss =","gt":"\"<STR_LIT>\";"}
{"input":"<s> export function test_power_attr_selector_correct_synta2() {<EOL>    let testButton = new buttonModule.Button();<EOL>    testButton[\"<STR_LIT>\"] = \"<STR_LIT>\";<EOL>    let","gt":"testCss = \"<STR_LIT>\";"}
{"input":"<s> export function test_dollar_attr_selector_correct_syntax2() {<EOL>    let testButton = new buttonModule.Button();<EOL>    testButton[\"<STR_LIT>\"] = \"<STR_LIT>\";<EOL>    let testCss =","gt":"\"<STR_LIT>\";"}
{"input":"<s> export function test_UsingSameSelectors_ShouldApplyLatest() {<EOL>    let testButton = new buttonModule.Button();<EOL>    testButton.className = '<STR_LIT>';<EOL>","gt":"let testCss = \"<STR_LIT>\";"}
{"input":"<s> export function test_resolveFileNameFromUrl_external_file_no_tilda() {<EOL>    const externalFileExistsMock = (fileName: string) => (fileName.indexOf(\"<STR_LIT>\") !== -<NUM_LIT>);<EOL>    let","gt":"url = \"<STR_LIT>\";"}
{"input":"<s> /**<EOL> * Helper for creating graphSnapshot used by<EOL> * extract or restore function.<EOL> */<EOL>export function createGraphSnapshot(payload: JsonObject, gqlString: string, cacheContext: CacheContext, gqlVariables?: JsonObject, rootId?: NodeId): GraphSnapshot {<EOL>    return createSnapshot(payload, gqlString, gqlVariables, rootId, cacheContext).","gt":"snapshot;"}
{"input":"<s> /**<EOL> * Utility function used to check if an value exists.<EOL> */<EOL>export function isNil(obj: any): boolean {<EOL>    return obj === undefined ||","gt":"obj === null;"}
{"input":"<s> /**<EOL> * Adds the properies of `$key`, `$value`, `$exists` as required by AngularFire2<EOL> */<EOL>export function unwrap(key: string, value: any, exists, priority = null) {<EOL>    let primitive = (/string|number|boolean/).test(typeof value);<EOL>    let unwrapped = isNil(value) || primitive ? {} : value;<EOL>    <EOL>","gt":"if (isNil(value)) {"}
{"input":"<s> /**<EOL> * Adds the properies of `$key`, `$value`, `$exists` as required by AngularFire2<EOL> */<EOL>export function unwrap(key: string, value: any, exists, priority = null) {<EOL>    let primitive = (/string|number|boolean/).test(typeof value);<EOL>    let unwrapped = isNil(value) || primitive ? {} : value;<EOL>    <EOL>    if (isNil(value)) {<EOL>        Object.defineProperty(unwrapped, '<STR_LIT>', {<EOL>            enumerable: false,<EOL>","gt":"value: null"}
{"input":"<s> /**<EOL> * Adds the properies of `$key`, `$value`, `$exists` as required by AngularFire2<EOL> */<EOL>export function unwrap(key: string, value: any, exists, priority = null) {<EOL>    let primitive = (/string|number|boolean/).test(typeof value);<EOL>    let unwrapped = isNil(value) || primitive ? {} : value;<EOL>    <EOL>    if (isNil(value)) {<EOL>        Object.defineProperty(unwrapped, '<STR_LIT>', {<EOL>            enumerable: false,<EOL>            value: null<EOL>        });<EOL>    }<EOL>    let initialValues = { key, value, exists, priority };<EOL>    return ['<STR_LIT>', '<STR_LIT>', '<STR_LIT>',","gt":"'<STR_LIT>'].reduce((p, c) => {"}
{"input":"<s> /**<EOL> * Adds the properies of `$key`, `$value`, `$exists` as required by AngularFire2<EOL> */<EOL>export function unwrap(key: string, value: any, exists, priority = null) {<EOL>    let primitive = (/string|number|boolean/).test(typeof value);<EOL>    let unwrapped = isNil(value) || primitive ? {} : value;<EOL>    <EOL>    if (isNil(value)) {<EOL>        Object.defineProperty(unwrapped, '<STR_LIT>', {<EOL>            enumerable: false,<EOL>            value: null<EOL>        });<EOL>    }<EOL>    let initialValues = { key, value, exists, priority };<EOL>    return ['<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>'].reduce((p, c) => {<EOL>        if ((c === '<STR_LIT>' && !primitive) || isNil(initialValues[c])) {<EOL>            return p;<EOL>        }<EOL>        Object.defineProperty(p, `<STR_LIT>`, {<EOL>","gt":"enumerable: false,"}
{"input":"<s> function drawBoxElement(boxElement: HTMLElement): void {<EOL>    const element =","gt":"document.getElementById('<STR_LIT>');"}
{"input":"<s> export function formatError(message: string, err: any): string {<EOL>    if (err instanceof Error) {<EOL>        let error = <Error>err;<EOL>        return `<STR_LIT>`;<EOL>    }<EOL>    else if (typeof err === '<STR_LIT>') {<EOL>        return `<STR_LIT>`;<EOL>    }<EOL>    else if (err) {<EOL>        return","gt":"}: ${err.toString()}`<STR_LIT>;"}
{"input":"<s> function testUnshiftCommand(lines: string[], languageIdentifier: LanguageIdentifier, useTabStops: boolean, selection: Selection, expectedLines: string[], expectedSelection: Selection): void {<EOL>    testCommand(lines, languageIdentifier, selection, (sel) => new ShiftCommand(sel, {<EOL>        isUnshift:","gt":"true,"}
{"input":"<s> /**<EOL> * Merges two node definitions; mutating `target` to include children from<EOL> * `source`.<EOL> */<EOL>function _mergeNodes<TArgTypes>(path: string[], target: ParsedQueryNode<TArgTypes>, source?: ParsedQueryNode<TArgTypes>) {<EOL>    if (!source)<EOL>        return target;<EOL>    if (!isEqual(target.args, source.args)) {<EOL>        throw new ConflictingFieldsError(`<STR_LIT>`, path, [target, source]);<EOL>    }<EOL>    if (target.schemaName !== source.schemaName) {<EOL>        throw new ConflictingFieldsError(`<STR_LIT>`, path, [","gt":"target, source]);"}
{"input":"<s> /**<EOL> * Merges two node definitions; mutating `target` to include children from<EOL> * `source`.<EOL> */<EOL>function _mergeNodes<TArgTypes>(path: string[], target: ParsedQueryNode<TArgTypes>, source?: ParsedQueryNode<TArgTypes>) {<EOL>    if (!source)<EOL>        return target;<EOL>    if (!isEqual(target.args, source.args)) {<EOL>        throw new ConflictingFieldsError(`<STR_LIT>`, path, [target, source]);<EOL>    }<EOL>    if (target.schemaName !== source.schemaName) {<EOL>        throw new ConflictingFieldsError(`<STR_LIT>`, path, [target, source]);<EOL>    }<EOL>    if (!source.children)<EOL>        return target;<EOL>    if (!target.children) {<EOL>        target.children =","gt":"source.children;"}
{"input":"<s> export function compare(tree1, tree2): Array<any> {<EOL>    const","gt":"patches = [];"}
{"input":"<s> async function testGetBearerToken1() {<EOL>    try {<EOL>        let authorizationclient = new AuthorizationClient(endpoint, httpClient);<EOL>        mockRequest(\"<STR_LIT>\", `<STR_LIT>`);<EOL>        let token1 = await","gt":"authorizationclient.getBearerToken();"}
{"input":"<s> async function testGetBearerToken1() {<EOL>    try {<EOL>        let authorizationclient = new AuthorizationClient(endpoint, httpClient);<EOL>        mockRequest(\"<STR_LIT>\", `<STR_LIT>`);<EOL>        let token1 = await authorizationclient.getBearerToken();<EOL>        let token2 = await authorizationclient.getBearerToken();<EOL>        assert(token1 === \"<STR_LIT>\", \"<STR_LIT>\");<EOL>        assert(token2 === \"<STR_LIT>\", \"<STR_LIT>\");<EOL>    }<EOL>    catch (","gt":"error) {"}
{"input":"<s> function generatePipeName(): string {<EOL>    var randomName = '<STR_LIT>' + makeRandomHexString(<NUM_LIT>);<EOL>    if (process.platform ===","gt":"'<STR_LIT>') {"}
{"input":"<s> function annotate(target: any, options: IDefineOptions = {}): void {<EOL>    if (options.freezeTableName === undefined)<EOL>        options.freezeTableName =","gt":"true;"}
{"input":"<s> export function onElementFound(node, highlights, buffer) {<EOL>    if (node) {<EOL>        buffer.enqueue(MessageFactory.foundDOMElement(node));<EOL>        send(","gt":"MessageFactory.push());"}
{"input":"<s> function ff<T>(g: G<T>): void {<EOL>    ff(","gt":"g);"}
{"input":"<s> /**<EOL> * Returns whether a selection set is considered static from the cache's<EOL> * perspective.<EOL> *<EOL> * This is helpful if you want to assert that certain fragments or queries stay<EOL> * static within the cache (and thus, avoid read-time overhead).<EOL> *<EOL> * If the selectionSet contains fragments, you must provide a getter function<EOL> * that exposes them.<EOL> */<EOL>export function selectionSetIsStatic(selectionSet: SelectionSetNode, fragmentGetter?: (name: string) => SelectionSetNode | undefined): boolean {<EOL>    for (const selection of selectionSet.selections) {<EOL>        if (selection.kind === '<STR_LIT>') {<EOL>            if (!fieldIsStatic(selection))<EOL>                return false;<EOL>","gt":"if (selection.selectionSet && !selectionSetIsStatic(selection.selectionSet, fragmentGetter))"}
{"input":"<s> /**<EOL> * Returns whether a selection set is considered static from the cache's<EOL> * perspective.<EOL> *<EOL> * This is helpful if you want to assert that certain fragments or queries stay<EOL> * static within the cache (and thus, avoid read-time overhead).<EOL> *<EOL> * If the selectionSet contains fragments, you must provide a getter function<EOL> * that exposes them.<EOL> */<EOL>export function selectionSetIsStatic(selectionSet: SelectionSetNode, fragmentGetter?: (name: string) => SelectionSetNode | undefined): boolean {<EOL>    for (const selection of selectionSet.selections) {<EOL>        if (selection.kind === '<STR_LIT>') {<EOL>            if (!fieldIsStatic(selection))<EOL>                return false;<EOL>            if (selection.selectionSet && !selectionSetIsStatic(selection.selectionSet, fragmentGetter))<EOL>                return false;<EOL>        }<EOL>        else if (selection.kind === '<STR_LIT>') {<EOL>","gt":"if (!fragmentGetter) {"}
{"input":"<s> /**<EOL> * Returns whether a selection set is considered static from the cache's<EOL> * perspective.<EOL> *<EOL> * This is helpful if you want to assert that certain fragments or queries stay<EOL> * static within the cache (and thus, avoid read-time overhead).<EOL> *<EOL> * If the selectionSet contains fragments, you must provide a getter function<EOL> * that exposes them.<EOL> */<EOL>export function selectionSetIsStatic(selectionSet: SelectionSetNode, fragmentGetter?: (name: string) => SelectionSetNode | undefined): boolean {<EOL>    for (const selection of selectionSet.selections) {<EOL>        if (selection.kind === '<STR_LIT>') {<EOL>            if (!fieldIsStatic(selection))<EOL>                return false;<EOL>            if (selection.selectionSet && !selectionSetIsStatic(selection.selectionSet, fragmentGetter))<EOL>                return false;<EOL>        }<EOL>        else if (selection.kind === '<STR_LIT>') {<EOL>            if (!fragmentGetter) {<EOL>                throw new Error(`<STR_LIT>`);<EOL>            }<EOL>            const","gt":"fragmentSet = fragmentGetter(selection.name.value);"}
{"input":"<s> /**<EOL> * Returns whether a selection set is considered static from the cache's<EOL> * perspective.<EOL> *<EOL> * This is helpful if you want to assert that certain fragments or queries stay<EOL> * static within the cache (and thus, avoid read-time overhead).<EOL> *<EOL> * If the selectionSet contains fragments, you must provide a getter function<EOL> * that exposes them.<EOL> */<EOL>export function selectionSetIsStatic(selectionSet: SelectionSetNode, fragmentGetter?: (name: string) => SelectionSetNode | undefined): boolean {<EOL>    for (const selection of selectionSet.selections) {<EOL>        if (selection.kind === '<STR_LIT>') {<EOL>            if (!fieldIsStatic(selection))<EOL>                return false;<EOL>            if (selection.selectionSet && !selectionSetIsStatic(selection.selectionSet, fragmentGetter))<EOL>                return false;<EOL>        }<EOL>        else if (selection.kind === '<STR_LIT>') {<EOL>            if (!fragmentGetter) {<EOL>                throw new Error(`<STR_LIT>`);<EOL>            }<EOL>            const fragmentSet = fragmentGetter(selection.name.value);<EOL>            if (!fragmentSet) {<EOL>                throw new Error(`<STR_LIT>`);<EOL>            }<EOL>            if (!selectionSetIsStatic(fragmentSet, fragmentGetter))<EOL>                return false;<EOL>        }<EOL>        else if (selection.kind === '<STR_LIT>') {<EOL>            if (!selectionSetIsStatic(selection.selectionSet, fragmentGetter))<EOL>","gt":"return false;"}
{"input":"<s> /**<EOL> * Walk and run on ParsedQueryNode and the result.<EOL> * This is used to verify result of the read operation.<EOL> */<EOL>export function walkOperation(rootOperation: ParsedQueryWithVariables, result: JsonObject | undefined, visitor: OperationVisitor) {<EOL>    <EOL>    <EOL>    const stack = [new OperationWalkNode(rootOperation,","gt":"result)];"}
{"input":"<s> /**<EOL> * Walk and run on ParsedQueryNode and the result.<EOL> * This is used to verify result of the read operation.<EOL> */<EOL>export function walkOperation(rootOperation: ParsedQueryWithVariables, result: JsonObject | undefined, visitor: OperationVisitor) {<EOL>    <EOL>    <EOL>    const stack = [new OperationWalkNode(rootOperation, result)];<EOL>    while (stack.length) {<EOL>        const { parsedOperation, parent } = stack.pop()!;<EOL>        <EOL>        if (parent === null)<EOL>            continue;<EOL>        <EOL>        if (Array.","gt":"isArray(parent)) {"}
{"input":"<s> /**<EOL> * Walk and run on ParsedQueryNode and the result.<EOL> * This is used to verify result of the read operation.<EOL> */<EOL>export function walkOperation(rootOperation: ParsedQueryWithVariables, result: JsonObject | undefined, visitor: OperationVisitor) {<EOL>    <EOL>    <EOL>    const stack = [new OperationWalkNode(rootOperation, result)];<EOL>    while (stack.length) {<EOL>        const { parsedOperation, parent } = stack.pop()!;<EOL>        <EOL>        if (parent === null)<EOL>            continue;<EOL>        <EOL>        if (Array.isArray(parent)) {<EOL>            <EOL>            for (let i = parent.length - <NUM_LIT>; i >= <NUM_LIT>; i--) {<EOL>                stack.push(","gt":"new OperationWalkNode(parsedOperation, parent[i]));"}
{"input":"<s> /**<EOL> * Walk and run on ParsedQueryNode and the result.<EOL> * This is used to verify result of the read operation.<EOL> */<EOL>export function walkOperation(rootOperation: ParsedQueryWithVariables, result: JsonObject | undefined, visitor: OperationVisitor) {<EOL>    <EOL>    <EOL>    const stack = [new OperationWalkNode(rootOperation, result)];<EOL>    while (stack.length) {<EOL>        const { parsedOperation, parent } = stack.pop()!;<EOL>        <EOL>        if (parent === null)<EOL>            continue;<EOL>        <EOL>        if (Array.isArray(parent)) {<EOL>            <EOL>            for (let i = parent.length - <NUM_LIT>; i >= <NUM_LIT>; i--) {<EOL>                stack.push(new OperationWalkNode(parsedOperation, parent[i]));<EOL>            }<EOL>            continue;<EOL>        }<EOL>","gt":"const fields: string[] = [];"}
{"input":"<s> /**<EOL> * Compares instance with expected values<EOL> */<EOL>export function assertInstance(instance: any | any[], expectedValues: any | any[]): void {<EOL>    if (Array.isArray(expectedValues)) {<EOL>        expect(instance).to.have.property('<STR_LIT>', expectedValues.length);<EOL>        return instance.forEach((_instance, i) => assertInstance(_instance, expectedValues[i]));<EOL>    }<EOL>    expect(instance)<EOL>        .to.have.property('<STR_LIT>')<EOL>        .that.","gt":"is.not.null;"}
{"input":"<s> /**<EOL> * Compares instance with expected values<EOL> */<EOL>export function assertInstance(instance: any | any[], expectedValues: any | any[]): void {<EOL>    if (Array.isArray(expectedValues)) {<EOL>        expect(instance).to.have.property('<STR_LIT>', expectedValues.length);<EOL>        return instance.forEach((_instance, i) => assertInstance(_instance, expectedValues[i]));<EOL>    }<EOL>    expect(instance)<EOL>        .to.have.property('<STR_LIT>')<EOL>        .that.is.not.null;<EOL>    Object<EOL>        .keys(expectedValues)<EOL>        .forEach(key => {<EOL>        const value = instance[key];<EOL>        const expectedValue = expectedValues[","gt":"key];"}
{"input":"<s> /**<EOL> * Compares instance with expected values<EOL> */<EOL>export function assertInstance(instance: any | any[], expectedValues: any | any[]): void {<EOL>    if (Array.isArray(expectedValues)) {<EOL>        expect(instance).to.have.property('<STR_LIT>', expectedValues.length);<EOL>        return instance.forEach((_instance, i) => assertInstance(_instance, expectedValues[i]));<EOL>    }<EOL>    expect(instance)<EOL>        .to.have.property('<STR_LIT>')<EOL>        .that.is.not.null;<EOL>    Object<EOL>        .keys(expectedValues)<EOL>        .forEach(key => {<EOL>        const value = instance[key];<EOL>        const expectedValue = expectedValues[key];<EOL>        expect(instance).to.have.property(key)<EOL>            .that.is.not.null.and.not.undefined;<EOL>        if (typeof expectedValue === '<STR_LIT>') {<EOL>","gt":"assertInstance(value, expectedValue);"}
{"input":"<s> function lineHasDecoration(model: Model, lineNumber: number, start: number, end: number, className: string) {<EOL>    lineHasDecorations(model, lineNumber, [{<EOL>","gt":"start: start,"}
{"input":"<s> function map(operation: Operation, value) {<EOL>    switch (typeof value) {<EOL>","gt":"case '<STR_LIT>':"}
{"input":"<s> function map(operation: Operation, value) {<EOL>    switch (typeof value) {<EOL>        case '<STR_LIT>':<EOL>            return JSON.stringify(value);<EOL>        case '<STR_LIT>':<EOL>","gt":"case '<STR_LIT>':"}
{"input":"<s> function map(operation: Operation, value) {<EOL>    switch (typeof value) {<EOL>        case '<STR_LIT>':<EOL>            return JSON.stringify(value);<EOL>        case '<STR_LIT>':<EOL>        case '<STR_LIT>':<EOL>            return value;<EOL>        case '<STR_LIT>':<EOL>            return '<STR_LIT>';<EOL>        default:<EOL>            if (value ===","gt":"null) {"}
{"input":"<s> function map(operation: Operation, value) {<EOL>    switch (typeof value) {<EOL>        case '<STR_LIT>':<EOL>            return JSON.stringify(value);<EOL>        case '<STR_LIT>':<EOL>        case '<STR_LIT>':<EOL>            return value;<EOL>        case '<STR_LIT>':<EOL>            return '<STR_LIT>';<EOL>        default:<EOL>            if (value === null) {<EOL>                return '<STR_LIT>';<EOL>            }<EOL>            const objectType = Object.prototype.toString.call(value);<EOL>            switch (","gt":"objectType) {"}
{"input":"<s> function map(operation: Operation, value) {<EOL>    switch (typeof value) {<EOL>        case '<STR_LIT>':<EOL>            return JSON.stringify(value);<EOL>        case '<STR_LIT>':<EOL>        case '<STR_LIT>':<EOL>            return value;<EOL>        case '<STR_LIT>':<EOL>            return '<STR_LIT>';<EOL>        default:<EOL>            if (value === null) {<EOL>                return '<STR_LIT>';<EOL>            }<EOL>            const objectType = Object.prototype.toString.call(value);<EOL>            switch (objectType) {<EOL>                case '<STR_LIT>':<EOL>                    return value.toString();<EOL>                case '<STR_LIT>':<EOL>                    return `<STR_LIT>`;<EOL>                default:<EOL>                    if (/Element/.test(objectType)) {<EOL>","gt":"return null;"}
{"input":"<s> function map(operation: Operation, value) {<EOL>    switch (typeof value) {<EOL>        case '<STR_LIT>':<EOL>            return JSON.stringify(value);<EOL>        case '<STR_LIT>':<EOL>        case '<STR_LIT>':<EOL>            return value;<EOL>        case '<STR_LIT>':<EOL>            return '<STR_LIT>';<EOL>        default:<EOL>            if (value === null) {<EOL>                return '<STR_LIT>';<EOL>            }<EOL>            const objectType = Object.prototype.toString.call(value);<EOL>            switch (objectType) {<EOL>                case '<STR_LIT>':<EOL>                    return value.toString();<EOL>                case '<STR_LIT>':<EOL>                    return `<STR_LIT>`;<EOL>                default:<EOL>                    if (/Element/.test(objectType)) {<EOL>                        return null; <EOL>                    }<EOL>                    <EOL>                    <EOL>                    <EOL>                    <EOL>                    <EOL>                    <EOL>                    if (typeof value === '<STR_LIT>') {<EOL>                        return `<STR_LIT>`;<EOL>                    }<EOL>                    let index = operation.visits.","gt":"get(value);"}
{"input":"<s> function map(operation: Operation, value) {<EOL>    switch (typeof value) {<EOL>        case '<STR_LIT>':<EOL>            return JSON.stringify(value);<EOL>        case '<STR_LIT>':<EOL>        case '<STR_LIT>':<EOL>            return value;<EOL>        case '<STR_LIT>':<EOL>            return '<STR_LIT>';<EOL>        default:<EOL>            if (value === null) {<EOL>                return '<STR_LIT>';<EOL>            }<EOL>            const objectType = Object.prototype.toString.call(value);<EOL>            switch (objectType) {<EOL>                case '<STR_LIT>':<EOL>                    return value.toString();<EOL>                case '<STR_LIT>':<EOL>                    return `<STR_LIT>`;<EOL>                default:<EOL>                    if (/Element/.test(objectType)) {<EOL>                        return null; <EOL>                    }<EOL>                    <EOL>                    <EOL>                    <EOL>                    <EOL>                    <EOL>                    <EOL>                    if (typeof value === '<STR_LIT>') {<EOL>                        return `<STR_LIT>`;<EOL>                    }<EOL>                    let index = operation.visits.get(value);<EOL>                    if (index != null) {<EOL>                        return new","gt":"Reference(index);"}
{"input":"<s> function map(operation: Operation, value) {<EOL>    switch (typeof value) {<EOL>        case '<STR_LIT>':<EOL>            return JSON.stringify(value);<EOL>        case '<STR_LIT>':<EOL>        case '<STR_LIT>':<EOL>            return value;<EOL>        case '<STR_LIT>':<EOL>            return '<STR_LIT>';<EOL>        default:<EOL>            if (value === null) {<EOL>                return '<STR_LIT>';<EOL>            }<EOL>            const objectType = Object.prototype.toString.call(value);<EOL>            switch (objectType) {<EOL>                case '<STR_LIT>':<EOL>                    return value.toString();<EOL>                case '<STR_LIT>':<EOL>                    return `<STR_LIT>`;<EOL>                default:<EOL>                    if (/Element/.test(objectType)) {<EOL>                        return null; <EOL>                    }<EOL>                    <EOL>                    <EOL>                    <EOL>                    <EOL>                    <EOL>                    <EOL>                    if (typeof value === '<STR_LIT>') {<EOL>                        return `<STR_LIT>`;<EOL>                    }<EOL>                    let index = operation.visits.get(value);<EOL>                    if (index != null) {<EOL>                        return new Reference(index);<EOL>                    }<EOL>                    else {<EOL>                        index = operation.visits.size;<EOL>                        operation.visits.set(value, index);<EOL>                    }<EOL>                    const mapArray = (collection: Array<any>, array: Array<any>) => {<EOL>                        return","gt":"ref);"}
{"input":"<s> function map(operation: Operation, value) {<EOL>    switch (typeof value) {<EOL>        case '<STR_LIT>':<EOL>            return JSON.stringify(value);<EOL>        case '<STR_LIT>':<EOL>        case '<STR_LIT>':<EOL>            return value;<EOL>        case '<STR_LIT>':<EOL>            return '<STR_LIT>';<EOL>        default:<EOL>            if (value === null) {<EOL>                return '<STR_LIT>';<EOL>            }<EOL>            const objectType = Object.prototype.toString.call(value);<EOL>            switch (objectType) {<EOL>                case '<STR_LIT>':<EOL>                    return value.toString();<EOL>                case '<STR_LIT>':<EOL>                    return `<STR_LIT>`;<EOL>                default:<EOL>                    if (/Element/.test(objectType)) {<EOL>                        return null; <EOL>                    }<EOL>                    <EOL>                    <EOL>                    <EOL>                    <EOL>                    <EOL>                    <EOL>                    if (typeof value === '<STR_LIT>') {<EOL>                        return `<STR_LIT>`;<EOL>                    }<EOL>                    let index = operation.visits.get(value);<EOL>                    if (index != null) {<EOL>                        return new Reference(index);<EOL>                    }<EOL>                    else {<EOL>                        index = operation.visits.size;<EOL>                        operation.visits.set(value, index);<EOL>                    }<EOL>                    const mapArray = (collection: Array<any>, array: Array<any>) => {<EOL>                        return `<STR_LIT>`;<EOL>                    };<EOL>                    switch (objectType) {<EOL>                        case '<STR_LIT>':<EOL>                            operation.tails.push(() => {<EOL>                                operation.objref[index] = mapArray(operation.arrays, value);<EOL>                            });<EOL>                            break;<EOL>                        case '<STR_LIT>':<EOL>                            operation.tails.push(() => {<EOL>                                operation.objref[index] = `<STR_LIT>`;<EOL>                                value.forEach((v, key) => {<EOL>","gt":"const ref = map(operation, v);"}
{"input":"<s> function map(operation: Operation, value) {<EOL>    switch (typeof value) {<EOL>        case '<STR_LIT>':<EOL>            return JSON.stringify(value);<EOL>        case '<STR_LIT>':<EOL>        case '<STR_LIT>':<EOL>            return value;<EOL>        case '<STR_LIT>':<EOL>            return '<STR_LIT>';<EOL>        default:<EOL>            if (value === null) {<EOL>                return '<STR_LIT>';<EOL>            }<EOL>            const objectType = Object.prototype.toString.call(value);<EOL>            switch (objectType) {<EOL>                case '<STR_LIT>':<EOL>                    return value.toString();<EOL>                case '<STR_LIT>':<EOL>                    return `<STR_LIT>`;<EOL>                default:<EOL>                    if (/Element/.test(objectType)) {<EOL>                        return null; <EOL>                    }<EOL>                    <EOL>                    <EOL>                    <EOL>                    <EOL>                    <EOL>                    <EOL>                    if (typeof value === '<STR_LIT>') {<EOL>                        return `<STR_LIT>`;<EOL>                    }<EOL>                    let index = operation.visits.get(value);<EOL>                    if (index != null) {<EOL>                        return new Reference(index);<EOL>                    }<EOL>                    else {<EOL>                        index = operation.visits.size;<EOL>                        operation.visits.set(value, index);<EOL>                    }<EOL>                    const mapArray = (collection: Array<any>, array: Array<any>) => {<EOL>                        return `<STR_LIT>`;<EOL>                    };<EOL>                    switch (objectType) {<EOL>                        case '<STR_LIT>':<EOL>                            operation.tails.push(() => {<EOL>                                operation.objref[index] = mapArray(operation.arrays, value);<EOL>                            });<EOL>                            break;<EOL>                        case '<STR_LIT>':<EOL>                            operation.tails.push(() => {<EOL>                                operation.objref[index] = `<STR_LIT>`;<EOL>                                value.forEach((v, key) => {<EOL>                                    const ref = map(operation, v);<EOL>                                    if (ref instanceof Reference) {<EOL>","gt":"ref.source = index;"}
{"input":"<s> function map(operation: Operation, value) {<EOL>    switch (typeof value) {<EOL>        case '<STR_LIT>':<EOL>            return JSON.stringify(value);<EOL>        case '<STR_LIT>':<EOL>        case '<STR_LIT>':<EOL>            return value;<EOL>        case '<STR_LIT>':<EOL>            return '<STR_LIT>';<EOL>        default:<EOL>            if (value === null) {<EOL>                return '<STR_LIT>';<EOL>            }<EOL>            const objectType = Object.prototype.toString.call(value);<EOL>            switch (objectType) {<EOL>                case '<STR_LIT>':<EOL>                    return value.toString();<EOL>                case '<STR_LIT>':<EOL>                    return `<STR_LIT>`;<EOL>                default:<EOL>                    if (/Element/.test(objectType)) {<EOL>                        return null; <EOL>                    }<EOL>                    <EOL>                    <EOL>                    <EOL>                    <EOL>                    <EOL>                    <EOL>                    if (typeof value === '<STR_LIT>') {<EOL>                        return `<STR_LIT>`;<EOL>                    }<EOL>                    let index = operation.visits.get(value);<EOL>                    if (index != null) {<EOL>                        return new Reference(index);<EOL>                    }<EOL>                    else {<EOL>                        index = operation.visits.size;<EOL>                        operation.visits.set(value, index);<EOL>                    }<EOL>                    const mapArray = (collection: Array<any>, array: Array<any>) => {<EOL>                        return `<STR_LIT>`;<EOL>                    };<EOL>                    switch (objectType) {<EOL>                        case '<STR_LIT>':<EOL>                            operation.tails.push(() => {<EOL>                                operation.objref[index] = mapArray(operation.arrays, value);<EOL>                            });<EOL>                            break;<EOL>                        case '<STR_LIT>':<EOL>                            operation.tails.push(() => {<EOL>                                operation.objref[index] = `<STR_LIT>`;<EOL>                                value.forEach((v, key) => {<EOL>                                    const ref = map(operation, v);<EOL>                                    if (ref instanceof Reference) {<EOL>                                        ref.source = index;<EOL>                                        operation.sets.push(ref);<EOL>                                    }<EOL>                                });<EOL>                            });<EOL>                            break;<EOL>                        case","gt":"'<STR_LIT>':"}
{"input":"<s> function map(operation: Operation, value) {<EOL>    switch (typeof value) {<EOL>        case '<STR_LIT>':<EOL>            return JSON.stringify(value);<EOL>        case '<STR_LIT>':<EOL>        case '<STR_LIT>':<EOL>            return value;<EOL>        case '<STR_LIT>':<EOL>            return '<STR_LIT>';<EOL>        default:<EOL>            if (value === null) {<EOL>                return '<STR_LIT>';<EOL>            }<EOL>            const objectType = Object.prototype.toString.call(value);<EOL>            switch (objectType) {<EOL>                case '<STR_LIT>':<EOL>                    return value.toString();<EOL>                case '<STR_LIT>':<EOL>                    return `<STR_LIT>`;<EOL>                default:<EOL>                    if (/Element/.test(objectType)) {<EOL>                        return null; <EOL>                    }<EOL>                    <EOL>                    <EOL>                    <EOL>                    <EOL>                    <EOL>                    <EOL>                    if (typeof value === '<STR_LIT>') {<EOL>                        return `<STR_LIT>`;<EOL>                    }<EOL>                    let index = operation.visits.get(value);<EOL>                    if (index != null) {<EOL>                        return new Reference(index);<EOL>                    }<EOL>                    else {<EOL>                        index = operation.visits.size;<EOL>                        operation.visits.set(value, index);<EOL>                    }<EOL>                    const mapArray = (collection: Array<any>, array: Array<any>) => {<EOL>                        return `<STR_LIT>`;<EOL>                    };<EOL>                    switch (objectType) {<EOL>                        case '<STR_LIT>':<EOL>                            operation.tails.push(() => {<EOL>                                operation.objref[index] = mapArray(operation.arrays, value);<EOL>                            });<EOL>                            break;<EOL>                        case '<STR_LIT>':<EOL>                            operation.tails.push(() => {<EOL>                                operation.objref[index] = `<STR_LIT>`;<EOL>                                value.forEach((v, key) => {<EOL>                                    const ref = map(operation, v);<EOL>                                    if (ref instanceof Reference) {<EOL>                                        ref.source = index;<EOL>                                        operation.sets.push(ref);<EOL>                                    }<EOL>                                });<EOL>                            });<EOL>                            break;<EOL>                        case '<STR_LIT>':<EOL>                            operation.tails.push(() => {<EOL>                                operation.","gt":"objref[index] = `<STR_LIT>`;"}
{"input":"<s> function map(operation: Operation, value) {<EOL>    switch (typeof value) {<EOL>        case '<STR_LIT>':<EOL>            return JSON.stringify(value);<EOL>        case '<STR_LIT>':<EOL>        case '<STR_LIT>':<EOL>            return value;<EOL>        case '<STR_LIT>':<EOL>            return '<STR_LIT>';<EOL>        default:<EOL>            if (value === null) {<EOL>                return '<STR_LIT>';<EOL>            }<EOL>            const objectType = Object.prototype.toString.call(value);<EOL>            switch (objectType) {<EOL>                case '<STR_LIT>':<EOL>                    return value.toString();<EOL>                case '<STR_LIT>':<EOL>                    return `<STR_LIT>`;<EOL>                default:<EOL>                    if (/Element/.test(objectType)) {<EOL>                        return null; <EOL>                    }<EOL>                    <EOL>                    <EOL>                    <EOL>                    <EOL>                    <EOL>                    <EOL>                    if (typeof value === '<STR_LIT>') {<EOL>                        return `<STR_LIT>`;<EOL>                    }<EOL>                    let index = operation.visits.get(value);<EOL>                    if (index != null) {<EOL>                        return new Reference(index);<EOL>                    }<EOL>                    else {<EOL>                        index = operation.visits.size;<EOL>                        operation.visits.set(value, index);<EOL>                    }<EOL>                    const mapArray = (collection: Array<any>, array: Array<any>) => {<EOL>                        return `<STR_LIT>`;<EOL>                    };<EOL>                    switch (objectType) {<EOL>                        case '<STR_LIT>':<EOL>                            operation.tails.push(() => {<EOL>                                operation.objref[index] = mapArray(operation.arrays, value);<EOL>                            });<EOL>                            break;<EOL>                        case '<STR_LIT>':<EOL>                            operation.tails.push(() => {<EOL>                                operation.objref[index] = `<STR_LIT>`;<EOL>                                value.forEach((v, key) => {<EOL>                                    const ref = map(operation, v);<EOL>                                    if (ref instanceof Reference) {<EOL>                                        ref.source = index;<EOL>                                        operation.sets.push(ref);<EOL>                                    }<EOL>                                });<EOL>                            });<EOL>                            break;<EOL>                        case '<STR_LIT>':<EOL>                            operation.tails.push(() => {<EOL>                                operation.objref[index] = `<STR_LIT>`;<EOL>                                value.forEach((v, key) => {<EOL>                                    let ref = map(operation, v);<EOL>                                    const keyRef = map(operation, key);<EOL>                                    if (ref instanceof Reference === false) {<EOL>                                        ref = new Reference(null, ref);<EOL>                                    }<EOL>                                    ref.source = index;<EOL>                                    ref.key = ref instanceof Reference ? keyRef : key;<EOL>                                    operation.maps.push(ref);<EOL>                                });<EOL>                            });<EOL>","gt":"break;"}
{"input":"<s> function map(operation: Operation, value) {<EOL>    switch (typeof value) {<EOL>        case '<STR_LIT>':<EOL>            return JSON.stringify(value);<EOL>        case '<STR_LIT>':<EOL>        case '<STR_LIT>':<EOL>            return value;<EOL>        case '<STR_LIT>':<EOL>            return '<STR_LIT>';<EOL>        default:<EOL>            if (value === null) {<EOL>                return '<STR_LIT>';<EOL>            }<EOL>            const objectType = Object.prototype.toString.call(value);<EOL>            switch (objectType) {<EOL>                case '<STR_LIT>':<EOL>                    return value.toString();<EOL>                case '<STR_LIT>':<EOL>                    return `<STR_LIT>`;<EOL>                default:<EOL>                    if (/Element/.test(objectType)) {<EOL>                        return null; <EOL>                    }<EOL>                    <EOL>                    <EOL>                    <EOL>                    <EOL>                    <EOL>                    <EOL>                    if (typeof value === '<STR_LIT>') {<EOL>                        return `<STR_LIT>`;<EOL>                    }<EOL>                    let index = operation.visits.get(value);<EOL>                    if (index != null) {<EOL>                        return new Reference(index);<EOL>                    }<EOL>                    else {<EOL>                        index = operation.visits.size;<EOL>                        operation.visits.set(value, index);<EOL>                    }<EOL>                    const mapArray = (collection: Array<any>, array: Array<any>) => {<EOL>                        return `<STR_LIT>`;<EOL>                    };<EOL>                    switch (objectType) {<EOL>                        case '<STR_LIT>':<EOL>                            operation.tails.push(() => {<EOL>                                operation.objref[index] = mapArray(operation.arrays, value);<EOL>                            });<EOL>                            break;<EOL>                        case '<STR_LIT>':<EOL>                            operation.tails.push(() => {<EOL>                                operation.objref[index] = `<STR_LIT>`;<EOL>                                value.forEach((v, key) => {<EOL>                                    const ref = map(operation, v);<EOL>                                    if (ref instanceof Reference) {<EOL>                                        ref.source = index;<EOL>                                        operation.sets.push(ref);<EOL>                                    }<EOL>                                });<EOL>                            });<EOL>                            break;<EOL>                        case '<STR_LIT>':<EOL>                            operation.tails.push(() => {<EOL>                                operation.objref[index] = `<STR_LIT>`;<EOL>                                value.forEach((v, key) => {<EOL>                                    let ref = map(operation, v);<EOL>                                    const keyRef = map(operation, key);<EOL>                                    if (ref instanceof Reference === false) {<EOL>                                        ref = new Reference(null, ref);<EOL>                                    }<EOL>                                    ref.source = index;<EOL>                                    ref.key = ref instanceof Reference ? keyRef : key;<EOL>                                    operation.maps.push(ref);<EOL>                                });<EOL>                            });<EOL>                            break;<EOL>                        default:<EOL>                            operation.tails.push(() => {<EOL>                                const","gt":"constructor = value && value.constructor ?"}
{"input":"<s> function map(operation: Operation, value) {<EOL>    switch (typeof value) {<EOL>        case '<STR_LIT>':<EOL>            return JSON.stringify(value);<EOL>        case '<STR_LIT>':<EOL>        case '<STR_LIT>':<EOL>            return value;<EOL>        case '<STR_LIT>':<EOL>            return '<STR_LIT>';<EOL>        default:<EOL>            if (value === null) {<EOL>                return '<STR_LIT>';<EOL>            }<EOL>            const objectType = Object.prototype.toString.call(value);<EOL>            switch (objectType) {<EOL>                case '<STR_LIT>':<EOL>                    return value.toString();<EOL>                case '<STR_LIT>':<EOL>                    return `<STR_LIT>`;<EOL>                default:<EOL>                    if (/Element/.test(objectType)) {<EOL>                        return null; <EOL>                    }<EOL>                    <EOL>                    <EOL>                    <EOL>                    <EOL>                    <EOL>                    <EOL>                    if (typeof value === '<STR_LIT>') {<EOL>                        return `<STR_LIT>`;<EOL>                    }<EOL>                    let index = operation.visits.get(value);<EOL>                    if (index != null) {<EOL>                        return new Reference(index);<EOL>                    }<EOL>                    else {<EOL>                        index = operation.visits.size;<EOL>                        operation.visits.set(value, index);<EOL>                    }<EOL>                    const mapArray = (collection: Array<any>, array: Array<any>) => {<EOL>                        return `<STR_LIT>`;<EOL>                    };<EOL>                    switch (objectType) {<EOL>                        case '<STR_LIT>':<EOL>                            operation.tails.push(() => {<EOL>                                operation.objref[index] = mapArray(operation.arrays, value);<EOL>                            });<EOL>                            break;<EOL>                        case '<STR_LIT>':<EOL>                            operation.tails.push(() => {<EOL>                                operation.objref[index] = `<STR_LIT>`;<EOL>                                value.forEach((v, key) => {<EOL>                                    const ref = map(operation, v);<EOL>                                    if (ref instanceof Reference) {<EOL>                                        ref.source = index;<EOL>                                        operation.sets.push(ref);<EOL>                                    }<EOL>                                });<EOL>                            });<EOL>                            break;<EOL>                        case '<STR_LIT>':<EOL>                            operation.tails.push(() => {<EOL>                                operation.objref[index] = `<STR_LIT>`;<EOL>                                value.forEach((v, key) => {<EOL>                                    let ref = map(operation, v);<EOL>                                    const keyRef = map(operation, key);<EOL>                                    if (ref instanceof Reference === false) {<EOL>                                        ref = new Reference(null, ref);<EOL>                                    }<EOL>                                    ref.source = index;<EOL>                                    ref.key = ref instanceof Reference ? keyRef : key;<EOL>                                    operation.maps.push(ref);<EOL>                                });<EOL>                            });<EOL>                            break;<EOL>                        default:<EOL>                            operation.tails.push(() => {<EOL>                                const constructor = value && value.constructor ?<EOL>                                    value.constructor : ({}).constructor;<EOL>                                const ctor = functionName(constructor) || '<STR_LIT>';<EOL>                                const mapProps = (key: string) => {<EOL>                                    const mapped = map(operation, value[key]);<EOL>                                    if (mapped instanceof Reference) {<EOL>                                        mapped.","gt":"source = index;"}
{"input":"<s> function map(operation: Operation, value) {<EOL>    switch (typeof value) {<EOL>        case '<STR_LIT>':<EOL>            return JSON.stringify(value);<EOL>        case '<STR_LIT>':<EOL>        case '<STR_LIT>':<EOL>            return value;<EOL>        case '<STR_LIT>':<EOL>            return '<STR_LIT>';<EOL>        default:<EOL>            if (value === null) {<EOL>                return '<STR_LIT>';<EOL>            }<EOL>            const objectType = Object.prototype.toString.call(value);<EOL>            switch (objectType) {<EOL>                case '<STR_LIT>':<EOL>                    return value.toString();<EOL>                case '<STR_LIT>':<EOL>                    return `<STR_LIT>`;<EOL>                default:<EOL>                    if (/Element/.test(objectType)) {<EOL>                        return null; <EOL>                    }<EOL>                    <EOL>                    <EOL>                    <EOL>                    <EOL>                    <EOL>                    <EOL>                    if (typeof value === '<STR_LIT>') {<EOL>                        return `<STR_LIT>`;<EOL>                    }<EOL>                    let index = operation.visits.get(value);<EOL>                    if (index != null) {<EOL>                        return new Reference(index);<EOL>                    }<EOL>                    else {<EOL>                        index = operation.visits.size;<EOL>                        operation.visits.set(value, index);<EOL>                    }<EOL>                    const mapArray = (collection: Array<any>, array: Array<any>) => {<EOL>                        return `<STR_LIT>`;<EOL>                    };<EOL>                    switch (objectType) {<EOL>                        case '<STR_LIT>':<EOL>                            operation.tails.push(() => {<EOL>                                operation.objref[index] = mapArray(operation.arrays, value);<EOL>                            });<EOL>                            break;<EOL>                        case '<STR_LIT>':<EOL>                            operation.tails.push(() => {<EOL>                                operation.objref[index] = `<STR_LIT>`;<EOL>                                value.forEach((v, key) => {<EOL>                                    const ref = map(operation, v);<EOL>                                    if (ref instanceof Reference) {<EOL>                                        ref.source = index;<EOL>                                        operation.sets.push(ref);<EOL>                                    }<EOL>                                });<EOL>                            });<EOL>                            break;<EOL>                        case '<STR_LIT>':<EOL>                            operation.tails.push(() => {<EOL>                                operation.objref[index] = `<STR_LIT>`;<EOL>                                value.forEach((v, key) => {<EOL>                                    let ref = map(operation, v);<EOL>                                    const keyRef = map(operation, key);<EOL>                                    if (ref instanceof Reference === false) {<EOL>                                        ref = new Reference(null, ref);<EOL>                                    }<EOL>                                    ref.source = index;<EOL>                                    ref.key = ref instanceof Reference ? keyRef : key;<EOL>                                    operation.maps.push(ref);<EOL>                                });<EOL>                            });<EOL>                            break;<EOL>                        default:<EOL>                            operation.tails.push(() => {<EOL>                                const constructor = value && value.constructor ?<EOL>                                    value.constructor : ({}).constructor;<EOL>                                const ctor = functionName(constructor) || '<STR_LIT>';<EOL>                                const mapProps = (key: string) => {<EOL>                                    const mapped = map(operation, value[key]);<EOL>                                    if (mapped instanceof Reference) {<EOL>                                        mapped.source = index;<EOL>                                        mapped.key = key;<EOL>","gt":"operation.hashes.push(mapped);"}
{"input":"<s> function map(operation: Operation, value) {<EOL>    switch (typeof value) {<EOL>        case '<STR_LIT>':<EOL>            return JSON.stringify(value);<EOL>        case '<STR_LIT>':<EOL>        case '<STR_LIT>':<EOL>            return value;<EOL>        case '<STR_LIT>':<EOL>            return '<STR_LIT>';<EOL>        default:<EOL>            if (value === null) {<EOL>                return '<STR_LIT>';<EOL>            }<EOL>            const objectType = Object.prototype.toString.call(value);<EOL>            switch (objectType) {<EOL>                case '<STR_LIT>':<EOL>                    return value.toString();<EOL>                case '<STR_LIT>':<EOL>                    return `<STR_LIT>`;<EOL>                default:<EOL>                    if (/Element/.test(objectType)) {<EOL>                        return null; <EOL>                    }<EOL>                    <EOL>                    <EOL>                    <EOL>                    <EOL>                    <EOL>                    <EOL>                    if (typeof value === '<STR_LIT>') {<EOL>                        return `<STR_LIT>`;<EOL>                    }<EOL>                    let index = operation.visits.get(value);<EOL>                    if (index != null) {<EOL>                        return new Reference(index);<EOL>                    }<EOL>                    else {<EOL>                        index = operation.visits.size;<EOL>                        operation.visits.set(value, index);<EOL>                    }<EOL>                    const mapArray = (collection: Array<any>, array: Array<any>) => {<EOL>                        return `<STR_LIT>`;<EOL>                    };<EOL>                    switch (objectType) {<EOL>                        case '<STR_LIT>':<EOL>                            operation.tails.push(() => {<EOL>                                operation.objref[index] = mapArray(operation.arrays, value);<EOL>                            });<EOL>                            break;<EOL>                        case '<STR_LIT>':<EOL>                            operation.tails.push(() => {<EOL>                                operation.objref[index] = `<STR_LIT>`;<EOL>                                value.forEach((v, key) => {<EOL>                                    const ref = map(operation, v);<EOL>                                    if (ref instanceof Reference) {<EOL>                                        ref.source = index;<EOL>                                        operation.sets.push(ref);<EOL>                                    }<EOL>                                });<EOL>                            });<EOL>                            break;<EOL>                        case '<STR_LIT>':<EOL>                            operation.tails.push(() => {<EOL>                                operation.objref[index] = `<STR_LIT>`;<EOL>                                value.forEach((v, key) => {<EOL>                                    let ref = map(operation, v);<EOL>                                    const keyRef = map(operation, key);<EOL>                                    if (ref instanceof Reference === false) {<EOL>                                        ref = new Reference(null, ref);<EOL>                                    }<EOL>                                    ref.source = index;<EOL>                                    ref.key = ref instanceof Reference ? keyRef : key;<EOL>                                    operation.maps.push(ref);<EOL>                                });<EOL>                            });<EOL>                            break;<EOL>                        default:<EOL>                            operation.tails.push(() => {<EOL>                                const constructor = value && value.constructor ?<EOL>                                    value.constructor : ({}).constructor;<EOL>                                const ctor = functionName(constructor) || '<STR_LIT>';<EOL>                                const mapProps = (key: string) => {<EOL>                                    const mapped = map(operation, value[key]);<EOL>                                    if (mapped instanceof Reference) {<EOL>                                        mapped.source = index;<EOL>                                        mapped.key = key;<EOL>                                        operation.hashes.push(mapped);<EOL>                                        return mapped;<EOL>                                    }<EOL>                                    return","gt":"mapped}`<STR_LIT>;"}
{"input":"<s> function map(operation: Operation, value) {<EOL>    switch (typeof value) {<EOL>        case '<STR_LIT>':<EOL>            return JSON.stringify(value);<EOL>        case '<STR_LIT>':<EOL>        case '<STR_LIT>':<EOL>            return value;<EOL>        case '<STR_LIT>':<EOL>            return '<STR_LIT>';<EOL>        default:<EOL>            if (value === null) {<EOL>                return '<STR_LIT>';<EOL>            }<EOL>            const objectType = Object.prototype.toString.call(value);<EOL>            switch (objectType) {<EOL>                case '<STR_LIT>':<EOL>                    return value.toString();<EOL>                case '<STR_LIT>':<EOL>                    return `<STR_LIT>`;<EOL>                default:<EOL>                    if (/Element/.test(objectType)) {<EOL>                        return null; <EOL>                    }<EOL>                    <EOL>                    <EOL>                    <EOL>                    <EOL>                    <EOL>                    <EOL>                    if (typeof value === '<STR_LIT>') {<EOL>                        return `<STR_LIT>`;<EOL>                    }<EOL>                    let index = operation.visits.get(value);<EOL>                    if (index != null) {<EOL>                        return new Reference(index);<EOL>                    }<EOL>                    else {<EOL>                        index = operation.visits.size;<EOL>                        operation.visits.set(value, index);<EOL>                    }<EOL>                    const mapArray = (collection: Array<any>, array: Array<any>) => {<EOL>                        return `<STR_LIT>`;<EOL>                    };<EOL>                    switch (objectType) {<EOL>                        case '<STR_LIT>':<EOL>                            operation.tails.push(() => {<EOL>                                operation.objref[index] = mapArray(operation.arrays, value);<EOL>                            });<EOL>                            break;<EOL>                        case '<STR_LIT>':<EOL>                            operation.tails.push(() => {<EOL>                                operation.objref[index] = `<STR_LIT>`;<EOL>                                value.forEach((v, key) => {<EOL>                                    const ref = map(operation, v);<EOL>                                    if (ref instanceof Reference) {<EOL>                                        ref.source = index;<EOL>                                        operation.sets.push(ref);<EOL>                                    }<EOL>                                });<EOL>                            });<EOL>                            break;<EOL>                        case '<STR_LIT>':<EOL>                            operation.tails.push(() => {<EOL>                                operation.objref[index] = `<STR_LIT>`;<EOL>                                value.forEach((v, key) => {<EOL>                                    let ref = map(operation, v);<EOL>                                    const keyRef = map(operation, key);<EOL>                                    if (ref instanceof Reference === false) {<EOL>                                        ref = new Reference(null, ref);<EOL>                                    }<EOL>                                    ref.source = index;<EOL>                                    ref.key = ref instanceof Reference ? keyRef : key;<EOL>                                    operation.maps.push(ref);<EOL>                                });<EOL>                            });<EOL>                            break;<EOL>                        default:<EOL>                            operation.tails.push(() => {<EOL>                                const constructor = value && value.constructor ?<EOL>                                    value.constructor : ({}).constructor;<EOL>                                const ctor = functionName(constructor) || '<STR_LIT>';<EOL>                                const mapProps = (key: string) => {<EOL>                                    const mapped = map(operation, value[key]);<EOL>                                    if (mapped instanceof Reference) {<EOL>                                        mapped.source = index;<EOL>                                        mapped.key = key;<EOL>                                        operation.hashes.push(mapped);<EOL>                                        return mapped;<EOL>                                    }<EOL>                                    return `<STR_LIT>`;<EOL>                                };<EOL>","gt":"const keys = Object.keys(value)"}
{"input":"<s> function map(operation: Operation, value) {<EOL>    switch (typeof value) {<EOL>        case '<STR_LIT>':<EOL>            return JSON.stringify(value);<EOL>        case '<STR_LIT>':<EOL>        case '<STR_LIT>':<EOL>            return value;<EOL>        case '<STR_LIT>':<EOL>            return '<STR_LIT>';<EOL>        default:<EOL>            if (value === null) {<EOL>                return '<STR_LIT>';<EOL>            }<EOL>            const objectType = Object.prototype.toString.call(value);<EOL>            switch (objectType) {<EOL>                case '<STR_LIT>':<EOL>                    return value.toString();<EOL>                case '<STR_LIT>':<EOL>                    return `<STR_LIT>`;<EOL>                default:<EOL>                    if (/Element/.test(objectType)) {<EOL>                        return null; <EOL>                    }<EOL>                    <EOL>                    <EOL>                    <EOL>                    <EOL>                    <EOL>                    <EOL>                    if (typeof value === '<STR_LIT>') {<EOL>                        return `<STR_LIT>`;<EOL>                    }<EOL>                    let index = operation.visits.get(value);<EOL>                    if (index != null) {<EOL>                        return new Reference(index);<EOL>                    }<EOL>                    else {<EOL>                        index = operation.visits.size;<EOL>                        operation.visits.set(value, index);<EOL>                    }<EOL>                    const mapArray = (collection: Array<any>, array: Array<any>) => {<EOL>                        return `<STR_LIT>`;<EOL>                    };<EOL>                    switch (objectType) {<EOL>                        case '<STR_LIT>':<EOL>                            operation.tails.push(() => {<EOL>                                operation.objref[index] = mapArray(operation.arrays, value);<EOL>                            });<EOL>                            break;<EOL>                        case '<STR_LIT>':<EOL>                            operation.tails.push(() => {<EOL>                                operation.objref[index] = `<STR_LIT>`;<EOL>                                value.forEach((v, key) => {<EOL>                                    const ref = map(operation, v);<EOL>                                    if (ref instanceof Reference) {<EOL>                                        ref.source = index;<EOL>                                        operation.sets.push(ref);<EOL>                                    }<EOL>                                });<EOL>                            });<EOL>                            break;<EOL>                        case '<STR_LIT>':<EOL>                            operation.tails.push(() => {<EOL>                                operation.objref[index] = `<STR_LIT>`;<EOL>                                value.forEach((v, key) => {<EOL>                                    let ref = map(operation, v);<EOL>                                    const keyRef = map(operation, key);<EOL>                                    if (ref instanceof Reference === false) {<EOL>                                        ref = new Reference(null, ref);<EOL>                                    }<EOL>                                    ref.source = index;<EOL>                                    ref.key = ref instanceof Reference ? keyRef : key;<EOL>                                    operation.maps.push(ref);<EOL>                                });<EOL>                            });<EOL>                            break;<EOL>                        default:<EOL>                            operation.tails.push(() => {<EOL>                                const constructor = value && value.constructor ?<EOL>                                    value.constructor : ({}).constructor;<EOL>                                const ctor = functionName(constructor) || '<STR_LIT>';<EOL>                                const mapProps = (key: string) => {<EOL>                                    const mapped = map(operation, value[key]);<EOL>                                    if (mapped instanceof Reference) {<EOL>                                        mapped.source = index;<EOL>                                        mapped.key = key;<EOL>                                        operation.hashes.push(mapped);<EOL>                                        return mapped;<EOL>                                    }<EOL>                                    return `<STR_LIT>`;<EOL>                                };<EOL>                                const keys = Object.keys(value)<EOL>                                    .","gt":"map(key => mapProps(key))"}
{"input":"<s> function map(operation: Operation, value) {<EOL>    switch (typeof value) {<EOL>        case '<STR_LIT>':<EOL>            return JSON.stringify(value);<EOL>        case '<STR_LIT>':<EOL>        case '<STR_LIT>':<EOL>            return value;<EOL>        case '<STR_LIT>':<EOL>            return '<STR_LIT>';<EOL>        default:<EOL>            if (value === null) {<EOL>                return '<STR_LIT>';<EOL>            }<EOL>            const objectType = Object.prototype.toString.call(value);<EOL>            switch (objectType) {<EOL>                case '<STR_LIT>':<EOL>                    return value.toString();<EOL>                case '<STR_LIT>':<EOL>                    return `<STR_LIT>`;<EOL>                default:<EOL>                    if (/Element/.test(objectType)) {<EOL>                        return null; <EOL>                    }<EOL>                    <EOL>                    <EOL>                    <EOL>                    <EOL>                    <EOL>                    <EOL>                    if (typeof value === '<STR_LIT>') {<EOL>                        return `<STR_LIT>`;<EOL>                    }<EOL>                    let index = operation.visits.get(value);<EOL>                    if (index != null) {<EOL>                        return new Reference(index);<EOL>                    }<EOL>                    else {<EOL>                        index = operation.visits.size;<EOL>                        operation.visits.set(value, index);<EOL>                    }<EOL>                    const mapArray = (collection: Array<any>, array: Array<any>) => {<EOL>                        return `<STR_LIT>`;<EOL>                    };<EOL>                    switch (objectType) {<EOL>                        case '<STR_LIT>':<EOL>                            operation.tails.push(() => {<EOL>                                operation.objref[index] = mapArray(operation.arrays, value);<EOL>                            });<EOL>                            break;<EOL>                        case '<STR_LIT>':<EOL>                            operation.tails.push(() => {<EOL>                                operation.objref[index] = `<STR_LIT>`;<EOL>                                value.forEach((v, key) => {<EOL>                                    const ref = map(operation, v);<EOL>                                    if (ref instanceof Reference) {<EOL>                                        ref.source = index;<EOL>                                        operation.sets.push(ref);<EOL>                                    }<EOL>                                });<EOL>                            });<EOL>                            break;<EOL>                        case '<STR_LIT>':<EOL>                            operation.tails.push(() => {<EOL>                                operation.objref[index] = `<STR_LIT>`;<EOL>                                value.forEach((v, key) => {<EOL>                                    let ref = map(operation, v);<EOL>                                    const keyRef = map(operation, key);<EOL>                                    if (ref instanceof Reference === false) {<EOL>                                        ref = new Reference(null, ref);<EOL>                                    }<EOL>                                    ref.source = index;<EOL>                                    ref.key = ref instanceof Reference ? keyRef : key;<EOL>                                    operation.maps.push(ref);<EOL>                                });<EOL>                            });<EOL>                            break;<EOL>                        default:<EOL>                            operation.tails.push(() => {<EOL>                                const constructor = value && value.constructor ?<EOL>                                    value.constructor : ({}).constructor;<EOL>                                const ctor = functionName(constructor) || '<STR_LIT>';<EOL>                                const mapProps = (key: string) => {<EOL>                                    const mapped = map(operation, value[key]);<EOL>                                    if (mapped instanceof Reference) {<EOL>                                        mapped.source = index;<EOL>                                        mapped.key = key;<EOL>                                        operation.hashes.push(mapped);<EOL>                                        return mapped;<EOL>                                    }<EOL>                                    return `<STR_LIT>`;<EOL>                                };<EOL>                                const keys = Object.keys(value)<EOL>                                    .map(key => mapProps(key))<EOL>                                    .filter(v => v instanceof Reference ===","gt":"false).join('<STR_LIT>');"}
{"input":"<s> function featureize(dirs: string[]) {<EOL>    libroots = JSON.parse(fs.readFileSync(\"<STR_LIT>\", \"<STR_LIT>\"));<EOL>    Object.keys(libroots).forEach(k => {<EOL>        var m = /^([^:]*):([^:]*)/.exec(libroots[","gt":"k]);"}
{"input":"<s> function featureize(dirs: string[]) {<EOL>    libroots = JSON.parse(fs.readFileSync(\"<STR_LIT>\", \"<STR_LIT>\"));<EOL>    Object.keys(libroots).forEach(k => {<EOL>        var m = /^([^:]*):([^:]*)/.exec(libroots[k]);<EOL>        if (m) {<EOL>            libroots[k] =","gt":"m[<NUM_LIT>] + \"<STR_LIT>\" + m[<NUM_LIT>];"}
{"input":"<s> function featureize(dirs: string[]) {<EOL>    libroots = JSON.parse(fs.readFileSync(\"<STR_LIT>\", \"<STR_LIT>\"));<EOL>    Object.keys(libroots).forEach(k => {<EOL>        var m = /^([^:]*):([^:]*)/.exec(libroots[k]);<EOL>        if (m) {<EOL>            libroots[k] = m[<NUM_LIT>] + \"<STR_LIT>\" + m[<NUM_LIT>];<EOL>        }<EOL>    });<EOL>","gt":"console.log(\"<STR_LIT>\" + dirs.join(\"<STR_LIT>\"));"}
{"input":"<s> function featureize(dirs: string[]) {<EOL>    libroots = JSON.parse(fs.readFileSync(\"<STR_LIT>\", \"<STR_LIT>\"));<EOL>    Object.keys(libroots).forEach(k => {<EOL>        var m = /^([^:]*):([^:]*)/.exec(libroots[k]);<EOL>        if (m) {<EOL>            libroots[k] = m[<NUM_LIT>] + \"<STR_LIT>\" + m[<NUM_LIT>];<EOL>        }<EOL>    });<EOL>    console.log(\"<STR_LIT>\" + dirs.join(\"<STR_LIT>\"));<EOL>    dirs.forEach(uu => {<EOL>        var userEntry = {<EOL>            uid: \"<STR_LIT>\",<EOL>","gt":"slots: [],"}
{"input":"<s> function featureize(dirs: string[]) {<EOL>    libroots = JSON.parse(fs.readFileSync(\"<STR_LIT>\", \"<STR_LIT>\"));<EOL>    Object.keys(libroots).forEach(k => {<EOL>        var m = /^([^:]*):([^:]*)/.exec(libroots[k]);<EOL>        if (m) {<EOL>            libroots[k] = m[<NUM_LIT>] + \"<STR_LIT>\" + m[<NUM_LIT>];<EOL>        }<EOL>    });<EOL>    console.log(\"<STR_LIT>\" + dirs.join(\"<STR_LIT>\"));<EOL>    dirs.forEach(uu => {<EOL>        var userEntry = {<EOL>            uid: \"<STR_LIT>\",<EOL>            slots: [],<EOL>        };<EOL>        var existing: any = {};<EOL>        var m = /([^\\/]+)$/.exec(uu);<EOL>        userEntry.uid = m[<NUM_LIT>];<EOL>        var jsonName = \"<STR_LIT>\" + userEntry.uid + \"<STR_LIT>\";<EOL>        if (fs.existsSync(jsonName)) {<EOL>            userEntry = JSON.","gt":"parse(fs.readFileSync(jsonName, \"<STR_LIT>\"));"}
{"input":"<s> function featureize(dirs: string[]) {<EOL>    libroots = JSON.parse(fs.readFileSync(\"<STR_LIT>\", \"<STR_LIT>\"));<EOL>    Object.keys(libroots).forEach(k => {<EOL>        var m = /^([^:]*):([^:]*)/.exec(libroots[k]);<EOL>        if (m) {<EOL>            libroots[k] = m[<NUM_LIT>] + \"<STR_LIT>\" + m[<NUM_LIT>];<EOL>        }<EOL>    });<EOL>    console.log(\"<STR_LIT>\" + dirs.join(\"<STR_LIT>\"));<EOL>    dirs.forEach(uu => {<EOL>        var userEntry = {<EOL>            uid: \"<STR_LIT>\",<EOL>            slots: [],<EOL>        };<EOL>        var existing: any = {};<EOL>        var m = /([^\\/]+)$/.exec(uu);<EOL>        userEntry.uid = m[<NUM_LIT>];<EOL>        var jsonName = \"<STR_LIT>\" + userEntry.uid + \"<STR_LIT>\";<EOL>        if (fs.existsSync(jsonName)) {<EOL>            userEntry = JSON.parse(fs.readFileSync(jsonName, \"<STR_LIT>\"));<EOL>            existing = {};<EOL>            userEntry.slots.forEach(s => existing[s.guid] = <NUM_LIT>);<EOL>        }<EOL>        fs.readdirSync(uu).forEach(fn => {<EOL>            var m = /([^\\/]+)\\.json$/.exec(fn);<EOL>","gt":"if (!m)"}
{"input":"<s> function featureize(dirs: string[]) {<EOL>    libroots = JSON.parse(fs.readFileSync(\"<STR_LIT>\", \"<STR_LIT>\"));<EOL>    Object.keys(libroots).forEach(k => {<EOL>        var m = /^([^:]*):([^:]*)/.exec(libroots[k]);<EOL>        if (m) {<EOL>            libroots[k] = m[<NUM_LIT>] + \"<STR_LIT>\" + m[<NUM_LIT>];<EOL>        }<EOL>    });<EOL>    console.log(\"<STR_LIT>\" + dirs.join(\"<STR_LIT>\"));<EOL>    dirs.forEach(uu => {<EOL>        var userEntry = {<EOL>            uid: \"<STR_LIT>\",<EOL>            slots: [],<EOL>        };<EOL>        var existing: any = {};<EOL>        var m = /([^\\/]+)$/.exec(uu);<EOL>        userEntry.uid = m[<NUM_LIT>];<EOL>        var jsonName = \"<STR_LIT>\" + userEntry.uid + \"<STR_LIT>\";<EOL>        if (fs.existsSync(jsonName)) {<EOL>            userEntry = JSON.parse(fs.readFileSync(jsonName, \"<STR_LIT>\"));<EOL>            existing = {};<EOL>            userEntry.slots.forEach(s => existing[s.guid] = <NUM_LIT>);<EOL>        }<EOL>        fs.readdirSync(uu).forEach(fn => {<EOL>            var m = /([^\\/]+)\\.json$/.exec(fn);<EOL>            if (!m)<EOL>                return;<EOL>            if (existing.hasOwnProperty(m[<NUM_LIT>]))<EOL>                return;<EOL>            <EOL>            var data = JSON.parse(fs.readFileSync(uu + \"<STR_LIT>\" + fn, \"<STR_LIT>\"));<EOL>            var slotEntry = {<EOL>                guid: data.","gt":"guid,"}
{"input":"<s> function featureize(dirs: string[]) {<EOL>    libroots = JSON.parse(fs.readFileSync(\"<STR_LIT>\", \"<STR_LIT>\"));<EOL>    Object.keys(libroots).forEach(k => {<EOL>        var m = /^([^:]*):([^:]*)/.exec(libroots[k]);<EOL>        if (m) {<EOL>            libroots[k] = m[<NUM_LIT>] + \"<STR_LIT>\" + m[<NUM_LIT>];<EOL>        }<EOL>    });<EOL>    console.log(\"<STR_LIT>\" + dirs.join(\"<STR_LIT>\"));<EOL>    dirs.forEach(uu => {<EOL>        var userEntry = {<EOL>            uid: \"<STR_LIT>\",<EOL>            slots: [],<EOL>        };<EOL>        var existing: any = {};<EOL>        var m = /([^\\/]+)$/.exec(uu);<EOL>        userEntry.uid = m[<NUM_LIT>];<EOL>        var jsonName = \"<STR_LIT>\" + userEntry.uid + \"<STR_LIT>\";<EOL>        if (fs.existsSync(jsonName)) {<EOL>            userEntry = JSON.parse(fs.readFileSync(jsonName, \"<STR_LIT>\"));<EOL>            existing = {};<EOL>            userEntry.slots.forEach(s => existing[s.guid] = <NUM_LIT>);<EOL>        }<EOL>        fs.readdirSync(uu).forEach(fn => {<EOL>            var m = /([^\\/]+)\\.json$/.exec(fn);<EOL>            if (!m)<EOL>                return;<EOL>            if (existing.hasOwnProperty(m[<NUM_LIT>]))<EOL>                return;<EOL>            <EOL>            var data = JSON.parse(fs.readFileSync(uu + \"<STR_LIT>\" + fn, \"<STR_LIT>\"));<EOL>            var slotEntry = {<EOL>                guid: data.guid,<EOL>                name: \"<STR_LIT>\",<EOL>                baseid: \"<STR_LIT>\",<EOL>                entries: []<EOL>            };<EOL>            userEntry.slots.push(slotEntry);<EOL>            <EOL>            data.items.reverse();<EOL>            var features: TDev.MultiSet = {};<EOL>            if (data.items[<NUM_LIT>] && data.items[<NUM_LIT>].scriptstatus == \"<STR_LIT>\")<EOL>                slotEntry.baseid = data.items[<NUM_LIT>].scriptid;<EOL>            slotEntry.entries = data.items.map(i => {<EOL>                TDev.AST.reset();<EOL>                TDev.AST.loadScriptAsync((s) => TDev.Promise.as(s == \"<STR_LIT>\" ? i.script : null));<EOL>                var","gt":"nf: any = getAstInfo({});"}
{"input":"<s> function featureize(dirs: string[]) {<EOL>    libroots = JSON.parse(fs.readFileSync(\"<STR_LIT>\", \"<STR_LIT>\"));<EOL>    Object.keys(libroots).forEach(k => {<EOL>        var m = /^([^:]*):([^:]*)/.exec(libroots[k]);<EOL>        if (m) {<EOL>            libroots[k] = m[<NUM_LIT>] + \"<STR_LIT>\" + m[<NUM_LIT>];<EOL>        }<EOL>    });<EOL>    console.log(\"<STR_LIT>\" + dirs.join(\"<STR_LIT>\"));<EOL>    dirs.forEach(uu => {<EOL>        var userEntry = {<EOL>            uid: \"<STR_LIT>\",<EOL>            slots: [],<EOL>        };<EOL>        var existing: any = {};<EOL>        var m = /([^\\/]+)$/.exec(uu);<EOL>        userEntry.uid = m[<NUM_LIT>];<EOL>        var jsonName = \"<STR_LIT>\" + userEntry.uid + \"<STR_LIT>\";<EOL>        if (fs.existsSync(jsonName)) {<EOL>            userEntry = JSON.parse(fs.readFileSync(jsonName, \"<STR_LIT>\"));<EOL>            existing = {};<EOL>            userEntry.slots.forEach(s => existing[s.guid] = <NUM_LIT>);<EOL>        }<EOL>        fs.readdirSync(uu).forEach(fn => {<EOL>            var m = /([^\\/]+)\\.json$/.exec(fn);<EOL>            if (!m)<EOL>                return;<EOL>            if (existing.hasOwnProperty(m[<NUM_LIT>]))<EOL>                return;<EOL>            <EOL>            var data = JSON.parse(fs.readFileSync(uu + \"<STR_LIT>\" + fn, \"<STR_LIT>\"));<EOL>            var slotEntry = {<EOL>                guid: data.guid,<EOL>                name: \"<STR_LIT>\",<EOL>                baseid: \"<STR_LIT>\",<EOL>                entries: []<EOL>            };<EOL>            userEntry.slots.push(slotEntry);<EOL>            <EOL>            data.items.reverse();<EOL>            var features: TDev.MultiSet = {};<EOL>            if (data.items[<NUM_LIT>] && data.items[<NUM_LIT>].scriptstatus == \"<STR_LIT>\")<EOL>                slotEntry.baseid = data.items[<NUM_LIT>].scriptid;<EOL>            slotEntry.entries = data.items.map(i => {<EOL>                TDev.AST.reset();<EOL>                TDev.AST.loadScriptAsync((s) => TDev.Promise.as(s == \"<STR_LIT>\" ? i.script : null));<EOL>                var nf: any = getAstInfo({});<EOL>                var diff = TDev.Util.msSubtract(nf.features, features);<EOL>                features = nf.features;<EOL>                nf.features = diff;<EOL>                <EOL>                nf.time = i.time;<EOL>                if (i.scriptstatus == \"<STR_LIT>\")<EOL>                    nf.pubid = i.","gt":"scriptid;"}
{"input":"<s> export function exec(command: string, options: cp.ExecOptions): Promise<{<EOL>    stdout: string;<EOL>    stderr: string;<EOL>}> {<EOL>    return new Promise<{<EOL>        stdout: string;<EOL>        stderr: string;<EOL>    }>((","gt":"resolve, reject) => {"}
{"input":"<s> export function exec(command: string, options: cp.ExecOptions): Promise<{<EOL>    stdout: string;<EOL>    stderr: string;<EOL>}> {<EOL>    return new Promise<{<EOL>        stdout: string;<EOL>        stderr: string;<EOL>    }>((resolve, reject) => {<EOL>        cp.exec(command, options, (error, stdout, stderr) => {<EOL>            if (error) {<EOL>                reject({ error, stdout, stderr });<EOL>            }<EOL>            resolve({ stdout,","gt":"stderr });"}
{"input":"<s> export function AfterUpdate(...args: any[]): void | Function {<EOL>    return implementHookDecorator(","gt":"'<STR_LIT>', args);"}
{"input":"<s> export async function updateLatestTag(pkg: AnyPackage, versions: Versions, client: NpmClient, log: Logger, dry: boolean): Promise<void> {<EOL>    <EOL>    const latestNonPrerelease = versions.","gt":"latestNonPrerelease(pkg);"}
{"input":"<s> export function nextItemHTML(selectionStart: vscode.Position, selectionEnd: vscode.Position, editor: vscode.TextEditor, rootNode: HtmlNode): vscode.Selection | undefined {<EOL>    let currentNode = <HtmlNode>getNode(rootNode, selectionEnd);<EOL>    let nextNode: HtmlNode | undefined = undefined;<EOL>    if (!currentNode) {<EOL>","gt":"return;"}
{"input":"<s> export function nextItemHTML(selectionStart: vscode.Position, selectionEnd: vscode.Position, editor: vscode.TextEditor, rootNode: HtmlNode): vscode.Selection | undefined {<EOL>    let currentNode = <HtmlNode>getNode(rootNode, selectionEnd);<EOL>    let nextNode: HtmlNode | undefined = undefined;<EOL>    if (!currentNode) {<EOL>        return;<EOL>    }<EOL>    if (currentNode.type !== '<STR_LIT>') {<EOL>        <EOL>        if (selectionEnd.isBefore(currentNode.open.start.translate(<NUM_LIT>, currentNode.name.length))) {<EOL>            return getSelectionFromNode(currentNode, editor.document);<EOL>        }<EOL>        <EOL>","gt":"if (selectionEnd.isBefore(currentNode.open.end)) {"}
{"input":"<s> export function nextItemHTML(selectionStart: vscode.Position, selectionEnd: vscode.Position, editor: vscode.TextEditor, rootNode: HtmlNode): vscode.Selection | undefined {<EOL>    let currentNode = <HtmlNode>getNode(rootNode, selectionEnd);<EOL>    let nextNode: HtmlNode | undefined = undefined;<EOL>    if (!currentNode) {<EOL>        return;<EOL>    }<EOL>    if (currentNode.type !== '<STR_LIT>') {<EOL>        <EOL>        if (selectionEnd.isBefore(currentNode.open.start.translate(<NUM_LIT>, currentNode.name.length))) {<EOL>            return getSelectionFromNode(currentNode, editor.document);<EOL>        }<EOL>        <EOL>        if (selectionEnd.isBefore(currentNode.open.end)) {<EOL>            let attrSelection = getNextAttribute(selectionStart, selectionEnd, editor.document, currentNode);<EOL>            if (attrSelection) {<EOL>                return attrSelection;<EOL>            }<EOL>        }<EOL>        <EOL>        nextNode = currentNode.firstChild;<EOL>        while (nextNode && (selectionEnd.isAfterOrEqual(nextNode.start) || nextNode.type === '<STR_LIT>')) {<EOL>            nextNode =","gt":"nextNode.nextSibling;"}
{"input":"<s> <EOL>export function HttpLoaderFactory(http: HttpClient) {<EOL>    return new TranslateHttpLoader(http,","gt":"'<STR_LIT>', '<STR_LIT>');"}
{"input":"<s> export function BeforeSave(...args: any[]): void | Function {<EOL>","gt":"return implementHookDecorator('<STR_LIT>', args);"}
{"input":"<s> export function BeforeCount(...args: any[]): void | Function {<EOL>","gt":"return implementHookDecorator('<STR_LIT>', args);"}
{"input":"<s> export function AfterDestroy(...args: any[]): void | Function {<EOL>","gt":"return implementHookDecorator('<STR_LIT>', args);"}
{"input":"<s> function Test() {<EOL>    <EOL>    const codeSection = get.section(mod, sect_id.code) as CodeSection;<EOL>    for (let funcBody of get.function_bodies(codeSection)) {<EOL>        printCode(funcBody.code, s => { console.log(s.replace(/[\\r\\n]+$/, '<STR_LIT>')); });<EOL>    }<EOL>    <EOL>    const emitbuf = new BufferedEmitter(new ArrayBuffer(mod.z));<EOL>    mod.emit(","gt":"emitbuf);"}
{"input":"<s> function Test() {<EOL>    <EOL>    const codeSection = get.section(mod, sect_id.code) as CodeSection;<EOL>    for (let funcBody of get.function_bodies(codeSection)) {<EOL>        printCode(funcBody.code, s => { console.log(s.replace(/[\\r\\n]+$/, '<STR_LIT>')); });<EOL>    }<EOL>    <EOL>    const emitbuf = new BufferedEmitter(new ArrayBuffer(mod.z));<EOL>    mod.emit(emitbuf);<EOL>    if (!isUnitTest) {<EOL>        console.log(strRepr(mod));<EOL>    }<EOL>    <EOL>    return specEval(emitbuf.buffer, {<EOL>        eval:","gt":"'<STR_LIT>',"}
{"input":"<s> /**<EOL> * Check for valid credit card numbers<EOL> */<EOL>export function IsCreditCard(target: any, propertyName: string): void {<EOL>    addAttributeOptions(target, propertyName, {<EOL>","gt":"validate: {"}
{"input":"<s> /**<EOL> * Don't allow specific substrings<EOL> */<EOL>export function NotContains(value: string | {<EOL>    msg: string;<EOL>    args: string;<EOL>}): Function {<EOL>    return (target: any, propertyName: string) => addAttributeOptions(target, propertyName, {<EOL>","gt":"validate: {"}
{"input":"<s> function varint32(value: int32): VarInt32 {<EOL>    assert(value >= -<NUM_LIT> && value <=","gt":"<NUM_LIT>);"}
{"input":"<s> function if_<R extends AnyResult>(r: R, cond: Op<I32>, then_: AnyOp[], else_?: AnyOp[]) {<EOL>    assert(r === then_[then_.length - <NUM_LIT>].r);<EOL>    assert(!else_ || else_.length == <NUM_LIT> || r === else_[else_.length - <NUM_LIT>].r);<EOL>    return new instr_pre_imm_post(<NUM_LIT>,","gt":"r, [cond],"}
{"input":"<s> function wrapInAction(callback: Function, callbackType: string) {<EOL>    let currentAction = getCurrentAction();<EOL>    if (!currentAction || !callback) {<EOL>        return callback;<EOL>    }<EOL>    let actionName = currentAction + '<STR_LIT>' + callbackType;<EOL>    return function () {<EOL>        let returnValue;<EOL>        let args = arguments;<EOL>        action(actionName)(() => {<EOL>            returnValue = callback.apply(","gt":"null, args);"}
{"input":"<s> function scrubFiles(files: string[]) {<EOL>    files.forEach(file => {<EOL>        if (/^[a-z]*$/.test(file)) {<EOL>            var pref = \"<STR_LIT>\" + file;<EOL>            scrubFiles(fs.readdirSync(pref).map(f => pref + \"<STR_LIT>\" + f));<EOL>        }<EOL>","gt":"else {"}
{"input":"<s> function scrubFiles(files: string[]) {<EOL>    files.forEach(file => {<EOL>        if (/^[a-z]*$/.test(file)) {<EOL>            var pref = \"<STR_LIT>\" + file;<EOL>            scrubFiles(fs.readdirSync(pref).map(f => pref + \"<STR_LIT>\" + f));<EOL>        }<EOL>        else {<EOL>            try {<EOL>                var entry = JSON.parse(fs.readFileSync(file, \"<STR_LIT>\"));<EOL>                TDev.AST.Diff.scrub(entry.items);<EOL>","gt":"var dst = file.replace(/compressed/, \"<STR_LIT>\");"}
{"input":"<s> function scrubFiles(files: string[]) {<EOL>    files.forEach(file => {<EOL>        if (/^[a-z]*$/.test(file)) {<EOL>            var pref = \"<STR_LIT>\" + file;<EOL>            scrubFiles(fs.readdirSync(pref).map(f => pref + \"<STR_LIT>\" + f));<EOL>        }<EOL>        else {<EOL>            try {<EOL>                var entry = JSON.parse(fs.readFileSync(file, \"<STR_LIT>\"));<EOL>                TDev.AST.Diff.scrub(entry.items);<EOL>                var dst = file.replace(/compressed/, \"<STR_LIT>\");<EOL>                fs.writeFileSync(dst, JSON.stringify(entry, null, <NUM_LIT>), \"<STR_LIT>\");<EOL>            }<EOL>            catch (","gt":"e) {"}
{"input":"<s> export function renderViewTree(container: HTMLElement): HTMLElement {<EOL>    const treeContainer = document.createElement('<STR_LIT>');<EOL>    dom.addClass(treeContainer,","gt":"'<STR_LIT>');"}
{"input":"<s> function getPublishingProfileWithSecrets(tr) {<EOL>    assert(tr.","gt":"stdOutContained('<STR_LIT>'), '<STR_LIT>');"}
{"input":"<s> export function isNotEmpty(str: any): boolean {<EOL>    return <boolean>(str &&","gt":"'<STR_LIT>' !== str);"}
{"input":"<s> function compileDuration(e: Environment, b: B.Block): J.JExpr {<EOL>    var matches = b.type.match(/^device_duration_1\\/(\\d+)/);<EOL>    if (matches)<EOL>","gt":"return H.mkSimpleCall(\"<STR_LIT>\", ["}
{"input":"<s> function f1() {<EOL>    var a: A1 = <NUM_LIT>;<EOL>","gt":"var a: A2 = <NUM_LIT>;"}
{"input":"<s> function declareEnums(ast: AST, options: Options, processed = new Set<AST>()): string {<EOL>    if (processed.has(ast)) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    processed.add(ast);<EOL>    let","gt":"type = '<STR_LIT>';"}
{"input":"<s> function declareEnums(ast: AST, options: Options, processed = new Set<AST>()): string {<EOL>    if (processed.has(ast)) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    processed.add(ast);<EOL>    let type = '<STR_LIT>';<EOL>    switch (ast.type) {<EOL>        case '<STR_LIT>':<EOL>            type = generateStandaloneEnum(ast, options) + '<STR_LIT>';<EOL>","gt":"break;"}
{"input":"<s> function declareEnums(ast: AST, options: Options, processed = new Set<AST>()): string {<EOL>    if (processed.has(ast)) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    processed.add(ast);<EOL>    let type = '<STR_LIT>';<EOL>    switch (ast.type) {<EOL>        case '<STR_LIT>':<EOL>            type = generateStandaloneEnum(ast, options) + '<STR_LIT>';<EOL>            break;<EOL>        case '<STR_LIT>':<EOL>            type = getSuperTypesAndParams(ast).reduce((prev, ast) => prev + declareEnums(ast, options, processed), '<STR_LIT>');<EOL>            break;<EOL>","gt":"default:"}
{"input":"<s> function comparePositions(p1: Position, p2: Position) {<EOL>    let diff = p2.line - p1.line;<EOL>    if (diff ===","gt":"<NUM_LIT>) {"}
{"input":"<s> function escapeKeyName(keyName: string): string {<EOL>    if (keyName.length<EOL>        && /[A-Za-z_$]/.test(keyName.charAt(<NUM_LIT>))<EOL>        &&","gt":"/^[\\w$]+$/.test(keyName)) {"}
{"input":"<s> /**<EOL> * TODO: Reduce rate of false positives<EOL> */<EOL>function hasDefinitions(schema: JSONSchema): schema is JSONSchemaWithDefinitions {<EOL>    return '<STR_LIT>' in","gt":"schema;"}
{"input":"<s> /**<EOL> * Return only positive patterns.<EOL> */<EOL>export function getPositivePatterns(patterns: Pattern[]): Pattern[] {<EOL>    return patternUtils.","gt":"getPositivePatterns(patterns);"}
{"input":"<s> export function renderVariable(tree: ITree, variable: Variable, data: IVariableTemplateData, showChanged: boolean): void {<EOL>    if (variable.available) {<EOL>        data.name.textContent = replaceWhitespace(variable.name);<EOL>        data.name.title = variable.type ? variable.type : variable.name;<EOL>        dom.toggleClass(data.name, '<STR_LIT>', !!variable.presentationHint && variable.presentationHint.kind === '<STR_LIT>');<EOL>    }<EOL>","gt":"if (variable.value) {"}
{"input":"<s> export function renderVariable(tree: ITree, variable: Variable, data: IVariableTemplateData, showChanged: boolean): void {<EOL>    if (variable.available) {<EOL>        data.name.textContent = replaceWhitespace(variable.name);<EOL>        data.name.title = variable.type ? variable.type : variable.name;<EOL>        dom.toggleClass(data.name, '<STR_LIT>', !!variable.presentationHint && variable.presentationHint.kind === '<STR_LIT>');<EOL>    }<EOL>    if (variable.value) {<EOL>        data.name.textContent += variable.name ? '<STR_LIT>' : '<STR_LIT>';<EOL>        renderExpressionValue(variable, data.value, {<EOL>            showChanged,<EOL>            maxValueLength: MAX_VALUE_RENDER_LENGTH_IN_VIEWLET,<EOL>            preserveWhitespace:","gt":"false,"}
{"input":"<s> /**<EOL> * Create a task for positive and negative patterns.<EOL> */<EOL>export function convertPatternGroupToTask(base: string, positive: Pattern[], negative: Pattern[], dynamic: boolean): ITask {<EOL>    return {<EOL>        base,<EOL>","gt":"dynamic,"}
{"input":"<s> function getStats(uid: number, isSymbolicLink: boolean): fs.Stats {<EOL>    return { uid,","gt":"isSymbolicLink: () => isSymbolicLink } as fs.Stats;"}
{"input":"<s> function f2() {<EOL>","gt":"var b: B1 = -<NUM_LIT>;"}
{"input":"<s> export default function createEnvironment() {<EOL>    const network = Network.create(fetchQuery);<EOL>    const source = new RecordSource();<EOL>    const store = new","gt":"Store(source);"}
{"input":"<s> export function convertHrtimeToMilliseconds(hrtime: [<EOL>    number,<EOL>    number<EOL>]): number {<EOL>    const nanoseconds = (","gt":"hrtime[<NUM_LIT>] * <NUM_LIT>) + hrtime[<NUM_LIT>];"}
{"input":"<s> export function reducer(state = initialState, action: Action): State {<EOL>    switch (action.type) {<EOL>        case ActionTypes.UPDATE_LOGIN_NOTIFICATION: {<EOL>            console.log('<STR_LIT>');<EOL>            let message = action.payload;<EOL>            state.loginFormErrorMessage =","gt":"message;"}
{"input":"<s> export function reducer(state = initialState, action: Action): State {<EOL>    switch (action.type) {<EOL>        case ActionTypes.UPDATE_LOGIN_NOTIFICATION: {<EOL>            console.log('<STR_LIT>');<EOL>            let message = action.payload;<EOL>            state.loginFormErrorMessage = message;<EOL>            return Object.assign({}, state);<EOL>        }<EOL>        case ActionTypes.UPDATE_SIGNUP_NOTIFICATION: {<EOL>            let","gt":"message = action.payload;"}
{"input":"<s> export function reducer(state = initialState, action: Action): State {<EOL>    switch (action.type) {<EOL>        case ActionTypes.UPDATE_LOGIN_NOTIFICATION: {<EOL>            console.log('<STR_LIT>');<EOL>            let message = action.payload;<EOL>            state.loginFormErrorMessage = message;<EOL>            return Object.assign({}, state);<EOL>        }<EOL>        case ActionTypes.UPDATE_SIGNUP_NOTIFICATION: {<EOL>            let message = action.payload;<EOL>            state.signUpFormErrorMessage = message;<EOL>            return Object.assign({}, state);<EOL>        }<EOL>","gt":"default: {"}
{"input":"<s> export function serenityBDDReporter(requirementsDirectory: string = serenity.config.requirementsDirectory, outputDirectory: string = serenity.config.outputDirectory): StageCrewMember {<EOL>    return new SerenityBDDReporter(requirementsDirectory, new","gt":"FileSystem(outputDirectory));"}
{"input":"<s> export function getMemory(): number {<EOL>    return process.memoryUsage().heapUsed /","gt":"<NUM_LIT> / <NUM_LIT>;"}
{"input":"<s> async function main(argv: minimist.ParsedArgs) {<EOL>    if (argv.help) {<EOL>        printHelp();<EOL>        process.exit(<NUM_LIT>);<EOL>    }<EOL>    const argIn: string = argv.","gt":"_[<NUM_LIT>] || argv.input;"}
{"input":"<s> async function main(argv: minimist.ParsedArgs) {<EOL>    if (argv.help) {<EOL>        printHelp();<EOL>        process.exit(<NUM_LIT>);<EOL>    }<EOL>    const argIn: string = argv._[<NUM_LIT>] || argv.input;<EOL>    const argOut: string = argv._[<NUM_LIT>] || argv.output;<EOL>    try {<EOL>        const schema: JSONSchema4 = JSON.parse(await readInput(argIn));<EOL>        const ts = await","gt":"compile(schema, argIn, argv as Partial<Options>);"}
{"input":"<s> async function main(argv: minimist.ParsedArgs) {<EOL>    if (argv.help) {<EOL>        printHelp();<EOL>        process.exit(<NUM_LIT>);<EOL>    }<EOL>    const argIn: string = argv._[<NUM_LIT>] || argv.input;<EOL>    const argOut: string = argv._[<NUM_LIT>] || argv.output;<EOL>    try {<EOL>        const schema: JSONSchema4 = JSON.parse(await readInput(argIn));<EOL>        const ts = await compile(schema, argIn, argv as Partial<Options>);<EOL>        await writeOutput(ts, argOut);<EOL>    }<EOL>    catch (","gt":"e) {"}
{"input":"<s> function getConfigAndOptions(options: TaskOptions): Promise<{<EOL>    config: Partial<Config>;<EOL>    options: TaskOptions;<EOL>}> {<EOL>    if (options.config) {<EOL>        return getConfig(options.config, []).then(({ config }) => {<EOL>            const opts = { ...","gt":"options };"}
{"input":"<s> export function outcome<T>(subject: T, stepStatus: string, error: Error | undefined): Outcome<T> {<EOL>    return new Outcome(subject, serenityResultFrom(stepStatus, error),","gt":"error);"}
{"input":"<s> function f(foo: T) {<EOL>    if (isS(foo)) {<EOL>","gt":"return foo;"}
{"input":"<s> function createFailingStep(stepInterface: StepInterface) {<EOL>    switch (stepInterface) {<EOL>        case StepInterface.CALLBACK:<EOL>            return cb => {<EOL>                process.nextTick(cb.bind(null, new Error('<STR_LIT>')));<EOL>            };<EOL>        case StepInterface.PROMISE:<EOL>            return () => {<EOL>","gt":"return new Promise((resolve, reject) => {"}
{"input":"<s> function createFailingStep(stepInterface: StepInterface) {<EOL>    switch (stepInterface) {<EOL>        case StepInterface.CALLBACK:<EOL>            return cb => {<EOL>                process.nextTick(cb.bind(null, new Error('<STR_LIT>')));<EOL>            };<EOL>        case StepInterface.PROMISE:<EOL>            return () => {<EOL>                return new Promise((resolve, reject) => {<EOL>                    process.nextTick(() => {<EOL>                        reject(new Error('<STR_LIT>'));<EOL>                    });<EOL>                });<EOL>            };<EOL>        case StepInterface.GENERATOR:<EOL>            return function* () {<EOL>                yield new Promise(process.nextTick);<EOL>                throw new Error('<STR_LIT>');<EOL>            };<EOL>        case StepInterface.","gt":"SYNCHRONOUS:"}
{"input":"<s> export function ucFirst(word: string): string {<EOL>    return","gt":"toUpperCase()}${word.substring(<NUM_LIT>)}`<STR_LIT>;"}
{"input":"<s> export function keyNameOf(key: string) {<EOL>    const keys = definitionsFrom(protractor, webdriver);<EOL>    for (const candidate in keys) {<EOL>        if (keys.hasOwnProperty(candidate) &&","gt":"keys[candidate] === key) {"}
{"input":"<s> function deserialised(event: any): DomainEvent<any> {<EOL>    const tagsFrom = (tags: Tag[]) => tags.map(_ => new Tag(_.type, _.values)), scene = ({ name, category, location, tags, id }: RecordedScene): RecordedScene => new RecordedScene(name, category, location, tagsFrom(tags), id), activity = ({ name, location, id }: RecordedActivity): RecordedActivity => new RecordedActivity(name, location, id), outcome = <T>(type: (T) => T, { subject, result, error }: Outcome<T>) => new Outcome(type(subject), result, error);<EOL>    switch (event.type) {<EOL>        case '<STR_LIT>':<EOL>            return new SceneStarts(scene(event.value),","gt":"event.timestamp);"}
{"input":"<s> function deserialised(event: any): DomainEvent<any> {<EOL>    const tagsFrom = (tags: Tag[]) => tags.map(_ => new Tag(_.type, _.values)), scene = ({ name, category, location, tags, id }: RecordedScene): RecordedScene => new RecordedScene(name, category, location, tagsFrom(tags), id), activity = ({ name, location, id }: RecordedActivity): RecordedActivity => new RecordedActivity(name, location, id), outcome = <T>(type: (T) => T, { subject, result, error }: Outcome<T>) => new Outcome(type(subject), result, error);<EOL>    switch (event.type) {<EOL>        case '<STR_LIT>':<EOL>            return new SceneStarts(scene(event.value), event.timestamp);<EOL>        case '<STR_LIT>':<EOL>            return new ActivityStarts(activity(event.value), event.timestamp);<EOL>        case '<STR_LIT>':<EOL>            return new ActivityFinished(outcome<RecordedActivity>(activity, event.value), event.timestamp);<EOL>        case '<STR_LIT>':<EOL>            return new SceneFinished(","gt":"outcome<RecordedScene>(scene, event.value), event.timestamp);"}
{"input":"<s> /**<EOL> * Create new PerfCascade from HAR data<EOL> * @param  {Har} harData - HAR object<EOL> * @param  {ChartOptions} options - PerfCascade options object<EOL> * @returns {SVGSVGElement} - Chart SVG Element<EOL> */<EOL>export function fromHar(harData: Har, options: ChartOptions = {}): SVGSVGElement {<EOL>    const harTransformerOptions: HarTransformerOptions = {<EOL>        ...defaultHarTransformerOptions,<EOL>        ...","gt":"options,"}
{"input":"<s> export default function (selector: string): any {<EOL>    let selectorArray: string[];<EOL>    let type: string;<EOL>    if (selector.match(/\\[(.*?)\\]/) !== null) {<EOL>        selectorArray = selector.slice(<NUM_LIT>, selector.length - <NUM_LIT>).split('<STR_LIT>');<EOL>        type = '<STR_LIT>';<EOL>    }<EOL>    else if (selector[<NUM_LIT>] === '<STR_LIT>') {<EOL>        selectorArray = selector.slice(<NUM_LIT>, selector.length).split('<STR_LIT>');<EOL>","gt":"type = '<STR_LIT>';"}
{"input":"<s> export default function (selector: string): any {<EOL>    let selectorArray: string[];<EOL>    let type: string;<EOL>    if (selector.match(/\\[(.*?)\\]/) !== null) {<EOL>        selectorArray = selector.slice(<NUM_LIT>, selector.length - <NUM_LIT>).split('<STR_LIT>');<EOL>        type = '<STR_LIT>';<EOL>    }<EOL>    else if (selector[<NUM_LIT>] === '<STR_LIT>') {<EOL>        selectorArray = selector.slice(<NUM_LIT>, selector.length).split('<STR_LIT>');<EOL>        type = '<STR_LIT>';<EOL>    }<EOL>    else {<EOL>        selectorArray = selector.split(","gt":"'<STR_LIT>');"}
{"input":"<s> export default function (selector: string): any {<EOL>    let selectorArray: string[];<EOL>    let type: string;<EOL>    if (selector.match(/\\[(.*?)\\]/) !== null) {<EOL>        selectorArray = selector.slice(<NUM_LIT>, selector.length - <NUM_LIT>).split('<STR_LIT>');<EOL>        type = '<STR_LIT>';<EOL>    }<EOL>    else if (selector[<NUM_LIT>] === '<STR_LIT>') {<EOL>        selectorArray = selector.slice(<NUM_LIT>, selector.length).split('<STR_LIT>');<EOL>        type = '<STR_LIT>';<EOL>    }<EOL>    else {<EOL>        selectorArray = selector.split('<STR_LIT>');<EOL>        type = '<STR_LIT>';<EOL>    }<EOL>    let","gt":"first = selectorArray.shift();"}
{"input":"<s> function stringify(token: string, value: any): string {<EOL>    switch ({}.toString.call(value)) {<EOL>        case '<STR_LIT>': return stringify(token, value());<EOL>        case '<STR_LIT>':","gt":"return value.map(item => stringify(token, item)).join('<STR_LIT>');"}
{"input":"<s> function isObject(item: any): Boolean {<EOL>    return","gt":"item && typeof item === '<STR_LIT>' && !Array.isArray(item);"}
{"input":"<s> export function Once(milliseconds: number = <NUM_LIT>) {<EOL>    return function (target, key, descriptor) {<EOL>        var originalMethod = descriptor.value;<EOL>        descriptor.value = function (...args) {<EOL>            var sub = originalMethod.apply(","gt":"this, args);"}
{"input":"<s> export function Once(milliseconds: number = <NUM_LIT>) {<EOL>    return function (target, key, descriptor) {<EOL>        var originalMethod = descriptor.value;<EOL>        descriptor.value = function (...args) {<EOL>            var sub = originalMethod.apply(this, args);<EOL>            setTimeout(() => {<EOL>                if (sub instanceof Subscriber) {<EOL>                    sub.","gt":"unsubscribe();"}
{"input":"<s> function hasCompressionIssue(entry: Entry, requestType: RequestType) {<EOL>","gt":"const headers = entry.response.headers;"}
{"input":"<s> /** Checks if the ressource uses https */<EOL>function isSecure(entry: Entry) {<EOL>    return entry.request.url.indexOf(\"<STR_LIT>\") ===","gt":"<NUM_LIT>;"}
{"input":"<s> function createStubbedSuite(stubbedMethodName: string, testMethodName: string, placeholders: string[], firstArguments: any[]) {<EOL>    let originalMethod: Function;<EOL>    let calledWith: any;<EOL>    let","gt":"extraArguments: any[] = [];"}
{"input":"<s> function createStubbedSuite(stubbedMethodName: string, testMethodName: string, placeholders: string[], firstArguments: any[]) {<EOL>    let originalMethod: Function;<EOL>    let calledWith: any;<EOL>    let extraArguments: any[] = [];<EOL>    let element = new Element('<STR_LIT>', <Session>{});<EOL>    const suite = {<EOL>","gt":"setup: function () {"}
{"input":"<s> function createStubbedSuite(stubbedMethodName: string, testMethodName: string, placeholders: string[], firstArguments: any[]) {<EOL>    let originalMethod: Function;<EOL>    let calledWith: any;<EOL>    let extraArguments: any[] = [];<EOL>    let element = new Element('<STR_LIT>', <Session>{});<EOL>    const suite = {<EOL>        setup: function () {<EOL>            originalMethod = (<any>element)[stubbedMethodName];<EOL>            (<any>element)[stubbedMethodName] = function () {<EOL>                calledWith = arguments;<EOL>            };<EOL>            for (let i = <NUM_LIT>, j = originalMethod.length - <NUM_LIT>; i < j; ++i) {<EOL>                extraArguments.push('<STR_LIT>' + (i + <NUM_LIT>));<EOL>            }<EOL>        },<EOL>        beforeEach: function () {<EOL>            calledWith = null;<EOL>        },<EOL>","gt":"teardown: function () {"}
{"input":"<s> function createStubbedSuite(stubbedMethodName: string, testMethodName: string, placeholders: string[], firstArguments: any[]) {<EOL>    let originalMethod: Function;<EOL>    let calledWith: any;<EOL>    let extraArguments: any[] = [];<EOL>    let element = new Element('<STR_LIT>', <Session>{});<EOL>    const suite = {<EOL>        setup: function () {<EOL>            originalMethod = (<any>element)[stubbedMethodName];<EOL>            (<any>element)[stubbedMethodName] = function () {<EOL>                calledWith = arguments;<EOL>            };<EOL>            for (let i = <NUM_LIT>, j = originalMethod.length - <NUM_LIT>; i < j; ++i) {<EOL>                extraArguments.push('<STR_LIT>' + (i + <NUM_LIT>));<EOL>            }<EOL>        },<EOL>        beforeEach: function () {<EOL>            calledWith = null;<EOL>        },<EOL>        teardown: function () {<EOL>            (<any>element)[stubbedMethodName] = originalMethod;<EOL>        }<EOL>    };<EOL>    placeholders.forEach(function (placeholder: string, index: number) {<EOL>        const method = testMethodName.replace('<STR_LIT>', placeholder);<EOL>        (<any>suite)['<STR_LIT>' + method] = function () {<EOL>","gt":"assert.isFunction((<any>element)[method]);"}
{"input":"<s> export function createRowBg(y: number, rowHeight: number): SVGGElement {<EOL>    const rowFixed = svg.newG(\"<STR_LIT>\");<EOL>    rowFixed.appendChild(svg.newRect({<EOL>        height: rowHeight,<EOL>        width:","gt":"\"<STR_LIT>\","}
{"input":"<s> export function createRowBg(y: number, rowHeight: number): SVGGElement {<EOL>    const rowFixed = svg.newG(\"<STR_LIT>\");<EOL>    rowFixed.appendChild(svg.newRect({<EOL>        height: rowHeight,<EOL>        width: \"<STR_LIT>\",<EOL>        x: \"<STR_LIT>\",<EOL>        y,<EOL>    }, \"<STR_LIT>\", {<EOL>        opacity:","gt":"<NUM_LIT>,"}
{"input":"<s> /**<EOL> * A sample async function (to demo Typescript's es7 async/await downleveling).<EOL> *<EOL> * ### Example (es imports)<EOL> * ```js<EOL> * import { asyncABC } from 'typescript-starter'<EOL> * console.log(await asyncABC())<EOL> * // => ['a','b','c']<EOL> * ```<EOL> *<EOL> * ### Example (commonjs)<EOL> * ```js<EOL> * var double = require('typescript-starter').asyncABC;<EOL> * asyncABC().then(console.log);<EOL> * // => ['a','b','c']<EOL> * ```<EOL> *<EOL> * @returns       a Promise which should contain `['a','b','c']`<EOL> */<EOL>export async function asyncABC() {<EOL>    function somethingSlow(index: <NUM_LIT> | <NUM_LIT> | <NUM_LIT>) {<EOL>        let storage = '<STR_LIT>'.charAt(index);<EOL>        return new Promise<string>(resolve => {<EOL>            <EOL>            setTimeout(() => resolve(storage), <NUM_LIT>);<EOL>        });<EOL>    }<EOL>    let a = await somethingSlow(<NUM_LIT>);<EOL>    let b = await somethingSlow(","gt":"<NUM_LIT>);"}
{"input":"<s> function _getStaggedDiffForAllFiles() {<EOL>    return Git.status().then((statusFiles) => {<EOL>        const untrackedFiles = [];<EOL>        const fileArray = [];<EOL>        statusFiles.forEach((fileObject) => {<EOL>            const isUntracked = fileObject.status.indexOf(Git.","gt":"FILE_STATUS.UNTRACKED) !== -<NUM_LIT>;"}
{"input":"<s> function _getStaggedDiffForAllFiles() {<EOL>    return Git.status().then((statusFiles) => {<EOL>        const untrackedFiles = [];<EOL>        const fileArray = [];<EOL>        statusFiles.forEach((fileObject) => {<EOL>            const isUntracked = fileObject.status.indexOf(Git.FILE_STATUS.UNTRACKED) !== -<NUM_LIT>;<EOL>            if (isUntracked) {<EOL>                untrackedFiles.push(fileObject.file);<EOL>            }<EOL>","gt":"else {"}
{"input":"<s> function _getStaggedDiffForAllFiles() {<EOL>    return Git.status().then((statusFiles) => {<EOL>        const untrackedFiles = [];<EOL>        const fileArray = [];<EOL>        statusFiles.forEach((fileObject) => {<EOL>            const isUntracked = fileObject.status.indexOf(Git.FILE_STATUS.UNTRACKED) !== -<NUM_LIT>;<EOL>            if (isUntracked) {<EOL>                untrackedFiles.push(fileObject.file);<EOL>            }<EOL>            else {<EOL>                fileArray.push(fileObject.file);<EOL>            }<EOL>        });<EOL>","gt":"return untrackedFiles.length > <NUM_LIT> ?"}
{"input":"<s> function discardAllChanges() {<EOL>    return Utils.askQuestion(Strings.RESET_LOCAL_REPO, Strings.RESET_LOCAL_REPO_CONFIRM, { booleanResponse: true })<EOL>        .then((response) => {<EOL>        if (response) {<EOL>            return Git2.discardAllChanges().","gt":"catch((err) => {"}
{"input":"<s> /**<EOL> * @param  {T[]} arr - array to search<EOL> * @param  {T} item - item to search for<EOL> * @returns boolean - true if `item` is in `arr`<EOL> */<EOL>export function contains<T>(arr: T[], item: T): boolean {<EOL>    return arr.some((x) => x ===","gt":"item);"}
{"input":"<s> export function getCommand(args: string[]): TfCommand<extPub.ExtensionArguments, void> {<EOL>    return new ExtensionPublisherBase<void>(","gt":"args);"}
{"input":"<s> async function fn6(x) {<EOL>    var { x, z } =","gt":"y;"}
{"input":"<s> /**<EOL> * Returns the fist instances of `headerName` in `headers`<EOL> * @param headers List of `Header` to search in<EOL> * @param headerName Name of `Header` to find<EOL> */<EOL>export function getHeader(headers: Header[], headerName: string): string {<EOL>    const headerFilter = matchHeaderPartialFn(headerName.toLowerCase());<EOL>    let firstItem;<EOL>","gt":"if (browserHasFind) {"}
{"input":"<s> function moveUp(cursor: Cursor, noOfLines: number = <NUM_LIT>, select?: boolean) {<EOL>    move(","gt":"cursor, { to: CursorMove.RawDirection.Up, by: CursorMove.RawUnit.WrappedLine, value: noOfLines, select: select });"}
{"input":"<s> export function formatBytes(bytes: number): string {<EOL>    const raw = `<STR_LIT>`;<EOL>    if (bytes >= bytesPerMB) {<EOL>        return","gt":"} (~${roundNumber(bytes / bytesPerMB, <NUM_LIT>)} MB)`<STR_LIT>;"}
{"input":"<s> function isSafari(capabilities: Capabilities, minOrExactVersion?: number, maxVersion?: number) {<EOL>    if (capabilities.browserName !== '<STR_LIT>') {<EOL>","gt":"return false;"}
{"input":"<s> function isFirefox(capabilities: Capabilities, minOrExactVersion?: number, maxVersion?: number) {<EOL>    if (capabilities.browserName !== '<STR_LIT>') {<EOL>        return","gt":"false;"}
{"input":"<s> export function testProperty<C extends Config = Config>(executor: Executor, mockConsole: {<EOL>    [name: string]: SinonSpy;<EOL>}, name: keyof C, badValue: any, goodValue: any, expectedValue: any, error: RegExp, allowDeprecated?: boolean | string, message?: string) {<EOL>    if (typeof allowDeprecated === '<STR_LIT>') {<EOL>        message = allowDeprecated;<EOL>        allowDeprecated = undefined;<EOL>    }<EOL>    if (typeof","gt":"allowDeprecated === '<STR_LIT>') {"}
{"input":"<s> export function testProperty<C extends Config = Config>(executor: Executor, mockConsole: {<EOL>    [name: string]: SinonSpy;<EOL>}, name: keyof C, badValue: any, goodValue: any, expectedValue: any, error: RegExp, allowDeprecated?: boolean | string, message?: string) {<EOL>    if (typeof allowDeprecated === '<STR_LIT>') {<EOL>        message = allowDeprecated;<EOL>        allowDeprecated = undefined;<EOL>    }<EOL>    if (typeof allowDeprecated === '<STR_LIT>') {<EOL>        allowDeprecated = false;<EOL>    }<EOL>    assert.throws(() => {<EOL>        executor.configure(<any>{ [name]:","gt":"badValue });"}
{"input":"<s> export function testProperty<C extends Config = Config>(executor: Executor, mockConsole: {<EOL>    [name: string]: SinonSpy;<EOL>}, name: keyof C, badValue: any, goodValue: any, expectedValue: any, error: RegExp, allowDeprecated?: boolean | string, message?: string) {<EOL>    if (typeof allowDeprecated === '<STR_LIT>') {<EOL>        message = allowDeprecated;<EOL>        allowDeprecated = undefined;<EOL>    }<EOL>    if (typeof allowDeprecated === '<STR_LIT>') {<EOL>        allowDeprecated = false;<EOL>    }<EOL>    assert.throws(() => {<EOL>        executor.configure(<any>{ [name]: badValue });<EOL>    }, error);<EOL>    executor.configure(<any>{ [name]: goodValue });<EOL>    if (","gt":"allowDeprecated) {"}
{"input":"<s> export function testProperty<C extends Config = Config>(executor: Executor, mockConsole: {<EOL>    [name: string]: SinonSpy;<EOL>}, name: keyof C, badValue: any, goodValue: any, expectedValue: any, error: RegExp, allowDeprecated?: boolean | string, message?: string) {<EOL>    if (typeof allowDeprecated === '<STR_LIT>') {<EOL>        message = allowDeprecated;<EOL>        allowDeprecated = undefined;<EOL>    }<EOL>    if (typeof allowDeprecated === '<STR_LIT>') {<EOL>        allowDeprecated = false;<EOL>    }<EOL>    assert.throws(() => {<EOL>        executor.configure(<any>{ [name]: badValue });<EOL>    }, error);<EOL>    executor.configure(<any>{ [name]: goodValue });<EOL>    if (allowDeprecated) {<EOL>        for (let call of mockConsole.warn.getCalls()) {<EOL>            assert.include(call.args[<NUM_LIT>], '<STR_LIT>', '<STR_LIT>');<EOL>        }<EOL>    }<EOL>    else {<EOL>        assert.equal(mockConsole.warn.callCount, <NUM_LIT>, '<STR_LIT>');<EOL>    }<EOL>    name = <keyof Config>name.replace(/\\+$/, '<STR_LIT>');<EOL>","gt":"const config = <C>executor.config;"}
{"input":"<s> export function getAuthStatus(state: State): any {<EOL>    return state.","gt":"auth;"}
{"input":"<s> /**<EOL> * Return a base path based on the current location pathname<EOL> */<EOL>export function getDefaultBasePath() {<EOL>    const match = /^(.*\\/)node_modules\\/intern\\/?/.exec(global.location.pathname);<EOL>    if (match) {<EOL>        <EOL>        <EOL>        <EOL>        return match[<NUM_LIT>];<EOL>    }<EOL>","gt":"else {"}
{"input":"<s> export function rebaseRemote(remote, branch) {<EOL>    return git([\"<STR_LIT>\", remote +","gt":"\"<STR_LIT>\" + branch]);"}
{"input":"<s> export function resetRemote(remote, branch) {<EOL>    return git([\"<STR_LIT>\", \"<STR_LIT>\", remote + \"<STR_LIT>\" +","gt":"branch]).then((stdout) => {"}
{"input":"<s> export function calculateFullStyle(full: Full, postFix: '<STR_LIT>' | '<STR_LIT>'): string {<EOL>    if (typeof full === '<STR_LIT>') {<EOL>        if (postFix === '<STR_LIT>') {<EOL>            return full.horizontal ? `<STR_LIT>` : '<STR_LIT>';<EOL>        }<EOL>        else {<EOL>            return full.vertical ? `<STR_LIT>` : '<STR_LIT>';<EOL>        }<EOL>    }<EOL>    else if (typeof full === '<STR_LIT>') {<EOL>        return full ?","gt":"postFix}`<STR_LIT>;"}
{"input":"<s> export function buildDelayFunction({ initial = <NUM_LIT>, max = Infinity, jitter = true, }: DelayFunctionOptions = {}): DelayFunction {<EOL>    let baseDelay;<EOL>    if (jitter) {<EOL>        <EOL>        <EOL>        baseDelay = initial;<EOL>    }<EOL>","gt":"else {"}
{"input":"<s> export function init() {<EOL>    return git([","gt":"\"<STR_LIT>\"]);"}
{"input":"<s> function _unquote(str) {<EOL>    return str.substring(<NUM_LIT>, str.","gt":"length - <NUM_LIT>);"}
{"input":"<s> /**<EOL> * Checks if an object is not undefined.<EOL> */<EOL>export function isDefined(value: any): boolean {<EOL>    return typeof value !==","gt":"'<STR_LIT>';"}
{"input":"<s> export function runBenchmarks() {<EOL>    Promise.all(groupPromises).then(() => {<EOL>        log('<STR_LIT>');<EOL>        bsuite<EOL>            .","gt":"on('<STR_LIT>', (error: any) => {"}
{"input":"<s> export function runBenchmarks() {<EOL>    Promise.all(groupPromises).then(() => {<EOL>        log('<STR_LIT>');<EOL>        bsuite<EOL>            .on('<STR_LIT>', (error: any) => {<EOL>            log('<STR_LIT>', error);<EOL>        })<EOL>            .on('<STR_LIT>', (event: any) => {<EOL>            log('<STR_LIT>', event.target.stats.mean * <NUM_LIT>);<EOL>            log(String(event.target));<EOL>","gt":"log('<STR_LIT>');"}
{"input":"<s> export function stop() {<EOL>    if (shell.test(","gt":"'<STR_LIT>', _pidPath)) {"}
{"input":"<s> function balance(out: boolean) {<EOL>    if (!validate(false) || !vscode.window.activeTextEditor) {<EOL>        return;<EOL>    }<EOL>    const editor = vscode.window.activeTextEditor;<EOL>    let rootNode = <HtmlNode>parseDocument(editor.","gt":"document);"}
{"input":"<s> function balance(out: boolean) {<EOL>    if (!validate(false) || !vscode.window.activeTextEditor) {<EOL>        return;<EOL>    }<EOL>    const editor = vscode.window.activeTextEditor;<EOL>    let rootNode = <HtmlNode>parseDocument(editor.document);<EOL>    if (!rootNode) {<EOL>        return;<EOL>    }<EOL>    let getRangeFunction = out ? getRangeToBalanceOut :","gt":"getRangeToBalanceIn;"}
{"input":"<s> function balance(out: boolean) {<EOL>    if (!validate(false) || !vscode.window.activeTextEditor) {<EOL>        return;<EOL>    }<EOL>    const editor = vscode.window.activeTextEditor;<EOL>    let rootNode = <HtmlNode>parseDocument(editor.document);<EOL>    if (!rootNode) {<EOL>        return;<EOL>    }<EOL>    let getRangeFunction = out ? getRangeToBalanceOut : getRangeToBalanceIn;<EOL>    let newSelections: vscode.Selection[] = [];<EOL>    editor.selections.forEach(selection => {<EOL>        let range = getRangeFunction(editor.document, selection, rootNode);<EOL>        newSelections.push(","gt":"range);"}
{"input":"<s> <EOL>export function get() {<EOL>    if (jsonPromise) {<EOL>        return jsonPromise;<EOL>    }<EOL>    const readPromise = FileUtils.readAsText(FileSystem.getFileForPath(","gt":"getPackageJsonPath()));"}
{"input":"<s> <EOL>export function get() {<EOL>    if (jsonPromise) {<EOL>        return jsonPromise;<EOL>    }<EOL>    const readPromise = FileUtils.readAsText(FileSystem.getFileForPath(getPackageJsonPath()));<EOL>    jsonPromise = Promise.cast(readPromise)<EOL>        .then((content) => {<EOL>        packageJson = JSON.parse(content);<EOL>","gt":"return packageJson;"}
{"input":"<s> export function getEventStreamFromElement<U extends Event = Event>(type: string, element: Element, eventListenerOptions: AddEventListenerOptions = { passive: true }): ObservableWithMotionOperators<U> {<EOL>    return new MotionObservable<Event>((observer: Observer<Event>) => {<EOL>        if (!supportsPassiveListeners) {<EOL>            eventListenerOptions = (eventListenerOptions.capture || false) as any as AddEventListenerOptions;<EOL>        }<EOL>        const next = observer.","gt":"next.bind(observer);"}
{"input":"<s> export function getEventStreamFromElement<U extends Event = Event>(type: string, element: Element, eventListenerOptions: AddEventListenerOptions = { passive: true }): ObservableWithMotionOperators<U> {<EOL>    return new MotionObservable<Event>((observer: Observer<Event>) => {<EOL>        if (!supportsPassiveListeners) {<EOL>            eventListenerOptions = (eventListenerOptions.capture || false) as any as AddEventListenerOptions;<EOL>        }<EOL>        const next = observer.next.bind(observer);<EOL>        <EOL>        <EOL>        <EOL>        <EOL>        <EOL>        element.addEventListener(type, next, eventListenerOptions as any as boolean);<EOL>","gt":"return () => {"}
{"input":"<s> /**<EOL> * Get the base path based on a config file path and a user-supplied base path.<EOL> *<EOL> * The path separator will be normalized based on the separator used in<EOL> * configFile or basePath and the optional pathSep arg.<EOL> */<EOL>export function getBasePath(configFile: string, basePath: string, isAbsolute: (path: string) => boolean, pathSep?: string) {<EOL>    pathSep = pathSep || getPathSep(configFile, basePath);<EOL>    <EOL>    const configPathParts = configFile.replace(/\\\\/g, '<STR_LIT>').split('<STR_LIT>');<EOL>    let initialBasePath: string;<EOL>    if (","gt":"configFile[<NUM_LIT>] === '<STR_LIT>' && configPathParts.length === <NUM_LIT>) {"}
{"input":"<s> /**<EOL> * Get the base path based on a config file path and a user-supplied base path.<EOL> *<EOL> * The path separator will be normalized based on the separator used in<EOL> * configFile or basePath and the optional pathSep arg.<EOL> */<EOL>export function getBasePath(configFile: string, basePath: string, isAbsolute: (path: string) => boolean, pathSep?: string) {<EOL>    pathSep = pathSep || getPathSep(configFile, basePath);<EOL>    <EOL>    const configPathParts = configFile.replace(/\\\\/g, '<STR_LIT>').split('<STR_LIT>');<EOL>    let initialBasePath: string;<EOL>    if (configFile[<NUM_LIT>] === '<STR_LIT>' && configPathParts.length === <NUM_LIT>) {<EOL>        initialBasePath = '<STR_LIT>';<EOL>    }<EOL>    else {<EOL>        initialBasePath = configPathParts.slice(","gt":"<NUM_LIT>, -<NUM_LIT>).join('<STR_LIT>');"}
{"input":"<s> /**<EOL> * Get the base path based on a config file path and a user-supplied base path.<EOL> *<EOL> * The path separator will be normalized based on the separator used in<EOL> * configFile or basePath and the optional pathSep arg.<EOL> */<EOL>export function getBasePath(configFile: string, basePath: string, isAbsolute: (path: string) => boolean, pathSep?: string) {<EOL>    pathSep = pathSep || getPathSep(configFile, basePath);<EOL>    <EOL>    const configPathParts = configFile.replace(/\\\\/g, '<STR_LIT>').split('<STR_LIT>');<EOL>    let initialBasePath: string;<EOL>    if (configFile[<NUM_LIT>] === '<STR_LIT>' && configPathParts.length === <NUM_LIT>) {<EOL>        initialBasePath = '<STR_LIT>';<EOL>    }<EOL>    else {<EOL>        initialBasePath = configPathParts.slice(<NUM_LIT>, -<NUM_LIT>).join('<STR_LIT>');<EOL>    }<EOL>    let finalBasePath: string;<EOL>","gt":"if (basePath) {"}
{"input":"<s> export function push(scope) {<EOL>    return","gt":"git([\"<STR_LIT>\", \"<STR_LIT>\", \"<STR_LIT>\", scope]);"}
{"input":"<s> function wireUpProcessErrorHandling(shouldWarningsFailBuild: boolean): void {<EOL>    if (!wiredUpErrorHandling) {<EOL>        wiredUpErrorHandling = true;<EOL>        let wroteToStdErr: boolean = false;<EOL>        if (shouldWarningsFailBuild) {<EOL>            const","gt":"oldStdErr: Function = process.stderr.write;"}
{"input":"<s> function wireUpProcessErrorHandling(shouldWarningsFailBuild: boolean): void {<EOL>    if (!wiredUpErrorHandling) {<EOL>        wiredUpErrorHandling = true;<EOL>        let wroteToStdErr: boolean = false;<EOL>        if (shouldWarningsFailBuild) {<EOL>            const oldStdErr: Function = process.stderr.write;<EOL>            <EOL>","gt":"process.stderr.write = function (text: string | Buffer): boolean {"}
{"input":"<s> function wireUpProcessErrorHandling(shouldWarningsFailBuild: boolean): void {<EOL>    if (!wiredUpErrorHandling) {<EOL>        wiredUpErrorHandling = true;<EOL>        let wroteToStdErr: boolean = false;<EOL>        if (shouldWarningsFailBuild) {<EOL>            const oldStdErr: Function = process.stderr.write;<EOL>            <EOL>            process.stderr.write = function (text: string | Buffer): boolean {<EOL>                if (!!text.toString()) {<EOL>                    wroteToStdErr = true;<EOL>","gt":"return oldStdErr.apply(process.stderr, arguments);"}
{"input":"<s> function wireUpProcessErrorHandling(shouldWarningsFailBuild: boolean): void {<EOL>    if (!wiredUpErrorHandling) {<EOL>        wiredUpErrorHandling = true;<EOL>        let wroteToStdErr: boolean = false;<EOL>        if (shouldWarningsFailBuild) {<EOL>            const oldStdErr: Function = process.stderr.write;<EOL>            <EOL>            process.stderr.write = function (text: string | Buffer): boolean {<EOL>                if (!!text.toString()) {<EOL>                    wroteToStdErr = true;<EOL>                    return oldStdErr.apply(process.stderr, arguments);<EOL>                }<EOL>                return true;<EOL>            };<EOL>        }<EOL>        process.on('<STR_LIT>', (code: number) => {<EOL>","gt":"duringFastExit = true;"}
{"input":"<s> function wireUpProcessErrorHandling(shouldWarningsFailBuild: boolean): void {<EOL>    if (!wiredUpErrorHandling) {<EOL>        wiredUpErrorHandling = true;<EOL>        let wroteToStdErr: boolean = false;<EOL>        if (shouldWarningsFailBuild) {<EOL>            const oldStdErr: Function = process.stderr.write;<EOL>            <EOL>            process.stderr.write = function (text: string | Buffer): boolean {<EOL>                if (!!text.toString()) {<EOL>                    wroteToStdErr = true;<EOL>                    return oldStdErr.apply(process.stderr, arguments);<EOL>                }<EOL>                return true;<EOL>            };<EOL>        }<EOL>        process.on('<STR_LIT>', (code: number) => {<EOL>            duringFastExit = true;<EOL>            if (!global['<STR_LIT>']) { <EOL>                if (!localCache.wroteSummary) {<EOL>                    localCache.wroteSummary = true;<EOL>                    console.log('<STR_LIT>', code);<EOL>                    console.error('<STR_LIT>' +<EOL>","gt":"'<STR_LIT>');"}
{"input":"<s> function wireUpProcessErrorHandling(shouldWarningsFailBuild: boolean): void {<EOL>    if (!wiredUpErrorHandling) {<EOL>        wiredUpErrorHandling = true;<EOL>        let wroteToStdErr: boolean = false;<EOL>        if (shouldWarningsFailBuild) {<EOL>            const oldStdErr: Function = process.stderr.write;<EOL>            <EOL>            process.stderr.write = function (text: string | Buffer): boolean {<EOL>                if (!!text.toString()) {<EOL>                    wroteToStdErr = true;<EOL>                    return oldStdErr.apply(process.stderr, arguments);<EOL>                }<EOL>                return true;<EOL>            };<EOL>        }<EOL>        process.on('<STR_LIT>', (code: number) => {<EOL>            duringFastExit = true;<EOL>            if (!global['<STR_LIT>']) { <EOL>                if (!localCache.wroteSummary) {<EOL>                    localCache.wroteSummary = true;<EOL>                    console.log('<STR_LIT>', code);<EOL>                    console.error('<STR_LIT>' +<EOL>                        '<STR_LIT>');<EOL>                    console.log('<STR_LIT>');<EOL>                    exitProcess(<NUM_LIT>);<EOL>                }<EOL>                else {<EOL>                    if (localCache.exitCode !== <NUM_LIT>) {<EOL>                        console.log(","gt":"localCache.exitCode}`<STR_LIT>;"}
{"input":"<s> function wireUpProcessErrorHandling(shouldWarningsFailBuild: boolean): void {<EOL>    if (!wiredUpErrorHandling) {<EOL>        wiredUpErrorHandling = true;<EOL>        let wroteToStdErr: boolean = false;<EOL>        if (shouldWarningsFailBuild) {<EOL>            const oldStdErr: Function = process.stderr.write;<EOL>            <EOL>            process.stderr.write = function (text: string | Buffer): boolean {<EOL>                if (!!text.toString()) {<EOL>                    wroteToStdErr = true;<EOL>                    return oldStdErr.apply(process.stderr, arguments);<EOL>                }<EOL>                return true;<EOL>            };<EOL>        }<EOL>        process.on('<STR_LIT>', (code: number) => {<EOL>            duringFastExit = true;<EOL>            if (!global['<STR_LIT>']) { <EOL>                if (!localCache.wroteSummary) {<EOL>                    localCache.wroteSummary = true;<EOL>                    console.log('<STR_LIT>', code);<EOL>                    console.error('<STR_LIT>' +<EOL>                        '<STR_LIT>');<EOL>                    console.log('<STR_LIT>');<EOL>                    exitProcess(<NUM_LIT>);<EOL>                }<EOL>                else {<EOL>                    if (localCache.exitCode !== <NUM_LIT>) {<EOL>                        console.log(`<STR_LIT>`);<EOL>                        exitProcess(localCache.exitCode);<EOL>                    }<EOL>                    else if (wroteToStdErr) {<EOL>                        console.error(`<STR_LIT>`);<EOL>                        console.log(`<STR_LIT>`);<EOL>                        exitProcess(<NUM_LIT>);<EOL>                    }<EOL>                }<EOL>            }<EOL>        });<EOL>        process.on('<STR_LIT>', (err: Error) => {<EOL>","gt":"console.error(err);"}
{"input":"<s> function wireUpProcessErrorHandling(shouldWarningsFailBuild: boolean): void {<EOL>    if (!wiredUpErrorHandling) {<EOL>        wiredUpErrorHandling = true;<EOL>        let wroteToStdErr: boolean = false;<EOL>        if (shouldWarningsFailBuild) {<EOL>            const oldStdErr: Function = process.stderr.write;<EOL>            <EOL>            process.stderr.write = function (text: string | Buffer): boolean {<EOL>                if (!!text.toString()) {<EOL>                    wroteToStdErr = true;<EOL>                    return oldStdErr.apply(process.stderr, arguments);<EOL>                }<EOL>                return true;<EOL>            };<EOL>        }<EOL>        process.on('<STR_LIT>', (code: number) => {<EOL>            duringFastExit = true;<EOL>            if (!global['<STR_LIT>']) { <EOL>                if (!localCache.wroteSummary) {<EOL>                    localCache.wroteSummary = true;<EOL>                    console.log('<STR_LIT>', code);<EOL>                    console.error('<STR_LIT>' +<EOL>                        '<STR_LIT>');<EOL>                    console.log('<STR_LIT>');<EOL>                    exitProcess(<NUM_LIT>);<EOL>                }<EOL>                else {<EOL>                    if (localCache.exitCode !== <NUM_LIT>) {<EOL>                        console.log(`<STR_LIT>`);<EOL>                        exitProcess(localCache.exitCode);<EOL>                    }<EOL>                    else if (wroteToStdErr) {<EOL>                        console.error(`<STR_LIT>`);<EOL>                        console.log(`<STR_LIT>`);<EOL>                        exitProcess(<NUM_LIT>);<EOL>                    }<EOL>                }<EOL>            }<EOL>        });<EOL>        process.on('<STR_LIT>', (err: Error) => {<EOL>            console.error(err);<EOL>            _writeTaskError(err);<EOL>            writeSummary(() => {<EOL>                exitProcess(","gt":"<NUM_LIT>);"}
{"input":"<s> function normalizePathForOs(path) {<EOL>    return brackets.platform === \"<STR_LIT>\" ?","gt":"path.replace(/\\//g, \"<STR_LIT>\") : path;"}
{"input":"<s> function uninstallBoardSuccess() {<EOL>","gt":"return {"}
{"input":"<s> <EOL>function toObject(val: Opaque) {<EOL>    if (val === null || val === undefined) {<EOL>","gt":"throw new TypeError('<STR_LIT>');"}
{"input":"<s> function buildMustache(path: BuilderPath | AST.Literal, params?: AST.Expression[], hash?: AST.Hash, raw?: boolean, loc?: AST.SourceLocation): AST.MustacheStatement {<EOL>    if (!AST.isLiteral(path)) {<EOL>        path = buildPath(path);<EOL>    }<EOL>","gt":"return {"}
{"input":"<s> function buildMustache(path: BuilderPath | AST.Literal, params?: AST.Expression[], hash?: AST.Hash, raw?: boolean, loc?: AST.SourceLocation): AST.MustacheStatement {<EOL>    if (!AST.isLiteral(path)) {<EOL>        path = buildPath(path);<EOL>    }<EOL>    return {<EOL>        type: \"<STR_LIT>\",<EOL>        path,<EOL>        params: params || [],<EOL>        hash: hash || buildHash([]),<EOL>","gt":"escaped: !raw,"}
{"input":"<s> /**<EOL> * Detaches the given terminal from the given socket<EOL> *<EOL> * @param term The terminal to be detached from the given socket.<EOL> * @param socket The socket from which to detach the current terminal.<EOL> */<EOL>export function terminadoDetach(term: Terminal, socket: WebSocket): void {<EOL>    const addonTerminal = <ITerminadoAddonTerminal>term;<EOL>    addonTerminal.off('<STR_LIT>', addonTerminal.__sendData);<EOL>    socket = (","gt":"typeof socket === '<STR_LIT>') ? addonTerminal.__socket : socket;"}
{"input":"<s> function getEmbeddedDocument(document: TextDocument, contents: EmbeddedRegion[], languageId: string, ignoreAttributeValues: boolean): TextDocument {<EOL>    let currentPos = <NUM_LIT>;<EOL>    let oldContent = document.getText();<EOL>    let result = '<STR_LIT>';<EOL>    let lastSuffix = '<STR_LIT>';<EOL>","gt":"for (let c of contents) {"}
{"input":"<s> function defaultGetWorkerUrl(workerId: string, label: string): string {<EOL>","gt":"return require.toUrl('<STR_LIT>' + workerId);"}
{"input":"<s> <EOL><EOL>function foo() {<EOL>    return","gt":"\"<STR_LIT>\";"}
{"input":"<s> export function writeResultToStore({ dataId, result, document, storeFactory = defaultNormalizedCacheFactory, store = storeFactory(), variables, dataIdFromObject, fragmentMatcherFunction, }: {<EOL>    dataId: string;<EOL>    result: any;<EOL>    document: DocumentNode;<EOL>    store?: NormalizedCache;<EOL>    storeFactory?: NormalizedCacheFactory;<EOL>    variables?: Object;<EOL>    dataIdFromObject?: IdGetter;<EOL>    fragmentMatcherFunction?: FragmentMatcher;<EOL>}): NormalizedCache {<EOL>    <EOL>    const operationDefinition = getOperationDefinition(document);<EOL>    const selectionSet = operationDefinition.selectionSet;<EOL>    const fragmentMap = createFragmentMap(getFragmentDefinitions(document));<EOL>    variables = assign({},","gt":"getDefaultValues(operationDefinition), variables);"}
{"input":"<s> export function writeResultToStore({ dataId, result, document, storeFactory = defaultNormalizedCacheFactory, store = storeFactory(), variables, dataIdFromObject, fragmentMatcherFunction, }: {<EOL>    dataId: string;<EOL>    result: any;<EOL>    document: DocumentNode;<EOL>    store?: NormalizedCache;<EOL>    storeFactory?: NormalizedCacheFactory;<EOL>    variables?: Object;<EOL>    dataIdFromObject?: IdGetter;<EOL>    fragmentMatcherFunction?: FragmentMatcher;<EOL>}): NormalizedCache {<EOL>    <EOL>    const operationDefinition = getOperationDefinition(document);<EOL>    const selectionSet = operationDefinition.selectionSet;<EOL>    const fragmentMap = createFragmentMap(getFragmentDefinitions(document));<EOL>    variables = assign({}, getDefaultValues(operationDefinition), variables);<EOL>    try {<EOL>        return writeSelectionSetToStore({<EOL>","gt":"result,"}
{"input":"<s> export function writeResultToStore({ dataId, result, document, storeFactory = defaultNormalizedCacheFactory, store = storeFactory(), variables, dataIdFromObject, fragmentMatcherFunction, }: {<EOL>    dataId: string;<EOL>    result: any;<EOL>    document: DocumentNode;<EOL>    store?: NormalizedCache;<EOL>    storeFactory?: NormalizedCacheFactory;<EOL>    variables?: Object;<EOL>    dataIdFromObject?: IdGetter;<EOL>    fragmentMatcherFunction?: FragmentMatcher;<EOL>}): NormalizedCache {<EOL>    <EOL>    const operationDefinition = getOperationDefinition(document);<EOL>    const selectionSet = operationDefinition.selectionSet;<EOL>    const fragmentMap = createFragmentMap(getFragmentDefinitions(document));<EOL>    variables = assign({}, getDefaultValues(operationDefinition), variables);<EOL>    try {<EOL>        return writeSelectionSetToStore({<EOL>            result,<EOL>            dataId,<EOL>            selectionSet,<EOL>            context: {<EOL>                store,<EOL>","gt":"storeFactory,"}
{"input":"<s> function createApp(options: CreateAppOptions = {}) {<EOL>    const app = new koa();<EOL>    const router = new koaRouter();<EOL>    options.graphqlOptions = options.graphqlOptions || { schema: Schema };<EOL>    if (!options.excludeParser) {<EOL>        app.","gt":"use(koaBody());"}
{"input":"<s> function createApp(options: CreateAppOptions = {}) {<EOL>    const app = new koa();<EOL>    const router = new koaRouter();<EOL>    options.graphqlOptions = options.graphqlOptions || { schema: Schema };<EOL>    if (!options.excludeParser) {<EOL>        app.use(koaBody());<EOL>    }<EOL>    if (options.graphiqlOptions) {<EOL>        router.get('<STR_LIT>', graphiqlKoa(options.graphiqlOptions));<EOL>    }<EOL>    router.get('<STR_LIT>', graphqlKoa(options.graphqlOptions));<EOL>","gt":"router.post('<STR_LIT>', graphqlKoa(options.graphqlOptions));"}
{"input":"<s> export function withSubtractedBy<T, S extends Constructor<MotionMathOperable<T>>>(superclass: S): S & Constructor<MotionSubtractable<T>> {<EOL>    return class extends superclass implements MotionSubtractable<T> {<EOL>        /**<EOL>         * Subtracts the provided value from the upstream value and emits the<EOL>         * result.<EOL>         */<EOL>        subtractedBy<U extends T & (Point2D | number)>(kwargs: SubtractedByArgs<U>): ObservableWithMotionOperators<U>;<EOL>        subtractedBy<U extends T & (Point2D | number)>(value$: SubtractedByValue<U>): ObservableWithMotionOperators<U>;<EOL>        subtractedBy<U extends T & (Point2D | number)>({ value$, ...","gt":"reactiveMapOptions }: SubtractedByArgs<U>): ObservableWithMotionOperators<U> {"}
{"input":"<s> export function withSubtractedBy<T, S extends Constructor<MotionMathOperable<T>>>(superclass: S): S & Constructor<MotionSubtractable<T>> {<EOL>    return class extends superclass implements MotionSubtractable<T> {<EOL>        /**<EOL>         * Subtracts the provided value from the upstream value and emits the<EOL>         * result.<EOL>         */<EOL>        subtractedBy<U extends T & (Point2D | number)>(kwargs: SubtractedByArgs<U>): ObservableWithMotionOperators<U>;<EOL>        subtractedBy<U extends T & (Point2D | number)>(value$: SubtractedByValue<U>): ObservableWithMotionOperators<U>;<EOL>        subtractedBy<U extends T & (Point2D | number)>({ value$, ...reactiveMapOptions }: SubtractedByArgs<U>): ObservableWithMotionOperators<U> {<EOL>            if (!isDefined(value$)) {<EOL>                value$ = arguments[<NUM_LIT>];<EOL>            }<EOL>","gt":"return this._mathOperator({"}
{"input":"<s> export function withSubtractedBy<T, S extends Constructor<MotionMathOperable<T>>>(superclass: S): S & Constructor<MotionSubtractable<T>> {<EOL>    return class extends superclass implements MotionSubtractable<T> {<EOL>        /**<EOL>         * Subtracts the provided value from the upstream value and emits the<EOL>         * result.<EOL>         */<EOL>        subtractedBy<U extends T & (Point2D | number)>(kwargs: SubtractedByArgs<U>): ObservableWithMotionOperators<U>;<EOL>        subtractedBy<U extends T & (Point2D | number)>(value$: SubtractedByValue<U>): ObservableWithMotionOperators<U>;<EOL>        subtractedBy<U extends T & (Point2D | number)>({ value$, ...reactiveMapOptions }: SubtractedByArgs<U>): ObservableWithMotionOperators<U> {<EOL>            if (!isDefined(value$)) {<EOL>                value$ = arguments[<NUM_LIT>];<EOL>            }<EOL>            return this._mathOperator({<EOL>                operation: (upstream, value) => upstream - value,<EOL>                value$,<EOL>                ...","gt":"reactiveMapOptions,"}
{"input":"<s> <EOL><EOL><EOL><EOL><EOL>export function decycle(object, replacer) {<EOL>    \"<STR_LIT>\";<EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    var objects = new WeakMap(); <EOL>    return (function derez(","gt":"value, path) {"}
{"input":"<s> <EOL><EOL><EOL><EOL><EOL>export function decycle(object, replacer) {<EOL>    \"<STR_LIT>\";<EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    var objects = new WeakMap(); <EOL>    return (function derez(value, path) {<EOL>        <EOL>        var old_path; <EOL>        var nu; <EOL>        <EOL>        if (replacer !== undefined) {<EOL>            value = replacer(value);<EOL>        }<EOL>        <EOL>        <EOL>        if (typeof value === \"<STR_LIT>\" && value !== null &&<EOL>            !(value instanceof Boolean) &&<EOL>            !(value instanceof Date) &&<EOL>            !(value instanceof Number) &&<EOL>            !(value instanceof","gt":"RegExp) &&"}
{"input":"<s> <EOL><EOL><EOL><EOL><EOL>export function decycle(object, replacer) {<EOL>    \"<STR_LIT>\";<EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    var objects = new WeakMap(); <EOL>    return (function derez(value, path) {<EOL>        <EOL>        var old_path; <EOL>        var nu; <EOL>        <EOL>        if (replacer !== undefined) {<EOL>            value = replacer(value);<EOL>        }<EOL>        <EOL>        <EOL>        if (typeof value === \"<STR_LIT>\" && value !== null &&<EOL>            !(value instanceof Boolean) &&<EOL>            !(value instanceof Date) &&<EOL>            !(value instanceof Number) &&<EOL>            !(value instanceof RegExp) &&<EOL>            !(value instanceof String)) {<EOL>            <EOL>            <EOL>            <EOL>            old_path = objects.get(value);<EOL>            if (old_path !==","gt":"undefined) {"}
{"input":"<s> <EOL><EOL><EOL><EOL><EOL>export function decycle(object, replacer) {<EOL>    \"<STR_LIT>\";<EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    var objects = new WeakMap(); <EOL>    return (function derez(value, path) {<EOL>        <EOL>        var old_path; <EOL>        var nu; <EOL>        <EOL>        if (replacer !== undefined) {<EOL>            value = replacer(value);<EOL>        }<EOL>        <EOL>        <EOL>        if (typeof value === \"<STR_LIT>\" && value !== null &&<EOL>            !(value instanceof Boolean) &&<EOL>            !(value instanceof Date) &&<EOL>            !(value instanceof Number) &&<EOL>            !(value instanceof RegExp) &&<EOL>            !(value instanceof String)) {<EOL>            <EOL>            <EOL>            <EOL>            old_path = objects.get(value);<EOL>            if (old_path !== undefined) {<EOL>                return { $ref: old_path };<EOL>            }<EOL>            <EOL>            objects.set(value, path);<EOL>            <EOL>            if (Array.isArray(value)) {<EOL>","gt":"nu = [];"}
{"input":"<s> <EOL><EOL><EOL><EOL><EOL>export function decycle(object, replacer) {<EOL>    \"<STR_LIT>\";<EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    var objects = new WeakMap(); <EOL>    return (function derez(value, path) {<EOL>        <EOL>        var old_path; <EOL>        var nu; <EOL>        <EOL>        if (replacer !== undefined) {<EOL>            value = replacer(value);<EOL>        }<EOL>        <EOL>        <EOL>        if (typeof value === \"<STR_LIT>\" && value !== null &&<EOL>            !(value instanceof Boolean) &&<EOL>            !(value instanceof Date) &&<EOL>            !(value instanceof Number) &&<EOL>            !(value instanceof RegExp) &&<EOL>            !(value instanceof String)) {<EOL>            <EOL>            <EOL>            <EOL>            old_path = objects.get(value);<EOL>            if (old_path !== undefined) {<EOL>                return { $ref: old_path };<EOL>            }<EOL>            <EOL>            objects.set(value, path);<EOL>            <EOL>            if (Array.isArray(value)) {<EOL>                nu = [];<EOL>                value.forEach(function (element, i) {<EOL>                    nu[i] = derez(element, path + \"<STR_LIT>\" + i + \"<STR_LIT>\");<EOL>                });<EOL>            }<EOL>","gt":"else {"}
{"input":"<s> <EOL><EOL><EOL><EOL><EOL>export function decycle(object, replacer) {<EOL>    \"<STR_LIT>\";<EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    var objects = new WeakMap(); <EOL>    return (function derez(value, path) {<EOL>        <EOL>        var old_path; <EOL>        var nu; <EOL>        <EOL>        if (replacer !== undefined) {<EOL>            value = replacer(value);<EOL>        }<EOL>        <EOL>        <EOL>        if (typeof value === \"<STR_LIT>\" && value !== null &&<EOL>            !(value instanceof Boolean) &&<EOL>            !(value instanceof Date) &&<EOL>            !(value instanceof Number) &&<EOL>            !(value instanceof RegExp) &&<EOL>            !(value instanceof String)) {<EOL>            <EOL>            <EOL>            <EOL>            old_path = objects.get(value);<EOL>            if (old_path !== undefined) {<EOL>                return { $ref: old_path };<EOL>            }<EOL>            <EOL>            objects.set(value, path);<EOL>            <EOL>            if (Array.isArray(value)) {<EOL>                nu = [];<EOL>                value.forEach(function (element, i) {<EOL>                    nu[i] = derez(element, path + \"<STR_LIT>\" + i + \"<STR_LIT>\");<EOL>                });<EOL>            }<EOL>            else {<EOL>                <EOL>                nu = {};<EOL>                Object.keys(","gt":"value).forEach(function (name) {"}
{"input":"<s> <EOL>function getCoverageData(coverageVariable: string) {<EOL>    let coverageData = (function (this: any) {<EOL>","gt":"return this;"}
{"input":"<s> export function createSuite<S extends typeof Suite, T extends typeof Test>(name: string, parent: Suite, descriptor: ObjectSuiteDescriptor | Tests, SuiteClass: S, TestClass: T) {<EOL>    let options: SuiteOptions = { name: name, parent };<EOL>    let","gt":"tests: Tests;"}
{"input":"<s> export function createSuite<S extends typeof Suite, T extends typeof Test>(name: string, parent: Suite, descriptor: ObjectSuiteDescriptor | Tests, SuiteClass: S, TestClass: T) {<EOL>    let options: SuiteOptions = { name: name, parent };<EOL>    let tests: Tests;<EOL>    <EOL>    <EOL>","gt":"if (isObjectSuiteDescriptor(descriptor)) {"}
{"input":"<s> export function createSuite<S extends typeof Suite, T extends typeof Test>(name: string, parent: Suite, descriptor: ObjectSuiteDescriptor | Tests, SuiteClass: S, TestClass: T) {<EOL>    let options: SuiteOptions = { name: name, parent };<EOL>    let tests: Tests;<EOL>    <EOL>    <EOL>    if (isObjectSuiteDescriptor(descriptor)) {<EOL>        const keys = Object.keys(descriptor).filter(key => key !== '<STR_LIT>');<EOL>","gt":"for (const key of keys) {"}
{"input":"<s> export function createSuite<S extends typeof Suite, T extends typeof Test>(name: string, parent: Suite, descriptor: ObjectSuiteDescriptor | Tests, SuiteClass: S, TestClass: T) {<EOL>    let options: SuiteOptions = { name: name, parent };<EOL>    let tests: Tests;<EOL>    <EOL>    <EOL>    if (isObjectSuiteDescriptor(descriptor)) {<EOL>        const keys = Object.keys(descriptor).filter(key => key !== '<STR_LIT>');<EOL>        for (const key of keys) {<EOL>            let optionsKey = <keyof SuiteOptions>key;<EOL>            <EOL>            if (key ===","gt":"'<STR_LIT>') {"}
{"input":"<s> export function createSuite<S extends typeof Suite, T extends typeof Test>(name: string, parent: Suite, descriptor: ObjectSuiteDescriptor | Tests, SuiteClass: S, TestClass: T) {<EOL>    let options: SuiteOptions = { name: name, parent };<EOL>    let tests: Tests;<EOL>    <EOL>    <EOL>    if (isObjectSuiteDescriptor(descriptor)) {<EOL>        const keys = Object.keys(descriptor).filter(key => key !== '<STR_LIT>');<EOL>        for (const key of keys) {<EOL>            let optionsKey = <keyof SuiteOptions>key;<EOL>            <EOL>            if (key === '<STR_LIT>') {<EOL>                parent.executor.emit('<STR_LIT>', {<EOL>                    original: '<STR_LIT>',<EOL>                    replacement: '<STR_LIT>'<EOL>                });<EOL>                optionsKey =","gt":"'<STR_LIT>';"}
{"input":"<s> export function createSuite<S extends typeof Suite, T extends typeof Test>(name: string, parent: Suite, descriptor: ObjectSuiteDescriptor | Tests, SuiteClass: S, TestClass: T) {<EOL>    let options: SuiteOptions = { name: name, parent };<EOL>    let tests: Tests;<EOL>    <EOL>    <EOL>    if (isObjectSuiteDescriptor(descriptor)) {<EOL>        const keys = Object.keys(descriptor).filter(key => key !== '<STR_LIT>');<EOL>        for (const key of keys) {<EOL>            let optionsKey = <keyof SuiteOptions>key;<EOL>            <EOL>            if (key === '<STR_LIT>') {<EOL>                parent.executor.emit('<STR_LIT>', {<EOL>                    original: '<STR_LIT>',<EOL>                    replacement: '<STR_LIT>'<EOL>                });<EOL>                optionsKey = '<STR_LIT>';<EOL>            }<EOL>            else if (key === '<STR_LIT>') {<EOL>                parent.executor.emit('<STR_LIT>', {<EOL>                    original: '<STR_LIT>',<EOL>                    replacement:","gt":"'<STR_LIT>'"}
{"input":"<s> export function createSuite<S extends typeof Suite, T extends typeof Test>(name: string, parent: Suite, descriptor: ObjectSuiteDescriptor | Tests, SuiteClass: S, TestClass: T) {<EOL>    let options: SuiteOptions = { name: name, parent };<EOL>    let tests: Tests;<EOL>    <EOL>    <EOL>    if (isObjectSuiteDescriptor(descriptor)) {<EOL>        const keys = Object.keys(descriptor).filter(key => key !== '<STR_LIT>');<EOL>        for (const key of keys) {<EOL>            let optionsKey = <keyof SuiteOptions>key;<EOL>            <EOL>            if (key === '<STR_LIT>') {<EOL>                parent.executor.emit('<STR_LIT>', {<EOL>                    original: '<STR_LIT>',<EOL>                    replacement: '<STR_LIT>'<EOL>                });<EOL>                optionsKey = '<STR_LIT>';<EOL>            }<EOL>            else if (key === '<STR_LIT>') {<EOL>                parent.executor.emit('<STR_LIT>', {<EOL>                    original: '<STR_LIT>',<EOL>                    replacement: '<STR_LIT>'<EOL>                });<EOL>                optionsKey = '<STR_LIT>';<EOL>            }<EOL>            options[optionsKey] = <any>descriptor[<keyof ObjectSuiteDescriptor>key];<EOL>        }<EOL>        tests = descriptor.tests;<EOL>    }<EOL>    else {<EOL>        tests = descriptor;<EOL>    }<EOL>    const suite = new SuiteClass(options);<EOL>    Object.keys(tests)<EOL>        .map(name => {<EOL>        if (name === '<STR_LIT>' ||<EOL>            name === '<STR_LIT>' ||<EOL>            name === '<STR_LIT>' ||<EOL>            name === '<STR_LIT>' ||<EOL>            name ===","gt":"'<STR_LIT>' ||"}
{"input":"<s> export function createSuite<S extends typeof Suite, T extends typeof Test>(name: string, parent: Suite, descriptor: ObjectSuiteDescriptor | Tests, SuiteClass: S, TestClass: T) {<EOL>    let options: SuiteOptions = { name: name, parent };<EOL>    let tests: Tests;<EOL>    <EOL>    <EOL>    if (isObjectSuiteDescriptor(descriptor)) {<EOL>        const keys = Object.keys(descriptor).filter(key => key !== '<STR_LIT>');<EOL>        for (const key of keys) {<EOL>            let optionsKey = <keyof SuiteOptions>key;<EOL>            <EOL>            if (key === '<STR_LIT>') {<EOL>                parent.executor.emit('<STR_LIT>', {<EOL>                    original: '<STR_LIT>',<EOL>                    replacement: '<STR_LIT>'<EOL>                });<EOL>                optionsKey = '<STR_LIT>';<EOL>            }<EOL>            else if (key === '<STR_LIT>') {<EOL>                parent.executor.emit('<STR_LIT>', {<EOL>                    original: '<STR_LIT>',<EOL>                    replacement: '<STR_LIT>'<EOL>                });<EOL>                optionsKey = '<STR_LIT>';<EOL>            }<EOL>            options[optionsKey] = <any>descriptor[<keyof ObjectSuiteDescriptor>key];<EOL>        }<EOL>        tests = descriptor.tests;<EOL>    }<EOL>    else {<EOL>        tests = descriptor;<EOL>    }<EOL>    const suite = new SuiteClass(options);<EOL>    Object.keys(tests)<EOL>        .map(name => {<EOL>        if (name === '<STR_LIT>' ||<EOL>            name === '<STR_LIT>' ||<EOL>            name === '<STR_LIT>' ||<EOL>            name === '<STR_LIT>' ||<EOL>            name === '<STR_LIT>' ||<EOL>            name === '<STR_LIT>') {<EOL>            parent.executor.log(`<STR_LIT>`);<EOL>        }<EOL>        const thing = tests[name];<EOL>        if (isTestFunction(","gt":"thing)) {"}
{"input":"<s> function _show() {<EOL>    const templateArgs = {<EOL>        config: pullConfig,<EOL>        mode: \"<STR_LIT>\",<EOL>        modeLabel: Strings.PULL_FROM,<EOL>","gt":"Strings"}
{"input":"<s> function _show() {<EOL>    const templateArgs = {<EOL>        config: pullConfig,<EOL>        mode: \"<STR_LIT>\",<EOL>        modeLabel: Strings.PULL_FROM,<EOL>        Strings<EOL>    };<EOL>    const compiledTemplate = Mustache.render(template, templateArgs, {<EOL>        credentials:","gt":"credentialsTemplate,"}
{"input":"<s> function _show() {<EOL>    const templateArgs = {<EOL>        config: pullConfig,<EOL>        mode: \"<STR_LIT>\",<EOL>        modeLabel: Strings.PULL_FROM,<EOL>        Strings<EOL>    };<EOL>    const compiledTemplate = Mustache.render(template, templateArgs, {<EOL>        credentials: credentialsTemplate,<EOL>        remotes: remotesTemplate<EOL>    });<EOL>    const dialog = Dialogs.showModalDialogUsingTemplate(compiledTemplate);<EOL>    const $dialog = dialog.getElement();<EOL>    _attachEvents(","gt":"$dialog);"}
{"input":"<s> function _show() {<EOL>    const templateArgs = {<EOL>        config: pullConfig,<EOL>        mode: \"<STR_LIT>\",<EOL>        modeLabel: Strings.PULL_FROM,<EOL>        Strings<EOL>    };<EOL>    const compiledTemplate = Mustache.render(template, templateArgs, {<EOL>        credentials: credentialsTemplate,<EOL>        remotes: remotesTemplate<EOL>    });<EOL>    const dialog = Dialogs.showModalDialogUsingTemplate(compiledTemplate);<EOL>    const $dialog = dialog.getElement();<EOL>    _attachEvents($dialog);<EOL>    dialog.done((buttonId) => {<EOL>        if (buttonId === \"<STR_LIT>\") {<EOL>            RemoteCommon.collectValues(pullConfig, $dialog);<EOL>            Preferences.set(\"<STR_LIT>\", pullConfig.strategy);<EOL>            defer.","gt":"resolve(pullConfig);"}
{"input":"<s> /**<EOL> * Sets the selection of the given element<EOL> *<EOL> * @param {any} element<EOL> * @param {any} start<EOL> * @param {any} end<EOL> */<EOL>export function setSelection(element: HTMLTextAreaElement, start: number, end: number): void {<EOL>    if (!element)<EOL>        throw Error(\"<STR_LIT>\");<EOL>","gt":"element.focus();"}
{"input":"<s> function statusToResponse(p: PermissionStatus): e.PermissionResponses {<EOL>    switch (p) {<EOL>        case PermissionStatus.NotYetPrompted:<EOL>        case PermissionStatus.Denied:<EOL>","gt":"return e.PermissionResponses.Denied;"}
{"input":"<s> function statusToResponse(p: PermissionStatus): e.PermissionResponses {<EOL>    switch (p) {<EOL>        case PermissionStatus.NotYetPrompted:<EOL>        case PermissionStatus.Denied:<EOL>            return e.PermissionResponses.Denied;<EOL>        case PermissionStatus.Granted:<EOL>            return e.PermissionResponses.Granted;<EOL>        case PermissionStatus.NotAvailable:<EOL>","gt":"default:"}
{"input":"<s> function off(el: any, type: string, handler: (event: Event) => any, capture: boolean = false): void {<EOL>    el.removeEventListener(type,","gt":"handler, capture);"}
{"input":"<s> export function before(fn: SuiteProperties['<STR_LIT>']) {<EOL>    if (!currentSuite) {<EOL>        throw","gt":"new Error('<STR_LIT>');"}
{"input":"<s> function decode(value: string): string {<EOL>    return value.split('<STR_LIT>').","gt":"reverse().join('<STR_LIT>');"}
{"input":"<s> /**<EOL> * Get the parent directory name of a path<EOL> */<EOL>export function dirname(path: string) {<EOL>    const sep = getPathSep(path);<EOL>    const parts = normalize(path).split('<STR_LIT>');<EOL>","gt":"parts.pop();"}
{"input":"<s> export function loadFile(module, filename) {<EOL>    var","gt":"js = t.transpile(fs.readFileSync(filename, '<STR_LIT>'));"}
{"input":"<s> /** Throws an error if the user supplied an invalid tooltip position. */<EOL>export function throwMd2TooltipInvalidPositionError(position: string) {<EOL>    throw new Error(","gt":"position}\"<STR_LIT>;"}
{"input":"<s> function writeFile(filePath: string, content: string) {<EOL>    fs.writeFileSync(","gt":"__dirname + '<STR_LIT>' + filePath, content);"}
{"input":"<s> /**<EOL> * Constructs a new ts.CompilerHost that overlays sources in substituteSource<EOL> * over another ts.CompilerHost.<EOL> *<EOL> * @param substituteSource A map of source file name -> overlay source text.<EOL> */<EOL>export function createSourceReplacingCompilerHost(substituteSource: Map<string, string>, delegate: ts.CompilerHost): ts.CompilerHost {<EOL>    return {<EOL>        getSourceFile,<EOL>        getCancellationToken: delegate.getCancellationToken,<EOL>        getDefaultLibFileName: delegate.getDefaultLibFileName,<EOL>        writeFile: delegate.","gt":"writeFile,"}
{"input":"<s> /**<EOL> * Constructs a new ts.CompilerHost that overlays sources in substituteSource<EOL> * over another ts.CompilerHost.<EOL> *<EOL> * @param substituteSource A map of source file name -> overlay source text.<EOL> */<EOL>export function createSourceReplacingCompilerHost(substituteSource: Map<string, string>, delegate: ts.CompilerHost): ts.CompilerHost {<EOL>    return {<EOL>        getSourceFile,<EOL>        getCancellationToken: delegate.getCancellationToken,<EOL>        getDefaultLibFileName: delegate.getDefaultLibFileName,<EOL>        writeFile: delegate.writeFile,<EOL>        getCurrentDirectory: delegate.getCurrentDirectory,<EOL>        getCanonicalFileName: delegate.","gt":"getCanonicalFileName,"}
{"input":"<s> /**<EOL> * Constructs a new ts.CompilerHost that overlays sources in substituteSource<EOL> * over another ts.CompilerHost.<EOL> *<EOL> * @param substituteSource A map of source file name -> overlay source text.<EOL> */<EOL>export function createSourceReplacingCompilerHost(substituteSource: Map<string, string>, delegate: ts.CompilerHost): ts.CompilerHost {<EOL>    return {<EOL>        getSourceFile,<EOL>        getCancellationToken: delegate.getCancellationToken,<EOL>        getDefaultLibFileName: delegate.getDefaultLibFileName,<EOL>        writeFile: delegate.writeFile,<EOL>        getCurrentDirectory: delegate.getCurrentDirectory,<EOL>        getCanonicalFileName: delegate.getCanonicalFileName,<EOL>        useCaseSensitiveFileNames: delegate.useCaseSensitiveFileNames,<EOL>        getNewLine: delegate.getNewLine,<EOL>        fileExists: delegate.fileExists,<EOL>        readFile: delegate.readFile,<EOL>","gt":"directoryExists: delegate.directoryExists,"}
{"input":"<s> /**<EOL> * Constructs a new ts.CompilerHost that overlays sources in substituteSource<EOL> * over another ts.CompilerHost.<EOL> *<EOL> * @param substituteSource A map of source file name -> overlay source text.<EOL> */<EOL>export function createSourceReplacingCompilerHost(substituteSource: Map<string, string>, delegate: ts.CompilerHost): ts.CompilerHost {<EOL>    return {<EOL>        getSourceFile,<EOL>        getCancellationToken: delegate.getCancellationToken,<EOL>        getDefaultLibFileName: delegate.getDefaultLibFileName,<EOL>        writeFile: delegate.writeFile,<EOL>        getCurrentDirectory: delegate.getCurrentDirectory,<EOL>        getCanonicalFileName: delegate.getCanonicalFileName,<EOL>        useCaseSensitiveFileNames: delegate.useCaseSensitiveFileNames,<EOL>        getNewLine: delegate.getNewLine,<EOL>        fileExists: delegate.fileExists,<EOL>        readFile: delegate.readFile,<EOL>        directoryExists: delegate.directoryExists,<EOL>        getDirectories: delegate.getDirectories,<EOL>    };<EOL>    function getSourceFile(fileName: string, languageVersion: ts.ScriptTarget, onError?: (message: string) => void): ts.SourceFile {<EOL>        let path: string = ts.sys.resolvePath(fileName);<EOL>        let sourceText = substituteSource.","gt":"get(path);"}
{"input":"<s> function allDirty<T>(refs: Reference<T>[], newValue: T) {<EOL>    refs.","gt":"forEach(function (ref) { isDirty(ref, newValue); });"}
{"input":"<s> async function fn10(x) {<EOL>","gt":"var { z: { x } = y } = y;"}
{"input":"<s> function isDataProcessed(dataId: string, field: FieldNode | SelectionSetNode, processedData?: {<EOL>    [x: string]: (FieldNode | SelectionSetNode)[];<EOL>}): boolean {<EOL>    if (!processedData) {<EOL>        return false;<EOL>    }<EOL>    if (processedData[dataId]) {<EOL>        if (","gt":"processedData[dataId].indexOf(field) >= <NUM_LIT>) {"}
{"input":"<s> function isDataProcessed(dataId: string, field: FieldNode | SelectionSetNode, processedData?: {<EOL>    [x: string]: (FieldNode | SelectionSetNode)[];<EOL>}): boolean {<EOL>    if (!processedData) {<EOL>        return false;<EOL>    }<EOL>    if (processedData[dataId]) {<EOL>        if (processedData[dataId].indexOf(field) >= <NUM_LIT>) {<EOL>            return true;<EOL>        }<EOL>        else {<EOL>            processedData[dataId].","gt":"push(field);"}
{"input":"<s> function isDataProcessed(dataId: string, field: FieldNode | SelectionSetNode, processedData?: {<EOL>    [x: string]: (FieldNode | SelectionSetNode)[];<EOL>}): boolean {<EOL>    if (!processedData) {<EOL>        return false;<EOL>    }<EOL>    if (processedData[dataId]) {<EOL>        if (processedData[dataId].indexOf(field) >= <NUM_LIT>) {<EOL>            return true;<EOL>        }<EOL>        else {<EOL>            processedData[dataId].push(field);<EOL>        }<EOL>    }<EOL>","gt":"else {"}
{"input":"<s> export function renderModule(name: string, renderTest: Constructor<RenderTest>) {<EOL>    QUnit.module(name);<EOL>    for (let prop in renderTest.prototype) {<EOL>        const test = renderTest.prototype[prop];<EOL>        if (isTestFunction(","gt":"test) && shouldRun(test)) {"}
{"input":"<s> /** Create a task that copies vendor files in the proper destination. */<EOL>export function vendorTask() {<EOL>    return () => gulpMerge(NPM_VENDOR_FILES.map(root => {<EOL>        const glob = path.join(PROJECT_ROOT,","gt":"'<STR_LIT>', root, '<STR_LIT>');"}
{"input":"<s> function g() {<EOL>    let x: string | number | boolean | RegExp | Function;<EOL>    x = \"<STR_LIT>\";<EOL>    do {<EOL>        if (cond) {<EOL>            x =","gt":"<NUM_LIT>;"}
{"input":"<s> function getQueriesFromTree<Cache>({ rootElement, rootContext = {} }: QueryTreeArgument<Cache>, fetchRoot: boolean = true): QueryTreeResult<Cache>[] {<EOL>    const queries: QueryTreeResult<Cache>[] = [];<EOL>    walkTree(rootElement, rootContext, (element, instance, context) => {<EOL>        const skipRoot = !fetchRoot && element === rootElement;<EOL>        if (skipRoot)<EOL>","gt":"return;"}
{"input":"<s> function getQueriesFromTree<Cache>({ rootElement, rootContext = {} }: QueryTreeArgument<Cache>, fetchRoot: boolean = true): QueryTreeResult<Cache>[] {<EOL>    const queries: QueryTreeResult<Cache>[] = [];<EOL>    walkTree(rootElement, rootContext, (element, instance, context) => {<EOL>        const skipRoot = !fetchRoot && element === rootElement;<EOL>        if (skipRoot)<EOL>            return;<EOL>        if (instance && isReactElement(element) && hasFetchDataFunction(instance)) {<EOL>            const query = instance.fetchData();<EOL>            if (isPromise<Object>(query)) {<EOL>                queries.","gt":"push({ query, element, context });"}
{"input":"<s> function _execNpmPublish(label: string): Promise<{}> {<EOL>    const packageDir = DIST_COMPONENTS_ROOT;<EOL>    if (!statSync(packageDir).isDirectory()) {<EOL>","gt":"return;"}
{"input":"<s> function _execNpmPublish(label: string): Promise<{}> {<EOL>    const packageDir = DIST_COMPONENTS_ROOT;<EOL>    if (!statSync(packageDir).isDirectory()) {<EOL>        return;<EOL>    }<EOL>    if (!existsSync(path.join(packageDir, '<STR_LIT>'))) {<EOL>        throw new Error(`<STR_LIT>`);<EOL>    }<EOL>    process.chdir(packageDir);<EOL>    console.log(`<STR_LIT>`);<EOL>    const command = '<STR_LIT>';<EOL>    const args = [","gt":"'<STR_LIT>', '<STR_LIT>', '<STR_LIT>', label ? `<STR_LIT>` : undefined, label || undefined];"}
{"input":"<s> function _execNpmPublish(label: string): Promise<{}> {<EOL>    const packageDir = DIST_COMPONENTS_ROOT;<EOL>    if (!statSync(packageDir).isDirectory()) {<EOL>        return;<EOL>    }<EOL>    if (!existsSync(path.join(packageDir, '<STR_LIT>'))) {<EOL>        throw new Error(`<STR_LIT>`);<EOL>    }<EOL>    process.chdir(packageDir);<EOL>    console.log(`<STR_LIT>`);<EOL>    const command = '<STR_LIT>';<EOL>    const args = ['<STR_LIT>', '<STR_LIT>', '<STR_LIT>', label ? `<STR_LIT>` : undefined, label || undefined];<EOL>    return new Promise((resolve, reject) => {<EOL>        console.log(`<STR_LIT>`);<EOL>","gt":"if (argv['<STR_LIT>']) {"}
{"input":"<s> function _execNpmPublish(label: string): Promise<{}> {<EOL>    const packageDir = DIST_COMPONENTS_ROOT;<EOL>    if (!statSync(packageDir).isDirectory()) {<EOL>        return;<EOL>    }<EOL>    if (!existsSync(path.join(packageDir, '<STR_LIT>'))) {<EOL>        throw new Error(`<STR_LIT>`);<EOL>    }<EOL>    process.chdir(packageDir);<EOL>    console.log(`<STR_LIT>`);<EOL>    const command = '<STR_LIT>';<EOL>    const args = ['<STR_LIT>', '<STR_LIT>', '<STR_LIT>', label ? `<STR_LIT>` : undefined, label || undefined];<EOL>    return new Promise((resolve, reject) => {<EOL>        console.log(`<STR_LIT>`);<EOL>        if (argv['<STR_LIT>']) {<EOL>            resolve();<EOL>            return;<EOL>        }<EOL>        const childProcess = spawn(","gt":"command, args);"}
{"input":"<s> function _execNpmPublish(label: string): Promise<{}> {<EOL>    const packageDir = DIST_COMPONENTS_ROOT;<EOL>    if (!statSync(packageDir).isDirectory()) {<EOL>        return;<EOL>    }<EOL>    if (!existsSync(path.join(packageDir, '<STR_LIT>'))) {<EOL>        throw new Error(`<STR_LIT>`);<EOL>    }<EOL>    process.chdir(packageDir);<EOL>    console.log(`<STR_LIT>`);<EOL>    const command = '<STR_LIT>';<EOL>    const args = ['<STR_LIT>', '<STR_LIT>', '<STR_LIT>', label ? `<STR_LIT>` : undefined, label || undefined];<EOL>    return new Promise((resolve, reject) => {<EOL>        console.log(`<STR_LIT>`);<EOL>        if (argv['<STR_LIT>']) {<EOL>            resolve();<EOL>            return;<EOL>        }<EOL>        const childProcess = spawn(command, args);<EOL>        childProcess.stdout.on('<STR_LIT>', (data: Buffer) => {<EOL>            console.log(`<STR_LIT>`);<EOL>        });<EOL>        childProcess.stderr.on('<STR_LIT>', (data: Buffer) => {<EOL>            console.error(`<STR_LIT>`);<EOL>        });<EOL>        childProcess.on('<STR_LIT>', (","gt":"code: number) => {"}
{"input":"<s> function isNullValue(value: ValueNode): value is NullValueNode {<EOL>    return value.","gt":"kind === '<STR_LIT>';"}
{"input":"<s> export function eliminateInterpolations(templateLiteralContents: string): string {<EOL>    const","gt":"regex = /\\$\\{[\\s\\S]+?\\}/mg;"}
{"input":"<s> export function isBoolean(obj: any): obj is boolean {<EOL>    return obj === true ||","gt":"obj === false;"}
{"input":"<s> export function overwriteDrive(sourcePath: string, destPath: string): string {<EOL>    const [val1, val2] =","gt":"this.getDrives(sourcePath, destPath);"}
{"input":"<s> export function toggleAngularPreset(disable: boolean, files: models.IFileCollection): models.IFileCollection {<EOL>    const icons = files.supported<EOL>        .filter(x => /^ng_.*\\D$/.test(x.","gt":"icon))"}
{"input":"<s> export function module(name: string): (klass: (typeof TestCase) & Constructor) => void {<EOL>    return function (klass: typeof TestCase & Constructor) {<EOL>        QUnit.module(name);<EOL>        let proto = klass.prototype as any as Dict<Opaque>;<EOL>        for (let prop","gt":"in proto) {"}
{"input":"<s> export function applyMixins(derivedCtor: any, baseCtors: any[]) {<EOL>    for (let i = <NUM_LIT>, len = baseCtors.length; i < len; i++) {<EOL>        const baseCtor = baseCtors[i];<EOL>        const propertyKeys = Object.getOwnPropertyNames(","gt":"baseCtor.prototype);"}
{"input":"<s> function processTree(sourceFile: ts.SourceFile, replacer: (node: ts.Node) => string): string {<EOL>    let code = '<STR_LIT>';<EOL>    let cursorPosition = <NUM_LIT>;<EOL>    function skip(node: ts.Node) {<EOL>        cursorPosition = node.end;<EOL>    }<EOL>    function readThrough(node: ts.Node) {<EOL>        code += sourceFile.text.slice(cursorPosition, node.pos);<EOL>        cursorPosition = node.","gt":"pos;"}
{"input":"<s> function processTree(sourceFile: ts.SourceFile, replacer: (node: ts.Node) => string): string {<EOL>    let code = '<STR_LIT>';<EOL>    let cursorPosition = <NUM_LIT>;<EOL>    function skip(node: ts.Node) {<EOL>        cursorPosition = node.end;<EOL>    }<EOL>    function readThrough(node: ts.Node) {<EOL>        code += sourceFile.text.slice(cursorPosition, node.pos);<EOL>        cursorPosition = node.pos;<EOL>    }<EOL>    function visit(node: ts.Node) {<EOL>        readThrough(node);<EOL>        const replacement = replacer(node);<EOL>        if (","gt":"replacement != null) {"}
{"input":"<s> function processTree(sourceFile: ts.SourceFile, replacer: (node: ts.Node) => string): string {<EOL>    let code = '<STR_LIT>';<EOL>    let cursorPosition = <NUM_LIT>;<EOL>    function skip(node: ts.Node) {<EOL>        cursorPosition = node.end;<EOL>    }<EOL>    function readThrough(node: ts.Node) {<EOL>        code += sourceFile.text.slice(cursorPosition, node.pos);<EOL>        cursorPosition = node.pos;<EOL>    }<EOL>    function visit(node: ts.Node) {<EOL>        readThrough(node);<EOL>        const replacement = replacer(node);<EOL>        if (replacement != null) {<EOL>            code += replacement;<EOL>            skip(node);<EOL>        }<EOL>        else {<EOL>","gt":"ts.forEachChild(node, visit);"}
{"input":"<s> /**<EOL> * Some more JSDOC<EOL> * @param something Blah blah blah<EOL> */<EOL>export function qat(something: Foo) {<EOL>","gt":"return something;"}
{"input":"<s> function isNodeKindExportAssignment(value: ts.Node): value is ts.ExportAssignment {<EOL>    return value && value.kind ===","gt":"ts.SyntaxKind.ExportAssignment;"}
{"input":"<s> function isNodeKindModuleDeclaration(value: ts.Node): value is ts.ModuleDeclaration {<EOL>    return value && value.kind === ts.","gt":"SyntaxKind.ModuleDeclaration;"}
{"input":"<s> export default function generate(options: Options): Promise<void> {<EOL>    if (Boolean(options.main) !== Boolean(options.name)) {<EOL>        if (Boolean(options.name)) {<EOL>            <EOL>            <EOL>            <EOL>            <EOL>            throw new Error(`<STR_LIT>`);<EOL>        }<EOL>        else {<EOL>            throw new Error('<STR_LIT>');<EOL>        }<EOL>    }<EOL>    const noop = function (message?: any, ...optionalParams: any[]): void { };<EOL>    const sendMessage = options.sendMessage || noop;<EOL>    const verboseMessage = options.verbose ? sendMessage : noop;<EOL>    let compilerOptions: ts.CompilerOptions = {};<EOL>    let files: string[] = options.files;<EOL>    <EOL>    if (options.project || !options.files || options.files.length === <NUM_LIT>) {<EOL>        verboseMessage(`<STR_LIT>`);<EOL>        <EOL>        <EOL>        <EOL>        <EOL>        let tsconfigFilename: string;<EOL>        if (Boolean(options.project)) {<EOL>            if (fs.lstatSync(options.project).isDirectory()) {<EOL>                tsconfigFilename = pathUtil.join(options.project, '<STR_LIT>');<EOL>            }<EOL>            else {<EOL>                <EOL>                tsconfigFilename = options.project;<EOL>            }<EOL>        }<EOL>        else {<EOL>            tsconfigFilename = pathUtil.join(options.baseDir, '<STR_LIT>');<EOL>        }<EOL>        if (fs.existsSync(tsconfigFilename)) {<EOL>","gt":"verboseMessage(`<STR_LIT>`);"}
{"input":"<s> export default function generate(options: Options): Promise<void> {<EOL>    if (Boolean(options.main) !== Boolean(options.name)) {<EOL>        if (Boolean(options.name)) {<EOL>            <EOL>            <EOL>            <EOL>            <EOL>            throw new Error(`<STR_LIT>`);<EOL>        }<EOL>        else {<EOL>            throw new Error('<STR_LIT>');<EOL>        }<EOL>    }<EOL>    const noop = function (message?: any, ...optionalParams: any[]): void { };<EOL>    const sendMessage = options.sendMessage || noop;<EOL>    const verboseMessage = options.verbose ? sendMessage : noop;<EOL>    let compilerOptions: ts.CompilerOptions = {};<EOL>    let files: string[] = options.files;<EOL>    <EOL>    if (options.project || !options.files || options.files.length === <NUM_LIT>) {<EOL>        verboseMessage(`<STR_LIT>`);<EOL>        <EOL>        <EOL>        <EOL>        <EOL>        let tsconfigFilename: string;<EOL>        if (Boolean(options.project)) {<EOL>            if (fs.lstatSync(options.project).isDirectory()) {<EOL>                tsconfigFilename = pathUtil.join(options.project, '<STR_LIT>');<EOL>            }<EOL>            else {<EOL>                <EOL>                tsconfigFilename = options.project;<EOL>            }<EOL>        }<EOL>        else {<EOL>            tsconfigFilename = pathUtil.join(options.baseDir, '<STR_LIT>');<EOL>        }<EOL>        if (fs.existsSync(tsconfigFilename)) {<EOL>            verboseMessage(`<STR_LIT>`);<EOL>            [files, compilerOptions] = getTSConfig(options, tsconfigFilename);<EOL>        }<EOL>        else {<EOL>            sendMessage(`<STR_LIT>`);<EOL>            return new Promise<void>(function (resolve,","gt":"reject) {"}
{"input":"<s> export default function generate(options: Options): Promise<void> {<EOL>    if (Boolean(options.main) !== Boolean(options.name)) {<EOL>        if (Boolean(options.name)) {<EOL>            <EOL>            <EOL>            <EOL>            <EOL>            throw new Error(`<STR_LIT>`);<EOL>        }<EOL>        else {<EOL>            throw new Error('<STR_LIT>');<EOL>        }<EOL>    }<EOL>    const noop = function (message?: any, ...optionalParams: any[]): void { };<EOL>    const sendMessage = options.sendMessage || noop;<EOL>    const verboseMessage = options.verbose ? sendMessage : noop;<EOL>    let compilerOptions: ts.CompilerOptions = {};<EOL>    let files: string[] = options.files;<EOL>    <EOL>    if (options.project || !options.files || options.files.length === <NUM_LIT>) {<EOL>        verboseMessage(`<STR_LIT>`);<EOL>        <EOL>        <EOL>        <EOL>        <EOL>        let tsconfigFilename: string;<EOL>        if (Boolean(options.project)) {<EOL>            if (fs.lstatSync(options.project).isDirectory()) {<EOL>                tsconfigFilename = pathUtil.join(options.project, '<STR_LIT>');<EOL>            }<EOL>            else {<EOL>                <EOL>                tsconfigFilename = options.project;<EOL>            }<EOL>        }<EOL>        else {<EOL>            tsconfigFilename = pathUtil.join(options.baseDir, '<STR_LIT>');<EOL>        }<EOL>        if (fs.existsSync(tsconfigFilename)) {<EOL>            verboseMessage(`<STR_LIT>`);<EOL>            [files, compilerOptions] = getTSConfig(options, tsconfigFilename);<EOL>        }<EOL>        else {<EOL>            sendMessage(`<STR_LIT>`);<EOL>            return new Promise<void>(function (resolve, reject) {<EOL>                reject(new SyntaxError('<STR_LIT>'));<EOL>            });<EOL>        }<EOL>    }<EOL>    const eol = options.eol || os.EOL;<EOL>    const nonEmptyLineStart =","gt":"new RegExp(eol + '<STR_LIT>' + eol + '<STR_LIT>', '<STR_LIT>');"}
{"input":"<s> export default function generate(options: Options): Promise<void> {<EOL>    if (Boolean(options.main) !== Boolean(options.name)) {<EOL>        if (Boolean(options.name)) {<EOL>            <EOL>            <EOL>            <EOL>            <EOL>            throw new Error(`<STR_LIT>`);<EOL>        }<EOL>        else {<EOL>            throw new Error('<STR_LIT>');<EOL>        }<EOL>    }<EOL>    const noop = function (message?: any, ...optionalParams: any[]): void { };<EOL>    const sendMessage = options.sendMessage || noop;<EOL>    const verboseMessage = options.verbose ? sendMessage : noop;<EOL>    let compilerOptions: ts.CompilerOptions = {};<EOL>    let files: string[] = options.files;<EOL>    <EOL>    if (options.project || !options.files || options.files.length === <NUM_LIT>) {<EOL>        verboseMessage(`<STR_LIT>`);<EOL>        <EOL>        <EOL>        <EOL>        <EOL>        let tsconfigFilename: string;<EOL>        if (Boolean(options.project)) {<EOL>            if (fs.lstatSync(options.project).isDirectory()) {<EOL>                tsconfigFilename = pathUtil.join(options.project, '<STR_LIT>');<EOL>            }<EOL>            else {<EOL>                <EOL>                tsconfigFilename = options.project;<EOL>            }<EOL>        }<EOL>        else {<EOL>            tsconfigFilename = pathUtil.join(options.baseDir, '<STR_LIT>');<EOL>        }<EOL>        if (fs.existsSync(tsconfigFilename)) {<EOL>            verboseMessage(`<STR_LIT>`);<EOL>            [files, compilerOptions] = getTSConfig(options, tsconfigFilename);<EOL>        }<EOL>        else {<EOL>            sendMessage(`<STR_LIT>`);<EOL>            return new Promise<void>(function (resolve, reject) {<EOL>                reject(new SyntaxError('<STR_LIT>'));<EOL>            });<EOL>        }<EOL>    }<EOL>    const eol = options.eol || os.EOL;<EOL>    const nonEmptyLineStart = new RegExp(eol + '<STR_LIT>' + eol + '<STR_LIT>', '<STR_LIT>');<EOL>    const indent = options.indent === undefined ? '<STR_LIT>' : options.indent;<EOL>    <EOL>    <EOL>    compilerOptions.declaration = true;<EOL>    compilerOptions.target = compilerOptions.target || ts.ScriptTarget.Latest; <EOL>    compilerOptions.moduleResolution = compilerOptions.moduleResolution || options.moduleResolution;<EOL>    compilerOptions.outDir = compilerOptions.outDir || options.outDir;<EOL>    <EOL>    const baseDir = pathUtil.resolve(compilerOptions.rootDir || options.project || options.baseDir);<EOL>    const outDir =","gt":"compilerOptions.outDir;"}
{"input":"<s> export default function generate(options: Options): Promise<void> {<EOL>    if (Boolean(options.main) !== Boolean(options.name)) {<EOL>        if (Boolean(options.name)) {<EOL>            <EOL>            <EOL>            <EOL>            <EOL>            throw new Error(`<STR_LIT>`);<EOL>        }<EOL>        else {<EOL>            throw new Error('<STR_LIT>');<EOL>        }<EOL>    }<EOL>    const noop = function (message?: any, ...optionalParams: any[]): void { };<EOL>    const sendMessage = options.sendMessage || noop;<EOL>    const verboseMessage = options.verbose ? sendMessage : noop;<EOL>    let compilerOptions: ts.CompilerOptions = {};<EOL>    let files: string[] = options.files;<EOL>    <EOL>    if (options.project || !options.files || options.files.length === <NUM_LIT>) {<EOL>        verboseMessage(`<STR_LIT>`);<EOL>        <EOL>        <EOL>        <EOL>        <EOL>        let tsconfigFilename: string;<EOL>        if (Boolean(options.project)) {<EOL>            if (fs.lstatSync(options.project).isDirectory()) {<EOL>                tsconfigFilename = pathUtil.join(options.project, '<STR_LIT>');<EOL>            }<EOL>            else {<EOL>                <EOL>                tsconfigFilename = options.project;<EOL>            }<EOL>        }<EOL>        else {<EOL>            tsconfigFilename = pathUtil.join(options.baseDir, '<STR_LIT>');<EOL>        }<EOL>        if (fs.existsSync(tsconfigFilename)) {<EOL>            verboseMessage(`<STR_LIT>`);<EOL>            [files, compilerOptions] = getTSConfig(options, tsconfigFilename);<EOL>        }<EOL>        else {<EOL>            sendMessage(`<STR_LIT>`);<EOL>            return new Promise<void>(function (resolve, reject) {<EOL>                reject(new SyntaxError('<STR_LIT>'));<EOL>            });<EOL>        }<EOL>    }<EOL>    const eol = options.eol || os.EOL;<EOL>    const nonEmptyLineStart = new RegExp(eol + '<STR_LIT>' + eol + '<STR_LIT>', '<STR_LIT>');<EOL>    const indent = options.indent === undefined ? '<STR_LIT>' : options.indent;<EOL>    <EOL>    <EOL>    compilerOptions.declaration = true;<EOL>    compilerOptions.target = compilerOptions.target || ts.ScriptTarget.Latest; <EOL>    compilerOptions.moduleResolution = compilerOptions.moduleResolution || options.moduleResolution;<EOL>    compilerOptions.outDir = compilerOptions.outDir || options.outDir;<EOL>    <EOL>    const baseDir = pathUtil.resolve(compilerOptions.rootDir || options.project || options.baseDir);<EOL>    const outDir = compilerOptions.outDir;<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    const","gt":"filenames = getFilenames(baseDir, files);"}
{"input":"<s> export default function generate(options: Options): Promise<void> {<EOL>    if (Boolean(options.main) !== Boolean(options.name)) {<EOL>        if (Boolean(options.name)) {<EOL>            <EOL>            <EOL>            <EOL>            <EOL>            throw new Error(`<STR_LIT>`);<EOL>        }<EOL>        else {<EOL>            throw new Error('<STR_LIT>');<EOL>        }<EOL>    }<EOL>    const noop = function (message?: any, ...optionalParams: any[]): void { };<EOL>    const sendMessage = options.sendMessage || noop;<EOL>    const verboseMessage = options.verbose ? sendMessage : noop;<EOL>    let compilerOptions: ts.CompilerOptions = {};<EOL>    let files: string[] = options.files;<EOL>    <EOL>    if (options.project || !options.files || options.files.length === <NUM_LIT>) {<EOL>        verboseMessage(`<STR_LIT>`);<EOL>        <EOL>        <EOL>        <EOL>        <EOL>        let tsconfigFilename: string;<EOL>        if (Boolean(options.project)) {<EOL>            if (fs.lstatSync(options.project).isDirectory()) {<EOL>                tsconfigFilename = pathUtil.join(options.project, '<STR_LIT>');<EOL>            }<EOL>            else {<EOL>                <EOL>                tsconfigFilename = options.project;<EOL>            }<EOL>        }<EOL>        else {<EOL>            tsconfigFilename = pathUtil.join(options.baseDir, '<STR_LIT>');<EOL>        }<EOL>        if (fs.existsSync(tsconfigFilename)) {<EOL>            verboseMessage(`<STR_LIT>`);<EOL>            [files, compilerOptions] = getTSConfig(options, tsconfigFilename);<EOL>        }<EOL>        else {<EOL>            sendMessage(`<STR_LIT>`);<EOL>            return new Promise<void>(function (resolve, reject) {<EOL>                reject(new SyntaxError('<STR_LIT>'));<EOL>            });<EOL>        }<EOL>    }<EOL>    const eol = options.eol || os.EOL;<EOL>    const nonEmptyLineStart = new RegExp(eol + '<STR_LIT>' + eol + '<STR_LIT>', '<STR_LIT>');<EOL>    const indent = options.indent === undefined ? '<STR_LIT>' : options.indent;<EOL>    <EOL>    <EOL>    compilerOptions.declaration = true;<EOL>    compilerOptions.target = compilerOptions.target || ts.ScriptTarget.Latest; <EOL>    compilerOptions.moduleResolution = compilerOptions.moduleResolution || options.moduleResolution;<EOL>    compilerOptions.outDir = compilerOptions.outDir || options.outDir;<EOL>    <EOL>    const baseDir = pathUtil.resolve(compilerOptions.rootDir || options.project || options.baseDir);<EOL>    const outDir = compilerOptions.outDir;<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    const filenames = getFilenames(baseDir, files);<EOL>    verboseMessage('<STR_LIT>');<EOL>    filenames.forEach(name => { verboseMessage('<STR_LIT>' + name); });<EOL>    const excludesMap: {<EOL>        [filename: string]: boolean;<EOL>    } = {};<EOL>    options.exclude = options.exclude || ['<STR_LIT>'];<EOL>    options.exclude && options.exclude.forEach(function (filename) {<EOL>        glob.sync(filename).forEach(function (globFileName) {<EOL>            excludesMap[filenameToMid(pathUtil.resolve(baseDir, globFileName))] =","gt":"true;"}
{"input":"<s> export default function generate(options: Options): Promise<void> {<EOL>    if (Boolean(options.main) !== Boolean(options.name)) {<EOL>        if (Boolean(options.name)) {<EOL>            <EOL>            <EOL>            <EOL>            <EOL>            throw new Error(`<STR_LIT>`);<EOL>        }<EOL>        else {<EOL>            throw new Error('<STR_LIT>');<EOL>        }<EOL>    }<EOL>    const noop = function (message?: any, ...optionalParams: any[]): void { };<EOL>    const sendMessage = options.sendMessage || noop;<EOL>    const verboseMessage = options.verbose ? sendMessage : noop;<EOL>    let compilerOptions: ts.CompilerOptions = {};<EOL>    let files: string[] = options.files;<EOL>    <EOL>    if (options.project || !options.files || options.files.length === <NUM_LIT>) {<EOL>        verboseMessage(`<STR_LIT>`);<EOL>        <EOL>        <EOL>        <EOL>        <EOL>        let tsconfigFilename: string;<EOL>        if (Boolean(options.project)) {<EOL>            if (fs.lstatSync(options.project).isDirectory()) {<EOL>                tsconfigFilename = pathUtil.join(options.project, '<STR_LIT>');<EOL>            }<EOL>            else {<EOL>                <EOL>                tsconfigFilename = options.project;<EOL>            }<EOL>        }<EOL>        else {<EOL>            tsconfigFilename = pathUtil.join(options.baseDir, '<STR_LIT>');<EOL>        }<EOL>        if (fs.existsSync(tsconfigFilename)) {<EOL>            verboseMessage(`<STR_LIT>`);<EOL>            [files, compilerOptions] = getTSConfig(options, tsconfigFilename);<EOL>        }<EOL>        else {<EOL>            sendMessage(`<STR_LIT>`);<EOL>            return new Promise<void>(function (resolve, reject) {<EOL>                reject(new SyntaxError('<STR_LIT>'));<EOL>            });<EOL>        }<EOL>    }<EOL>    const eol = options.eol || os.EOL;<EOL>    const nonEmptyLineStart = new RegExp(eol + '<STR_LIT>' + eol + '<STR_LIT>', '<STR_LIT>');<EOL>    const indent = options.indent === undefined ? '<STR_LIT>' : options.indent;<EOL>    <EOL>    <EOL>    compilerOptions.declaration = true;<EOL>    compilerOptions.target = compilerOptions.target || ts.ScriptTarget.Latest; <EOL>    compilerOptions.moduleResolution = compilerOptions.moduleResolution || options.moduleResolution;<EOL>    compilerOptions.outDir = compilerOptions.outDir || options.outDir;<EOL>    <EOL>    const baseDir = pathUtil.resolve(compilerOptions.rootDir || options.project || options.baseDir);<EOL>    const outDir = compilerOptions.outDir;<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    const filenames = getFilenames(baseDir, files);<EOL>    verboseMessage('<STR_LIT>');<EOL>    filenames.forEach(name => { verboseMessage('<STR_LIT>' + name); });<EOL>    const excludesMap: {<EOL>        [filename: string]: boolean;<EOL>    } = {};<EOL>    options.exclude = options.exclude || ['<STR_LIT>'];<EOL>    options.exclude && options.exclude.forEach(function (filename) {<EOL>        glob.sync(filename).forEach(function (globFileName) {<EOL>            excludesMap[filenameToMid(pathUtil.resolve(baseDir, globFileName))] = true;<EOL>        });<EOL>    });<EOL>    if (options.exclude) {<EOL>        verboseMessage('<STR_LIT>');<EOL>        options.exclude.","gt":"forEach(name => { verboseMessage('<STR_LIT>' + name); });"}
{"input":"<s> export default function generate(options: Options): Promise<void> {<EOL>    if (Boolean(options.main) !== Boolean(options.name)) {<EOL>        if (Boolean(options.name)) {<EOL>            <EOL>            <EOL>            <EOL>            <EOL>            throw new Error(`<STR_LIT>`);<EOL>        }<EOL>        else {<EOL>            throw new Error('<STR_LIT>');<EOL>        }<EOL>    }<EOL>    const noop = function (message?: any, ...optionalParams: any[]): void { };<EOL>    const sendMessage = options.sendMessage || noop;<EOL>    const verboseMessage = options.verbose ? sendMessage : noop;<EOL>    let compilerOptions: ts.CompilerOptions = {};<EOL>    let files: string[] = options.files;<EOL>    <EOL>    if (options.project || !options.files || options.files.length === <NUM_LIT>) {<EOL>        verboseMessage(`<STR_LIT>`);<EOL>        <EOL>        <EOL>        <EOL>        <EOL>        let tsconfigFilename: string;<EOL>        if (Boolean(options.project)) {<EOL>            if (fs.lstatSync(options.project).isDirectory()) {<EOL>                tsconfigFilename = pathUtil.join(options.project, '<STR_LIT>');<EOL>            }<EOL>            else {<EOL>                <EOL>                tsconfigFilename = options.project;<EOL>            }<EOL>        }<EOL>        else {<EOL>            tsconfigFilename = pathUtil.join(options.baseDir, '<STR_LIT>');<EOL>        }<EOL>        if (fs.existsSync(tsconfigFilename)) {<EOL>            verboseMessage(`<STR_LIT>`);<EOL>            [files, compilerOptions] = getTSConfig(options, tsconfigFilename);<EOL>        }<EOL>        else {<EOL>            sendMessage(`<STR_LIT>`);<EOL>            return new Promise<void>(function (resolve, reject) {<EOL>                reject(new SyntaxError('<STR_LIT>'));<EOL>            });<EOL>        }<EOL>    }<EOL>    const eol = options.eol || os.EOL;<EOL>    const nonEmptyLineStart = new RegExp(eol + '<STR_LIT>' + eol + '<STR_LIT>', '<STR_LIT>');<EOL>    const indent = options.indent === undefined ? '<STR_LIT>' : options.indent;<EOL>    <EOL>    <EOL>    compilerOptions.declaration = true;<EOL>    compilerOptions.target = compilerOptions.target || ts.ScriptTarget.Latest; <EOL>    compilerOptions.moduleResolution = compilerOptions.moduleResolution || options.moduleResolution;<EOL>    compilerOptions.outDir = compilerOptions.outDir || options.outDir;<EOL>    <EOL>    const baseDir = pathUtil.resolve(compilerOptions.rootDir || options.project || options.baseDir);<EOL>    const outDir = compilerOptions.outDir;<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    const filenames = getFilenames(baseDir, files);<EOL>    verboseMessage('<STR_LIT>');<EOL>    filenames.forEach(name => { verboseMessage('<STR_LIT>' + name); });<EOL>    const excludesMap: {<EOL>        [filename: string]: boolean;<EOL>    } = {};<EOL>    options.exclude = options.exclude || ['<STR_LIT>'];<EOL>    options.exclude && options.exclude.forEach(function (filename) {<EOL>        glob.sync(filename).forEach(function (globFileName) {<EOL>            excludesMap[filenameToMid(pathUtil.resolve(baseDir, globFileName))] = true;<EOL>        });<EOL>    });<EOL>    if (options.exclude) {<EOL>        verboseMessage('<STR_LIT>');<EOL>        options.exclude.forEach(name => { verboseMessage('<STR_LIT>' + name); });<EOL>    }<EOL>    mkdirp.","gt":"sync(pathUtil.dirname("}
{"input":"<s> export default function generate(options: Options): Promise<void> {<EOL>    if (Boolean(options.main) !== Boolean(options.name)) {<EOL>        if (Boolean(options.name)) {<EOL>            <EOL>            <EOL>            <EOL>            <EOL>            throw new Error(`<STR_LIT>`);<EOL>        }<EOL>        else {<EOL>            throw new Error('<STR_LIT>');<EOL>        }<EOL>    }<EOL>    const noop = function (message?: any, ...optionalParams: any[]): void { };<EOL>    const sendMessage = options.sendMessage || noop;<EOL>    const verboseMessage = options.verbose ? sendMessage : noop;<EOL>    let compilerOptions: ts.CompilerOptions = {};<EOL>    let files: string[] = options.files;<EOL>    <EOL>    if (options.project || !options.files || options.files.length === <NUM_LIT>) {<EOL>        verboseMessage(`<STR_LIT>`);<EOL>        <EOL>        <EOL>        <EOL>        <EOL>        let tsconfigFilename: string;<EOL>        if (Boolean(options.project)) {<EOL>            if (fs.lstatSync(options.project).isDirectory()) {<EOL>                tsconfigFilename = pathUtil.join(options.project, '<STR_LIT>');<EOL>            }<EOL>            else {<EOL>                <EOL>                tsconfigFilename = options.project;<EOL>            }<EOL>        }<EOL>        else {<EOL>            tsconfigFilename = pathUtil.join(options.baseDir, '<STR_LIT>');<EOL>        }<EOL>        if (fs.existsSync(tsconfigFilename)) {<EOL>            verboseMessage(`<STR_LIT>`);<EOL>            [files, compilerOptions] = getTSConfig(options, tsconfigFilename);<EOL>        }<EOL>        else {<EOL>            sendMessage(`<STR_LIT>`);<EOL>            return new Promise<void>(function (resolve, reject) {<EOL>                reject(new SyntaxError('<STR_LIT>'));<EOL>            });<EOL>        }<EOL>    }<EOL>    const eol = options.eol || os.EOL;<EOL>    const nonEmptyLineStart = new RegExp(eol + '<STR_LIT>' + eol + '<STR_LIT>', '<STR_LIT>');<EOL>    const indent = options.indent === undefined ? '<STR_LIT>' : options.indent;<EOL>    <EOL>    <EOL>    compilerOptions.declaration = true;<EOL>    compilerOptions.target = compilerOptions.target || ts.ScriptTarget.Latest; <EOL>    compilerOptions.moduleResolution = compilerOptions.moduleResolution || options.moduleResolution;<EOL>    compilerOptions.outDir = compilerOptions.outDir || options.outDir;<EOL>    <EOL>    const baseDir = pathUtil.resolve(compilerOptions.rootDir || options.project || options.baseDir);<EOL>    const outDir = compilerOptions.outDir;<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    const filenames = getFilenames(baseDir, files);<EOL>    verboseMessage('<STR_LIT>');<EOL>    filenames.forEach(name => { verboseMessage('<STR_LIT>' + name); });<EOL>    const excludesMap: {<EOL>        [filename: string]: boolean;<EOL>    } = {};<EOL>    options.exclude = options.exclude || ['<STR_LIT>'];<EOL>    options.exclude && options.exclude.forEach(function (filename) {<EOL>        glob.sync(filename).forEach(function (globFileName) {<EOL>            excludesMap[filenameToMid(pathUtil.resolve(baseDir, globFileName))] = true;<EOL>        });<EOL>    });<EOL>    if (options.exclude) {<EOL>        verboseMessage('<STR_LIT>');<EOL>        options.exclude.forEach(name => { verboseMessage('<STR_LIT>' + name); });<EOL>    }<EOL>    mkdirp.sync(pathUtil.dirname(","gt":"options.out));"}
{"input":"<s> export default function generate(options: Options): Promise<void> {<EOL>    if (Boolean(options.main) !== Boolean(options.name)) {<EOL>        if (Boolean(options.name)) {<EOL>            <EOL>            <EOL>            <EOL>            <EOL>            throw new Error(`<STR_LIT>`);<EOL>        }<EOL>        else {<EOL>            throw new Error('<STR_LIT>');<EOL>        }<EOL>    }<EOL>    const noop = function (message?: any, ...optionalParams: any[]): void { };<EOL>    const sendMessage = options.sendMessage || noop;<EOL>    const verboseMessage = options.verbose ? sendMessage : noop;<EOL>    let compilerOptions: ts.CompilerOptions = {};<EOL>    let files: string[] = options.files;<EOL>    <EOL>    if (options.project || !options.files || options.files.length === <NUM_LIT>) {<EOL>        verboseMessage(`<STR_LIT>`);<EOL>        <EOL>        <EOL>        <EOL>        <EOL>        let tsconfigFilename: string;<EOL>        if (Boolean(options.project)) {<EOL>            if (fs.lstatSync(options.project).isDirectory()) {<EOL>                tsconfigFilename = pathUtil.join(options.project, '<STR_LIT>');<EOL>            }<EOL>            else {<EOL>                <EOL>                tsconfigFilename = options.project;<EOL>            }<EOL>        }<EOL>        else {<EOL>            tsconfigFilename = pathUtil.join(options.baseDir, '<STR_LIT>');<EOL>        }<EOL>        if (fs.existsSync(tsconfigFilename)) {<EOL>            verboseMessage(`<STR_LIT>`);<EOL>            [files, compilerOptions] = getTSConfig(options, tsconfigFilename);<EOL>        }<EOL>        else {<EOL>            sendMessage(`<STR_LIT>`);<EOL>            return new Promise<void>(function (resolve, reject) {<EOL>                reject(new SyntaxError('<STR_LIT>'));<EOL>            });<EOL>        }<EOL>    }<EOL>    const eol = options.eol || os.EOL;<EOL>    const nonEmptyLineStart = new RegExp(eol + '<STR_LIT>' + eol + '<STR_LIT>', '<STR_LIT>');<EOL>    const indent = options.indent === undefined ? '<STR_LIT>' : options.indent;<EOL>    <EOL>    <EOL>    compilerOptions.declaration = true;<EOL>    compilerOptions.target = compilerOptions.target || ts.ScriptTarget.Latest; <EOL>    compilerOptions.moduleResolution = compilerOptions.moduleResolution || options.moduleResolution;<EOL>    compilerOptions.outDir = compilerOptions.outDir || options.outDir;<EOL>    <EOL>    const baseDir = pathUtil.resolve(compilerOptions.rootDir || options.project || options.baseDir);<EOL>    const outDir = compilerOptions.outDir;<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    const filenames = getFilenames(baseDir, files);<EOL>    verboseMessage('<STR_LIT>');<EOL>    filenames.forEach(name => { verboseMessage('<STR_LIT>' + name); });<EOL>    const excludesMap: {<EOL>        [filename: string]: boolean;<EOL>    } = {};<EOL>    options.exclude = options.exclude || ['<STR_LIT>'];<EOL>    options.exclude && options.exclude.forEach(function (filename) {<EOL>        glob.sync(filename).forEach(function (globFileName) {<EOL>            excludesMap[filenameToMid(pathUtil.resolve(baseDir, globFileName))] = true;<EOL>        });<EOL>    });<EOL>    if (options.exclude) {<EOL>        verboseMessage('<STR_LIT>');<EOL>        options.exclude.forEach(name => { verboseMessage('<STR_LIT>' + name); });<EOL>    }<EOL>    mkdirp.sync(pathUtil.dirname(options.out));<EOL>    <EOL>    const output = fs.createWriteStream(options.out, <any>{ mode: parseInt('<STR_LIT>', <NUM_LIT>) });<EOL>    const host = ts.createCompilerHost(compilerOptions);<EOL>    const program = ts.createProgram(filenames, compilerOptions, host);<EOL>    function writeFile(filename: string, data: string, writeByteOrderMark: boolean) {<EOL>        <EOL>        if (filename.slice(-DTSLEN) !== '<STR_LIT>') {<EOL>            return;<EOL>        }<EOL>        writeDeclaration(ts.createSourceFile(filename, data, compilerOptions.target, true), true);<EOL>    }<EOL>    let declaredExternalModules:","gt":"string[] = [];"}
{"input":"<s> export default function generate(options: Options): Promise<void> {<EOL>    if (Boolean(options.main) !== Boolean(options.name)) {<EOL>        if (Boolean(options.name)) {<EOL>            <EOL>            <EOL>            <EOL>            <EOL>            throw new Error(`<STR_LIT>`);<EOL>        }<EOL>        else {<EOL>            throw new Error('<STR_LIT>');<EOL>        }<EOL>    }<EOL>    const noop = function (message?: any, ...optionalParams: any[]): void { };<EOL>    const sendMessage = options.sendMessage || noop;<EOL>    const verboseMessage = options.verbose ? sendMessage : noop;<EOL>    let compilerOptions: ts.CompilerOptions = {};<EOL>    let files: string[] = options.files;<EOL>    <EOL>    if (options.project || !options.files || options.files.length === <NUM_LIT>) {<EOL>        verboseMessage(`<STR_LIT>`);<EOL>        <EOL>        <EOL>        <EOL>        <EOL>        let tsconfigFilename: string;<EOL>        if (Boolean(options.project)) {<EOL>            if (fs.lstatSync(options.project).isDirectory()) {<EOL>                tsconfigFilename = pathUtil.join(options.project, '<STR_LIT>');<EOL>            }<EOL>            else {<EOL>                <EOL>                tsconfigFilename = options.project;<EOL>            }<EOL>        }<EOL>        else {<EOL>            tsconfigFilename = pathUtil.join(options.baseDir, '<STR_LIT>');<EOL>        }<EOL>        if (fs.existsSync(tsconfigFilename)) {<EOL>            verboseMessage(`<STR_LIT>`);<EOL>            [files, compilerOptions] = getTSConfig(options, tsconfigFilename);<EOL>        }<EOL>        else {<EOL>            sendMessage(`<STR_LIT>`);<EOL>            return new Promise<void>(function (resolve, reject) {<EOL>                reject(new SyntaxError('<STR_LIT>'));<EOL>            });<EOL>        }<EOL>    }<EOL>    const eol = options.eol || os.EOL;<EOL>    const nonEmptyLineStart = new RegExp(eol + '<STR_LIT>' + eol + '<STR_LIT>', '<STR_LIT>');<EOL>    const indent = options.indent === undefined ? '<STR_LIT>' : options.indent;<EOL>    <EOL>    <EOL>    compilerOptions.declaration = true;<EOL>    compilerOptions.target = compilerOptions.target || ts.ScriptTarget.Latest; <EOL>    compilerOptions.moduleResolution = compilerOptions.moduleResolution || options.moduleResolution;<EOL>    compilerOptions.outDir = compilerOptions.outDir || options.outDir;<EOL>    <EOL>    const baseDir = pathUtil.resolve(compilerOptions.rootDir || options.project || options.baseDir);<EOL>    const outDir = compilerOptions.outDir;<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    const filenames = getFilenames(baseDir, files);<EOL>    verboseMessage('<STR_LIT>');<EOL>    filenames.forEach(name => { verboseMessage('<STR_LIT>' + name); });<EOL>    const excludesMap: {<EOL>        [filename: string]: boolean;<EOL>    } = {};<EOL>    options.exclude = options.exclude || ['<STR_LIT>'];<EOL>    options.exclude && options.exclude.forEach(function (filename) {<EOL>        glob.sync(filename).forEach(function (globFileName) {<EOL>            excludesMap[filenameToMid(pathUtil.resolve(baseDir, globFileName))] = true;<EOL>        });<EOL>    });<EOL>    if (options.exclude) {<EOL>        verboseMessage('<STR_LIT>');<EOL>        options.exclude.forEach(name => { verboseMessage('<STR_LIT>' + name); });<EOL>    }<EOL>    mkdirp.sync(pathUtil.dirname(options.out));<EOL>    <EOL>    const output = fs.createWriteStream(options.out, <any>{ mode: parseInt('<STR_LIT>', <NUM_LIT>) });<EOL>    const host = ts.createCompilerHost(compilerOptions);<EOL>    const program = ts.createProgram(filenames, compilerOptions, host);<EOL>    function writeFile(filename: string, data: string, writeByteOrderMark: boolean) {<EOL>        <EOL>        if (filename.slice(-DTSLEN) !== '<STR_LIT>') {<EOL>            return;<EOL>        }<EOL>        writeDeclaration(ts.createSourceFile(filename, data, compilerOptions.target, true), true);<EOL>    }<EOL>    let declaredExternalModules: string[] = [];<EOL>    return new Promise<void>(","gt":"function (resolve, reject) {"}
{"input":"<s> export default function generate(options: Options): Promise<void> {<EOL>    if (Boolean(options.main) !== Boolean(options.name)) {<EOL>        if (Boolean(options.name)) {<EOL>            <EOL>            <EOL>            <EOL>            <EOL>            throw new Error(`<STR_LIT>`);<EOL>        }<EOL>        else {<EOL>            throw new Error('<STR_LIT>');<EOL>        }<EOL>    }<EOL>    const noop = function (message?: any, ...optionalParams: any[]): void { };<EOL>    const sendMessage = options.sendMessage || noop;<EOL>    const verboseMessage = options.verbose ? sendMessage : noop;<EOL>    let compilerOptions: ts.CompilerOptions = {};<EOL>    let files: string[] = options.files;<EOL>    <EOL>    if (options.project || !options.files || options.files.length === <NUM_LIT>) {<EOL>        verboseMessage(`<STR_LIT>`);<EOL>        <EOL>        <EOL>        <EOL>        <EOL>        let tsconfigFilename: string;<EOL>        if (Boolean(options.project)) {<EOL>            if (fs.lstatSync(options.project).isDirectory()) {<EOL>                tsconfigFilename = pathUtil.join(options.project, '<STR_LIT>');<EOL>            }<EOL>            else {<EOL>                <EOL>                tsconfigFilename = options.project;<EOL>            }<EOL>        }<EOL>        else {<EOL>            tsconfigFilename = pathUtil.join(options.baseDir, '<STR_LIT>');<EOL>        }<EOL>        if (fs.existsSync(tsconfigFilename)) {<EOL>            verboseMessage(`<STR_LIT>`);<EOL>            [files, compilerOptions] = getTSConfig(options, tsconfigFilename);<EOL>        }<EOL>        else {<EOL>            sendMessage(`<STR_LIT>`);<EOL>            return new Promise<void>(function (resolve, reject) {<EOL>                reject(new SyntaxError('<STR_LIT>'));<EOL>            });<EOL>        }<EOL>    }<EOL>    const eol = options.eol || os.EOL;<EOL>    const nonEmptyLineStart = new RegExp(eol + '<STR_LIT>' + eol + '<STR_LIT>', '<STR_LIT>');<EOL>    const indent = options.indent === undefined ? '<STR_LIT>' : options.indent;<EOL>    <EOL>    <EOL>    compilerOptions.declaration = true;<EOL>    compilerOptions.target = compilerOptions.target || ts.ScriptTarget.Latest; <EOL>    compilerOptions.moduleResolution = compilerOptions.moduleResolution || options.moduleResolution;<EOL>    compilerOptions.outDir = compilerOptions.outDir || options.outDir;<EOL>    <EOL>    const baseDir = pathUtil.resolve(compilerOptions.rootDir || options.project || options.baseDir);<EOL>    const outDir = compilerOptions.outDir;<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    const filenames = getFilenames(baseDir, files);<EOL>    verboseMessage('<STR_LIT>');<EOL>    filenames.forEach(name => { verboseMessage('<STR_LIT>' + name); });<EOL>    const excludesMap: {<EOL>        [filename: string]: boolean;<EOL>    } = {};<EOL>    options.exclude = options.exclude || ['<STR_LIT>'];<EOL>    options.exclude && options.exclude.forEach(function (filename) {<EOL>        glob.sync(filename).forEach(function (globFileName) {<EOL>            excludesMap[filenameToMid(pathUtil.resolve(baseDir, globFileName))] = true;<EOL>        });<EOL>    });<EOL>    if (options.exclude) {<EOL>        verboseMessage('<STR_LIT>');<EOL>        options.exclude.forEach(name => { verboseMessage('<STR_LIT>' + name); });<EOL>    }<EOL>    mkdirp.sync(pathUtil.dirname(options.out));<EOL>    <EOL>    const output = fs.createWriteStream(options.out, <any>{ mode: parseInt('<STR_LIT>', <NUM_LIT>) });<EOL>    const host = ts.createCompilerHost(compilerOptions);<EOL>    const program = ts.createProgram(filenames, compilerOptions, host);<EOL>    function writeFile(filename: string, data: string, writeByteOrderMark: boolean) {<EOL>        <EOL>        if (filename.slice(-DTSLEN) !== '<STR_LIT>') {<EOL>            return;<EOL>        }<EOL>        writeDeclaration(ts.createSourceFile(filename, data, compilerOptions.target, true), true);<EOL>    }<EOL>    let declaredExternalModules: string[] = [];<EOL>    return new Promise<void>(function (resolve, reject) {<EOL>        output.on('<STR_LIT>', () => { resolve(undefined); });<EOL>        output.on('<STR_LIT>', reject);<EOL>        if (options.externs) {<EOL>            options.externs.forEach(function (path: string) {<EOL>                sendMessage(`<STR_LIT>`);<EOL>                output.write(`<STR_LIT>` + eol);<EOL>            });<EOL>        }<EOL>        if (options.types) {<EOL>            options.types.forEach(function (type: string) {<EOL>                sendMessage(`<STR_LIT>`);<EOL>                output.write(`<STR_LIT>` + eol);<EOL>            });<EOL>        }<EOL>","gt":"sendMessage('<STR_LIT>');"}
{"input":"<s> export default function generate(options: Options): Promise<void> {<EOL>    if (Boolean(options.main) !== Boolean(options.name)) {<EOL>        if (Boolean(options.name)) {<EOL>            <EOL>            <EOL>            <EOL>            <EOL>            throw new Error(`<STR_LIT>`);<EOL>        }<EOL>        else {<EOL>            throw new Error('<STR_LIT>');<EOL>        }<EOL>    }<EOL>    const noop = function (message?: any, ...optionalParams: any[]): void { };<EOL>    const sendMessage = options.sendMessage || noop;<EOL>    const verboseMessage = options.verbose ? sendMessage : noop;<EOL>    let compilerOptions: ts.CompilerOptions = {};<EOL>    let files: string[] = options.files;<EOL>    <EOL>    if (options.project || !options.files || options.files.length === <NUM_LIT>) {<EOL>        verboseMessage(`<STR_LIT>`);<EOL>        <EOL>        <EOL>        <EOL>        <EOL>        let tsconfigFilename: string;<EOL>        if (Boolean(options.project)) {<EOL>            if (fs.lstatSync(options.project).isDirectory()) {<EOL>                tsconfigFilename = pathUtil.join(options.project, '<STR_LIT>');<EOL>            }<EOL>            else {<EOL>                <EOL>                tsconfigFilename = options.project;<EOL>            }<EOL>        }<EOL>        else {<EOL>            tsconfigFilename = pathUtil.join(options.baseDir, '<STR_LIT>');<EOL>        }<EOL>        if (fs.existsSync(tsconfigFilename)) {<EOL>            verboseMessage(`<STR_LIT>`);<EOL>            [files, compilerOptions] = getTSConfig(options, tsconfigFilename);<EOL>        }<EOL>        else {<EOL>            sendMessage(`<STR_LIT>`);<EOL>            return new Promise<void>(function (resolve, reject) {<EOL>                reject(new SyntaxError('<STR_LIT>'));<EOL>            });<EOL>        }<EOL>    }<EOL>    const eol = options.eol || os.EOL;<EOL>    const nonEmptyLineStart = new RegExp(eol + '<STR_LIT>' + eol + '<STR_LIT>', '<STR_LIT>');<EOL>    const indent = options.indent === undefined ? '<STR_LIT>' : options.indent;<EOL>    <EOL>    <EOL>    compilerOptions.declaration = true;<EOL>    compilerOptions.target = compilerOptions.target || ts.ScriptTarget.Latest; <EOL>    compilerOptions.moduleResolution = compilerOptions.moduleResolution || options.moduleResolution;<EOL>    compilerOptions.outDir = compilerOptions.outDir || options.outDir;<EOL>    <EOL>    const baseDir = pathUtil.resolve(compilerOptions.rootDir || options.project || options.baseDir);<EOL>    const outDir = compilerOptions.outDir;<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    const filenames = getFilenames(baseDir, files);<EOL>    verboseMessage('<STR_LIT>');<EOL>    filenames.forEach(name => { verboseMessage('<STR_LIT>' + name); });<EOL>    const excludesMap: {<EOL>        [filename: string]: boolean;<EOL>    } = {};<EOL>    options.exclude = options.exclude || ['<STR_LIT>'];<EOL>    options.exclude && options.exclude.forEach(function (filename) {<EOL>        glob.sync(filename).forEach(function (globFileName) {<EOL>            excludesMap[filenameToMid(pathUtil.resolve(baseDir, globFileName))] = true;<EOL>        });<EOL>    });<EOL>    if (options.exclude) {<EOL>        verboseMessage('<STR_LIT>');<EOL>        options.exclude.forEach(name => { verboseMessage('<STR_LIT>' + name); });<EOL>    }<EOL>    mkdirp.sync(pathUtil.dirname(options.out));<EOL>    <EOL>    const output = fs.createWriteStream(options.out, <any>{ mode: parseInt('<STR_LIT>', <NUM_LIT>) });<EOL>    const host = ts.createCompilerHost(compilerOptions);<EOL>    const program = ts.createProgram(filenames, compilerOptions, host);<EOL>    function writeFile(filename: string, data: string, writeByteOrderMark: boolean) {<EOL>        <EOL>        if (filename.slice(-DTSLEN) !== '<STR_LIT>') {<EOL>            return;<EOL>        }<EOL>        writeDeclaration(ts.createSourceFile(filename, data, compilerOptions.target, true), true);<EOL>    }<EOL>    let declaredExternalModules: string[] = [];<EOL>    return new Promise<void>(function (resolve, reject) {<EOL>        output.on('<STR_LIT>', () => { resolve(undefined); });<EOL>        output.on('<STR_LIT>', reject);<EOL>        if (options.externs) {<EOL>            options.externs.forEach(function (path: string) {<EOL>                sendMessage(`<STR_LIT>`);<EOL>                output.write(`<STR_LIT>` + eol);<EOL>            });<EOL>        }<EOL>        if (options.types) {<EOL>            options.types.forEach(function (type: string) {<EOL>                sendMessage(`<STR_LIT>`);<EOL>                output.write(`<STR_LIT>` + eol);<EOL>            });<EOL>        }<EOL>        sendMessage('<STR_LIT>');<EOL>        let mainExportDeclaration = false;<EOL>        let mainExportAssignment = false;<EOL>        let foundMain = false;<EOL>        program.getSourceFiles().forEach(function (sourceFile) {<EOL>            processTree(sourceFile, function (node) {<EOL>                if (isNodeKindModuleDeclaration(node)) {<EOL>                    const name = node.","gt":"name;"}
{"input":"<s> export default function generate(options: Options): Promise<void> {<EOL>    if (Boolean(options.main) !== Boolean(options.name)) {<EOL>        if (Boolean(options.name)) {<EOL>            <EOL>            <EOL>            <EOL>            <EOL>            throw new Error(`<STR_LIT>`);<EOL>        }<EOL>        else {<EOL>            throw new Error('<STR_LIT>');<EOL>        }<EOL>    }<EOL>    const noop = function (message?: any, ...optionalParams: any[]): void { };<EOL>    const sendMessage = options.sendMessage || noop;<EOL>    const verboseMessage = options.verbose ? sendMessage : noop;<EOL>    let compilerOptions: ts.CompilerOptions = {};<EOL>    let files: string[] = options.files;<EOL>    <EOL>    if (options.project || !options.files || options.files.length === <NUM_LIT>) {<EOL>        verboseMessage(`<STR_LIT>`);<EOL>        <EOL>        <EOL>        <EOL>        <EOL>        let tsconfigFilename: string;<EOL>        if (Boolean(options.project)) {<EOL>            if (fs.lstatSync(options.project).isDirectory()) {<EOL>                tsconfigFilename = pathUtil.join(options.project, '<STR_LIT>');<EOL>            }<EOL>            else {<EOL>                <EOL>                tsconfigFilename = options.project;<EOL>            }<EOL>        }<EOL>        else {<EOL>            tsconfigFilename = pathUtil.join(options.baseDir, '<STR_LIT>');<EOL>        }<EOL>        if (fs.existsSync(tsconfigFilename)) {<EOL>            verboseMessage(`<STR_LIT>`);<EOL>            [files, compilerOptions] = getTSConfig(options, tsconfigFilename);<EOL>        }<EOL>        else {<EOL>            sendMessage(`<STR_LIT>`);<EOL>            return new Promise<void>(function (resolve, reject) {<EOL>                reject(new SyntaxError('<STR_LIT>'));<EOL>            });<EOL>        }<EOL>    }<EOL>    const eol = options.eol || os.EOL;<EOL>    const nonEmptyLineStart = new RegExp(eol + '<STR_LIT>' + eol + '<STR_LIT>', '<STR_LIT>');<EOL>    const indent = options.indent === undefined ? '<STR_LIT>' : options.indent;<EOL>    <EOL>    <EOL>    compilerOptions.declaration = true;<EOL>    compilerOptions.target = compilerOptions.target || ts.ScriptTarget.Latest; <EOL>    compilerOptions.moduleResolution = compilerOptions.moduleResolution || options.moduleResolution;<EOL>    compilerOptions.outDir = compilerOptions.outDir || options.outDir;<EOL>    <EOL>    const baseDir = pathUtil.resolve(compilerOptions.rootDir || options.project || options.baseDir);<EOL>    const outDir = compilerOptions.outDir;<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    const filenames = getFilenames(baseDir, files);<EOL>    verboseMessage('<STR_LIT>');<EOL>    filenames.forEach(name => { verboseMessage('<STR_LIT>' + name); });<EOL>    const excludesMap: {<EOL>        [filename: string]: boolean;<EOL>    } = {};<EOL>    options.exclude = options.exclude || ['<STR_LIT>'];<EOL>    options.exclude && options.exclude.forEach(function (filename) {<EOL>        glob.sync(filename).forEach(function (globFileName) {<EOL>            excludesMap[filenameToMid(pathUtil.resolve(baseDir, globFileName))] = true;<EOL>        });<EOL>    });<EOL>    if (options.exclude) {<EOL>        verboseMessage('<STR_LIT>');<EOL>        options.exclude.forEach(name => { verboseMessage('<STR_LIT>' + name); });<EOL>    }<EOL>    mkdirp.sync(pathUtil.dirname(options.out));<EOL>    <EOL>    const output = fs.createWriteStream(options.out, <any>{ mode: parseInt('<STR_LIT>', <NUM_LIT>) });<EOL>    const host = ts.createCompilerHost(compilerOptions);<EOL>    const program = ts.createProgram(filenames, compilerOptions, host);<EOL>    function writeFile(filename: string, data: string, writeByteOrderMark: boolean) {<EOL>        <EOL>        if (filename.slice(-DTSLEN) !== '<STR_LIT>') {<EOL>            return;<EOL>        }<EOL>        writeDeclaration(ts.createSourceFile(filename, data, compilerOptions.target, true), true);<EOL>    }<EOL>    let declaredExternalModules: string[] = [];<EOL>    return new Promise<void>(function (resolve, reject) {<EOL>        output.on('<STR_LIT>', () => { resolve(undefined); });<EOL>        output.on('<STR_LIT>', reject);<EOL>        if (options.externs) {<EOL>            options.externs.forEach(function (path: string) {<EOL>                sendMessage(`<STR_LIT>`);<EOL>                output.write(`<STR_LIT>` + eol);<EOL>            });<EOL>        }<EOL>        if (options.types) {<EOL>            options.types.forEach(function (type: string) {<EOL>                sendMessage(`<STR_LIT>`);<EOL>                output.write(`<STR_LIT>` + eol);<EOL>            });<EOL>        }<EOL>        sendMessage('<STR_LIT>');<EOL>        let mainExportDeclaration = false;<EOL>        let mainExportAssignment = false;<EOL>        let foundMain = false;<EOL>        program.getSourceFiles().forEach(function (sourceFile) {<EOL>            processTree(sourceFile, function (node) {<EOL>                if (isNodeKindModuleDeclaration(node)) {<EOL>                    const name = node.name;<EOL>                    if (isNodeKindStringLiteral(name)) {<EOL>                        declaredExternalModules.push(name.text);<EOL>                    }<EOL>                }<EOL>                return null;<EOL>            });<EOL>        });<EOL>        program.getSourceFiles().some(function (sourceFile) {<EOL>            <EOL>            <EOL>            if (pathUtil.normalize(sourceFile.fileName).indexOf(baseDir) !== <NUM_LIT>) {<EOL>                return;<EOL>            }<EOL>            if (excludesMap[filenameToMid(pathUtil.","gt":"normalize(sourceFile.fileName))]) {"}
{"input":"<s> export default function generate(options: Options): Promise<void> {<EOL>    if (Boolean(options.main) !== Boolean(options.name)) {<EOL>        if (Boolean(options.name)) {<EOL>            <EOL>            <EOL>            <EOL>            <EOL>            throw new Error(`<STR_LIT>`);<EOL>        }<EOL>        else {<EOL>            throw new Error('<STR_LIT>');<EOL>        }<EOL>    }<EOL>    const noop = function (message?: any, ...optionalParams: any[]): void { };<EOL>    const sendMessage = options.sendMessage || noop;<EOL>    const verboseMessage = options.verbose ? sendMessage : noop;<EOL>    let compilerOptions: ts.CompilerOptions = {};<EOL>    let files: string[] = options.files;<EOL>    <EOL>    if (options.project || !options.files || options.files.length === <NUM_LIT>) {<EOL>        verboseMessage(`<STR_LIT>`);<EOL>        <EOL>        <EOL>        <EOL>        <EOL>        let tsconfigFilename: string;<EOL>        if (Boolean(options.project)) {<EOL>            if (fs.lstatSync(options.project).isDirectory()) {<EOL>                tsconfigFilename = pathUtil.join(options.project, '<STR_LIT>');<EOL>            }<EOL>            else {<EOL>                <EOL>                tsconfigFilename = options.project;<EOL>            }<EOL>        }<EOL>        else {<EOL>            tsconfigFilename = pathUtil.join(options.baseDir, '<STR_LIT>');<EOL>        }<EOL>        if (fs.existsSync(tsconfigFilename)) {<EOL>            verboseMessage(`<STR_LIT>`);<EOL>            [files, compilerOptions] = getTSConfig(options, tsconfigFilename);<EOL>        }<EOL>        else {<EOL>            sendMessage(`<STR_LIT>`);<EOL>            return new Promise<void>(function (resolve, reject) {<EOL>                reject(new SyntaxError('<STR_LIT>'));<EOL>            });<EOL>        }<EOL>    }<EOL>    const eol = options.eol || os.EOL;<EOL>    const nonEmptyLineStart = new RegExp(eol + '<STR_LIT>' + eol + '<STR_LIT>', '<STR_LIT>');<EOL>    const indent = options.indent === undefined ? '<STR_LIT>' : options.indent;<EOL>    <EOL>    <EOL>    compilerOptions.declaration = true;<EOL>    compilerOptions.target = compilerOptions.target || ts.ScriptTarget.Latest; <EOL>    compilerOptions.moduleResolution = compilerOptions.moduleResolution || options.moduleResolution;<EOL>    compilerOptions.outDir = compilerOptions.outDir || options.outDir;<EOL>    <EOL>    const baseDir = pathUtil.resolve(compilerOptions.rootDir || options.project || options.baseDir);<EOL>    const outDir = compilerOptions.outDir;<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    const filenames = getFilenames(baseDir, files);<EOL>    verboseMessage('<STR_LIT>');<EOL>    filenames.forEach(name => { verboseMessage('<STR_LIT>' + name); });<EOL>    const excludesMap: {<EOL>        [filename: string]: boolean;<EOL>    } = {};<EOL>    options.exclude = options.exclude || ['<STR_LIT>'];<EOL>    options.exclude && options.exclude.forEach(function (filename) {<EOL>        glob.sync(filename).forEach(function (globFileName) {<EOL>            excludesMap[filenameToMid(pathUtil.resolve(baseDir, globFileName))] = true;<EOL>        });<EOL>    });<EOL>    if (options.exclude) {<EOL>        verboseMessage('<STR_LIT>');<EOL>        options.exclude.forEach(name => { verboseMessage('<STR_LIT>' + name); });<EOL>    }<EOL>    mkdirp.sync(pathUtil.dirname(options.out));<EOL>    <EOL>    const output = fs.createWriteStream(options.out, <any>{ mode: parseInt('<STR_LIT>', <NUM_LIT>) });<EOL>    const host = ts.createCompilerHost(compilerOptions);<EOL>    const program = ts.createProgram(filenames, compilerOptions, host);<EOL>    function writeFile(filename: string, data: string, writeByteOrderMark: boolean) {<EOL>        <EOL>        if (filename.slice(-DTSLEN) !== '<STR_LIT>') {<EOL>            return;<EOL>        }<EOL>        writeDeclaration(ts.createSourceFile(filename, data, compilerOptions.target, true), true);<EOL>    }<EOL>    let declaredExternalModules: string[] = [];<EOL>    return new Promise<void>(function (resolve, reject) {<EOL>        output.on('<STR_LIT>', () => { resolve(undefined); });<EOL>        output.on('<STR_LIT>', reject);<EOL>        if (options.externs) {<EOL>            options.externs.forEach(function (path: string) {<EOL>                sendMessage(`<STR_LIT>`);<EOL>                output.write(`<STR_LIT>` + eol);<EOL>            });<EOL>        }<EOL>        if (options.types) {<EOL>            options.types.forEach(function (type: string) {<EOL>                sendMessage(`<STR_LIT>`);<EOL>                output.write(`<STR_LIT>` + eol);<EOL>            });<EOL>        }<EOL>        sendMessage('<STR_LIT>');<EOL>        let mainExportDeclaration = false;<EOL>        let mainExportAssignment = false;<EOL>        let foundMain = false;<EOL>        program.getSourceFiles().forEach(function (sourceFile) {<EOL>            processTree(sourceFile, function (node) {<EOL>                if (isNodeKindModuleDeclaration(node)) {<EOL>                    const name = node.name;<EOL>                    if (isNodeKindStringLiteral(name)) {<EOL>                        declaredExternalModules.push(name.text);<EOL>                    }<EOL>                }<EOL>                return null;<EOL>            });<EOL>        });<EOL>        program.getSourceFiles().some(function (sourceFile) {<EOL>            <EOL>            <EOL>            if (pathUtil.normalize(sourceFile.fileName).indexOf(baseDir) !== <NUM_LIT>) {<EOL>                return;<EOL>            }<EOL>            if (excludesMap[filenameToMid(pathUtil.normalize(sourceFile.fileName))]) {<EOL>","gt":"return;"}
{"input":"<s> export default function generate(options: Options): Promise<void> {<EOL>    if (Boolean(options.main) !== Boolean(options.name)) {<EOL>        if (Boolean(options.name)) {<EOL>            <EOL>            <EOL>            <EOL>            <EOL>            throw new Error(`<STR_LIT>`);<EOL>        }<EOL>        else {<EOL>            throw new Error('<STR_LIT>');<EOL>        }<EOL>    }<EOL>    const noop = function (message?: any, ...optionalParams: any[]): void { };<EOL>    const sendMessage = options.sendMessage || noop;<EOL>    const verboseMessage = options.verbose ? sendMessage : noop;<EOL>    let compilerOptions: ts.CompilerOptions = {};<EOL>    let files: string[] = options.files;<EOL>    <EOL>    if (options.project || !options.files || options.files.length === <NUM_LIT>) {<EOL>        verboseMessage(`<STR_LIT>`);<EOL>        <EOL>        <EOL>        <EOL>        <EOL>        let tsconfigFilename: string;<EOL>        if (Boolean(options.project)) {<EOL>            if (fs.lstatSync(options.project).isDirectory()) {<EOL>                tsconfigFilename = pathUtil.join(options.project, '<STR_LIT>');<EOL>            }<EOL>            else {<EOL>                <EOL>                tsconfigFilename = options.project;<EOL>            }<EOL>        }<EOL>        else {<EOL>            tsconfigFilename = pathUtil.join(options.baseDir, '<STR_LIT>');<EOL>        }<EOL>        if (fs.existsSync(tsconfigFilename)) {<EOL>            verboseMessage(`<STR_LIT>`);<EOL>            [files, compilerOptions] = getTSConfig(options, tsconfigFilename);<EOL>        }<EOL>        else {<EOL>            sendMessage(`<STR_LIT>`);<EOL>            return new Promise<void>(function (resolve, reject) {<EOL>                reject(new SyntaxError('<STR_LIT>'));<EOL>            });<EOL>        }<EOL>    }<EOL>    const eol = options.eol || os.EOL;<EOL>    const nonEmptyLineStart = new RegExp(eol + '<STR_LIT>' + eol + '<STR_LIT>', '<STR_LIT>');<EOL>    const indent = options.indent === undefined ? '<STR_LIT>' : options.indent;<EOL>    <EOL>    <EOL>    compilerOptions.declaration = true;<EOL>    compilerOptions.target = compilerOptions.target || ts.ScriptTarget.Latest; <EOL>    compilerOptions.moduleResolution = compilerOptions.moduleResolution || options.moduleResolution;<EOL>    compilerOptions.outDir = compilerOptions.outDir || options.outDir;<EOL>    <EOL>    const baseDir = pathUtil.resolve(compilerOptions.rootDir || options.project || options.baseDir);<EOL>    const outDir = compilerOptions.outDir;<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    const filenames = getFilenames(baseDir, files);<EOL>    verboseMessage('<STR_LIT>');<EOL>    filenames.forEach(name => { verboseMessage('<STR_LIT>' + name); });<EOL>    const excludesMap: {<EOL>        [filename: string]: boolean;<EOL>    } = {};<EOL>    options.exclude = options.exclude || ['<STR_LIT>'];<EOL>    options.exclude && options.exclude.forEach(function (filename) {<EOL>        glob.sync(filename).forEach(function (globFileName) {<EOL>            excludesMap[filenameToMid(pathUtil.resolve(baseDir, globFileName))] = true;<EOL>        });<EOL>    });<EOL>    if (options.exclude) {<EOL>        verboseMessage('<STR_LIT>');<EOL>        options.exclude.forEach(name => { verboseMessage('<STR_LIT>' + name); });<EOL>    }<EOL>    mkdirp.sync(pathUtil.dirname(options.out));<EOL>    <EOL>    const output = fs.createWriteStream(options.out, <any>{ mode: parseInt('<STR_LIT>', <NUM_LIT>) });<EOL>    const host = ts.createCompilerHost(compilerOptions);<EOL>    const program = ts.createProgram(filenames, compilerOptions, host);<EOL>    function writeFile(filename: string, data: string, writeByteOrderMark: boolean) {<EOL>        <EOL>        if (filename.slice(-DTSLEN) !== '<STR_LIT>') {<EOL>            return;<EOL>        }<EOL>        writeDeclaration(ts.createSourceFile(filename, data, compilerOptions.target, true), true);<EOL>    }<EOL>    let declaredExternalModules: string[] = [];<EOL>    return new Promise<void>(function (resolve, reject) {<EOL>        output.on('<STR_LIT>', () => { resolve(undefined); });<EOL>        output.on('<STR_LIT>', reject);<EOL>        if (options.externs) {<EOL>            options.externs.forEach(function (path: string) {<EOL>                sendMessage(`<STR_LIT>`);<EOL>                output.write(`<STR_LIT>` + eol);<EOL>            });<EOL>        }<EOL>        if (options.types) {<EOL>            options.types.forEach(function (type: string) {<EOL>                sendMessage(`<STR_LIT>`);<EOL>                output.write(`<STR_LIT>` + eol);<EOL>            });<EOL>        }<EOL>        sendMessage('<STR_LIT>');<EOL>        let mainExportDeclaration = false;<EOL>        let mainExportAssignment = false;<EOL>        let foundMain = false;<EOL>        program.getSourceFiles().forEach(function (sourceFile) {<EOL>            processTree(sourceFile, function (node) {<EOL>                if (isNodeKindModuleDeclaration(node)) {<EOL>                    const name = node.name;<EOL>                    if (isNodeKindStringLiteral(name)) {<EOL>                        declaredExternalModules.push(name.text);<EOL>                    }<EOL>                }<EOL>                return null;<EOL>            });<EOL>        });<EOL>        program.getSourceFiles().some(function (sourceFile) {<EOL>            <EOL>            <EOL>            if (pathUtil.normalize(sourceFile.fileName).indexOf(baseDir) !== <NUM_LIT>) {<EOL>                return;<EOL>            }<EOL>            if (excludesMap[filenameToMid(pathUtil.normalize(sourceFile.fileName))]) {<EOL>                return;<EOL>            }<EOL>            sendMessage(`<STR_LIT>`);<EOL>            <EOL>            if (sourceFile.fileName.","gt":"slice(-DTSLEN) === '<STR_LIT>') {"}
{"input":"<s> export default function generate(options: Options): Promise<void> {<EOL>    if (Boolean(options.main) !== Boolean(options.name)) {<EOL>        if (Boolean(options.name)) {<EOL>            <EOL>            <EOL>            <EOL>            <EOL>            throw new Error(`<STR_LIT>`);<EOL>        }<EOL>        else {<EOL>            throw new Error('<STR_LIT>');<EOL>        }<EOL>    }<EOL>    const noop = function (message?: any, ...optionalParams: any[]): void { };<EOL>    const sendMessage = options.sendMessage || noop;<EOL>    const verboseMessage = options.verbose ? sendMessage : noop;<EOL>    let compilerOptions: ts.CompilerOptions = {};<EOL>    let files: string[] = options.files;<EOL>    <EOL>    if (options.project || !options.files || options.files.length === <NUM_LIT>) {<EOL>        verboseMessage(`<STR_LIT>`);<EOL>        <EOL>        <EOL>        <EOL>        <EOL>        let tsconfigFilename: string;<EOL>        if (Boolean(options.project)) {<EOL>            if (fs.lstatSync(options.project).isDirectory()) {<EOL>                tsconfigFilename = pathUtil.join(options.project, '<STR_LIT>');<EOL>            }<EOL>            else {<EOL>                <EOL>                tsconfigFilename = options.project;<EOL>            }<EOL>        }<EOL>        else {<EOL>            tsconfigFilename = pathUtil.join(options.baseDir, '<STR_LIT>');<EOL>        }<EOL>        if (fs.existsSync(tsconfigFilename)) {<EOL>            verboseMessage(`<STR_LIT>`);<EOL>            [files, compilerOptions] = getTSConfig(options, tsconfigFilename);<EOL>        }<EOL>        else {<EOL>            sendMessage(`<STR_LIT>`);<EOL>            return new Promise<void>(function (resolve, reject) {<EOL>                reject(new SyntaxError('<STR_LIT>'));<EOL>            });<EOL>        }<EOL>    }<EOL>    const eol = options.eol || os.EOL;<EOL>    const nonEmptyLineStart = new RegExp(eol + '<STR_LIT>' + eol + '<STR_LIT>', '<STR_LIT>');<EOL>    const indent = options.indent === undefined ? '<STR_LIT>' : options.indent;<EOL>    <EOL>    <EOL>    compilerOptions.declaration = true;<EOL>    compilerOptions.target = compilerOptions.target || ts.ScriptTarget.Latest; <EOL>    compilerOptions.moduleResolution = compilerOptions.moduleResolution || options.moduleResolution;<EOL>    compilerOptions.outDir = compilerOptions.outDir || options.outDir;<EOL>    <EOL>    const baseDir = pathUtil.resolve(compilerOptions.rootDir || options.project || options.baseDir);<EOL>    const outDir = compilerOptions.outDir;<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    const filenames = getFilenames(baseDir, files);<EOL>    verboseMessage('<STR_LIT>');<EOL>    filenames.forEach(name => { verboseMessage('<STR_LIT>' + name); });<EOL>    const excludesMap: {<EOL>        [filename: string]: boolean;<EOL>    } = {};<EOL>    options.exclude = options.exclude || ['<STR_LIT>'];<EOL>    options.exclude && options.exclude.forEach(function (filename) {<EOL>        glob.sync(filename).forEach(function (globFileName) {<EOL>            excludesMap[filenameToMid(pathUtil.resolve(baseDir, globFileName))] = true;<EOL>        });<EOL>    });<EOL>    if (options.exclude) {<EOL>        verboseMessage('<STR_LIT>');<EOL>        options.exclude.forEach(name => { verboseMessage('<STR_LIT>' + name); });<EOL>    }<EOL>    mkdirp.sync(pathUtil.dirname(options.out));<EOL>    <EOL>    const output = fs.createWriteStream(options.out, <any>{ mode: parseInt('<STR_LIT>', <NUM_LIT>) });<EOL>    const host = ts.createCompilerHost(compilerOptions);<EOL>    const program = ts.createProgram(filenames, compilerOptions, host);<EOL>    function writeFile(filename: string, data: string, writeByteOrderMark: boolean) {<EOL>        <EOL>        if (filename.slice(-DTSLEN) !== '<STR_LIT>') {<EOL>            return;<EOL>        }<EOL>        writeDeclaration(ts.createSourceFile(filename, data, compilerOptions.target, true), true);<EOL>    }<EOL>    let declaredExternalModules: string[] = [];<EOL>    return new Promise<void>(function (resolve, reject) {<EOL>        output.on('<STR_LIT>', () => { resolve(undefined); });<EOL>        output.on('<STR_LIT>', reject);<EOL>        if (options.externs) {<EOL>            options.externs.forEach(function (path: string) {<EOL>                sendMessage(`<STR_LIT>`);<EOL>                output.write(`<STR_LIT>` + eol);<EOL>            });<EOL>        }<EOL>        if (options.types) {<EOL>            options.types.forEach(function (type: string) {<EOL>                sendMessage(`<STR_LIT>`);<EOL>                output.write(`<STR_LIT>` + eol);<EOL>            });<EOL>        }<EOL>        sendMessage('<STR_LIT>');<EOL>        let mainExportDeclaration = false;<EOL>        let mainExportAssignment = false;<EOL>        let foundMain = false;<EOL>        program.getSourceFiles().forEach(function (sourceFile) {<EOL>            processTree(sourceFile, function (node) {<EOL>                if (isNodeKindModuleDeclaration(node)) {<EOL>                    const name = node.name;<EOL>                    if (isNodeKindStringLiteral(name)) {<EOL>                        declaredExternalModules.push(name.text);<EOL>                    }<EOL>                }<EOL>                return null;<EOL>            });<EOL>        });<EOL>        program.getSourceFiles().some(function (sourceFile) {<EOL>            <EOL>            <EOL>            if (pathUtil.normalize(sourceFile.fileName).indexOf(baseDir) !== <NUM_LIT>) {<EOL>                return;<EOL>            }<EOL>            if (excludesMap[filenameToMid(pathUtil.normalize(sourceFile.fileName))]) {<EOL>                return;<EOL>            }<EOL>            sendMessage(`<STR_LIT>`);<EOL>            <EOL>            if (sourceFile.fileName.slice(-DTSLEN) === '<STR_LIT>') {<EOL>                writeDeclaration(sourceFile, false);<EOL>                return;<EOL>            }<EOL>            <EOL>            if (options.main && options.main === (options.prefix + filenameToMid(sourceFile.fileName.slice(baseDir.length, -<NUM_LIT>)))) {<EOL>","gt":"foundMain = true;"}
{"input":"<s> export default function generate(options: Options): Promise<void> {<EOL>    if (Boolean(options.main) !== Boolean(options.name)) {<EOL>        if (Boolean(options.name)) {<EOL>            <EOL>            <EOL>            <EOL>            <EOL>            throw new Error(`<STR_LIT>`);<EOL>        }<EOL>        else {<EOL>            throw new Error('<STR_LIT>');<EOL>        }<EOL>    }<EOL>    const noop = function (message?: any, ...optionalParams: any[]): void { };<EOL>    const sendMessage = options.sendMessage || noop;<EOL>    const verboseMessage = options.verbose ? sendMessage : noop;<EOL>    let compilerOptions: ts.CompilerOptions = {};<EOL>    let files: string[] = options.files;<EOL>    <EOL>    if (options.project || !options.files || options.files.length === <NUM_LIT>) {<EOL>        verboseMessage(`<STR_LIT>`);<EOL>        <EOL>        <EOL>        <EOL>        <EOL>        let tsconfigFilename: string;<EOL>        if (Boolean(options.project)) {<EOL>            if (fs.lstatSync(options.project).isDirectory()) {<EOL>                tsconfigFilename = pathUtil.join(options.project, '<STR_LIT>');<EOL>            }<EOL>            else {<EOL>                <EOL>                tsconfigFilename = options.project;<EOL>            }<EOL>        }<EOL>        else {<EOL>            tsconfigFilename = pathUtil.join(options.baseDir, '<STR_LIT>');<EOL>        }<EOL>        if (fs.existsSync(tsconfigFilename)) {<EOL>            verboseMessage(`<STR_LIT>`);<EOL>            [files, compilerOptions] = getTSConfig(options, tsconfigFilename);<EOL>        }<EOL>        else {<EOL>            sendMessage(`<STR_LIT>`);<EOL>            return new Promise<void>(function (resolve, reject) {<EOL>                reject(new SyntaxError('<STR_LIT>'));<EOL>            });<EOL>        }<EOL>    }<EOL>    const eol = options.eol || os.EOL;<EOL>    const nonEmptyLineStart = new RegExp(eol + '<STR_LIT>' + eol + '<STR_LIT>', '<STR_LIT>');<EOL>    const indent = options.indent === undefined ? '<STR_LIT>' : options.indent;<EOL>    <EOL>    <EOL>    compilerOptions.declaration = true;<EOL>    compilerOptions.target = compilerOptions.target || ts.ScriptTarget.Latest; <EOL>    compilerOptions.moduleResolution = compilerOptions.moduleResolution || options.moduleResolution;<EOL>    compilerOptions.outDir = compilerOptions.outDir || options.outDir;<EOL>    <EOL>    const baseDir = pathUtil.resolve(compilerOptions.rootDir || options.project || options.baseDir);<EOL>    const outDir = compilerOptions.outDir;<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    const filenames = getFilenames(baseDir, files);<EOL>    verboseMessage('<STR_LIT>');<EOL>    filenames.forEach(name => { verboseMessage('<STR_LIT>' + name); });<EOL>    const excludesMap: {<EOL>        [filename: string]: boolean;<EOL>    } = {};<EOL>    options.exclude = options.exclude || ['<STR_LIT>'];<EOL>    options.exclude && options.exclude.forEach(function (filename) {<EOL>        glob.sync(filename).forEach(function (globFileName) {<EOL>            excludesMap[filenameToMid(pathUtil.resolve(baseDir, globFileName))] = true;<EOL>        });<EOL>    });<EOL>    if (options.exclude) {<EOL>        verboseMessage('<STR_LIT>');<EOL>        options.exclude.forEach(name => { verboseMessage('<STR_LIT>' + name); });<EOL>    }<EOL>    mkdirp.sync(pathUtil.dirname(options.out));<EOL>    <EOL>    const output = fs.createWriteStream(options.out, <any>{ mode: parseInt('<STR_LIT>', <NUM_LIT>) });<EOL>    const host = ts.createCompilerHost(compilerOptions);<EOL>    const program = ts.createProgram(filenames, compilerOptions, host);<EOL>    function writeFile(filename: string, data: string, writeByteOrderMark: boolean) {<EOL>        <EOL>        if (filename.slice(-DTSLEN) !== '<STR_LIT>') {<EOL>            return;<EOL>        }<EOL>        writeDeclaration(ts.createSourceFile(filename, data, compilerOptions.target, true), true);<EOL>    }<EOL>    let declaredExternalModules: string[] = [];<EOL>    return new Promise<void>(function (resolve, reject) {<EOL>        output.on('<STR_LIT>', () => { resolve(undefined); });<EOL>        output.on('<STR_LIT>', reject);<EOL>        if (options.externs) {<EOL>            options.externs.forEach(function (path: string) {<EOL>                sendMessage(`<STR_LIT>`);<EOL>                output.write(`<STR_LIT>` + eol);<EOL>            });<EOL>        }<EOL>        if (options.types) {<EOL>            options.types.forEach(function (type: string) {<EOL>                sendMessage(`<STR_LIT>`);<EOL>                output.write(`<STR_LIT>` + eol);<EOL>            });<EOL>        }<EOL>        sendMessage('<STR_LIT>');<EOL>        let mainExportDeclaration = false;<EOL>        let mainExportAssignment = false;<EOL>        let foundMain = false;<EOL>        program.getSourceFiles().forEach(function (sourceFile) {<EOL>            processTree(sourceFile, function (node) {<EOL>                if (isNodeKindModuleDeclaration(node)) {<EOL>                    const name = node.name;<EOL>                    if (isNodeKindStringLiteral(name)) {<EOL>                        declaredExternalModules.push(name.text);<EOL>                    }<EOL>                }<EOL>                return null;<EOL>            });<EOL>        });<EOL>        program.getSourceFiles().some(function (sourceFile) {<EOL>            <EOL>            <EOL>            if (pathUtil.normalize(sourceFile.fileName).indexOf(baseDir) !== <NUM_LIT>) {<EOL>                return;<EOL>            }<EOL>            if (excludesMap[filenameToMid(pathUtil.normalize(sourceFile.fileName))]) {<EOL>                return;<EOL>            }<EOL>            sendMessage(`<STR_LIT>`);<EOL>            <EOL>            if (sourceFile.fileName.slice(-DTSLEN) === '<STR_LIT>') {<EOL>                writeDeclaration(sourceFile, false);<EOL>                return;<EOL>            }<EOL>            <EOL>            if (options.main && options.main === (options.prefix + filenameToMid(sourceFile.fileName.slice(baseDir.length, -<NUM_LIT>)))) {<EOL>                foundMain = true;<EOL>                ts.forEachChild(sourceFile, function (node: ts.Node) {<EOL>                    mainExportDeclaration =","gt":"mainExportDeclaration ||"}
{"input":"<s> export default function generate(options: Options): Promise<void> {<EOL>    if (Boolean(options.main) !== Boolean(options.name)) {<EOL>        if (Boolean(options.name)) {<EOL>            <EOL>            <EOL>            <EOL>            <EOL>            throw new Error(`<STR_LIT>`);<EOL>        }<EOL>        else {<EOL>            throw new Error('<STR_LIT>');<EOL>        }<EOL>    }<EOL>    const noop = function (message?: any, ...optionalParams: any[]): void { };<EOL>    const sendMessage = options.sendMessage || noop;<EOL>    const verboseMessage = options.verbose ? sendMessage : noop;<EOL>    let compilerOptions: ts.CompilerOptions = {};<EOL>    let files: string[] = options.files;<EOL>    <EOL>    if (options.project || !options.files || options.files.length === <NUM_LIT>) {<EOL>        verboseMessage(`<STR_LIT>`);<EOL>        <EOL>        <EOL>        <EOL>        <EOL>        let tsconfigFilename: string;<EOL>        if (Boolean(options.project)) {<EOL>            if (fs.lstatSync(options.project).isDirectory()) {<EOL>                tsconfigFilename = pathUtil.join(options.project, '<STR_LIT>');<EOL>            }<EOL>            else {<EOL>                <EOL>                tsconfigFilename = options.project;<EOL>            }<EOL>        }<EOL>        else {<EOL>            tsconfigFilename = pathUtil.join(options.baseDir, '<STR_LIT>');<EOL>        }<EOL>        if (fs.existsSync(tsconfigFilename)) {<EOL>            verboseMessage(`<STR_LIT>`);<EOL>            [files, compilerOptions] = getTSConfig(options, tsconfigFilename);<EOL>        }<EOL>        else {<EOL>            sendMessage(`<STR_LIT>`);<EOL>            return new Promise<void>(function (resolve, reject) {<EOL>                reject(new SyntaxError('<STR_LIT>'));<EOL>            });<EOL>        }<EOL>    }<EOL>    const eol = options.eol || os.EOL;<EOL>    const nonEmptyLineStart = new RegExp(eol + '<STR_LIT>' + eol + '<STR_LIT>', '<STR_LIT>');<EOL>    const indent = options.indent === undefined ? '<STR_LIT>' : options.indent;<EOL>    <EOL>    <EOL>    compilerOptions.declaration = true;<EOL>    compilerOptions.target = compilerOptions.target || ts.ScriptTarget.Latest; <EOL>    compilerOptions.moduleResolution = compilerOptions.moduleResolution || options.moduleResolution;<EOL>    compilerOptions.outDir = compilerOptions.outDir || options.outDir;<EOL>    <EOL>    const baseDir = pathUtil.resolve(compilerOptions.rootDir || options.project || options.baseDir);<EOL>    const outDir = compilerOptions.outDir;<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    const filenames = getFilenames(baseDir, files);<EOL>    verboseMessage('<STR_LIT>');<EOL>    filenames.forEach(name => { verboseMessage('<STR_LIT>' + name); });<EOL>    const excludesMap: {<EOL>        [filename: string]: boolean;<EOL>    } = {};<EOL>    options.exclude = options.exclude || ['<STR_LIT>'];<EOL>    options.exclude && options.exclude.forEach(function (filename) {<EOL>        glob.sync(filename).forEach(function (globFileName) {<EOL>            excludesMap[filenameToMid(pathUtil.resolve(baseDir, globFileName))] = true;<EOL>        });<EOL>    });<EOL>    if (options.exclude) {<EOL>        verboseMessage('<STR_LIT>');<EOL>        options.exclude.forEach(name => { verboseMessage('<STR_LIT>' + name); });<EOL>    }<EOL>    mkdirp.sync(pathUtil.dirname(options.out));<EOL>    <EOL>    const output = fs.createWriteStream(options.out, <any>{ mode: parseInt('<STR_LIT>', <NUM_LIT>) });<EOL>    const host = ts.createCompilerHost(compilerOptions);<EOL>    const program = ts.createProgram(filenames, compilerOptions, host);<EOL>    function writeFile(filename: string, data: string, writeByteOrderMark: boolean) {<EOL>        <EOL>        if (filename.slice(-DTSLEN) !== '<STR_LIT>') {<EOL>            return;<EOL>        }<EOL>        writeDeclaration(ts.createSourceFile(filename, data, compilerOptions.target, true), true);<EOL>    }<EOL>    let declaredExternalModules: string[] = [];<EOL>    return new Promise<void>(function (resolve, reject) {<EOL>        output.on('<STR_LIT>', () => { resolve(undefined); });<EOL>        output.on('<STR_LIT>', reject);<EOL>        if (options.externs) {<EOL>            options.externs.forEach(function (path: string) {<EOL>                sendMessage(`<STR_LIT>`);<EOL>                output.write(`<STR_LIT>` + eol);<EOL>            });<EOL>        }<EOL>        if (options.types) {<EOL>            options.types.forEach(function (type: string) {<EOL>                sendMessage(`<STR_LIT>`);<EOL>                output.write(`<STR_LIT>` + eol);<EOL>            });<EOL>        }<EOL>        sendMessage('<STR_LIT>');<EOL>        let mainExportDeclaration = false;<EOL>        let mainExportAssignment = false;<EOL>        let foundMain = false;<EOL>        program.getSourceFiles().forEach(function (sourceFile) {<EOL>            processTree(sourceFile, function (node) {<EOL>                if (isNodeKindModuleDeclaration(node)) {<EOL>                    const name = node.name;<EOL>                    if (isNodeKindStringLiteral(name)) {<EOL>                        declaredExternalModules.push(name.text);<EOL>                    }<EOL>                }<EOL>                return null;<EOL>            });<EOL>        });<EOL>        program.getSourceFiles().some(function (sourceFile) {<EOL>            <EOL>            <EOL>            if (pathUtil.normalize(sourceFile.fileName).indexOf(baseDir) !== <NUM_LIT>) {<EOL>                return;<EOL>            }<EOL>            if (excludesMap[filenameToMid(pathUtil.normalize(sourceFile.fileName))]) {<EOL>                return;<EOL>            }<EOL>            sendMessage(`<STR_LIT>`);<EOL>            <EOL>            if (sourceFile.fileName.slice(-DTSLEN) === '<STR_LIT>') {<EOL>                writeDeclaration(sourceFile, false);<EOL>                return;<EOL>            }<EOL>            <EOL>            if (options.main && options.main === (options.prefix + filenameToMid(sourceFile.fileName.slice(baseDir.length, -<NUM_LIT>)))) {<EOL>                foundMain = true;<EOL>                ts.forEachChild(sourceFile, function (node: ts.Node) {<EOL>                    mainExportDeclaration = mainExportDeclaration ||","gt":"isNodeKindExportDeclaration(node);"}
{"input":"<s> export default function generate(options: Options): Promise<void> {<EOL>    if (Boolean(options.main) !== Boolean(options.name)) {<EOL>        if (Boolean(options.name)) {<EOL>            <EOL>            <EOL>            <EOL>            <EOL>            throw new Error(`<STR_LIT>`);<EOL>        }<EOL>        else {<EOL>            throw new Error('<STR_LIT>');<EOL>        }<EOL>    }<EOL>    const noop = function (message?: any, ...optionalParams: any[]): void { };<EOL>    const sendMessage = options.sendMessage || noop;<EOL>    const verboseMessage = options.verbose ? sendMessage : noop;<EOL>    let compilerOptions: ts.CompilerOptions = {};<EOL>    let files: string[] = options.files;<EOL>    <EOL>    if (options.project || !options.files || options.files.length === <NUM_LIT>) {<EOL>        verboseMessage(`<STR_LIT>`);<EOL>        <EOL>        <EOL>        <EOL>        <EOL>        let tsconfigFilename: string;<EOL>        if (Boolean(options.project)) {<EOL>            if (fs.lstatSync(options.project).isDirectory()) {<EOL>                tsconfigFilename = pathUtil.join(options.project, '<STR_LIT>');<EOL>            }<EOL>            else {<EOL>                <EOL>                tsconfigFilename = options.project;<EOL>            }<EOL>        }<EOL>        else {<EOL>            tsconfigFilename = pathUtil.join(options.baseDir, '<STR_LIT>');<EOL>        }<EOL>        if (fs.existsSync(tsconfigFilename)) {<EOL>            verboseMessage(`<STR_LIT>`);<EOL>            [files, compilerOptions] = getTSConfig(options, tsconfigFilename);<EOL>        }<EOL>        else {<EOL>            sendMessage(`<STR_LIT>`);<EOL>            return new Promise<void>(function (resolve, reject) {<EOL>                reject(new SyntaxError('<STR_LIT>'));<EOL>            });<EOL>        }<EOL>    }<EOL>    const eol = options.eol || os.EOL;<EOL>    const nonEmptyLineStart = new RegExp(eol + '<STR_LIT>' + eol + '<STR_LIT>', '<STR_LIT>');<EOL>    const indent = options.indent === undefined ? '<STR_LIT>' : options.indent;<EOL>    <EOL>    <EOL>    compilerOptions.declaration = true;<EOL>    compilerOptions.target = compilerOptions.target || ts.ScriptTarget.Latest; <EOL>    compilerOptions.moduleResolution = compilerOptions.moduleResolution || options.moduleResolution;<EOL>    compilerOptions.outDir = compilerOptions.outDir || options.outDir;<EOL>    <EOL>    const baseDir = pathUtil.resolve(compilerOptions.rootDir || options.project || options.baseDir);<EOL>    const outDir = compilerOptions.outDir;<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    const filenames = getFilenames(baseDir, files);<EOL>    verboseMessage('<STR_LIT>');<EOL>    filenames.forEach(name => { verboseMessage('<STR_LIT>' + name); });<EOL>    const excludesMap: {<EOL>        [filename: string]: boolean;<EOL>    } = {};<EOL>    options.exclude = options.exclude || ['<STR_LIT>'];<EOL>    options.exclude && options.exclude.forEach(function (filename) {<EOL>        glob.sync(filename).forEach(function (globFileName) {<EOL>            excludesMap[filenameToMid(pathUtil.resolve(baseDir, globFileName))] = true;<EOL>        });<EOL>    });<EOL>    if (options.exclude) {<EOL>        verboseMessage('<STR_LIT>');<EOL>        options.exclude.forEach(name => { verboseMessage('<STR_LIT>' + name); });<EOL>    }<EOL>    mkdirp.sync(pathUtil.dirname(options.out));<EOL>    <EOL>    const output = fs.createWriteStream(options.out, <any>{ mode: parseInt('<STR_LIT>', <NUM_LIT>) });<EOL>    const host = ts.createCompilerHost(compilerOptions);<EOL>    const program = ts.createProgram(filenames, compilerOptions, host);<EOL>    function writeFile(filename: string, data: string, writeByteOrderMark: boolean) {<EOL>        <EOL>        if (filename.slice(-DTSLEN) !== '<STR_LIT>') {<EOL>            return;<EOL>        }<EOL>        writeDeclaration(ts.createSourceFile(filename, data, compilerOptions.target, true), true);<EOL>    }<EOL>    let declaredExternalModules: string[] = [];<EOL>    return new Promise<void>(function (resolve, reject) {<EOL>        output.on('<STR_LIT>', () => { resolve(undefined); });<EOL>        output.on('<STR_LIT>', reject);<EOL>        if (options.externs) {<EOL>            options.externs.forEach(function (path: string) {<EOL>                sendMessage(`<STR_LIT>`);<EOL>                output.write(`<STR_LIT>` + eol);<EOL>            });<EOL>        }<EOL>        if (options.types) {<EOL>            options.types.forEach(function (type: string) {<EOL>                sendMessage(`<STR_LIT>`);<EOL>                output.write(`<STR_LIT>` + eol);<EOL>            });<EOL>        }<EOL>        sendMessage('<STR_LIT>');<EOL>        let mainExportDeclaration = false;<EOL>        let mainExportAssignment = false;<EOL>        let foundMain = false;<EOL>        program.getSourceFiles().forEach(function (sourceFile) {<EOL>            processTree(sourceFile, function (node) {<EOL>                if (isNodeKindModuleDeclaration(node)) {<EOL>                    const name = node.name;<EOL>                    if (isNodeKindStringLiteral(name)) {<EOL>                        declaredExternalModules.push(name.text);<EOL>                    }<EOL>                }<EOL>                return null;<EOL>            });<EOL>        });<EOL>        program.getSourceFiles().some(function (sourceFile) {<EOL>            <EOL>            <EOL>            if (pathUtil.normalize(sourceFile.fileName).indexOf(baseDir) !== <NUM_LIT>) {<EOL>                return;<EOL>            }<EOL>            if (excludesMap[filenameToMid(pathUtil.normalize(sourceFile.fileName))]) {<EOL>                return;<EOL>            }<EOL>            sendMessage(`<STR_LIT>`);<EOL>            <EOL>            if (sourceFile.fileName.slice(-DTSLEN) === '<STR_LIT>') {<EOL>                writeDeclaration(sourceFile, false);<EOL>                return;<EOL>            }<EOL>            <EOL>            if (options.main && options.main === (options.prefix + filenameToMid(sourceFile.fileName.slice(baseDir.length, -<NUM_LIT>)))) {<EOL>                foundMain = true;<EOL>                ts.forEachChild(sourceFile, function (node: ts.Node) {<EOL>                    mainExportDeclaration = mainExportDeclaration || isNodeKindExportDeclaration(node);<EOL>                    mainExportAssignment = mainExportAssignment || isNodeKindExportAssignment(","gt":"node);"}
{"input":"<s> export default function generate(options: Options): Promise<void> {<EOL>    if (Boolean(options.main) !== Boolean(options.name)) {<EOL>        if (Boolean(options.name)) {<EOL>            <EOL>            <EOL>            <EOL>            <EOL>            throw new Error(`<STR_LIT>`);<EOL>        }<EOL>        else {<EOL>            throw new Error('<STR_LIT>');<EOL>        }<EOL>    }<EOL>    const noop = function (message?: any, ...optionalParams: any[]): void { };<EOL>    const sendMessage = options.sendMessage || noop;<EOL>    const verboseMessage = options.verbose ? sendMessage : noop;<EOL>    let compilerOptions: ts.CompilerOptions = {};<EOL>    let files: string[] = options.files;<EOL>    <EOL>    if (options.project || !options.files || options.files.length === <NUM_LIT>) {<EOL>        verboseMessage(`<STR_LIT>`);<EOL>        <EOL>        <EOL>        <EOL>        <EOL>        let tsconfigFilename: string;<EOL>        if (Boolean(options.project)) {<EOL>            if (fs.lstatSync(options.project).isDirectory()) {<EOL>                tsconfigFilename = pathUtil.join(options.project, '<STR_LIT>');<EOL>            }<EOL>            else {<EOL>                <EOL>                tsconfigFilename = options.project;<EOL>            }<EOL>        }<EOL>        else {<EOL>            tsconfigFilename = pathUtil.join(options.baseDir, '<STR_LIT>');<EOL>        }<EOL>        if (fs.existsSync(tsconfigFilename)) {<EOL>            verboseMessage(`<STR_LIT>`);<EOL>            [files, compilerOptions] = getTSConfig(options, tsconfigFilename);<EOL>        }<EOL>        else {<EOL>            sendMessage(`<STR_LIT>`);<EOL>            return new Promise<void>(function (resolve, reject) {<EOL>                reject(new SyntaxError('<STR_LIT>'));<EOL>            });<EOL>        }<EOL>    }<EOL>    const eol = options.eol || os.EOL;<EOL>    const nonEmptyLineStart = new RegExp(eol + '<STR_LIT>' + eol + '<STR_LIT>', '<STR_LIT>');<EOL>    const indent = options.indent === undefined ? '<STR_LIT>' : options.indent;<EOL>    <EOL>    <EOL>    compilerOptions.declaration = true;<EOL>    compilerOptions.target = compilerOptions.target || ts.ScriptTarget.Latest; <EOL>    compilerOptions.moduleResolution = compilerOptions.moduleResolution || options.moduleResolution;<EOL>    compilerOptions.outDir = compilerOptions.outDir || options.outDir;<EOL>    <EOL>    const baseDir = pathUtil.resolve(compilerOptions.rootDir || options.project || options.baseDir);<EOL>    const outDir = compilerOptions.outDir;<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    const filenames = getFilenames(baseDir, files);<EOL>    verboseMessage('<STR_LIT>');<EOL>    filenames.forEach(name => { verboseMessage('<STR_LIT>' + name); });<EOL>    const excludesMap: {<EOL>        [filename: string]: boolean;<EOL>    } = {};<EOL>    options.exclude = options.exclude || ['<STR_LIT>'];<EOL>    options.exclude && options.exclude.forEach(function (filename) {<EOL>        glob.sync(filename).forEach(function (globFileName) {<EOL>            excludesMap[filenameToMid(pathUtil.resolve(baseDir, globFileName))] = true;<EOL>        });<EOL>    });<EOL>    if (options.exclude) {<EOL>        verboseMessage('<STR_LIT>');<EOL>        options.exclude.forEach(name => { verboseMessage('<STR_LIT>' + name); });<EOL>    }<EOL>    mkdirp.sync(pathUtil.dirname(options.out));<EOL>    <EOL>    const output = fs.createWriteStream(options.out, <any>{ mode: parseInt('<STR_LIT>', <NUM_LIT>) });<EOL>    const host = ts.createCompilerHost(compilerOptions);<EOL>    const program = ts.createProgram(filenames, compilerOptions, host);<EOL>    function writeFile(filename: string, data: string, writeByteOrderMark: boolean) {<EOL>        <EOL>        if (filename.slice(-DTSLEN) !== '<STR_LIT>') {<EOL>            return;<EOL>        }<EOL>        writeDeclaration(ts.createSourceFile(filename, data, compilerOptions.target, true), true);<EOL>    }<EOL>    let declaredExternalModules: string[] = [];<EOL>    return new Promise<void>(function (resolve, reject) {<EOL>        output.on('<STR_LIT>', () => { resolve(undefined); });<EOL>        output.on('<STR_LIT>', reject);<EOL>        if (options.externs) {<EOL>            options.externs.forEach(function (path: string) {<EOL>                sendMessage(`<STR_LIT>`);<EOL>                output.write(`<STR_LIT>` + eol);<EOL>            });<EOL>        }<EOL>        if (options.types) {<EOL>            options.types.forEach(function (type: string) {<EOL>                sendMessage(`<STR_LIT>`);<EOL>                output.write(`<STR_LIT>` + eol);<EOL>            });<EOL>        }<EOL>        sendMessage('<STR_LIT>');<EOL>        let mainExportDeclaration = false;<EOL>        let mainExportAssignment = false;<EOL>        let foundMain = false;<EOL>        program.getSourceFiles().forEach(function (sourceFile) {<EOL>            processTree(sourceFile, function (node) {<EOL>                if (isNodeKindModuleDeclaration(node)) {<EOL>                    const name = node.name;<EOL>                    if (isNodeKindStringLiteral(name)) {<EOL>                        declaredExternalModules.push(name.text);<EOL>                    }<EOL>                }<EOL>                return null;<EOL>            });<EOL>        });<EOL>        program.getSourceFiles().some(function (sourceFile) {<EOL>            <EOL>            <EOL>            if (pathUtil.normalize(sourceFile.fileName).indexOf(baseDir) !== <NUM_LIT>) {<EOL>                return;<EOL>            }<EOL>            if (excludesMap[filenameToMid(pathUtil.normalize(sourceFile.fileName))]) {<EOL>                return;<EOL>            }<EOL>            sendMessage(`<STR_LIT>`);<EOL>            <EOL>            if (sourceFile.fileName.slice(-DTSLEN) === '<STR_LIT>') {<EOL>                writeDeclaration(sourceFile, false);<EOL>                return;<EOL>            }<EOL>            <EOL>            if (options.main && options.main === (options.prefix + filenameToMid(sourceFile.fileName.slice(baseDir.length, -<NUM_LIT>)))) {<EOL>                foundMain = true;<EOL>                ts.forEachChild(sourceFile, function (node: ts.Node) {<EOL>                    mainExportDeclaration = mainExportDeclaration || isNodeKindExportDeclaration(node);<EOL>                    mainExportAssignment = mainExportAssignment || isNodeKindExportAssignment(node);<EOL>                });<EOL>            }<EOL>            const emitOutput =","gt":"program.emit(sourceFile, writeFile);"}
{"input":"<s> export default function generate(options: Options): Promise<void> {<EOL>    if (Boolean(options.main) !== Boolean(options.name)) {<EOL>        if (Boolean(options.name)) {<EOL>            <EOL>            <EOL>            <EOL>            <EOL>            throw new Error(`<STR_LIT>`);<EOL>        }<EOL>        else {<EOL>            throw new Error('<STR_LIT>');<EOL>        }<EOL>    }<EOL>    const noop = function (message?: any, ...optionalParams: any[]): void { };<EOL>    const sendMessage = options.sendMessage || noop;<EOL>    const verboseMessage = options.verbose ? sendMessage : noop;<EOL>    let compilerOptions: ts.CompilerOptions = {};<EOL>    let files: string[] = options.files;<EOL>    <EOL>    if (options.project || !options.files || options.files.length === <NUM_LIT>) {<EOL>        verboseMessage(`<STR_LIT>`);<EOL>        <EOL>        <EOL>        <EOL>        <EOL>        let tsconfigFilename: string;<EOL>        if (Boolean(options.project)) {<EOL>            if (fs.lstatSync(options.project).isDirectory()) {<EOL>                tsconfigFilename = pathUtil.join(options.project, '<STR_LIT>');<EOL>            }<EOL>            else {<EOL>                <EOL>                tsconfigFilename = options.project;<EOL>            }<EOL>        }<EOL>        else {<EOL>            tsconfigFilename = pathUtil.join(options.baseDir, '<STR_LIT>');<EOL>        }<EOL>        if (fs.existsSync(tsconfigFilename)) {<EOL>            verboseMessage(`<STR_LIT>`);<EOL>            [files, compilerOptions] = getTSConfig(options, tsconfigFilename);<EOL>        }<EOL>        else {<EOL>            sendMessage(`<STR_LIT>`);<EOL>            return new Promise<void>(function (resolve, reject) {<EOL>                reject(new SyntaxError('<STR_LIT>'));<EOL>            });<EOL>        }<EOL>    }<EOL>    const eol = options.eol || os.EOL;<EOL>    const nonEmptyLineStart = new RegExp(eol + '<STR_LIT>' + eol + '<STR_LIT>', '<STR_LIT>');<EOL>    const indent = options.indent === undefined ? '<STR_LIT>' : options.indent;<EOL>    <EOL>    <EOL>    compilerOptions.declaration = true;<EOL>    compilerOptions.target = compilerOptions.target || ts.ScriptTarget.Latest; <EOL>    compilerOptions.moduleResolution = compilerOptions.moduleResolution || options.moduleResolution;<EOL>    compilerOptions.outDir = compilerOptions.outDir || options.outDir;<EOL>    <EOL>    const baseDir = pathUtil.resolve(compilerOptions.rootDir || options.project || options.baseDir);<EOL>    const outDir = compilerOptions.outDir;<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    const filenames = getFilenames(baseDir, files);<EOL>    verboseMessage('<STR_LIT>');<EOL>    filenames.forEach(name => { verboseMessage('<STR_LIT>' + name); });<EOL>    const excludesMap: {<EOL>        [filename: string]: boolean;<EOL>    } = {};<EOL>    options.exclude = options.exclude || ['<STR_LIT>'];<EOL>    options.exclude && options.exclude.forEach(function (filename) {<EOL>        glob.sync(filename).forEach(function (globFileName) {<EOL>            excludesMap[filenameToMid(pathUtil.resolve(baseDir, globFileName))] = true;<EOL>        });<EOL>    });<EOL>    if (options.exclude) {<EOL>        verboseMessage('<STR_LIT>');<EOL>        options.exclude.forEach(name => { verboseMessage('<STR_LIT>' + name); });<EOL>    }<EOL>    mkdirp.sync(pathUtil.dirname(options.out));<EOL>    <EOL>    const output = fs.createWriteStream(options.out, <any>{ mode: parseInt('<STR_LIT>', <NUM_LIT>) });<EOL>    const host = ts.createCompilerHost(compilerOptions);<EOL>    const program = ts.createProgram(filenames, compilerOptions, host);<EOL>    function writeFile(filename: string, data: string, writeByteOrderMark: boolean) {<EOL>        <EOL>        if (filename.slice(-DTSLEN) !== '<STR_LIT>') {<EOL>            return;<EOL>        }<EOL>        writeDeclaration(ts.createSourceFile(filename, data, compilerOptions.target, true), true);<EOL>    }<EOL>    let declaredExternalModules: string[] = [];<EOL>    return new Promise<void>(function (resolve, reject) {<EOL>        output.on('<STR_LIT>', () => { resolve(undefined); });<EOL>        output.on('<STR_LIT>', reject);<EOL>        if (options.externs) {<EOL>            options.externs.forEach(function (path: string) {<EOL>                sendMessage(`<STR_LIT>`);<EOL>                output.write(`<STR_LIT>` + eol);<EOL>            });<EOL>        }<EOL>        if (options.types) {<EOL>            options.types.forEach(function (type: string) {<EOL>                sendMessage(`<STR_LIT>`);<EOL>                output.write(`<STR_LIT>` + eol);<EOL>            });<EOL>        }<EOL>        sendMessage('<STR_LIT>');<EOL>        let mainExportDeclaration = false;<EOL>        let mainExportAssignment = false;<EOL>        let foundMain = false;<EOL>        program.getSourceFiles().forEach(function (sourceFile) {<EOL>            processTree(sourceFile, function (node) {<EOL>                if (isNodeKindModuleDeclaration(node)) {<EOL>                    const name = node.name;<EOL>                    if (isNodeKindStringLiteral(name)) {<EOL>                        declaredExternalModules.push(name.text);<EOL>                    }<EOL>                }<EOL>                return null;<EOL>            });<EOL>        });<EOL>        program.getSourceFiles().some(function (sourceFile) {<EOL>            <EOL>            <EOL>            if (pathUtil.normalize(sourceFile.fileName).indexOf(baseDir) !== <NUM_LIT>) {<EOL>                return;<EOL>            }<EOL>            if (excludesMap[filenameToMid(pathUtil.normalize(sourceFile.fileName))]) {<EOL>                return;<EOL>            }<EOL>            sendMessage(`<STR_LIT>`);<EOL>            <EOL>            if (sourceFile.fileName.slice(-DTSLEN) === '<STR_LIT>') {<EOL>                writeDeclaration(sourceFile, false);<EOL>                return;<EOL>            }<EOL>            <EOL>            if (options.main && options.main === (options.prefix + filenameToMid(sourceFile.fileName.slice(baseDir.length, -<NUM_LIT>)))) {<EOL>                foundMain = true;<EOL>                ts.forEachChild(sourceFile, function (node: ts.Node) {<EOL>                    mainExportDeclaration = mainExportDeclaration || isNodeKindExportDeclaration(node);<EOL>                    mainExportAssignment = mainExportAssignment || isNodeKindExportAssignment(node);<EOL>                });<EOL>            }<EOL>            const emitOutput = program.emit(sourceFile, writeFile);<EOL>            if (emitOutput.emitSkipped || emitOutput.diagnostics.length > <NUM_LIT>) {<EOL>                reject(getError(emitOutput.diagnostics<EOL>                    .concat(program.getSemanticDiagnostics(sourceFile))<EOL>                    .concat(program.","gt":"getSyntacticDiagnostics(sourceFile))"}
{"input":"<s> export default function generate(options: Options): Promise<void> {<EOL>    if (Boolean(options.main) !== Boolean(options.name)) {<EOL>        if (Boolean(options.name)) {<EOL>            <EOL>            <EOL>            <EOL>            <EOL>            throw new Error(`<STR_LIT>`);<EOL>        }<EOL>        else {<EOL>            throw new Error('<STR_LIT>');<EOL>        }<EOL>    }<EOL>    const noop = function (message?: any, ...optionalParams: any[]): void { };<EOL>    const sendMessage = options.sendMessage || noop;<EOL>    const verboseMessage = options.verbose ? sendMessage : noop;<EOL>    let compilerOptions: ts.CompilerOptions = {};<EOL>    let files: string[] = options.files;<EOL>    <EOL>    if (options.project || !options.files || options.files.length === <NUM_LIT>) {<EOL>        verboseMessage(`<STR_LIT>`);<EOL>        <EOL>        <EOL>        <EOL>        <EOL>        let tsconfigFilename: string;<EOL>        if (Boolean(options.project)) {<EOL>            if (fs.lstatSync(options.project).isDirectory()) {<EOL>                tsconfigFilename = pathUtil.join(options.project, '<STR_LIT>');<EOL>            }<EOL>            else {<EOL>                <EOL>                tsconfigFilename = options.project;<EOL>            }<EOL>        }<EOL>        else {<EOL>            tsconfigFilename = pathUtil.join(options.baseDir, '<STR_LIT>');<EOL>        }<EOL>        if (fs.existsSync(tsconfigFilename)) {<EOL>            verboseMessage(`<STR_LIT>`);<EOL>            [files, compilerOptions] = getTSConfig(options, tsconfigFilename);<EOL>        }<EOL>        else {<EOL>            sendMessage(`<STR_LIT>`);<EOL>            return new Promise<void>(function (resolve, reject) {<EOL>                reject(new SyntaxError('<STR_LIT>'));<EOL>            });<EOL>        }<EOL>    }<EOL>    const eol = options.eol || os.EOL;<EOL>    const nonEmptyLineStart = new RegExp(eol + '<STR_LIT>' + eol + '<STR_LIT>', '<STR_LIT>');<EOL>    const indent = options.indent === undefined ? '<STR_LIT>' : options.indent;<EOL>    <EOL>    <EOL>    compilerOptions.declaration = true;<EOL>    compilerOptions.target = compilerOptions.target || ts.ScriptTarget.Latest; <EOL>    compilerOptions.moduleResolution = compilerOptions.moduleResolution || options.moduleResolution;<EOL>    compilerOptions.outDir = compilerOptions.outDir || options.outDir;<EOL>    <EOL>    const baseDir = pathUtil.resolve(compilerOptions.rootDir || options.project || options.baseDir);<EOL>    const outDir = compilerOptions.outDir;<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    const filenames = getFilenames(baseDir, files);<EOL>    verboseMessage('<STR_LIT>');<EOL>    filenames.forEach(name => { verboseMessage('<STR_LIT>' + name); });<EOL>    const excludesMap: {<EOL>        [filename: string]: boolean;<EOL>    } = {};<EOL>    options.exclude = options.exclude || ['<STR_LIT>'];<EOL>    options.exclude && options.exclude.forEach(function (filename) {<EOL>        glob.sync(filename).forEach(function (globFileName) {<EOL>            excludesMap[filenameToMid(pathUtil.resolve(baseDir, globFileName))] = true;<EOL>        });<EOL>    });<EOL>    if (options.exclude) {<EOL>        verboseMessage('<STR_LIT>');<EOL>        options.exclude.forEach(name => { verboseMessage('<STR_LIT>' + name); });<EOL>    }<EOL>    mkdirp.sync(pathUtil.dirname(options.out));<EOL>    <EOL>    const output = fs.createWriteStream(options.out, <any>{ mode: parseInt('<STR_LIT>', <NUM_LIT>) });<EOL>    const host = ts.createCompilerHost(compilerOptions);<EOL>    const program = ts.createProgram(filenames, compilerOptions, host);<EOL>    function writeFile(filename: string, data: string, writeByteOrderMark: boolean) {<EOL>        <EOL>        if (filename.slice(-DTSLEN) !== '<STR_LIT>') {<EOL>            return;<EOL>        }<EOL>        writeDeclaration(ts.createSourceFile(filename, data, compilerOptions.target, true), true);<EOL>    }<EOL>    let declaredExternalModules: string[] = [];<EOL>    return new Promise<void>(function (resolve, reject) {<EOL>        output.on('<STR_LIT>', () => { resolve(undefined); });<EOL>        output.on('<STR_LIT>', reject);<EOL>        if (options.externs) {<EOL>            options.externs.forEach(function (path: string) {<EOL>                sendMessage(`<STR_LIT>`);<EOL>                output.write(`<STR_LIT>` + eol);<EOL>            });<EOL>        }<EOL>        if (options.types) {<EOL>            options.types.forEach(function (type: string) {<EOL>                sendMessage(`<STR_LIT>`);<EOL>                output.write(`<STR_LIT>` + eol);<EOL>            });<EOL>        }<EOL>        sendMessage('<STR_LIT>');<EOL>        let mainExportDeclaration = false;<EOL>        let mainExportAssignment = false;<EOL>        let foundMain = false;<EOL>        program.getSourceFiles().forEach(function (sourceFile) {<EOL>            processTree(sourceFile, function (node) {<EOL>                if (isNodeKindModuleDeclaration(node)) {<EOL>                    const name = node.name;<EOL>                    if (isNodeKindStringLiteral(name)) {<EOL>                        declaredExternalModules.push(name.text);<EOL>                    }<EOL>                }<EOL>                return null;<EOL>            });<EOL>        });<EOL>        program.getSourceFiles().some(function (sourceFile) {<EOL>            <EOL>            <EOL>            if (pathUtil.normalize(sourceFile.fileName).indexOf(baseDir) !== <NUM_LIT>) {<EOL>                return;<EOL>            }<EOL>            if (excludesMap[filenameToMid(pathUtil.normalize(sourceFile.fileName))]) {<EOL>                return;<EOL>            }<EOL>            sendMessage(`<STR_LIT>`);<EOL>            <EOL>            if (sourceFile.fileName.slice(-DTSLEN) === '<STR_LIT>') {<EOL>                writeDeclaration(sourceFile, false);<EOL>                return;<EOL>            }<EOL>            <EOL>            if (options.main && options.main === (options.prefix + filenameToMid(sourceFile.fileName.slice(baseDir.length, -<NUM_LIT>)))) {<EOL>                foundMain = true;<EOL>                ts.forEachChild(sourceFile, function (node: ts.Node) {<EOL>                    mainExportDeclaration = mainExportDeclaration || isNodeKindExportDeclaration(node);<EOL>                    mainExportAssignment = mainExportAssignment || isNodeKindExportAssignment(node);<EOL>                });<EOL>            }<EOL>            const emitOutput = program.emit(sourceFile, writeFile);<EOL>            if (emitOutput.emitSkipped || emitOutput.diagnostics.length > <NUM_LIT>) {<EOL>                reject(getError(emitOutput.diagnostics<EOL>                    .concat(program.getSemanticDiagnostics(sourceFile))<EOL>                    .concat(program.getSyntacticDiagnostics(sourceFile))<EOL>                    .","gt":"concat(program.getDeclarationDiagnostics(sourceFile))));"}
{"input":"<s> export default function generate(options: Options): Promise<void> {<EOL>    if (Boolean(options.main) !== Boolean(options.name)) {<EOL>        if (Boolean(options.name)) {<EOL>            <EOL>            <EOL>            <EOL>            <EOL>            throw new Error(`<STR_LIT>`);<EOL>        }<EOL>        else {<EOL>            throw new Error('<STR_LIT>');<EOL>        }<EOL>    }<EOL>    const noop = function (message?: any, ...optionalParams: any[]): void { };<EOL>    const sendMessage = options.sendMessage || noop;<EOL>    const verboseMessage = options.verbose ? sendMessage : noop;<EOL>    let compilerOptions: ts.CompilerOptions = {};<EOL>    let files: string[] = options.files;<EOL>    <EOL>    if (options.project || !options.files || options.files.length === <NUM_LIT>) {<EOL>        verboseMessage(`<STR_LIT>`);<EOL>        <EOL>        <EOL>        <EOL>        <EOL>        let tsconfigFilename: string;<EOL>        if (Boolean(options.project)) {<EOL>            if (fs.lstatSync(options.project).isDirectory()) {<EOL>                tsconfigFilename = pathUtil.join(options.project, '<STR_LIT>');<EOL>            }<EOL>            else {<EOL>                <EOL>                tsconfigFilename = options.project;<EOL>            }<EOL>        }<EOL>        else {<EOL>            tsconfigFilename = pathUtil.join(options.baseDir, '<STR_LIT>');<EOL>        }<EOL>        if (fs.existsSync(tsconfigFilename)) {<EOL>            verboseMessage(`<STR_LIT>`);<EOL>            [files, compilerOptions] = getTSConfig(options, tsconfigFilename);<EOL>        }<EOL>        else {<EOL>            sendMessage(`<STR_LIT>`);<EOL>            return new Promise<void>(function (resolve, reject) {<EOL>                reject(new SyntaxError('<STR_LIT>'));<EOL>            });<EOL>        }<EOL>    }<EOL>    const eol = options.eol || os.EOL;<EOL>    const nonEmptyLineStart = new RegExp(eol + '<STR_LIT>' + eol + '<STR_LIT>', '<STR_LIT>');<EOL>    const indent = options.indent === undefined ? '<STR_LIT>' : options.indent;<EOL>    <EOL>    <EOL>    compilerOptions.declaration = true;<EOL>    compilerOptions.target = compilerOptions.target || ts.ScriptTarget.Latest; <EOL>    compilerOptions.moduleResolution = compilerOptions.moduleResolution || options.moduleResolution;<EOL>    compilerOptions.outDir = compilerOptions.outDir || options.outDir;<EOL>    <EOL>    const baseDir = pathUtil.resolve(compilerOptions.rootDir || options.project || options.baseDir);<EOL>    const outDir = compilerOptions.outDir;<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    const filenames = getFilenames(baseDir, files);<EOL>    verboseMessage('<STR_LIT>');<EOL>    filenames.forEach(name => { verboseMessage('<STR_LIT>' + name); });<EOL>    const excludesMap: {<EOL>        [filename: string]: boolean;<EOL>    } = {};<EOL>    options.exclude = options.exclude || ['<STR_LIT>'];<EOL>    options.exclude && options.exclude.forEach(function (filename) {<EOL>        glob.sync(filename).forEach(function (globFileName) {<EOL>            excludesMap[filenameToMid(pathUtil.resolve(baseDir, globFileName))] = true;<EOL>        });<EOL>    });<EOL>    if (options.exclude) {<EOL>        verboseMessage('<STR_LIT>');<EOL>        options.exclude.forEach(name => { verboseMessage('<STR_LIT>' + name); });<EOL>    }<EOL>    mkdirp.sync(pathUtil.dirname(options.out));<EOL>    <EOL>    const output = fs.createWriteStream(options.out, <any>{ mode: parseInt('<STR_LIT>', <NUM_LIT>) });<EOL>    const host = ts.createCompilerHost(compilerOptions);<EOL>    const program = ts.createProgram(filenames, compilerOptions, host);<EOL>    function writeFile(filename: string, data: string, writeByteOrderMark: boolean) {<EOL>        <EOL>        if (filename.slice(-DTSLEN) !== '<STR_LIT>') {<EOL>            return;<EOL>        }<EOL>        writeDeclaration(ts.createSourceFile(filename, data, compilerOptions.target, true), true);<EOL>    }<EOL>    let declaredExternalModules: string[] = [];<EOL>    return new Promise<void>(function (resolve, reject) {<EOL>        output.on('<STR_LIT>', () => { resolve(undefined); });<EOL>        output.on('<STR_LIT>', reject);<EOL>        if (options.externs) {<EOL>            options.externs.forEach(function (path: string) {<EOL>                sendMessage(`<STR_LIT>`);<EOL>                output.write(`<STR_LIT>` + eol);<EOL>            });<EOL>        }<EOL>        if (options.types) {<EOL>            options.types.forEach(function (type: string) {<EOL>                sendMessage(`<STR_LIT>`);<EOL>                output.write(`<STR_LIT>` + eol);<EOL>            });<EOL>        }<EOL>        sendMessage('<STR_LIT>');<EOL>        let mainExportDeclaration = false;<EOL>        let mainExportAssignment = false;<EOL>        let foundMain = false;<EOL>        program.getSourceFiles().forEach(function (sourceFile) {<EOL>            processTree(sourceFile, function (node) {<EOL>                if (isNodeKindModuleDeclaration(node)) {<EOL>                    const name = node.name;<EOL>                    if (isNodeKindStringLiteral(name)) {<EOL>                        declaredExternalModules.push(name.text);<EOL>                    }<EOL>                }<EOL>                return null;<EOL>            });<EOL>        });<EOL>        program.getSourceFiles().some(function (sourceFile) {<EOL>            <EOL>            <EOL>            if (pathUtil.normalize(sourceFile.fileName).indexOf(baseDir) !== <NUM_LIT>) {<EOL>                return;<EOL>            }<EOL>            if (excludesMap[filenameToMid(pathUtil.normalize(sourceFile.fileName))]) {<EOL>                return;<EOL>            }<EOL>            sendMessage(`<STR_LIT>`);<EOL>            <EOL>            if (sourceFile.fileName.slice(-DTSLEN) === '<STR_LIT>') {<EOL>                writeDeclaration(sourceFile, false);<EOL>                return;<EOL>            }<EOL>            <EOL>            if (options.main && options.main === (options.prefix + filenameToMid(sourceFile.fileName.slice(baseDir.length, -<NUM_LIT>)))) {<EOL>                foundMain = true;<EOL>                ts.forEachChild(sourceFile, function (node: ts.Node) {<EOL>                    mainExportDeclaration = mainExportDeclaration || isNodeKindExportDeclaration(node);<EOL>                    mainExportAssignment = mainExportAssignment || isNodeKindExportAssignment(node);<EOL>                });<EOL>            }<EOL>            const emitOutput = program.emit(sourceFile, writeFile);<EOL>            if (emitOutput.emitSkipped || emitOutput.diagnostics.length > <NUM_LIT>) {<EOL>                reject(getError(emitOutput.diagnostics<EOL>                    .concat(program.getSemanticDiagnostics(sourceFile))<EOL>                    .concat(program.getSyntacticDiagnostics(sourceFile))<EOL>                    .concat(program.getDeclarationDiagnostics(sourceFile))));<EOL>                return true;<EOL>            }<EOL>        });<EOL>        if (options.main && !foundMain) {<EOL>            throw new Error(`<STR_LIT>`);<EOL>        }<EOL>        if (options.main) {<EOL>            output.write(`<STR_LIT>` + eol + indent);<EOL>            if (compilerOptions.","gt":"target >= ts.ScriptTarget.ES2015) {"}
{"input":"<s> export default function generate(options: Options): Promise<void> {<EOL>    if (Boolean(options.main) !== Boolean(options.name)) {<EOL>        if (Boolean(options.name)) {<EOL>            <EOL>            <EOL>            <EOL>            <EOL>            throw new Error(`<STR_LIT>`);<EOL>        }<EOL>        else {<EOL>            throw new Error('<STR_LIT>');<EOL>        }<EOL>    }<EOL>    const noop = function (message?: any, ...optionalParams: any[]): void { };<EOL>    const sendMessage = options.sendMessage || noop;<EOL>    const verboseMessage = options.verbose ? sendMessage : noop;<EOL>    let compilerOptions: ts.CompilerOptions = {};<EOL>    let files: string[] = options.files;<EOL>    <EOL>    if (options.project || !options.files || options.files.length === <NUM_LIT>) {<EOL>        verboseMessage(`<STR_LIT>`);<EOL>        <EOL>        <EOL>        <EOL>        <EOL>        let tsconfigFilename: string;<EOL>        if (Boolean(options.project)) {<EOL>            if (fs.lstatSync(options.project).isDirectory()) {<EOL>                tsconfigFilename = pathUtil.join(options.project, '<STR_LIT>');<EOL>            }<EOL>            else {<EOL>                <EOL>                tsconfigFilename = options.project;<EOL>            }<EOL>        }<EOL>        else {<EOL>            tsconfigFilename = pathUtil.join(options.baseDir, '<STR_LIT>');<EOL>        }<EOL>        if (fs.existsSync(tsconfigFilename)) {<EOL>            verboseMessage(`<STR_LIT>`);<EOL>            [files, compilerOptions] = getTSConfig(options, tsconfigFilename);<EOL>        }<EOL>        else {<EOL>            sendMessage(`<STR_LIT>`);<EOL>            return new Promise<void>(function (resolve, reject) {<EOL>                reject(new SyntaxError('<STR_LIT>'));<EOL>            });<EOL>        }<EOL>    }<EOL>    const eol = options.eol || os.EOL;<EOL>    const nonEmptyLineStart = new RegExp(eol + '<STR_LIT>' + eol + '<STR_LIT>', '<STR_LIT>');<EOL>    const indent = options.indent === undefined ? '<STR_LIT>' : options.indent;<EOL>    <EOL>    <EOL>    compilerOptions.declaration = true;<EOL>    compilerOptions.target = compilerOptions.target || ts.ScriptTarget.Latest; <EOL>    compilerOptions.moduleResolution = compilerOptions.moduleResolution || options.moduleResolution;<EOL>    compilerOptions.outDir = compilerOptions.outDir || options.outDir;<EOL>    <EOL>    const baseDir = pathUtil.resolve(compilerOptions.rootDir || options.project || options.baseDir);<EOL>    const outDir = compilerOptions.outDir;<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    const filenames = getFilenames(baseDir, files);<EOL>    verboseMessage('<STR_LIT>');<EOL>    filenames.forEach(name => { verboseMessage('<STR_LIT>' + name); });<EOL>    const excludesMap: {<EOL>        [filename: string]: boolean;<EOL>    } = {};<EOL>    options.exclude = options.exclude || ['<STR_LIT>'];<EOL>    options.exclude && options.exclude.forEach(function (filename) {<EOL>        glob.sync(filename).forEach(function (globFileName) {<EOL>            excludesMap[filenameToMid(pathUtil.resolve(baseDir, globFileName))] = true;<EOL>        });<EOL>    });<EOL>    if (options.exclude) {<EOL>        verboseMessage('<STR_LIT>');<EOL>        options.exclude.forEach(name => { verboseMessage('<STR_LIT>' + name); });<EOL>    }<EOL>    mkdirp.sync(pathUtil.dirname(options.out));<EOL>    <EOL>    const output = fs.createWriteStream(options.out, <any>{ mode: parseInt('<STR_LIT>', <NUM_LIT>) });<EOL>    const host = ts.createCompilerHost(compilerOptions);<EOL>    const program = ts.createProgram(filenames, compilerOptions, host);<EOL>    function writeFile(filename: string, data: string, writeByteOrderMark: boolean) {<EOL>        <EOL>        if (filename.slice(-DTSLEN) !== '<STR_LIT>') {<EOL>            return;<EOL>        }<EOL>        writeDeclaration(ts.createSourceFile(filename, data, compilerOptions.target, true), true);<EOL>    }<EOL>    let declaredExternalModules: string[] = [];<EOL>    return new Promise<void>(function (resolve, reject) {<EOL>        output.on('<STR_LIT>', () => { resolve(undefined); });<EOL>        output.on('<STR_LIT>', reject);<EOL>        if (options.externs) {<EOL>            options.externs.forEach(function (path: string) {<EOL>                sendMessage(`<STR_LIT>`);<EOL>                output.write(`<STR_LIT>` + eol);<EOL>            });<EOL>        }<EOL>        if (options.types) {<EOL>            options.types.forEach(function (type: string) {<EOL>                sendMessage(`<STR_LIT>`);<EOL>                output.write(`<STR_LIT>` + eol);<EOL>            });<EOL>        }<EOL>        sendMessage('<STR_LIT>');<EOL>        let mainExportDeclaration = false;<EOL>        let mainExportAssignment = false;<EOL>        let foundMain = false;<EOL>        program.getSourceFiles().forEach(function (sourceFile) {<EOL>            processTree(sourceFile, function (node) {<EOL>                if (isNodeKindModuleDeclaration(node)) {<EOL>                    const name = node.name;<EOL>                    if (isNodeKindStringLiteral(name)) {<EOL>                        declaredExternalModules.push(name.text);<EOL>                    }<EOL>                }<EOL>                return null;<EOL>            });<EOL>        });<EOL>        program.getSourceFiles().some(function (sourceFile) {<EOL>            <EOL>            <EOL>            if (pathUtil.normalize(sourceFile.fileName).indexOf(baseDir) !== <NUM_LIT>) {<EOL>                return;<EOL>            }<EOL>            if (excludesMap[filenameToMid(pathUtil.normalize(sourceFile.fileName))]) {<EOL>                return;<EOL>            }<EOL>            sendMessage(`<STR_LIT>`);<EOL>            <EOL>            if (sourceFile.fileName.slice(-DTSLEN) === '<STR_LIT>') {<EOL>                writeDeclaration(sourceFile, false);<EOL>                return;<EOL>            }<EOL>            <EOL>            if (options.main && options.main === (options.prefix + filenameToMid(sourceFile.fileName.slice(baseDir.length, -<NUM_LIT>)))) {<EOL>                foundMain = true;<EOL>                ts.forEachChild(sourceFile, function (node: ts.Node) {<EOL>                    mainExportDeclaration = mainExportDeclaration || isNodeKindExportDeclaration(node);<EOL>                    mainExportAssignment = mainExportAssignment || isNodeKindExportAssignment(node);<EOL>                });<EOL>            }<EOL>            const emitOutput = program.emit(sourceFile, writeFile);<EOL>            if (emitOutput.emitSkipped || emitOutput.diagnostics.length > <NUM_LIT>) {<EOL>                reject(getError(emitOutput.diagnostics<EOL>                    .concat(program.getSemanticDiagnostics(sourceFile))<EOL>                    .concat(program.getSyntacticDiagnostics(sourceFile))<EOL>                    .concat(program.getDeclarationDiagnostics(sourceFile))));<EOL>                return true;<EOL>            }<EOL>        });<EOL>        if (options.main && !foundMain) {<EOL>            throw new Error(`<STR_LIT>`);<EOL>        }<EOL>        if (options.main) {<EOL>            output.write(`<STR_LIT>` + eol + indent);<EOL>            if (compilerOptions.target >= ts.ScriptTarget.ES2015) {<EOL>                if (mainExportAssignment) {<EOL>                    output.write(`<STR_LIT>` + eol +","gt":"indent);"}
{"input":"<s> export default function generate(options: Options): Promise<void> {<EOL>    if (Boolean(options.main) !== Boolean(options.name)) {<EOL>        if (Boolean(options.name)) {<EOL>            <EOL>            <EOL>            <EOL>            <EOL>            throw new Error(`<STR_LIT>`);<EOL>        }<EOL>        else {<EOL>            throw new Error('<STR_LIT>');<EOL>        }<EOL>    }<EOL>    const noop = function (message?: any, ...optionalParams: any[]): void { };<EOL>    const sendMessage = options.sendMessage || noop;<EOL>    const verboseMessage = options.verbose ? sendMessage : noop;<EOL>    let compilerOptions: ts.CompilerOptions = {};<EOL>    let files: string[] = options.files;<EOL>    <EOL>    if (options.project || !options.files || options.files.length === <NUM_LIT>) {<EOL>        verboseMessage(`<STR_LIT>`);<EOL>        <EOL>        <EOL>        <EOL>        <EOL>        let tsconfigFilename: string;<EOL>        if (Boolean(options.project)) {<EOL>            if (fs.lstatSync(options.project).isDirectory()) {<EOL>                tsconfigFilename = pathUtil.join(options.project, '<STR_LIT>');<EOL>            }<EOL>            else {<EOL>                <EOL>                tsconfigFilename = options.project;<EOL>            }<EOL>        }<EOL>        else {<EOL>            tsconfigFilename = pathUtil.join(options.baseDir, '<STR_LIT>');<EOL>        }<EOL>        if (fs.existsSync(tsconfigFilename)) {<EOL>            verboseMessage(`<STR_LIT>`);<EOL>            [files, compilerOptions] = getTSConfig(options, tsconfigFilename);<EOL>        }<EOL>        else {<EOL>            sendMessage(`<STR_LIT>`);<EOL>            return new Promise<void>(function (resolve, reject) {<EOL>                reject(new SyntaxError('<STR_LIT>'));<EOL>            });<EOL>        }<EOL>    }<EOL>    const eol = options.eol || os.EOL;<EOL>    const nonEmptyLineStart = new RegExp(eol + '<STR_LIT>' + eol + '<STR_LIT>', '<STR_LIT>');<EOL>    const indent = options.indent === undefined ? '<STR_LIT>' : options.indent;<EOL>    <EOL>    <EOL>    compilerOptions.declaration = true;<EOL>    compilerOptions.target = compilerOptions.target || ts.ScriptTarget.Latest; <EOL>    compilerOptions.moduleResolution = compilerOptions.moduleResolution || options.moduleResolution;<EOL>    compilerOptions.outDir = compilerOptions.outDir || options.outDir;<EOL>    <EOL>    const baseDir = pathUtil.resolve(compilerOptions.rootDir || options.project || options.baseDir);<EOL>    const outDir = compilerOptions.outDir;<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    const filenames = getFilenames(baseDir, files);<EOL>    verboseMessage('<STR_LIT>');<EOL>    filenames.forEach(name => { verboseMessage('<STR_LIT>' + name); });<EOL>    const excludesMap: {<EOL>        [filename: string]: boolean;<EOL>    } = {};<EOL>    options.exclude = options.exclude || ['<STR_LIT>'];<EOL>    options.exclude && options.exclude.forEach(function (filename) {<EOL>        glob.sync(filename).forEach(function (globFileName) {<EOL>            excludesMap[filenameToMid(pathUtil.resolve(baseDir, globFileName))] = true;<EOL>        });<EOL>    });<EOL>    if (options.exclude) {<EOL>        verboseMessage('<STR_LIT>');<EOL>        options.exclude.forEach(name => { verboseMessage('<STR_LIT>' + name); });<EOL>    }<EOL>    mkdirp.sync(pathUtil.dirname(options.out));<EOL>    <EOL>    const output = fs.createWriteStream(options.out, <any>{ mode: parseInt('<STR_LIT>', <NUM_LIT>) });<EOL>    const host = ts.createCompilerHost(compilerOptions);<EOL>    const program = ts.createProgram(filenames, compilerOptions, host);<EOL>    function writeFile(filename: string, data: string, writeByteOrderMark: boolean) {<EOL>        <EOL>        if (filename.slice(-DTSLEN) !== '<STR_LIT>') {<EOL>            return;<EOL>        }<EOL>        writeDeclaration(ts.createSourceFile(filename, data, compilerOptions.target, true), true);<EOL>    }<EOL>    let declaredExternalModules: string[] = [];<EOL>    return new Promise<void>(function (resolve, reject) {<EOL>        output.on('<STR_LIT>', () => { resolve(undefined); });<EOL>        output.on('<STR_LIT>', reject);<EOL>        if (options.externs) {<EOL>            options.externs.forEach(function (path: string) {<EOL>                sendMessage(`<STR_LIT>`);<EOL>                output.write(`<STR_LIT>` + eol);<EOL>            });<EOL>        }<EOL>        if (options.types) {<EOL>            options.types.forEach(function (type: string) {<EOL>                sendMessage(`<STR_LIT>`);<EOL>                output.write(`<STR_LIT>` + eol);<EOL>            });<EOL>        }<EOL>        sendMessage('<STR_LIT>');<EOL>        let mainExportDeclaration = false;<EOL>        let mainExportAssignment = false;<EOL>        let foundMain = false;<EOL>        program.getSourceFiles().forEach(function (sourceFile) {<EOL>            processTree(sourceFile, function (node) {<EOL>                if (isNodeKindModuleDeclaration(node)) {<EOL>                    const name = node.name;<EOL>                    if (isNodeKindStringLiteral(name)) {<EOL>                        declaredExternalModules.push(name.text);<EOL>                    }<EOL>                }<EOL>                return null;<EOL>            });<EOL>        });<EOL>        program.getSourceFiles().some(function (sourceFile) {<EOL>            <EOL>            <EOL>            if (pathUtil.normalize(sourceFile.fileName).indexOf(baseDir) !== <NUM_LIT>) {<EOL>                return;<EOL>            }<EOL>            if (excludesMap[filenameToMid(pathUtil.normalize(sourceFile.fileName))]) {<EOL>                return;<EOL>            }<EOL>            sendMessage(`<STR_LIT>`);<EOL>            <EOL>            if (sourceFile.fileName.slice(-DTSLEN) === '<STR_LIT>') {<EOL>                writeDeclaration(sourceFile, false);<EOL>                return;<EOL>            }<EOL>            <EOL>            if (options.main && options.main === (options.prefix + filenameToMid(sourceFile.fileName.slice(baseDir.length, -<NUM_LIT>)))) {<EOL>                foundMain = true;<EOL>                ts.forEachChild(sourceFile, function (node: ts.Node) {<EOL>                    mainExportDeclaration = mainExportDeclaration || isNodeKindExportDeclaration(node);<EOL>                    mainExportAssignment = mainExportAssignment || isNodeKindExportAssignment(node);<EOL>                });<EOL>            }<EOL>            const emitOutput = program.emit(sourceFile, writeFile);<EOL>            if (emitOutput.emitSkipped || emitOutput.diagnostics.length > <NUM_LIT>) {<EOL>                reject(getError(emitOutput.diagnostics<EOL>                    .concat(program.getSemanticDiagnostics(sourceFile))<EOL>                    .concat(program.getSyntacticDiagnostics(sourceFile))<EOL>                    .concat(program.getDeclarationDiagnostics(sourceFile))));<EOL>                return true;<EOL>            }<EOL>        });<EOL>        if (options.main && !foundMain) {<EOL>            throw new Error(`<STR_LIT>`);<EOL>        }<EOL>        if (options.main) {<EOL>            output.write(`<STR_LIT>` + eol + indent);<EOL>            if (compilerOptions.target >= ts.ScriptTarget.ES2015) {<EOL>                if (mainExportAssignment) {<EOL>                    output.write(`<STR_LIT>` + eol + indent);<EOL>                }<EOL>                if (mainExportDeclaration) {<EOL>                    output.write(`<STR_LIT>` + eol);<EOL>                }<EOL>            }<EOL>            else {<EOL>","gt":"output.write(`<STR_LIT>` + eol + indent);"}
{"input":"<s> export default function generate(options: Options): Promise<void> {<EOL>    if (Boolean(options.main) !== Boolean(options.name)) {<EOL>        if (Boolean(options.name)) {<EOL>            <EOL>            <EOL>            <EOL>            <EOL>            throw new Error(`<STR_LIT>`);<EOL>        }<EOL>        else {<EOL>            throw new Error('<STR_LIT>');<EOL>        }<EOL>    }<EOL>    const noop = function (message?: any, ...optionalParams: any[]): void { };<EOL>    const sendMessage = options.sendMessage || noop;<EOL>    const verboseMessage = options.verbose ? sendMessage : noop;<EOL>    let compilerOptions: ts.CompilerOptions = {};<EOL>    let files: string[] = options.files;<EOL>    <EOL>    if (options.project || !options.files || options.files.length === <NUM_LIT>) {<EOL>        verboseMessage(`<STR_LIT>`);<EOL>        <EOL>        <EOL>        <EOL>        <EOL>        let tsconfigFilename: string;<EOL>        if (Boolean(options.project)) {<EOL>            if (fs.lstatSync(options.project).isDirectory()) {<EOL>                tsconfigFilename = pathUtil.join(options.project, '<STR_LIT>');<EOL>            }<EOL>            else {<EOL>                <EOL>                tsconfigFilename = options.project;<EOL>            }<EOL>        }<EOL>        else {<EOL>            tsconfigFilename = pathUtil.join(options.baseDir, '<STR_LIT>');<EOL>        }<EOL>        if (fs.existsSync(tsconfigFilename)) {<EOL>            verboseMessage(`<STR_LIT>`);<EOL>            [files, compilerOptions] = getTSConfig(options, tsconfigFilename);<EOL>        }<EOL>        else {<EOL>            sendMessage(`<STR_LIT>`);<EOL>            return new Promise<void>(function (resolve, reject) {<EOL>                reject(new SyntaxError('<STR_LIT>'));<EOL>            });<EOL>        }<EOL>    }<EOL>    const eol = options.eol || os.EOL;<EOL>    const nonEmptyLineStart = new RegExp(eol + '<STR_LIT>' + eol + '<STR_LIT>', '<STR_LIT>');<EOL>    const indent = options.indent === undefined ? '<STR_LIT>' : options.indent;<EOL>    <EOL>    <EOL>    compilerOptions.declaration = true;<EOL>    compilerOptions.target = compilerOptions.target || ts.ScriptTarget.Latest; <EOL>    compilerOptions.moduleResolution = compilerOptions.moduleResolution || options.moduleResolution;<EOL>    compilerOptions.outDir = compilerOptions.outDir || options.outDir;<EOL>    <EOL>    const baseDir = pathUtil.resolve(compilerOptions.rootDir || options.project || options.baseDir);<EOL>    const outDir = compilerOptions.outDir;<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    const filenames = getFilenames(baseDir, files);<EOL>    verboseMessage('<STR_LIT>');<EOL>    filenames.forEach(name => { verboseMessage('<STR_LIT>' + name); });<EOL>    const excludesMap: {<EOL>        [filename: string]: boolean;<EOL>    } = {};<EOL>    options.exclude = options.exclude || ['<STR_LIT>'];<EOL>    options.exclude && options.exclude.forEach(function (filename) {<EOL>        glob.sync(filename).forEach(function (globFileName) {<EOL>            excludesMap[filenameToMid(pathUtil.resolve(baseDir, globFileName))] = true;<EOL>        });<EOL>    });<EOL>    if (options.exclude) {<EOL>        verboseMessage('<STR_LIT>');<EOL>        options.exclude.forEach(name => { verboseMessage('<STR_LIT>' + name); });<EOL>    }<EOL>    mkdirp.sync(pathUtil.dirname(options.out));<EOL>    <EOL>    const output = fs.createWriteStream(options.out, <any>{ mode: parseInt('<STR_LIT>', <NUM_LIT>) });<EOL>    const host = ts.createCompilerHost(compilerOptions);<EOL>    const program = ts.createProgram(filenames, compilerOptions, host);<EOL>    function writeFile(filename: string, data: string, writeByteOrderMark: boolean) {<EOL>        <EOL>        if (filename.slice(-DTSLEN) !== '<STR_LIT>') {<EOL>            return;<EOL>        }<EOL>        writeDeclaration(ts.createSourceFile(filename, data, compilerOptions.target, true), true);<EOL>    }<EOL>    let declaredExternalModules: string[] = [];<EOL>    return new Promise<void>(function (resolve, reject) {<EOL>        output.on('<STR_LIT>', () => { resolve(undefined); });<EOL>        output.on('<STR_LIT>', reject);<EOL>        if (options.externs) {<EOL>            options.externs.forEach(function (path: string) {<EOL>                sendMessage(`<STR_LIT>`);<EOL>                output.write(`<STR_LIT>` + eol);<EOL>            });<EOL>        }<EOL>        if (options.types) {<EOL>            options.types.forEach(function (type: string) {<EOL>                sendMessage(`<STR_LIT>`);<EOL>                output.write(`<STR_LIT>` + eol);<EOL>            });<EOL>        }<EOL>        sendMessage('<STR_LIT>');<EOL>        let mainExportDeclaration = false;<EOL>        let mainExportAssignment = false;<EOL>        let foundMain = false;<EOL>        program.getSourceFiles().forEach(function (sourceFile) {<EOL>            processTree(sourceFile, function (node) {<EOL>                if (isNodeKindModuleDeclaration(node)) {<EOL>                    const name = node.name;<EOL>                    if (isNodeKindStringLiteral(name)) {<EOL>                        declaredExternalModules.push(name.text);<EOL>                    }<EOL>                }<EOL>                return null;<EOL>            });<EOL>        });<EOL>        program.getSourceFiles().some(function (sourceFile) {<EOL>            <EOL>            <EOL>            if (pathUtil.normalize(sourceFile.fileName).indexOf(baseDir) !== <NUM_LIT>) {<EOL>                return;<EOL>            }<EOL>            if (excludesMap[filenameToMid(pathUtil.normalize(sourceFile.fileName))]) {<EOL>                return;<EOL>            }<EOL>            sendMessage(`<STR_LIT>`);<EOL>            <EOL>            if (sourceFile.fileName.slice(-DTSLEN) === '<STR_LIT>') {<EOL>                writeDeclaration(sourceFile, false);<EOL>                return;<EOL>            }<EOL>            <EOL>            if (options.main && options.main === (options.prefix + filenameToMid(sourceFile.fileName.slice(baseDir.length, -<NUM_LIT>)))) {<EOL>                foundMain = true;<EOL>                ts.forEachChild(sourceFile, function (node: ts.Node) {<EOL>                    mainExportDeclaration = mainExportDeclaration || isNodeKindExportDeclaration(node);<EOL>                    mainExportAssignment = mainExportAssignment || isNodeKindExportAssignment(node);<EOL>                });<EOL>            }<EOL>            const emitOutput = program.emit(sourceFile, writeFile);<EOL>            if (emitOutput.emitSkipped || emitOutput.diagnostics.length > <NUM_LIT>) {<EOL>                reject(getError(emitOutput.diagnostics<EOL>                    .concat(program.getSemanticDiagnostics(sourceFile))<EOL>                    .concat(program.getSyntacticDiagnostics(sourceFile))<EOL>                    .concat(program.getDeclarationDiagnostics(sourceFile))));<EOL>                return true;<EOL>            }<EOL>        });<EOL>        if (options.main && !foundMain) {<EOL>            throw new Error(`<STR_LIT>`);<EOL>        }<EOL>        if (options.main) {<EOL>            output.write(`<STR_LIT>` + eol + indent);<EOL>            if (compilerOptions.target >= ts.ScriptTarget.ES2015) {<EOL>                if (mainExportAssignment) {<EOL>                    output.write(`<STR_LIT>` + eol + indent);<EOL>                }<EOL>                if (mainExportDeclaration) {<EOL>                    output.write(`<STR_LIT>` + eol);<EOL>                }<EOL>            }<EOL>            else {<EOL>                output.write(`<STR_LIT>` + eol + indent);<EOL>                output.write('<STR_LIT>' + eol);<EOL>            }<EOL>            output.write('<STR_LIT>' + eol);<EOL>            sendMessage(`<STR_LIT>`);<EOL>        }<EOL>        sendMessage(","gt":"out}\"<STR_LIT>;"}
{"input":"<s> export default function generate(options: Options): Promise<void> {<EOL>    if (Boolean(options.main) !== Boolean(options.name)) {<EOL>        if (Boolean(options.name)) {<EOL>            <EOL>            <EOL>            <EOL>            <EOL>            throw new Error(`<STR_LIT>`);<EOL>        }<EOL>        else {<EOL>            throw new Error('<STR_LIT>');<EOL>        }<EOL>    }<EOL>    const noop = function (message?: any, ...optionalParams: any[]): void { };<EOL>    const sendMessage = options.sendMessage || noop;<EOL>    const verboseMessage = options.verbose ? sendMessage : noop;<EOL>    let compilerOptions: ts.CompilerOptions = {};<EOL>    let files: string[] = options.files;<EOL>    <EOL>    if (options.project || !options.files || options.files.length === <NUM_LIT>) {<EOL>        verboseMessage(`<STR_LIT>`);<EOL>        <EOL>        <EOL>        <EOL>        <EOL>        let tsconfigFilename: string;<EOL>        if (Boolean(options.project)) {<EOL>            if (fs.lstatSync(options.project).isDirectory()) {<EOL>                tsconfigFilename = pathUtil.join(options.project, '<STR_LIT>');<EOL>            }<EOL>            else {<EOL>                <EOL>                tsconfigFilename = options.project;<EOL>            }<EOL>        }<EOL>        else {<EOL>            tsconfigFilename = pathUtil.join(options.baseDir, '<STR_LIT>');<EOL>        }<EOL>        if (fs.existsSync(tsconfigFilename)) {<EOL>            verboseMessage(`<STR_LIT>`);<EOL>            [files, compilerOptions] = getTSConfig(options, tsconfigFilename);<EOL>        }<EOL>        else {<EOL>            sendMessage(`<STR_LIT>`);<EOL>            return new Promise<void>(function (resolve, reject) {<EOL>                reject(new SyntaxError('<STR_LIT>'));<EOL>            });<EOL>        }<EOL>    }<EOL>    const eol = options.eol || os.EOL;<EOL>    const nonEmptyLineStart = new RegExp(eol + '<STR_LIT>' + eol + '<STR_LIT>', '<STR_LIT>');<EOL>    const indent = options.indent === undefined ? '<STR_LIT>' : options.indent;<EOL>    <EOL>    <EOL>    compilerOptions.declaration = true;<EOL>    compilerOptions.target = compilerOptions.target || ts.ScriptTarget.Latest; <EOL>    compilerOptions.moduleResolution = compilerOptions.moduleResolution || options.moduleResolution;<EOL>    compilerOptions.outDir = compilerOptions.outDir || options.outDir;<EOL>    <EOL>    const baseDir = pathUtil.resolve(compilerOptions.rootDir || options.project || options.baseDir);<EOL>    const outDir = compilerOptions.outDir;<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    const filenames = getFilenames(baseDir, files);<EOL>    verboseMessage('<STR_LIT>');<EOL>    filenames.forEach(name => { verboseMessage('<STR_LIT>' + name); });<EOL>    const excludesMap: {<EOL>        [filename: string]: boolean;<EOL>    } = {};<EOL>    options.exclude = options.exclude || ['<STR_LIT>'];<EOL>    options.exclude && options.exclude.forEach(function (filename) {<EOL>        glob.sync(filename).forEach(function (globFileName) {<EOL>            excludesMap[filenameToMid(pathUtil.resolve(baseDir, globFileName))] = true;<EOL>        });<EOL>    });<EOL>    if (options.exclude) {<EOL>        verboseMessage('<STR_LIT>');<EOL>        options.exclude.forEach(name => { verboseMessage('<STR_LIT>' + name); });<EOL>    }<EOL>    mkdirp.sync(pathUtil.dirname(options.out));<EOL>    <EOL>    const output = fs.createWriteStream(options.out, <any>{ mode: parseInt('<STR_LIT>', <NUM_LIT>) });<EOL>    const host = ts.createCompilerHost(compilerOptions);<EOL>    const program = ts.createProgram(filenames, compilerOptions, host);<EOL>    function writeFile(filename: string, data: string, writeByteOrderMark: boolean) {<EOL>        <EOL>        if (filename.slice(-DTSLEN) !== '<STR_LIT>') {<EOL>            return;<EOL>        }<EOL>        writeDeclaration(ts.createSourceFile(filename, data, compilerOptions.target, true), true);<EOL>    }<EOL>    let declaredExternalModules: string[] = [];<EOL>    return new Promise<void>(function (resolve, reject) {<EOL>        output.on('<STR_LIT>', () => { resolve(undefined); });<EOL>        output.on('<STR_LIT>', reject);<EOL>        if (options.externs) {<EOL>            options.externs.forEach(function (path: string) {<EOL>                sendMessage(`<STR_LIT>`);<EOL>                output.write(`<STR_LIT>` + eol);<EOL>            });<EOL>        }<EOL>        if (options.types) {<EOL>            options.types.forEach(function (type: string) {<EOL>                sendMessage(`<STR_LIT>`);<EOL>                output.write(`<STR_LIT>` + eol);<EOL>            });<EOL>        }<EOL>        sendMessage('<STR_LIT>');<EOL>        let mainExportDeclaration = false;<EOL>        let mainExportAssignment = false;<EOL>        let foundMain = false;<EOL>        program.getSourceFiles().forEach(function (sourceFile) {<EOL>            processTree(sourceFile, function (node) {<EOL>                if (isNodeKindModuleDeclaration(node)) {<EOL>                    const name = node.name;<EOL>                    if (isNodeKindStringLiteral(name)) {<EOL>                        declaredExternalModules.push(name.text);<EOL>                    }<EOL>                }<EOL>                return null;<EOL>            });<EOL>        });<EOL>        program.getSourceFiles().some(function (sourceFile) {<EOL>            <EOL>            <EOL>            if (pathUtil.normalize(sourceFile.fileName).indexOf(baseDir) !== <NUM_LIT>) {<EOL>                return;<EOL>            }<EOL>            if (excludesMap[filenameToMid(pathUtil.normalize(sourceFile.fileName))]) {<EOL>                return;<EOL>            }<EOL>            sendMessage(`<STR_LIT>`);<EOL>            <EOL>            if (sourceFile.fileName.slice(-DTSLEN) === '<STR_LIT>') {<EOL>                writeDeclaration(sourceFile, false);<EOL>                return;<EOL>            }<EOL>            <EOL>            if (options.main && options.main === (options.prefix + filenameToMid(sourceFile.fileName.slice(baseDir.length, -<NUM_LIT>)))) {<EOL>                foundMain = true;<EOL>                ts.forEachChild(sourceFile, function (node: ts.Node) {<EOL>                    mainExportDeclaration = mainExportDeclaration || isNodeKindExportDeclaration(node);<EOL>                    mainExportAssignment = mainExportAssignment || isNodeKindExportAssignment(node);<EOL>                });<EOL>            }<EOL>            const emitOutput = program.emit(sourceFile, writeFile);<EOL>            if (emitOutput.emitSkipped || emitOutput.diagnostics.length > <NUM_LIT>) {<EOL>                reject(getError(emitOutput.diagnostics<EOL>                    .concat(program.getSemanticDiagnostics(sourceFile))<EOL>                    .concat(program.getSyntacticDiagnostics(sourceFile))<EOL>                    .concat(program.getDeclarationDiagnostics(sourceFile))));<EOL>                return true;<EOL>            }<EOL>        });<EOL>        if (options.main && !foundMain) {<EOL>            throw new Error(`<STR_LIT>`);<EOL>        }<EOL>        if (options.main) {<EOL>            output.write(`<STR_LIT>` + eol + indent);<EOL>            if (compilerOptions.target >= ts.ScriptTarget.ES2015) {<EOL>                if (mainExportAssignment) {<EOL>                    output.write(`<STR_LIT>` + eol + indent);<EOL>                }<EOL>                if (mainExportDeclaration) {<EOL>                    output.write(`<STR_LIT>` + eol);<EOL>                }<EOL>            }<EOL>            else {<EOL>                output.write(`<STR_LIT>` + eol + indent);<EOL>                output.write('<STR_LIT>' + eol);<EOL>            }<EOL>            output.write('<STR_LIT>' + eol);<EOL>            sendMessage(`<STR_LIT>`);<EOL>        }<EOL>        sendMessage(`<STR_LIT>`);<EOL>        output.","gt":"end();"}
{"input":"<s> export default function generate(options: Options): Promise<void> {<EOL>    if (Boolean(options.main) !== Boolean(options.name)) {<EOL>        if (Boolean(options.name)) {<EOL>            <EOL>            <EOL>            <EOL>            <EOL>            throw new Error(`<STR_LIT>`);<EOL>        }<EOL>        else {<EOL>            throw new Error('<STR_LIT>');<EOL>        }<EOL>    }<EOL>    const noop = function (message?: any, ...optionalParams: any[]): void { };<EOL>    const sendMessage = options.sendMessage || noop;<EOL>    const verboseMessage = options.verbose ? sendMessage : noop;<EOL>    let compilerOptions: ts.CompilerOptions = {};<EOL>    let files: string[] = options.files;<EOL>    <EOL>    if (options.project || !options.files || options.files.length === <NUM_LIT>) {<EOL>        verboseMessage(`<STR_LIT>`);<EOL>        <EOL>        <EOL>        <EOL>        <EOL>        let tsconfigFilename: string;<EOL>        if (Boolean(options.project)) {<EOL>            if (fs.lstatSync(options.project).isDirectory()) {<EOL>                tsconfigFilename = pathUtil.join(options.project, '<STR_LIT>');<EOL>            }<EOL>            else {<EOL>                <EOL>                tsconfigFilename = options.project;<EOL>            }<EOL>        }<EOL>        else {<EOL>            tsconfigFilename = pathUtil.join(options.baseDir, '<STR_LIT>');<EOL>        }<EOL>        if (fs.existsSync(tsconfigFilename)) {<EOL>            verboseMessage(`<STR_LIT>`);<EOL>            [files, compilerOptions] = getTSConfig(options, tsconfigFilename);<EOL>        }<EOL>        else {<EOL>            sendMessage(`<STR_LIT>`);<EOL>            return new Promise<void>(function (resolve, reject) {<EOL>                reject(new SyntaxError('<STR_LIT>'));<EOL>            });<EOL>        }<EOL>    }<EOL>    const eol = options.eol || os.EOL;<EOL>    const nonEmptyLineStart = new RegExp(eol + '<STR_LIT>' + eol + '<STR_LIT>', '<STR_LIT>');<EOL>    const indent = options.indent === undefined ? '<STR_LIT>' : options.indent;<EOL>    <EOL>    <EOL>    compilerOptions.declaration = true;<EOL>    compilerOptions.target = compilerOptions.target || ts.ScriptTarget.Latest; <EOL>    compilerOptions.moduleResolution = compilerOptions.moduleResolution || options.moduleResolution;<EOL>    compilerOptions.outDir = compilerOptions.outDir || options.outDir;<EOL>    <EOL>    const baseDir = pathUtil.resolve(compilerOptions.rootDir || options.project || options.baseDir);<EOL>    const outDir = compilerOptions.outDir;<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    const filenames = getFilenames(baseDir, files);<EOL>    verboseMessage('<STR_LIT>');<EOL>    filenames.forEach(name => { verboseMessage('<STR_LIT>' + name); });<EOL>    const excludesMap: {<EOL>        [filename: string]: boolean;<EOL>    } = {};<EOL>    options.exclude = options.exclude || ['<STR_LIT>'];<EOL>    options.exclude && options.exclude.forEach(function (filename) {<EOL>        glob.sync(filename).forEach(function (globFileName) {<EOL>            excludesMap[filenameToMid(pathUtil.resolve(baseDir, globFileName))] = true;<EOL>        });<EOL>    });<EOL>    if (options.exclude) {<EOL>        verboseMessage('<STR_LIT>');<EOL>        options.exclude.forEach(name => { verboseMessage('<STR_LIT>' + name); });<EOL>    }<EOL>    mkdirp.sync(pathUtil.dirname(options.out));<EOL>    <EOL>    const output = fs.createWriteStream(options.out, <any>{ mode: parseInt('<STR_LIT>', <NUM_LIT>) });<EOL>    const host = ts.createCompilerHost(compilerOptions);<EOL>    const program = ts.createProgram(filenames, compilerOptions, host);<EOL>    function writeFile(filename: string, data: string, writeByteOrderMark: boolean) {<EOL>        <EOL>        if (filename.slice(-DTSLEN) !== '<STR_LIT>') {<EOL>            return;<EOL>        }<EOL>        writeDeclaration(ts.createSourceFile(filename, data, compilerOptions.target, true), true);<EOL>    }<EOL>    let declaredExternalModules: string[] = [];<EOL>    return new Promise<void>(function (resolve, reject) {<EOL>        output.on('<STR_LIT>', () => { resolve(undefined); });<EOL>        output.on('<STR_LIT>', reject);<EOL>        if (options.externs) {<EOL>            options.externs.forEach(function (path: string) {<EOL>                sendMessage(`<STR_LIT>`);<EOL>                output.write(`<STR_LIT>` + eol);<EOL>            });<EOL>        }<EOL>        if (options.types) {<EOL>            options.types.forEach(function (type: string) {<EOL>                sendMessage(`<STR_LIT>`);<EOL>                output.write(`<STR_LIT>` + eol);<EOL>            });<EOL>        }<EOL>        sendMessage('<STR_LIT>');<EOL>        let mainExportDeclaration = false;<EOL>        let mainExportAssignment = false;<EOL>        let foundMain = false;<EOL>        program.getSourceFiles().forEach(function (sourceFile) {<EOL>            processTree(sourceFile, function (node) {<EOL>                if (isNodeKindModuleDeclaration(node)) {<EOL>                    const name = node.name;<EOL>                    if (isNodeKindStringLiteral(name)) {<EOL>                        declaredExternalModules.push(name.text);<EOL>                    }<EOL>                }<EOL>                return null;<EOL>            });<EOL>        });<EOL>        program.getSourceFiles().some(function (sourceFile) {<EOL>            <EOL>            <EOL>            if (pathUtil.normalize(sourceFile.fileName).indexOf(baseDir) !== <NUM_LIT>) {<EOL>                return;<EOL>            }<EOL>            if (excludesMap[filenameToMid(pathUtil.normalize(sourceFile.fileName))]) {<EOL>                return;<EOL>            }<EOL>            sendMessage(`<STR_LIT>`);<EOL>            <EOL>            if (sourceFile.fileName.slice(-DTSLEN) === '<STR_LIT>') {<EOL>                writeDeclaration(sourceFile, false);<EOL>                return;<EOL>            }<EOL>            <EOL>            if (options.main && options.main === (options.prefix + filenameToMid(sourceFile.fileName.slice(baseDir.length, -<NUM_LIT>)))) {<EOL>                foundMain = true;<EOL>                ts.forEachChild(sourceFile, function (node: ts.Node) {<EOL>                    mainExportDeclaration = mainExportDeclaration || isNodeKindExportDeclaration(node);<EOL>                    mainExportAssignment = mainExportAssignment || isNodeKindExportAssignment(node);<EOL>                });<EOL>            }<EOL>            const emitOutput = program.emit(sourceFile, writeFile);<EOL>            if (emitOutput.emitSkipped || emitOutput.diagnostics.length > <NUM_LIT>) {<EOL>                reject(getError(emitOutput.diagnostics<EOL>                    .concat(program.getSemanticDiagnostics(sourceFile))<EOL>                    .concat(program.getSyntacticDiagnostics(sourceFile))<EOL>                    .concat(program.getDeclarationDiagnostics(sourceFile))));<EOL>                return true;<EOL>            }<EOL>        });<EOL>        if (options.main && !foundMain) {<EOL>            throw new Error(`<STR_LIT>`);<EOL>        }<EOL>        if (options.main) {<EOL>            output.write(`<STR_LIT>` + eol + indent);<EOL>            if (compilerOptions.target >= ts.ScriptTarget.ES2015) {<EOL>                if (mainExportAssignment) {<EOL>                    output.write(`<STR_LIT>` + eol + indent);<EOL>                }<EOL>                if (mainExportDeclaration) {<EOL>                    output.write(`<STR_LIT>` + eol);<EOL>                }<EOL>            }<EOL>            else {<EOL>                output.write(`<STR_LIT>` + eol + indent);<EOL>                output.write('<STR_LIT>' + eol);<EOL>            }<EOL>            output.write('<STR_LIT>' + eol);<EOL>            sendMessage(`<STR_LIT>`);<EOL>        }<EOL>        sendMessage(`<STR_LIT>`);<EOL>        output.end();<EOL>    });<EOL>    function writeDeclaration(declarationFile: ts.SourceFile, isOutput: boolean) {<EOL>        <EOL>        const filename = pathUtil.resolve(declarationFile.fileName);<EOL>        <EOL>        <EOL>        <EOL>        <EOL>        <EOL>        const outputDir = (isOutput && Boolean(outDir)) ? pathUtil.resolve(outDir) : baseDir;<EOL>        const sourceModuleId = filenameToMid(filename.slice(outputDir.length + <NUM_LIT>, -DTSLEN));<EOL>        const currentModuleId = filenameToMid(filename.slice(outputDir.length + <NUM_LIT>, -DTSLEN));<EOL>        function resolveModuleImport(moduleId: string): string {<EOL>            const isDeclaredExternalModule: boolean = declaredExternalModules.indexOf(moduleId) !== -<NUM_LIT>;<EOL>            let resolved: string;<EOL>            if (options.resolveModuleImport) {<EOL>                resolved = options.resolveModuleImport({<EOL>                    importedModuleId: moduleId,<EOL>                    currentModuleId: currentModuleId,<EOL>","gt":"isDeclaredExternalModule: isDeclaredExternalModule"}
{"input":"<s> export default function generate(options: Options): Promise<void> {<EOL>    if (Boolean(options.main) !== Boolean(options.name)) {<EOL>        if (Boolean(options.name)) {<EOL>            <EOL>            <EOL>            <EOL>            <EOL>            throw new Error(`<STR_LIT>`);<EOL>        }<EOL>        else {<EOL>            throw new Error('<STR_LIT>');<EOL>        }<EOL>    }<EOL>    const noop = function (message?: any, ...optionalParams: any[]): void { };<EOL>    const sendMessage = options.sendMessage || noop;<EOL>    const verboseMessage = options.verbose ? sendMessage : noop;<EOL>    let compilerOptions: ts.CompilerOptions = {};<EOL>    let files: string[] = options.files;<EOL>    <EOL>    if (options.project || !options.files || options.files.length === <NUM_LIT>) {<EOL>        verboseMessage(`<STR_LIT>`);<EOL>        <EOL>        <EOL>        <EOL>        <EOL>        let tsconfigFilename: string;<EOL>        if (Boolean(options.project)) {<EOL>            if (fs.lstatSync(options.project).isDirectory()) {<EOL>                tsconfigFilename = pathUtil.join(options.project, '<STR_LIT>');<EOL>            }<EOL>            else {<EOL>                <EOL>                tsconfigFilename = options.project;<EOL>            }<EOL>        }<EOL>        else {<EOL>            tsconfigFilename = pathUtil.join(options.baseDir, '<STR_LIT>');<EOL>        }<EOL>        if (fs.existsSync(tsconfigFilename)) {<EOL>            verboseMessage(`<STR_LIT>`);<EOL>            [files, compilerOptions] = getTSConfig(options, tsconfigFilename);<EOL>        }<EOL>        else {<EOL>            sendMessage(`<STR_LIT>`);<EOL>            return new Promise<void>(function (resolve, reject) {<EOL>                reject(new SyntaxError('<STR_LIT>'));<EOL>            });<EOL>        }<EOL>    }<EOL>    const eol = options.eol || os.EOL;<EOL>    const nonEmptyLineStart = new RegExp(eol + '<STR_LIT>' + eol + '<STR_LIT>', '<STR_LIT>');<EOL>    const indent = options.indent === undefined ? '<STR_LIT>' : options.indent;<EOL>    <EOL>    <EOL>    compilerOptions.declaration = true;<EOL>    compilerOptions.target = compilerOptions.target || ts.ScriptTarget.Latest; <EOL>    compilerOptions.moduleResolution = compilerOptions.moduleResolution || options.moduleResolution;<EOL>    compilerOptions.outDir = compilerOptions.outDir || options.outDir;<EOL>    <EOL>    const baseDir = pathUtil.resolve(compilerOptions.rootDir || options.project || options.baseDir);<EOL>    const outDir = compilerOptions.outDir;<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    const filenames = getFilenames(baseDir, files);<EOL>    verboseMessage('<STR_LIT>');<EOL>    filenames.forEach(name => { verboseMessage('<STR_LIT>' + name); });<EOL>    const excludesMap: {<EOL>        [filename: string]: boolean;<EOL>    } = {};<EOL>    options.exclude = options.exclude || ['<STR_LIT>'];<EOL>    options.exclude && options.exclude.forEach(function (filename) {<EOL>        glob.sync(filename).forEach(function (globFileName) {<EOL>            excludesMap[filenameToMid(pathUtil.resolve(baseDir, globFileName))] = true;<EOL>        });<EOL>    });<EOL>    if (options.exclude) {<EOL>        verboseMessage('<STR_LIT>');<EOL>        options.exclude.forEach(name => { verboseMessage('<STR_LIT>' + name); });<EOL>    }<EOL>    mkdirp.sync(pathUtil.dirname(options.out));<EOL>    <EOL>    const output = fs.createWriteStream(options.out, <any>{ mode: parseInt('<STR_LIT>', <NUM_LIT>) });<EOL>    const host = ts.createCompilerHost(compilerOptions);<EOL>    const program = ts.createProgram(filenames, compilerOptions, host);<EOL>    function writeFile(filename: string, data: string, writeByteOrderMark: boolean) {<EOL>        <EOL>        if (filename.slice(-DTSLEN) !== '<STR_LIT>') {<EOL>            return;<EOL>        }<EOL>        writeDeclaration(ts.createSourceFile(filename, data, compilerOptions.target, true), true);<EOL>    }<EOL>    let declaredExternalModules: string[] = [];<EOL>    return new Promise<void>(function (resolve, reject) {<EOL>        output.on('<STR_LIT>', () => { resolve(undefined); });<EOL>        output.on('<STR_LIT>', reject);<EOL>        if (options.externs) {<EOL>            options.externs.forEach(function (path: string) {<EOL>                sendMessage(`<STR_LIT>`);<EOL>                output.write(`<STR_LIT>` + eol);<EOL>            });<EOL>        }<EOL>        if (options.types) {<EOL>            options.types.forEach(function (type: string) {<EOL>                sendMessage(`<STR_LIT>`);<EOL>                output.write(`<STR_LIT>` + eol);<EOL>            });<EOL>        }<EOL>        sendMessage('<STR_LIT>');<EOL>        let mainExportDeclaration = false;<EOL>        let mainExportAssignment = false;<EOL>        let foundMain = false;<EOL>        program.getSourceFiles().forEach(function (sourceFile) {<EOL>            processTree(sourceFile, function (node) {<EOL>                if (isNodeKindModuleDeclaration(node)) {<EOL>                    const name = node.name;<EOL>                    if (isNodeKindStringLiteral(name)) {<EOL>                        declaredExternalModules.push(name.text);<EOL>                    }<EOL>                }<EOL>                return null;<EOL>            });<EOL>        });<EOL>        program.getSourceFiles().some(function (sourceFile) {<EOL>            <EOL>            <EOL>            if (pathUtil.normalize(sourceFile.fileName).indexOf(baseDir) !== <NUM_LIT>) {<EOL>                return;<EOL>            }<EOL>            if (excludesMap[filenameToMid(pathUtil.normalize(sourceFile.fileName))]) {<EOL>                return;<EOL>            }<EOL>            sendMessage(`<STR_LIT>`);<EOL>            <EOL>            if (sourceFile.fileName.slice(-DTSLEN) === '<STR_LIT>') {<EOL>                writeDeclaration(sourceFile, false);<EOL>                return;<EOL>            }<EOL>            <EOL>            if (options.main && options.main === (options.prefix + filenameToMid(sourceFile.fileName.slice(baseDir.length, -<NUM_LIT>)))) {<EOL>                foundMain = true;<EOL>                ts.forEachChild(sourceFile, function (node: ts.Node) {<EOL>                    mainExportDeclaration = mainExportDeclaration || isNodeKindExportDeclaration(node);<EOL>                    mainExportAssignment = mainExportAssignment || isNodeKindExportAssignment(node);<EOL>                });<EOL>            }<EOL>            const emitOutput = program.emit(sourceFile, writeFile);<EOL>            if (emitOutput.emitSkipped || emitOutput.diagnostics.length > <NUM_LIT>) {<EOL>                reject(getError(emitOutput.diagnostics<EOL>                    .concat(program.getSemanticDiagnostics(sourceFile))<EOL>                    .concat(program.getSyntacticDiagnostics(sourceFile))<EOL>                    .concat(program.getDeclarationDiagnostics(sourceFile))));<EOL>                return true;<EOL>            }<EOL>        });<EOL>        if (options.main && !foundMain) {<EOL>            throw new Error(`<STR_LIT>`);<EOL>        }<EOL>        if (options.main) {<EOL>            output.write(`<STR_LIT>` + eol + indent);<EOL>            if (compilerOptions.target >= ts.ScriptTarget.ES2015) {<EOL>                if (mainExportAssignment) {<EOL>                    output.write(`<STR_LIT>` + eol + indent);<EOL>                }<EOL>                if (mainExportDeclaration) {<EOL>                    output.write(`<STR_LIT>` + eol);<EOL>                }<EOL>            }<EOL>            else {<EOL>                output.write(`<STR_LIT>` + eol + indent);<EOL>                output.write('<STR_LIT>' + eol);<EOL>            }<EOL>            output.write('<STR_LIT>' + eol);<EOL>            sendMessage(`<STR_LIT>`);<EOL>        }<EOL>        sendMessage(`<STR_LIT>`);<EOL>        output.end();<EOL>    });<EOL>    function writeDeclaration(declarationFile: ts.SourceFile, isOutput: boolean) {<EOL>        <EOL>        const filename = pathUtil.resolve(declarationFile.fileName);<EOL>        <EOL>        <EOL>        <EOL>        <EOL>        <EOL>        const outputDir = (isOutput && Boolean(outDir)) ? pathUtil.resolve(outDir) : baseDir;<EOL>        const sourceModuleId = filenameToMid(filename.slice(outputDir.length + <NUM_LIT>, -DTSLEN));<EOL>        const currentModuleId = filenameToMid(filename.slice(outputDir.length + <NUM_LIT>, -DTSLEN));<EOL>        function resolveModuleImport(moduleId: string): string {<EOL>            const isDeclaredExternalModule: boolean = declaredExternalModules.indexOf(moduleId) !== -<NUM_LIT>;<EOL>            let resolved: string;<EOL>            if (options.resolveModuleImport) {<EOL>                resolved = options.resolveModuleImport({<EOL>                    importedModuleId: moduleId,<EOL>                    currentModuleId: currentModuleId,<EOL>                    isDeclaredExternalModule: isDeclaredExternalModule<EOL>                });<EOL>            }<EOL>","gt":"if (!resolved) {"}
{"input":"<s> export default function generate(options: Options): Promise<void> {<EOL>    if (Boolean(options.main) !== Boolean(options.name)) {<EOL>        if (Boolean(options.name)) {<EOL>            <EOL>            <EOL>            <EOL>            <EOL>            throw new Error(`<STR_LIT>`);<EOL>        }<EOL>        else {<EOL>            throw new Error('<STR_LIT>');<EOL>        }<EOL>    }<EOL>    const noop = function (message?: any, ...optionalParams: any[]): void { };<EOL>    const sendMessage = options.sendMessage || noop;<EOL>    const verboseMessage = options.verbose ? sendMessage : noop;<EOL>    let compilerOptions: ts.CompilerOptions = {};<EOL>    let files: string[] = options.files;<EOL>    <EOL>    if (options.project || !options.files || options.files.length === <NUM_LIT>) {<EOL>        verboseMessage(`<STR_LIT>`);<EOL>        <EOL>        <EOL>        <EOL>        <EOL>        let tsconfigFilename: string;<EOL>        if (Boolean(options.project)) {<EOL>            if (fs.lstatSync(options.project).isDirectory()) {<EOL>                tsconfigFilename = pathUtil.join(options.project, '<STR_LIT>');<EOL>            }<EOL>            else {<EOL>                <EOL>                tsconfigFilename = options.project;<EOL>            }<EOL>        }<EOL>        else {<EOL>            tsconfigFilename = pathUtil.join(options.baseDir, '<STR_LIT>');<EOL>        }<EOL>        if (fs.existsSync(tsconfigFilename)) {<EOL>            verboseMessage(`<STR_LIT>`);<EOL>            [files, compilerOptions] = getTSConfig(options, tsconfigFilename);<EOL>        }<EOL>        else {<EOL>            sendMessage(`<STR_LIT>`);<EOL>            return new Promise<void>(function (resolve, reject) {<EOL>                reject(new SyntaxError('<STR_LIT>'));<EOL>            });<EOL>        }<EOL>    }<EOL>    const eol = options.eol || os.EOL;<EOL>    const nonEmptyLineStart = new RegExp(eol + '<STR_LIT>' + eol + '<STR_LIT>', '<STR_LIT>');<EOL>    const indent = options.indent === undefined ? '<STR_LIT>' : options.indent;<EOL>    <EOL>    <EOL>    compilerOptions.declaration = true;<EOL>    compilerOptions.target = compilerOptions.target || ts.ScriptTarget.Latest; <EOL>    compilerOptions.moduleResolution = compilerOptions.moduleResolution || options.moduleResolution;<EOL>    compilerOptions.outDir = compilerOptions.outDir || options.outDir;<EOL>    <EOL>    const baseDir = pathUtil.resolve(compilerOptions.rootDir || options.project || options.baseDir);<EOL>    const outDir = compilerOptions.outDir;<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    const filenames = getFilenames(baseDir, files);<EOL>    verboseMessage('<STR_LIT>');<EOL>    filenames.forEach(name => { verboseMessage('<STR_LIT>' + name); });<EOL>    const excludesMap: {<EOL>        [filename: string]: boolean;<EOL>    } = {};<EOL>    options.exclude = options.exclude || ['<STR_LIT>'];<EOL>    options.exclude && options.exclude.forEach(function (filename) {<EOL>        glob.sync(filename).forEach(function (globFileName) {<EOL>            excludesMap[filenameToMid(pathUtil.resolve(baseDir, globFileName))] = true;<EOL>        });<EOL>    });<EOL>    if (options.exclude) {<EOL>        verboseMessage('<STR_LIT>');<EOL>        options.exclude.forEach(name => { verboseMessage('<STR_LIT>' + name); });<EOL>    }<EOL>    mkdirp.sync(pathUtil.dirname(options.out));<EOL>    <EOL>    const output = fs.createWriteStream(options.out, <any>{ mode: parseInt('<STR_LIT>', <NUM_LIT>) });<EOL>    const host = ts.createCompilerHost(compilerOptions);<EOL>    const program = ts.createProgram(filenames, compilerOptions, host);<EOL>    function writeFile(filename: string, data: string, writeByteOrderMark: boolean) {<EOL>        <EOL>        if (filename.slice(-DTSLEN) !== '<STR_LIT>') {<EOL>            return;<EOL>        }<EOL>        writeDeclaration(ts.createSourceFile(filename, data, compilerOptions.target, true), true);<EOL>    }<EOL>    let declaredExternalModules: string[] = [];<EOL>    return new Promise<void>(function (resolve, reject) {<EOL>        output.on('<STR_LIT>', () => { resolve(undefined); });<EOL>        output.on('<STR_LIT>', reject);<EOL>        if (options.externs) {<EOL>            options.externs.forEach(function (path: string) {<EOL>                sendMessage(`<STR_LIT>`);<EOL>                output.write(`<STR_LIT>` + eol);<EOL>            });<EOL>        }<EOL>        if (options.types) {<EOL>            options.types.forEach(function (type: string) {<EOL>                sendMessage(`<STR_LIT>`);<EOL>                output.write(`<STR_LIT>` + eol);<EOL>            });<EOL>        }<EOL>        sendMessage('<STR_LIT>');<EOL>        let mainExportDeclaration = false;<EOL>        let mainExportAssignment = false;<EOL>        let foundMain = false;<EOL>        program.getSourceFiles().forEach(function (sourceFile) {<EOL>            processTree(sourceFile, function (node) {<EOL>                if (isNodeKindModuleDeclaration(node)) {<EOL>                    const name = node.name;<EOL>                    if (isNodeKindStringLiteral(name)) {<EOL>                        declaredExternalModules.push(name.text);<EOL>                    }<EOL>                }<EOL>                return null;<EOL>            });<EOL>        });<EOL>        program.getSourceFiles().some(function (sourceFile) {<EOL>            <EOL>            <EOL>            if (pathUtil.normalize(sourceFile.fileName).indexOf(baseDir) !== <NUM_LIT>) {<EOL>                return;<EOL>            }<EOL>            if (excludesMap[filenameToMid(pathUtil.normalize(sourceFile.fileName))]) {<EOL>                return;<EOL>            }<EOL>            sendMessage(`<STR_LIT>`);<EOL>            <EOL>            if (sourceFile.fileName.slice(-DTSLEN) === '<STR_LIT>') {<EOL>                writeDeclaration(sourceFile, false);<EOL>                return;<EOL>            }<EOL>            <EOL>            if (options.main && options.main === (options.prefix + filenameToMid(sourceFile.fileName.slice(baseDir.length, -<NUM_LIT>)))) {<EOL>                foundMain = true;<EOL>                ts.forEachChild(sourceFile, function (node: ts.Node) {<EOL>                    mainExportDeclaration = mainExportDeclaration || isNodeKindExportDeclaration(node);<EOL>                    mainExportAssignment = mainExportAssignment || isNodeKindExportAssignment(node);<EOL>                });<EOL>            }<EOL>            const emitOutput = program.emit(sourceFile, writeFile);<EOL>            if (emitOutput.emitSkipped || emitOutput.diagnostics.length > <NUM_LIT>) {<EOL>                reject(getError(emitOutput.diagnostics<EOL>                    .concat(program.getSemanticDiagnostics(sourceFile))<EOL>                    .concat(program.getSyntacticDiagnostics(sourceFile))<EOL>                    .concat(program.getDeclarationDiagnostics(sourceFile))));<EOL>                return true;<EOL>            }<EOL>        });<EOL>        if (options.main && !foundMain) {<EOL>            throw new Error(`<STR_LIT>`);<EOL>        }<EOL>        if (options.main) {<EOL>            output.write(`<STR_LIT>` + eol + indent);<EOL>            if (compilerOptions.target >= ts.ScriptTarget.ES2015) {<EOL>                if (mainExportAssignment) {<EOL>                    output.write(`<STR_LIT>` + eol + indent);<EOL>                }<EOL>                if (mainExportDeclaration) {<EOL>                    output.write(`<STR_LIT>` + eol);<EOL>                }<EOL>            }<EOL>            else {<EOL>                output.write(`<STR_LIT>` + eol + indent);<EOL>                output.write('<STR_LIT>' + eol);<EOL>            }<EOL>            output.write('<STR_LIT>' + eol);<EOL>            sendMessage(`<STR_LIT>`);<EOL>        }<EOL>        sendMessage(`<STR_LIT>`);<EOL>        output.end();<EOL>    });<EOL>    function writeDeclaration(declarationFile: ts.SourceFile, isOutput: boolean) {<EOL>        <EOL>        const filename = pathUtil.resolve(declarationFile.fileName);<EOL>        <EOL>        <EOL>        <EOL>        <EOL>        <EOL>        const outputDir = (isOutput && Boolean(outDir)) ? pathUtil.resolve(outDir) : baseDir;<EOL>        const sourceModuleId = filenameToMid(filename.slice(outputDir.length + <NUM_LIT>, -DTSLEN));<EOL>        const currentModuleId = filenameToMid(filename.slice(outputDir.length + <NUM_LIT>, -DTSLEN));<EOL>        function resolveModuleImport(moduleId: string): string {<EOL>            const isDeclaredExternalModule: boolean = declaredExternalModules.indexOf(moduleId) !== -<NUM_LIT>;<EOL>            let resolved: string;<EOL>            if (options.resolveModuleImport) {<EOL>                resolved = options.resolveModuleImport({<EOL>                    importedModuleId: moduleId,<EOL>                    currentModuleId: currentModuleId,<EOL>                    isDeclaredExternalModule: isDeclaredExternalModule<EOL>                });<EOL>            }<EOL>            if (!resolved) {<EOL>                <EOL>                if (moduleId.charAt(<NUM_LIT>) === '<STR_LIT>') {<EOL>                    resolved = filenameToMid(pathUtil.join(","gt":"pathUtil.dirname(sourceModuleId), moduleId));"}
{"input":"<s> export default function generate(options: Options): Promise<void> {<EOL>    if (Boolean(options.main) !== Boolean(options.name)) {<EOL>        if (Boolean(options.name)) {<EOL>            <EOL>            <EOL>            <EOL>            <EOL>            throw new Error(`<STR_LIT>`);<EOL>        }<EOL>        else {<EOL>            throw new Error('<STR_LIT>');<EOL>        }<EOL>    }<EOL>    const noop = function (message?: any, ...optionalParams: any[]): void { };<EOL>    const sendMessage = options.sendMessage || noop;<EOL>    const verboseMessage = options.verbose ? sendMessage : noop;<EOL>    let compilerOptions: ts.CompilerOptions = {};<EOL>    let files: string[] = options.files;<EOL>    <EOL>    if (options.project || !options.files || options.files.length === <NUM_LIT>) {<EOL>        verboseMessage(`<STR_LIT>`);<EOL>        <EOL>        <EOL>        <EOL>        <EOL>        let tsconfigFilename: string;<EOL>        if (Boolean(options.project)) {<EOL>            if (fs.lstatSync(options.project).isDirectory()) {<EOL>                tsconfigFilename = pathUtil.join(options.project, '<STR_LIT>');<EOL>            }<EOL>            else {<EOL>                <EOL>                tsconfigFilename = options.project;<EOL>            }<EOL>        }<EOL>        else {<EOL>            tsconfigFilename = pathUtil.join(options.baseDir, '<STR_LIT>');<EOL>        }<EOL>        if (fs.existsSync(tsconfigFilename)) {<EOL>            verboseMessage(`<STR_LIT>`);<EOL>            [files, compilerOptions] = getTSConfig(options, tsconfigFilename);<EOL>        }<EOL>        else {<EOL>            sendMessage(`<STR_LIT>`);<EOL>            return new Promise<void>(function (resolve, reject) {<EOL>                reject(new SyntaxError('<STR_LIT>'));<EOL>            });<EOL>        }<EOL>    }<EOL>    const eol = options.eol || os.EOL;<EOL>    const nonEmptyLineStart = new RegExp(eol + '<STR_LIT>' + eol + '<STR_LIT>', '<STR_LIT>');<EOL>    const indent = options.indent === undefined ? '<STR_LIT>' : options.indent;<EOL>    <EOL>    <EOL>    compilerOptions.declaration = true;<EOL>    compilerOptions.target = compilerOptions.target || ts.ScriptTarget.Latest; <EOL>    compilerOptions.moduleResolution = compilerOptions.moduleResolution || options.moduleResolution;<EOL>    compilerOptions.outDir = compilerOptions.outDir || options.outDir;<EOL>    <EOL>    const baseDir = pathUtil.resolve(compilerOptions.rootDir || options.project || options.baseDir);<EOL>    const outDir = compilerOptions.outDir;<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    const filenames = getFilenames(baseDir, files);<EOL>    verboseMessage('<STR_LIT>');<EOL>    filenames.forEach(name => { verboseMessage('<STR_LIT>' + name); });<EOL>    const excludesMap: {<EOL>        [filename: string]: boolean;<EOL>    } = {};<EOL>    options.exclude = options.exclude || ['<STR_LIT>'];<EOL>    options.exclude && options.exclude.forEach(function (filename) {<EOL>        glob.sync(filename).forEach(function (globFileName) {<EOL>            excludesMap[filenameToMid(pathUtil.resolve(baseDir, globFileName))] = true;<EOL>        });<EOL>    });<EOL>    if (options.exclude) {<EOL>        verboseMessage('<STR_LIT>');<EOL>        options.exclude.forEach(name => { verboseMessage('<STR_LIT>' + name); });<EOL>    }<EOL>    mkdirp.sync(pathUtil.dirname(options.out));<EOL>    <EOL>    const output = fs.createWriteStream(options.out, <any>{ mode: parseInt('<STR_LIT>', <NUM_LIT>) });<EOL>    const host = ts.createCompilerHost(compilerOptions);<EOL>    const program = ts.createProgram(filenames, compilerOptions, host);<EOL>    function writeFile(filename: string, data: string, writeByteOrderMark: boolean) {<EOL>        <EOL>        if (filename.slice(-DTSLEN) !== '<STR_LIT>') {<EOL>            return;<EOL>        }<EOL>        writeDeclaration(ts.createSourceFile(filename, data, compilerOptions.target, true), true);<EOL>    }<EOL>    let declaredExternalModules: string[] = [];<EOL>    return new Promise<void>(function (resolve, reject) {<EOL>        output.on('<STR_LIT>', () => { resolve(undefined); });<EOL>        output.on('<STR_LIT>', reject);<EOL>        if (options.externs) {<EOL>            options.externs.forEach(function (path: string) {<EOL>                sendMessage(`<STR_LIT>`);<EOL>                output.write(`<STR_LIT>` + eol);<EOL>            });<EOL>        }<EOL>        if (options.types) {<EOL>            options.types.forEach(function (type: string) {<EOL>                sendMessage(`<STR_LIT>`);<EOL>                output.write(`<STR_LIT>` + eol);<EOL>            });<EOL>        }<EOL>        sendMessage('<STR_LIT>');<EOL>        let mainExportDeclaration = false;<EOL>        let mainExportAssignment = false;<EOL>        let foundMain = false;<EOL>        program.getSourceFiles().forEach(function (sourceFile) {<EOL>            processTree(sourceFile, function (node) {<EOL>                if (isNodeKindModuleDeclaration(node)) {<EOL>                    const name = node.name;<EOL>                    if (isNodeKindStringLiteral(name)) {<EOL>                        declaredExternalModules.push(name.text);<EOL>                    }<EOL>                }<EOL>                return null;<EOL>            });<EOL>        });<EOL>        program.getSourceFiles().some(function (sourceFile) {<EOL>            <EOL>            <EOL>            if (pathUtil.normalize(sourceFile.fileName).indexOf(baseDir) !== <NUM_LIT>) {<EOL>                return;<EOL>            }<EOL>            if (excludesMap[filenameToMid(pathUtil.normalize(sourceFile.fileName))]) {<EOL>                return;<EOL>            }<EOL>            sendMessage(`<STR_LIT>`);<EOL>            <EOL>            if (sourceFile.fileName.slice(-DTSLEN) === '<STR_LIT>') {<EOL>                writeDeclaration(sourceFile, false);<EOL>                return;<EOL>            }<EOL>            <EOL>            if (options.main && options.main === (options.prefix + filenameToMid(sourceFile.fileName.slice(baseDir.length, -<NUM_LIT>)))) {<EOL>                foundMain = true;<EOL>                ts.forEachChild(sourceFile, function (node: ts.Node) {<EOL>                    mainExportDeclaration = mainExportDeclaration || isNodeKindExportDeclaration(node);<EOL>                    mainExportAssignment = mainExportAssignment || isNodeKindExportAssignment(node);<EOL>                });<EOL>            }<EOL>            const emitOutput = program.emit(sourceFile, writeFile);<EOL>            if (emitOutput.emitSkipped || emitOutput.diagnostics.length > <NUM_LIT>) {<EOL>                reject(getError(emitOutput.diagnostics<EOL>                    .concat(program.getSemanticDiagnostics(sourceFile))<EOL>                    .concat(program.getSyntacticDiagnostics(sourceFile))<EOL>                    .concat(program.getDeclarationDiagnostics(sourceFile))));<EOL>                return true;<EOL>            }<EOL>        });<EOL>        if (options.main && !foundMain) {<EOL>            throw new Error(`<STR_LIT>`);<EOL>        }<EOL>        if (options.main) {<EOL>            output.write(`<STR_LIT>` + eol + indent);<EOL>            if (compilerOptions.target >= ts.ScriptTarget.ES2015) {<EOL>                if (mainExportAssignment) {<EOL>                    output.write(`<STR_LIT>` + eol + indent);<EOL>                }<EOL>                if (mainExportDeclaration) {<EOL>                    output.write(`<STR_LIT>` + eol);<EOL>                }<EOL>            }<EOL>            else {<EOL>                output.write(`<STR_LIT>` + eol + indent);<EOL>                output.write('<STR_LIT>' + eol);<EOL>            }<EOL>            output.write('<STR_LIT>' + eol);<EOL>            sendMessage(`<STR_LIT>`);<EOL>        }<EOL>        sendMessage(`<STR_LIT>`);<EOL>        output.end();<EOL>    });<EOL>    function writeDeclaration(declarationFile: ts.SourceFile, isOutput: boolean) {<EOL>        <EOL>        const filename = pathUtil.resolve(declarationFile.fileName);<EOL>        <EOL>        <EOL>        <EOL>        <EOL>        <EOL>        const outputDir = (isOutput && Boolean(outDir)) ? pathUtil.resolve(outDir) : baseDir;<EOL>        const sourceModuleId = filenameToMid(filename.slice(outputDir.length + <NUM_LIT>, -DTSLEN));<EOL>        const currentModuleId = filenameToMid(filename.slice(outputDir.length + <NUM_LIT>, -DTSLEN));<EOL>        function resolveModuleImport(moduleId: string): string {<EOL>            const isDeclaredExternalModule: boolean = declaredExternalModules.indexOf(moduleId) !== -<NUM_LIT>;<EOL>            let resolved: string;<EOL>            if (options.resolveModuleImport) {<EOL>                resolved = options.resolveModuleImport({<EOL>                    importedModuleId: moduleId,<EOL>                    currentModuleId: currentModuleId,<EOL>                    isDeclaredExternalModule: isDeclaredExternalModule<EOL>                });<EOL>            }<EOL>            if (!resolved) {<EOL>                <EOL>                if (moduleId.charAt(<NUM_LIT>) === '<STR_LIT>') {<EOL>                    resolved = filenameToMid(pathUtil.join(pathUtil.dirname(sourceModuleId), moduleId));<EOL>                }<EOL>                else {<EOL>                    resolved = moduleId;<EOL>                }<EOL>                <EOL>                <EOL>                <EOL>                <EOL>                <EOL>                <EOL>                <EOL>                if (Boolean(","gt":"options."}
{"input":"<s> export default function generate(options: Options): Promise<void> {<EOL>    if (Boolean(options.main) !== Boolean(options.name)) {<EOL>        if (Boolean(options.name)) {<EOL>            <EOL>            <EOL>            <EOL>            <EOL>            throw new Error(`<STR_LIT>`);<EOL>        }<EOL>        else {<EOL>            throw new Error('<STR_LIT>');<EOL>        }<EOL>    }<EOL>    const noop = function (message?: any, ...optionalParams: any[]): void { };<EOL>    const sendMessage = options.sendMessage || noop;<EOL>    const verboseMessage = options.verbose ? sendMessage : noop;<EOL>    let compilerOptions: ts.CompilerOptions = {};<EOL>    let files: string[] = options.files;<EOL>    <EOL>    if (options.project || !options.files || options.files.length === <NUM_LIT>) {<EOL>        verboseMessage(`<STR_LIT>`);<EOL>        <EOL>        <EOL>        <EOL>        <EOL>        let tsconfigFilename: string;<EOL>        if (Boolean(options.project)) {<EOL>            if (fs.lstatSync(options.project).isDirectory()) {<EOL>                tsconfigFilename = pathUtil.join(options.project, '<STR_LIT>');<EOL>            }<EOL>            else {<EOL>                <EOL>                tsconfigFilename = options.project;<EOL>            }<EOL>        }<EOL>        else {<EOL>            tsconfigFilename = pathUtil.join(options.baseDir, '<STR_LIT>');<EOL>        }<EOL>        if (fs.existsSync(tsconfigFilename)) {<EOL>            verboseMessage(`<STR_LIT>`);<EOL>            [files, compilerOptions] = getTSConfig(options, tsconfigFilename);<EOL>        }<EOL>        else {<EOL>            sendMessage(`<STR_LIT>`);<EOL>            return new Promise<void>(function (resolve, reject) {<EOL>                reject(new SyntaxError('<STR_LIT>'));<EOL>            });<EOL>        }<EOL>    }<EOL>    const eol = options.eol || os.EOL;<EOL>    const nonEmptyLineStart = new RegExp(eol + '<STR_LIT>' + eol + '<STR_LIT>', '<STR_LIT>');<EOL>    const indent = options.indent === undefined ? '<STR_LIT>' : options.indent;<EOL>    <EOL>    <EOL>    compilerOptions.declaration = true;<EOL>    compilerOptions.target = compilerOptions.target || ts.ScriptTarget.Latest; <EOL>    compilerOptions.moduleResolution = compilerOptions.moduleResolution || options.moduleResolution;<EOL>    compilerOptions.outDir = compilerOptions.outDir || options.outDir;<EOL>    <EOL>    const baseDir = pathUtil.resolve(compilerOptions.rootDir || options.project || options.baseDir);<EOL>    const outDir = compilerOptions.outDir;<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    const filenames = getFilenames(baseDir, files);<EOL>    verboseMessage('<STR_LIT>');<EOL>    filenames.forEach(name => { verboseMessage('<STR_LIT>' + name); });<EOL>    const excludesMap: {<EOL>        [filename: string]: boolean;<EOL>    } = {};<EOL>    options.exclude = options.exclude || ['<STR_LIT>'];<EOL>    options.exclude && options.exclude.forEach(function (filename) {<EOL>        glob.sync(filename).forEach(function (globFileName) {<EOL>            excludesMap[filenameToMid(pathUtil.resolve(baseDir, globFileName))] = true;<EOL>        });<EOL>    });<EOL>    if (options.exclude) {<EOL>        verboseMessage('<STR_LIT>');<EOL>        options.exclude.forEach(name => { verboseMessage('<STR_LIT>' + name); });<EOL>    }<EOL>    mkdirp.sync(pathUtil.dirname(options.out));<EOL>    <EOL>    const output = fs.createWriteStream(options.out, <any>{ mode: parseInt('<STR_LIT>', <NUM_LIT>) });<EOL>    const host = ts.createCompilerHost(compilerOptions);<EOL>    const program = ts.createProgram(filenames, compilerOptions, host);<EOL>    function writeFile(filename: string, data: string, writeByteOrderMark: boolean) {<EOL>        <EOL>        if (filename.slice(-DTSLEN) !== '<STR_LIT>') {<EOL>            return;<EOL>        }<EOL>        writeDeclaration(ts.createSourceFile(filename, data, compilerOptions.target, true), true);<EOL>    }<EOL>    let declaredExternalModules: string[] = [];<EOL>    return new Promise<void>(function (resolve, reject) {<EOL>        output.on('<STR_LIT>', () => { resolve(undefined); });<EOL>        output.on('<STR_LIT>', reject);<EOL>        if (options.externs) {<EOL>            options.externs.forEach(function (path: string) {<EOL>                sendMessage(`<STR_LIT>`);<EOL>                output.write(`<STR_LIT>` + eol);<EOL>            });<EOL>        }<EOL>        if (options.types) {<EOL>            options.types.forEach(function (type: string) {<EOL>                sendMessage(`<STR_LIT>`);<EOL>                output.write(`<STR_LIT>` + eol);<EOL>            });<EOL>        }<EOL>        sendMessage('<STR_LIT>');<EOL>        let mainExportDeclaration = false;<EOL>        let mainExportAssignment = false;<EOL>        let foundMain = false;<EOL>        program.getSourceFiles().forEach(function (sourceFile) {<EOL>            processTree(sourceFile, function (node) {<EOL>                if (isNodeKindModuleDeclaration(node)) {<EOL>                    const name = node.name;<EOL>                    if (isNodeKindStringLiteral(name)) {<EOL>                        declaredExternalModules.push(name.text);<EOL>                    }<EOL>                }<EOL>                return null;<EOL>            });<EOL>        });<EOL>        program.getSourceFiles().some(function (sourceFile) {<EOL>            <EOL>            <EOL>            if (pathUtil.normalize(sourceFile.fileName).indexOf(baseDir) !== <NUM_LIT>) {<EOL>                return;<EOL>            }<EOL>            if (excludesMap[filenameToMid(pathUtil.normalize(sourceFile.fileName))]) {<EOL>                return;<EOL>            }<EOL>            sendMessage(`<STR_LIT>`);<EOL>            <EOL>            if (sourceFile.fileName.slice(-DTSLEN) === '<STR_LIT>') {<EOL>                writeDeclaration(sourceFile, false);<EOL>                return;<EOL>            }<EOL>            <EOL>            if (options.main && options.main === (options.prefix + filenameToMid(sourceFile.fileName.slice(baseDir.length, -<NUM_LIT>)))) {<EOL>                foundMain = true;<EOL>                ts.forEachChild(sourceFile, function (node: ts.Node) {<EOL>                    mainExportDeclaration = mainExportDeclaration || isNodeKindExportDeclaration(node);<EOL>                    mainExportAssignment = mainExportAssignment || isNodeKindExportAssignment(node);<EOL>                });<EOL>            }<EOL>            const emitOutput = program.emit(sourceFile, writeFile);<EOL>            if (emitOutput.emitSkipped || emitOutput.diagnostics.length > <NUM_LIT>) {<EOL>                reject(getError(emitOutput.diagnostics<EOL>                    .concat(program.getSemanticDiagnostics(sourceFile))<EOL>                    .concat(program.getSyntacticDiagnostics(sourceFile))<EOL>                    .concat(program.getDeclarationDiagnostics(sourceFile))));<EOL>                return true;<EOL>            }<EOL>        });<EOL>        if (options.main && !foundMain) {<EOL>            throw new Error(`<STR_LIT>`);<EOL>        }<EOL>        if (options.main) {<EOL>            output.write(`<STR_LIT>` + eol + indent);<EOL>            if (compilerOptions.target >= ts.ScriptTarget.ES2015) {<EOL>                if (mainExportAssignment) {<EOL>                    output.write(`<STR_LIT>` + eol + indent);<EOL>                }<EOL>                if (mainExportDeclaration) {<EOL>                    output.write(`<STR_LIT>` + eol);<EOL>                }<EOL>            }<EOL>            else {<EOL>                output.write(`<STR_LIT>` + eol + indent);<EOL>                output.write('<STR_LIT>' + eol);<EOL>            }<EOL>            output.write('<STR_LIT>' + eol);<EOL>            sendMessage(`<STR_LIT>`);<EOL>        }<EOL>        sendMessage(`<STR_LIT>`);<EOL>        output.end();<EOL>    });<EOL>    function writeDeclaration(declarationFile: ts.SourceFile, isOutput: boolean) {<EOL>        <EOL>        const filename = pathUtil.resolve(declarationFile.fileName);<EOL>        <EOL>        <EOL>        <EOL>        <EOL>        <EOL>        const outputDir = (isOutput && Boolean(outDir)) ? pathUtil.resolve(outDir) : baseDir;<EOL>        const sourceModuleId = filenameToMid(filename.slice(outputDir.length + <NUM_LIT>, -DTSLEN));<EOL>        const currentModuleId = filenameToMid(filename.slice(outputDir.length + <NUM_LIT>, -DTSLEN));<EOL>        function resolveModuleImport(moduleId: string): string {<EOL>            const isDeclaredExternalModule: boolean = declaredExternalModules.indexOf(moduleId) !== -<NUM_LIT>;<EOL>            let resolved: string;<EOL>            if (options.resolveModuleImport) {<EOL>                resolved = options.resolveModuleImport({<EOL>                    importedModuleId: moduleId,<EOL>                    currentModuleId: currentModuleId,<EOL>                    isDeclaredExternalModule: isDeclaredExternalModule<EOL>                });<EOL>            }<EOL>            if (!resolved) {<EOL>                <EOL>                if (moduleId.charAt(<NUM_LIT>) === '<STR_LIT>') {<EOL>                    resolved = filenameToMid(pathUtil.join(pathUtil.dirname(sourceModuleId), moduleId));<EOL>                }<EOL>                else {<EOL>                    resolved = moduleId;<EOL>                }<EOL>                <EOL>                <EOL>                <EOL>                <EOL>                <EOL>                <EOL>                <EOL>                if (Boolean(options.","gt":"prefix) && !isDeclaredExternalModule) {"}
{"input":"<s> export default function generate(options: Options): Promise<void> {<EOL>    if (Boolean(options.main) !== Boolean(options.name)) {<EOL>        if (Boolean(options.name)) {<EOL>            <EOL>            <EOL>            <EOL>            <EOL>            throw new Error(`<STR_LIT>`);<EOL>        }<EOL>        else {<EOL>            throw new Error('<STR_LIT>');<EOL>        }<EOL>    }<EOL>    const noop = function (message?: any, ...optionalParams: any[]): void { };<EOL>    const sendMessage = options.sendMessage || noop;<EOL>    const verboseMessage = options.verbose ? sendMessage : noop;<EOL>    let compilerOptions: ts.CompilerOptions = {};<EOL>    let files: string[] = options.files;<EOL>    <EOL>    if (options.project || !options.files || options.files.length === <NUM_LIT>) {<EOL>        verboseMessage(`<STR_LIT>`);<EOL>        <EOL>        <EOL>        <EOL>        <EOL>        let tsconfigFilename: string;<EOL>        if (Boolean(options.project)) {<EOL>            if (fs.lstatSync(options.project).isDirectory()) {<EOL>                tsconfigFilename = pathUtil.join(options.project, '<STR_LIT>');<EOL>            }<EOL>            else {<EOL>                <EOL>                tsconfigFilename = options.project;<EOL>            }<EOL>        }<EOL>        else {<EOL>            tsconfigFilename = pathUtil.join(options.baseDir, '<STR_LIT>');<EOL>        }<EOL>        if (fs.existsSync(tsconfigFilename)) {<EOL>            verboseMessage(`<STR_LIT>`);<EOL>            [files, compilerOptions] = getTSConfig(options, tsconfigFilename);<EOL>        }<EOL>        else {<EOL>            sendMessage(`<STR_LIT>`);<EOL>            return new Promise<void>(function (resolve, reject) {<EOL>                reject(new SyntaxError('<STR_LIT>'));<EOL>            });<EOL>        }<EOL>    }<EOL>    const eol = options.eol || os.EOL;<EOL>    const nonEmptyLineStart = new RegExp(eol + '<STR_LIT>' + eol + '<STR_LIT>', '<STR_LIT>');<EOL>    const indent = options.indent === undefined ? '<STR_LIT>' : options.indent;<EOL>    <EOL>    <EOL>    compilerOptions.declaration = true;<EOL>    compilerOptions.target = compilerOptions.target || ts.ScriptTarget.Latest; <EOL>    compilerOptions.moduleResolution = compilerOptions.moduleResolution || options.moduleResolution;<EOL>    compilerOptions.outDir = compilerOptions.outDir || options.outDir;<EOL>    <EOL>    const baseDir = pathUtil.resolve(compilerOptions.rootDir || options.project || options.baseDir);<EOL>    const outDir = compilerOptions.outDir;<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    const filenames = getFilenames(baseDir, files);<EOL>    verboseMessage('<STR_LIT>');<EOL>    filenames.forEach(name => { verboseMessage('<STR_LIT>' + name); });<EOL>    const excludesMap: {<EOL>        [filename: string]: boolean;<EOL>    } = {};<EOL>    options.exclude = options.exclude || ['<STR_LIT>'];<EOL>    options.exclude && options.exclude.forEach(function (filename) {<EOL>        glob.sync(filename).forEach(function (globFileName) {<EOL>            excludesMap[filenameToMid(pathUtil.resolve(baseDir, globFileName))] = true;<EOL>        });<EOL>    });<EOL>    if (options.exclude) {<EOL>        verboseMessage('<STR_LIT>');<EOL>        options.exclude.forEach(name => { verboseMessage('<STR_LIT>' + name); });<EOL>    }<EOL>    mkdirp.sync(pathUtil.dirname(options.out));<EOL>    <EOL>    const output = fs.createWriteStream(options.out, <any>{ mode: parseInt('<STR_LIT>', <NUM_LIT>) });<EOL>    const host = ts.createCompilerHost(compilerOptions);<EOL>    const program = ts.createProgram(filenames, compilerOptions, host);<EOL>    function writeFile(filename: string, data: string, writeByteOrderMark: boolean) {<EOL>        <EOL>        if (filename.slice(-DTSLEN) !== '<STR_LIT>') {<EOL>            return;<EOL>        }<EOL>        writeDeclaration(ts.createSourceFile(filename, data, compilerOptions.target, true), true);<EOL>    }<EOL>    let declaredExternalModules: string[] = [];<EOL>    return new Promise<void>(function (resolve, reject) {<EOL>        output.on('<STR_LIT>', () => { resolve(undefined); });<EOL>        output.on('<STR_LIT>', reject);<EOL>        if (options.externs) {<EOL>            options.externs.forEach(function (path: string) {<EOL>                sendMessage(`<STR_LIT>`);<EOL>                output.write(`<STR_LIT>` + eol);<EOL>            });<EOL>        }<EOL>        if (options.types) {<EOL>            options.types.forEach(function (type: string) {<EOL>                sendMessage(`<STR_LIT>`);<EOL>                output.write(`<STR_LIT>` + eol);<EOL>            });<EOL>        }<EOL>        sendMessage('<STR_LIT>');<EOL>        let mainExportDeclaration = false;<EOL>        let mainExportAssignment = false;<EOL>        let foundMain = false;<EOL>        program.getSourceFiles().forEach(function (sourceFile) {<EOL>            processTree(sourceFile, function (node) {<EOL>                if (isNodeKindModuleDeclaration(node)) {<EOL>                    const name = node.name;<EOL>                    if (isNodeKindStringLiteral(name)) {<EOL>                        declaredExternalModules.push(name.text);<EOL>                    }<EOL>                }<EOL>                return null;<EOL>            });<EOL>        });<EOL>        program.getSourceFiles().some(function (sourceFile) {<EOL>            <EOL>            <EOL>            if (pathUtil.normalize(sourceFile.fileName).indexOf(baseDir) !== <NUM_LIT>) {<EOL>                return;<EOL>            }<EOL>            if (excludesMap[filenameToMid(pathUtil.normalize(sourceFile.fileName))]) {<EOL>                return;<EOL>            }<EOL>            sendMessage(`<STR_LIT>`);<EOL>            <EOL>            if (sourceFile.fileName.slice(-DTSLEN) === '<STR_LIT>') {<EOL>                writeDeclaration(sourceFile, false);<EOL>                return;<EOL>            }<EOL>            <EOL>            if (options.main && options.main === (options.prefix + filenameToMid(sourceFile.fileName.slice(baseDir.length, -<NUM_LIT>)))) {<EOL>                foundMain = true;<EOL>                ts.forEachChild(sourceFile, function (node: ts.Node) {<EOL>                    mainExportDeclaration = mainExportDeclaration || isNodeKindExportDeclaration(node);<EOL>                    mainExportAssignment = mainExportAssignment || isNodeKindExportAssignment(node);<EOL>                });<EOL>            }<EOL>            const emitOutput = program.emit(sourceFile, writeFile);<EOL>            if (emitOutput.emitSkipped || emitOutput.diagnostics.length > <NUM_LIT>) {<EOL>                reject(getError(emitOutput.diagnostics<EOL>                    .concat(program.getSemanticDiagnostics(sourceFile))<EOL>                    .concat(program.getSyntacticDiagnostics(sourceFile))<EOL>                    .concat(program.getDeclarationDiagnostics(sourceFile))));<EOL>                return true;<EOL>            }<EOL>        });<EOL>        if (options.main && !foundMain) {<EOL>            throw new Error(`<STR_LIT>`);<EOL>        }<EOL>        if (options.main) {<EOL>            output.write(`<STR_LIT>` + eol + indent);<EOL>            if (compilerOptions.target >= ts.ScriptTarget.ES2015) {<EOL>                if (mainExportAssignment) {<EOL>                    output.write(`<STR_LIT>` + eol + indent);<EOL>                }<EOL>                if (mainExportDeclaration) {<EOL>                    output.write(`<STR_LIT>` + eol);<EOL>                }<EOL>            }<EOL>            else {<EOL>                output.write(`<STR_LIT>` + eol + indent);<EOL>                output.write('<STR_LIT>' + eol);<EOL>            }<EOL>            output.write('<STR_LIT>' + eol);<EOL>            sendMessage(`<STR_LIT>`);<EOL>        }<EOL>        sendMessage(`<STR_LIT>`);<EOL>        output.end();<EOL>    });<EOL>    function writeDeclaration(declarationFile: ts.SourceFile, isOutput: boolean) {<EOL>        <EOL>        const filename = pathUtil.resolve(declarationFile.fileName);<EOL>        <EOL>        <EOL>        <EOL>        <EOL>        <EOL>        const outputDir = (isOutput && Boolean(outDir)) ? pathUtil.resolve(outDir) : baseDir;<EOL>        const sourceModuleId = filenameToMid(filename.slice(outputDir.length + <NUM_LIT>, -DTSLEN));<EOL>        const currentModuleId = filenameToMid(filename.slice(outputDir.length + <NUM_LIT>, -DTSLEN));<EOL>        function resolveModuleImport(moduleId: string): string {<EOL>            const isDeclaredExternalModule: boolean = declaredExternalModules.indexOf(moduleId) !== -<NUM_LIT>;<EOL>            let resolved: string;<EOL>            if (options.resolveModuleImport) {<EOL>                resolved = options.resolveModuleImport({<EOL>                    importedModuleId: moduleId,<EOL>                    currentModuleId: currentModuleId,<EOL>                    isDeclaredExternalModule: isDeclaredExternalModule<EOL>                });<EOL>            }<EOL>            if (!resolved) {<EOL>                <EOL>                if (moduleId.charAt(<NUM_LIT>) === '<STR_LIT>') {<EOL>                    resolved = filenameToMid(pathUtil.join(pathUtil.dirname(sourceModuleId), moduleId));<EOL>                }<EOL>                else {<EOL>                    resolved = moduleId;<EOL>                }<EOL>                <EOL>                <EOL>                <EOL>                <EOL>                <EOL>                <EOL>                <EOL>                if (Boolean(options.prefix) && !isDeclaredExternalModule) {<EOL>                    resolved =","gt":"options.prefix}/${resolved}`;"}
{"input":"<s> export default function generate(options: Options): Promise<void> {<EOL>    if (Boolean(options.main) !== Boolean(options.name)) {<EOL>        if (Boolean(options.name)) {<EOL>            <EOL>            <EOL>            <EOL>            <EOL>            throw new Error(`<STR_LIT>`);<EOL>        }<EOL>        else {<EOL>            throw new Error('<STR_LIT>');<EOL>        }<EOL>    }<EOL>    const noop = function (message?: any, ...optionalParams: any[]): void { };<EOL>    const sendMessage = options.sendMessage || noop;<EOL>    const verboseMessage = options.verbose ? sendMessage : noop;<EOL>    let compilerOptions: ts.CompilerOptions = {};<EOL>    let files: string[] = options.files;<EOL>    <EOL>    if (options.project || !options.files || options.files.length === <NUM_LIT>) {<EOL>        verboseMessage(`<STR_LIT>`);<EOL>        <EOL>        <EOL>        <EOL>        <EOL>        let tsconfigFilename: string;<EOL>        if (Boolean(options.project)) {<EOL>            if (fs.lstatSync(options.project).isDirectory()) {<EOL>                tsconfigFilename = pathUtil.join(options.project, '<STR_LIT>');<EOL>            }<EOL>            else {<EOL>                <EOL>                tsconfigFilename = options.project;<EOL>            }<EOL>        }<EOL>        else {<EOL>            tsconfigFilename = pathUtil.join(options.baseDir, '<STR_LIT>');<EOL>        }<EOL>        if (fs.existsSync(tsconfigFilename)) {<EOL>            verboseMessage(`<STR_LIT>`);<EOL>            [files, compilerOptions] = getTSConfig(options, tsconfigFilename);<EOL>        }<EOL>        else {<EOL>            sendMessage(`<STR_LIT>`);<EOL>            return new Promise<void>(function (resolve, reject) {<EOL>                reject(new SyntaxError('<STR_LIT>'));<EOL>            });<EOL>        }<EOL>    }<EOL>    const eol = options.eol || os.EOL;<EOL>    const nonEmptyLineStart = new RegExp(eol + '<STR_LIT>' + eol + '<STR_LIT>', '<STR_LIT>');<EOL>    const indent = options.indent === undefined ? '<STR_LIT>' : options.indent;<EOL>    <EOL>    <EOL>    compilerOptions.declaration = true;<EOL>    compilerOptions.target = compilerOptions.target || ts.ScriptTarget.Latest; <EOL>    compilerOptions.moduleResolution = compilerOptions.moduleResolution || options.moduleResolution;<EOL>    compilerOptions.outDir = compilerOptions.outDir || options.outDir;<EOL>    <EOL>    const baseDir = pathUtil.resolve(compilerOptions.rootDir || options.project || options.baseDir);<EOL>    const outDir = compilerOptions.outDir;<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    const filenames = getFilenames(baseDir, files);<EOL>    verboseMessage('<STR_LIT>');<EOL>    filenames.forEach(name => { verboseMessage('<STR_LIT>' + name); });<EOL>    const excludesMap: {<EOL>        [filename: string]: boolean;<EOL>    } = {};<EOL>    options.exclude = options.exclude || ['<STR_LIT>'];<EOL>    options.exclude && options.exclude.forEach(function (filename) {<EOL>        glob.sync(filename).forEach(function (globFileName) {<EOL>            excludesMap[filenameToMid(pathUtil.resolve(baseDir, globFileName))] = true;<EOL>        });<EOL>    });<EOL>    if (options.exclude) {<EOL>        verboseMessage('<STR_LIT>');<EOL>        options.exclude.forEach(name => { verboseMessage('<STR_LIT>' + name); });<EOL>    }<EOL>    mkdirp.sync(pathUtil.dirname(options.out));<EOL>    <EOL>    const output = fs.createWriteStream(options.out, <any>{ mode: parseInt('<STR_LIT>', <NUM_LIT>) });<EOL>    const host = ts.createCompilerHost(compilerOptions);<EOL>    const program = ts.createProgram(filenames, compilerOptions, host);<EOL>    function writeFile(filename: string, data: string, writeByteOrderMark: boolean) {<EOL>        <EOL>        if (filename.slice(-DTSLEN) !== '<STR_LIT>') {<EOL>            return;<EOL>        }<EOL>        writeDeclaration(ts.createSourceFile(filename, data, compilerOptions.target, true), true);<EOL>    }<EOL>    let declaredExternalModules: string[] = [];<EOL>    return new Promise<void>(function (resolve, reject) {<EOL>        output.on('<STR_LIT>', () => { resolve(undefined); });<EOL>        output.on('<STR_LIT>', reject);<EOL>        if (options.externs) {<EOL>            options.externs.forEach(function (path: string) {<EOL>                sendMessage(`<STR_LIT>`);<EOL>                output.write(`<STR_LIT>` + eol);<EOL>            });<EOL>        }<EOL>        if (options.types) {<EOL>            options.types.forEach(function (type: string) {<EOL>                sendMessage(`<STR_LIT>`);<EOL>                output.write(`<STR_LIT>` + eol);<EOL>            });<EOL>        }<EOL>        sendMessage('<STR_LIT>');<EOL>        let mainExportDeclaration = false;<EOL>        let mainExportAssignment = false;<EOL>        let foundMain = false;<EOL>        program.getSourceFiles().forEach(function (sourceFile) {<EOL>            processTree(sourceFile, function (node) {<EOL>                if (isNodeKindModuleDeclaration(node)) {<EOL>                    const name = node.name;<EOL>                    if (isNodeKindStringLiteral(name)) {<EOL>                        declaredExternalModules.push(name.text);<EOL>                    }<EOL>                }<EOL>                return null;<EOL>            });<EOL>        });<EOL>        program.getSourceFiles().some(function (sourceFile) {<EOL>            <EOL>            <EOL>            if (pathUtil.normalize(sourceFile.fileName).indexOf(baseDir) !== <NUM_LIT>) {<EOL>                return;<EOL>            }<EOL>            if (excludesMap[filenameToMid(pathUtil.normalize(sourceFile.fileName))]) {<EOL>                return;<EOL>            }<EOL>            sendMessage(`<STR_LIT>`);<EOL>            <EOL>            if (sourceFile.fileName.slice(-DTSLEN) === '<STR_LIT>') {<EOL>                writeDeclaration(sourceFile, false);<EOL>                return;<EOL>            }<EOL>            <EOL>            if (options.main && options.main === (options.prefix + filenameToMid(sourceFile.fileName.slice(baseDir.length, -<NUM_LIT>)))) {<EOL>                foundMain = true;<EOL>                ts.forEachChild(sourceFile, function (node: ts.Node) {<EOL>                    mainExportDeclaration = mainExportDeclaration || isNodeKindExportDeclaration(node);<EOL>                    mainExportAssignment = mainExportAssignment || isNodeKindExportAssignment(node);<EOL>                });<EOL>            }<EOL>            const emitOutput = program.emit(sourceFile, writeFile);<EOL>            if (emitOutput.emitSkipped || emitOutput.diagnostics.length > <NUM_LIT>) {<EOL>                reject(getError(emitOutput.diagnostics<EOL>                    .concat(program.getSemanticDiagnostics(sourceFile))<EOL>                    .concat(program.getSyntacticDiagnostics(sourceFile))<EOL>                    .concat(program.getDeclarationDiagnostics(sourceFile))));<EOL>                return true;<EOL>            }<EOL>        });<EOL>        if (options.main && !foundMain) {<EOL>            throw new Error(`<STR_LIT>`);<EOL>        }<EOL>        if (options.main) {<EOL>            output.write(`<STR_LIT>` + eol + indent);<EOL>            if (compilerOptions.target >= ts.ScriptTarget.ES2015) {<EOL>                if (mainExportAssignment) {<EOL>                    output.write(`<STR_LIT>` + eol + indent);<EOL>                }<EOL>                if (mainExportDeclaration) {<EOL>                    output.write(`<STR_LIT>` + eol);<EOL>                }<EOL>            }<EOL>            else {<EOL>                output.write(`<STR_LIT>` + eol + indent);<EOL>                output.write('<STR_LIT>' + eol);<EOL>            }<EOL>            output.write('<STR_LIT>' + eol);<EOL>            sendMessage(`<STR_LIT>`);<EOL>        }<EOL>        sendMessage(`<STR_LIT>`);<EOL>        output.end();<EOL>    });<EOL>    function writeDeclaration(declarationFile: ts.SourceFile, isOutput: boolean) {<EOL>        <EOL>        const filename = pathUtil.resolve(declarationFile.fileName);<EOL>        <EOL>        <EOL>        <EOL>        <EOL>        <EOL>        const outputDir = (isOutput && Boolean(outDir)) ? pathUtil.resolve(outDir) : baseDir;<EOL>        const sourceModuleId = filenameToMid(filename.slice(outputDir.length + <NUM_LIT>, -DTSLEN));<EOL>        const currentModuleId = filenameToMid(filename.slice(outputDir.length + <NUM_LIT>, -DTSLEN));<EOL>        function resolveModuleImport(moduleId: string): string {<EOL>            const isDeclaredExternalModule: boolean = declaredExternalModules.indexOf(moduleId) !== -<NUM_LIT>;<EOL>            let resolved: string;<EOL>            if (options.resolveModuleImport) {<EOL>                resolved = options.resolveModuleImport({<EOL>                    importedModuleId: moduleId,<EOL>                    currentModuleId: currentModuleId,<EOL>                    isDeclaredExternalModule: isDeclaredExternalModule<EOL>                });<EOL>            }<EOL>            if (!resolved) {<EOL>                <EOL>                if (moduleId.charAt(<NUM_LIT>) === '<STR_LIT>') {<EOL>                    resolved = filenameToMid(pathUtil.join(pathUtil.dirname(sourceModuleId), moduleId));<EOL>                }<EOL>                else {<EOL>                    resolved = moduleId;<EOL>                }<EOL>                <EOL>                <EOL>                <EOL>                <EOL>                <EOL>                <EOL>                <EOL>                if (Boolean(options.prefix) && !isDeclaredExternalModule) {<EOL>                    resolved = `<STR_LIT>`;<EOL>                }<EOL>            }<EOL>            return resolved;<EOL>        }<EOL>        <EOL>","gt":"if ((<any>declarationFile).externalModuleIndicator) {"}
{"input":"<s> export default function generate(options: Options): Promise<void> {<EOL>    if (Boolean(options.main) !== Boolean(options.name)) {<EOL>        if (Boolean(options.name)) {<EOL>            <EOL>            <EOL>            <EOL>            <EOL>            throw new Error(`<STR_LIT>`);<EOL>        }<EOL>        else {<EOL>            throw new Error('<STR_LIT>');<EOL>        }<EOL>    }<EOL>    const noop = function (message?: any, ...optionalParams: any[]): void { };<EOL>    const sendMessage = options.sendMessage || noop;<EOL>    const verboseMessage = options.verbose ? sendMessage : noop;<EOL>    let compilerOptions: ts.CompilerOptions = {};<EOL>    let files: string[] = options.files;<EOL>    <EOL>    if (options.project || !options.files || options.files.length === <NUM_LIT>) {<EOL>        verboseMessage(`<STR_LIT>`);<EOL>        <EOL>        <EOL>        <EOL>        <EOL>        let tsconfigFilename: string;<EOL>        if (Boolean(options.project)) {<EOL>            if (fs.lstatSync(options.project).isDirectory()) {<EOL>                tsconfigFilename = pathUtil.join(options.project, '<STR_LIT>');<EOL>            }<EOL>            else {<EOL>                <EOL>                tsconfigFilename = options.project;<EOL>            }<EOL>        }<EOL>        else {<EOL>            tsconfigFilename = pathUtil.join(options.baseDir, '<STR_LIT>');<EOL>        }<EOL>        if (fs.existsSync(tsconfigFilename)) {<EOL>            verboseMessage(`<STR_LIT>`);<EOL>            [files, compilerOptions] = getTSConfig(options, tsconfigFilename);<EOL>        }<EOL>        else {<EOL>            sendMessage(`<STR_LIT>`);<EOL>            return new Promise<void>(function (resolve, reject) {<EOL>                reject(new SyntaxError('<STR_LIT>'));<EOL>            });<EOL>        }<EOL>    }<EOL>    const eol = options.eol || os.EOL;<EOL>    const nonEmptyLineStart = new RegExp(eol + '<STR_LIT>' + eol + '<STR_LIT>', '<STR_LIT>');<EOL>    const indent = options.indent === undefined ? '<STR_LIT>' : options.indent;<EOL>    <EOL>    <EOL>    compilerOptions.declaration = true;<EOL>    compilerOptions.target = compilerOptions.target || ts.ScriptTarget.Latest; <EOL>    compilerOptions.moduleResolution = compilerOptions.moduleResolution || options.moduleResolution;<EOL>    compilerOptions.outDir = compilerOptions.outDir || options.outDir;<EOL>    <EOL>    const baseDir = pathUtil.resolve(compilerOptions.rootDir || options.project || options.baseDir);<EOL>    const outDir = compilerOptions.outDir;<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    const filenames = getFilenames(baseDir, files);<EOL>    verboseMessage('<STR_LIT>');<EOL>    filenames.forEach(name => { verboseMessage('<STR_LIT>' + name); });<EOL>    const excludesMap: {<EOL>        [filename: string]: boolean;<EOL>    } = {};<EOL>    options.exclude = options.exclude || ['<STR_LIT>'];<EOL>    options.exclude && options.exclude.forEach(function (filename) {<EOL>        glob.sync(filename).forEach(function (globFileName) {<EOL>            excludesMap[filenameToMid(pathUtil.resolve(baseDir, globFileName))] = true;<EOL>        });<EOL>    });<EOL>    if (options.exclude) {<EOL>        verboseMessage('<STR_LIT>');<EOL>        options.exclude.forEach(name => { verboseMessage('<STR_LIT>' + name); });<EOL>    }<EOL>    mkdirp.sync(pathUtil.dirname(options.out));<EOL>    <EOL>    const output = fs.createWriteStream(options.out, <any>{ mode: parseInt('<STR_LIT>', <NUM_LIT>) });<EOL>    const host = ts.createCompilerHost(compilerOptions);<EOL>    const program = ts.createProgram(filenames, compilerOptions, host);<EOL>    function writeFile(filename: string, data: string, writeByteOrderMark: boolean) {<EOL>        <EOL>        if (filename.slice(-DTSLEN) !== '<STR_LIT>') {<EOL>            return;<EOL>        }<EOL>        writeDeclaration(ts.createSourceFile(filename, data, compilerOptions.target, true), true);<EOL>    }<EOL>    let declaredExternalModules: string[] = [];<EOL>    return new Promise<void>(function (resolve, reject) {<EOL>        output.on('<STR_LIT>', () => { resolve(undefined); });<EOL>        output.on('<STR_LIT>', reject);<EOL>        if (options.externs) {<EOL>            options.externs.forEach(function (path: string) {<EOL>                sendMessage(`<STR_LIT>`);<EOL>                output.write(`<STR_LIT>` + eol);<EOL>            });<EOL>        }<EOL>        if (options.types) {<EOL>            options.types.forEach(function (type: string) {<EOL>                sendMessage(`<STR_LIT>`);<EOL>                output.write(`<STR_LIT>` + eol);<EOL>            });<EOL>        }<EOL>        sendMessage('<STR_LIT>');<EOL>        let mainExportDeclaration = false;<EOL>        let mainExportAssignment = false;<EOL>        let foundMain = false;<EOL>        program.getSourceFiles().forEach(function (sourceFile) {<EOL>            processTree(sourceFile, function (node) {<EOL>                if (isNodeKindModuleDeclaration(node)) {<EOL>                    const name = node.name;<EOL>                    if (isNodeKindStringLiteral(name)) {<EOL>                        declaredExternalModules.push(name.text);<EOL>                    }<EOL>                }<EOL>                return null;<EOL>            });<EOL>        });<EOL>        program.getSourceFiles().some(function (sourceFile) {<EOL>            <EOL>            <EOL>            if (pathUtil.normalize(sourceFile.fileName).indexOf(baseDir) !== <NUM_LIT>) {<EOL>                return;<EOL>            }<EOL>            if (excludesMap[filenameToMid(pathUtil.normalize(sourceFile.fileName))]) {<EOL>                return;<EOL>            }<EOL>            sendMessage(`<STR_LIT>`);<EOL>            <EOL>            if (sourceFile.fileName.slice(-DTSLEN) === '<STR_LIT>') {<EOL>                writeDeclaration(sourceFile, false);<EOL>                return;<EOL>            }<EOL>            <EOL>            if (options.main && options.main === (options.prefix + filenameToMid(sourceFile.fileName.slice(baseDir.length, -<NUM_LIT>)))) {<EOL>                foundMain = true;<EOL>                ts.forEachChild(sourceFile, function (node: ts.Node) {<EOL>                    mainExportDeclaration = mainExportDeclaration || isNodeKindExportDeclaration(node);<EOL>                    mainExportAssignment = mainExportAssignment || isNodeKindExportAssignment(node);<EOL>                });<EOL>            }<EOL>            const emitOutput = program.emit(sourceFile, writeFile);<EOL>            if (emitOutput.emitSkipped || emitOutput.diagnostics.length > <NUM_LIT>) {<EOL>                reject(getError(emitOutput.diagnostics<EOL>                    .concat(program.getSemanticDiagnostics(sourceFile))<EOL>                    .concat(program.getSyntacticDiagnostics(sourceFile))<EOL>                    .concat(program.getDeclarationDiagnostics(sourceFile))));<EOL>                return true;<EOL>            }<EOL>        });<EOL>        if (options.main && !foundMain) {<EOL>            throw new Error(`<STR_LIT>`);<EOL>        }<EOL>        if (options.main) {<EOL>            output.write(`<STR_LIT>` + eol + indent);<EOL>            if (compilerOptions.target >= ts.ScriptTarget.ES2015) {<EOL>                if (mainExportAssignment) {<EOL>                    output.write(`<STR_LIT>` + eol + indent);<EOL>                }<EOL>                if (mainExportDeclaration) {<EOL>                    output.write(`<STR_LIT>` + eol);<EOL>                }<EOL>            }<EOL>            else {<EOL>                output.write(`<STR_LIT>` + eol + indent);<EOL>                output.write('<STR_LIT>' + eol);<EOL>            }<EOL>            output.write('<STR_LIT>' + eol);<EOL>            sendMessage(`<STR_LIT>`);<EOL>        }<EOL>        sendMessage(`<STR_LIT>`);<EOL>        output.end();<EOL>    });<EOL>    function writeDeclaration(declarationFile: ts.SourceFile, isOutput: boolean) {<EOL>        <EOL>        const filename = pathUtil.resolve(declarationFile.fileName);<EOL>        <EOL>        <EOL>        <EOL>        <EOL>        <EOL>        const outputDir = (isOutput && Boolean(outDir)) ? pathUtil.resolve(outDir) : baseDir;<EOL>        const sourceModuleId = filenameToMid(filename.slice(outputDir.length + <NUM_LIT>, -DTSLEN));<EOL>        const currentModuleId = filenameToMid(filename.slice(outputDir.length + <NUM_LIT>, -DTSLEN));<EOL>        function resolveModuleImport(moduleId: string): string {<EOL>            const isDeclaredExternalModule: boolean = declaredExternalModules.indexOf(moduleId) !== -<NUM_LIT>;<EOL>            let resolved: string;<EOL>            if (options.resolveModuleImport) {<EOL>                resolved = options.resolveModuleImport({<EOL>                    importedModuleId: moduleId,<EOL>                    currentModuleId: currentModuleId,<EOL>                    isDeclaredExternalModule: isDeclaredExternalModule<EOL>                });<EOL>            }<EOL>            if (!resolved) {<EOL>                <EOL>                if (moduleId.charAt(<NUM_LIT>) === '<STR_LIT>') {<EOL>                    resolved = filenameToMid(pathUtil.join(pathUtil.dirname(sourceModuleId), moduleId));<EOL>                }<EOL>                else {<EOL>                    resolved = moduleId;<EOL>                }<EOL>                <EOL>                <EOL>                <EOL>                <EOL>                <EOL>                <EOL>                <EOL>                if (Boolean(options.prefix) && !isDeclaredExternalModule) {<EOL>                    resolved = `<STR_LIT>`;<EOL>                }<EOL>            }<EOL>            return resolved;<EOL>        }<EOL>        <EOL>        if ((<any>declarationFile).externalModuleIndicator) {<EOL>            let resolvedModuleId: string = sourceModuleId;<EOL>            if (options.resolveModuleId) {<EOL>                const resolveModuleIdResult: string = options.resolveModuleId({<EOL>                    currentModuleId:","gt":"currentModuleId"}
{"input":"<s> export default function generate(options: Options): Promise<void> {<EOL>    if (Boolean(options.main) !== Boolean(options.name)) {<EOL>        if (Boolean(options.name)) {<EOL>            <EOL>            <EOL>            <EOL>            <EOL>            throw new Error(`<STR_LIT>`);<EOL>        }<EOL>        else {<EOL>            throw new Error('<STR_LIT>');<EOL>        }<EOL>    }<EOL>    const noop = function (message?: any, ...optionalParams: any[]): void { };<EOL>    const sendMessage = options.sendMessage || noop;<EOL>    const verboseMessage = options.verbose ? sendMessage : noop;<EOL>    let compilerOptions: ts.CompilerOptions = {};<EOL>    let files: string[] = options.files;<EOL>    <EOL>    if (options.project || !options.files || options.files.length === <NUM_LIT>) {<EOL>        verboseMessage(`<STR_LIT>`);<EOL>        <EOL>        <EOL>        <EOL>        <EOL>        let tsconfigFilename: string;<EOL>        if (Boolean(options.project)) {<EOL>            if (fs.lstatSync(options.project).isDirectory()) {<EOL>                tsconfigFilename = pathUtil.join(options.project, '<STR_LIT>');<EOL>            }<EOL>            else {<EOL>                <EOL>                tsconfigFilename = options.project;<EOL>            }<EOL>        }<EOL>        else {<EOL>            tsconfigFilename = pathUtil.join(options.baseDir, '<STR_LIT>');<EOL>        }<EOL>        if (fs.existsSync(tsconfigFilename)) {<EOL>            verboseMessage(`<STR_LIT>`);<EOL>            [files, compilerOptions] = getTSConfig(options, tsconfigFilename);<EOL>        }<EOL>        else {<EOL>            sendMessage(`<STR_LIT>`);<EOL>            return new Promise<void>(function (resolve, reject) {<EOL>                reject(new SyntaxError('<STR_LIT>'));<EOL>            });<EOL>        }<EOL>    }<EOL>    const eol = options.eol || os.EOL;<EOL>    const nonEmptyLineStart = new RegExp(eol + '<STR_LIT>' + eol + '<STR_LIT>', '<STR_LIT>');<EOL>    const indent = options.indent === undefined ? '<STR_LIT>' : options.indent;<EOL>    <EOL>    <EOL>    compilerOptions.declaration = true;<EOL>    compilerOptions.target = compilerOptions.target || ts.ScriptTarget.Latest; <EOL>    compilerOptions.moduleResolution = compilerOptions.moduleResolution || options.moduleResolution;<EOL>    compilerOptions.outDir = compilerOptions.outDir || options.outDir;<EOL>    <EOL>    const baseDir = pathUtil.resolve(compilerOptions.rootDir || options.project || options.baseDir);<EOL>    const outDir = compilerOptions.outDir;<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    const filenames = getFilenames(baseDir, files);<EOL>    verboseMessage('<STR_LIT>');<EOL>    filenames.forEach(name => { verboseMessage('<STR_LIT>' + name); });<EOL>    const excludesMap: {<EOL>        [filename: string]: boolean;<EOL>    } = {};<EOL>    options.exclude = options.exclude || ['<STR_LIT>'];<EOL>    options.exclude && options.exclude.forEach(function (filename) {<EOL>        glob.sync(filename).forEach(function (globFileName) {<EOL>            excludesMap[filenameToMid(pathUtil.resolve(baseDir, globFileName))] = true;<EOL>        });<EOL>    });<EOL>    if (options.exclude) {<EOL>        verboseMessage('<STR_LIT>');<EOL>        options.exclude.forEach(name => { verboseMessage('<STR_LIT>' + name); });<EOL>    }<EOL>    mkdirp.sync(pathUtil.dirname(options.out));<EOL>    <EOL>    const output = fs.createWriteStream(options.out, <any>{ mode: parseInt('<STR_LIT>', <NUM_LIT>) });<EOL>    const host = ts.createCompilerHost(compilerOptions);<EOL>    const program = ts.createProgram(filenames, compilerOptions, host);<EOL>    function writeFile(filename: string, data: string, writeByteOrderMark: boolean) {<EOL>        <EOL>        if (filename.slice(-DTSLEN) !== '<STR_LIT>') {<EOL>            return;<EOL>        }<EOL>        writeDeclaration(ts.createSourceFile(filename, data, compilerOptions.target, true), true);<EOL>    }<EOL>    let declaredExternalModules: string[] = [];<EOL>    return new Promise<void>(function (resolve, reject) {<EOL>        output.on('<STR_LIT>', () => { resolve(undefined); });<EOL>        output.on('<STR_LIT>', reject);<EOL>        if (options.externs) {<EOL>            options.externs.forEach(function (path: string) {<EOL>                sendMessage(`<STR_LIT>`);<EOL>                output.write(`<STR_LIT>` + eol);<EOL>            });<EOL>        }<EOL>        if (options.types) {<EOL>            options.types.forEach(function (type: string) {<EOL>                sendMessage(`<STR_LIT>`);<EOL>                output.write(`<STR_LIT>` + eol);<EOL>            });<EOL>        }<EOL>        sendMessage('<STR_LIT>');<EOL>        let mainExportDeclaration = false;<EOL>        let mainExportAssignment = false;<EOL>        let foundMain = false;<EOL>        program.getSourceFiles().forEach(function (sourceFile) {<EOL>            processTree(sourceFile, function (node) {<EOL>                if (isNodeKindModuleDeclaration(node)) {<EOL>                    const name = node.name;<EOL>                    if (isNodeKindStringLiteral(name)) {<EOL>                        declaredExternalModules.push(name.text);<EOL>                    }<EOL>                }<EOL>                return null;<EOL>            });<EOL>        });<EOL>        program.getSourceFiles().some(function (sourceFile) {<EOL>            <EOL>            <EOL>            if (pathUtil.normalize(sourceFile.fileName).indexOf(baseDir) !== <NUM_LIT>) {<EOL>                return;<EOL>            }<EOL>            if (excludesMap[filenameToMid(pathUtil.normalize(sourceFile.fileName))]) {<EOL>                return;<EOL>            }<EOL>            sendMessage(`<STR_LIT>`);<EOL>            <EOL>            if (sourceFile.fileName.slice(-DTSLEN) === '<STR_LIT>') {<EOL>                writeDeclaration(sourceFile, false);<EOL>                return;<EOL>            }<EOL>            <EOL>            if (options.main && options.main === (options.prefix + filenameToMid(sourceFile.fileName.slice(baseDir.length, -<NUM_LIT>)))) {<EOL>                foundMain = true;<EOL>                ts.forEachChild(sourceFile, function (node: ts.Node) {<EOL>                    mainExportDeclaration = mainExportDeclaration || isNodeKindExportDeclaration(node);<EOL>                    mainExportAssignment = mainExportAssignment || isNodeKindExportAssignment(node);<EOL>                });<EOL>            }<EOL>            const emitOutput = program.emit(sourceFile, writeFile);<EOL>            if (emitOutput.emitSkipped || emitOutput.diagnostics.length > <NUM_LIT>) {<EOL>                reject(getError(emitOutput.diagnostics<EOL>                    .concat(program.getSemanticDiagnostics(sourceFile))<EOL>                    .concat(program.getSyntacticDiagnostics(sourceFile))<EOL>                    .concat(program.getDeclarationDiagnostics(sourceFile))));<EOL>                return true;<EOL>            }<EOL>        });<EOL>        if (options.main && !foundMain) {<EOL>            throw new Error(`<STR_LIT>`);<EOL>        }<EOL>        if (options.main) {<EOL>            output.write(`<STR_LIT>` + eol + indent);<EOL>            if (compilerOptions.target >= ts.ScriptTarget.ES2015) {<EOL>                if (mainExportAssignment) {<EOL>                    output.write(`<STR_LIT>` + eol + indent);<EOL>                }<EOL>                if (mainExportDeclaration) {<EOL>                    output.write(`<STR_LIT>` + eol);<EOL>                }<EOL>            }<EOL>            else {<EOL>                output.write(`<STR_LIT>` + eol + indent);<EOL>                output.write('<STR_LIT>' + eol);<EOL>            }<EOL>            output.write('<STR_LIT>' + eol);<EOL>            sendMessage(`<STR_LIT>`);<EOL>        }<EOL>        sendMessage(`<STR_LIT>`);<EOL>        output.end();<EOL>    });<EOL>    function writeDeclaration(declarationFile: ts.SourceFile, isOutput: boolean) {<EOL>        <EOL>        const filename = pathUtil.resolve(declarationFile.fileName);<EOL>        <EOL>        <EOL>        <EOL>        <EOL>        <EOL>        const outputDir = (isOutput && Boolean(outDir)) ? pathUtil.resolve(outDir) : baseDir;<EOL>        const sourceModuleId = filenameToMid(filename.slice(outputDir.length + <NUM_LIT>, -DTSLEN));<EOL>        const currentModuleId = filenameToMid(filename.slice(outputDir.length + <NUM_LIT>, -DTSLEN));<EOL>        function resolveModuleImport(moduleId: string): string {<EOL>            const isDeclaredExternalModule: boolean = declaredExternalModules.indexOf(moduleId) !== -<NUM_LIT>;<EOL>            let resolved: string;<EOL>            if (options.resolveModuleImport) {<EOL>                resolved = options.resolveModuleImport({<EOL>                    importedModuleId: moduleId,<EOL>                    currentModuleId: currentModuleId,<EOL>                    isDeclaredExternalModule: isDeclaredExternalModule<EOL>                });<EOL>            }<EOL>            if (!resolved) {<EOL>                <EOL>                if (moduleId.charAt(<NUM_LIT>) === '<STR_LIT>') {<EOL>                    resolved = filenameToMid(pathUtil.join(pathUtil.dirname(sourceModuleId), moduleId));<EOL>                }<EOL>                else {<EOL>                    resolved = moduleId;<EOL>                }<EOL>                <EOL>                <EOL>                <EOL>                <EOL>                <EOL>                <EOL>                <EOL>                if (Boolean(options.prefix) && !isDeclaredExternalModule) {<EOL>                    resolved = `<STR_LIT>`;<EOL>                }<EOL>            }<EOL>            return resolved;<EOL>        }<EOL>        <EOL>        if ((<any>declarationFile).externalModuleIndicator) {<EOL>            let resolvedModuleId: string = sourceModuleId;<EOL>            if (options.resolveModuleId) {<EOL>                const resolveModuleIdResult: string = options.resolveModuleId({<EOL>                    currentModuleId: currentModuleId<EOL>                });<EOL>                if (resolveModuleIdResult) {<EOL>                    resolvedModuleId = resolveModuleIdResult;<EOL>                }<EOL>                else if (options.","gt":"prefix) {"}
{"input":"<s> export default function generate(options: Options): Promise<void> {<EOL>    if (Boolean(options.main) !== Boolean(options.name)) {<EOL>        if (Boolean(options.name)) {<EOL>            <EOL>            <EOL>            <EOL>            <EOL>            throw new Error(`<STR_LIT>`);<EOL>        }<EOL>        else {<EOL>            throw new Error('<STR_LIT>');<EOL>        }<EOL>    }<EOL>    const noop = function (message?: any, ...optionalParams: any[]): void { };<EOL>    const sendMessage = options.sendMessage || noop;<EOL>    const verboseMessage = options.verbose ? sendMessage : noop;<EOL>    let compilerOptions: ts.CompilerOptions = {};<EOL>    let files: string[] = options.files;<EOL>    <EOL>    if (options.project || !options.files || options.files.length === <NUM_LIT>) {<EOL>        verboseMessage(`<STR_LIT>`);<EOL>        <EOL>        <EOL>        <EOL>        <EOL>        let tsconfigFilename: string;<EOL>        if (Boolean(options.project)) {<EOL>            if (fs.lstatSync(options.project).isDirectory()) {<EOL>                tsconfigFilename = pathUtil.join(options.project, '<STR_LIT>');<EOL>            }<EOL>            else {<EOL>                <EOL>                tsconfigFilename = options.project;<EOL>            }<EOL>        }<EOL>        else {<EOL>            tsconfigFilename = pathUtil.join(options.baseDir, '<STR_LIT>');<EOL>        }<EOL>        if (fs.existsSync(tsconfigFilename)) {<EOL>            verboseMessage(`<STR_LIT>`);<EOL>            [files, compilerOptions] = getTSConfig(options, tsconfigFilename);<EOL>        }<EOL>        else {<EOL>            sendMessage(`<STR_LIT>`);<EOL>            return new Promise<void>(function (resolve, reject) {<EOL>                reject(new SyntaxError('<STR_LIT>'));<EOL>            });<EOL>        }<EOL>    }<EOL>    const eol = options.eol || os.EOL;<EOL>    const nonEmptyLineStart = new RegExp(eol + '<STR_LIT>' + eol + '<STR_LIT>', '<STR_LIT>');<EOL>    const indent = options.indent === undefined ? '<STR_LIT>' : options.indent;<EOL>    <EOL>    <EOL>    compilerOptions.declaration = true;<EOL>    compilerOptions.target = compilerOptions.target || ts.ScriptTarget.Latest; <EOL>    compilerOptions.moduleResolution = compilerOptions.moduleResolution || options.moduleResolution;<EOL>    compilerOptions.outDir = compilerOptions.outDir || options.outDir;<EOL>    <EOL>    const baseDir = pathUtil.resolve(compilerOptions.rootDir || options.project || options.baseDir);<EOL>    const outDir = compilerOptions.outDir;<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    const filenames = getFilenames(baseDir, files);<EOL>    verboseMessage('<STR_LIT>');<EOL>    filenames.forEach(name => { verboseMessage('<STR_LIT>' + name); });<EOL>    const excludesMap: {<EOL>        [filename: string]: boolean;<EOL>    } = {};<EOL>    options.exclude = options.exclude || ['<STR_LIT>'];<EOL>    options.exclude && options.exclude.forEach(function (filename) {<EOL>        glob.sync(filename).forEach(function (globFileName) {<EOL>            excludesMap[filenameToMid(pathUtil.resolve(baseDir, globFileName))] = true;<EOL>        });<EOL>    });<EOL>    if (options.exclude) {<EOL>        verboseMessage('<STR_LIT>');<EOL>        options.exclude.forEach(name => { verboseMessage('<STR_LIT>' + name); });<EOL>    }<EOL>    mkdirp.sync(pathUtil.dirname(options.out));<EOL>    <EOL>    const output = fs.createWriteStream(options.out, <any>{ mode: parseInt('<STR_LIT>', <NUM_LIT>) });<EOL>    const host = ts.createCompilerHost(compilerOptions);<EOL>    const program = ts.createProgram(filenames, compilerOptions, host);<EOL>    function writeFile(filename: string, data: string, writeByteOrderMark: boolean) {<EOL>        <EOL>        if (filename.slice(-DTSLEN) !== '<STR_LIT>') {<EOL>            return;<EOL>        }<EOL>        writeDeclaration(ts.createSourceFile(filename, data, compilerOptions.target, true), true);<EOL>    }<EOL>    let declaredExternalModules: string[] = [];<EOL>    return new Promise<void>(function (resolve, reject) {<EOL>        output.on('<STR_LIT>', () => { resolve(undefined); });<EOL>        output.on('<STR_LIT>', reject);<EOL>        if (options.externs) {<EOL>            options.externs.forEach(function (path: string) {<EOL>                sendMessage(`<STR_LIT>`);<EOL>                output.write(`<STR_LIT>` + eol);<EOL>            });<EOL>        }<EOL>        if (options.types) {<EOL>            options.types.forEach(function (type: string) {<EOL>                sendMessage(`<STR_LIT>`);<EOL>                output.write(`<STR_LIT>` + eol);<EOL>            });<EOL>        }<EOL>        sendMessage('<STR_LIT>');<EOL>        let mainExportDeclaration = false;<EOL>        let mainExportAssignment = false;<EOL>        let foundMain = false;<EOL>        program.getSourceFiles().forEach(function (sourceFile) {<EOL>            processTree(sourceFile, function (node) {<EOL>                if (isNodeKindModuleDeclaration(node)) {<EOL>                    const name = node.name;<EOL>                    if (isNodeKindStringLiteral(name)) {<EOL>                        declaredExternalModules.push(name.text);<EOL>                    }<EOL>                }<EOL>                return null;<EOL>            });<EOL>        });<EOL>        program.getSourceFiles().some(function (sourceFile) {<EOL>            <EOL>            <EOL>            if (pathUtil.normalize(sourceFile.fileName).indexOf(baseDir) !== <NUM_LIT>) {<EOL>                return;<EOL>            }<EOL>            if (excludesMap[filenameToMid(pathUtil.normalize(sourceFile.fileName))]) {<EOL>                return;<EOL>            }<EOL>            sendMessage(`<STR_LIT>`);<EOL>            <EOL>            if (sourceFile.fileName.slice(-DTSLEN) === '<STR_LIT>') {<EOL>                writeDeclaration(sourceFile, false);<EOL>                return;<EOL>            }<EOL>            <EOL>            if (options.main && options.main === (options.prefix + filenameToMid(sourceFile.fileName.slice(baseDir.length, -<NUM_LIT>)))) {<EOL>                foundMain = true;<EOL>                ts.forEachChild(sourceFile, function (node: ts.Node) {<EOL>                    mainExportDeclaration = mainExportDeclaration || isNodeKindExportDeclaration(node);<EOL>                    mainExportAssignment = mainExportAssignment || isNodeKindExportAssignment(node);<EOL>                });<EOL>            }<EOL>            const emitOutput = program.emit(sourceFile, writeFile);<EOL>            if (emitOutput.emitSkipped || emitOutput.diagnostics.length > <NUM_LIT>) {<EOL>                reject(getError(emitOutput.diagnostics<EOL>                    .concat(program.getSemanticDiagnostics(sourceFile))<EOL>                    .concat(program.getSyntacticDiagnostics(sourceFile))<EOL>                    .concat(program.getDeclarationDiagnostics(sourceFile))));<EOL>                return true;<EOL>            }<EOL>        });<EOL>        if (options.main && !foundMain) {<EOL>            throw new Error(`<STR_LIT>`);<EOL>        }<EOL>        if (options.main) {<EOL>            output.write(`<STR_LIT>` + eol + indent);<EOL>            if (compilerOptions.target >= ts.ScriptTarget.ES2015) {<EOL>                if (mainExportAssignment) {<EOL>                    output.write(`<STR_LIT>` + eol + indent);<EOL>                }<EOL>                if (mainExportDeclaration) {<EOL>                    output.write(`<STR_LIT>` + eol);<EOL>                }<EOL>            }<EOL>            else {<EOL>                output.write(`<STR_LIT>` + eol + indent);<EOL>                output.write('<STR_LIT>' + eol);<EOL>            }<EOL>            output.write('<STR_LIT>' + eol);<EOL>            sendMessage(`<STR_LIT>`);<EOL>        }<EOL>        sendMessage(`<STR_LIT>`);<EOL>        output.end();<EOL>    });<EOL>    function writeDeclaration(declarationFile: ts.SourceFile, isOutput: boolean) {<EOL>        <EOL>        const filename = pathUtil.resolve(declarationFile.fileName);<EOL>        <EOL>        <EOL>        <EOL>        <EOL>        <EOL>        const outputDir = (isOutput && Boolean(outDir)) ? pathUtil.resolve(outDir) : baseDir;<EOL>        const sourceModuleId = filenameToMid(filename.slice(outputDir.length + <NUM_LIT>, -DTSLEN));<EOL>        const currentModuleId = filenameToMid(filename.slice(outputDir.length + <NUM_LIT>, -DTSLEN));<EOL>        function resolveModuleImport(moduleId: string): string {<EOL>            const isDeclaredExternalModule: boolean = declaredExternalModules.indexOf(moduleId) !== -<NUM_LIT>;<EOL>            let resolved: string;<EOL>            if (options.resolveModuleImport) {<EOL>                resolved = options.resolveModuleImport({<EOL>                    importedModuleId: moduleId,<EOL>                    currentModuleId: currentModuleId,<EOL>                    isDeclaredExternalModule: isDeclaredExternalModule<EOL>                });<EOL>            }<EOL>            if (!resolved) {<EOL>                <EOL>                if (moduleId.charAt(<NUM_LIT>) === '<STR_LIT>') {<EOL>                    resolved = filenameToMid(pathUtil.join(pathUtil.dirname(sourceModuleId), moduleId));<EOL>                }<EOL>                else {<EOL>                    resolved = moduleId;<EOL>                }<EOL>                <EOL>                <EOL>                <EOL>                <EOL>                <EOL>                <EOL>                <EOL>                if (Boolean(options.prefix) && !isDeclaredExternalModule) {<EOL>                    resolved = `<STR_LIT>`;<EOL>                }<EOL>            }<EOL>            return resolved;<EOL>        }<EOL>        <EOL>        if ((<any>declarationFile).externalModuleIndicator) {<EOL>            let resolvedModuleId: string = sourceModuleId;<EOL>            if (options.resolveModuleId) {<EOL>                const resolveModuleIdResult: string = options.resolveModuleId({<EOL>                    currentModuleId: currentModuleId<EOL>                });<EOL>                if (resolveModuleIdResult) {<EOL>                    resolvedModuleId = resolveModuleIdResult;<EOL>                }<EOL>                else if (options.prefix) {<EOL>","gt":"resolvedModuleId = `<STR_LIT>`;"}
{"input":"<s> export default function generate(options: Options): Promise<void> {<EOL>    if (Boolean(options.main) !== Boolean(options.name)) {<EOL>        if (Boolean(options.name)) {<EOL>            <EOL>            <EOL>            <EOL>            <EOL>            throw new Error(`<STR_LIT>`);<EOL>        }<EOL>        else {<EOL>            throw new Error('<STR_LIT>');<EOL>        }<EOL>    }<EOL>    const noop = function (message?: any, ...optionalParams: any[]): void { };<EOL>    const sendMessage = options.sendMessage || noop;<EOL>    const verboseMessage = options.verbose ? sendMessage : noop;<EOL>    let compilerOptions: ts.CompilerOptions = {};<EOL>    let files: string[] = options.files;<EOL>    <EOL>    if (options.project || !options.files || options.files.length === <NUM_LIT>) {<EOL>        verboseMessage(`<STR_LIT>`);<EOL>        <EOL>        <EOL>        <EOL>        <EOL>        let tsconfigFilename: string;<EOL>        if (Boolean(options.project)) {<EOL>            if (fs.lstatSync(options.project).isDirectory()) {<EOL>                tsconfigFilename = pathUtil.join(options.project, '<STR_LIT>');<EOL>            }<EOL>            else {<EOL>                <EOL>                tsconfigFilename = options.project;<EOL>            }<EOL>        }<EOL>        else {<EOL>            tsconfigFilename = pathUtil.join(options.baseDir, '<STR_LIT>');<EOL>        }<EOL>        if (fs.existsSync(tsconfigFilename)) {<EOL>            verboseMessage(`<STR_LIT>`);<EOL>            [files, compilerOptions] = getTSConfig(options, tsconfigFilename);<EOL>        }<EOL>        else {<EOL>            sendMessage(`<STR_LIT>`);<EOL>            return new Promise<void>(function (resolve, reject) {<EOL>                reject(new SyntaxError('<STR_LIT>'));<EOL>            });<EOL>        }<EOL>    }<EOL>    const eol = options.eol || os.EOL;<EOL>    const nonEmptyLineStart = new RegExp(eol + '<STR_LIT>' + eol + '<STR_LIT>', '<STR_LIT>');<EOL>    const indent = options.indent === undefined ? '<STR_LIT>' : options.indent;<EOL>    <EOL>    <EOL>    compilerOptions.declaration = true;<EOL>    compilerOptions.target = compilerOptions.target || ts.ScriptTarget.Latest; <EOL>    compilerOptions.moduleResolution = compilerOptions.moduleResolution || options.moduleResolution;<EOL>    compilerOptions.outDir = compilerOptions.outDir || options.outDir;<EOL>    <EOL>    const baseDir = pathUtil.resolve(compilerOptions.rootDir || options.project || options.baseDir);<EOL>    const outDir = compilerOptions.outDir;<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    const filenames = getFilenames(baseDir, files);<EOL>    verboseMessage('<STR_LIT>');<EOL>    filenames.forEach(name => { verboseMessage('<STR_LIT>' + name); });<EOL>    const excludesMap: {<EOL>        [filename: string]: boolean;<EOL>    } = {};<EOL>    options.exclude = options.exclude || ['<STR_LIT>'];<EOL>    options.exclude && options.exclude.forEach(function (filename) {<EOL>        glob.sync(filename).forEach(function (globFileName) {<EOL>            excludesMap[filenameToMid(pathUtil.resolve(baseDir, globFileName))] = true;<EOL>        });<EOL>    });<EOL>    if (options.exclude) {<EOL>        verboseMessage('<STR_LIT>');<EOL>        options.exclude.forEach(name => { verboseMessage('<STR_LIT>' + name); });<EOL>    }<EOL>    mkdirp.sync(pathUtil.dirname(options.out));<EOL>    <EOL>    const output = fs.createWriteStream(options.out, <any>{ mode: parseInt('<STR_LIT>', <NUM_LIT>) });<EOL>    const host = ts.createCompilerHost(compilerOptions);<EOL>    const program = ts.createProgram(filenames, compilerOptions, host);<EOL>    function writeFile(filename: string, data: string, writeByteOrderMark: boolean) {<EOL>        <EOL>        if (filename.slice(-DTSLEN) !== '<STR_LIT>') {<EOL>            return;<EOL>        }<EOL>        writeDeclaration(ts.createSourceFile(filename, data, compilerOptions.target, true), true);<EOL>    }<EOL>    let declaredExternalModules: string[] = [];<EOL>    return new Promise<void>(function (resolve, reject) {<EOL>        output.on('<STR_LIT>', () => { resolve(undefined); });<EOL>        output.on('<STR_LIT>', reject);<EOL>        if (options.externs) {<EOL>            options.externs.forEach(function (path: string) {<EOL>                sendMessage(`<STR_LIT>`);<EOL>                output.write(`<STR_LIT>` + eol);<EOL>            });<EOL>        }<EOL>        if (options.types) {<EOL>            options.types.forEach(function (type: string) {<EOL>                sendMessage(`<STR_LIT>`);<EOL>                output.write(`<STR_LIT>` + eol);<EOL>            });<EOL>        }<EOL>        sendMessage('<STR_LIT>');<EOL>        let mainExportDeclaration = false;<EOL>        let mainExportAssignment = false;<EOL>        let foundMain = false;<EOL>        program.getSourceFiles().forEach(function (sourceFile) {<EOL>            processTree(sourceFile, function (node) {<EOL>                if (isNodeKindModuleDeclaration(node)) {<EOL>                    const name = node.name;<EOL>                    if (isNodeKindStringLiteral(name)) {<EOL>                        declaredExternalModules.push(name.text);<EOL>                    }<EOL>                }<EOL>                return null;<EOL>            });<EOL>        });<EOL>        program.getSourceFiles().some(function (sourceFile) {<EOL>            <EOL>            <EOL>            if (pathUtil.normalize(sourceFile.fileName).indexOf(baseDir) !== <NUM_LIT>) {<EOL>                return;<EOL>            }<EOL>            if (excludesMap[filenameToMid(pathUtil.normalize(sourceFile.fileName))]) {<EOL>                return;<EOL>            }<EOL>            sendMessage(`<STR_LIT>`);<EOL>            <EOL>            if (sourceFile.fileName.slice(-DTSLEN) === '<STR_LIT>') {<EOL>                writeDeclaration(sourceFile, false);<EOL>                return;<EOL>            }<EOL>            <EOL>            if (options.main && options.main === (options.prefix + filenameToMid(sourceFile.fileName.slice(baseDir.length, -<NUM_LIT>)))) {<EOL>                foundMain = true;<EOL>                ts.forEachChild(sourceFile, function (node: ts.Node) {<EOL>                    mainExportDeclaration = mainExportDeclaration || isNodeKindExportDeclaration(node);<EOL>                    mainExportAssignment = mainExportAssignment || isNodeKindExportAssignment(node);<EOL>                });<EOL>            }<EOL>            const emitOutput = program.emit(sourceFile, writeFile);<EOL>            if (emitOutput.emitSkipped || emitOutput.diagnostics.length > <NUM_LIT>) {<EOL>                reject(getError(emitOutput.diagnostics<EOL>                    .concat(program.getSemanticDiagnostics(sourceFile))<EOL>                    .concat(program.getSyntacticDiagnostics(sourceFile))<EOL>                    .concat(program.getDeclarationDiagnostics(sourceFile))));<EOL>                return true;<EOL>            }<EOL>        });<EOL>        if (options.main && !foundMain) {<EOL>            throw new Error(`<STR_LIT>`);<EOL>        }<EOL>        if (options.main) {<EOL>            output.write(`<STR_LIT>` + eol + indent);<EOL>            if (compilerOptions.target >= ts.ScriptTarget.ES2015) {<EOL>                if (mainExportAssignment) {<EOL>                    output.write(`<STR_LIT>` + eol + indent);<EOL>                }<EOL>                if (mainExportDeclaration) {<EOL>                    output.write(`<STR_LIT>` + eol);<EOL>                }<EOL>            }<EOL>            else {<EOL>                output.write(`<STR_LIT>` + eol + indent);<EOL>                output.write('<STR_LIT>' + eol);<EOL>            }<EOL>            output.write('<STR_LIT>' + eol);<EOL>            sendMessage(`<STR_LIT>`);<EOL>        }<EOL>        sendMessage(`<STR_LIT>`);<EOL>        output.end();<EOL>    });<EOL>    function writeDeclaration(declarationFile: ts.SourceFile, isOutput: boolean) {<EOL>        <EOL>        const filename = pathUtil.resolve(declarationFile.fileName);<EOL>        <EOL>        <EOL>        <EOL>        <EOL>        <EOL>        const outputDir = (isOutput && Boolean(outDir)) ? pathUtil.resolve(outDir) : baseDir;<EOL>        const sourceModuleId = filenameToMid(filename.slice(outputDir.length + <NUM_LIT>, -DTSLEN));<EOL>        const currentModuleId = filenameToMid(filename.slice(outputDir.length + <NUM_LIT>, -DTSLEN));<EOL>        function resolveModuleImport(moduleId: string): string {<EOL>            const isDeclaredExternalModule: boolean = declaredExternalModules.indexOf(moduleId) !== -<NUM_LIT>;<EOL>            let resolved: string;<EOL>            if (options.resolveModuleImport) {<EOL>                resolved = options.resolveModuleImport({<EOL>                    importedModuleId: moduleId,<EOL>                    currentModuleId: currentModuleId,<EOL>                    isDeclaredExternalModule: isDeclaredExternalModule<EOL>                });<EOL>            }<EOL>            if (!resolved) {<EOL>                <EOL>                if (moduleId.charAt(<NUM_LIT>) === '<STR_LIT>') {<EOL>                    resolved = filenameToMid(pathUtil.join(pathUtil.dirname(sourceModuleId), moduleId));<EOL>                }<EOL>                else {<EOL>                    resolved = moduleId;<EOL>                }<EOL>                <EOL>                <EOL>                <EOL>                <EOL>                <EOL>                <EOL>                <EOL>                if (Boolean(options.prefix) && !isDeclaredExternalModule) {<EOL>                    resolved = `<STR_LIT>`;<EOL>                }<EOL>            }<EOL>            return resolved;<EOL>        }<EOL>        <EOL>        if ((<any>declarationFile).externalModuleIndicator) {<EOL>            let resolvedModuleId: string = sourceModuleId;<EOL>            if (options.resolveModuleId) {<EOL>                const resolveModuleIdResult: string = options.resolveModuleId({<EOL>                    currentModuleId: currentModuleId<EOL>                });<EOL>                if (resolveModuleIdResult) {<EOL>                    resolvedModuleId = resolveModuleIdResult;<EOL>                }<EOL>                else if (options.prefix) {<EOL>                    resolvedModuleId = `<STR_LIT>`;<EOL>                }<EOL>            }<EOL>            else","gt":"if (options.prefix) {"}
{"input":"<s> export default function generate(options: Options): Promise<void> {<EOL>    if (Boolean(options.main) !== Boolean(options.name)) {<EOL>        if (Boolean(options.name)) {<EOL>            <EOL>            <EOL>            <EOL>            <EOL>            throw new Error(`<STR_LIT>`);<EOL>        }<EOL>        else {<EOL>            throw new Error('<STR_LIT>');<EOL>        }<EOL>    }<EOL>    const noop = function (message?: any, ...optionalParams: any[]): void { };<EOL>    const sendMessage = options.sendMessage || noop;<EOL>    const verboseMessage = options.verbose ? sendMessage : noop;<EOL>    let compilerOptions: ts.CompilerOptions = {};<EOL>    let files: string[] = options.files;<EOL>    <EOL>    if (options.project || !options.files || options.files.length === <NUM_LIT>) {<EOL>        verboseMessage(`<STR_LIT>`);<EOL>        <EOL>        <EOL>        <EOL>        <EOL>        let tsconfigFilename: string;<EOL>        if (Boolean(options.project)) {<EOL>            if (fs.lstatSync(options.project).isDirectory()) {<EOL>                tsconfigFilename = pathUtil.join(options.project, '<STR_LIT>');<EOL>            }<EOL>            else {<EOL>                <EOL>                tsconfigFilename = options.project;<EOL>            }<EOL>        }<EOL>        else {<EOL>            tsconfigFilename = pathUtil.join(options.baseDir, '<STR_LIT>');<EOL>        }<EOL>        if (fs.existsSync(tsconfigFilename)) {<EOL>            verboseMessage(`<STR_LIT>`);<EOL>            [files, compilerOptions] = getTSConfig(options, tsconfigFilename);<EOL>        }<EOL>        else {<EOL>            sendMessage(`<STR_LIT>`);<EOL>            return new Promise<void>(function (resolve, reject) {<EOL>                reject(new SyntaxError('<STR_LIT>'));<EOL>            });<EOL>        }<EOL>    }<EOL>    const eol = options.eol || os.EOL;<EOL>    const nonEmptyLineStart = new RegExp(eol + '<STR_LIT>' + eol + '<STR_LIT>', '<STR_LIT>');<EOL>    const indent = options.indent === undefined ? '<STR_LIT>' : options.indent;<EOL>    <EOL>    <EOL>    compilerOptions.declaration = true;<EOL>    compilerOptions.target = compilerOptions.target || ts.ScriptTarget.Latest; <EOL>    compilerOptions.moduleResolution = compilerOptions.moduleResolution || options.moduleResolution;<EOL>    compilerOptions.outDir = compilerOptions.outDir || options.outDir;<EOL>    <EOL>    const baseDir = pathUtil.resolve(compilerOptions.rootDir || options.project || options.baseDir);<EOL>    const outDir = compilerOptions.outDir;<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    verboseMessage(`<STR_LIT>`);<EOL>    const filenames = getFilenames(baseDir, files);<EOL>    verboseMessage('<STR_LIT>');<EOL>    filenames.forEach(name => { verboseMessage('<STR_LIT>' + name); });<EOL>    const excludesMap: {<EOL>        [filename: string]: boolean;<EOL>    } = {};<EOL>    options.exclude = options.exclude || ['<STR_LIT>'];<EOL>    options.exclude && options.exclude.forEach(function (filename) {<EOL>        glob.sync(filename).forEach(function (globFileName) {<EOL>            excludesMap[filenameToMid(pathUtil.resolve(baseDir, globFileName))] = true;<EOL>        });<EOL>    });<EOL>    if (options.exclude) {<EOL>        verboseMessage('<STR_LIT>');<EOL>        options.exclude.forEach(name => { verboseMessage('<STR_LIT>' + name); });<EOL>    }<EOL>    mkdirp.sync(pathUtil.dirname(options.out));<EOL>    <EOL>    const output = fs.createWriteStream(options.out, <any>{ mode: parseInt('<STR_LIT>', <NUM_LIT>) });<EOL>    const host = ts.createCompilerHost(compilerOptions);<EOL>    const program = ts.createProgram(filenames, compilerOptions, host);<EOL>    function writeFile(filename: string, data: string, writeByteOrderMark: boolean) {<EOL>        <EOL>        if (filename.slice(-DTSLEN) !== '<STR_LIT>') {<EOL>            return;<EOL>        }<EOL>        writeDeclaration(ts.createSourceFile(filename, data, compilerOptions.target, true), true);<EOL>    }<EOL>    let declaredExternalModules: string[] = [];<EOL>    return new Promise<void>(function (resolve, reject) {<EOL>        output.on('<STR_LIT>', () => { resolve(undefined); });<EOL>        output.on('<STR_LIT>', reject);<EOL>        if (options.externs) {<EOL>            options.externs.forEach(function (path: string) {<EOL>                sendMessage(`<STR_LIT>`);<EOL>                output.write(`<STR_LIT>` + eol);<EOL>            });<EOL>        }<EOL>        if (options.types) {<EOL>            options.types.forEach(function (type: string) {<EOL>                sendMessage(`<STR_LIT>`);<EOL>                output.write(`<STR_LIT>` + eol);<EOL>            });<EOL>        }<EOL>        sendMessage('<STR_LIT>');<EOL>        let mainExportDeclaration = false;<EOL>        let mainExportAssignment = false;<EOL>        let foundMain = false;<EOL>        program.getSourceFiles().forEach(function (sourceFile) {<EOL>            processTree(sourceFile, function (node) {<EOL>                if (isNodeKindModuleDeclaration(node)) {<EOL>                    const name = node.name;<EOL>                    if (isNodeKindStringLiteral(name)) {<EOL>                        declaredExternalModules.push(name.text);<EOL>                    }<EOL>                }<EOL>                return null;<EOL>            });<EOL>        });<EOL>        program.getSourceFiles().some(function (sourceFile) {<EOL>            <EOL>            <EOL>            if (pathUtil.normalize(sourceFile.fileName).indexOf(baseDir) !== <NUM_LIT>) {<EOL>                return;<EOL>            }<EOL>            if (excludesMap[filenameToMid(pathUtil.normalize(sourceFile.fileName))]) {<EOL>                return;<EOL>            }<EOL>            sendMessage(`<STR_LIT>`);<EOL>            <EOL>            if (sourceFile.fileName.slice(-DTSLEN) === '<STR_LIT>') {<EOL>                writeDeclaration(sourceFile, false);<EOL>                return;<EOL>            }<EOL>            <EOL>            if (options.main && options.main === (options.prefix + filenameToMid(sourceFile.fileName.slice(baseDir.length, -<NUM_LIT>)))) {<EOL>                foundMain = true;<EOL>                ts.forEachChild(sourceFile, function (node: ts.Node) {<EOL>                    mainExportDeclaration = mainExportDeclaration || isNodeKindExportDeclaration(node);<EOL>                    mainExportAssignment = mainExportAssignment || isNodeKindExportAssignment(node);<EOL>                });<EOL>            }<EOL>            const emitOutput = program.emit(sourceFile, writeFile);<EOL>            if (emitOutput.emitSkipped || emitOutput.diagnostics.length > <NUM_LIT>) {<EOL>                reject(getError(emitOutput.diagnostics<EOL>                    .concat(program.getSemanticDiagnostics(sourceFile))<EOL>                    .concat(program.getSyntacticDiagnostics(sourceFile))<EOL>                    .concat(program.getDeclarationDiagnostics(sourceFile))));<EOL>                return true;<EOL>            }<EOL>        });<EOL>        if (options.main && !foundMain) {<EOL>            throw new Error(`<STR_LIT>`);<EOL>        }<EOL>        if (options.main) {<EOL>            output.write(`<STR_LIT>` + eol + indent);<EOL>            if (compilerOptions.target >= ts.ScriptTarget.ES2015) {<EOL>                if (mainExportAssignment) {<EOL>                    output.write(`<STR_LIT>` + eol + indent);<EOL>                }<EOL>                if (mainExportDeclaration) {<EOL>                    output.write(`<STR_LIT>` + eol);<EOL>                }<EOL>            }<EOL>            else {<EOL>                output.write(`<STR_LIT>` + eol + indent);<EOL>                output.write('<STR_LIT>' + eol);<EOL>            }<EOL>            output.write('<STR_LIT>' + eol);<EOL>            sendMessage(`<STR_LIT>`);<EOL>        }<EOL>        sendMessage(`<STR_LIT>`);<EOL>        output.end();<EOL>    });<EOL>    function writeDeclaration(declarationFile: ts.SourceFile, isOutput: boolean) {<EOL>        <EOL>        const filename = pathUtil.resolve(declarationFile.fileName);<EOL>        <EOL>        <EOL>        <EOL>        <EOL>        <EOL>        const outputDir = (isOutput && Boolean(outDir)) ? pathUtil.resolve(outDir) : baseDir;<EOL>        const sourceModuleId = filenameToMid(filename.slice(outputDir.length + <NUM_LIT>, -DTSLEN));<EOL>        const currentModuleId = filenameToMid(filename.slice(outputDir.length + <NUM_LIT>, -DTSLEN));<EOL>        function resolveModuleImport(moduleId: string): string {<EOL>            const isDeclaredExternalModule: boolean = declaredExternalModules.indexOf(moduleId) !== -<NUM_LIT>;<EOL>            let resolved: string;<EOL>            if (options.resolveModuleImport) {<EOL>                resolved = options.resolveModuleImport({<EOL>                    importedModuleId: moduleId,<EOL>                    currentModuleId: currentModuleId,<EOL>                    isDeclaredExternalModule: isDeclaredExternalModule<EOL>                });<EOL>            }<EOL>            if (!resolved) {<EOL>                <EOL>                if (moduleId.charAt(<NUM_LIT>) === '<STR_LIT>') {<EOL>                    resolved = filenameToMid(pathUtil.join(pathUtil.dirname(sourceModuleId), moduleId));<EOL>                }<EOL>                else {<EOL>                    resolved = moduleId;<EOL>                }<EOL>                <EOL>                <EOL>                <EOL>                <EOL>                <EOL>                <EOL>                <EOL>                if (Boolean(options.prefix) && !isDeclaredExternalModule) {<EOL>                    resolved = `<STR_LIT>`;<EOL>                }<EOL>            }<EOL>            return resolved;<EOL>        }<EOL>        <EOL>        if ((<any>declarationFile).externalModuleIndicator) {<EOL>            let resolvedModuleId: string = sourceModuleId;<EOL>            if (options.resolveModuleId) {<EOL>                const resolveModuleIdResult: string = options.resolveModuleId({<EOL>                    currentModuleId: currentModuleId<EOL>                });<EOL>                if (resolveModuleIdResult) {<EOL>                    resolvedModuleId = resolveModuleIdResult;<EOL>                }<EOL>                else if (options.prefix) {<EOL>                    resolvedModuleId = `<STR_LIT>`;<EOL>                }<EOL>            }<EOL>            else if (options.prefix) {<EOL>                resolvedModuleId = `<STR_LIT>`;<EOL>            }<EOL>            output.write('<STR_LIT>' + resolvedModuleId + '<STR_LIT>' + eol +","gt":"indent);"}
{"input":"<s> export function bounds(parent: Simple.Element, first: Simple.Node, last: Simple.Node): ConcreteBounds {<EOL>","gt":"return new ConcreteBounds(parent, first, last);"}
{"input":"<s> /** @internal */<EOL>export default function ifHelper(params: any[]) {<EOL>    return params[<NUM_LIT>] ? params[<NUM_LIT>] :","gt":"params[<NUM_LIT>];"}
{"input":"<s> export function sourceMapConsumerToGenerator(sourceMapConsumer: SourceMapConsumer): SourceMapGenerator {<EOL>    return SourceMapGenerator.","gt":"fromSourceMap(sourceMapConsumer);"}
{"input":"<s> <EOL><EOL>export function timeout(milliseconds: number = <NUM_LIT>) {<EOL>    return function (target, key, descriptor) {<EOL>        var originalMethod = descriptor.value;<EOL>","gt":"descriptor.value = function (...args) {"}
{"input":"<s> export function blockStack() {<EOL>    let stack: number[] = [];<EOL>    return (id: number) => {<EOL>        if (stack.indexOf(id) > -<NUM_LIT>) {<EOL>","gt":"let close = `<STR_LIT>`;"}
{"input":"<s> export function blockStack() {<EOL>    let stack: number[] = [];<EOL>    return (id: number) => {<EOL>        if (stack.indexOf(id) > -<NUM_LIT>) {<EOL>            let close = `<STR_LIT>`;<EOL>            stack.pop();<EOL>            return close;<EOL>        }<EOL>        else {<EOL>            stack.push(id);<EOL>","gt":"return `<STR_LIT>`;"}
{"input":"<s> function isMarker(node: Simple.Node): boolean {<EOL>    return node.","gt":"nodeType === <NUM_LIT> && node.nodeValue === '<STR_LIT>';"}
{"input":"<s> export function getAssign(root: any) {<EOL>","gt":"return root.Object.assign || assignImpl;"}
{"input":"<s> function setFieldProperties(field: GraphQLField<any, any>, propertiesObj: Object) {<EOL>    Object.","gt":"keys(propertiesObj).forEach(propertyName => {"}
{"input":"<s> <EOL>function f() {<EOL>","gt":"var arguments;"}
{"input":"<s> function maybeCommentedOut(content: string) {<EOL>    return (content.indexOf(","gt":"'<STR_LIT>') > -<NUM_LIT> && content.indexOf('<STR_LIT>') > -<NUM_LIT>) ||"}
{"input":"<s> export default function render<T>(program: RuntimeProgram<T>, env: Environment, self: PathReference<Opaque>, dynamicScope: DynamicScope, builder: ElementBuilder, handle: number): TemplateIterator {<EOL>    let vm =","gt":"VM.initial(program, env, self, dynamicScope, builder, handle);"}
{"input":"<s> async function main(): Promise<void> {<EOL>    for (const secret of allSecrets) {<EOL>","gt":"console.log(`<STR_LIT>`);"}
{"input":"<s> function executeSubSelectedArray(field, result, execContext) {<EOL>    return Promise.all(result.map(item => {<EOL>        <EOL>        if (item === null) {<EOL>            return","gt":"null;"}
{"input":"<s> function compileWhile(e: Environment, b: B.Block): J.JStmt {<EOL>    var cond = compileExpression(e, b.getInputTargetBlock(\"<STR_LIT>\"));<EOL>    var","gt":"body = compileStatements(e, b.getInputTargetBlock(\"<STR_LIT>\"));"}
{"input":"<s> function installLibraryRequest(libraryName) {<EOL>    return {<EOL>        type:","gt":"INSTALL_LIBRARY_REQUEST,"}
{"input":"<s> export function debugRehydration(env: Environment, cursor: Cursor): ElementBuilder {<EOL>    return","gt":"DebugRehydrationBuilder.forInitialRender(env, cursor);"}
{"input":"<s> function isReadOnly(operation: Operation): boolean {<EOL>    switch (operation) {<EOL>        case Operation.Show:<EOL>        case","gt":"Operation.GetCommitTemplate:"}
{"input":"<s> function assertGuess(expectedInsertSpaces: boolean, expectedTabSize: number, text: string[], msg?: string): void {<EOL>    if (typeof expectedInsertSpaces === '<STR_LIT>') {<EOL>        <EOL>        if (typeof expectedTabSize === '<STR_LIT>') {<EOL>            <EOL>            testGuessIndentation(true, <NUM_LIT>,","gt":"true, <NUM_LIT>, text, msg);"}
{"input":"<s> function assertGuess(expectedInsertSpaces: boolean, expectedTabSize: number, text: string[], msg?: string): void {<EOL>    if (typeof expectedInsertSpaces === '<STR_LIT>') {<EOL>        <EOL>        if (typeof expectedTabSize === '<STR_LIT>') {<EOL>            <EOL>            testGuessIndentation(true, <NUM_LIT>, true, <NUM_LIT>, text, msg);<EOL>            testGuessIndentation(false, <NUM_LIT>, false, <NUM_LIT>, text, msg);<EOL>        }<EOL>","gt":"else {"}
{"input":"<s> function assertGuess(expectedInsertSpaces: boolean, expectedTabSize: number, text: string[], msg?: string): void {<EOL>    if (typeof expectedInsertSpaces === '<STR_LIT>') {<EOL>        <EOL>        if (typeof expectedTabSize === '<STR_LIT>') {<EOL>            <EOL>            testGuessIndentation(true, <NUM_LIT>, true, <NUM_LIT>, text, msg);<EOL>            testGuessIndentation(false, <NUM_LIT>, false, <NUM_LIT>, text, msg);<EOL>        }<EOL>        else {<EOL>            <EOL>            testGuessIndentation(true, <NUM_LIT>, true, expectedTabSize, text, msg);<EOL>            testGuessIndentation(false, <NUM_LIT>, false,","gt":"expectedTabSize, text, msg);"}
{"input":"<s> function assertGuess(expectedInsertSpaces: boolean, expectedTabSize: number, text: string[], msg?: string): void {<EOL>    if (typeof expectedInsertSpaces === '<STR_LIT>') {<EOL>        <EOL>        if (typeof expectedTabSize === '<STR_LIT>') {<EOL>            <EOL>            testGuessIndentation(true, <NUM_LIT>, true, <NUM_LIT>, text, msg);<EOL>            testGuessIndentation(false, <NUM_LIT>, false, <NUM_LIT>, text, msg);<EOL>        }<EOL>        else {<EOL>            <EOL>            testGuessIndentation(true, <NUM_LIT>, true, expectedTabSize, text, msg);<EOL>            testGuessIndentation(false, <NUM_LIT>, false, expectedTabSize, text, msg);<EOL>        }<EOL>    }<EOL>","gt":"else {"}
{"input":"<s> function isImmediate(value: Opaque): value is number | boolean | null | undefined {<EOL>    let type = typeof value;<EOL>    if (value === null || value === undefined)<EOL>        return true;<EOL>    switch (type) {<EOL>        case '<STR_LIT>':<EOL>","gt":"case '<STR_LIT>':"}
{"input":"<s> function isImmediate(value: Opaque): value is number | boolean | null | undefined {<EOL>    let type = typeof value;<EOL>    if (value === null || value === undefined)<EOL>        return true;<EOL>    switch (type) {<EOL>        case '<STR_LIT>':<EOL>        case '<STR_LIT>':<EOL>            return true;<EOL>        case '<STR_LIT>':<EOL>            <EOL>            if (value as number % <NUM_LIT> !== <NUM_LIT>)<EOL>","gt":"return false;"}
{"input":"<s> function isImmediate(value: Opaque): value is number | boolean | null | undefined {<EOL>    let type = typeof value;<EOL>    if (value === null || value === undefined)<EOL>        return true;<EOL>    switch (type) {<EOL>        case '<STR_LIT>':<EOL>        case '<STR_LIT>':<EOL>            return true;<EOL>        case '<STR_LIT>':<EOL>            <EOL>            if (value as number % <NUM_LIT> !== <NUM_LIT>)<EOL>                return false;<EOL>            let abs = Math.abs(value as number);<EOL>            <EOL>            if (abs > HI)<EOL>                return","gt":"false;"}
{"input":"<s> /**<EOL> * Branch out the source Observable values as a nested Observable using a<EOL> * factory function of closing Observables to determine when to start a new<EOL> * window.<EOL> *<EOL> * <span class=\"informal\">It's like {@link bufferWhen}, but emits a nested<EOL> * Observable instead of an array.</span><EOL> *<EOL> * <img src=\"./img/windowWhen.png\" width=\"100%\"><EOL> *<EOL> * Returns an Observable that emits windows of items it collects from the source<EOL> * Observable. The output Observable emits connected, non-overlapping windows.<EOL> * It emits the current window and opens a new one whenever the Observable<EOL> * produced by the specified `closingSelector` function emits an item. The first<EOL> * window is opened immediately when subscribing to the output Observable.<EOL> *<EOL> * @example <caption>Emit only the first two clicks events in every window of [1-5] random seconds</caption><EOL> * var clicks = Rx.Observable.fromEvent(document, 'click');<EOL> * var result = clicks<EOL> *   .windowWhen(() => Rx.Observable.interval(1000 + Math.random() * 4000))<EOL> *   .map(win => win.take(2)) // each window has at most 2 emissions<EOL> *   .mergeAll(); // flatten the Observable-of-Observables<EOL> * result.subscribe(x => console.log(x));<EOL> *<EOL> * @see {@link window}<EOL> * @see {@link windowCount}<EOL> * @see {@link windowTime}<EOL> * @see {@link windowToggle}<EOL> * @see {@link bufferWhen}<EOL> *<EOL> * @param {function(): Observable} closingSelector A function that takes no<EOL> * arguments and returns an Observable that signals (on either `next` or<EOL> * `complete`) when to close the previous window and start a new one.<EOL> * @return {Observable<Observable<T>>} An observable of windows, which in turn<EOL> * are Observables.<EOL> * @method windowWhen<EOL> * @owner Observable<EOL> */<EOL>export function windowWhen<T>(this: Observable<T>, closingSelector: () => Observable<any>): Observable<Observable<T>> {<EOL>    return this.lift(new WindowOperator<T>(","gt":"closingSelector));"}
{"input":"<s> export async function introspect(schemaContents: string) {<EOL>    const schema = buildASTSchema(parse(","gt":"schemaContents), { commentDescriptions: true });"}
{"input":"<s> /**<EOL> * Buffers the source Observable values until `closingNotifier` emits.<EOL> *<EOL> * <span class=\"informal\">Collects values from the past as an array, and emits<EOL> * that array only when another Observable emits.</span><EOL> *<EOL> * <img src=\"./img/buffer.png\" width=\"100%\"><EOL> *<EOL> * Buffers the incoming Observable values until the given `closingNotifier`<EOL> * Observable emits a value, at which point it emits the buffer on the output<EOL> * Observable and starts a new buffer internally, awaiting the next time<EOL> * `closingNotifier` emits.<EOL> *<EOL> * @example <caption>On every click, emit array of most recent interval events</caption><EOL> * var clicks = Rx.Observable.fromEvent(document, 'click');<EOL> * var interval = Rx.Observable.interval(1000);<EOL> * var buffered = interval.buffer(clicks);<EOL> * buffered.subscribe(x => console.log(x));<EOL> *<EOL> * @see {@link bufferCount}<EOL> * @see {@link bufferTime}<EOL> * @see {@link bufferToggle}<EOL> * @see {@link bufferWhen}<EOL> * @see {@link window}<EOL> *<EOL> * @param {Observable<any>} closingNotifier An Observable that signals the<EOL> * buffer to be emitted on the output Observable.<EOL> * @return {Observable<T[]>} An Observable of buffers, which are arrays of<EOL> * values.<EOL> * @method buffer<EOL> * @owner Observable<EOL> */<EOL>export function buffer<T>(this: Observable<T>, closingNotifier: Observable<any>): Observable<T[]> {<EOL>","gt":"return this.lift(new BufferOperator<T>(closingNotifier));"}
{"input":"<s> async function func(): Promise<void> {<EOL>","gt":"before();"}
{"input":"<s> export function createCSSRule(selector: string, cssText: string, style: HTMLStyleElement = sharedStyle): void {<EOL>    if (!style || !cssText) {<EOL>","gt":"return;"}
{"input":"<s> function storeRoundtrip(query: DocumentNode, result: any, variables = {}) {<EOL>    const fragmentMap = createFragmentMap(getFragmentDefinitions(query));<EOL>    const store = writeQueryToStore({<EOL>        result,<EOL>        query,<EOL>","gt":"variables,"}
{"input":"<s> function storeRoundtrip(query: DocumentNode, result: any, variables = {}) {<EOL>    const fragmentMap = createFragmentMap(getFragmentDefinitions(query));<EOL>    const store = writeQueryToStore({<EOL>        result,<EOL>        query,<EOL>        variables,<EOL>        fragmentMap,<EOL>    });<EOL>    const reconstructedResult = readQueryFromStore({<EOL>        store,<EOL>        query,<EOL>","gt":"variables,"}
{"input":"<s> function compileForever(e: Environment, b: B.Block): J.JStmt {<EOL>    var bBody = b.","gt":"getInputTargetBlock(\"<STR_LIT>\");"}
{"input":"<s> export function errLog(arg) {<EOL>    if (typeof arg === \"<STR_LIT>\") {<EOL>        trace.error(arg);<EOL>    }<EOL>    else if (typeof arg.toString === \"<STR_LIT>\") {<EOL>        trace.debug(arg.stack);<EOL>        trace.error(","gt":"arg.toString());"}
{"input":"<s> /**<EOL> * Returns a query document which adds a single query operation that only<EOL> * spreads the target fragment inside of it.<EOL> *<EOL> * So for example a document of:<EOL> *<EOL> * ```graphql<EOL> * fragment foo on Foo { a b c }<EOL> * ```<EOL> *<EOL> * Turns into:<EOL> *<EOL> * ```graphql<EOL> * { ...foo }<EOL> *<EOL> * fragment foo on Foo { a b c }<EOL> * ```<EOL> *<EOL> * The target fragment will either be the only fragment in the document, or a<EOL> * fragment specified by the provided `fragmentName`. If there is more then one<EOL> * fragment, but a `fragmentName` was not defined then an error will be thrown.<EOL> */<EOL>export function getFragmentQueryDocument(document: DocumentNode, fragmentName?: string): DocumentNode {<EOL>    let actualFragmentName = fragmentName;<EOL>    <EOL>    <EOL>    <EOL>    const","gt":"fragments: Array<FragmentDefinitionNode> = [];"}
{"input":"<s> /**<EOL> * Returns a query document which adds a single query operation that only<EOL> * spreads the target fragment inside of it.<EOL> *<EOL> * So for example a document of:<EOL> *<EOL> * ```graphql<EOL> * fragment foo on Foo { a b c }<EOL> * ```<EOL> *<EOL> * Turns into:<EOL> *<EOL> * ```graphql<EOL> * { ...foo }<EOL> *<EOL> * fragment foo on Foo { a b c }<EOL> * ```<EOL> *<EOL> * The target fragment will either be the only fragment in the document, or a<EOL> * fragment specified by the provided `fragmentName`. If there is more then one<EOL> * fragment, but a `fragmentName` was not defined then an error will be thrown.<EOL> */<EOL>export function getFragmentQueryDocument(document: DocumentNode, fragmentName?: string): DocumentNode {<EOL>    let actualFragmentName = fragmentName;<EOL>    <EOL>    <EOL>    <EOL>    const fragments: Array<FragmentDefinitionNode> = [];<EOL>    document.definitions.forEach(definition => {<EOL>        <EOL>        <EOL>        if (definition.kind === '<STR_LIT>') {<EOL>            throw new","gt":"Error(`<STR_LIT>` +"}
{"input":"<s> /**<EOL> * Returns a query document which adds a single query operation that only<EOL> * spreads the target fragment inside of it.<EOL> *<EOL> * So for example a document of:<EOL> *<EOL> * ```graphql<EOL> * fragment foo on Foo { a b c }<EOL> * ```<EOL> *<EOL> * Turns into:<EOL> *<EOL> * ```graphql<EOL> * { ...foo }<EOL> *<EOL> * fragment foo on Foo { a b c }<EOL> * ```<EOL> *<EOL> * The target fragment will either be the only fragment in the document, or a<EOL> * fragment specified by the provided `fragmentName`. If there is more then one<EOL> * fragment, but a `fragmentName` was not defined then an error will be thrown.<EOL> */<EOL>export function getFragmentQueryDocument(document: DocumentNode, fragmentName?: string): DocumentNode {<EOL>    let actualFragmentName = fragmentName;<EOL>    <EOL>    <EOL>    <EOL>    const fragments: Array<FragmentDefinitionNode> = [];<EOL>    document.definitions.forEach(definition => {<EOL>        <EOL>        <EOL>        if (definition.kind === '<STR_LIT>') {<EOL>            throw new Error(`<STR_LIT>` +<EOL>                '<STR_LIT>');<EOL>        }<EOL>        <EOL>        <EOL>        if (definition.kind === '<STR_LIT>') {<EOL>            fragments.","gt":"push(definition);"}
{"input":"<s> /**<EOL> * Returns a query document which adds a single query operation that only<EOL> * spreads the target fragment inside of it.<EOL> *<EOL> * So for example a document of:<EOL> *<EOL> * ```graphql<EOL> * fragment foo on Foo { a b c }<EOL> * ```<EOL> *<EOL> * Turns into:<EOL> *<EOL> * ```graphql<EOL> * { ...foo }<EOL> *<EOL> * fragment foo on Foo { a b c }<EOL> * ```<EOL> *<EOL> * The target fragment will either be the only fragment in the document, or a<EOL> * fragment specified by the provided `fragmentName`. If there is more then one<EOL> * fragment, but a `fragmentName` was not defined then an error will be thrown.<EOL> */<EOL>export function getFragmentQueryDocument(document: DocumentNode, fragmentName?: string): DocumentNode {<EOL>    let actualFragmentName = fragmentName;<EOL>    <EOL>    <EOL>    <EOL>    const fragments: Array<FragmentDefinitionNode> = [];<EOL>    document.definitions.forEach(definition => {<EOL>        <EOL>        <EOL>        if (definition.kind === '<STR_LIT>') {<EOL>            throw new Error(`<STR_LIT>` +<EOL>                '<STR_LIT>');<EOL>        }<EOL>        <EOL>        <EOL>        if (definition.kind === '<STR_LIT>') {<EOL>            fragments.push(definition);<EOL>        }<EOL>    });<EOL>    <EOL>    <EOL>    if (typeof","gt":"actualFragmentName === '<STR_LIT>') {"}
{"input":"<s> /**<EOL> * Returns a query document which adds a single query operation that only<EOL> * spreads the target fragment inside of it.<EOL> *<EOL> * So for example a document of:<EOL> *<EOL> * ```graphql<EOL> * fragment foo on Foo { a b c }<EOL> * ```<EOL> *<EOL> * Turns into:<EOL> *<EOL> * ```graphql<EOL> * { ...foo }<EOL> *<EOL> * fragment foo on Foo { a b c }<EOL> * ```<EOL> *<EOL> * The target fragment will either be the only fragment in the document, or a<EOL> * fragment specified by the provided `fragmentName`. If there is more then one<EOL> * fragment, but a `fragmentName` was not defined then an error will be thrown.<EOL> */<EOL>export function getFragmentQueryDocument(document: DocumentNode, fragmentName?: string): DocumentNode {<EOL>    let actualFragmentName = fragmentName;<EOL>    <EOL>    <EOL>    <EOL>    const fragments: Array<FragmentDefinitionNode> = [];<EOL>    document.definitions.forEach(definition => {<EOL>        <EOL>        <EOL>        if (definition.kind === '<STR_LIT>') {<EOL>            throw new Error(`<STR_LIT>` +<EOL>                '<STR_LIT>');<EOL>        }<EOL>        <EOL>        <EOL>        if (definition.kind === '<STR_LIT>') {<EOL>            fragments.push(definition);<EOL>        }<EOL>    });<EOL>    <EOL>    <EOL>    if (typeof actualFragmentName === '<STR_LIT>') {<EOL>        if (fragments.length !== <NUM_LIT>) {<EOL>            throw new Error(`<STR_LIT>`);<EOL>        }<EOL>        actualFragmentName = fragments[<NUM_LIT>].name.value;<EOL>    }<EOL>    <EOL>    <EOL>    const query: DocumentNode = {<EOL>        ...document,<EOL>        definitions: [<EOL>            {<EOL>                kind: '<STR_LIT>',<EOL>                operation: '<STR_LIT>',<EOL>                selectionSet: {<EOL>                    kind: '<STR_LIT>',<EOL>                    selections: [<EOL>                        {<EOL>","gt":"kind: '<STR_LIT>',"}
{"input":"<s> export default function renameBranch<T>(branchId: BranchId, branchName: string, history: DagHistory<T>): DagHistory<T> {<EOL>    const { graph } = history;<EOL>    log('<STR_LIT>', branchId, branchName);<EOL>","gt":"return {"}
{"input":"<s> function parseFragmentToInlineFragment(definitions: string): InlineFragmentNode {<EOL>    const document = parse(definitions);<EOL>    for (const definition of document.definitions) {<EOL>        if (definition.kind === Kind.FRAGMENT_DEFINITION) {<EOL>","gt":"return {"}
{"input":"<s> function testRandomFile(file: string): boolean {<EOL>    let tests = getRandomInt(<NUM_LIT>, <NUM_LIT>);<EOL>    for (let i = <NUM_LIT>; i < tests; i++) {<EOL>        let chunks = generateRandomChunks(file);<EOL>","gt":"try {"}
{"input":"<s> function testRandomFile(file: string): boolean {<EOL>    let tests = getRandomInt(<NUM_LIT>, <NUM_LIT>);<EOL>    for (let i = <NUM_LIT>; i < tests; i++) {<EOL>        let chunks = generateRandomChunks(file);<EOL>        try {<EOL>            testModelBuilder(chunks);<EOL>        }<EOL>        catch (err) {<EOL>            console.log(err);<EOL>            console.log(JSON.stringify(chunks));<EOL>            return","gt":"false;"}
{"input":"<s> /**<EOL> * Selects an observable from the store, and attaches it to the decorated<EOL> * property.<EOL> *<EOL> * ```ts<EOL> *  import { select } from '@angular-redux/store';<EOL> *<EOL> *  class SomeClass {<EOL> *    @select(['foo','bar']) foo$: Observable<string><EOL> * }<EOL> * ```<EOL> *<EOL> * @param selector<EOL> * A selector function, property name string, or property name path<EOL> * (array of strings/array indices) that locates the store data to be<EOL> * selected<EOL> *<EOL> * @param comparator Function used to determine if this selector has changed.<EOL> */<EOL>export function select<T>(selector?: Selector<any, T>, comparator?: Comparator): PropertyDecorator {<EOL>    return (target: any, key: string): void => {<EOL>        const adjustedSelector = selector<EOL>            ?","gt":"selector"}
{"input":"<s> export function minifyTask(src: string, sourceMapBaseUrl?: string): (cb: any) => void {<EOL>    const sourceMappingURL = sourceMapBaseUrl && (f => `<STR_LIT>`);<EOL>    return cb => {<EOL>        const jsFilter = filter('<STR_LIT>', { restore: true });<EOL>        const cssFilter = filter('<STR_LIT>', { restore: true });<EOL>","gt":"pump(gulp.src([src + '<STR_LIT>', '<STR_LIT>' + src + '<STR_LIT>']), jsFilter, sourcemaps.init({ loadMaps: true }), uglifyWithCopyrights(), jsFilter.restore, cssFilter, minifyCSS({ reduceIdents: false }), cssFilter.restore, sourcemaps.write('<STR_LIT>', {"}
{"input":"<s> export function minifyTask(src: string, sourceMapBaseUrl?: string): (cb: any) => void {<EOL>    const sourceMappingURL = sourceMapBaseUrl && (f => `<STR_LIT>`);<EOL>    return cb => {<EOL>        const jsFilter = filter('<STR_LIT>', { restore: true });<EOL>        const cssFilter = filter('<STR_LIT>', { restore: true });<EOL>        pump(gulp.src([src + '<STR_LIT>', '<STR_LIT>' + src + '<STR_LIT>']), jsFilter, sourcemaps.init({ loadMaps: true }), uglifyWithCopyrights(), jsFilter.restore, cssFilter, minifyCSS({ reduceIdents: false }), cssFilter.restore, sourcemaps.write('<STR_LIT>', {<EOL>            sourceMappingURL,<EOL>            sourceRoot: null,<EOL>            includeContent: true,<EOL>            addComment:","gt":"true"}
{"input":"<s> export function cannotReplaceNode(node: AST.Node, parent: AST.Node, key: string) {<EOL>    return new TraversalError(\"<STR_LIT>\", node,","gt":"parent, key);"}
{"input":"<s> /**<EOL> * Returns an Observable that emits all items emitted by the source Observable that are distinct by comparison from previous items.<EOL> *<EOL> * If a keySelector function is provided, then it will project each value from the source observable into a new value that it will<EOL> * check for equality with previously projected values. If a keySelector function is not provided, it will use each value from the<EOL> * source observable directly with an equality check against previous values.<EOL> *<EOL> * In JavaScript runtimes that support `Set`, this operator will use a `Set` to improve performance of the distinct value checking.<EOL> *<EOL> * In other runtimes, this operator will use a minimal implementation of `Set` that relies on an `Array` and `indexOf` under the<EOL> * hood, so performance will degrade as more values are checked for distinction. Even in newer browsers, a long-running `distinct`<EOL> * use might result in memory leaks. To help alleviate this in some scenarios, an optional `flushes` parameter is also provided so<EOL> * that the internal `Set` can be \"flushed\", basically clearing it of values.<EOL> *<EOL> * @example <caption>A simple example with numbers</caption><EOL> * Observable.of(1, 1, 2, 2, 2, 1, 2, 3, 4, 3, 2, 1)<EOL> *   .distinct()<EOL> *   .subscribe(x => console.log(x)); // 1, 2, 3, 4<EOL> *<EOL> * @example <caption>An example using a keySelector function</caption><EOL> * interface Person {<EOL> *    age: number,<EOL> *    name: string<EOL> * }<EOL> *<EOL> * Observable.of<Person>(<EOL> *     { age: 4, name: 'Foo'},<EOL> *     { age: 7, name: 'Bar'},<EOL> *     { age: 5, name: 'Foo'})<EOL> *     .distinct((p: Person) => p.name)<EOL> *     .subscribe(x => console.log(x));<EOL> *<EOL> * // displays:<EOL> * // { age: 4, name: 'Foo' }<EOL> * // { age: 7, name: 'Bar' }<EOL> *<EOL> * @see {@link distinctUntilChanged}<EOL> * @see {@link distinctUntilKeyChanged}<EOL> *<EOL> * @param {function} [keySelector] Optional function to select which value you want to check as distinct.<EOL> * @param {Observable} [flushes] Optional Observable for flushing the internal HashSet of the operator.<EOL> * @return {Observable} An Observable that emits items from the source Observable with distinct values.<EOL> * @method distinct<EOL> * @owner Observable<EOL> */<EOL>export function distinct<T, K>(this: Observable<T>, keySelector?: (value: T) => K, flushes?: Observable<any>): Observable<T> {<EOL>    return this.lift(new DistinctOperator(keySelector,","gt":"flushes));"}
{"input":"<s> export function isWhitespace(string: string) {<EOL>    return WHITESPACE.test(","gt":"string);"}
{"input":"<s> export function renderTemplate(src: string, env: LazyTestEnvironment, self: PathReference<Opaque>, builder: ElementBuilder) {<EOL>    let template = env.compile(","gt":"src);"}
{"input":"<s> function compileSet(e: Environment, b: B.Block): J.JStmt {<EOL>    var bVar = b.getFieldValue(\"<STR_LIT>\");<EOL>","gt":"var bExpr = b.getInputTargetBlock(\"<STR_LIT>\");"}
{"input":"<s> <EOL><EOL>function rbTreeDelete(T: IntervalTree, z: IntervalNode): void {<EOL>    let x: IntervalNode;<EOL>    let y: IntervalNode;<EOL>    <EOL>    <EOL>    if (z.left === SENTINEL) {<EOL>        x = z.right;<EOL>","gt":"y = z;"}
{"input":"<s> <EOL><EOL>function rbTreeDelete(T: IntervalTree, z: IntervalNode): void {<EOL>    let x: IntervalNode;<EOL>    let y: IntervalNode;<EOL>    <EOL>    <EOL>    if (z.left === SENTINEL) {<EOL>        x = z.right;<EOL>        y = z;<EOL>        <EOL>        x.delta += z.delta;<EOL>        if (x.delta < Constants.MIN_SAFE_DELTA || x.delta > Constants.MAX_SAFE_DELTA) {<EOL>            T.requestNormalizeDelta = true;<EOL>        }<EOL>        x.start += z.delta;<EOL>","gt":"x.end += z.delta;"}
{"input":"<s> <EOL><EOL>function rbTreeDelete(T: IntervalTree, z: IntervalNode): void {<EOL>    let x: IntervalNode;<EOL>    let y: IntervalNode;<EOL>    <EOL>    <EOL>    if (z.left === SENTINEL) {<EOL>        x = z.right;<EOL>        y = z;<EOL>        <EOL>        x.delta += z.delta;<EOL>        if (x.delta < Constants.MIN_SAFE_DELTA || x.delta > Constants.MAX_SAFE_DELTA) {<EOL>            T.requestNormalizeDelta = true;<EOL>        }<EOL>        x.start += z.delta;<EOL>        x.end += z.delta;<EOL>    }<EOL>    else if (z.right === SENTINEL) {<EOL>        x = z.left;<EOL>        y = z;<EOL>    }<EOL>","gt":"else {"}
{"input":"<s> <EOL><EOL>function rbTreeDelete(T: IntervalTree, z: IntervalNode): void {<EOL>    let x: IntervalNode;<EOL>    let y: IntervalNode;<EOL>    <EOL>    <EOL>    if (z.left === SENTINEL) {<EOL>        x = z.right;<EOL>        y = z;<EOL>        <EOL>        x.delta += z.delta;<EOL>        if (x.delta < Constants.MIN_SAFE_DELTA || x.delta > Constants.MAX_SAFE_DELTA) {<EOL>            T.requestNormalizeDelta = true;<EOL>        }<EOL>        x.start += z.delta;<EOL>        x.end += z.delta;<EOL>    }<EOL>    else if (z.right === SENTINEL) {<EOL>        x = z.left;<EOL>        y = z;<EOL>    }<EOL>    else {<EOL>        y = leftest(z.right);<EOL>        x = y.right;<EOL>        <EOL>        <EOL>        <EOL>        x.start += y.delta;<EOL>        x.end += y.delta;<EOL>        x.delta += y.delta;<EOL>        if (x.delta < Constants.MIN_SAFE_DELTA || x.delta > Constants.MAX_SAFE_DELTA) {<EOL>            T.","gt":"requestNormalizeDelta = true;"}
{"input":"<s> <EOL><EOL>function rbTreeDelete(T: IntervalTree, z: IntervalNode): void {<EOL>    let x: IntervalNode;<EOL>    let y: IntervalNode;<EOL>    <EOL>    <EOL>    if (z.left === SENTINEL) {<EOL>        x = z.right;<EOL>        y = z;<EOL>        <EOL>        x.delta += z.delta;<EOL>        if (x.delta < Constants.MIN_SAFE_DELTA || x.delta > Constants.MAX_SAFE_DELTA) {<EOL>            T.requestNormalizeDelta = true;<EOL>        }<EOL>        x.start += z.delta;<EOL>        x.end += z.delta;<EOL>    }<EOL>    else if (z.right === SENTINEL) {<EOL>        x = z.left;<EOL>        y = z;<EOL>    }<EOL>    else {<EOL>        y = leftest(z.right);<EOL>        x = y.right;<EOL>        <EOL>        <EOL>        <EOL>        x.start += y.delta;<EOL>        x.end += y.delta;<EOL>        x.delta += y.delta;<EOL>        if (x.delta < Constants.MIN_SAFE_DELTA || x.delta > Constants.MAX_SAFE_DELTA) {<EOL>            T.requestNormalizeDelta = true;<EOL>        }<EOL>        y.start += z.","gt":"delta;"}
{"input":"<s> <EOL><EOL>function rbTreeDelete(T: IntervalTree, z: IntervalNode): void {<EOL>    let x: IntervalNode;<EOL>    let y: IntervalNode;<EOL>    <EOL>    <EOL>    if (z.left === SENTINEL) {<EOL>        x = z.right;<EOL>        y = z;<EOL>        <EOL>        x.delta += z.delta;<EOL>        if (x.delta < Constants.MIN_SAFE_DELTA || x.delta > Constants.MAX_SAFE_DELTA) {<EOL>            T.requestNormalizeDelta = true;<EOL>        }<EOL>        x.start += z.delta;<EOL>        x.end += z.delta;<EOL>    }<EOL>    else if (z.right === SENTINEL) {<EOL>        x = z.left;<EOL>        y = z;<EOL>    }<EOL>    else {<EOL>        y = leftest(z.right);<EOL>        x = y.right;<EOL>        <EOL>        <EOL>        <EOL>        x.start += y.delta;<EOL>        x.end += y.delta;<EOL>        x.delta += y.delta;<EOL>        if (x.delta < Constants.MIN_SAFE_DELTA || x.delta > Constants.MAX_SAFE_DELTA) {<EOL>            T.requestNormalizeDelta = true;<EOL>        }<EOL>        y.start += z.delta;<EOL>        y.end += z.delta;<EOL>        y.delta = z.delta;<EOL>        if (y.delta < Constants.MIN_SAFE_DELTA || y.delta > Constants.MAX_SAFE_DELTA) {<EOL>            T.requestNormalizeDelta = true;<EOL>        }<EOL>    }<EOL>    if (","gt":"y === T.root) {"}
{"input":"<s> <EOL><EOL>function rbTreeDelete(T: IntervalTree, z: IntervalNode): void {<EOL>    let x: IntervalNode;<EOL>    let y: IntervalNode;<EOL>    <EOL>    <EOL>    if (z.left === SENTINEL) {<EOL>        x = z.right;<EOL>        y = z;<EOL>        <EOL>        x.delta += z.delta;<EOL>        if (x.delta < Constants.MIN_SAFE_DELTA || x.delta > Constants.MAX_SAFE_DELTA) {<EOL>            T.requestNormalizeDelta = true;<EOL>        }<EOL>        x.start += z.delta;<EOL>        x.end += z.delta;<EOL>    }<EOL>    else if (z.right === SENTINEL) {<EOL>        x = z.left;<EOL>        y = z;<EOL>    }<EOL>    else {<EOL>        y = leftest(z.right);<EOL>        x = y.right;<EOL>        <EOL>        <EOL>        <EOL>        x.start += y.delta;<EOL>        x.end += y.delta;<EOL>        x.delta += y.delta;<EOL>        if (x.delta < Constants.MIN_SAFE_DELTA || x.delta > Constants.MAX_SAFE_DELTA) {<EOL>            T.requestNormalizeDelta = true;<EOL>        }<EOL>        y.start += z.delta;<EOL>        y.end += z.delta;<EOL>        y.delta = z.delta;<EOL>        if (y.delta < Constants.MIN_SAFE_DELTA || y.delta > Constants.MAX_SAFE_DELTA) {<EOL>            T.requestNormalizeDelta = true;<EOL>        }<EOL>    }<EOL>    if (y === T.root) {<EOL>        T.root = x;<EOL>        setNodeColor(x, NodeColor.Black);<EOL>        z.detach();<EOL>        resetSentinel();<EOL>        recomputeMaxEnd(x);<EOL>        T.","gt":"root.parent = SENTINEL;"}
{"input":"<s> <EOL><EOL>function rbTreeDelete(T: IntervalTree, z: IntervalNode): void {<EOL>    let x: IntervalNode;<EOL>    let y: IntervalNode;<EOL>    <EOL>    <EOL>    if (z.left === SENTINEL) {<EOL>        x = z.right;<EOL>        y = z;<EOL>        <EOL>        x.delta += z.delta;<EOL>        if (x.delta < Constants.MIN_SAFE_DELTA || x.delta > Constants.MAX_SAFE_DELTA) {<EOL>            T.requestNormalizeDelta = true;<EOL>        }<EOL>        x.start += z.delta;<EOL>        x.end += z.delta;<EOL>    }<EOL>    else if (z.right === SENTINEL) {<EOL>        x = z.left;<EOL>        y = z;<EOL>    }<EOL>    else {<EOL>        y = leftest(z.right);<EOL>        x = y.right;<EOL>        <EOL>        <EOL>        <EOL>        x.start += y.delta;<EOL>        x.end += y.delta;<EOL>        x.delta += y.delta;<EOL>        if (x.delta < Constants.MIN_SAFE_DELTA || x.delta > Constants.MAX_SAFE_DELTA) {<EOL>            T.requestNormalizeDelta = true;<EOL>        }<EOL>        y.start += z.delta;<EOL>        y.end += z.delta;<EOL>        y.delta = z.delta;<EOL>        if (y.delta < Constants.MIN_SAFE_DELTA || y.delta > Constants.MAX_SAFE_DELTA) {<EOL>            T.requestNormalizeDelta = true;<EOL>        }<EOL>    }<EOL>    if (y === T.root) {<EOL>        T.root = x;<EOL>        setNodeColor(x, NodeColor.Black);<EOL>        z.detach();<EOL>        resetSentinel();<EOL>        recomputeMaxEnd(x);<EOL>        T.root.parent = SENTINEL;<EOL>        return;<EOL>    }<EOL>    let yWasRed = (","gt":"getNodeColor(y) === NodeColor.Red);"}
{"input":"<s> <EOL><EOL>function rbTreeDelete(T: IntervalTree, z: IntervalNode): void {<EOL>    let x: IntervalNode;<EOL>    let y: IntervalNode;<EOL>    <EOL>    <EOL>    if (z.left === SENTINEL) {<EOL>        x = z.right;<EOL>        y = z;<EOL>        <EOL>        x.delta += z.delta;<EOL>        if (x.delta < Constants.MIN_SAFE_DELTA || x.delta > Constants.MAX_SAFE_DELTA) {<EOL>            T.requestNormalizeDelta = true;<EOL>        }<EOL>        x.start += z.delta;<EOL>        x.end += z.delta;<EOL>    }<EOL>    else if (z.right === SENTINEL) {<EOL>        x = z.left;<EOL>        y = z;<EOL>    }<EOL>    else {<EOL>        y = leftest(z.right);<EOL>        x = y.right;<EOL>        <EOL>        <EOL>        <EOL>        x.start += y.delta;<EOL>        x.end += y.delta;<EOL>        x.delta += y.delta;<EOL>        if (x.delta < Constants.MIN_SAFE_DELTA || x.delta > Constants.MAX_SAFE_DELTA) {<EOL>            T.requestNormalizeDelta = true;<EOL>        }<EOL>        y.start += z.delta;<EOL>        y.end += z.delta;<EOL>        y.delta = z.delta;<EOL>        if (y.delta < Constants.MIN_SAFE_DELTA || y.delta > Constants.MAX_SAFE_DELTA) {<EOL>            T.requestNormalizeDelta = true;<EOL>        }<EOL>    }<EOL>    if (y === T.root) {<EOL>        T.root = x;<EOL>        setNodeColor(x, NodeColor.Black);<EOL>        z.detach();<EOL>        resetSentinel();<EOL>        recomputeMaxEnd(x);<EOL>        T.root.parent = SENTINEL;<EOL>        return;<EOL>    }<EOL>    let yWasRed = (getNodeColor(y) === NodeColor.Red);<EOL>    if (","gt":"y === y.parent."}
{"input":"<s> <EOL><EOL>function rbTreeDelete(T: IntervalTree, z: IntervalNode): void {<EOL>    let x: IntervalNode;<EOL>    let y: IntervalNode;<EOL>    <EOL>    <EOL>    if (z.left === SENTINEL) {<EOL>        x = z.right;<EOL>        y = z;<EOL>        <EOL>        x.delta += z.delta;<EOL>        if (x.delta < Constants.MIN_SAFE_DELTA || x.delta > Constants.MAX_SAFE_DELTA) {<EOL>            T.requestNormalizeDelta = true;<EOL>        }<EOL>        x.start += z.delta;<EOL>        x.end += z.delta;<EOL>    }<EOL>    else if (z.right === SENTINEL) {<EOL>        x = z.left;<EOL>        y = z;<EOL>    }<EOL>    else {<EOL>        y = leftest(z.right);<EOL>        x = y.right;<EOL>        <EOL>        <EOL>        <EOL>        x.start += y.delta;<EOL>        x.end += y.delta;<EOL>        x.delta += y.delta;<EOL>        if (x.delta < Constants.MIN_SAFE_DELTA || x.delta > Constants.MAX_SAFE_DELTA) {<EOL>            T.requestNormalizeDelta = true;<EOL>        }<EOL>        y.start += z.delta;<EOL>        y.end += z.delta;<EOL>        y.delta = z.delta;<EOL>        if (y.delta < Constants.MIN_SAFE_DELTA || y.delta > Constants.MAX_SAFE_DELTA) {<EOL>            T.requestNormalizeDelta = true;<EOL>        }<EOL>    }<EOL>    if (y === T.root) {<EOL>        T.root = x;<EOL>        setNodeColor(x, NodeColor.Black);<EOL>        z.detach();<EOL>        resetSentinel();<EOL>        recomputeMaxEnd(x);<EOL>        T.root.parent = SENTINEL;<EOL>        return;<EOL>    }<EOL>    let yWasRed = (getNodeColor(y) === NodeColor.Red);<EOL>    if (y === y.parent.","gt":"left) {"}
{"input":"<s> <EOL><EOL>function rbTreeDelete(T: IntervalTree, z: IntervalNode): void {<EOL>    let x: IntervalNode;<EOL>    let y: IntervalNode;<EOL>    <EOL>    <EOL>    if (z.left === SENTINEL) {<EOL>        x = z.right;<EOL>        y = z;<EOL>        <EOL>        x.delta += z.delta;<EOL>        if (x.delta < Constants.MIN_SAFE_DELTA || x.delta > Constants.MAX_SAFE_DELTA) {<EOL>            T.requestNormalizeDelta = true;<EOL>        }<EOL>        x.start += z.delta;<EOL>        x.end += z.delta;<EOL>    }<EOL>    else if (z.right === SENTINEL) {<EOL>        x = z.left;<EOL>        y = z;<EOL>    }<EOL>    else {<EOL>        y = leftest(z.right);<EOL>        x = y.right;<EOL>        <EOL>        <EOL>        <EOL>        x.start += y.delta;<EOL>        x.end += y.delta;<EOL>        x.delta += y.delta;<EOL>        if (x.delta < Constants.MIN_SAFE_DELTA || x.delta > Constants.MAX_SAFE_DELTA) {<EOL>            T.requestNormalizeDelta = true;<EOL>        }<EOL>        y.start += z.delta;<EOL>        y.end += z.delta;<EOL>        y.delta = z.delta;<EOL>        if (y.delta < Constants.MIN_SAFE_DELTA || y.delta > Constants.MAX_SAFE_DELTA) {<EOL>            T.requestNormalizeDelta = true;<EOL>        }<EOL>    }<EOL>    if (y === T.root) {<EOL>        T.root = x;<EOL>        setNodeColor(x, NodeColor.Black);<EOL>        z.detach();<EOL>        resetSentinel();<EOL>        recomputeMaxEnd(x);<EOL>        T.root.parent = SENTINEL;<EOL>        return;<EOL>    }<EOL>    let yWasRed = (getNodeColor(y) === NodeColor.Red);<EOL>    if (y === y.parent.left) {<EOL>        y.parent.left = x;<EOL>    }<EOL>    else {<EOL>        y.parent.right = x;<EOL>    }<EOL>    if (y === z) {<EOL>        x.","gt":"parent = y.parent;"}
{"input":"<s> <EOL><EOL>function rbTreeDelete(T: IntervalTree, z: IntervalNode): void {<EOL>    let x: IntervalNode;<EOL>    let y: IntervalNode;<EOL>    <EOL>    <EOL>    if (z.left === SENTINEL) {<EOL>        x = z.right;<EOL>        y = z;<EOL>        <EOL>        x.delta += z.delta;<EOL>        if (x.delta < Constants.MIN_SAFE_DELTA || x.delta > Constants.MAX_SAFE_DELTA) {<EOL>            T.requestNormalizeDelta = true;<EOL>        }<EOL>        x.start += z.delta;<EOL>        x.end += z.delta;<EOL>    }<EOL>    else if (z.right === SENTINEL) {<EOL>        x = z.left;<EOL>        y = z;<EOL>    }<EOL>    else {<EOL>        y = leftest(z.right);<EOL>        x = y.right;<EOL>        <EOL>        <EOL>        <EOL>        x.start += y.delta;<EOL>        x.end += y.delta;<EOL>        x.delta += y.delta;<EOL>        if (x.delta < Constants.MIN_SAFE_DELTA || x.delta > Constants.MAX_SAFE_DELTA) {<EOL>            T.requestNormalizeDelta = true;<EOL>        }<EOL>        y.start += z.delta;<EOL>        y.end += z.delta;<EOL>        y.delta = z.delta;<EOL>        if (y.delta < Constants.MIN_SAFE_DELTA || y.delta > Constants.MAX_SAFE_DELTA) {<EOL>            T.requestNormalizeDelta = true;<EOL>        }<EOL>    }<EOL>    if (y === T.root) {<EOL>        T.root = x;<EOL>        setNodeColor(x, NodeColor.Black);<EOL>        z.detach();<EOL>        resetSentinel();<EOL>        recomputeMaxEnd(x);<EOL>        T.root.parent = SENTINEL;<EOL>        return;<EOL>    }<EOL>    let yWasRed = (getNodeColor(y) === NodeColor.Red);<EOL>    if (y === y.parent.left) {<EOL>        y.parent.left = x;<EOL>    }<EOL>    else {<EOL>        y.parent.right = x;<EOL>    }<EOL>    if (y === z) {<EOL>        x.parent = y.parent;<EOL>    }<EOL>    else {<EOL>        if (y.parent === z) {<EOL>            x.parent = y;<EOL>        }<EOL>        else {<EOL>            x.parent = y.parent;<EOL>        }<EOL>        y.left = z.left;<EOL>","gt":"y.right = z.right;"}
{"input":"<s> <EOL><EOL>function rbTreeDelete(T: IntervalTree, z: IntervalNode): void {<EOL>    let x: IntervalNode;<EOL>    let y: IntervalNode;<EOL>    <EOL>    <EOL>    if (z.left === SENTINEL) {<EOL>        x = z.right;<EOL>        y = z;<EOL>        <EOL>        x.delta += z.delta;<EOL>        if (x.delta < Constants.MIN_SAFE_DELTA || x.delta > Constants.MAX_SAFE_DELTA) {<EOL>            T.requestNormalizeDelta = true;<EOL>        }<EOL>        x.start += z.delta;<EOL>        x.end += z.delta;<EOL>    }<EOL>    else if (z.right === SENTINEL) {<EOL>        x = z.left;<EOL>        y = z;<EOL>    }<EOL>    else {<EOL>        y = leftest(z.right);<EOL>        x = y.right;<EOL>        <EOL>        <EOL>        <EOL>        x.start += y.delta;<EOL>        x.end += y.delta;<EOL>        x.delta += y.delta;<EOL>        if (x.delta < Constants.MIN_SAFE_DELTA || x.delta > Constants.MAX_SAFE_DELTA) {<EOL>            T.requestNormalizeDelta = true;<EOL>        }<EOL>        y.start += z.delta;<EOL>        y.end += z.delta;<EOL>        y.delta = z.delta;<EOL>        if (y.delta < Constants.MIN_SAFE_DELTA || y.delta > Constants.MAX_SAFE_DELTA) {<EOL>            T.requestNormalizeDelta = true;<EOL>        }<EOL>    }<EOL>    if (y === T.root) {<EOL>        T.root = x;<EOL>        setNodeColor(x, NodeColor.Black);<EOL>        z.detach();<EOL>        resetSentinel();<EOL>        recomputeMaxEnd(x);<EOL>        T.root.parent = SENTINEL;<EOL>        return;<EOL>    }<EOL>    let yWasRed = (getNodeColor(y) === NodeColor.Red);<EOL>    if (y === y.parent.left) {<EOL>        y.parent.left = x;<EOL>    }<EOL>    else {<EOL>        y.parent.right = x;<EOL>    }<EOL>    if (y === z) {<EOL>        x.parent = y.parent;<EOL>    }<EOL>    else {<EOL>        if (y.parent === z) {<EOL>            x.parent = y;<EOL>        }<EOL>        else {<EOL>            x.parent = y.parent;<EOL>        }<EOL>        y.left = z.left;<EOL>        y.right = z.right;<EOL>        y.parent = z.parent;<EOL>        setNodeColor(y, getNodeColor(z));<EOL>        if (z === T.root) {<EOL>            T.root =","gt":"y;"}
{"input":"<s> <EOL><EOL>function rbTreeDelete(T: IntervalTree, z: IntervalNode): void {<EOL>    let x: IntervalNode;<EOL>    let y: IntervalNode;<EOL>    <EOL>    <EOL>    if (z.left === SENTINEL) {<EOL>        x = z.right;<EOL>        y = z;<EOL>        <EOL>        x.delta += z.delta;<EOL>        if (x.delta < Constants.MIN_SAFE_DELTA || x.delta > Constants.MAX_SAFE_DELTA) {<EOL>            T.requestNormalizeDelta = true;<EOL>        }<EOL>        x.start += z.delta;<EOL>        x.end += z.delta;<EOL>    }<EOL>    else if (z.right === SENTINEL) {<EOL>        x = z.left;<EOL>        y = z;<EOL>    }<EOL>    else {<EOL>        y = leftest(z.right);<EOL>        x = y.right;<EOL>        <EOL>        <EOL>        <EOL>        x.start += y.delta;<EOL>        x.end += y.delta;<EOL>        x.delta += y.delta;<EOL>        if (x.delta < Constants.MIN_SAFE_DELTA || x.delta > Constants.MAX_SAFE_DELTA) {<EOL>            T.requestNormalizeDelta = true;<EOL>        }<EOL>        y.start += z.delta;<EOL>        y.end += z.delta;<EOL>        y.delta = z.delta;<EOL>        if (y.delta < Constants.MIN_SAFE_DELTA || y.delta > Constants.MAX_SAFE_DELTA) {<EOL>            T.requestNormalizeDelta = true;<EOL>        }<EOL>    }<EOL>    if (y === T.root) {<EOL>        T.root = x;<EOL>        setNodeColor(x, NodeColor.Black);<EOL>        z.detach();<EOL>        resetSentinel();<EOL>        recomputeMaxEnd(x);<EOL>        T.root.parent = SENTINEL;<EOL>        return;<EOL>    }<EOL>    let yWasRed = (getNodeColor(y) === NodeColor.Red);<EOL>    if (y === y.parent.left) {<EOL>        y.parent.left = x;<EOL>    }<EOL>    else {<EOL>        y.parent.right = x;<EOL>    }<EOL>    if (y === z) {<EOL>        x.parent = y.parent;<EOL>    }<EOL>    else {<EOL>        if (y.parent === z) {<EOL>            x.parent = y;<EOL>        }<EOL>        else {<EOL>            x.parent = y.parent;<EOL>        }<EOL>        y.left = z.left;<EOL>        y.right = z.right;<EOL>        y.parent = z.parent;<EOL>        setNodeColor(y, getNodeColor(z));<EOL>        if (z === T.root) {<EOL>            T.root = y;<EOL>        }<EOL>","gt":"else {"}
{"input":"<s> <EOL><EOL>function rbTreeDelete(T: IntervalTree, z: IntervalNode): void {<EOL>    let x: IntervalNode;<EOL>    let y: IntervalNode;<EOL>    <EOL>    <EOL>    if (z.left === SENTINEL) {<EOL>        x = z.right;<EOL>        y = z;<EOL>        <EOL>        x.delta += z.delta;<EOL>        if (x.delta < Constants.MIN_SAFE_DELTA || x.delta > Constants.MAX_SAFE_DELTA) {<EOL>            T.requestNormalizeDelta = true;<EOL>        }<EOL>        x.start += z.delta;<EOL>        x.end += z.delta;<EOL>    }<EOL>    else if (z.right === SENTINEL) {<EOL>        x = z.left;<EOL>        y = z;<EOL>    }<EOL>    else {<EOL>        y = leftest(z.right);<EOL>        x = y.right;<EOL>        <EOL>        <EOL>        <EOL>        x.start += y.delta;<EOL>        x.end += y.delta;<EOL>        x.delta += y.delta;<EOL>        if (x.delta < Constants.MIN_SAFE_DELTA || x.delta > Constants.MAX_SAFE_DELTA) {<EOL>            T.requestNormalizeDelta = true;<EOL>        }<EOL>        y.start += z.delta;<EOL>        y.end += z.delta;<EOL>        y.delta = z.delta;<EOL>        if (y.delta < Constants.MIN_SAFE_DELTA || y.delta > Constants.MAX_SAFE_DELTA) {<EOL>            T.requestNormalizeDelta = true;<EOL>        }<EOL>    }<EOL>    if (y === T.root) {<EOL>        T.root = x;<EOL>        setNodeColor(x, NodeColor.Black);<EOL>        z.detach();<EOL>        resetSentinel();<EOL>        recomputeMaxEnd(x);<EOL>        T.root.parent = SENTINEL;<EOL>        return;<EOL>    }<EOL>    let yWasRed = (getNodeColor(y) === NodeColor.Red);<EOL>    if (y === y.parent.left) {<EOL>        y.parent.left = x;<EOL>    }<EOL>    else {<EOL>        y.parent.right = x;<EOL>    }<EOL>    if (y === z) {<EOL>        x.parent = y.parent;<EOL>    }<EOL>    else {<EOL>        if (y.parent === z) {<EOL>            x.parent = y;<EOL>        }<EOL>        else {<EOL>            x.parent = y.parent;<EOL>        }<EOL>        y.left = z.left;<EOL>        y.right = z.right;<EOL>        y.parent = z.parent;<EOL>        setNodeColor(y, getNodeColor(z));<EOL>        if (z === T.root) {<EOL>            T.root = y;<EOL>        }<EOL>        else {<EOL>            if (z === z.parent.left) {<EOL>                z.parent.left = y;<EOL>            }<EOL>            else {<EOL>                z.parent.right = y;<EOL>            }<EOL>        }<EOL>        if (y.left !== SENTINEL) {<EOL>            y.left.parent = y;<EOL>        }<EOL>        if (y.right !== SENTINEL) {<EOL>            y.","gt":"right.parent = y;"}
{"input":"<s> <EOL><EOL>function rbTreeDelete(T: IntervalTree, z: IntervalNode): void {<EOL>    let x: IntervalNode;<EOL>    let y: IntervalNode;<EOL>    <EOL>    <EOL>    if (z.left === SENTINEL) {<EOL>        x = z.right;<EOL>        y = z;<EOL>        <EOL>        x.delta += z.delta;<EOL>        if (x.delta < Constants.MIN_SAFE_DELTA || x.delta > Constants.MAX_SAFE_DELTA) {<EOL>            T.requestNormalizeDelta = true;<EOL>        }<EOL>        x.start += z.delta;<EOL>        x.end += z.delta;<EOL>    }<EOL>    else if (z.right === SENTINEL) {<EOL>        x = z.left;<EOL>        y = z;<EOL>    }<EOL>    else {<EOL>        y = leftest(z.right);<EOL>        x = y.right;<EOL>        <EOL>        <EOL>        <EOL>        x.start += y.delta;<EOL>        x.end += y.delta;<EOL>        x.delta += y.delta;<EOL>        if (x.delta < Constants.MIN_SAFE_DELTA || x.delta > Constants.MAX_SAFE_DELTA) {<EOL>            T.requestNormalizeDelta = true;<EOL>        }<EOL>        y.start += z.delta;<EOL>        y.end += z.delta;<EOL>        y.delta = z.delta;<EOL>        if (y.delta < Constants.MIN_SAFE_DELTA || y.delta > Constants.MAX_SAFE_DELTA) {<EOL>            T.requestNormalizeDelta = true;<EOL>        }<EOL>    }<EOL>    if (y === T.root) {<EOL>        T.root = x;<EOL>        setNodeColor(x, NodeColor.Black);<EOL>        z.detach();<EOL>        resetSentinel();<EOL>        recomputeMaxEnd(x);<EOL>        T.root.parent = SENTINEL;<EOL>        return;<EOL>    }<EOL>    let yWasRed = (getNodeColor(y) === NodeColor.Red);<EOL>    if (y === y.parent.left) {<EOL>        y.parent.left = x;<EOL>    }<EOL>    else {<EOL>        y.parent.right = x;<EOL>    }<EOL>    if (y === z) {<EOL>        x.parent = y.parent;<EOL>    }<EOL>    else {<EOL>        if (y.parent === z) {<EOL>            x.parent = y;<EOL>        }<EOL>        else {<EOL>            x.parent = y.parent;<EOL>        }<EOL>        y.left = z.left;<EOL>        y.right = z.right;<EOL>        y.parent = z.parent;<EOL>        setNodeColor(y, getNodeColor(z));<EOL>        if (z === T.root) {<EOL>            T.root = y;<EOL>        }<EOL>        else {<EOL>            if (z === z.parent.left) {<EOL>                z.parent.left = y;<EOL>            }<EOL>            else {<EOL>                z.parent.right = y;<EOL>            }<EOL>        }<EOL>        if (y.left !== SENTINEL) {<EOL>            y.left.parent = y;<EOL>        }<EOL>        if (y.right !== SENTINEL) {<EOL>            y.right.parent = y;<EOL>        }<EOL>    }<EOL>    z.detach();<EOL>    if (yWasRed) {<EOL>","gt":"recomputeMaxEndWalkToRoot(x.parent);"}
{"input":"<s> <EOL><EOL>function rbTreeDelete(T: IntervalTree, z: IntervalNode): void {<EOL>    let x: IntervalNode;<EOL>    let y: IntervalNode;<EOL>    <EOL>    <EOL>    if (z.left === SENTINEL) {<EOL>        x = z.right;<EOL>        y = z;<EOL>        <EOL>        x.delta += z.delta;<EOL>        if (x.delta < Constants.MIN_SAFE_DELTA || x.delta > Constants.MAX_SAFE_DELTA) {<EOL>            T.requestNormalizeDelta = true;<EOL>        }<EOL>        x.start += z.delta;<EOL>        x.end += z.delta;<EOL>    }<EOL>    else if (z.right === SENTINEL) {<EOL>        x = z.left;<EOL>        y = z;<EOL>    }<EOL>    else {<EOL>        y = leftest(z.right);<EOL>        x = y.right;<EOL>        <EOL>        <EOL>        <EOL>        x.start += y.delta;<EOL>        x.end += y.delta;<EOL>        x.delta += y.delta;<EOL>        if (x.delta < Constants.MIN_SAFE_DELTA || x.delta > Constants.MAX_SAFE_DELTA) {<EOL>            T.requestNormalizeDelta = true;<EOL>        }<EOL>        y.start += z.delta;<EOL>        y.end += z.delta;<EOL>        y.delta = z.delta;<EOL>        if (y.delta < Constants.MIN_SAFE_DELTA || y.delta > Constants.MAX_SAFE_DELTA) {<EOL>            T.requestNormalizeDelta = true;<EOL>        }<EOL>    }<EOL>    if (y === T.root) {<EOL>        T.root = x;<EOL>        setNodeColor(x, NodeColor.Black);<EOL>        z.detach();<EOL>        resetSentinel();<EOL>        recomputeMaxEnd(x);<EOL>        T.root.parent = SENTINEL;<EOL>        return;<EOL>    }<EOL>    let yWasRed = (getNodeColor(y) === NodeColor.Red);<EOL>    if (y === y.parent.left) {<EOL>        y.parent.left = x;<EOL>    }<EOL>    else {<EOL>        y.parent.right = x;<EOL>    }<EOL>    if (y === z) {<EOL>        x.parent = y.parent;<EOL>    }<EOL>    else {<EOL>        if (y.parent === z) {<EOL>            x.parent = y;<EOL>        }<EOL>        else {<EOL>            x.parent = y.parent;<EOL>        }<EOL>        y.left = z.left;<EOL>        y.right = z.right;<EOL>        y.parent = z.parent;<EOL>        setNodeColor(y, getNodeColor(z));<EOL>        if (z === T.root) {<EOL>            T.root = y;<EOL>        }<EOL>        else {<EOL>            if (z === z.parent.left) {<EOL>                z.parent.left = y;<EOL>            }<EOL>            else {<EOL>                z.parent.right = y;<EOL>            }<EOL>        }<EOL>        if (y.left !== SENTINEL) {<EOL>            y.left.parent = y;<EOL>        }<EOL>        if (y.right !== SENTINEL) {<EOL>            y.right.parent = y;<EOL>        }<EOL>    }<EOL>    z.detach();<EOL>    if (yWasRed) {<EOL>        recomputeMaxEndWalkToRoot(x.parent);<EOL>        if (y !== z) {<EOL>            recomputeMaxEndWalkToRoot(y);<EOL>            recomputeMaxEndWalkToRoot(y.parent);<EOL>        }<EOL>","gt":"resetSentinel();"}
{"input":"<s> <EOL><EOL>function rbTreeDelete(T: IntervalTree, z: IntervalNode): void {<EOL>    let x: IntervalNode;<EOL>    let y: IntervalNode;<EOL>    <EOL>    <EOL>    if (z.left === SENTINEL) {<EOL>        x = z.right;<EOL>        y = z;<EOL>        <EOL>        x.delta += z.delta;<EOL>        if (x.delta < Constants.MIN_SAFE_DELTA || x.delta > Constants.MAX_SAFE_DELTA) {<EOL>            T.requestNormalizeDelta = true;<EOL>        }<EOL>        x.start += z.delta;<EOL>        x.end += z.delta;<EOL>    }<EOL>    else if (z.right === SENTINEL) {<EOL>        x = z.left;<EOL>        y = z;<EOL>    }<EOL>    else {<EOL>        y = leftest(z.right);<EOL>        x = y.right;<EOL>        <EOL>        <EOL>        <EOL>        x.start += y.delta;<EOL>        x.end += y.delta;<EOL>        x.delta += y.delta;<EOL>        if (x.delta < Constants.MIN_SAFE_DELTA || x.delta > Constants.MAX_SAFE_DELTA) {<EOL>            T.requestNormalizeDelta = true;<EOL>        }<EOL>        y.start += z.delta;<EOL>        y.end += z.delta;<EOL>        y.delta = z.delta;<EOL>        if (y.delta < Constants.MIN_SAFE_DELTA || y.delta > Constants.MAX_SAFE_DELTA) {<EOL>            T.requestNormalizeDelta = true;<EOL>        }<EOL>    }<EOL>    if (y === T.root) {<EOL>        T.root = x;<EOL>        setNodeColor(x, NodeColor.Black);<EOL>        z.detach();<EOL>        resetSentinel();<EOL>        recomputeMaxEnd(x);<EOL>        T.root.parent = SENTINEL;<EOL>        return;<EOL>    }<EOL>    let yWasRed = (getNodeColor(y) === NodeColor.Red);<EOL>    if (y === y.parent.left) {<EOL>        y.parent.left = x;<EOL>    }<EOL>    else {<EOL>        y.parent.right = x;<EOL>    }<EOL>    if (y === z) {<EOL>        x.parent = y.parent;<EOL>    }<EOL>    else {<EOL>        if (y.parent === z) {<EOL>            x.parent = y;<EOL>        }<EOL>        else {<EOL>            x.parent = y.parent;<EOL>        }<EOL>        y.left = z.left;<EOL>        y.right = z.right;<EOL>        y.parent = z.parent;<EOL>        setNodeColor(y, getNodeColor(z));<EOL>        if (z === T.root) {<EOL>            T.root = y;<EOL>        }<EOL>        else {<EOL>            if (z === z.parent.left) {<EOL>                z.parent.left = y;<EOL>            }<EOL>            else {<EOL>                z.parent.right = y;<EOL>            }<EOL>        }<EOL>        if (y.left !== SENTINEL) {<EOL>            y.left.parent = y;<EOL>        }<EOL>        if (y.right !== SENTINEL) {<EOL>            y.right.parent = y;<EOL>        }<EOL>    }<EOL>    z.detach();<EOL>    if (yWasRed) {<EOL>        recomputeMaxEndWalkToRoot(x.parent);<EOL>        if (y !== z) {<EOL>            recomputeMaxEndWalkToRoot(y);<EOL>            recomputeMaxEndWalkToRoot(y.parent);<EOL>        }<EOL>        resetSentinel();<EOL>        return;<EOL>    }<EOL>    recomputeMaxEndWalkToRoot(x);<EOL>    recomputeMaxEndWalkToRoot(x.parent);<EOL>    if (y !==","gt":"z) {"}
{"input":"<s> <EOL><EOL>function rbTreeDelete(T: IntervalTree, z: IntervalNode): void {<EOL>    let x: IntervalNode;<EOL>    let y: IntervalNode;<EOL>    <EOL>    <EOL>    if (z.left === SENTINEL) {<EOL>        x = z.right;<EOL>        y = z;<EOL>        <EOL>        x.delta += z.delta;<EOL>        if (x.delta < Constants.MIN_SAFE_DELTA || x.delta > Constants.MAX_SAFE_DELTA) {<EOL>            T.requestNormalizeDelta = true;<EOL>        }<EOL>        x.start += z.delta;<EOL>        x.end += z.delta;<EOL>    }<EOL>    else if (z.right === SENTINEL) {<EOL>        x = z.left;<EOL>        y = z;<EOL>    }<EOL>    else {<EOL>        y = leftest(z.right);<EOL>        x = y.right;<EOL>        <EOL>        <EOL>        <EOL>        x.start += y.delta;<EOL>        x.end += y.delta;<EOL>        x.delta += y.delta;<EOL>        if (x.delta < Constants.MIN_SAFE_DELTA || x.delta > Constants.MAX_SAFE_DELTA) {<EOL>            T.requestNormalizeDelta = true;<EOL>        }<EOL>        y.start += z.delta;<EOL>        y.end += z.delta;<EOL>        y.delta = z.delta;<EOL>        if (y.delta < Constants.MIN_SAFE_DELTA || y.delta > Constants.MAX_SAFE_DELTA) {<EOL>            T.requestNormalizeDelta = true;<EOL>        }<EOL>    }<EOL>    if (y === T.root) {<EOL>        T.root = x;<EOL>        setNodeColor(x, NodeColor.Black);<EOL>        z.detach();<EOL>        resetSentinel();<EOL>        recomputeMaxEnd(x);<EOL>        T.root.parent = SENTINEL;<EOL>        return;<EOL>    }<EOL>    let yWasRed = (getNodeColor(y) === NodeColor.Red);<EOL>    if (y === y.parent.left) {<EOL>        y.parent.left = x;<EOL>    }<EOL>    else {<EOL>        y.parent.right = x;<EOL>    }<EOL>    if (y === z) {<EOL>        x.parent = y.parent;<EOL>    }<EOL>    else {<EOL>        if (y.parent === z) {<EOL>            x.parent = y;<EOL>        }<EOL>        else {<EOL>            x.parent = y.parent;<EOL>        }<EOL>        y.left = z.left;<EOL>        y.right = z.right;<EOL>        y.parent = z.parent;<EOL>        setNodeColor(y, getNodeColor(z));<EOL>        if (z === T.root) {<EOL>            T.root = y;<EOL>        }<EOL>        else {<EOL>            if (z === z.parent.left) {<EOL>                z.parent.left = y;<EOL>            }<EOL>            else {<EOL>                z.parent.right = y;<EOL>            }<EOL>        }<EOL>        if (y.left !== SENTINEL) {<EOL>            y.left.parent = y;<EOL>        }<EOL>        if (y.right !== SENTINEL) {<EOL>            y.right.parent = y;<EOL>        }<EOL>    }<EOL>    z.detach();<EOL>    if (yWasRed) {<EOL>        recomputeMaxEndWalkToRoot(x.parent);<EOL>        if (y !== z) {<EOL>            recomputeMaxEndWalkToRoot(y);<EOL>            recomputeMaxEndWalkToRoot(y.parent);<EOL>        }<EOL>        resetSentinel();<EOL>        return;<EOL>    }<EOL>    recomputeMaxEndWalkToRoot(x);<EOL>    recomputeMaxEndWalkToRoot(x.parent);<EOL>    if (y !== z) {<EOL>        recomputeMaxEndWalkToRoot(y);<EOL>        recomputeMaxEndWalkToRoot(y.","gt":"parent);"}
{"input":"<s> <EOL><EOL>function rbTreeDelete(T: IntervalTree, z: IntervalNode): void {<EOL>    let x: IntervalNode;<EOL>    let y: IntervalNode;<EOL>    <EOL>    <EOL>    if (z.left === SENTINEL) {<EOL>        x = z.right;<EOL>        y = z;<EOL>        <EOL>        x.delta += z.delta;<EOL>        if (x.delta < Constants.MIN_SAFE_DELTA || x.delta > Constants.MAX_SAFE_DELTA) {<EOL>            T.requestNormalizeDelta = true;<EOL>        }<EOL>        x.start += z.delta;<EOL>        x.end += z.delta;<EOL>    }<EOL>    else if (z.right === SENTINEL) {<EOL>        x = z.left;<EOL>        y = z;<EOL>    }<EOL>    else {<EOL>        y = leftest(z.right);<EOL>        x = y.right;<EOL>        <EOL>        <EOL>        <EOL>        x.start += y.delta;<EOL>        x.end += y.delta;<EOL>        x.delta += y.delta;<EOL>        if (x.delta < Constants.MIN_SAFE_DELTA || x.delta > Constants.MAX_SAFE_DELTA) {<EOL>            T.requestNormalizeDelta = true;<EOL>        }<EOL>        y.start += z.delta;<EOL>        y.end += z.delta;<EOL>        y.delta = z.delta;<EOL>        if (y.delta < Constants.MIN_SAFE_DELTA || y.delta > Constants.MAX_SAFE_DELTA) {<EOL>            T.requestNormalizeDelta = true;<EOL>        }<EOL>    }<EOL>    if (y === T.root) {<EOL>        T.root = x;<EOL>        setNodeColor(x, NodeColor.Black);<EOL>        z.detach();<EOL>        resetSentinel();<EOL>        recomputeMaxEnd(x);<EOL>        T.root.parent = SENTINEL;<EOL>        return;<EOL>    }<EOL>    let yWasRed = (getNodeColor(y) === NodeColor.Red);<EOL>    if (y === y.parent.left) {<EOL>        y.parent.left = x;<EOL>    }<EOL>    else {<EOL>        y.parent.right = x;<EOL>    }<EOL>    if (y === z) {<EOL>        x.parent = y.parent;<EOL>    }<EOL>    else {<EOL>        if (y.parent === z) {<EOL>            x.parent = y;<EOL>        }<EOL>        else {<EOL>            x.parent = y.parent;<EOL>        }<EOL>        y.left = z.left;<EOL>        y.right = z.right;<EOL>        y.parent = z.parent;<EOL>        setNodeColor(y, getNodeColor(z));<EOL>        if (z === T.root) {<EOL>            T.root = y;<EOL>        }<EOL>        else {<EOL>            if (z === z.parent.left) {<EOL>                z.parent.left = y;<EOL>            }<EOL>            else {<EOL>                z.parent.right = y;<EOL>            }<EOL>        }<EOL>        if (y.left !== SENTINEL) {<EOL>            y.left.parent = y;<EOL>        }<EOL>        if (y.right !== SENTINEL) {<EOL>            y.right.parent = y;<EOL>        }<EOL>    }<EOL>    z.detach();<EOL>    if (yWasRed) {<EOL>        recomputeMaxEndWalkToRoot(x.parent);<EOL>        if (y !== z) {<EOL>            recomputeMaxEndWalkToRoot(y);<EOL>            recomputeMaxEndWalkToRoot(y.parent);<EOL>        }<EOL>        resetSentinel();<EOL>        return;<EOL>    }<EOL>    recomputeMaxEndWalkToRoot(x);<EOL>    recomputeMaxEndWalkToRoot(x.parent);<EOL>    if (y !== z) {<EOL>        recomputeMaxEndWalkToRoot(y);<EOL>        recomputeMaxEndWalkToRoot(y.parent);<EOL>    }<EOL>    <EOL>    let w: IntervalNode;<EOL>    while (x !== T.root && getNodeColor(x) === NodeColor.Black) {<EOL>        if (x === x.parent.left) {<EOL>            w = x.","gt":"parent.right;"}
{"input":"<s> <EOL><EOL>function rbTreeDelete(T: IntervalTree, z: IntervalNode): void {<EOL>    let x: IntervalNode;<EOL>    let y: IntervalNode;<EOL>    <EOL>    <EOL>    if (z.left === SENTINEL) {<EOL>        x = z.right;<EOL>        y = z;<EOL>        <EOL>        x.delta += z.delta;<EOL>        if (x.delta < Constants.MIN_SAFE_DELTA || x.delta > Constants.MAX_SAFE_DELTA) {<EOL>            T.requestNormalizeDelta = true;<EOL>        }<EOL>        x.start += z.delta;<EOL>        x.end += z.delta;<EOL>    }<EOL>    else if (z.right === SENTINEL) {<EOL>        x = z.left;<EOL>        y = z;<EOL>    }<EOL>    else {<EOL>        y = leftest(z.right);<EOL>        x = y.right;<EOL>        <EOL>        <EOL>        <EOL>        x.start += y.delta;<EOL>        x.end += y.delta;<EOL>        x.delta += y.delta;<EOL>        if (x.delta < Constants.MIN_SAFE_DELTA || x.delta > Constants.MAX_SAFE_DELTA) {<EOL>            T.requestNormalizeDelta = true;<EOL>        }<EOL>        y.start += z.delta;<EOL>        y.end += z.delta;<EOL>        y.delta = z.delta;<EOL>        if (y.delta < Constants.MIN_SAFE_DELTA || y.delta > Constants.MAX_SAFE_DELTA) {<EOL>            T.requestNormalizeDelta = true;<EOL>        }<EOL>    }<EOL>    if (y === T.root) {<EOL>        T.root = x;<EOL>        setNodeColor(x, NodeColor.Black);<EOL>        z.detach();<EOL>        resetSentinel();<EOL>        recomputeMaxEnd(x);<EOL>        T.root.parent = SENTINEL;<EOL>        return;<EOL>    }<EOL>    let yWasRed = (getNodeColor(y) === NodeColor.Red);<EOL>    if (y === y.parent.left) {<EOL>        y.parent.left = x;<EOL>    }<EOL>    else {<EOL>        y.parent.right = x;<EOL>    }<EOL>    if (y === z) {<EOL>        x.parent = y.parent;<EOL>    }<EOL>    else {<EOL>        if (y.parent === z) {<EOL>            x.parent = y;<EOL>        }<EOL>        else {<EOL>            x.parent = y.parent;<EOL>        }<EOL>        y.left = z.left;<EOL>        y.right = z.right;<EOL>        y.parent = z.parent;<EOL>        setNodeColor(y, getNodeColor(z));<EOL>        if (z === T.root) {<EOL>            T.root = y;<EOL>        }<EOL>        else {<EOL>            if (z === z.parent.left) {<EOL>                z.parent.left = y;<EOL>            }<EOL>            else {<EOL>                z.parent.right = y;<EOL>            }<EOL>        }<EOL>        if (y.left !== SENTINEL) {<EOL>            y.left.parent = y;<EOL>        }<EOL>        if (y.right !== SENTINEL) {<EOL>            y.right.parent = y;<EOL>        }<EOL>    }<EOL>    z.detach();<EOL>    if (yWasRed) {<EOL>        recomputeMaxEndWalkToRoot(x.parent);<EOL>        if (y !== z) {<EOL>            recomputeMaxEndWalkToRoot(y);<EOL>            recomputeMaxEndWalkToRoot(y.parent);<EOL>        }<EOL>        resetSentinel();<EOL>        return;<EOL>    }<EOL>    recomputeMaxEndWalkToRoot(x);<EOL>    recomputeMaxEndWalkToRoot(x.parent);<EOL>    if (y !== z) {<EOL>        recomputeMaxEndWalkToRoot(y);<EOL>        recomputeMaxEndWalkToRoot(y.parent);<EOL>    }<EOL>    <EOL>    let w: IntervalNode;<EOL>    while (x !== T.root && getNodeColor(x) === NodeColor.Black) {<EOL>        if (x === x.parent.left) {<EOL>            w = x.parent.right;<EOL>            if (getNodeColor(w) === NodeColor.Red) {<EOL>                setNodeColor(w, NodeColor.Black);<EOL>                setNodeColor(x.parent, NodeColor.Red);<EOL>                leftRotate(T, x.parent);<EOL>                w = x.parent.right;<EOL>            }<EOL>            if (getNodeColor(w.left) === NodeColor.Black && getNodeColor(w.right) === NodeColor.Black) {<EOL>                setNodeColor(w, NodeColor.Red);<EOL>                x = x.parent;<EOL>            }<EOL>            else {<EOL>                if (getNodeColor(w.right) === NodeColor.Black) {<EOL>","gt":"setNodeColor(w.left, NodeColor.Black);"}
{"input":"<s> <EOL><EOL>function rbTreeDelete(T: IntervalTree, z: IntervalNode): void {<EOL>    let x: IntervalNode;<EOL>    let y: IntervalNode;<EOL>    <EOL>    <EOL>    if (z.left === SENTINEL) {<EOL>        x = z.right;<EOL>        y = z;<EOL>        <EOL>        x.delta += z.delta;<EOL>        if (x.delta < Constants.MIN_SAFE_DELTA || x.delta > Constants.MAX_SAFE_DELTA) {<EOL>            T.requestNormalizeDelta = true;<EOL>        }<EOL>        x.start += z.delta;<EOL>        x.end += z.delta;<EOL>    }<EOL>    else if (z.right === SENTINEL) {<EOL>        x = z.left;<EOL>        y = z;<EOL>    }<EOL>    else {<EOL>        y = leftest(z.right);<EOL>        x = y.right;<EOL>        <EOL>        <EOL>        <EOL>        x.start += y.delta;<EOL>        x.end += y.delta;<EOL>        x.delta += y.delta;<EOL>        if (x.delta < Constants.MIN_SAFE_DELTA || x.delta > Constants.MAX_SAFE_DELTA) {<EOL>            T.requestNormalizeDelta = true;<EOL>        }<EOL>        y.start += z.delta;<EOL>        y.end += z.delta;<EOL>        y.delta = z.delta;<EOL>        if (y.delta < Constants.MIN_SAFE_DELTA || y.delta > Constants.MAX_SAFE_DELTA) {<EOL>            T.requestNormalizeDelta = true;<EOL>        }<EOL>    }<EOL>    if (y === T.root) {<EOL>        T.root = x;<EOL>        setNodeColor(x, NodeColor.Black);<EOL>        z.detach();<EOL>        resetSentinel();<EOL>        recomputeMaxEnd(x);<EOL>        T.root.parent = SENTINEL;<EOL>        return;<EOL>    }<EOL>    let yWasRed = (getNodeColor(y) === NodeColor.Red);<EOL>    if (y === y.parent.left) {<EOL>        y.parent.left = x;<EOL>    }<EOL>    else {<EOL>        y.parent.right = x;<EOL>    }<EOL>    if (y === z) {<EOL>        x.parent = y.parent;<EOL>    }<EOL>    else {<EOL>        if (y.parent === z) {<EOL>            x.parent = y;<EOL>        }<EOL>        else {<EOL>            x.parent = y.parent;<EOL>        }<EOL>        y.left = z.left;<EOL>        y.right = z.right;<EOL>        y.parent = z.parent;<EOL>        setNodeColor(y, getNodeColor(z));<EOL>        if (z === T.root) {<EOL>            T.root = y;<EOL>        }<EOL>        else {<EOL>            if (z === z.parent.left) {<EOL>                z.parent.left = y;<EOL>            }<EOL>            else {<EOL>                z.parent.right = y;<EOL>            }<EOL>        }<EOL>        if (y.left !== SENTINEL) {<EOL>            y.left.parent = y;<EOL>        }<EOL>        if (y.right !== SENTINEL) {<EOL>            y.right.parent = y;<EOL>        }<EOL>    }<EOL>    z.detach();<EOL>    if (yWasRed) {<EOL>        recomputeMaxEndWalkToRoot(x.parent);<EOL>        if (y !== z) {<EOL>            recomputeMaxEndWalkToRoot(y);<EOL>            recomputeMaxEndWalkToRoot(y.parent);<EOL>        }<EOL>        resetSentinel();<EOL>        return;<EOL>    }<EOL>    recomputeMaxEndWalkToRoot(x);<EOL>    recomputeMaxEndWalkToRoot(x.parent);<EOL>    if (y !== z) {<EOL>        recomputeMaxEndWalkToRoot(y);<EOL>        recomputeMaxEndWalkToRoot(y.parent);<EOL>    }<EOL>    <EOL>    let w: IntervalNode;<EOL>    while (x !== T.root && getNodeColor(x) === NodeColor.Black) {<EOL>        if (x === x.parent.left) {<EOL>            w = x.parent.right;<EOL>            if (getNodeColor(w) === NodeColor.Red) {<EOL>                setNodeColor(w, NodeColor.Black);<EOL>                setNodeColor(x.parent, NodeColor.Red);<EOL>                leftRotate(T, x.parent);<EOL>                w = x.parent.right;<EOL>            }<EOL>            if (getNodeColor(w.left) === NodeColor.Black && getNodeColor(w.right) === NodeColor.Black) {<EOL>                setNodeColor(w, NodeColor.Red);<EOL>                x = x.parent;<EOL>            }<EOL>            else {<EOL>                if (getNodeColor(w.right) === NodeColor.Black) {<EOL>                    setNodeColor(w.left, NodeColor.Black);<EOL>                    setNodeColor(w, NodeColor.Red);<EOL>                    rightRotate(T, w);<EOL>                    w = x.parent.right;<EOL>                }<EOL>                setNodeColor(w, getNodeColor(x.parent));<EOL>                setNodeColor(x.parent, NodeColor.Black);<EOL>                setNodeColor(w.right, NodeColor.Black);<EOL>                leftRotate(T, x.parent);<EOL>","gt":"x = T.root;"}
{"input":"<s> <EOL><EOL>function rbTreeDelete(T: IntervalTree, z: IntervalNode): void {<EOL>    let x: IntervalNode;<EOL>    let y: IntervalNode;<EOL>    <EOL>    <EOL>    if (z.left === SENTINEL) {<EOL>        x = z.right;<EOL>        y = z;<EOL>        <EOL>        x.delta += z.delta;<EOL>        if (x.delta < Constants.MIN_SAFE_DELTA || x.delta > Constants.MAX_SAFE_DELTA) {<EOL>            T.requestNormalizeDelta = true;<EOL>        }<EOL>        x.start += z.delta;<EOL>        x.end += z.delta;<EOL>    }<EOL>    else if (z.right === SENTINEL) {<EOL>        x = z.left;<EOL>        y = z;<EOL>    }<EOL>    else {<EOL>        y = leftest(z.right);<EOL>        x = y.right;<EOL>        <EOL>        <EOL>        <EOL>        x.start += y.delta;<EOL>        x.end += y.delta;<EOL>        x.delta += y.delta;<EOL>        if (x.delta < Constants.MIN_SAFE_DELTA || x.delta > Constants.MAX_SAFE_DELTA) {<EOL>            T.requestNormalizeDelta = true;<EOL>        }<EOL>        y.start += z.delta;<EOL>        y.end += z.delta;<EOL>        y.delta = z.delta;<EOL>        if (y.delta < Constants.MIN_SAFE_DELTA || y.delta > Constants.MAX_SAFE_DELTA) {<EOL>            T.requestNormalizeDelta = true;<EOL>        }<EOL>    }<EOL>    if (y === T.root) {<EOL>        T.root = x;<EOL>        setNodeColor(x, NodeColor.Black);<EOL>        z.detach();<EOL>        resetSentinel();<EOL>        recomputeMaxEnd(x);<EOL>        T.root.parent = SENTINEL;<EOL>        return;<EOL>    }<EOL>    let yWasRed = (getNodeColor(y) === NodeColor.Red);<EOL>    if (y === y.parent.left) {<EOL>        y.parent.left = x;<EOL>    }<EOL>    else {<EOL>        y.parent.right = x;<EOL>    }<EOL>    if (y === z) {<EOL>        x.parent = y.parent;<EOL>    }<EOL>    else {<EOL>        if (y.parent === z) {<EOL>            x.parent = y;<EOL>        }<EOL>        else {<EOL>            x.parent = y.parent;<EOL>        }<EOL>        y.left = z.left;<EOL>        y.right = z.right;<EOL>        y.parent = z.parent;<EOL>        setNodeColor(y, getNodeColor(z));<EOL>        if (z === T.root) {<EOL>            T.root = y;<EOL>        }<EOL>        else {<EOL>            if (z === z.parent.left) {<EOL>                z.parent.left = y;<EOL>            }<EOL>            else {<EOL>                z.parent.right = y;<EOL>            }<EOL>        }<EOL>        if (y.left !== SENTINEL) {<EOL>            y.left.parent = y;<EOL>        }<EOL>        if (y.right !== SENTINEL) {<EOL>            y.right.parent = y;<EOL>        }<EOL>    }<EOL>    z.detach();<EOL>    if (yWasRed) {<EOL>        recomputeMaxEndWalkToRoot(x.parent);<EOL>        if (y !== z) {<EOL>            recomputeMaxEndWalkToRoot(y);<EOL>            recomputeMaxEndWalkToRoot(y.parent);<EOL>        }<EOL>        resetSentinel();<EOL>        return;<EOL>    }<EOL>    recomputeMaxEndWalkToRoot(x);<EOL>    recomputeMaxEndWalkToRoot(x.parent);<EOL>    if (y !== z) {<EOL>        recomputeMaxEndWalkToRoot(y);<EOL>        recomputeMaxEndWalkToRoot(y.parent);<EOL>    }<EOL>    <EOL>    let w: IntervalNode;<EOL>    while (x !== T.root && getNodeColor(x) === NodeColor.Black) {<EOL>        if (x === x.parent.left) {<EOL>            w = x.parent.right;<EOL>            if (getNodeColor(w) === NodeColor.Red) {<EOL>                setNodeColor(w, NodeColor.Black);<EOL>                setNodeColor(x.parent, NodeColor.Red);<EOL>                leftRotate(T, x.parent);<EOL>                w = x.parent.right;<EOL>            }<EOL>            if (getNodeColor(w.left) === NodeColor.Black && getNodeColor(w.right) === NodeColor.Black) {<EOL>                setNodeColor(w, NodeColor.Red);<EOL>                x = x.parent;<EOL>            }<EOL>            else {<EOL>                if (getNodeColor(w.right) === NodeColor.Black) {<EOL>                    setNodeColor(w.left, NodeColor.Black);<EOL>                    setNodeColor(w, NodeColor.Red);<EOL>                    rightRotate(T, w);<EOL>                    w = x.parent.right;<EOL>                }<EOL>                setNodeColor(w, getNodeColor(x.parent));<EOL>                setNodeColor(x.parent, NodeColor.Black);<EOL>                setNodeColor(w.right, NodeColor.Black);<EOL>                leftRotate(T, x.parent);<EOL>                x = T.root;<EOL>            }<EOL>        }<EOL>","gt":"else {"}
{"input":"<s> <EOL><EOL>function rbTreeDelete(T: IntervalTree, z: IntervalNode): void {<EOL>    let x: IntervalNode;<EOL>    let y: IntervalNode;<EOL>    <EOL>    <EOL>    if (z.left === SENTINEL) {<EOL>        x = z.right;<EOL>        y = z;<EOL>        <EOL>        x.delta += z.delta;<EOL>        if (x.delta < Constants.MIN_SAFE_DELTA || x.delta > Constants.MAX_SAFE_DELTA) {<EOL>            T.requestNormalizeDelta = true;<EOL>        }<EOL>        x.start += z.delta;<EOL>        x.end += z.delta;<EOL>    }<EOL>    else if (z.right === SENTINEL) {<EOL>        x = z.left;<EOL>        y = z;<EOL>    }<EOL>    else {<EOL>        y = leftest(z.right);<EOL>        x = y.right;<EOL>        <EOL>        <EOL>        <EOL>        x.start += y.delta;<EOL>        x.end += y.delta;<EOL>        x.delta += y.delta;<EOL>        if (x.delta < Constants.MIN_SAFE_DELTA || x.delta > Constants.MAX_SAFE_DELTA) {<EOL>            T.requestNormalizeDelta = true;<EOL>        }<EOL>        y.start += z.delta;<EOL>        y.end += z.delta;<EOL>        y.delta = z.delta;<EOL>        if (y.delta < Constants.MIN_SAFE_DELTA || y.delta > Constants.MAX_SAFE_DELTA) {<EOL>            T.requestNormalizeDelta = true;<EOL>        }<EOL>    }<EOL>    if (y === T.root) {<EOL>        T.root = x;<EOL>        setNodeColor(x, NodeColor.Black);<EOL>        z.detach();<EOL>        resetSentinel();<EOL>        recomputeMaxEnd(x);<EOL>        T.root.parent = SENTINEL;<EOL>        return;<EOL>    }<EOL>    let yWasRed = (getNodeColor(y) === NodeColor.Red);<EOL>    if (y === y.parent.left) {<EOL>        y.parent.left = x;<EOL>    }<EOL>    else {<EOL>        y.parent.right = x;<EOL>    }<EOL>    if (y === z) {<EOL>        x.parent = y.parent;<EOL>    }<EOL>    else {<EOL>        if (y.parent === z) {<EOL>            x.parent = y;<EOL>        }<EOL>        else {<EOL>            x.parent = y.parent;<EOL>        }<EOL>        y.left = z.left;<EOL>        y.right = z.right;<EOL>        y.parent = z.parent;<EOL>        setNodeColor(y, getNodeColor(z));<EOL>        if (z === T.root) {<EOL>            T.root = y;<EOL>        }<EOL>        else {<EOL>            if (z === z.parent.left) {<EOL>                z.parent.left = y;<EOL>            }<EOL>            else {<EOL>                z.parent.right = y;<EOL>            }<EOL>        }<EOL>        if (y.left !== SENTINEL) {<EOL>            y.left.parent = y;<EOL>        }<EOL>        if (y.right !== SENTINEL) {<EOL>            y.right.parent = y;<EOL>        }<EOL>    }<EOL>    z.detach();<EOL>    if (yWasRed) {<EOL>        recomputeMaxEndWalkToRoot(x.parent);<EOL>        if (y !== z) {<EOL>            recomputeMaxEndWalkToRoot(y);<EOL>            recomputeMaxEndWalkToRoot(y.parent);<EOL>        }<EOL>        resetSentinel();<EOL>        return;<EOL>    }<EOL>    recomputeMaxEndWalkToRoot(x);<EOL>    recomputeMaxEndWalkToRoot(x.parent);<EOL>    if (y !== z) {<EOL>        recomputeMaxEndWalkToRoot(y);<EOL>        recomputeMaxEndWalkToRoot(y.parent);<EOL>    }<EOL>    <EOL>    let w: IntervalNode;<EOL>    while (x !== T.root && getNodeColor(x) === NodeColor.Black) {<EOL>        if (x === x.parent.left) {<EOL>            w = x.parent.right;<EOL>            if (getNodeColor(w) === NodeColor.Red) {<EOL>                setNodeColor(w, NodeColor.Black);<EOL>                setNodeColor(x.parent, NodeColor.Red);<EOL>                leftRotate(T, x.parent);<EOL>                w = x.parent.right;<EOL>            }<EOL>            if (getNodeColor(w.left) === NodeColor.Black && getNodeColor(w.right) === NodeColor.Black) {<EOL>                setNodeColor(w, NodeColor.Red);<EOL>                x = x.parent;<EOL>            }<EOL>            else {<EOL>                if (getNodeColor(w.right) === NodeColor.Black) {<EOL>                    setNodeColor(w.left, NodeColor.Black);<EOL>                    setNodeColor(w, NodeColor.Red);<EOL>                    rightRotate(T, w);<EOL>                    w = x.parent.right;<EOL>                }<EOL>                setNodeColor(w, getNodeColor(x.parent));<EOL>                setNodeColor(x.parent, NodeColor.Black);<EOL>                setNodeColor(w.right, NodeColor.Black);<EOL>                leftRotate(T, x.parent);<EOL>                x = T.root;<EOL>            }<EOL>        }<EOL>        else {<EOL>            w = x.parent.","gt":"left;"}
{"input":"<s> <EOL><EOL>function rbTreeDelete(T: IntervalTree, z: IntervalNode): void {<EOL>    let x: IntervalNode;<EOL>    let y: IntervalNode;<EOL>    <EOL>    <EOL>    if (z.left === SENTINEL) {<EOL>        x = z.right;<EOL>        y = z;<EOL>        <EOL>        x.delta += z.delta;<EOL>        if (x.delta < Constants.MIN_SAFE_DELTA || x.delta > Constants.MAX_SAFE_DELTA) {<EOL>            T.requestNormalizeDelta = true;<EOL>        }<EOL>        x.start += z.delta;<EOL>        x.end += z.delta;<EOL>    }<EOL>    else if (z.right === SENTINEL) {<EOL>        x = z.left;<EOL>        y = z;<EOL>    }<EOL>    else {<EOL>        y = leftest(z.right);<EOL>        x = y.right;<EOL>        <EOL>        <EOL>        <EOL>        x.start += y.delta;<EOL>        x.end += y.delta;<EOL>        x.delta += y.delta;<EOL>        if (x.delta < Constants.MIN_SAFE_DELTA || x.delta > Constants.MAX_SAFE_DELTA) {<EOL>            T.requestNormalizeDelta = true;<EOL>        }<EOL>        y.start += z.delta;<EOL>        y.end += z.delta;<EOL>        y.delta = z.delta;<EOL>        if (y.delta < Constants.MIN_SAFE_DELTA || y.delta > Constants.MAX_SAFE_DELTA) {<EOL>            T.requestNormalizeDelta = true;<EOL>        }<EOL>    }<EOL>    if (y === T.root) {<EOL>        T.root = x;<EOL>        setNodeColor(x, NodeColor.Black);<EOL>        z.detach();<EOL>        resetSentinel();<EOL>        recomputeMaxEnd(x);<EOL>        T.root.parent = SENTINEL;<EOL>        return;<EOL>    }<EOL>    let yWasRed = (getNodeColor(y) === NodeColor.Red);<EOL>    if (y === y.parent.left) {<EOL>        y.parent.left = x;<EOL>    }<EOL>    else {<EOL>        y.parent.right = x;<EOL>    }<EOL>    if (y === z) {<EOL>        x.parent = y.parent;<EOL>    }<EOL>    else {<EOL>        if (y.parent === z) {<EOL>            x.parent = y;<EOL>        }<EOL>        else {<EOL>            x.parent = y.parent;<EOL>        }<EOL>        y.left = z.left;<EOL>        y.right = z.right;<EOL>        y.parent = z.parent;<EOL>        setNodeColor(y, getNodeColor(z));<EOL>        if (z === T.root) {<EOL>            T.root = y;<EOL>        }<EOL>        else {<EOL>            if (z === z.parent.left) {<EOL>                z.parent.left = y;<EOL>            }<EOL>            else {<EOL>                z.parent.right = y;<EOL>            }<EOL>        }<EOL>        if (y.left !== SENTINEL) {<EOL>            y.left.parent = y;<EOL>        }<EOL>        if (y.right !== SENTINEL) {<EOL>            y.right.parent = y;<EOL>        }<EOL>    }<EOL>    z.detach();<EOL>    if (yWasRed) {<EOL>        recomputeMaxEndWalkToRoot(x.parent);<EOL>        if (y !== z) {<EOL>            recomputeMaxEndWalkToRoot(y);<EOL>            recomputeMaxEndWalkToRoot(y.parent);<EOL>        }<EOL>        resetSentinel();<EOL>        return;<EOL>    }<EOL>    recomputeMaxEndWalkToRoot(x);<EOL>    recomputeMaxEndWalkToRoot(x.parent);<EOL>    if (y !== z) {<EOL>        recomputeMaxEndWalkToRoot(y);<EOL>        recomputeMaxEndWalkToRoot(y.parent);<EOL>    }<EOL>    <EOL>    let w: IntervalNode;<EOL>    while (x !== T.root && getNodeColor(x) === NodeColor.Black) {<EOL>        if (x === x.parent.left) {<EOL>            w = x.parent.right;<EOL>            if (getNodeColor(w) === NodeColor.Red) {<EOL>                setNodeColor(w, NodeColor.Black);<EOL>                setNodeColor(x.parent, NodeColor.Red);<EOL>                leftRotate(T, x.parent);<EOL>                w = x.parent.right;<EOL>            }<EOL>            if (getNodeColor(w.left) === NodeColor.Black && getNodeColor(w.right) === NodeColor.Black) {<EOL>                setNodeColor(w, NodeColor.Red);<EOL>                x = x.parent;<EOL>            }<EOL>            else {<EOL>                if (getNodeColor(w.right) === NodeColor.Black) {<EOL>                    setNodeColor(w.left, NodeColor.Black);<EOL>                    setNodeColor(w, NodeColor.Red);<EOL>                    rightRotate(T, w);<EOL>                    w = x.parent.right;<EOL>                }<EOL>                setNodeColor(w, getNodeColor(x.parent));<EOL>                setNodeColor(x.parent, NodeColor.Black);<EOL>                setNodeColor(w.right, NodeColor.Black);<EOL>                leftRotate(T, x.parent);<EOL>                x = T.root;<EOL>            }<EOL>        }<EOL>        else {<EOL>            w = x.parent.left;<EOL>            if (getNodeColor(w) === NodeColor.Red) {<EOL>                setNodeColor(w, NodeColor.Black);<EOL>                setNodeColor(x.parent, NodeColor.Red);<EOL>","gt":"rightRotate(T, x.parent);"}
{"input":"<s> <EOL><EOL>function rbTreeDelete(T: IntervalTree, z: IntervalNode): void {<EOL>    let x: IntervalNode;<EOL>    let y: IntervalNode;<EOL>    <EOL>    <EOL>    if (z.left === SENTINEL) {<EOL>        x = z.right;<EOL>        y = z;<EOL>        <EOL>        x.delta += z.delta;<EOL>        if (x.delta < Constants.MIN_SAFE_DELTA || x.delta > Constants.MAX_SAFE_DELTA) {<EOL>            T.requestNormalizeDelta = true;<EOL>        }<EOL>        x.start += z.delta;<EOL>        x.end += z.delta;<EOL>    }<EOL>    else if (z.right === SENTINEL) {<EOL>        x = z.left;<EOL>        y = z;<EOL>    }<EOL>    else {<EOL>        y = leftest(z.right);<EOL>        x = y.right;<EOL>        <EOL>        <EOL>        <EOL>        x.start += y.delta;<EOL>        x.end += y.delta;<EOL>        x.delta += y.delta;<EOL>        if (x.delta < Constants.MIN_SAFE_DELTA || x.delta > Constants.MAX_SAFE_DELTA) {<EOL>            T.requestNormalizeDelta = true;<EOL>        }<EOL>        y.start += z.delta;<EOL>        y.end += z.delta;<EOL>        y.delta = z.delta;<EOL>        if (y.delta < Constants.MIN_SAFE_DELTA || y.delta > Constants.MAX_SAFE_DELTA) {<EOL>            T.requestNormalizeDelta = true;<EOL>        }<EOL>    }<EOL>    if (y === T.root) {<EOL>        T.root = x;<EOL>        setNodeColor(x, NodeColor.Black);<EOL>        z.detach();<EOL>        resetSentinel();<EOL>        recomputeMaxEnd(x);<EOL>        T.root.parent = SENTINEL;<EOL>        return;<EOL>    }<EOL>    let yWasRed = (getNodeColor(y) === NodeColor.Red);<EOL>    if (y === y.parent.left) {<EOL>        y.parent.left = x;<EOL>    }<EOL>    else {<EOL>        y.parent.right = x;<EOL>    }<EOL>    if (y === z) {<EOL>        x.parent = y.parent;<EOL>    }<EOL>    else {<EOL>        if (y.parent === z) {<EOL>            x.parent = y;<EOL>        }<EOL>        else {<EOL>            x.parent = y.parent;<EOL>        }<EOL>        y.left = z.left;<EOL>        y.right = z.right;<EOL>        y.parent = z.parent;<EOL>        setNodeColor(y, getNodeColor(z));<EOL>        if (z === T.root) {<EOL>            T.root = y;<EOL>        }<EOL>        else {<EOL>            if (z === z.parent.left) {<EOL>                z.parent.left = y;<EOL>            }<EOL>            else {<EOL>                z.parent.right = y;<EOL>            }<EOL>        }<EOL>        if (y.left !== SENTINEL) {<EOL>            y.left.parent = y;<EOL>        }<EOL>        if (y.right !== SENTINEL) {<EOL>            y.right.parent = y;<EOL>        }<EOL>    }<EOL>    z.detach();<EOL>    if (yWasRed) {<EOL>        recomputeMaxEndWalkToRoot(x.parent);<EOL>        if (y !== z) {<EOL>            recomputeMaxEndWalkToRoot(y);<EOL>            recomputeMaxEndWalkToRoot(y.parent);<EOL>        }<EOL>        resetSentinel();<EOL>        return;<EOL>    }<EOL>    recomputeMaxEndWalkToRoot(x);<EOL>    recomputeMaxEndWalkToRoot(x.parent);<EOL>    if (y !== z) {<EOL>        recomputeMaxEndWalkToRoot(y);<EOL>        recomputeMaxEndWalkToRoot(y.parent);<EOL>    }<EOL>    <EOL>    let w: IntervalNode;<EOL>    while (x !== T.root && getNodeColor(x) === NodeColor.Black) {<EOL>        if (x === x.parent.left) {<EOL>            w = x.parent.right;<EOL>            if (getNodeColor(w) === NodeColor.Red) {<EOL>                setNodeColor(w, NodeColor.Black);<EOL>                setNodeColor(x.parent, NodeColor.Red);<EOL>                leftRotate(T, x.parent);<EOL>                w = x.parent.right;<EOL>            }<EOL>            if (getNodeColor(w.left) === NodeColor.Black && getNodeColor(w.right) === NodeColor.Black) {<EOL>                setNodeColor(w, NodeColor.Red);<EOL>                x = x.parent;<EOL>            }<EOL>            else {<EOL>                if (getNodeColor(w.right) === NodeColor.Black) {<EOL>                    setNodeColor(w.left, NodeColor.Black);<EOL>                    setNodeColor(w, NodeColor.Red);<EOL>                    rightRotate(T, w);<EOL>                    w = x.parent.right;<EOL>                }<EOL>                setNodeColor(w, getNodeColor(x.parent));<EOL>                setNodeColor(x.parent, NodeColor.Black);<EOL>                setNodeColor(w.right, NodeColor.Black);<EOL>                leftRotate(T, x.parent);<EOL>                x = T.root;<EOL>            }<EOL>        }<EOL>        else {<EOL>            w = x.parent.left;<EOL>            if (getNodeColor(w) === NodeColor.Red) {<EOL>                setNodeColor(w, NodeColor.Black);<EOL>                setNodeColor(x.parent, NodeColor.Red);<EOL>                rightRotate(T, x.parent);<EOL>                w = x.parent.left;<EOL>            }<EOL>            if (getNodeColor(w.left) ===","gt":"NodeColor.Black && getNodeColor(w.right) === NodeColor.Black) {"}
{"input":"<s> <EOL><EOL>function rbTreeDelete(T: IntervalTree, z: IntervalNode): void {<EOL>    let x: IntervalNode;<EOL>    let y: IntervalNode;<EOL>    <EOL>    <EOL>    if (z.left === SENTINEL) {<EOL>        x = z.right;<EOL>        y = z;<EOL>        <EOL>        x.delta += z.delta;<EOL>        if (x.delta < Constants.MIN_SAFE_DELTA || x.delta > Constants.MAX_SAFE_DELTA) {<EOL>            T.requestNormalizeDelta = true;<EOL>        }<EOL>        x.start += z.delta;<EOL>        x.end += z.delta;<EOL>    }<EOL>    else if (z.right === SENTINEL) {<EOL>        x = z.left;<EOL>        y = z;<EOL>    }<EOL>    else {<EOL>        y = leftest(z.right);<EOL>        x = y.right;<EOL>        <EOL>        <EOL>        <EOL>        x.start += y.delta;<EOL>        x.end += y.delta;<EOL>        x.delta += y.delta;<EOL>        if (x.delta < Constants.MIN_SAFE_DELTA || x.delta > Constants.MAX_SAFE_DELTA) {<EOL>            T.requestNormalizeDelta = true;<EOL>        }<EOL>        y.start += z.delta;<EOL>        y.end += z.delta;<EOL>        y.delta = z.delta;<EOL>        if (y.delta < Constants.MIN_SAFE_DELTA || y.delta > Constants.MAX_SAFE_DELTA) {<EOL>            T.requestNormalizeDelta = true;<EOL>        }<EOL>    }<EOL>    if (y === T.root) {<EOL>        T.root = x;<EOL>        setNodeColor(x, NodeColor.Black);<EOL>        z.detach();<EOL>        resetSentinel();<EOL>        recomputeMaxEnd(x);<EOL>        T.root.parent = SENTINEL;<EOL>        return;<EOL>    }<EOL>    let yWasRed = (getNodeColor(y) === NodeColor.Red);<EOL>    if (y === y.parent.left) {<EOL>        y.parent.left = x;<EOL>    }<EOL>    else {<EOL>        y.parent.right = x;<EOL>    }<EOL>    if (y === z) {<EOL>        x.parent = y.parent;<EOL>    }<EOL>    else {<EOL>        if (y.parent === z) {<EOL>            x.parent = y;<EOL>        }<EOL>        else {<EOL>            x.parent = y.parent;<EOL>        }<EOL>        y.left = z.left;<EOL>        y.right = z.right;<EOL>        y.parent = z.parent;<EOL>        setNodeColor(y, getNodeColor(z));<EOL>        if (z === T.root) {<EOL>            T.root = y;<EOL>        }<EOL>        else {<EOL>            if (z === z.parent.left) {<EOL>                z.parent.left = y;<EOL>            }<EOL>            else {<EOL>                z.parent.right = y;<EOL>            }<EOL>        }<EOL>        if (y.left !== SENTINEL) {<EOL>            y.left.parent = y;<EOL>        }<EOL>        if (y.right !== SENTINEL) {<EOL>            y.right.parent = y;<EOL>        }<EOL>    }<EOL>    z.detach();<EOL>    if (yWasRed) {<EOL>        recomputeMaxEndWalkToRoot(x.parent);<EOL>        if (y !== z) {<EOL>            recomputeMaxEndWalkToRoot(y);<EOL>            recomputeMaxEndWalkToRoot(y.parent);<EOL>        }<EOL>        resetSentinel();<EOL>        return;<EOL>    }<EOL>    recomputeMaxEndWalkToRoot(x);<EOL>    recomputeMaxEndWalkToRoot(x.parent);<EOL>    if (y !== z) {<EOL>        recomputeMaxEndWalkToRoot(y);<EOL>        recomputeMaxEndWalkToRoot(y.parent);<EOL>    }<EOL>    <EOL>    let w: IntervalNode;<EOL>    while (x !== T.root && getNodeColor(x) === NodeColor.Black) {<EOL>        if (x === x.parent.left) {<EOL>            w = x.parent.right;<EOL>            if (getNodeColor(w) === NodeColor.Red) {<EOL>                setNodeColor(w, NodeColor.Black);<EOL>                setNodeColor(x.parent, NodeColor.Red);<EOL>                leftRotate(T, x.parent);<EOL>                w = x.parent.right;<EOL>            }<EOL>            if (getNodeColor(w.left) === NodeColor.Black && getNodeColor(w.right) === NodeColor.Black) {<EOL>                setNodeColor(w, NodeColor.Red);<EOL>                x = x.parent;<EOL>            }<EOL>            else {<EOL>                if (getNodeColor(w.right) === NodeColor.Black) {<EOL>                    setNodeColor(w.left, NodeColor.Black);<EOL>                    setNodeColor(w, NodeColor.Red);<EOL>                    rightRotate(T, w);<EOL>                    w = x.parent.right;<EOL>                }<EOL>                setNodeColor(w, getNodeColor(x.parent));<EOL>                setNodeColor(x.parent, NodeColor.Black);<EOL>                setNodeColor(w.right, NodeColor.Black);<EOL>                leftRotate(T, x.parent);<EOL>                x = T.root;<EOL>            }<EOL>        }<EOL>        else {<EOL>            w = x.parent.left;<EOL>            if (getNodeColor(w) === NodeColor.Red) {<EOL>                setNodeColor(w, NodeColor.Black);<EOL>                setNodeColor(x.parent, NodeColor.Red);<EOL>                rightRotate(T, x.parent);<EOL>                w = x.parent.left;<EOL>            }<EOL>            if (getNodeColor(w.left) === NodeColor.Black && getNodeColor(w.right) === NodeColor.Black) {<EOL>                setNodeColor(w, NodeColor.Red);<EOL>","gt":"x = x.parent;"}
{"input":"<s> <EOL><EOL>function rbTreeDelete(T: IntervalTree, z: IntervalNode): void {<EOL>    let x: IntervalNode;<EOL>    let y: IntervalNode;<EOL>    <EOL>    <EOL>    if (z.left === SENTINEL) {<EOL>        x = z.right;<EOL>        y = z;<EOL>        <EOL>        x.delta += z.delta;<EOL>        if (x.delta < Constants.MIN_SAFE_DELTA || x.delta > Constants.MAX_SAFE_DELTA) {<EOL>            T.requestNormalizeDelta = true;<EOL>        }<EOL>        x.start += z.delta;<EOL>        x.end += z.delta;<EOL>    }<EOL>    else if (z.right === SENTINEL) {<EOL>        x = z.left;<EOL>        y = z;<EOL>    }<EOL>    else {<EOL>        y = leftest(z.right);<EOL>        x = y.right;<EOL>        <EOL>        <EOL>        <EOL>        x.start += y.delta;<EOL>        x.end += y.delta;<EOL>        x.delta += y.delta;<EOL>        if (x.delta < Constants.MIN_SAFE_DELTA || x.delta > Constants.MAX_SAFE_DELTA) {<EOL>            T.requestNormalizeDelta = true;<EOL>        }<EOL>        y.start += z.delta;<EOL>        y.end += z.delta;<EOL>        y.delta = z.delta;<EOL>        if (y.delta < Constants.MIN_SAFE_DELTA || y.delta > Constants.MAX_SAFE_DELTA) {<EOL>            T.requestNormalizeDelta = true;<EOL>        }<EOL>    }<EOL>    if (y === T.root) {<EOL>        T.root = x;<EOL>        setNodeColor(x, NodeColor.Black);<EOL>        z.detach();<EOL>        resetSentinel();<EOL>        recomputeMaxEnd(x);<EOL>        T.root.parent = SENTINEL;<EOL>        return;<EOL>    }<EOL>    let yWasRed = (getNodeColor(y) === NodeColor.Red);<EOL>    if (y === y.parent.left) {<EOL>        y.parent.left = x;<EOL>    }<EOL>    else {<EOL>        y.parent.right = x;<EOL>    }<EOL>    if (y === z) {<EOL>        x.parent = y.parent;<EOL>    }<EOL>    else {<EOL>        if (y.parent === z) {<EOL>            x.parent = y;<EOL>        }<EOL>        else {<EOL>            x.parent = y.parent;<EOL>        }<EOL>        y.left = z.left;<EOL>        y.right = z.right;<EOL>        y.parent = z.parent;<EOL>        setNodeColor(y, getNodeColor(z));<EOL>        if (z === T.root) {<EOL>            T.root = y;<EOL>        }<EOL>        else {<EOL>            if (z === z.parent.left) {<EOL>                z.parent.left = y;<EOL>            }<EOL>            else {<EOL>                z.parent.right = y;<EOL>            }<EOL>        }<EOL>        if (y.left !== SENTINEL) {<EOL>            y.left.parent = y;<EOL>        }<EOL>        if (y.right !== SENTINEL) {<EOL>            y.right.parent = y;<EOL>        }<EOL>    }<EOL>    z.detach();<EOL>    if (yWasRed) {<EOL>        recomputeMaxEndWalkToRoot(x.parent);<EOL>        if (y !== z) {<EOL>            recomputeMaxEndWalkToRoot(y);<EOL>            recomputeMaxEndWalkToRoot(y.parent);<EOL>        }<EOL>        resetSentinel();<EOL>        return;<EOL>    }<EOL>    recomputeMaxEndWalkToRoot(x);<EOL>    recomputeMaxEndWalkToRoot(x.parent);<EOL>    if (y !== z) {<EOL>        recomputeMaxEndWalkToRoot(y);<EOL>        recomputeMaxEndWalkToRoot(y.parent);<EOL>    }<EOL>    <EOL>    let w: IntervalNode;<EOL>    while (x !== T.root && getNodeColor(x) === NodeColor.Black) {<EOL>        if (x === x.parent.left) {<EOL>            w = x.parent.right;<EOL>            if (getNodeColor(w) === NodeColor.Red) {<EOL>                setNodeColor(w, NodeColor.Black);<EOL>                setNodeColor(x.parent, NodeColor.Red);<EOL>                leftRotate(T, x.parent);<EOL>                w = x.parent.right;<EOL>            }<EOL>            if (getNodeColor(w.left) === NodeColor.Black && getNodeColor(w.right) === NodeColor.Black) {<EOL>                setNodeColor(w, NodeColor.Red);<EOL>                x = x.parent;<EOL>            }<EOL>            else {<EOL>                if (getNodeColor(w.right) === NodeColor.Black) {<EOL>                    setNodeColor(w.left, NodeColor.Black);<EOL>                    setNodeColor(w, NodeColor.Red);<EOL>                    rightRotate(T, w);<EOL>                    w = x.parent.right;<EOL>                }<EOL>                setNodeColor(w, getNodeColor(x.parent));<EOL>                setNodeColor(x.parent, NodeColor.Black);<EOL>                setNodeColor(w.right, NodeColor.Black);<EOL>                leftRotate(T, x.parent);<EOL>                x = T.root;<EOL>            }<EOL>        }<EOL>        else {<EOL>            w = x.parent.left;<EOL>            if (getNodeColor(w) === NodeColor.Red) {<EOL>                setNodeColor(w, NodeColor.Black);<EOL>                setNodeColor(x.parent, NodeColor.Red);<EOL>                rightRotate(T, x.parent);<EOL>                w = x.parent.left;<EOL>            }<EOL>            if (getNodeColor(w.left) === NodeColor.Black && getNodeColor(w.right) === NodeColor.Black) {<EOL>                setNodeColor(w, NodeColor.Red);<EOL>                x = x.parent;<EOL>            }<EOL>            else {<EOL>                if (getNodeColor(w.left) === NodeColor.Black) {<EOL>                    setNodeColor(w.right, NodeColor.Black);<EOL>                    setNodeColor(","gt":"w, NodeColor.Red);"}
{"input":"<s> function assertFired(component: EmberishGlimmerComponent, name: string, count = <NUM_LIT>) {<EOL>    let hooks = component['<STR_LIT>'];<EOL>    if (!hooks) {<EOL>        throw new TypeError(\"<STR_LIT>\" + component);<EOL>    }<EOL>    if (name in hooks) {<EOL>        assert.strictEqual(hooks[name], count, `<STR_LIT>`);<EOL>    }<EOL>","gt":"else {"}
{"input":"<s> /**<EOL> * @param {number} due<EOL> * @param {Scheduler} [scheduler]<EOL> * @return {Observable<R>|WebSocketSubject<T>|Observable<T>}<EOL> * @method timeout<EOL> * @owner Observable<EOL> */<EOL>export function timeout<T>(this: Observable<T>, due: number | Date, scheduler: IScheduler = async): Observable<T> {<EOL>","gt":"const absoluteTimeout = isDate(due);"}
{"input":"<s> <EOL>/**<EOL> * Emits only the first value emitted by the source Observable that meets some<EOL> * condition.<EOL> *<EOL> * <span class=\"informal\">Finds the first value that passes some test and emits<EOL> * that.</span><EOL> *<EOL> * <img src=\"./img/find.png\" width=\"100%\"><EOL> *<EOL> * `find` searches for the first item in the source Observable that matches the<EOL> * specified condition embodied by the `predicate`, and returns the first<EOL> * occurrence in the source. Unlike {@link first}, the `predicate` is required<EOL> * in `find`, and does not emit an error if a valid value is not found.<EOL> *<EOL> * @example <caption>Find and emit the first click that happens on a DIV element</caption><EOL> * var clicks = Rx.Observable.fromEvent(document, 'click');<EOL> * var result = clicks.find(ev => ev.target.tagName === 'DIV');<EOL> * result.subscribe(x => console.log(x));<EOL> *<EOL> * @see {@link filter}<EOL> * @see {@link first}<EOL> * @see {@link findIndex}<EOL> * @see {@link take}<EOL> *<EOL> * @param {function(value: T, index: number, source: Observable<T>): boolean} predicate<EOL> * A function called with each item to test for condition matching.<EOL> * @param {any} [thisArg] An optional argument to determine the value of `this`<EOL> * in the `predicate` function.<EOL> * @return {Observable<T>} An Observable of the first item that matches the<EOL> * condition.<EOL> * @method find<EOL> * @owner Observable<EOL> */<EOL>export function find<T>(this: Observable<T>, predicate: (value: T, index: number, source: Observable<T>) => boolean, thisArg?: any): Observable<T> {<EOL>    if (typeof predicate !== '<STR_LIT>') {<EOL>        throw new","gt":"TypeError('<STR_LIT>');"}
{"input":"<s> <EOL>/**<EOL> * Emits a given value if the source Observable completes without emitting any<EOL> * `next` value, otherwise mirrors the source Observable.<EOL> *<EOL> * <span class=\"informal\">If the source Observable turns out to be empty, then<EOL> * this operator will emit a default value.</span><EOL> *<EOL> * <img src=\"./img/defaultIfEmpty.png\" width=\"100%\"><EOL> *<EOL> * `defaultIfEmpty` emits the values emitted by the source Observable or a<EOL> * specified default value if the source Observable is empty (completes without<EOL> * having emitted any `next` value).<EOL> *<EOL> * @example <caption>If no clicks happen in 5 seconds, then emit \"no clicks\"</caption><EOL> * var clicks = Rx.Observable.fromEvent(document, 'click');<EOL> * var clicksBeforeFive = clicks.takeUntil(Rx.Observable.interval(5000));<EOL> * var result = clicksBeforeFive.defaultIfEmpty('no clicks');<EOL> * result.subscribe(x => console.log(x));<EOL> *<EOL> * @see {@link empty}<EOL> * @see {@link last}<EOL> *<EOL> * @param {any} [defaultValue=null] The default value used if the source<EOL> * Observable is empty.<EOL> * @return {Observable} An Observable that emits either the specified<EOL> * `defaultValue` if the source Observable emits no items, or the values emitted<EOL> * by the source Observable.<EOL> * @method defaultIfEmpty<EOL> * @owner Observable<EOL> */<EOL>export function defaultIfEmpty<T, R>(this: Observable<T>, defaultValue: R = null): Observable<T | R> {<EOL>","gt":"return this.lift(new DefaultIfEmptyOperator(defaultValue));"}
{"input":"<s> /**<EOL> * Emits the most recently emitted value from the source Observable whenever<EOL> * another Observable, the `notifier`, emits.<EOL> *<EOL> * <span class=\"informal\">It's like {@link sampleTime}, but samples whenever<EOL> * the `notifier` Observable emits something.</span><EOL> *<EOL> * <img src=\"./img/sample.png\" width=\"100%\"><EOL> *<EOL> * Whenever the `notifier` Observable emits a value or completes, `sample`<EOL> * looks at the source Observable and emits whichever value it has most recently<EOL> * emitted since the previous sampling, unless the source has not emitted<EOL> * anything since the previous sampling. The `notifier` is subscribed to as soon<EOL> * as the output Observable is subscribed.<EOL> *<EOL> * @example <caption>On every click, sample the most recent \"seconds\" timer</caption><EOL> * var seconds = Rx.Observable.interval(1000);<EOL> * var clicks = Rx.Observable.fromEvent(document, 'click');<EOL> * var result = seconds.sample(clicks);<EOL> * result.subscribe(x => console.log(x));<EOL> *<EOL> * @see {@link audit}<EOL> * @see {@link debounce}<EOL> * @see {@link sampleTime}<EOL> * @see {@link throttle}<EOL> *<EOL> * @param {Observable<any>} notifier The Observable to use for sampling the<EOL> * source Observable.<EOL> * @return {Observable<T>} An Observable that emits the results of sampling the<EOL> * values emitted by the source Observable whenever the notifier Observable<EOL> * emits value or completes.<EOL> * @method sample<EOL> * @owner Observable<EOL> */<EOL>export function sample<T>(this: Observable<T>, notifier: Observable<any>): Observable<T> {<EOL>    return this.lift(","gt":"new SampleOperator(notifier));"}
{"input":"<s> function getDirectiveMatcher(directives: (RemoveDirectiveConfig | GetDirectiveConfig)[]) {<EOL>    return function directiveMatcher(directive: DirectiveNode): Boolean {<EOL>        return directives.some((dir: RemoveDirectiveConfig | GetDirectiveConfig) => {<EOL>            if (dir.name && dir.name ===","gt":"directive.name.value)"}
{"input":"<s> function typeToAst(type: GraphQLInputType): TypeNode {<EOL>    if (type instanceof GraphQLNonNull) {<EOL>        const innerType = typeToAst(type.ofType);<EOL>        if (innerType.kind === Kind.LIST_TYPE ||<EOL>            innerType.kind === Kind.NAMED_TYPE) {<EOL>            return {<EOL>                kind: Kind.","gt":"NON_NULL_TYPE,"}
{"input":"<s> function typeToAst(type: GraphQLInputType): TypeNode {<EOL>    if (type instanceof GraphQLNonNull) {<EOL>        const innerType = typeToAst(type.ofType);<EOL>        if (innerType.kind === Kind.LIST_TYPE ||<EOL>            innerType.kind === Kind.NAMED_TYPE) {<EOL>            return {<EOL>                kind: Kind.NON_NULL_TYPE,<EOL>                type: innerType,<EOL>            };<EOL>        }<EOL>        else {<EOL>            throw new Error('<STR_LIT>');<EOL>        }<EOL>    }<EOL>    else if (type instanceof GraphQLList) {<EOL>","gt":"return {"}
{"input":"<s> function typeToAst(type: GraphQLInputType): TypeNode {<EOL>    if (type instanceof GraphQLNonNull) {<EOL>        const innerType = typeToAst(type.ofType);<EOL>        if (innerType.kind === Kind.LIST_TYPE ||<EOL>            innerType.kind === Kind.NAMED_TYPE) {<EOL>            return {<EOL>                kind: Kind.NON_NULL_TYPE,<EOL>                type: innerType,<EOL>            };<EOL>        }<EOL>        else {<EOL>            throw new Error('<STR_LIT>');<EOL>        }<EOL>    }<EOL>    else if (type instanceof GraphQLList) {<EOL>        return {<EOL>            kind: Kind.LIST_TYPE,<EOL>            type: typeToAst(type.ofType),<EOL>        };<EOL>    }<EOL>    else {<EOL>        return {<EOL>            kind:","gt":"Kind.NAMED_TYPE,"}
{"input":"<s> function makeInterfaceType(typeRegistry: TypeRegistry, node: InterfaceTypeDefinitionNode): GraphQLInterfaceType {<EOL>    return new GraphQLInterfaceType({<EOL>        name:","gt":"node.name.value,"}
{"input":"<s> function concatErrors(errors: Error[]) {<EOL>","gt":"return errors.map(error => error.message).join('<STR_LIT>');"}
{"input":"<s> <EOL>function deepFreeze(o: any) {<EOL>    Object.freeze(o);<EOL>    Object.getOwnPropertyNames(o).forEach(function (prop) {<EOL>        if (o.hasOwnProperty(prop) &&<EOL>            o[","gt":"prop] !== null &&"}
{"input":"<s> function f82() {<EOL>    let x1 = f81({ a: { x:","gt":"\"<STR_LIT>\" } });"}
{"input":"<s> function objectHash(obj: any, initialHashVal: number): number {<EOL>    initialHashVal = numberHash(<NUM_LIT>, initialHashVal);<EOL>    return Object.","gt":"keys(obj).sort().reduce((hashVal, key) => {"}
{"input":"<s> function createEditableTextModelFromString(text: string): TextModel {<EOL>    return new","gt":"TextModel(text, TextModel.DEFAULT_CREATION_OPTIONS, null);"}
{"input":"<s> async function func(): Promise<void> {<EOL>","gt":"before();"}
{"input":"<s> function moduleIdToPath(out: string, moduleId: string): string {<EOL>    if (/\\.d\\.ts/.test(moduleId)) {<EOL>        return path.","gt":"join(SRC, moduleId);"}
{"input":"<s> function removeDuplicateTSBoilerplate(destFiles: IConcatFile[]): IConcatFile[] {<EOL>    <EOL>    let BOILERPLATE = [<EOL>        { start: /^var __extends/, end: /^};$/ },<EOL>        { start:","gt":"/^var __assign/, end: /^};$/ },"}
{"input":"<s> function removeDuplicateTSBoilerplate(destFiles: IConcatFile[]): IConcatFile[] {<EOL>    <EOL>    let BOILERPLATE = [<EOL>        { start: /^var __extends/, end: /^};$/ },<EOL>        { start: /^var __assign/, end: /^};$/ },<EOL>        { start: /^var __decorate/, end: /^};$/ },<EOL>        { start: /^var __metadata/,","gt":"end: /^};$/ },"}
{"input":"<s> function removeDuplicateTSBoilerplate(destFiles: IConcatFile[]): IConcatFile[] {<EOL>    <EOL>    let BOILERPLATE = [<EOL>        { start: /^var __extends/, end: /^};$/ },<EOL>        { start: /^var __assign/, end: /^};$/ },<EOL>        { start: /^var __decorate/, end: /^};$/ },<EOL>        { start: /^var __metadata/, end: /^};$/ },<EOL>        { start: /^var __param/, end: /^};$/ },<EOL>        { start: /^var __awaiter/, end: /^};$/ },<EOL>    ];<EOL>    destFiles.forEach((destFile) => {<EOL>        let SEEN_BOILERPLATE = [];<EOL>        destFile.sources.forEach((source) => {<EOL>            let lines = source.contents.split(/\\r\\n|\\n|\\r/);<EOL>            let newLines: string[] = [];<EOL>","gt":"let IS_REMOVING_BOILERPLATE = false, END_BOILERPLATE: RegExp;"}
{"input":"<s> function removeDuplicateTSBoilerplate(destFiles: IConcatFile[]): IConcatFile[] {<EOL>    <EOL>    let BOILERPLATE = [<EOL>        { start: /^var __extends/, end: /^};$/ },<EOL>        { start: /^var __assign/, end: /^};$/ },<EOL>        { start: /^var __decorate/, end: /^};$/ },<EOL>        { start: /^var __metadata/, end: /^};$/ },<EOL>        { start: /^var __param/, end: /^};$/ },<EOL>        { start: /^var __awaiter/, end: /^};$/ },<EOL>    ];<EOL>    destFiles.forEach((destFile) => {<EOL>        let SEEN_BOILERPLATE = [];<EOL>        destFile.sources.forEach((source) => {<EOL>            let lines = source.contents.split(/\\r\\n|\\n|\\r/);<EOL>            let newLines: string[] = [];<EOL>            let IS_REMOVING_BOILERPLATE = false, END_BOILERPLATE: RegExp;<EOL>            for (let i = <NUM_LIT>; i < lines.length; i++) {<EOL>                let line = lines[i];<EOL>                if (IS_REMOVING_BOILERPLATE) {<EOL>                    newLines.push('<STR_LIT>');<EOL>","gt":"if (END_BOILERPLATE.test(line)) {"}
{"input":"<s> function removeDuplicateTSBoilerplate(destFiles: IConcatFile[]): IConcatFile[] {<EOL>    <EOL>    let BOILERPLATE = [<EOL>        { start: /^var __extends/, end: /^};$/ },<EOL>        { start: /^var __assign/, end: /^};$/ },<EOL>        { start: /^var __decorate/, end: /^};$/ },<EOL>        { start: /^var __metadata/, end: /^};$/ },<EOL>        { start: /^var __param/, end: /^};$/ },<EOL>        { start: /^var __awaiter/, end: /^};$/ },<EOL>    ];<EOL>    destFiles.forEach((destFile) => {<EOL>        let SEEN_BOILERPLATE = [];<EOL>        destFile.sources.forEach((source) => {<EOL>            let lines = source.contents.split(/\\r\\n|\\n|\\r/);<EOL>            let newLines: string[] = [];<EOL>            let IS_REMOVING_BOILERPLATE = false, END_BOILERPLATE: RegExp;<EOL>            for (let i = <NUM_LIT>; i < lines.length; i++) {<EOL>                let line = lines[i];<EOL>                if (IS_REMOVING_BOILERPLATE) {<EOL>                    newLines.push('<STR_LIT>');<EOL>                    if (END_BOILERPLATE.test(line)) {<EOL>                        IS_REMOVING_BOILERPLATE = false;<EOL>                    }<EOL>                }<EOL>                else {<EOL>                    for (let j = <NUM_LIT>; j < BOILERPLATE.length; j++) {<EOL>                        let boilerplate =","gt":"BOILERPLATE[j];"}
{"input":"<s> function removeDuplicateTSBoilerplate(destFiles: IConcatFile[]): IConcatFile[] {<EOL>    <EOL>    let BOILERPLATE = [<EOL>        { start: /^var __extends/, end: /^};$/ },<EOL>        { start: /^var __assign/, end: /^};$/ },<EOL>        { start: /^var __decorate/, end: /^};$/ },<EOL>        { start: /^var __metadata/, end: /^};$/ },<EOL>        { start: /^var __param/, end: /^};$/ },<EOL>        { start: /^var __awaiter/, end: /^};$/ },<EOL>    ];<EOL>    destFiles.forEach((destFile) => {<EOL>        let SEEN_BOILERPLATE = [];<EOL>        destFile.sources.forEach((source) => {<EOL>            let lines = source.contents.split(/\\r\\n|\\n|\\r/);<EOL>            let newLines: string[] = [];<EOL>            let IS_REMOVING_BOILERPLATE = false, END_BOILERPLATE: RegExp;<EOL>            for (let i = <NUM_LIT>; i < lines.length; i++) {<EOL>                let line = lines[i];<EOL>                if (IS_REMOVING_BOILERPLATE) {<EOL>                    newLines.push('<STR_LIT>');<EOL>                    if (END_BOILERPLATE.test(line)) {<EOL>                        IS_REMOVING_BOILERPLATE = false;<EOL>                    }<EOL>                }<EOL>                else {<EOL>                    for (let j = <NUM_LIT>; j < BOILERPLATE.length; j++) {<EOL>                        let boilerplate = BOILERPLATE[j];<EOL>                        if (boilerplate.start.test(line)) {<EOL>                            if (SEEN_BOILERPLATE[j]) {<EOL>                                IS_REMOVING_BOILERPLATE = true;<EOL>                                END_BOILERPLATE = boilerplate.end;<EOL>                            }<EOL>                            else {<EOL>                                SEEN_BOILERPLATE[j] = true;<EOL>                            }<EOL>                        }<EOL>                    }<EOL>","gt":"if (IS_REMOVING_BOILERPLATE) {"}
{"input":"<s> function removeDuplicateTSBoilerplate(destFiles: IConcatFile[]): IConcatFile[] {<EOL>    <EOL>    let BOILERPLATE = [<EOL>        { start: /^var __extends/, end: /^};$/ },<EOL>        { start: /^var __assign/, end: /^};$/ },<EOL>        { start: /^var __decorate/, end: /^};$/ },<EOL>        { start: /^var __metadata/, end: /^};$/ },<EOL>        { start: /^var __param/, end: /^};$/ },<EOL>        { start: /^var __awaiter/, end: /^};$/ },<EOL>    ];<EOL>    destFiles.forEach((destFile) => {<EOL>        let SEEN_BOILERPLATE = [];<EOL>        destFile.sources.forEach((source) => {<EOL>            let lines = source.contents.split(/\\r\\n|\\n|\\r/);<EOL>            let newLines: string[] = [];<EOL>            let IS_REMOVING_BOILERPLATE = false, END_BOILERPLATE: RegExp;<EOL>            for (let i = <NUM_LIT>; i < lines.length; i++) {<EOL>                let line = lines[i];<EOL>                if (IS_REMOVING_BOILERPLATE) {<EOL>                    newLines.push('<STR_LIT>');<EOL>                    if (END_BOILERPLATE.test(line)) {<EOL>                        IS_REMOVING_BOILERPLATE = false;<EOL>                    }<EOL>                }<EOL>                else {<EOL>                    for (let j = <NUM_LIT>; j < BOILERPLATE.length; j++) {<EOL>                        let boilerplate = BOILERPLATE[j];<EOL>                        if (boilerplate.start.test(line)) {<EOL>                            if (SEEN_BOILERPLATE[j]) {<EOL>                                IS_REMOVING_BOILERPLATE = true;<EOL>                                END_BOILERPLATE = boilerplate.end;<EOL>                            }<EOL>                            else {<EOL>                                SEEN_BOILERPLATE[j] = true;<EOL>                            }<EOL>                        }<EOL>                    }<EOL>                    if (IS_REMOVING_BOILERPLATE) {<EOL>                        newLines.push('<STR_LIT>');<EOL>                    }<EOL>","gt":"else {"}
{"input":"<s> export function fileTransformations(isFolderBasedDeployment: boolean, JSONFiles: any, xmlTransformation: boolean, xmlVariableSubstitution: boolean, folderPath: string, isMSBuildPackage: boolean) {<EOL>    if (xmlTransformation) {<EOL>        if (isMSBuildPackage) {<EOL>            var","gt":"debugMode = tl.getVariable('<STR_LIT>');"}
{"input":"<s> export function fileTransformations(isFolderBasedDeployment: boolean, JSONFiles: any, xmlTransformation: boolean, xmlVariableSubstitution: boolean, folderPath: string, isMSBuildPackage: boolean) {<EOL>    if (xmlTransformation) {<EOL>        if (isMSBuildPackage) {<EOL>            var debugMode = tl.getVariable('<STR_LIT>');<EOL>            if (debugMode && debugMode.toLowerCase() == '<STR_LIT>') {<EOL>                tl.warning(tl.loc('<STR_LIT>'));<EOL>            }<EOL>","gt":"else {"}
{"input":"<s> export function fileTransformations(isFolderBasedDeployment: boolean, JSONFiles: any, xmlTransformation: boolean, xmlVariableSubstitution: boolean, folderPath: string, isMSBuildPackage: boolean) {<EOL>    if (xmlTransformation) {<EOL>        if (isMSBuildPackage) {<EOL>            var debugMode = tl.getVariable('<STR_LIT>');<EOL>            if (debugMode && debugMode.toLowerCase() == '<STR_LIT>') {<EOL>                tl.warning(tl.loc('<STR_LIT>'));<EOL>            }<EOL>            else {<EOL>                console.log(tl.loc('<STR_LIT>'));<EOL>            }<EOL>        }<EOL>        var environmentName =","gt":"tl.getVariable('<STR_LIT>');"}
{"input":"<s> export function fileTransformations(isFolderBasedDeployment: boolean, JSONFiles: any, xmlTransformation: boolean, xmlVariableSubstitution: boolean, folderPath: string, isMSBuildPackage: boolean) {<EOL>    if (xmlTransformation) {<EOL>        if (isMSBuildPackage) {<EOL>            var debugMode = tl.getVariable('<STR_LIT>');<EOL>            if (debugMode && debugMode.toLowerCase() == '<STR_LIT>') {<EOL>                tl.warning(tl.loc('<STR_LIT>'));<EOL>            }<EOL>            else {<EOL>                console.log(tl.loc('<STR_LIT>'));<EOL>            }<EOL>        }<EOL>        var environmentName = tl.getVariable('<STR_LIT>');<EOL>        if (tl.osType().match(/^Win/)) {<EOL>            var transformConfigs = [\"<STR_LIT>\"];<EOL>            if (environmentName && environmentName.","gt":"toLowerCase() != '<STR_LIT>') {"}
{"input":"<s> export function fileTransformations(isFolderBasedDeployment: boolean, JSONFiles: any, xmlTransformation: boolean, xmlVariableSubstitution: boolean, folderPath: string, isMSBuildPackage: boolean) {<EOL>    if (xmlTransformation) {<EOL>        if (isMSBuildPackage) {<EOL>            var debugMode = tl.getVariable('<STR_LIT>');<EOL>            if (debugMode && debugMode.toLowerCase() == '<STR_LIT>') {<EOL>                tl.warning(tl.loc('<STR_LIT>'));<EOL>            }<EOL>            else {<EOL>                console.log(tl.loc('<STR_LIT>'));<EOL>            }<EOL>        }<EOL>        var environmentName = tl.getVariable('<STR_LIT>');<EOL>        if (tl.osType().match(/^Win/)) {<EOL>            var transformConfigs = [\"<STR_LIT>\"];<EOL>            if (environmentName && environmentName.toLowerCase() != '<STR_LIT>') {<EOL>                transformConfigs.push(environmentName + \"<STR_LIT>\");<EOL>            }<EOL>            var isTransformationApplied: boolean = xdtTransformationUtility.basicXdtTransformation(folderPath, transformConfigs);<EOL>            if (","gt":"isTransformationApplied) {"}
{"input":"<s> export function append<T extends Node>(parent: HTMLElement, ...children: T[]): T {<EOL>    children.forEach(child =>","gt":"parent.appendChild(child));"}
{"input":"<s> function isD1(x: any): x is D1 {<EOL>","gt":"return true;"}
{"input":"<s> /**<EOL> * Helper to get a file resource from an object.<EOL> */<EOL>export function asFileResource(obj: any): IFileResource {<EOL>    if (obj instanceof FileStat) {<EOL>        let stat = <FileStat>obj;<EOL>","gt":"return {"}
{"input":"<s> async function func(): Promise<void> {<EOL>","gt":"before();"}
{"input":"<s> /**<EOL> * Get markers for owner and/or resource<EOL> * @returns {IMarker[]} list of markers<EOL> * @param filter<EOL> */<EOL>export function getModelMarkers(filter: {<EOL>    owner?: string;<EOL>    resource?: URI;<EOL>    take?: number;<EOL>}): IMarker[] {<EOL>","gt":"return StaticServices.markerService.get().read(filter);"}
{"input":"<s> /**<EOL> * Get the model that has `uri` if it exists.<EOL> */<EOL>export function getModel(uri: URI): ITextModel {<EOL>    return StaticServices.modelService.get().","gt":"getModel(uri);"}
{"input":"<s> export function getNonWhitespacePrefix(model: ISimpleModel, position: IPosition): string {<EOL>    /**<EOL>     * Do not analyze more characters<EOL>     */<EOL>    const MAX_PREFIX_LENGTH = <NUM_LIT>;<EOL>    let line = model.getLineContent(position.lineNumber).substr(<NUM_LIT>, position.column - <NUM_LIT>);<EOL>    let minChIndex = Math.max(<NUM_LIT>, line.length - MAX_PREFIX_LENGTH);<EOL>    for (let chIndex = line.length - <NUM_LIT>; chIndex >= minChIndex;","gt":"chIndex--) {"}
{"input":"<s> export function getNonWhitespacePrefix(model: ISimpleModel, position: IPosition): string {<EOL>    /**<EOL>     * Do not analyze more characters<EOL>     */<EOL>    const MAX_PREFIX_LENGTH = <NUM_LIT>;<EOL>    let line = model.getLineContent(position.lineNumber).substr(<NUM_LIT>, position.column - <NUM_LIT>);<EOL>    let minChIndex = Math.max(<NUM_LIT>, line.length - MAX_PREFIX_LENGTH);<EOL>    for (let chIndex = line.length - <NUM_LIT>; chIndex >= minChIndex; chIndex--) {<EOL>        let ch = line.charAt(chIndex);<EOL>        if (/\\s/.test(ch)) {<EOL>            return line.substr(chIndex + <NUM_LIT>);<EOL>        }<EOL>    }<EOL>    if (minChIndex ===","gt":"<NUM_LIT>) {"}
{"input":"<s> function test(r: Real | Fake) {<EOL>    r.method(","gt":"<NUM_LIT>);"}
{"input":"<s> function kindIs(kind: Kind, is: Kind): boolean {<EOL>    return","gt":"kind === is;"}
{"input":"<s> export function decodeTextMateToken(decodeMap: DecodeMap, scopes: string[]): string {<EOL>    const prevTokenScopes = decodeMap.prevToken.scopes;<EOL>    const prevTokenScopesLength = prevTokenScopes.length;<EOL>    const prevTokenScopeTokensMaps = decodeMap.prevToken.scopeTokensMaps;<EOL>    let scopeTokensMaps: boolean[][] = [];<EOL>    let","gt":"prevScopeTokensMaps: boolean[] = [];"}
{"input":"<s> export function decodeTextMateToken(decodeMap: DecodeMap, scopes: string[]): string {<EOL>    const prevTokenScopes = decodeMap.prevToken.scopes;<EOL>    const prevTokenScopesLength = prevTokenScopes.length;<EOL>    const prevTokenScopeTokensMaps = decodeMap.prevToken.scopeTokensMaps;<EOL>    let scopeTokensMaps: boolean[][] = [];<EOL>    let prevScopeTokensMaps: boolean[] = [];<EOL>    let sameAsPrev = true;<EOL>    for (let level = <NUM_LIT> ; level < scopes.length; level++) {<EOL>        let scope =","gt":"scopes[level];"}
{"input":"<s> export function decodeTextMateToken(decodeMap: DecodeMap, scopes: string[]): string {<EOL>    const prevTokenScopes = decodeMap.prevToken.scopes;<EOL>    const prevTokenScopesLength = prevTokenScopes.length;<EOL>    const prevTokenScopeTokensMaps = decodeMap.prevToken.scopeTokensMaps;<EOL>    let scopeTokensMaps: boolean[][] = [];<EOL>    let prevScopeTokensMaps: boolean[] = [];<EOL>    let sameAsPrev = true;<EOL>    for (let level = <NUM_LIT> ; level < scopes.length; level++) {<EOL>        let scope = scopes[level];<EOL>        if (sameAsPrev) {<EOL>            if (level < prevTokenScopesLength && prevTokenScopes[level] === scope) {<EOL>                prevScopeTokensMaps = prevTokenScopeTokensMaps[","gt":"level];"}
{"input":"<s> export function decodeTextMateToken(decodeMap: DecodeMap, scopes: string[]): string {<EOL>    const prevTokenScopes = decodeMap.prevToken.scopes;<EOL>    const prevTokenScopesLength = prevTokenScopes.length;<EOL>    const prevTokenScopeTokensMaps = decodeMap.prevToken.scopeTokensMaps;<EOL>    let scopeTokensMaps: boolean[][] = [];<EOL>    let prevScopeTokensMaps: boolean[] = [];<EOL>    let sameAsPrev = true;<EOL>    for (let level = <NUM_LIT> ; level < scopes.length; level++) {<EOL>        let scope = scopes[level];<EOL>        if (sameAsPrev) {<EOL>            if (level < prevTokenScopesLength && prevTokenScopes[level] === scope) {<EOL>                prevScopeTokensMaps = prevTokenScopeTokensMaps[level];<EOL>                scopeTokensMaps[level] = prevScopeTokensMaps;<EOL>                continue;<EOL>            }<EOL>            sameAsPrev = false;<EOL>        }<EOL>        let tokens = decodeMap.getTokenIds(scope);<EOL>        prevScopeTokensMaps = prevScopeTokensMaps.slice(<NUM_LIT>);<EOL>        for (let i = <NUM_LIT>; i < tokens.","gt":"length; i++) {"}
{"input":"<s> function toQueueKey(path: string): string {<EOL>    let queueKey = path;<EOL>    if (","gt":"platform.isWindows || platform.isMacintosh) {"}
{"input":"<s> export function resolveArduinoPath(): string {<EOL>    let pathString;<EOL>    try {<EOL>        pathString = childProcess.execSync(\"<STR_LIT>\", { encoding: \"<STR_LIT>\" });<EOL>        pathString = path.","gt":"resolve(pathString).trim();"}
{"input":"<s> <EOL>/**<EOL> * Is a string null, undefined, or empty?<EOL> */<EOL>export function empty(s: string): boolean {<EOL>","gt":"return (s ? false : true);"}
{"input":"<s> function fff<T extends {<EOL>    (): void;<EOL>}, U extends T>(x: T, y: U) {<EOL>    foo2(","gt":"x);"}
{"input":"<s> function update(tr) {<EOL>    assert(","gt":"tr.stdOutContained('<STR_LIT>'), '<STR_LIT>');"}
{"input":"<s> function findGitHubGitWin32(): TPromise<IGit> {<EOL>    const github = join(process.env['<STR_LIT>'], '<STR_LIT>');<EOL>    return readdir(github).then(children => {<EOL>","gt":"const git = children.filter(child => /^PortableGit/.test(child))[<NUM_LIT>];"}
{"input":"<s> export function validateArduinoPath(arduinoPath: string): boolean {<EOL>    return fileExistsSync(path.","gt":"join(arduinoPath, \"<STR_LIT>\"));"}
{"input":"<s> function treeInsert(T: IntervalTree, z: IntervalNode): void {<EOL>    let delta: number = <NUM_LIT>;<EOL>    let x = T.root;<EOL>    const zAbsoluteStart = z.start;<EOL>    const zAbsoluteEnd = z.","gt":"end;"}
{"input":"<s> function treeInsert(T: IntervalTree, z: IntervalNode): void {<EOL>    let delta: number = <NUM_LIT>;<EOL>    let x = T.root;<EOL>    const zAbsoluteStart = z.start;<EOL>    const zAbsoluteEnd = z.end;<EOL>    while (","gt":"true) {"}
{"input":"<s> function treeInsert(T: IntervalTree, z: IntervalNode): void {<EOL>    let delta: number = <NUM_LIT>;<EOL>    let x = T.root;<EOL>    const zAbsoluteStart = z.start;<EOL>    const zAbsoluteEnd = z.end;<EOL>    while (true) {<EOL>        const cmp = intervalCompare(zAbsoluteStart, zAbsoluteEnd, x.start + delta, x.end + delta);<EOL>        if (cmp < <NUM_LIT>) {<EOL>            <EOL>            <EOL>            if (x.left === SENTINEL) {<EOL>                z.start -= delta;<EOL>                z.end -= delta;<EOL>","gt":"z.maxEnd -= delta;"}
{"input":"<s> function treeInsert(T: IntervalTree, z: IntervalNode): void {<EOL>    let delta: number = <NUM_LIT>;<EOL>    let x = T.root;<EOL>    const zAbsoluteStart = z.start;<EOL>    const zAbsoluteEnd = z.end;<EOL>    while (true) {<EOL>        const cmp = intervalCompare(zAbsoluteStart, zAbsoluteEnd, x.start + delta, x.end + delta);<EOL>        if (cmp < <NUM_LIT>) {<EOL>            <EOL>            <EOL>            if (x.left === SENTINEL) {<EOL>                z.start -= delta;<EOL>                z.end -= delta;<EOL>                z.maxEnd -= delta;<EOL>                x.left = z;<EOL>                break;<EOL>            }<EOL>","gt":"else {"}
{"input":"<s> <EOL>function getLocalStorage(): Storage {<EOL>    try {<EOL>        const storage = window['<STR_LIT>'];<EOL>        const x = '<STR_LIT>';<EOL>        storage.setItem(x,","gt":"x);"}
{"input":"<s> <EOL>function getLocalStorage(): Storage {<EOL>    try {<EOL>        const storage = window['<STR_LIT>'];<EOL>        const x = '<STR_LIT>';<EOL>        storage.setItem(x, x);<EOL>        storage.removeItem(x);<EOL>        return localStorage;<EOL>    }<EOL>","gt":"catch (e) {"}
{"input":"<s> function getInstructions(networkName: string) {<EOL>    var label: string = (<any>{<EOL>        '<STR_LIT>': '<STR_LIT>',<EOL>","gt":"'<STR_LIT>': '<STR_LIT>',"}
{"input":"<s> function getDefaultProps() {<EOL>    return {<EOL>        releaseuri:","gt":"tl.getVariable('<STR_LIT>'),"}
{"input":"<s> /** Generates the package to disk */<EOL>export default function generateAnyPackage(pkg: AnyPackage, packages: AllPackages, versions: Versions, options: Options): Promise<Log> {<EOL>    return pkg.","gt":"isNotNeeded() ? generateNotNeededPackage(pkg, versions) : generatePackage(pkg, packages, versions, options);"}
{"input":"<s> export function consolidate(configMap: {<EOL>    [key: string]: IConfigFile;<EOL>}): {<EOL>    contents: any;<EOL>    parseErrors: string[];<EOL>} {<EOL>    const finalConfig: any = Object.create(null);<EOL>    const parseErrors: string[] = [];<EOL>    const","gt":"regexp = /\\/(team\\.)?([^\\.]*)*\\.json/;"}
{"input":"<s> export function consolidate(configMap: {<EOL>    [key: string]: IConfigFile;<EOL>}): {<EOL>    contents: any;<EOL>    parseErrors: string[];<EOL>} {<EOL>    const finalConfig: any = Object.create(null);<EOL>    const parseErrors: string[] = [];<EOL>    const regexp = /\\/(team\\.)?([^\\.]*)*\\.json/;<EOL>    <EOL>    Object.keys(configMap).forEach((configFileName) => {<EOL>        const config = objects.clone(configMap[configFileName]);<EOL>        const matches = regexp.exec(","gt":"configFileName);"}
{"input":"<s> export function consolidate(configMap: {<EOL>    [key: string]: IConfigFile;<EOL>}): {<EOL>    contents: any;<EOL>    parseErrors: string[];<EOL>} {<EOL>    const finalConfig: any = Object.create(null);<EOL>    const parseErrors: string[] = [];<EOL>    const regexp = /\\/(team\\.)?([^\\.]*)*\\.json/;<EOL>    <EOL>    Object.keys(configMap).forEach((configFileName) => {<EOL>        const config = objects.clone(configMap[configFileName]);<EOL>        const matches = regexp.exec(configFileName);<EOL>        if (!matches || !config) {<EOL>            return;<EOL>        }<EOL>        <EOL>        const isTeamSetting = !!matches[<NUM_LIT>];<EOL>        <EOL>        let configElement:","gt":"any = finalConfig;"}
{"input":"<s> export function consolidate(configMap: {<EOL>    [key: string]: IConfigFile;<EOL>}): {<EOL>    contents: any;<EOL>    parseErrors: string[];<EOL>} {<EOL>    const finalConfig: any = Object.create(null);<EOL>    const parseErrors: string[] = [];<EOL>    const regexp = /\\/(team\\.)?([^\\.]*)*\\.json/;<EOL>    <EOL>    Object.keys(configMap).forEach((configFileName) => {<EOL>        const config = objects.clone(configMap[configFileName]);<EOL>        const matches = regexp.exec(configFileName);<EOL>        if (!matches || !config) {<EOL>            return;<EOL>        }<EOL>        <EOL>        const isTeamSetting = !!matches[<NUM_LIT>];<EOL>        <EOL>        let configElement: any = finalConfig;<EOL>        if (matches && matches[<NUM_LIT>] && matches[<NUM_LIT>] !== CONFIG_DEFAULT_NAME) {<EOL>            <EOL>            const configSection = matches[<NUM_LIT>];<EOL>","gt":"let element = configElement[configSection];"}
{"input":"<s> export function consolidate(configMap: {<EOL>    [key: string]: IConfigFile;<EOL>}): {<EOL>    contents: any;<EOL>    parseErrors: string[];<EOL>} {<EOL>    const finalConfig: any = Object.create(null);<EOL>    const parseErrors: string[] = [];<EOL>    const regexp = /\\/(team\\.)?([^\\.]*)*\\.json/;<EOL>    <EOL>    Object.keys(configMap).forEach((configFileName) => {<EOL>        const config = objects.clone(configMap[configFileName]);<EOL>        const matches = regexp.exec(configFileName);<EOL>        if (!matches || !config) {<EOL>            return;<EOL>        }<EOL>        <EOL>        const isTeamSetting = !!matches[<NUM_LIT>];<EOL>        <EOL>        let configElement: any = finalConfig;<EOL>        if (matches && matches[<NUM_LIT>] && matches[<NUM_LIT>] !== CONFIG_DEFAULT_NAME) {<EOL>            <EOL>            const configSection = matches[<NUM_LIT>];<EOL>            let element = configElement[configSection];<EOL>            if (!element) {<EOL>                element = Object.create(null);<EOL>                configElement[configSection] = element;<EOL>            }<EOL>            configElement = element;<EOL>        }<EOL>        merge(configElement, config.","gt":"contents, !isTeamSetting );"}
{"input":"<s> export function getWordAtText(column: number, wordDefinition: RegExp, text: string, textOffset: number): IWordAtPosition {<EOL>    <EOL>    var words = text.match(wordDefinition), k: number, startWord: number, endWord: number, startColumn: number, endColumn: number, word: string;<EOL>    if (words) {<EOL>        for (k = <NUM_LIT>; k < words.length;","gt":"k++) {"}
{"input":"<s> export function getWordAtText(column: number, wordDefinition: RegExp, text: string, textOffset: number): IWordAtPosition {<EOL>    <EOL>    var words = text.match(wordDefinition), k: number, startWord: number, endWord: number, startColumn: number, endColumn: number, word: string;<EOL>    if (words) {<EOL>        for (k = <NUM_LIT>; k < words.length; k++) {<EOL>            word = words[k].trim();<EOL>            if (word.length > <NUM_LIT>) {<EOL>                startWord = text.indexOf(word,","gt":"endWord);"}
{"input":"<s> export function getWordAtText(column: number, wordDefinition: RegExp, text: string, textOffset: number): IWordAtPosition {<EOL>    <EOL>    var words = text.match(wordDefinition), k: number, startWord: number, endWord: number, startColumn: number, endColumn: number, word: string;<EOL>    if (words) {<EOL>        for (k = <NUM_LIT>; k < words.length; k++) {<EOL>            word = words[k].trim();<EOL>            if (word.length > <NUM_LIT>) {<EOL>                startWord = text.indexOf(word, endWord);<EOL>                endWord = startWord + word.length;<EOL>                startColumn = textOffset + startWord + <NUM_LIT>;<EOL>                endColumn = textOffset + endWord + <NUM_LIT>;<EOL>                if (startColumn <= column && column <= endColumn) {<EOL>","gt":"return {"}
{"input":"<s> export function getWordAtText(column: number, wordDefinition: RegExp, text: string, textOffset: number): IWordAtPosition {<EOL>    <EOL>    var words = text.match(wordDefinition), k: number, startWord: number, endWord: number, startColumn: number, endColumn: number, word: string;<EOL>    if (words) {<EOL>        for (k = <NUM_LIT>; k < words.length; k++) {<EOL>            word = words[k].trim();<EOL>            if (word.length > <NUM_LIT>) {<EOL>                startWord = text.indexOf(word, endWord);<EOL>                endWord = startWord + word.length;<EOL>                startColumn = textOffset + startWord + <NUM_LIT>;<EOL>                endColumn = textOffset + endWord + <NUM_LIT>;<EOL>                if (startColumn <= column && column <= endColumn) {<EOL>                    return {<EOL>                        word: word,<EOL>                        startColumn: startColumn,<EOL>                        endColumn:","gt":"endColumn"}
{"input":"<s> export function executeTests(tokenizationSupport: modes.ITokenizationSupport, tests: ITestItem[][]): void {<EOL>    for (var i = <NUM_LIT>, len = tests.length; i < len; i++) {<EOL>        assert.","gt":"ok(true, '<STR_LIT>' + i);"}
{"input":"<s> <EOL><EOL>export function setGlobalStorageForTest(newStorage: local_storage.Storage): void {<EOL>","gt":"storage = newStorage;"}
{"input":"<s> <EOL><EOL>export function isReservedWord(s: string): boolean {<EOL>    var keywords = ['<STR_LIT>', '<STR_LIT>', '<STR_LIT>',<EOL>        '<STR_LIT>', '<STR_LIT>', '<STR_LIT>'];<EOL>    for (","gt":"var k in keywords) {"}
{"input":"<s> /**<EOL> * Ensures there are no bad characters in a CSS token class.<EOL> */<EOL>export function sanitize(s: string) {<EOL>    return s.replace(","gt":"/[&<>'\"_]/g, '<STR_LIT>');"}
{"input":"<s> function _translateRef(ref) {<EOL>    var brPre = '<STR_LIT>';<EOL>","gt":"if (ref.startsWith(brPre)) {"}
{"input":"<s> <EOL><EOL><EOL>export function execAll(func: (item: any, state: any) => any, items: any[], state: any): Q.IPromise<any> {<EOL>    var initialState = state;<EOL>    var current = Q(null);<EOL>    items.","gt":"forEach((item) => {"}
{"input":"<s> export function finalHandler<T extends DOMEvent>(fn: (event: T) => any): (event: T) => any {<EOL>    return e => {<EOL>        e.","gt":"preventDefault();"}
{"input":"<s> /**<EOL> * Similar to array.map, `mapPager` lets you map the elements of an<EOL> * abstract paged collection to another type.<EOL> */<EOL>export function mapPager<T, R>(pager: IPager<T>, fn: (t: T) => R): IPager<R> {<EOL>    return {<EOL>        firstPage: pager.","gt":"firstPage.map(fn),"}
{"input":"<s> export default function f2() {<EOL>","gt":"f1();"}
{"input":"<s> <EOL>/**<EOL> * substituteMatches is used on lexer strings and can substitutes predefined patterns:<EOL> * \t\t$$  => $<EOL> * \t\t$#  => id<EOL> * \t\t$n  => matched entry n<EOL> * \t\t@attr => contents of lexer[attr]<EOL> *<EOL> * See documentation for more info<EOL> */<EOL>export function substituteMatches(lexer: ILexerMin, str: string, id: string, matches: string[], state: string) {<EOL>    var re = /\\$((\\$)|(#)|(\\d\\d?)|[sS](\\d\\d?)|@(\\w+))/g;<EOL>    var stateMatches: string[] = null;<EOL>    return str.replace(re, function (full, sub?, dollar?, hash?, n?, s?, attr?, ofs?, total?) {<EOL>        if (!empty(dollar)) {<EOL>","gt":"return '<STR_LIT>';"}
{"input":"<s> <EOL>/**<EOL> * substituteMatches is used on lexer strings and can substitutes predefined patterns:<EOL> * \t\t$$  => $<EOL> * \t\t$#  => id<EOL> * \t\t$n  => matched entry n<EOL> * \t\t@attr => contents of lexer[attr]<EOL> *<EOL> * See documentation for more info<EOL> */<EOL>export function substituteMatches(lexer: ILexerMin, str: string, id: string, matches: string[], state: string) {<EOL>    var re = /\\$((\\$)|(#)|(\\d\\d?)|[sS](\\d\\d?)|@(\\w+))/g;<EOL>    var stateMatches: string[] = null;<EOL>    return str.replace(re, function (full, sub?, dollar?, hash?, n?, s?, attr?, ofs?, total?) {<EOL>        if (!empty(dollar)) {<EOL>            return '<STR_LIT>'; <EOL>        }<EOL>        if (!empty(hash)) {<EOL>            return","gt":"fixCase(lexer, id);"}
{"input":"<s> <EOL>/**<EOL> * substituteMatches is used on lexer strings and can substitutes predefined patterns:<EOL> * \t\t$$  => $<EOL> * \t\t$#  => id<EOL> * \t\t$n  => matched entry n<EOL> * \t\t@attr => contents of lexer[attr]<EOL> *<EOL> * See documentation for more info<EOL> */<EOL>export function substituteMatches(lexer: ILexerMin, str: string, id: string, matches: string[], state: string) {<EOL>    var re = /\\$((\\$)|(#)|(\\d\\d?)|[sS](\\d\\d?)|@(\\w+))/g;<EOL>    var stateMatches: string[] = null;<EOL>    return str.replace(re, function (full, sub?, dollar?, hash?, n?, s?, attr?, ofs?, total?) {<EOL>        if (!empty(dollar)) {<EOL>            return '<STR_LIT>'; <EOL>        }<EOL>        if (!empty(hash)) {<EOL>            return fixCase(lexer, id); <EOL>        }<EOL>        if (!empty(n) && n < matches.length) {<EOL>            return fixCase(lexer, matches[n]); <EOL>        }<EOL>        if (!empty(attr) && lexer && typeof (lexer[attr]) ===","gt":"'<STR_LIT>') {"}
{"input":"<s> function createClient(): Client {<EOL>    return new Client(uri.parse(require.toUrl('<STR_LIT>')).fsPath, {<EOL>","gt":"serverName: '<STR_LIT>',"}
{"input":"<s> function toBooleanWithDefault(value: any, defaultValue: boolean): boolean {<EOL>    if (typeof value === '<STR_LIT>') {<EOL>        return","gt":"defaultValue;"}
{"input":"<s> function sorter(a: IKeybindingItem, b: IKeybindingItem): number {<EOL>    if (a.weight1 !== b.weight1) {<EOL>        return a.weight1 - b.weight1;<EOL>    }<EOL>","gt":"if (a.command < b.command) {"}
{"input":"<s> function sorter(a: IKeybindingItem, b: IKeybindingItem): number {<EOL>    if (a.weight1 !== b.weight1) {<EOL>        return a.weight1 - b.weight1;<EOL>    }<EOL>    if (a.command < b.command) {<EOL>        return -<NUM_LIT>;<EOL>    }<EOL>    if (a.command > b.command) {<EOL>","gt":"return <NUM_LIT>;"}
{"input":"<s> export function finalHandler<T extends DOMEvent>(fn: (event: T) => any): (event: T) => any {<EOL>    return e => {<EOL>        e.","gt":"preventDefault();"}
{"input":"<s> export function isValidExtensionVersion(version: string, extensionDesc: IReducedExtensionDescription, notices: string[]): boolean {<EOL>    if (extensionDesc.isBuiltin || typeof extensionDesc.main === '<STR_LIT>') {<EOL>        <EOL>","gt":"return true;"}
{"input":"<s> export function isValidExtensionVersion(version: string, extensionDesc: IReducedExtensionDescription, notices: string[]): boolean {<EOL>    if (extensionDesc.isBuiltin || typeof extensionDesc.main === '<STR_LIT>') {<EOL>        <EOL>        return true;<EOL>    }<EOL>    let desiredVersion = normalizeVersion(parseVersion(extensionDesc.engines.vscode));<EOL>","gt":"if (!desiredVersion) {"}
{"input":"<s> export function isValidExtensionVersion(version: string, extensionDesc: IReducedExtensionDescription, notices: string[]): boolean {<EOL>    if (extensionDesc.isBuiltin || typeof extensionDesc.main === '<STR_LIT>') {<EOL>        <EOL>        return true;<EOL>    }<EOL>    let desiredVersion = normalizeVersion(parseVersion(extensionDesc.engines.vscode));<EOL>    if (!desiredVersion) {<EOL>        notices.push(nls.localize('<STR_LIT>', \"<STR_LIT>\", extensionDesc.engines.vscode));<EOL>        return false;<EOL>    }<EOL>    <EOL>    <EOL>    <EOL>","gt":"if (desiredVersion.majorBase === <NUM_LIT>) {"}
{"input":"<s> export function isValidExtensionVersion(version: string, extensionDesc: IReducedExtensionDescription, notices: string[]): boolean {<EOL>    if (extensionDesc.isBuiltin || typeof extensionDesc.main === '<STR_LIT>') {<EOL>        <EOL>        return true;<EOL>    }<EOL>    let desiredVersion = normalizeVersion(parseVersion(extensionDesc.engines.vscode));<EOL>    if (!desiredVersion) {<EOL>        notices.push(nls.localize('<STR_LIT>', \"<STR_LIT>\", extensionDesc.engines.vscode));<EOL>        return false;<EOL>    }<EOL>    <EOL>    <EOL>    <EOL>    if (desiredVersion.majorBase === <NUM_LIT>) {<EOL>        <EOL>        if (!desiredVersion.majorMustEqual || !desiredVersion.minorMustEqual) {<EOL>            notices.push(nls.localize('<STR_LIT>', \"<STR_LIT>\", extensionDesc.engines.vscode));<EOL>","gt":"return false;"}
{"input":"<s> export function createWordRegExp(allowInWords: string = '<STR_LIT>'): RegExp {<EOL>    return wordHelper.","gt":"createWordRegExp(allowInWords);"}
{"input":"<s> function foo2<T extends {<EOL>    (): void;<EOL>}, U extends {<EOL>    (): void;<EOL>}>(x: T, y: U) {<EOL>    foo(","gt":"x);"}
{"input":"<s> function MODEL_ID(resource: URI): string {<EOL>    return","gt":"resource.toString();"}
{"input":"<s> function printJson(object: any): void {<EOL>    log(JSON.stringify(object, null,","gt":"<NUM_LIT>));"}
{"input":"<s> async function processRuntimeDependencies(): Promise<void> {<EOL>    const installLockExists: boolean = await util.checkInstallLockFile();<EOL>    if (installLockExists) {<EOL>        <EOL>        if (util.packageJson.activationEvents && util.packageJson.activationEvents.length === <NUM_LIT>) {<EOL>","gt":"try {"}
{"input":"<s> async function processRuntimeDependencies(): Promise<void> {<EOL>    const installLockExists: boolean = await util.checkInstallLockFile();<EOL>    if (installLockExists) {<EOL>        <EOL>        if (util.packageJson.activationEvents && util.packageJson.activationEvents.length === <NUM_LIT>) {<EOL>            try {<EOL>                await offlineInstallation();<EOL>            }<EOL>            catch (","gt":"error) {"}
{"input":"<s> async function processRuntimeDependencies(): Promise<void> {<EOL>    const installLockExists: boolean = await util.checkInstallLockFile();<EOL>    if (installLockExists) {<EOL>        <EOL>        if (util.packageJson.activationEvents && util.packageJson.activationEvents.length === <NUM_LIT>) {<EOL>            try {<EOL>                await offlineInstallation();<EOL>            }<EOL>            catch (error) {<EOL>                getOutputChannelLogger().showErrorMessage('<STR_LIT>');<EOL>                showOutputChannel();<EOL>            }<EOL>            <EOL>        }<EOL>","gt":"else {"}
{"input":"<s> async function processRuntimeDependencies(): Promise<void> {<EOL>    const installLockExists: boolean = await util.checkInstallLockFile();<EOL>    if (installLockExists) {<EOL>        <EOL>        if (util.packageJson.activationEvents && util.packageJson.activationEvents.length === <NUM_LIT>) {<EOL>            try {<EOL>                await offlineInstallation();<EOL>            }<EOL>            catch (error) {<EOL>                getOutputChannelLogger().showErrorMessage('<STR_LIT>');<EOL>                showOutputChannel();<EOL>            }<EOL>            <EOL>        }<EOL>        else {<EOL>            await finalizeExtensionActivation();<EOL>        }<EOL>        <EOL>    }<EOL>    else {<EOL>","gt":"try {"}
{"input":"<s> function f3(s: string) {<EOL>    return s === \"<STR_LIT>\" || s === \"<STR_LIT>\" ? s :","gt":"undefined;"}
{"input":"<s> /**<EOL> * Reveals the output channel in the UI.<EOL> */<EOL>export function showTestOutput() {<EOL>","gt":"outputChannel.show(true);"}
{"input":"<s> function f1() {<EOL>    var","gt":"a = [<NUM_LIT>, <NUM_LIT>, <NUM_LIT>];"}
{"input":"<s> /**<EOL> * See https://github.com/Microsoft/monaco-editor/issues/601<EOL> * To protect against malicious code in the linked site, particularly phishing attempts,<EOL> * the window.opener should be set to null to prevent the linked site from having access<EOL> * to change the location of the current page.<EOL> * See https://mathiasbynens.github.io/rel-noopener/<EOL> */<EOL>export function windowOpenNoOpener(url: string): void {<EOL>    if (platform.isNative) {<EOL>        <EOL>        window.open(url);<EOL>    }<EOL>    else {<EOL>        let newTab = window.open();<EOL>        if (newTab) {<EOL>            newTab.opener = null;<EOL>","gt":"newTab.location.href = url;"}
{"input":"<s> function matches(segments: JSONPath, pattern: string[]) {<EOL>    let k = <NUM_LIT>;<EOL>    for (let i = <NUM_LIT>; k < pattern.length && i < segments.length; i++) {<EOL>        if (pattern[k] === segments[i] || pattern[k] === '<STR_LIT>') {<EOL>","gt":"k++;"}
{"input":"<s> async function downloadAndInstallPackages(info: PlatformInformation): Promise<void> {<EOL>    let outputChannelLogger: Logger = getOutputChannelLogger();<EOL>    outputChannelLogger.appendLine(\"<STR_LIT>\");<EOL>    let statusItem: vscode.StatusBarItem = vscode.window.createStatusBarItem(vscode.StatusBarAlignment.Right);<EOL>    let packageManager: PackageManager = new PackageManager(info,","gt":"outputChannelLogger, statusItem);"}
{"input":"<s> async function downloadAndInstallPackages(info: PlatformInformation): Promise<void> {<EOL>    let outputChannelLogger: Logger = getOutputChannelLogger();<EOL>    outputChannelLogger.appendLine(\"<STR_LIT>\");<EOL>    let statusItem: vscode.StatusBarItem = vscode.window.createStatusBarItem(vscode.StatusBarAlignment.Right);<EOL>    let packageManager: PackageManager = new PackageManager(info, outputChannelLogger, statusItem);<EOL>    outputChannelLogger.appendLine('<STR_LIT>');<EOL>    setInstallationStage('<STR_LIT>');<EOL>    await packageManager.DownloadPackages();<EOL>    outputChannelLogger.appendLine('<STR_LIT>');<EOL>","gt":"setInstallationStage('<STR_LIT>');"}
{"input":"<s> function getOneList(name: string, saveFiles: boolean, f: () => void) {<EOL>    var hurl = name + \"<STR_LIT>\";<EOL>    var dir = \"<STR_LIT>\";<EOL>    if (!/localhost/.test(localUrl)) {<EOL>        var m = /(.*)\\?(.*)/.exec(localUrl);<EOL>        if (","gt":"/tdpublogger/.test(localUrl)) {"}
{"input":"<s> function getOneList(name: string, saveFiles: boolean, f: () => void) {<EOL>    var hurl = name + \"<STR_LIT>\";<EOL>    var dir = \"<STR_LIT>\";<EOL>    if (!/localhost/.test(localUrl)) {<EOL>        var m = /(.*)\\?(.*)/.exec(localUrl);<EOL>        if (/tdpublogger/.test(localUrl)) {<EOL>            hurl = localUrl + hurl;<EOL>        }<EOL>","gt":"else if (m) {"}
{"input":"<s> function getOneList(name: string, saveFiles: boolean, f: () => void) {<EOL>    var hurl = name + \"<STR_LIT>\";<EOL>    var dir = \"<STR_LIT>\";<EOL>    if (!/localhost/.test(localUrl)) {<EOL>        var m = /(.*)\\?(.*)/.exec(localUrl);<EOL>        if (/tdpublogger/.test(localUrl)) {<EOL>            hurl = localUrl + hurl;<EOL>        }<EOL>        else if (m) {<EOL>            hurl = m[<NUM_LIT>] + \"<STR_LIT>\" + name + \"<STR_LIT>\" + m[<NUM_LIT>];<EOL>        }<EOL>","gt":"else {"}
{"input":"<s> function getOneList(name: string, saveFiles: boolean, f: () => void) {<EOL>    var hurl = name + \"<STR_LIT>\";<EOL>    var dir = \"<STR_LIT>\";<EOL>    if (!/localhost/.test(localUrl)) {<EOL>        var m = /(.*)\\?(.*)/.exec(localUrl);<EOL>        if (/tdpublogger/.test(localUrl)) {<EOL>            hurl = localUrl + hurl;<EOL>        }<EOL>        else if (m) {<EOL>            hurl = m[<NUM_LIT>] + \"<STR_LIT>\" + name + \"<STR_LIT>\" + m[<NUM_LIT>];<EOL>        }<EOL>        else {<EOL>            hurl =","gt":"localUrl + \"<STR_LIT>\" + hurl;"}
{"input":"<s> function getOneList(name: string, saveFiles: boolean, f: () => void) {<EOL>    var hurl = name + \"<STR_LIT>\";<EOL>    var dir = \"<STR_LIT>\";<EOL>    if (!/localhost/.test(localUrl)) {<EOL>        var m = /(.*)\\?(.*)/.exec(localUrl);<EOL>        if (/tdpublogger/.test(localUrl)) {<EOL>            hurl = localUrl + hurl;<EOL>        }<EOL>        else if (m) {<EOL>            hurl = m[<NUM_LIT>] + \"<STR_LIT>\" + name + \"<STR_LIT>\" + m[<NUM_LIT>];<EOL>        }<EOL>        else {<EOL>            hurl = localUrl + \"<STR_LIT>\" + hurl;<EOL>        }<EOL>        dir = \"<STR_LIT>\";<EOL>    }<EOL>    <EOL>    var allUsers = [];<EOL>    var","gt":"n = <NUM_LIT>;"}
{"input":"<s> function getOneList(name: string, saveFiles: boolean, f: () => void) {<EOL>    var hurl = name + \"<STR_LIT>\";<EOL>    var dir = \"<STR_LIT>\";<EOL>    if (!/localhost/.test(localUrl)) {<EOL>        var m = /(.*)\\?(.*)/.exec(localUrl);<EOL>        if (/tdpublogger/.test(localUrl)) {<EOL>            hurl = localUrl + hurl;<EOL>        }<EOL>        else if (m) {<EOL>            hurl = m[<NUM_LIT>] + \"<STR_LIT>\" + name + \"<STR_LIT>\" + m[<NUM_LIT>];<EOL>        }<EOL>        else {<EOL>            hurl = localUrl + \"<STR_LIT>\" + hurl;<EOL>        }<EOL>        dir = \"<STR_LIT>\";<EOL>    }<EOL>    <EOL>    var allUsers = [];<EOL>    var n = <NUM_LIT>;<EOL>    var","gt":"seen: any = {};"}
{"input":"<s> function getOneList(name: string, saveFiles: boolean, f: () => void) {<EOL>    var hurl = name + \"<STR_LIT>\";<EOL>    var dir = \"<STR_LIT>\";<EOL>    if (!/localhost/.test(localUrl)) {<EOL>        var m = /(.*)\\?(.*)/.exec(localUrl);<EOL>        if (/tdpublogger/.test(localUrl)) {<EOL>            hurl = localUrl + hurl;<EOL>        }<EOL>        else if (m) {<EOL>            hurl = m[<NUM_LIT>] + \"<STR_LIT>\" + name + \"<STR_LIT>\" + m[<NUM_LIT>];<EOL>        }<EOL>        else {<EOL>            hurl = localUrl + \"<STR_LIT>\" + hurl;<EOL>        }<EOL>        dir = \"<STR_LIT>\";<EOL>    }<EOL>    <EOL>    var allUsers = [];<EOL>    var n = <NUM_LIT>;<EOL>    var seen: any = {};<EOL>    function getHFrom(cont: string) {<EOL>        tdevGet(hurl + cont, text => {<EOL>            var resp = JSON.parse(text);<EOL>            console.log(\"<STR_LIT>\", n++, hurl + cont, resp.items.length);<EOL>            if (saveFiles)<EOL>","gt":"allUsers = [];"}
{"input":"<s> function getOneList(name: string, saveFiles: boolean, f: () => void) {<EOL>    var hurl = name + \"<STR_LIT>\";<EOL>    var dir = \"<STR_LIT>\";<EOL>    if (!/localhost/.test(localUrl)) {<EOL>        var m = /(.*)\\?(.*)/.exec(localUrl);<EOL>        if (/tdpublogger/.test(localUrl)) {<EOL>            hurl = localUrl + hurl;<EOL>        }<EOL>        else if (m) {<EOL>            hurl = m[<NUM_LIT>] + \"<STR_LIT>\" + name + \"<STR_LIT>\" + m[<NUM_LIT>];<EOL>        }<EOL>        else {<EOL>            hurl = localUrl + \"<STR_LIT>\" + hurl;<EOL>        }<EOL>        dir = \"<STR_LIT>\";<EOL>    }<EOL>    <EOL>    var allUsers = [];<EOL>    var n = <NUM_LIT>;<EOL>    var seen: any = {};<EOL>    function getHFrom(cont: string) {<EOL>        tdevGet(hurl + cont, text => {<EOL>            var resp = JSON.parse(text);<EOL>            console.log(\"<STR_LIT>\", n++, hurl + cont, resp.items.length);<EOL>            if (saveFiles)<EOL>                allUsers = [];<EOL>            resp.items.forEach(it => {<EOL>                if (it.id && seen[it.id])<EOL>                    return;<EOL>                seen[it.id] = true;<EOL>                allUsers.push(it);<EOL>            });<EOL>            if (saveFiles)<EOL>                fs.writeFile(dir + name + \"<STR_LIT>\" + Date.now() + \"<STR_LIT>\", JSON.stringify(allUsers, null, <NUM_LIT>), \"<STR_LIT>\", err => {<EOL>                    if (err)<EOL>                        throw err;<EOL>                    if (resp.continuation) {<EOL>                        fs.writeFile(dir + \"<STR_LIT>\" + name, resp.continuation, \"<STR_LIT>\", err => {<EOL>                            if (err)<EOL>                                throw err;<EOL>                            getHFrom(\"<STR_LIT>\" + resp.continuation);<EOL>                        });<EOL>                    }<EOL>                });<EOL>            else {<EOL>","gt":"if (resp.continuation)"}
{"input":"<s> <EOL>export function editorAction(ctor: {<EOL>    new (): EditorAction;<EOL>}): void {<EOL>","gt":"CommonEditorRegistry.registerEditorAction(new ctor());"}
{"input":"<s> function listDir(tr) {<EOL>    assert(tr.stdOutContained('<STR_LIT>'),","gt":"'<STR_LIT>');"}
{"input":"<s> export function createTaskDummy(userId?: string, name?: string, description?: string) {<EOL>    var user = {<EOL>        name: name || \"<STR_LIT>\",<EOL>        description:","gt":"description || \"<STR_LIT>\""}
{"input":"<s> export function startSpinner(message: string) {<EOL>    if (spinnerTimer == null) {<EOL>        let state = <NUM_LIT>;<EOL>        spinnerTimer =","gt":"setInterval(function () {"}
{"input":"<s> function reactionEquals(one: _.IDragOverReaction, other: _.IDragOverReaction): boolean {<EOL>    if (!one && !other) {<EOL>        return true;<EOL>    }<EOL>    else if (!one || !other) {<EOL>        return false;<EOL>    }<EOL>    else if (one.accept !== other.accept) {<EOL>        return false;<EOL>    }<EOL>    else if (","gt":"one.bubble !== other.bubble) {"}
{"input":"<s> function reactionEquals(one: _.IDragOverReaction, other: _.IDragOverReaction): boolean {<EOL>    if (!one && !other) {<EOL>        return true;<EOL>    }<EOL>    else if (!one || !other) {<EOL>        return false;<EOL>    }<EOL>    else if (one.accept !== other.accept) {<EOL>        return false;<EOL>    }<EOL>    else if (one.bubble !== other.bubble) {<EOL>        return false;<EOL>    }<EOL>    else if (one.effect !== other.effect) {<EOL>        return","gt":"false;"}
{"input":"<s> function foo() {<EOL>","gt":"bar();"}
{"input":"<s> export function toggleShowQuotes() {<EOL>","gt":"return {"}
{"input":"<s> export function loadSettings(callback) {<EOL>    chrome.storage.sync.get(","gt":"null, (data) => {"}
{"input":"<s> function g<T>(value: [<EOL>    string,<EOL>    T<EOL>]): T {<EOL>    return","gt":"value[<NUM_LIT>];"}
{"input":"<s> function lazyFetch(url, options?) {<EOL>    return new Observable(fetchObserver => {<EOL>        let cancelToken = false;<EOL>        fetch(url, options)<EOL>            .then(res => {<EOL>","gt":"if (!cancelToken) {"}
{"input":"<s> function lazyFetch(url, options?) {<EOL>    return new Observable(fetchObserver => {<EOL>        let cancelToken = false;<EOL>        fetch(url, options)<EOL>            .then(res => {<EOL>            if (!cancelToken) {<EOL>                return res.json()<EOL>                    .then(data => {<EOL>                    fetchObserver.next(data);<EOL>","gt":"fetchObserver.complete();"}
{"input":"<s> function lazyFetch(url, options?) {<EOL>    return new Observable(fetchObserver => {<EOL>        let cancelToken = false;<EOL>        fetch(url, options)<EOL>            .then(res => {<EOL>            if (!cancelToken) {<EOL>                return res.json()<EOL>                    .then(data => {<EOL>                    fetchObserver.next(data);<EOL>                    fetchObserver.complete();<EOL>                });<EOL>            }<EOL>        }).catch(err => fetchObserver.error(err));<EOL>","gt":"return () => {"}
{"input":"<s> <EOL>export function isValidBranchName(value: string): boolean {<EOL>","gt":"return !/^\\.|\\/\\.|\\.\\.|~|\\^|:|\\/$|\\.lock$|\\.lock\\/|\\\\|\\*|\\s|^\\s*$/.test(value);"}
{"input":"<s> function ensureAIEngineIsInitialized(): void {<EOL>    if (_initialized === false) {<EOL>        <EOL>        appInsights.","gt":"setup('<STR_LIT>')"}
{"input":"<s> function patchDockermakeHexInfo(extInfo: pxtc.ExtensionInfo) {<EOL>    let hexPath = thisBuild.buildPath + \"<STR_LIT>\";<EOL>","gt":"return {"}
{"input":"<s> function createArray<T>(length: number, value: T): T[] {<EOL>    var r = [];<EOL>    for (var","gt":"i = <NUM_LIT>; i < length; i++) {"}
{"input":"<s> export function createLineParts(lineNumber: number, minLineColumn: number, lineContent: string, tabSize: number, lineTokens: ViewLineTokens, rawLineDecorations: InlineDecoration[], renderWhitespace: boolean): LineParts {<EOL>    if (renderWhitespace) {<EOL>        let oldLength = rawLineDecorations.length;<EOL>        rawLineDecorations = insertWhitespaceLineDecorations(lineNumber, lineContent, tabSize, lineTokens.getFauxIndentLength(), rawLineDecorations);<EOL>        if (","gt":"rawLineDecorations.length !== oldLength) {"}
{"input":"<s> function getDefaultMetadata(topLevelLanguageId: LanguageId): number {<EOL>    return ((topLevelLanguageId << MetadataConsts.LANGUAGEID_OFFSET)<EOL>        | (","gt":"StandardTokenType.Other << MetadataConsts.TOKEN_TYPE_OFFSET)"}
{"input":"<s> function getClient(aiKey: string): typeof appInsights.client {<EOL>    ensureAIEngineIsInitialized();<EOL>    const client = appInsights.getClient(aiKey);<EOL>    client.channel.","gt":"setOfflineMode(true);"}
{"input":"<s> export function compress(s: string): string {<EOL>    return","gt":"LZString.compressToBase64(s);"}
{"input":"<s> function isSuccess(context: IRequestContext): boolean {<EOL>    return (context.res.statusCode >= <NUM_LIT> &&","gt":"context.res.statusCode < <NUM_LIT>) || context.res.statusCode === <NUM_LIT>;"}
{"input":"<s> export function watchCoverageFiles(root: string) {<EOL>    <EOL>    const coveragePath = join(root, \"<STR_LIT>\");<EOL>    let changeCallback = (path: string) => { };<EOL>    setTimeout(() => {<EOL>        changeCallback(","gt":"getCoverageFiles(coveragePath));"}
{"input":"<s> export function watchCoverageFiles(root: string) {<EOL>    <EOL>    const coveragePath = join(root, \"<STR_LIT>\");<EOL>    let changeCallback = (path: string) => { };<EOL>    setTimeout(() => {<EOL>        changeCallback(getCoverageFiles(coveragePath));<EOL>    }, <NUM_LIT>);<EOL>    chokidar<EOL>        .watch(coveragePath, { ignoreInitial: true })<EOL>        .","gt":"on(\"<STR_LIT>\", (event, path) => {"}
{"input":"<s> export function watchCoverageFiles(root: string) {<EOL>    <EOL>    const coveragePath = join(root, \"<STR_LIT>\");<EOL>    let changeCallback = (path: string) => { };<EOL>    setTimeout(() => {<EOL>        changeCallback(getCoverageFiles(coveragePath));<EOL>    }, <NUM_LIT>);<EOL>    chokidar<EOL>        .watch(coveragePath, { ignoreInitial: true })<EOL>        .on(\"<STR_LIT>\", (event, path) => {<EOL>        changeCallback(getCoverageFiles(coveragePath));<EOL>    });<EOL>    return {<EOL>","gt":"change(callback) {"}
{"input":"<s> export async function noNext<T>(t: test.Test, source: AsyncIterator<T>) {<EOL>","gt":"const next = await source.next();"}
{"input":"<s> export async function executeInSequence(funcs: Array<{<EOL>    fn: () => void;<EOL>    delay: number;<EOL>}>) {<EOL>    for (const { fn, delay } of","gt":"funcs) {"}
{"input":"<s> function sendTelemetry(info: PlatformInformation): boolean {<EOL>    let installBlob: InstallationInformation = getInstallationInformationInstance();<EOL>    const success: boolean = !installBlob.hasError;<EOL>    installBlob.telemetryProperties['<STR_LIT>'] = success.toString();<EOL>    if (info.distribution) {<EOL>        installBlob.telemetryProperties['<STR_LIT>'] = info.distribution.name;<EOL>        installBlob.telemetryProperties[","gt":"'<STR_LIT>'] = info.distribution.version;"}
{"input":"<s> function sendTelemetry(info: PlatformInformation): boolean {<EOL>    let installBlob: InstallationInformation = getInstallationInformationInstance();<EOL>    const success: boolean = !installBlob.hasError;<EOL>    installBlob.telemetryProperties['<STR_LIT>'] = success.toString();<EOL>    if (info.distribution) {<EOL>        installBlob.telemetryProperties['<STR_LIT>'] = info.distribution.name;<EOL>        installBlob.telemetryProperties['<STR_LIT>'] = info.distribution.version;<EOL>    }<EOL>    if (success) {<EOL>        util.setProgress(util.getProgressInstallSuccess());<EOL>","gt":"let versionShown: PersistentState<number> = new PersistentState<number>(\"<STR_LIT>\", -<NUM_LIT>);"}
{"input":"<s> function testComma() {<EOL>    glb1 = <NUM_LIT>;<EOL>    let x = (incrBy_2(), <NUM_LIT>);<EOL>","gt":"assert(x == <NUM_LIT>, \"<STR_LIT>\");"}
{"input":"<s> function isLeapYear(year: number): boolean {<EOL>    var date =","gt":"new Date(year, <NUM_LIT>, <NUM_LIT>);"}
{"input":"<s> export function getWalletConfig(state: AppState): WalletConfig | null | undefined {<EOL>    return","gt":"state.wallet.config;"}
{"input":"<s> function getSafeTokenizationSupport(languageIdentifier: LanguageIdentifier): ITokenizationSupport {<EOL>    let tokenizationSupport = TokenizationRegistry.get(languageIdentifier.language);<EOL>    if (tokenizationSupport) {<EOL>        return","gt":"tokenizationSupport;"}
{"input":"<s> function resolveQuirks(nuGetVersion: VersionInfoVersion, definitions: QuirkDescriptor[]): NuGetQuirkName[] {<EOL>    return","gt":"definitions"}
{"input":"<s> export function getResource(sourceFile: string): Resource {<EOL>    let resource: string;<EOL>    if (/^vs\\/platform/.test(sourceFile)) {<EOL>        return { name: '<STR_LIT>', project: editorProject };<EOL>    }<EOL>    else if (/^vs\\/editor\\/contrib/.test(sourceFile)) {<EOL>","gt":"return { name: '<STR_LIT>', project: editorProject };"}
{"input":"<s> export function getResource(sourceFile: string): Resource {<EOL>    let resource: string;<EOL>    if (/^vs\\/platform/.test(sourceFile)) {<EOL>        return { name: '<STR_LIT>', project: editorProject };<EOL>    }<EOL>    else if (/^vs\\/editor\\/contrib/.test(sourceFile)) {<EOL>        return { name: '<STR_LIT>', project: editorProject };<EOL>    }<EOL>    else if (/^vs\\/editor/.test(sourceFile)) {<EOL>        return { name:","gt":"'<STR_LIT>', project: editorProject };"}
{"input":"<s> export function getResource(sourceFile: string): Resource {<EOL>    let resource: string;<EOL>    if (/^vs\\/platform/.test(sourceFile)) {<EOL>        return { name: '<STR_LIT>', project: editorProject };<EOL>    }<EOL>    else if (/^vs\\/editor\\/contrib/.test(sourceFile)) {<EOL>        return { name: '<STR_LIT>', project: editorProject };<EOL>    }<EOL>    else if (/^vs\\/editor/.test(sourceFile)) {<EOL>        return { name: '<STR_LIT>', project: editorProject };<EOL>    }<EOL>    else if (/^vs\\/base/.test(sourceFile)) {<EOL>        return {","gt":"name: '<STR_LIT>', project: editorProject };"}
{"input":"<s> export function getResource(sourceFile: string): Resource {<EOL>    let resource: string;<EOL>    if (/^vs\\/platform/.test(sourceFile)) {<EOL>        return { name: '<STR_LIT>', project: editorProject };<EOL>    }<EOL>    else if (/^vs\\/editor\\/contrib/.test(sourceFile)) {<EOL>        return { name: '<STR_LIT>', project: editorProject };<EOL>    }<EOL>    else if (/^vs\\/editor/.test(sourceFile)) {<EOL>        return { name: '<STR_LIT>', project: editorProject };<EOL>    }<EOL>    else if (/^vs\\/base/.test(sourceFile)) {<EOL>        return { name: '<STR_LIT>', project: editorProject };<EOL>    }<EOL>    else if (/^vs\\/code/.test(sourceFile)) {<EOL>        return { name: '<STR_LIT>',","gt":"project: workbenchProject };"}
{"input":"<s> export function getResource(sourceFile: string): Resource {<EOL>    let resource: string;<EOL>    if (/^vs\\/platform/.test(sourceFile)) {<EOL>        return { name: '<STR_LIT>', project: editorProject };<EOL>    }<EOL>    else if (/^vs\\/editor\\/contrib/.test(sourceFile)) {<EOL>        return { name: '<STR_LIT>', project: editorProject };<EOL>    }<EOL>    else if (/^vs\\/editor/.test(sourceFile)) {<EOL>        return { name: '<STR_LIT>', project: editorProject };<EOL>    }<EOL>    else if (/^vs\\/base/.test(sourceFile)) {<EOL>        return { name: '<STR_LIT>', project: editorProject };<EOL>    }<EOL>    else if (/^vs\\/code/.test(sourceFile)) {<EOL>        return { name: '<STR_LIT>', project: workbenchProject };<EOL>    }<EOL>    else if (/^vs\\/workbench\\/parts/.test(sourceFile)) {<EOL>        resource = sourceFile.split('<STR_LIT>', <NUM_LIT>).join('<STR_LIT>');<EOL>        return { name: resource, project: workbenchProject };<EOL>    }<EOL>    else if (/^vs\\/workbench\\/services/.test(sourceFile)) {<EOL>        resource =","gt":"sourceFile.split('<STR_LIT>', <NUM_LIT>).join('<STR_LIT>');"}
{"input":"<s> function testOn(...args: any[]) {<EOL>    let handle = on.apply(","gt":"null, arguments);"}
{"input":"<s> export function undefined(value: any): boolean {<EOL>    return typeof value ===","gt":"'<STR_LIT>';"}
{"input":"<s> function getUnixShellEnvironment(): TPromise<IEnv> {<EOL>    const promise = new TPromise((c, e) => {<EOL>        const runAsNode = process.env['<STR_LIT>'];<EOL>        const noAttach = process.env['<STR_LIT>'];<EOL>        const mark = generateUuid().replace(/-/g, '<STR_LIT>').","gt":"substr(<NUM_LIT>, <NUM_LIT>);"}
{"input":"<s> function getUnixShellEnvironment(): TPromise<IEnv> {<EOL>    const promise = new TPromise((c, e) => {<EOL>        const runAsNode = process.env['<STR_LIT>'];<EOL>        const noAttach = process.env['<STR_LIT>'];<EOL>        const mark = generateUuid().replace(/-/g, '<STR_LIT>').substr(<NUM_LIT>, <NUM_LIT>);<EOL>        const regex = new RegExp(mark + '<STR_LIT>' + mark);<EOL>        const env = assign({}, process.","gt":"env, {"}
{"input":"<s> function getUnixShellEnvironment(): TPromise<IEnv> {<EOL>    const promise = new TPromise((c, e) => {<EOL>        const runAsNode = process.env['<STR_LIT>'];<EOL>        const noAttach = process.env['<STR_LIT>'];<EOL>        const mark = generateUuid().replace(/-/g, '<STR_LIT>').substr(<NUM_LIT>, <NUM_LIT>);<EOL>        const regex = new RegExp(mark + '<STR_LIT>' + mark);<EOL>        const env = assign({}, process.env, {<EOL>            ATOM_SHELL_INTERNAL_RUN_AS_NODE: '<STR_LIT>',<EOL>            ELECTRON_NO_ATTACH_CONSOLE:","gt":"'<STR_LIT>'"}
{"input":"<s> function getUnixShellEnvironment(): TPromise<IEnv> {<EOL>    const promise = new TPromise((c, e) => {<EOL>        const runAsNode = process.env['<STR_LIT>'];<EOL>        const noAttach = process.env['<STR_LIT>'];<EOL>        const mark = generateUuid().replace(/-/g, '<STR_LIT>').substr(<NUM_LIT>, <NUM_LIT>);<EOL>        const regex = new RegExp(mark + '<STR_LIT>' + mark);<EOL>        const env = assign({}, process.env, {<EOL>            ATOM_SHELL_INTERNAL_RUN_AS_NODE: '<STR_LIT>',<EOL>            ELECTRON_NO_ATTACH_CONSOLE: '<STR_LIT>'<EOL>        });<EOL>        const command = `<STR_LIT>`;<EOL>        const child = cp.spawn(process.env.SHELL, ['<STR_LIT>', command], {<EOL>            detached: true,<EOL>            stdio: ['<STR_LIT>', '<STR_LIT>', process.stderr],<EOL>","gt":"env"}
{"input":"<s> function getUnixShellEnvironment(): TPromise<IEnv> {<EOL>    const promise = new TPromise((c, e) => {<EOL>        const runAsNode = process.env['<STR_LIT>'];<EOL>        const noAttach = process.env['<STR_LIT>'];<EOL>        const mark = generateUuid().replace(/-/g, '<STR_LIT>').substr(<NUM_LIT>, <NUM_LIT>);<EOL>        const regex = new RegExp(mark + '<STR_LIT>' + mark);<EOL>        const env = assign({}, process.env, {<EOL>            ATOM_SHELL_INTERNAL_RUN_AS_NODE: '<STR_LIT>',<EOL>            ELECTRON_NO_ATTACH_CONSOLE: '<STR_LIT>'<EOL>        });<EOL>        const command = `<STR_LIT>`;<EOL>        const child = cp.spawn(process.env.SHELL, ['<STR_LIT>', command], {<EOL>            detached: true,<EOL>            stdio: ['<STR_LIT>', '<STR_LIT>', process.stderr],<EOL>            env<EOL>        });<EOL>        const buffers: Buffer[] = [];<EOL>        child.on('<STR_LIT>', () => c({}));<EOL>        child.stdout.on('<STR_LIT>', b => buffers.push(b));<EOL>        child.on('<STR_LIT>', (code: number, signal: any) => {<EOL>","gt":"if (code !== <NUM_LIT>) {"}
{"input":"<s> function getUnixShellEnvironment(): TPromise<IEnv> {<EOL>    const promise = new TPromise((c, e) => {<EOL>        const runAsNode = process.env['<STR_LIT>'];<EOL>        const noAttach = process.env['<STR_LIT>'];<EOL>        const mark = generateUuid().replace(/-/g, '<STR_LIT>').substr(<NUM_LIT>, <NUM_LIT>);<EOL>        const regex = new RegExp(mark + '<STR_LIT>' + mark);<EOL>        const env = assign({}, process.env, {<EOL>            ATOM_SHELL_INTERNAL_RUN_AS_NODE: '<STR_LIT>',<EOL>            ELECTRON_NO_ATTACH_CONSOLE: '<STR_LIT>'<EOL>        });<EOL>        const command = `<STR_LIT>`;<EOL>        const child = cp.spawn(process.env.SHELL, ['<STR_LIT>', command], {<EOL>            detached: true,<EOL>            stdio: ['<STR_LIT>', '<STR_LIT>', process.stderr],<EOL>            env<EOL>        });<EOL>        const buffers: Buffer[] = [];<EOL>        child.on('<STR_LIT>', () => c({}));<EOL>        child.stdout.on('<STR_LIT>', b => buffers.push(b));<EOL>        child.on('<STR_LIT>', (code: number, signal: any) => {<EOL>            if (code !== <NUM_LIT>) {<EOL>                return e(new Error('<STR_LIT>'));<EOL>            }<EOL>            const raw = Buffer.concat(buffers).toString('<STR_LIT>');<EOL>            const match = regex.exec(raw);<EOL>            const rawStripped = match ? match[<NUM_LIT>] :","gt":"'<STR_LIT>';"}
{"input":"<s> function getUnixShellEnvironment(): TPromise<IEnv> {<EOL>    const promise = new TPromise((c, e) => {<EOL>        const runAsNode = process.env['<STR_LIT>'];<EOL>        const noAttach = process.env['<STR_LIT>'];<EOL>        const mark = generateUuid().replace(/-/g, '<STR_LIT>').substr(<NUM_LIT>, <NUM_LIT>);<EOL>        const regex = new RegExp(mark + '<STR_LIT>' + mark);<EOL>        const env = assign({}, process.env, {<EOL>            ATOM_SHELL_INTERNAL_RUN_AS_NODE: '<STR_LIT>',<EOL>            ELECTRON_NO_ATTACH_CONSOLE: '<STR_LIT>'<EOL>        });<EOL>        const command = `<STR_LIT>`;<EOL>        const child = cp.spawn(process.env.SHELL, ['<STR_LIT>', command], {<EOL>            detached: true,<EOL>            stdio: ['<STR_LIT>', '<STR_LIT>', process.stderr],<EOL>            env<EOL>        });<EOL>        const buffers: Buffer[] = [];<EOL>        child.on('<STR_LIT>', () => c({}));<EOL>        child.stdout.on('<STR_LIT>', b => buffers.push(b));<EOL>        child.on('<STR_LIT>', (code: number, signal: any) => {<EOL>            if (code !== <NUM_LIT>) {<EOL>                return e(new Error('<STR_LIT>'));<EOL>            }<EOL>            const raw = Buffer.concat(buffers).toString('<STR_LIT>');<EOL>            const match = regex.exec(raw);<EOL>            const rawStripped = match ? match[<NUM_LIT>] : '<STR_LIT>';<EOL>            try {<EOL>                const env = JSON.parse(rawStripped);<EOL>                if (runAsNode) {<EOL>                    env['<STR_LIT>'] = runAsNode;<EOL>                }<EOL>                else {<EOL>                    delete env['<STR_LIT>'];<EOL>                }<EOL>                if (noAttach) {<EOL>                    env['<STR_LIT>'] = noAttach;<EOL>                }<EOL>                else {<EOL>                    delete env['<STR_LIT>'];<EOL>                }<EOL>","gt":"c(env);"}
{"input":"<s> function getUnixShellEnvironment(): TPromise<IEnv> {<EOL>    const promise = new TPromise((c, e) => {<EOL>        const runAsNode = process.env['<STR_LIT>'];<EOL>        const noAttach = process.env['<STR_LIT>'];<EOL>        const mark = generateUuid().replace(/-/g, '<STR_LIT>').substr(<NUM_LIT>, <NUM_LIT>);<EOL>        const regex = new RegExp(mark + '<STR_LIT>' + mark);<EOL>        const env = assign({}, process.env, {<EOL>            ATOM_SHELL_INTERNAL_RUN_AS_NODE: '<STR_LIT>',<EOL>            ELECTRON_NO_ATTACH_CONSOLE: '<STR_LIT>'<EOL>        });<EOL>        const command = `<STR_LIT>`;<EOL>        const child = cp.spawn(process.env.SHELL, ['<STR_LIT>', command], {<EOL>            detached: true,<EOL>            stdio: ['<STR_LIT>', '<STR_LIT>', process.stderr],<EOL>            env<EOL>        });<EOL>        const buffers: Buffer[] = [];<EOL>        child.on('<STR_LIT>', () => c({}));<EOL>        child.stdout.on('<STR_LIT>', b => buffers.push(b));<EOL>        child.on('<STR_LIT>', (code: number, signal: any) => {<EOL>            if (code !== <NUM_LIT>) {<EOL>                return e(new Error('<STR_LIT>'));<EOL>            }<EOL>            const raw = Buffer.concat(buffers).toString('<STR_LIT>');<EOL>            const match = regex.exec(raw);<EOL>            const rawStripped = match ? match[<NUM_LIT>] : '<STR_LIT>';<EOL>            try {<EOL>                const env = JSON.parse(rawStripped);<EOL>                if (runAsNode) {<EOL>                    env['<STR_LIT>'] = runAsNode;<EOL>                }<EOL>                else {<EOL>                    delete env['<STR_LIT>'];<EOL>                }<EOL>                if (noAttach) {<EOL>                    env['<STR_LIT>'] = noAttach;<EOL>                }<EOL>                else {<EOL>                    delete env['<STR_LIT>'];<EOL>                }<EOL>                c(env);<EOL>            }<EOL>","gt":"catch (err) {"}
{"input":"<s> /**<EOL> * @ignore<EOL> */<EOL>export function intersectProto<T>(this: IterableX<T>, second: IterableX<T>, comparer?: (x: T, y: T) => boolean) {<EOL>    return","gt":"intersect(this, second, comparer);"}
{"input":"<s> export function generateDiv(width = <NUM_LIT>, height = <NUM_LIT>): d3.Selection<HTMLDivElement, void | {}, any, any> {<EOL>    const","gt":"parent = getElementParent();"}
{"input":"<s> export function isMultilineText(text: string): boolean {<EOL>","gt":"return /\\n/.test(text);"}
{"input":"<s> async function finalizeExtensionActivation(): Promise<void> {<EOL>    const cpptoolsJsonFile: string = util.getExtensionFilePath(\"<STR_LIT>\");<EOL>    try {<EOL>        const exists: boolean = await util.checkFileExists(cpptoolsJsonFile);<EOL>        if (exists) {<EOL>            const","gt":"cpptoolsString: string = await util.readFileText(cpptoolsJsonFile);"}
{"input":"<s> async function finalizeExtensionActivation(): Promise<void> {<EOL>    const cpptoolsJsonFile: string = util.getExtensionFilePath(\"<STR_LIT>\");<EOL>    try {<EOL>        const exists: boolean = await util.checkFileExists(cpptoolsJsonFile);<EOL>        if (exists) {<EOL>            const cpptoolsString: string = await util.readFileText(cpptoolsJsonFile);<EOL>            await cpptoolsJsonUtils.processCpptoolsJson(cpptoolsString);<EOL>        }<EOL>    }<EOL>    catch (","gt":"error) {"}
{"input":"<s> async function finalizeExtensionActivation(): Promise<void> {<EOL>    const cpptoolsJsonFile: string = util.getExtensionFilePath(\"<STR_LIT>\");<EOL>    try {<EOL>        const exists: boolean = await util.checkFileExists(cpptoolsJsonFile);<EOL>        if (exists) {<EOL>            const cpptoolsString: string = await util.readFileText(cpptoolsJsonFile);<EOL>            await cpptoolsJsonUtils.processCpptoolsJson(cpptoolsString);<EOL>        }<EOL>    }<EOL>    catch (error) {<EOL>        <EOL>    }<EOL>","gt":"getTemporaryCommandRegistrarInstance().activateLanguageServer();"}
{"input":"<s> export default function (GanttColumn: {<EOL>    new (date: moment.Moment, endDate: moment.Moment, left: number, width: number, calendar: GanttCalendar, timeFramesWorkingMode?: TimeFramesDisplayMode, timeFramesNonWorkingMode?: TimeFramesDisplayMode): GanttColumn;<EOL>}) {<EOL>","gt":"'<STR_LIT>';"}
{"input":"<s> function getPropDocData(srcPath: string, docClassName: string, inputs: any[], outputs: any[]) {<EOL>    let prog = ts.createProgram([srcPath], {<EOL>        target: ts.ScriptTarget.ES5, module: ts.ModuleKind.CommonJS<EOL>    });<EOL>    let sourceFiles = prog.","gt":"getSourceFiles();"}
{"input":"<s> function getPropDocData(srcPath: string, docClassName: string, inputs: any[], outputs: any[]) {<EOL>    let prog = ts.createProgram([srcPath], {<EOL>        target: ts.ScriptTarget.ES5, module: ts.ModuleKind.CommonJS<EOL>    });<EOL>    let sourceFiles = prog.getSourceFiles();<EOL>    let checker = prog.getTypeChecker();<EOL>    for (var i = <NUM_LIT>; i < sourceFiles.length; i++) {<EOL>","gt":"if (!sourceFiles[i].isDeclarationFile)"}
{"input":"<s> function getPropDocData(srcPath: string, docClassName: string, inputs: any[], outputs: any[]) {<EOL>    let prog = ts.createProgram([srcPath], {<EOL>        target: ts.ScriptTarget.ES5, module: ts.ModuleKind.CommonJS<EOL>    });<EOL>    let sourceFiles = prog.getSourceFiles();<EOL>    let checker = prog.getTypeChecker();<EOL>    for (var i = <NUM_LIT>; i < sourceFiles.length; i++) {<EOL>        if (!sourceFiles[i].isDeclarationFile)<EOL>            ts.forEachChild(sourceFiles[i], visit);<EOL>    }<EOL>    function visit(node: ts.Node) {<EOL>        if (!isNodeExported(","gt":"node))"}
{"input":"<s> function getPropDocData(srcPath: string, docClassName: string, inputs: any[], outputs: any[]) {<EOL>    let prog = ts.createProgram([srcPath], {<EOL>        target: ts.ScriptTarget.ES5, module: ts.ModuleKind.CommonJS<EOL>    });<EOL>    let sourceFiles = prog.getSourceFiles();<EOL>    let checker = prog.getTypeChecker();<EOL>    for (var i = <NUM_LIT>; i < sourceFiles.length; i++) {<EOL>        if (!sourceFiles[i].isDeclarationFile)<EOL>            ts.forEachChild(sourceFiles[i], visit);<EOL>    }<EOL>    function visit(node: ts.Node) {<EOL>        if (!isNodeExported(node))<EOL>            return;<EOL>        if (ts.isClassDeclaration(node) && node.name) {<EOL>            let classDec: ts.ClassDeclaration = node;<EOL>            let sourceFile = classDec.getSourceFile();<EOL>","gt":"if (classDec.name.escapedText === docClassName) {"}
{"input":"<s> export function browserDownloadDeployCoreAsync(resp: pxtc.CompileResult): Promise<void> {<EOL>    let url = \"<STR_LIT>\";<EOL>    const ext = pxt.outputName().replace(/[^.]*/, \"<STR_LIT>\");<EOL>    const","gt":"out = resp.outfiles[pxt.outputName()];"}
{"input":"<s> export function browserDownloadDeployCoreAsync(resp: pxtc.CompileResult): Promise<void> {<EOL>    let url = \"<STR_LIT>\";<EOL>    const ext = pxt.outputName().replace(/[^.]*/, \"<STR_LIT>\");<EOL>    const out = resp.outfiles[pxt.outputName()];<EOL>    const fn = pkg.genFileName(ext);<EOL>    const userContext = pxt.BrowserUtils.isBrowserDownloadWithinUserContext();<EOL>    if (","gt":"userContext) {"}
{"input":"<s> export function browserDownloadDeployCoreAsync(resp: pxtc.CompileResult): Promise<void> {<EOL>    let url = \"<STR_LIT>\";<EOL>    const ext = pxt.outputName().replace(/[^.]*/, \"<STR_LIT>\");<EOL>    const out = resp.outfiles[pxt.outputName()];<EOL>    const fn = pkg.genFileName(ext);<EOL>    const userContext = pxt.BrowserUtils.isBrowserDownloadWithinUserContext();<EOL>    if (userContext) {<EOL>        url = pxt.BrowserUtils.toDownloadDataUri(pxt.isOutputText() ? ts.pxtc.encodeBase64(out) : out, pxt.appTarget.compile.hexMimeType);<EOL>    }<EOL>    else if (!pxt.isOutputText()) {<EOL>        pxt.debug(","gt":"'<STR_LIT>' + fn);"}
{"input":"<s> export function browserDownloadDeployCoreAsync(resp: pxtc.CompileResult): Promise<void> {<EOL>    let url = \"<STR_LIT>\";<EOL>    const ext = pxt.outputName().replace(/[^.]*/, \"<STR_LIT>\");<EOL>    const out = resp.outfiles[pxt.outputName()];<EOL>    const fn = pkg.genFileName(ext);<EOL>    const userContext = pxt.BrowserUtils.isBrowserDownloadWithinUserContext();<EOL>    if (userContext) {<EOL>        url = pxt.BrowserUtils.toDownloadDataUri(pxt.isOutputText() ? ts.pxtc.encodeBase64(out) : out, pxt.appTarget.compile.hexMimeType);<EOL>    }<EOL>    else if (!pxt.isOutputText()) {<EOL>        pxt.debug('<STR_LIT>' + fn);<EOL>        url = pxt.BrowserUtils.browserDownloadBase64(out, fn, \"<STR_LIT>\", resp.userContextWindow, e => core.errorNotification(lf(\"<STR_LIT>\")));<EOL>    }<EOL>","gt":"else {"}
{"input":"<s> export function browserDownloadDeployCoreAsync(resp: pxtc.CompileResult): Promise<void> {<EOL>    let url = \"<STR_LIT>\";<EOL>    const ext = pxt.outputName().replace(/[^.]*/, \"<STR_LIT>\");<EOL>    const out = resp.outfiles[pxt.outputName()];<EOL>    const fn = pkg.genFileName(ext);<EOL>    const userContext = pxt.BrowserUtils.isBrowserDownloadWithinUserContext();<EOL>    if (userContext) {<EOL>        url = pxt.BrowserUtils.toDownloadDataUri(pxt.isOutputText() ? ts.pxtc.encodeBase64(out) : out, pxt.appTarget.compile.hexMimeType);<EOL>    }<EOL>    else if (!pxt.isOutputText()) {<EOL>        pxt.debug('<STR_LIT>' + fn);<EOL>        url = pxt.BrowserUtils.browserDownloadBase64(out, fn, \"<STR_LIT>\", resp.userContextWindow, e => core.errorNotification(lf(\"<STR_LIT>\")));<EOL>    }<EOL>    else {<EOL>        pxt.debug('<STR_LIT>' + fn);<EOL>        url = pxt.BrowserUtils.browserDownloadBinText(out, fn, pxt.appTarget.compile.hexMimeType, resp.userContextWindow, e => core.errorNotification(lf(\"<STR_LIT>\")));<EOL>    }<EOL>","gt":"if (!resp.success) {"}
{"input":"<s> export function browserDownloadDeployCoreAsync(resp: pxtc.CompileResult): Promise<void> {<EOL>    let url = \"<STR_LIT>\";<EOL>    const ext = pxt.outputName().replace(/[^.]*/, \"<STR_LIT>\");<EOL>    const out = resp.outfiles[pxt.outputName()];<EOL>    const fn = pkg.genFileName(ext);<EOL>    const userContext = pxt.BrowserUtils.isBrowserDownloadWithinUserContext();<EOL>    if (userContext) {<EOL>        url = pxt.BrowserUtils.toDownloadDataUri(pxt.isOutputText() ? ts.pxtc.encodeBase64(out) : out, pxt.appTarget.compile.hexMimeType);<EOL>    }<EOL>    else if (!pxt.isOutputText()) {<EOL>        pxt.debug('<STR_LIT>' + fn);<EOL>        url = pxt.BrowserUtils.browserDownloadBase64(out, fn, \"<STR_LIT>\", resp.userContextWindow, e => core.errorNotification(lf(\"<STR_LIT>\")));<EOL>    }<EOL>    else {<EOL>        pxt.debug('<STR_LIT>' + fn);<EOL>        url = pxt.BrowserUtils.browserDownloadBinText(out, fn, pxt.appTarget.compile.hexMimeType, resp.userContextWindow, e => core.errorNotification(lf(\"<STR_LIT>\")));<EOL>    }<EOL>    if (!resp.success) {<EOL>        return core.confirmAsync({<EOL>            header: lf(\"<STR_LIT>\"),<EOL>            body: lf(\"<STR_LIT>\"),<EOL>            hideAgree: true,<EOL>            disagreeLbl: lf(","gt":"\"<STR_LIT>\")"}
{"input":"<s> export function* updateTokenBalance(action: SetTokenBalancePendingAction): SagaIterator {<EOL>    try {<EOL>        const isOffline = yield select(getOffline);<EOL>        if (isOffline) {<EOL>            return;<EOL>        }<EOL>        const wallet: null | IWallet = yield select(getWalletInst);<EOL>        const { tokenSymbol } = action.","gt":"payload;"}
{"input":"<s> export function* updateTokenBalance(action: SetTokenBalancePendingAction): SagaIterator {<EOL>    try {<EOL>        const isOffline = yield select(getOffline);<EOL>        if (isOffline) {<EOL>            return;<EOL>        }<EOL>        const wallet: null | IWallet = yield select(getWalletInst);<EOL>        const { tokenSymbol } = action.payload;<EOL>        const allTokens: Token[] = yield select(getAllTokens);<EOL>        const token = allTokens.find(t => t.symbol === tokenSymbol);<EOL>        if (!wallet) {<EOL>            return;<EOL>        }<EOL>        if (!token) {<EOL>            throw Error('<STR_LIT>');<EOL>        }<EOL>        const tokenBalances: TokenBalanceLookup = yield call(getTokenBalances, wallet, [token]);<EOL>        yield put(setTokenBalanceFulfilled(","gt":"tokenBalances));"}
{"input":"<s> function hasNonMatchingParameterType2(x: string): x is number {<EOL>    return","gt":"true;"}
{"input":"<s> /**<EOL> * @description grabs wallet and required tx parameters via selectors, and assigns<EOL> * the rest of the tx parameters from the action<EOL> * @param partialTx<EOL> */<EOL>function* getWalletAndTransaction(partialTx: SignTransactionRequestedAction['<STR_LIT>']) {<EOL>    <EOL>    const wallet: null | IFullWallet = yield select(getWalletInst);<EOL>    if (!wallet) {<EOL>        throw Error(","gt":"'<STR_LIT>');"}
{"input":"<s> /**<EOL> * @description grabs wallet and required tx parameters via selectors, and assigns<EOL> * the rest of the tx parameters from the action<EOL> * @param partialTx<EOL> */<EOL>function* getWalletAndTransaction(partialTx: SignTransactionRequestedAction['<STR_LIT>']) {<EOL>    <EOL>    const wallet: null | IFullWallet = yield select(getWalletInst);<EOL>    if (!wallet) {<EOL>        throw Error('<STR_LIT>');<EOL>    }<EOL>    <EOL>    const { chainId }: StaticNetworkConfig = yield select(getNetworkConfig);<EOL>    <EOL>    partialTx._chainId = chainId;<EOL>","gt":"return {"}
{"input":"<s> /**<EOL> * Replace model ids with models recursively.<EOL> */<EOL>export function unpack_models(value, manager): Promise<any> {<EOL>    let unpacked;<EOL>    if (Array.isArray(value)) {<EOL>        unpacked = [];<EOL>        value.forEach((sub_value, key) => {<EOL>","gt":"unpacked.push(unpack_models(sub_value, manager));"}
{"input":"<s> /**<EOL> * Replace model ids with models recursively.<EOL> */<EOL>export function unpack_models(value, manager): Promise<any> {<EOL>    let unpacked;<EOL>    if (Array.isArray(value)) {<EOL>        unpacked = [];<EOL>        value.forEach((sub_value, key) => {<EOL>            unpacked.push(unpack_models(sub_value, manager));<EOL>        });<EOL>","gt":"return Promise.all(unpacked);"}
{"input":"<s> /**<EOL> * Replace model ids with models recursively.<EOL> */<EOL>export function unpack_models(value, manager): Promise<any> {<EOL>    let unpacked;<EOL>    if (Array.isArray(value)) {<EOL>        unpacked = [];<EOL>        value.forEach((sub_value, key) => {<EOL>            unpacked.push(unpack_models(sub_value, manager));<EOL>        });<EOL>        return Promise.all(unpacked);<EOL>    }<EOL>    else if (value instanceof Object) {<EOL>        unpacked = {};<EOL>        Object.keys(value).forEach((key) => {<EOL>            unpacked[key] = unpack_models(value[","gt":"key], manager);"}
{"input":"<s> <EOL>function* g() {<EOL>    var x =","gt":"class C extends (yield) {"}
{"input":"<s> /**<EOL> * Bakes group transforms into paths.<EOL> */<EOL>function fn(item: JsApi, params: Params) {<EOL>    if (!item.isElem('<STR_LIT>') ||<EOL>        !item.hasAttr() ||<EOL>","gt":"item.hasAttr('<STR_LIT>') ||"}
{"input":"<s> /**<EOL> * Bakes group transforms into paths.<EOL> */<EOL>function fn(item: JsApi, params: Params) {<EOL>    if (!item.isElem('<STR_LIT>') ||<EOL>        !item.hasAttr() ||<EOL>        item.hasAttr('<STR_LIT>') ||<EOL>        item.isEmpty() ||<EOL>        item.content.some(i => i.hasAttr('<STR_LIT>')) ||<EOL>        <EOL>        item.content.some(","gt":"i => i.isElem('<STR_LIT>'))) {"}
{"input":"<s> /**<EOL> * Bakes group transforms into paths.<EOL> */<EOL>function fn(item: JsApi, params: Params) {<EOL>    if (!item.isElem('<STR_LIT>') ||<EOL>        !item.hasAttr() ||<EOL>        item.hasAttr('<STR_LIT>') ||<EOL>        item.isEmpty() ||<EOL>        item.content.some(i => i.hasAttr('<STR_LIT>')) ||<EOL>        <EOL>        item.content.some(i => i.isElem('<STR_LIT>'))) {<EOL>        return item;<EOL>    }<EOL>    const {","gt":"floatPrecision } = params;"}
{"input":"<s> /**<EOL> * Bakes group transforms into paths.<EOL> */<EOL>function fn(item: JsApi, params: Params) {<EOL>    if (!item.isElem('<STR_LIT>') ||<EOL>        !item.hasAttr() ||<EOL>        item.hasAttr('<STR_LIT>') ||<EOL>        item.isEmpty() ||<EOL>        item.content.some(i => i.hasAttr('<STR_LIT>')) ||<EOL>        <EOL>        item.content.some(i => i.isElem('<STR_LIT>'))) {<EOL>        return item;<EOL>    }<EOL>    const { floatPrecision } = params;<EOL>    const error = +Math.pow(<NUM_LIT>, floatPrecision).toFixed(floatPrecision);<EOL>    /**<EOL>     * Decrease accuracy of floating-point numbers<EOL>     * in path data keeping a specified number of decimals.<EOL>     * Smart rounds values like 2.3491 to 2.35 instead of 2.349.<EOL>     * Doesn't apply \"smartness\" if the number precision fits already.<EOL>     *<EOL>     * @param {Array} data input data array<EOL>     * @return {Array} output data array<EOL>     */<EOL>    function strongRound(data: number[]) {<EOL>        for (","gt":"let i = data.length; i-- > <NUM_LIT>;) {"}
{"input":"<s> /**<EOL> * Bakes group transforms into paths.<EOL> */<EOL>function fn(item: JsApi, params: Params) {<EOL>    if (!item.isElem('<STR_LIT>') ||<EOL>        !item.hasAttr() ||<EOL>        item.hasAttr('<STR_LIT>') ||<EOL>        item.isEmpty() ||<EOL>        item.content.some(i => i.hasAttr('<STR_LIT>')) ||<EOL>        <EOL>        item.content.some(i => i.isElem('<STR_LIT>'))) {<EOL>        return item;<EOL>    }<EOL>    const { floatPrecision } = params;<EOL>    const error = +Math.pow(<NUM_LIT>, floatPrecision).toFixed(floatPrecision);<EOL>    /**<EOL>     * Decrease accuracy of floating-point numbers<EOL>     * in path data keeping a specified number of decimals.<EOL>     * Smart rounds values like 2.3491 to 2.35 instead of 2.349.<EOL>     * Doesn't apply \"smartness\" if the number precision fits already.<EOL>     *<EOL>     * @param {Array} data input data array<EOL>     * @return {Array} output data array<EOL>     */<EOL>    function strongRound(data: number[]) {<EOL>        for (let i = data.length; i-- > <NUM_LIT>;) {<EOL>            if (+","gt":"data[i].toFixed(floatPrecision) !== data[i]) {"}
{"input":"<s> /**<EOL> * Bakes group transforms into paths.<EOL> */<EOL>function fn(item: JsApi, params: Params) {<EOL>    if (!item.isElem('<STR_LIT>') ||<EOL>        !item.hasAttr() ||<EOL>        item.hasAttr('<STR_LIT>') ||<EOL>        item.isEmpty() ||<EOL>        item.content.some(i => i.hasAttr('<STR_LIT>')) ||<EOL>        <EOL>        item.content.some(i => i.isElem('<STR_LIT>'))) {<EOL>        return item;<EOL>    }<EOL>    const { floatPrecision } = params;<EOL>    const error = +Math.pow(<NUM_LIT>, floatPrecision).toFixed(floatPrecision);<EOL>    /**<EOL>     * Decrease accuracy of floating-point numbers<EOL>     * in path data keeping a specified number of decimals.<EOL>     * Smart rounds values like 2.3491 to 2.35 instead of 2.349.<EOL>     * Doesn't apply \"smartness\" if the number precision fits already.<EOL>     *<EOL>     * @param {Array} data input data array<EOL>     * @return {Array} output data array<EOL>     */<EOL>    function strongRound(data: number[]) {<EOL>        for (let i = data.length; i-- > <NUM_LIT>;) {<EOL>            if (+data[i].toFixed(floatPrecision) !== data[i]) {<EOL>                const rounded = +data[i].toFixed(floatPrecision - <NUM_LIT>);<EOL>                data[i] =<EOL>                    +Math.abs(rounded - data[i]).toFixed(floatPrecision + <NUM_LIT>) >= error<EOL>                        ? +data[i].toFixed(floatPrecision)<EOL>                        : rounded;<EOL>            }<EOL>        }<EOL>","gt":"return data;"}
{"input":"<s> /**<EOL> * Bakes group transforms into paths.<EOL> */<EOL>function fn(item: JsApi, params: Params) {<EOL>    if (!item.isElem('<STR_LIT>') ||<EOL>        !item.hasAttr() ||<EOL>        item.hasAttr('<STR_LIT>') ||<EOL>        item.isEmpty() ||<EOL>        item.content.some(i => i.hasAttr('<STR_LIT>')) ||<EOL>        <EOL>        item.content.some(i => i.isElem('<STR_LIT>'))) {<EOL>        return item;<EOL>    }<EOL>    const { floatPrecision } = params;<EOL>    const error = +Math.pow(<NUM_LIT>, floatPrecision).toFixed(floatPrecision);<EOL>    /**<EOL>     * Decrease accuracy of floating-point numbers<EOL>     * in path data keeping a specified number of decimals.<EOL>     * Smart rounds values like 2.3491 to 2.35 instead of 2.349.<EOL>     * Doesn't apply \"smartness\" if the number precision fits already.<EOL>     *<EOL>     * @param {Array} data input data array<EOL>     * @return {Array} output data array<EOL>     */<EOL>    function strongRound(data: number[]) {<EOL>        for (let i = data.length; i-- > <NUM_LIT>;) {<EOL>            if (+data[i].toFixed(floatPrecision) !== data[i]) {<EOL>                const rounded = +data[i].toFixed(floatPrecision - <NUM_LIT>);<EOL>                data[i] =<EOL>                    +Math.abs(rounded - data[i]).toFixed(floatPrecision + <NUM_LIT>) >= error<EOL>                        ? +data[i].toFixed(floatPrecision)<EOL>                        : rounded;<EOL>            }<EOL>        }<EOL>        return data;<EOL>    }<EOL>    /**<EOL>     * Simple rounding function if precision is 0.<EOL>     *<EOL>     * @param {Array} data input data array<EOL>     * @return {Array} output data array<EOL>     */<EOL>    function round(data: number[]) {<EOL>        for (let i = data.length; i-- > <NUM_LIT>;) {<EOL>            data[i] = Math.round(data[i]);<EOL>        }<EOL>        return data;<EOL>    }<EOL>    const roundData = floatPrecision > <NUM_LIT> && floatPrecision < <NUM_LIT> ?","gt":"strongRound : round;"}
{"input":"<s> /**<EOL> * Bakes group transforms into paths.<EOL> */<EOL>function fn(item: JsApi, params: Params) {<EOL>    if (!item.isElem('<STR_LIT>') ||<EOL>        !item.hasAttr() ||<EOL>        item.hasAttr('<STR_LIT>') ||<EOL>        item.isEmpty() ||<EOL>        item.content.some(i => i.hasAttr('<STR_LIT>')) ||<EOL>        <EOL>        item.content.some(i => i.isElem('<STR_LIT>'))) {<EOL>        return item;<EOL>    }<EOL>    const { floatPrecision } = params;<EOL>    const error = +Math.pow(<NUM_LIT>, floatPrecision).toFixed(floatPrecision);<EOL>    /**<EOL>     * Decrease accuracy of floating-point numbers<EOL>     * in path data keeping a specified number of decimals.<EOL>     * Smart rounds values like 2.3491 to 2.35 instead of 2.349.<EOL>     * Doesn't apply \"smartness\" if the number precision fits already.<EOL>     *<EOL>     * @param {Array} data input data array<EOL>     * @return {Array} output data array<EOL>     */<EOL>    function strongRound(data: number[]) {<EOL>        for (let i = data.length; i-- > <NUM_LIT>;) {<EOL>            if (+data[i].toFixed(floatPrecision) !== data[i]) {<EOL>                const rounded = +data[i].toFixed(floatPrecision - <NUM_LIT>);<EOL>                data[i] =<EOL>                    +Math.abs(rounded - data[i]).toFixed(floatPrecision + <NUM_LIT>) >= error<EOL>                        ? +data[i].toFixed(floatPrecision)<EOL>                        : rounded;<EOL>            }<EOL>        }<EOL>        return data;<EOL>    }<EOL>    /**<EOL>     * Simple rounding function if precision is 0.<EOL>     *<EOL>     * @param {Array} data input data array<EOL>     * @return {Array} output data array<EOL>     */<EOL>    function round(data: number[]) {<EOL>        for (let i = data.length; i-- > <NUM_LIT>;) {<EOL>            data[i] = Math.round(data[i]);<EOL>        }<EOL>        return data;<EOL>    }<EOL>    const roundData = floatPrecision > <NUM_LIT> && floatPrecision < <NUM_LIT> ? strongRound : round;<EOL>    const g1Attrs = getGroupAttrs(item);<EOL>    item.content.forEach(i => {<EOL>        if (i.isElem('<STR_LIT>')) {<EOL>            const g2Attrs = getGroupAttrs(i);<EOL>            const matrix = flattenGroups([g1Attrs, g2Attrs]);<EOL>            const { sx, sy } = getScaling(matrix);<EOL>            const { r } = getRotation(matrix);<EOL>            const { tx, ty } = getTranslation(","gt":"matrix);"}
{"input":"<s> /**<EOL> * Bakes group transforms into paths.<EOL> */<EOL>function fn(item: JsApi, params: Params) {<EOL>    if (!item.isElem('<STR_LIT>') ||<EOL>        !item.hasAttr() ||<EOL>        item.hasAttr('<STR_LIT>') ||<EOL>        item.isEmpty() ||<EOL>        item.content.some(i => i.hasAttr('<STR_LIT>')) ||<EOL>        <EOL>        item.content.some(i => i.isElem('<STR_LIT>'))) {<EOL>        return item;<EOL>    }<EOL>    const { floatPrecision } = params;<EOL>    const error = +Math.pow(<NUM_LIT>, floatPrecision).toFixed(floatPrecision);<EOL>    /**<EOL>     * Decrease accuracy of floating-point numbers<EOL>     * in path data keeping a specified number of decimals.<EOL>     * Smart rounds values like 2.3491 to 2.35 instead of 2.349.<EOL>     * Doesn't apply \"smartness\" if the number precision fits already.<EOL>     *<EOL>     * @param {Array} data input data array<EOL>     * @return {Array} output data array<EOL>     */<EOL>    function strongRound(data: number[]) {<EOL>        for (let i = data.length; i-- > <NUM_LIT>;) {<EOL>            if (+data[i].toFixed(floatPrecision) !== data[i]) {<EOL>                const rounded = +data[i].toFixed(floatPrecision - <NUM_LIT>);<EOL>                data[i] =<EOL>                    +Math.abs(rounded - data[i]).toFixed(floatPrecision + <NUM_LIT>) >= error<EOL>                        ? +data[i].toFixed(floatPrecision)<EOL>                        : rounded;<EOL>            }<EOL>        }<EOL>        return data;<EOL>    }<EOL>    /**<EOL>     * Simple rounding function if precision is 0.<EOL>     *<EOL>     * @param {Array} data input data array<EOL>     * @return {Array} output data array<EOL>     */<EOL>    function round(data: number[]) {<EOL>        for (let i = data.length; i-- > <NUM_LIT>;) {<EOL>            data[i] = Math.round(data[i]);<EOL>        }<EOL>        return data;<EOL>    }<EOL>    const roundData = floatPrecision > <NUM_LIT> && floatPrecision < <NUM_LIT> ? strongRound : round;<EOL>    const g1Attrs = getGroupAttrs(item);<EOL>    item.content.forEach(i => {<EOL>        if (i.isElem('<STR_LIT>')) {<EOL>            const g2Attrs = getGroupAttrs(i);<EOL>            const matrix = flattenGroups([g1Attrs, g2Attrs]);<EOL>            const { sx, sy } = getScaling(matrix);<EOL>            const { r } = getRotation(matrix);<EOL>            const { tx, ty } = getTranslation(matrix);<EOL>            const g3Attrs = { sx, sy, r, tx, ty };<EOL>            const addAttrFn = (local: string, value: number) => {<EOL>                i.addAttr({<EOL>                    name: `<STR_LIT>`,<EOL>","gt":"prefix: '<STR_LIT>',"}
{"input":"<s> /**<EOL> * Bakes group transforms into paths.<EOL> */<EOL>function fn(item: JsApi, params: Params) {<EOL>    if (!item.isElem('<STR_LIT>') ||<EOL>        !item.hasAttr() ||<EOL>        item.hasAttr('<STR_LIT>') ||<EOL>        item.isEmpty() ||<EOL>        item.content.some(i => i.hasAttr('<STR_LIT>')) ||<EOL>        <EOL>        item.content.some(i => i.isElem('<STR_LIT>'))) {<EOL>        return item;<EOL>    }<EOL>    const { floatPrecision } = params;<EOL>    const error = +Math.pow(<NUM_LIT>, floatPrecision).toFixed(floatPrecision);<EOL>    /**<EOL>     * Decrease accuracy of floating-point numbers<EOL>     * in path data keeping a specified number of decimals.<EOL>     * Smart rounds values like 2.3491 to 2.35 instead of 2.349.<EOL>     * Doesn't apply \"smartness\" if the number precision fits already.<EOL>     *<EOL>     * @param {Array} data input data array<EOL>     * @return {Array} output data array<EOL>     */<EOL>    function strongRound(data: number[]) {<EOL>        for (let i = data.length; i-- > <NUM_LIT>;) {<EOL>            if (+data[i].toFixed(floatPrecision) !== data[i]) {<EOL>                const rounded = +data[i].toFixed(floatPrecision - <NUM_LIT>);<EOL>                data[i] =<EOL>                    +Math.abs(rounded - data[i]).toFixed(floatPrecision + <NUM_LIT>) >= error<EOL>                        ? +data[i].toFixed(floatPrecision)<EOL>                        : rounded;<EOL>            }<EOL>        }<EOL>        return data;<EOL>    }<EOL>    /**<EOL>     * Simple rounding function if precision is 0.<EOL>     *<EOL>     * @param {Array} data input data array<EOL>     * @return {Array} output data array<EOL>     */<EOL>    function round(data: number[]) {<EOL>        for (let i = data.length; i-- > <NUM_LIT>;) {<EOL>            data[i] = Math.round(data[i]);<EOL>        }<EOL>        return data;<EOL>    }<EOL>    const roundData = floatPrecision > <NUM_LIT> && floatPrecision < <NUM_LIT> ? strongRound : round;<EOL>    const g1Attrs = getGroupAttrs(item);<EOL>    item.content.forEach(i => {<EOL>        if (i.isElem('<STR_LIT>')) {<EOL>            const g2Attrs = getGroupAttrs(i);<EOL>            const matrix = flattenGroups([g1Attrs, g2Attrs]);<EOL>            const { sx, sy } = getScaling(matrix);<EOL>            const { r } = getRotation(matrix);<EOL>            const { tx, ty } = getTranslation(matrix);<EOL>            const g3Attrs = { sx, sy, r, tx, ty };<EOL>            const addAttrFn = (local: string, value: number) => {<EOL>                i.addAttr({<EOL>                    name: `<STR_LIT>`,<EOL>                    prefix: '<STR_LIT>',<EOL>                    local,<EOL>                    value: String(value),<EOL>                });<EOL>            };<EOL>            addAttrFn('<STR_LIT>', sx);<EOL>            addAttrFn('<STR_LIT>', sy);<EOL>            addAttrFn('<STR_LIT>', r);<EOL>            addAttrFn('<STR_LIT>', tx);<EOL>            addAttrFn('<STR_LIT>', ty);<EOL>        }<EOL>        else if (i.isElem('<STR_LIT>') || i.isElem('<STR_LIT>')) {<EOL>            let data =","gt":"path2js(i);"}
{"input":"<s> /**<EOL> * Bakes group transforms into paths.<EOL> */<EOL>function fn(item: JsApi, params: Params) {<EOL>    if (!item.isElem('<STR_LIT>') ||<EOL>        !item.hasAttr() ||<EOL>        item.hasAttr('<STR_LIT>') ||<EOL>        item.isEmpty() ||<EOL>        item.content.some(i => i.hasAttr('<STR_LIT>')) ||<EOL>        <EOL>        item.content.some(i => i.isElem('<STR_LIT>'))) {<EOL>        return item;<EOL>    }<EOL>    const { floatPrecision } = params;<EOL>    const error = +Math.pow(<NUM_LIT>, floatPrecision).toFixed(floatPrecision);<EOL>    /**<EOL>     * Decrease accuracy of floating-point numbers<EOL>     * in path data keeping a specified number of decimals.<EOL>     * Smart rounds values like 2.3491 to 2.35 instead of 2.349.<EOL>     * Doesn't apply \"smartness\" if the number precision fits already.<EOL>     *<EOL>     * @param {Array} data input data array<EOL>     * @return {Array} output data array<EOL>     */<EOL>    function strongRound(data: number[]) {<EOL>        for (let i = data.length; i-- > <NUM_LIT>;) {<EOL>            if (+data[i].toFixed(floatPrecision) !== data[i]) {<EOL>                const rounded = +data[i].toFixed(floatPrecision - <NUM_LIT>);<EOL>                data[i] =<EOL>                    +Math.abs(rounded - data[i]).toFixed(floatPrecision + <NUM_LIT>) >= error<EOL>                        ? +data[i].toFixed(floatPrecision)<EOL>                        : rounded;<EOL>            }<EOL>        }<EOL>        return data;<EOL>    }<EOL>    /**<EOL>     * Simple rounding function if precision is 0.<EOL>     *<EOL>     * @param {Array} data input data array<EOL>     * @return {Array} output data array<EOL>     */<EOL>    function round(data: number[]) {<EOL>        for (let i = data.length; i-- > <NUM_LIT>;) {<EOL>            data[i] = Math.round(data[i]);<EOL>        }<EOL>        return data;<EOL>    }<EOL>    const roundData = floatPrecision > <NUM_LIT> && floatPrecision < <NUM_LIT> ? strongRound : round;<EOL>    const g1Attrs = getGroupAttrs(item);<EOL>    item.content.forEach(i => {<EOL>        if (i.isElem('<STR_LIT>')) {<EOL>            const g2Attrs = getGroupAttrs(i);<EOL>            const matrix = flattenGroups([g1Attrs, g2Attrs]);<EOL>            const { sx, sy } = getScaling(matrix);<EOL>            const { r } = getRotation(matrix);<EOL>            const { tx, ty } = getTranslation(matrix);<EOL>            const g3Attrs = { sx, sy, r, tx, ty };<EOL>            const addAttrFn = (local: string, value: number) => {<EOL>                i.addAttr({<EOL>                    name: `<STR_LIT>`,<EOL>                    prefix: '<STR_LIT>',<EOL>                    local,<EOL>                    value: String(value),<EOL>                });<EOL>            };<EOL>            addAttrFn('<STR_LIT>', sx);<EOL>            addAttrFn('<STR_LIT>', sy);<EOL>            addAttrFn('<STR_LIT>', r);<EOL>            addAttrFn('<STR_LIT>', tx);<EOL>            addAttrFn('<STR_LIT>', ty);<EOL>        }<EOL>        else if (i.isElem('<STR_LIT>') || i.isElem('<STR_LIT>')) {<EOL>            let data = path2js(i);<EOL>            if (!data.length) {<EOL>                return;<EOL>            }<EOL>            convertToRelative(data);<EOL>            data = applyTransforms(item, i, data,","gt":"params);"}
{"input":"<s> /**<EOL> * Bakes group transforms into paths.<EOL> */<EOL>function fn(item: JsApi, params: Params) {<EOL>    if (!item.isElem('<STR_LIT>') ||<EOL>        !item.hasAttr() ||<EOL>        item.hasAttr('<STR_LIT>') ||<EOL>        item.isEmpty() ||<EOL>        item.content.some(i => i.hasAttr('<STR_LIT>')) ||<EOL>        <EOL>        item.content.some(i => i.isElem('<STR_LIT>'))) {<EOL>        return item;<EOL>    }<EOL>    const { floatPrecision } = params;<EOL>    const error = +Math.pow(<NUM_LIT>, floatPrecision).toFixed(floatPrecision);<EOL>    /**<EOL>     * Decrease accuracy of floating-point numbers<EOL>     * in path data keeping a specified number of decimals.<EOL>     * Smart rounds values like 2.3491 to 2.35 instead of 2.349.<EOL>     * Doesn't apply \"smartness\" if the number precision fits already.<EOL>     *<EOL>     * @param {Array} data input data array<EOL>     * @return {Array} output data array<EOL>     */<EOL>    function strongRound(data: number[]) {<EOL>        for (let i = data.length; i-- > <NUM_LIT>;) {<EOL>            if (+data[i].toFixed(floatPrecision) !== data[i]) {<EOL>                const rounded = +data[i].toFixed(floatPrecision - <NUM_LIT>);<EOL>                data[i] =<EOL>                    +Math.abs(rounded - data[i]).toFixed(floatPrecision + <NUM_LIT>) >= error<EOL>                        ? +data[i].toFixed(floatPrecision)<EOL>                        : rounded;<EOL>            }<EOL>        }<EOL>        return data;<EOL>    }<EOL>    /**<EOL>     * Simple rounding function if precision is 0.<EOL>     *<EOL>     * @param {Array} data input data array<EOL>     * @return {Array} output data array<EOL>     */<EOL>    function round(data: number[]) {<EOL>        for (let i = data.length; i-- > <NUM_LIT>;) {<EOL>            data[i] = Math.round(data[i]);<EOL>        }<EOL>        return data;<EOL>    }<EOL>    const roundData = floatPrecision > <NUM_LIT> && floatPrecision < <NUM_LIT> ? strongRound : round;<EOL>    const g1Attrs = getGroupAttrs(item);<EOL>    item.content.forEach(i => {<EOL>        if (i.isElem('<STR_LIT>')) {<EOL>            const g2Attrs = getGroupAttrs(i);<EOL>            const matrix = flattenGroups([g1Attrs, g2Attrs]);<EOL>            const { sx, sy } = getScaling(matrix);<EOL>            const { r } = getRotation(matrix);<EOL>            const { tx, ty } = getTranslation(matrix);<EOL>            const g3Attrs = { sx, sy, r, tx, ty };<EOL>            const addAttrFn = (local: string, value: number) => {<EOL>                i.addAttr({<EOL>                    name: `<STR_LIT>`,<EOL>                    prefix: '<STR_LIT>',<EOL>                    local,<EOL>                    value: String(value),<EOL>                });<EOL>            };<EOL>            addAttrFn('<STR_LIT>', sx);<EOL>            addAttrFn('<STR_LIT>', sy);<EOL>            addAttrFn('<STR_LIT>', r);<EOL>            addAttrFn('<STR_LIT>', tx);<EOL>            addAttrFn('<STR_LIT>', ty);<EOL>        }<EOL>        else if (i.isElem('<STR_LIT>') || i.isElem('<STR_LIT>')) {<EOL>            let data = path2js(i);<EOL>            if (!data.length) {<EOL>                return;<EOL>            }<EOL>            convertToRelative(data);<EOL>            data = applyTransforms(item, i, data, params);<EOL>","gt":"data.forEach(d => {"}
{"input":"<s> function loadSvgIcons(svgIcons: Array<{<EOL>    name: string;<EOL>    path: string;<EOL>}>) {<EOL>    const matIconRegistry = TestBed.get(MatIconRegistry);<EOL>    const sanitizer = TestBed.","gt":"get(DomSanitizer);"}
{"input":"<s> export function fromPosition(position: types.Position): IPosition {<EOL>    return {","gt":"lineNumber: position.line + <NUM_LIT>, column: position.character + <NUM_LIT> };"}
{"input":"<s> function hasNonMathcingGenericType<T>(a: string): a is T[] {<EOL>    return","gt":"true;"}
{"input":"<s> /**<EOL> * @ignore<EOL> */<EOL>export function sorter<TElement>(fst: TElement, snd: TElement): number {<EOL>    return fst > snd ? <NUM_LIT> :","gt":"fst < snd ? -<NUM_LIT> : <NUM_LIT>;"}
{"input":"<s> function render(text: string): string {<EOL>","gt":"return escape(text);"}
{"input":"<s> function isIgnoredPropertyValue(name: string, a: any, b: any, ignoredPropertyValues: (string | RegExp)[] | IgnorePropertyFunction) {<EOL>    return Array.isArray(ignoredPropertyValues)<EOL>        ? ignoredPropertyValues.","gt":"some((value) => {"}
{"input":"<s> function* getFrom(): SagaIterator {<EOL>    yield put(getFromRequested());<EOL>    <EOL>    const { type }: GetFromFailedAction | GetFromSucceededAction = yield take([<EOL>        TK.","gt":"GET_FROM_SUCCEEDED,"}
{"input":"<s> function* getFrom(): SagaIterator {<EOL>    yield put(getFromRequested());<EOL>    <EOL>    const { type }: GetFromFailedAction | GetFromSucceededAction = yield take([<EOL>        TK.GET_FROM_SUCCEEDED,<EOL>        TK.GET_FROM_FAILED<EOL>    ]);<EOL>    <EOL>","gt":"if (type === TK.GET_FROM_FAILED) {"}
{"input":"<s> export default function ($compile, $document) {<EOL>    '<STR_LIT>';<EOL>    return {<EOL>        restrict: '<STR_LIT>',<EOL>        require: '<STR_LIT>',<EOL>","gt":"scope: {"}
{"input":"<s> export default function ($compile, $document) {<EOL>    '<STR_LIT>';<EOL>    return {<EOL>        restrict: '<STR_LIT>',<EOL>        require: '<STR_LIT>',<EOL>        scope: {<EOL>            enabled: '<STR_LIT>',<EOL>            dateFormat:","gt":"'<STR_LIT>',"}
{"input":"<s> export default function ($compile, $document) {<EOL>    '<STR_LIT>';<EOL>    return {<EOL>        restrict: '<STR_LIT>',<EOL>        require: '<STR_LIT>',<EOL>        scope: {<EOL>            enabled: '<STR_LIT>',<EOL>            dateFormat: '<STR_LIT>',<EOL>            content: '<STR_LIT>',<EOL>            delay:","gt":"'<STR_LIT>'"}
{"input":"<s> export default function ($compile, $document) {<EOL>    '<STR_LIT>';<EOL>    return {<EOL>        restrict: '<STR_LIT>',<EOL>        require: '<STR_LIT>',<EOL>        scope: {<EOL>            enabled: '<STR_LIT>',<EOL>            dateFormat: '<STR_LIT>',<EOL>            content: '<STR_LIT>',<EOL>            delay: '<STR_LIT>'<EOL>        },<EOL>        link: function (scope, element, attrs,","gt":"ganttCtrl) {"}
{"input":"<s> export default function ($compile, $document) {<EOL>    '<STR_LIT>';<EOL>    return {<EOL>        restrict: '<STR_LIT>',<EOL>        require: '<STR_LIT>',<EOL>        scope: {<EOL>            enabled: '<STR_LIT>',<EOL>            dateFormat: '<STR_LIT>',<EOL>            content: '<STR_LIT>',<EOL>            delay: '<STR_LIT>'<EOL>        },<EOL>        link: function (scope, element, attrs, ganttCtrl) {<EOL>            let api = ganttCtrl.gantt.api;<EOL>            <EOL>            if (scope.options && typeof (scope.options.tooltips) === '<STR_LIT>') {<EOL>                for (let option in scope.options.tooltips) {<EOL>                    scope[option] = scope.options.tooltips[","gt":"option];"}
{"input":"<s> export default function ($compile, $document) {<EOL>    '<STR_LIT>';<EOL>    return {<EOL>        restrict: '<STR_LIT>',<EOL>        require: '<STR_LIT>',<EOL>        scope: {<EOL>            enabled: '<STR_LIT>',<EOL>            dateFormat: '<STR_LIT>',<EOL>            content: '<STR_LIT>',<EOL>            delay: '<STR_LIT>'<EOL>        },<EOL>        link: function (scope, element, attrs, ganttCtrl) {<EOL>            let api = ganttCtrl.gantt.api;<EOL>            <EOL>            if (scope.options && typeof (scope.options.tooltips) === '<STR_LIT>') {<EOL>                for (let option in scope.options.tooltips) {<EOL>                    scope[option] = scope.options.tooltips[option];<EOL>                }<EOL>            }<EOL>            if (scope.enabled === undefined) {<EOL>                scope.enabled = true;<EOL>            }<EOL>            if (","gt":"scope.dateFormat === undefined) {"}
{"input":"<s> export default function ($compile, $document) {<EOL>    '<STR_LIT>';<EOL>    return {<EOL>        restrict: '<STR_LIT>',<EOL>        require: '<STR_LIT>',<EOL>        scope: {<EOL>            enabled: '<STR_LIT>',<EOL>            dateFormat: '<STR_LIT>',<EOL>            content: '<STR_LIT>',<EOL>            delay: '<STR_LIT>'<EOL>        },<EOL>        link: function (scope, element, attrs, ganttCtrl) {<EOL>            let api = ganttCtrl.gantt.api;<EOL>            <EOL>            if (scope.options && typeof (scope.options.tooltips) === '<STR_LIT>') {<EOL>                for (let option in scope.options.tooltips) {<EOL>                    scope[option] = scope.options.tooltips[option];<EOL>                }<EOL>            }<EOL>            if (scope.enabled === undefined) {<EOL>                scope.enabled = true;<EOL>            }<EOL>            if (scope.dateFormat === undefined) {<EOL>                scope.dateFormat = '<STR_LIT>';<EOL>            }<EOL>            if (scope.delay === undefined) {<EOL>                scope.delay = <NUM_LIT>;<EOL>            }<EOL>            if (scope.content ===","gt":"undefined) {"}
{"input":"<s> export default function ($compile, $document) {<EOL>    '<STR_LIT>';<EOL>    return {<EOL>        restrict: '<STR_LIT>',<EOL>        require: '<STR_LIT>',<EOL>        scope: {<EOL>            enabled: '<STR_LIT>',<EOL>            dateFormat: '<STR_LIT>',<EOL>            content: '<STR_LIT>',<EOL>            delay: '<STR_LIT>'<EOL>        },<EOL>        link: function (scope, element, attrs, ganttCtrl) {<EOL>            let api = ganttCtrl.gantt.api;<EOL>            <EOL>            if (scope.options && typeof (scope.options.tooltips) === '<STR_LIT>') {<EOL>                for (let option in scope.options.tooltips) {<EOL>                    scope[option] = scope.options.tooltips[option];<EOL>                }<EOL>            }<EOL>            if (scope.enabled === undefined) {<EOL>                scope.enabled = true;<EOL>            }<EOL>            if (scope.dateFormat === undefined) {<EOL>                scope.dateFormat = '<STR_LIT>';<EOL>            }<EOL>            if (scope.delay === undefined) {<EOL>                scope.delay = <NUM_LIT>;<EOL>            }<EOL>            if (scope.content === undefined) {<EOL>                scope.content = '<STR_LIT>' +<EOL>                    '<STR_LIT>' +<EOL>                    '<STR_LIT>' +<EOL>                    '<STR_LIT>';<EOL>            }<EOL>            scope.api = api;<EOL>            api.directives.on.new(scope, function (directiveName, taskScope, taskElement) {<EOL>                if (directiveName === '<STR_LIT>') {<EOL>                    let tooltipScope = taskScope.$new();<EOL>                    tooltipScope.pluginScope = scope;<EOL>                    let ifElement = $document[<NUM_LIT>].createElement(","gt":"'<STR_LIT>');"}
{"input":"<s> /**<EOL> * A guard that determines if the value is a `SpliceRecord`<EOL> *<EOL> * @param value The value to check<EOL> */<EOL>function isSpliceRecord(value: any): value is SpliceRecord {<EOL>    return","gt":"value && value.type === '<STR_LIT>' && '<STR_LIT>' in value && '<STR_LIT>' in value;"}
{"input":"<s> function newHashObj(): {<EOL>    [name: string]: any;<EOL>} {<EOL>","gt":"return Object.create(null);"}
{"input":"<s> export function array<T>(value: any): value is T[] {<EOL>    return","gt":"Array.isArray(value);"}
{"input":"<s> export default function () {<EOL>    '<STR_LIT>';<EOL>    <EOL>    return {<EOL>","gt":"restrict: '<STR_LIT>',"}
{"input":"<s> export default function () {<EOL>    '<STR_LIT>';<EOL>    <EOL>    return {<EOL>        restrict: '<STR_LIT>',<EOL>        require: ['<STR_LIT>',","gt":"'<STR_LIT>'],"}
{"input":"<s> export default function () {<EOL>    '<STR_LIT>';<EOL>    <EOL>    return {<EOL>        restrict: '<STR_LIT>',<EOL>        require: ['<STR_LIT>', '<STR_LIT>'],<EOL>        link: function (scope, element, attrs, controllers) {<EOL>            let el = element[<NUM_LIT>];<EOL>            let updateListeners =","gt":"function () {"}
{"input":"<s> export default function () {<EOL>    '<STR_LIT>';<EOL>    <EOL>    return {<EOL>        restrict: '<STR_LIT>',<EOL>        require: ['<STR_LIT>', '<STR_LIT>'],<EOL>        link: function (scope, element, attrs, controllers) {<EOL>            let el = element[<NUM_LIT>];<EOL>            let updateListeners = function () {<EOL>                let i;<EOL>                let l;<EOL>                let vertical = controllers[<NUM_LIT>].getVerticalRecievers();<EOL>                for (i = <NUM_LIT>, l = vertical.length; i < l; i++) {<EOL>                    let vElement =","gt":"vertical[i];"}
{"input":"<s> export default function () {<EOL>    '<STR_LIT>';<EOL>    <EOL>    return {<EOL>        restrict: '<STR_LIT>',<EOL>        require: ['<STR_LIT>', '<STR_LIT>'],<EOL>        link: function (scope, element, attrs, controllers) {<EOL>            let el = element[<NUM_LIT>];<EOL>            let updateListeners = function () {<EOL>                let i;<EOL>                let l;<EOL>                let vertical = controllers[<NUM_LIT>].getVerticalRecievers();<EOL>                for (i = <NUM_LIT>, l = vertical.length; i < l; i++) {<EOL>                    let vElement = vertical[i];<EOL>                    if (vElement.parentNode.scrollTop !== el.scrollTop) {<EOL>                        vElement.parentNode.scrollTop = el.scrollTop;<EOL>                    }<EOL>                }<EOL>                let horizontal = controllers[<NUM_LIT>].getHorizontalRecievers();<EOL>                for (i = <NUM_LIT>, l = horizontal.length; i < l; i++) {<EOL>                    let hElement = horizontal[i];<EOL>                    if (hElement.parentNode.scrollLeft !== el.scrollLeft) {<EOL>                        hElement.parentNode.scrollLeft =","gt":"el.scrollLeft;"}
{"input":"<s> export default function () {<EOL>    '<STR_LIT>';<EOL>    <EOL>    return {<EOL>        restrict: '<STR_LIT>',<EOL>        require: ['<STR_LIT>', '<STR_LIT>'],<EOL>        link: function (scope, element, attrs, controllers) {<EOL>            let el = element[<NUM_LIT>];<EOL>            let updateListeners = function () {<EOL>                let i;<EOL>                let l;<EOL>                let vertical = controllers[<NUM_LIT>].getVerticalRecievers();<EOL>                for (i = <NUM_LIT>, l = vertical.length; i < l; i++) {<EOL>                    let vElement = vertical[i];<EOL>                    if (vElement.parentNode.scrollTop !== el.scrollTop) {<EOL>                        vElement.parentNode.scrollTop = el.scrollTop;<EOL>                    }<EOL>                }<EOL>                let horizontal = controllers[<NUM_LIT>].getHorizontalRecievers();<EOL>                for (i = <NUM_LIT>, l = horizontal.length; i < l; i++) {<EOL>                    let hElement = horizontal[i];<EOL>                    if (hElement.parentNode.scrollLeft !== el.scrollLeft) {<EOL>                        hElement.parentNode.scrollLeft = el.scrollLeft;<EOL>                    }<EOL>                }<EOL>            };<EOL>            element.bind('<STR_LIT>', updateListeners);<EOL>            scope.$watch(function () {<EOL>                return controllers[<NUM_LIT>].gantt.width;<EOL>            }, function (newValue, oldValue) {<EOL>                if (newValue !== oldValue) {<EOL>                    let","gt":"horizontal = controllers[<NUM_LIT>].getHorizontalRecievers();"}
{"input":"<s> export default function () {<EOL>    '<STR_LIT>';<EOL>    <EOL>    return {<EOL>        restrict: '<STR_LIT>',<EOL>        require: ['<STR_LIT>', '<STR_LIT>'],<EOL>        link: function (scope, element, attrs, controllers) {<EOL>            let el = element[<NUM_LIT>];<EOL>            let updateListeners = function () {<EOL>                let i;<EOL>                let l;<EOL>                let vertical = controllers[<NUM_LIT>].getVerticalRecievers();<EOL>                for (i = <NUM_LIT>, l = vertical.length; i < l; i++) {<EOL>                    let vElement = vertical[i];<EOL>                    if (vElement.parentNode.scrollTop !== el.scrollTop) {<EOL>                        vElement.parentNode.scrollTop = el.scrollTop;<EOL>                    }<EOL>                }<EOL>                let horizontal = controllers[<NUM_LIT>].getHorizontalRecievers();<EOL>                for (i = <NUM_LIT>, l = horizontal.length; i < l; i++) {<EOL>                    let hElement = horizontal[i];<EOL>                    if (hElement.parentNode.scrollLeft !== el.scrollLeft) {<EOL>                        hElement.parentNode.scrollLeft = el.scrollLeft;<EOL>                    }<EOL>                }<EOL>            };<EOL>            element.bind('<STR_LIT>', updateListeners);<EOL>            scope.$watch(function () {<EOL>                return controllers[<NUM_LIT>].gantt.width;<EOL>            }, function (newValue, oldValue) {<EOL>                if (newValue !== oldValue) {<EOL>                    let horizontal = controllers[<NUM_LIT>].getHorizontalRecievers();<EOL>                    <EOL>                    for (let i = <NUM_LIT>, l = horizontal.length; i < l; i++) {<EOL>","gt":"let hElement = horizontal[i];"}
{"input":"<s> function fn1(x2: number) {<EOL>","gt":"x2 **= value;"}
{"input":"<s> /**<EOL> * Takes two arrays of numbers and adds them together<EOL> *<EOL> * @param {number[]} aList The first array of numbers<EOL> * @param {number[]} bList The second array of numbers<EOL> * @return {number[]} An array of numbers where x[i] = aList[i] + bList[i]<EOL> */<EOL>export function add(aList: number[], bList: number[]): number[] {<EOL>    if (aList.length !== bList.length) {<EOL>        throw new Error(","gt":"\"<STR_LIT>\");"}
{"input":"<s> export function* ens(): SagaIterator {<EOL>    yield all([fork(","gt":"resolveDomain)]);"}
{"input":"<s> function define(constructor, instanceMembers, staticMembers) {<EOL>    constructor = constructor || function () { };<EOL>    PluginUtilities.Utilities.markSupportedForProcessing(constructor);<EOL>","gt":"if (instanceMembers) {"}
{"input":"<s> <EOL>function foo<T, U>(arg: {<EOL>    cb: new (t: T) => U;<EOL>}) {<EOL>    return","gt":"new arg.cb(null);"}
{"input":"<s> function runPlatformioAsync(args: string[]) {<EOL>    pxt.log(\"<STR_LIT>\" + args.join(\"<STR_LIT>\"));<EOL>    let child = child_process.spawn(\"<STR_LIT>\", args, {<EOL>        cwd: thisBuild.buildPath,<EOL>        stdio: \"<STR_LIT>\",<EOL>        env:","gt":"process.env"}
{"input":"<s> function runPlatformioAsync(args: string[]) {<EOL>    pxt.log(\"<STR_LIT>\" + args.join(\"<STR_LIT>\"));<EOL>    let child = child_process.spawn(\"<STR_LIT>\", args, {<EOL>        cwd: thisBuild.buildPath,<EOL>        stdio: \"<STR_LIT>\",<EOL>        env: process.env<EOL>    });<EOL>    return new Promise<void>((resolve, reject) => {<EOL>        child.on(\"<STR_LIT>\", (code: number) => {<EOL>            if (code === <NUM_LIT>)<EOL>                resolve();<EOL>","gt":"else"}
{"input":"<s> export default function () {<EOL>","gt":"'<STR_LIT>';"}
{"input":"<s> function assertUrl(raw: string, scheme: string, domain: string, port: string, path: string, queryString: string, fragmentId: string): void {<EOL>    <EOL>    const uri = URI.parse(raw);<EOL>    assert.","gt":"equal(uri.scheme, scheme);"}
{"input":"<s> function noneComputedMemoize() {<EOL>    console.time(\"<STR_LIT>\");<EOL>    class C {<EOL>        a: number;<EOL>        b: number;<EOL>","gt":"get sum() { return this.a + this.b; }"}
{"input":"<s> function noneComputedMemoize() {<EOL>    console.time(\"<STR_LIT>\");<EOL>    class C {<EOL>        a: number;<EOL>        b: number;<EOL>        get sum() { return this.a + this.b; }<EOL>    }<EOL>    let c = new C();<EOL>    c.a = <NUM_LIT>;<EOL>    c.b =","gt":"<NUM_LIT>;"}
{"input":"<s> function noneComputedMemoize() {<EOL>    console.time(\"<STR_LIT>\");<EOL>    class C {<EOL>        a: number;<EOL>        b: number;<EOL>        get sum() { return this.a + this.b; }<EOL>    }<EOL>    let c = new C();<EOL>    c.a = <NUM_LIT>;<EOL>    c.b = <NUM_LIT>;<EOL>    let s = <NUM_LIT>;<EOL>    for (let i = <NUM_LIT>; i < <NUM_LIT>; i++) {<EOL>        s += c.","gt":"sum;"}
{"input":"<s> function showFirmwareUpdateInstructionsAsync(resp: pxtc.CompileResult): Promise<void> {<EOL>    return pxt.targetConfigAsync()<EOL>        .then(config => {<EOL>        const firmwareUrl = (config.firmwareUrls || {})[pxt.appTarget.simulator.boardDefinition.id];<EOL>        if (!firmwareUrl) <EOL>            return","gt":"showWebUSBPairingInstructionsAsync(resp);"}
{"input":"<s> function showFirmwareUpdateInstructionsAsync(resp: pxtc.CompileResult): Promise<void> {<EOL>    return pxt.targetConfigAsync()<EOL>        .then(config => {<EOL>        const firmwareUrl = (config.firmwareUrls || {})[pxt.appTarget.simulator.boardDefinition.id];<EOL>        if (!firmwareUrl) <EOL>            return showWebUSBPairingInstructionsAsync(resp);<EOL>        pxt.tickEvent(`<STR_LIT>`);<EOL>        const boardName = pxt.appTarget.appTheme.boardName || lf(\"<STR_LIT>\");<EOL>        const driveName = pxt.appTarget.appTheme.driveDisplayName || \"<STR_LIT>\";<EOL>        const htmlBody =","gt":"\"<STR_LIT>\")}</strong>"}
{"input":"<s> function showFirmwareUpdateInstructionsAsync(resp: pxtc.CompileResult): Promise<void> {<EOL>    return pxt.targetConfigAsync()<EOL>        .then(config => {<EOL>        const firmwareUrl = (config.firmwareUrls || {})[pxt.appTarget.simulator.boardDefinition.id];<EOL>        if (!firmwareUrl) <EOL>            return showWebUSBPairingInstructionsAsync(resp);<EOL>        pxt.tickEvent(`<STR_LIT>`);<EOL>        const boardName = pxt.appTarget.appTheme.boardName || lf(\"<STR_LIT>\");<EOL>        const driveName = pxt.appTarget.appTheme.driveDisplayName || \"<STR_LIT>\";<EOL>        const htmlBody = `<STR_LIT>`;<EOL>        return core.confirmAsync({<EOL>            header: lf(\"<STR_LIT>\"),<EOL>            htmlBody,<EOL>","gt":"agreeLbl: lf(\"<STR_LIT>\")"}
{"input":"<s> export function fixInsert(tree: PieceTreeBase, x: TreeNode) {<EOL>    recomputeTreeMetadata(tree, x);<EOL>    while (x !== tree.root && x.parent.color === NodeColor.Red) {<EOL>        if (x.parent === x.parent.parent.left) {<EOL>            const y =","gt":"x.parent.parent.right;"}
{"input":"<s> export function fixInsert(tree: PieceTreeBase, x: TreeNode) {<EOL>    recomputeTreeMetadata(tree, x);<EOL>    while (x !== tree.root && x.parent.color === NodeColor.Red) {<EOL>        if (x.parent === x.parent.parent.left) {<EOL>            const y = x.parent.parent.right;<EOL>","gt":"if (y.color === NodeColor.Red) {"}
{"input":"<s> export function fixInsert(tree: PieceTreeBase, x: TreeNode) {<EOL>    recomputeTreeMetadata(tree, x);<EOL>    while (x !== tree.root && x.parent.color === NodeColor.Red) {<EOL>        if (x.parent === x.parent.parent.left) {<EOL>            const y = x.parent.parent.right;<EOL>            if (y.color === NodeColor.Red) {<EOL>                x.parent.color = NodeColor.Black;<EOL>                y.color = NodeColor.Black;<EOL>","gt":"x.parent.parent.color = NodeColor.Red;"}
{"input":"<s> export function fixInsert(tree: PieceTreeBase, x: TreeNode) {<EOL>    recomputeTreeMetadata(tree, x);<EOL>    while (x !== tree.root && x.parent.color === NodeColor.Red) {<EOL>        if (x.parent === x.parent.parent.left) {<EOL>            const y = x.parent.parent.right;<EOL>            if (y.color === NodeColor.Red) {<EOL>                x.parent.color = NodeColor.Black;<EOL>                y.color = NodeColor.Black;<EOL>                x.parent.parent.color = NodeColor.Red;<EOL>                x = x.parent.parent;<EOL>            }<EOL>            else {<EOL>                if (x === x.parent.right) {<EOL>","gt":"x = x.parent;"}
{"input":"<s> export function fixInsert(tree: PieceTreeBase, x: TreeNode) {<EOL>    recomputeTreeMetadata(tree, x);<EOL>    while (x !== tree.root && x.parent.color === NodeColor.Red) {<EOL>        if (x.parent === x.parent.parent.left) {<EOL>            const y = x.parent.parent.right;<EOL>            if (y.color === NodeColor.Red) {<EOL>                x.parent.color = NodeColor.Black;<EOL>                y.color = NodeColor.Black;<EOL>                x.parent.parent.color = NodeColor.Red;<EOL>                x = x.parent.parent;<EOL>            }<EOL>            else {<EOL>                if (x === x.parent.right) {<EOL>                    x = x.parent;<EOL>                    leftRotate(tree, x);<EOL>                }<EOL>                x.parent.color = NodeColor.Black;<EOL>                x.parent.","gt":"parent.color = NodeColor.Red;"}
{"input":"<s> export function fixInsert(tree: PieceTreeBase, x: TreeNode) {<EOL>    recomputeTreeMetadata(tree, x);<EOL>    while (x !== tree.root && x.parent.color === NodeColor.Red) {<EOL>        if (x.parent === x.parent.parent.left) {<EOL>            const y = x.parent.parent.right;<EOL>            if (y.color === NodeColor.Red) {<EOL>                x.parent.color = NodeColor.Black;<EOL>                y.color = NodeColor.Black;<EOL>                x.parent.parent.color = NodeColor.Red;<EOL>                x = x.parent.parent;<EOL>            }<EOL>            else {<EOL>                if (x === x.parent.right) {<EOL>                    x = x.parent;<EOL>                    leftRotate(tree, x);<EOL>                }<EOL>                x.parent.color = NodeColor.Black;<EOL>                x.parent.parent.color = NodeColor.Red;<EOL>                rightRotate(tree, x.parent.parent);<EOL>            }<EOL>        }<EOL>        else {<EOL>","gt":"const y = x.parent.parent.left;"}
{"input":"<s> export function fixInsert(tree: PieceTreeBase, x: TreeNode) {<EOL>    recomputeTreeMetadata(tree, x);<EOL>    while (x !== tree.root && x.parent.color === NodeColor.Red) {<EOL>        if (x.parent === x.parent.parent.left) {<EOL>            const y = x.parent.parent.right;<EOL>            if (y.color === NodeColor.Red) {<EOL>                x.parent.color = NodeColor.Black;<EOL>                y.color = NodeColor.Black;<EOL>                x.parent.parent.color = NodeColor.Red;<EOL>                x = x.parent.parent;<EOL>            }<EOL>            else {<EOL>                if (x === x.parent.right) {<EOL>                    x = x.parent;<EOL>                    leftRotate(tree, x);<EOL>                }<EOL>                x.parent.color = NodeColor.Black;<EOL>                x.parent.parent.color = NodeColor.Red;<EOL>                rightRotate(tree, x.parent.parent);<EOL>            }<EOL>        }<EOL>        else {<EOL>            const y = x.parent.parent.left;<EOL>            if (y.color === NodeColor.Red) {<EOL>                x.parent.color = NodeColor.Black;<EOL>                y.color = NodeColor.Black;<EOL>                x.parent.parent.color = NodeColor.Red;<EOL>                x = x.parent.parent;<EOL>            }<EOL>            else {<EOL>                if (x === x.parent.","gt":"left) {"}
{"input":"<s> export function fixInsert(tree: PieceTreeBase, x: TreeNode) {<EOL>    recomputeTreeMetadata(tree, x);<EOL>    while (x !== tree.root && x.parent.color === NodeColor.Red) {<EOL>        if (x.parent === x.parent.parent.left) {<EOL>            const y = x.parent.parent.right;<EOL>            if (y.color === NodeColor.Red) {<EOL>                x.parent.color = NodeColor.Black;<EOL>                y.color = NodeColor.Black;<EOL>                x.parent.parent.color = NodeColor.Red;<EOL>                x = x.parent.parent;<EOL>            }<EOL>            else {<EOL>                if (x === x.parent.right) {<EOL>                    x = x.parent;<EOL>                    leftRotate(tree, x);<EOL>                }<EOL>                x.parent.color = NodeColor.Black;<EOL>                x.parent.parent.color = NodeColor.Red;<EOL>                rightRotate(tree, x.parent.parent);<EOL>            }<EOL>        }<EOL>        else {<EOL>            const y = x.parent.parent.left;<EOL>            if (y.color === NodeColor.Red) {<EOL>                x.parent.color = NodeColor.Black;<EOL>                y.color = NodeColor.Black;<EOL>                x.parent.parent.color = NodeColor.Red;<EOL>                x = x.parent.parent;<EOL>            }<EOL>            else {<EOL>                if (x === x.parent.left) {<EOL>                    x = x.parent;<EOL>                    rightRotate(tree, x);<EOL>                }<EOL>","gt":"x.parent.color = NodeColor.Black;"}
{"input":"<s> function deleteWordLeft(cursor: Cursor) {<EOL>    cursorCommand(","gt":"cursor, H.DeleteWordLeft);"}
{"input":"<s> /**<EOL> * Convert transform string to JS representation.<EOL> *<EOL> * @param {String} transformString input string<EOL> * @param {Object} params plugin params<EOL> * @return {Array} output array<EOL> */<EOL>export function transform2js(transformString) {<EOL>    <EOL>    var transforms = [], <EOL>    <EOL>    current;<EOL>    <EOL>    transformString.split(regTransformSplit).forEach(function (","gt":"item) {"}
{"input":"<s> /**<EOL> * Convert transform string to JS representation.<EOL> *<EOL> * @param {String} transformString input string<EOL> * @param {Object} params plugin params<EOL> * @return {Array} output array<EOL> */<EOL>export function transform2js(transformString) {<EOL>    <EOL>    var transforms = [], <EOL>    <EOL>    current;<EOL>    <EOL>    transformString.split(regTransformSplit).forEach(function (item) {<EOL>        <EOL>        var num;<EOL>","gt":"if (item) {"}
{"input":"<s> export function* unlockPrivateKey(action: UnlockPrivateKeyAction): SagaIterator {<EOL>    let wallet: IWallet | null = null;<EOL>    const { key, password } = action.payload;<EOL>    try {<EOL>        wallet =","gt":"getPrivKeyWallet(key, password);"}
{"input":"<s> export function* unlockPrivateKey(action: UnlockPrivateKeyAction): SagaIterator {<EOL>    let wallet: IWallet | null = null;<EOL>    const { key, password } = action.payload;<EOL>    try {<EOL>        wallet = getPrivKeyWallet(key, password);<EOL>    }<EOL>    catch (e) {<EOL>        yield put(showNotification('<STR_LIT>', translate('<STR_LIT>')));<EOL>","gt":"return;"}
{"input":"<s> export function startupServiceFactory(configService: AppConfigService): Function {<EOL>","gt":"return () => configService.load();"}
{"input":"<s> /**<EOL> * @returns {string | number} This comment is not currently exposed<EOL> */<EOL>function f1() {<EOL>    return","gt":"<NUM_LIT> || true;"}
{"input":"<s> /**<EOL> * Take an array of values, and return the unique values.<EOL> * Will work iff ∀ a, b, a.toString() == b.toString() => a == b; will break on Object inputs<EOL> *<EOL> * @param {T[]} values The values to find uniqueness for<EOL> * @return {T[]} The unique values<EOL> */<EOL>export function uniq<T>(arr: T[]): T[] {<EOL>    const seen: d3.Set = d3.set();<EOL>    const result: T[] = [];<EOL>    arr.","gt":"forEach((x) => {"}
{"input":"<s> export function unregisterFocusRoot(ctx: IBobrilCtx) {<EOL>    let idx = focusRootStack.indexOf(ctx.me);<EOL>","gt":"if (idx !== -<NUM_LIT>) {"}
{"input":"<s> function scanWalletForTokens(state: State): State {<EOL>    return {<EOL>        ...","gt":"state,"}
{"input":"<s> function finishInitialize() {<EOL>","gt":"initializing = false;"}
{"input":"<s> function firstInvalidate() {<EOL>","gt":"initializing = true;"}
{"input":"<s> export function init(factory: () => any, element?: HTMLElement) {<EOL>    assert(rootIds == null, \"<STR_LIT>\");<EOL>    removeRoot(","gt":"\"<STR_LIT>\");"}
{"input":"<s> function testShiftCommandInDocBlockCommentMode(lines: string[], selection: Selection, expectedLines: string[], expectedSelection: Selection): void {<EOL>    testCommand(lines, new DocBlockCommentMode(), selection, (sel) => new ShiftCommand(sel, {<EOL>","gt":"isUnshift: false,"}
{"input":"<s> export function select(node: IBobrilCacheNode, start: number, end = start): void {<EOL>    (<any>node.element).setSelectionRange(Math.min(start, end), Math.max(start, end), start > end ? \"<STR_LIT>\" :","gt":"\"<STR_LIT>\");"}
{"input":"<s> export function wallet(state: State = INITIAL_STATE, action: WalletAction): State {<EOL>    switch (action.type) {<EOL>        case TypeKeys.WALLET_SET:<EOL>            return","gt":"setWallet(state, action);"}
{"input":"<s> export function wallet(state: State = INITIAL_STATE, action: WalletAction): State {<EOL>    switch (action.type) {<EOL>        case TypeKeys.WALLET_SET:<EOL>            return setWallet(state, action);<EOL>        case TypeKeys.WALLET_RESET:<EOL>            return INITIAL_STATE;<EOL>        case TypeKeys.WALLET_SET_BALANCE_PENDING:<EOL>            return setBalancePending(","gt":"state);"}
{"input":"<s> export function wallet(state: State = INITIAL_STATE, action: WalletAction): State {<EOL>    switch (action.type) {<EOL>        case TypeKeys.WALLET_SET:<EOL>            return setWallet(state, action);<EOL>        case TypeKeys.WALLET_RESET:<EOL>            return INITIAL_STATE;<EOL>        case TypeKeys.WALLET_SET_BALANCE_PENDING:<EOL>            return setBalancePending(state);<EOL>        case TypeKeys.WALLET_SET_BALANCE_FULFILLED:<EOL>            return setBalanceFullfilled(state, action);<EOL>        case TypeKeys.WALLET_SET_BALANCE_REJECTED:<EOL>            return setBalanceRejected(","gt":"state);"}
{"input":"<s> export function wallet(state: State = INITIAL_STATE, action: WalletAction): State {<EOL>    switch (action.type) {<EOL>        case TypeKeys.WALLET_SET:<EOL>            return setWallet(state, action);<EOL>        case TypeKeys.WALLET_RESET:<EOL>            return INITIAL_STATE;<EOL>        case TypeKeys.WALLET_SET_BALANCE_PENDING:<EOL>            return setBalancePending(state);<EOL>        case TypeKeys.WALLET_SET_BALANCE_FULFILLED:<EOL>            return setBalanceFullfilled(state, action);<EOL>        case TypeKeys.WALLET_SET_BALANCE_REJECTED:<EOL>            return setBalanceRejected(state);<EOL>        case","gt":"TypeKeys.WALLET_SET_PENDING:"}
{"input":"<s> export function wallet(state: State = INITIAL_STATE, action: WalletAction): State {<EOL>    switch (action.type) {<EOL>        case TypeKeys.WALLET_SET:<EOL>            return setWallet(state, action);<EOL>        case TypeKeys.WALLET_RESET:<EOL>            return INITIAL_STATE;<EOL>        case TypeKeys.WALLET_SET_BALANCE_PENDING:<EOL>            return setBalancePending(state);<EOL>        case TypeKeys.WALLET_SET_BALANCE_FULFILLED:<EOL>            return setBalanceFullfilled(state, action);<EOL>        case TypeKeys.WALLET_SET_BALANCE_REJECTED:<EOL>            return setBalanceRejected(state);<EOL>        case TypeKeys.WALLET_SET_PENDING:<EOL>            return setWalletPending(state, action);<EOL>        case TypeKeys.WALLET_SET_TOKEN_BALANCES_PENDING:<EOL>            return setTokenBalancesPending(","gt":"state);"}
{"input":"<s> export function wallet(state: State = INITIAL_STATE, action: WalletAction): State {<EOL>    switch (action.type) {<EOL>        case TypeKeys.WALLET_SET:<EOL>            return setWallet(state, action);<EOL>        case TypeKeys.WALLET_RESET:<EOL>            return INITIAL_STATE;<EOL>        case TypeKeys.WALLET_SET_BALANCE_PENDING:<EOL>            return setBalancePending(state);<EOL>        case TypeKeys.WALLET_SET_BALANCE_FULFILLED:<EOL>            return setBalanceFullfilled(state, action);<EOL>        case TypeKeys.WALLET_SET_BALANCE_REJECTED:<EOL>            return setBalanceRejected(state);<EOL>        case TypeKeys.WALLET_SET_PENDING:<EOL>            return setWalletPending(state, action);<EOL>        case TypeKeys.WALLET_SET_TOKEN_BALANCES_PENDING:<EOL>            return setTokenBalancesPending(state);<EOL>        case TypeKeys.WALLET_SET_TOKEN_BALANCES_FULFILLED:<EOL>            return setTokenBalancesFulfilled(state, action);<EOL>        case TypeKeys.WALLET_SET_TOKEN_BALANCES_REJECTED:<EOL>            return setTokenBalancesRejected(state);<EOL>","gt":"case TypeKeys.WALLET_SET_TOKEN_BALANCE_PENDING:"}
{"input":"<s> export function wallet(state: State = INITIAL_STATE, action: WalletAction): State {<EOL>    switch (action.type) {<EOL>        case TypeKeys.WALLET_SET:<EOL>            return setWallet(state, action);<EOL>        case TypeKeys.WALLET_RESET:<EOL>            return INITIAL_STATE;<EOL>        case TypeKeys.WALLET_SET_BALANCE_PENDING:<EOL>            return setBalancePending(state);<EOL>        case TypeKeys.WALLET_SET_BALANCE_FULFILLED:<EOL>            return setBalanceFullfilled(state, action);<EOL>        case TypeKeys.WALLET_SET_BALANCE_REJECTED:<EOL>            return setBalanceRejected(state);<EOL>        case TypeKeys.WALLET_SET_PENDING:<EOL>            return setWalletPending(state, action);<EOL>        case TypeKeys.WALLET_SET_TOKEN_BALANCES_PENDING:<EOL>            return setTokenBalancesPending(state);<EOL>        case TypeKeys.WALLET_SET_TOKEN_BALANCES_FULFILLED:<EOL>            return setTokenBalancesFulfilled(state, action);<EOL>        case TypeKeys.WALLET_SET_TOKEN_BALANCES_REJECTED:<EOL>            return setTokenBalancesRejected(state);<EOL>        case TypeKeys.WALLET_SET_TOKEN_BALANCE_PENDING:<EOL>            return setTokenBalancePending(state);<EOL>        case TypeKeys.WALLET_SET_TOKEN_BALANCE_FULFILLED:<EOL>            return setTokenBalanceFufilled(state, action);<EOL>        case TypeKeys.WALLET_SET_TOKEN_BALANCE_REJECTED:<EOL>            return setTokenBalanceRejected(state);<EOL>        case TypeKeys.WALLET_SCAN_WALLET_FOR_TOKENS:<EOL>            return scanWalletForTokens(","gt":"state);"}
{"input":"<s> function updateDndFromPointerEvent(dnd: IDndCtx, ev: IBobrilPointerEvent) {<EOL>    dnd.shift = ev.shift;<EOL>    dnd.ctrl = ev.","gt":"ctrl;"}
{"input":"<s> function setDropEffect(ev: DragEvent, op: DndOp) {<EOL>    ev.dataTransfer.dropEffect = [\"<STR_LIT>\", \"<STR_LIT>\",","gt":"\"<STR_LIT>\", \"<STR_LIT>\"][op];"}
{"input":"<s> export function on(target: any, methodName: string, advice: Function): core.IHandle {<EOL>","gt":"return advise(getDispatcher(target, methodName), '<STR_LIT>', advice, true);"}
{"input":"<s> export function getRoutes() {<EOL>    return","gt":"rootRoutes;"}
{"input":"<s> function lineHasNoDecorations(model, lineNumber) {<EOL>    lineHasDecorations(model,","gt":"lineNumber, []);"}
{"input":"<s> export function propim<T>(value: T, ctx?: IBobrilCtx, onChange?: (value: T, old: T) => void): IProp<T> {<EOL>    return (val?: T) => {<EOL>        if (val !== undefined && val !== value) {<EOL>            const oldVal = val;<EOL>","gt":"value = val;"}
{"input":"<s> export function* loadBityRates(): SagaIterator {<EOL>    while (true) {<EOL>        try {<EOL>            const data = yield call(getAllRates);<EOL>            yield put(loadBityRatesSucceededSwap(data));<EOL>        }<EOL>        catch (error) {<EOL>            const hasNotified = yield select(getHasNotifiedRatesFailure);<EOL>            if (!hasNotified) {<EOL>                console.","gt":"error('<STR_LIT>', error);"}
{"input":"<s> export function* loadBityRates(): SagaIterator {<EOL>    while (true) {<EOL>        try {<EOL>            const data = yield call(getAllRates);<EOL>            yield put(loadBityRatesSucceededSwap(data));<EOL>        }<EOL>        catch (error) {<EOL>            const hasNotified = yield select(getHasNotifiedRatesFailure);<EOL>            if (!hasNotified) {<EOL>                console.error('<STR_LIT>', error);<EOL>                yield put(showNotification('<STR_LIT>', error.message));<EOL>            }<EOL>            yield","gt":"put(loadBityRatesFailedSwap());"}
{"input":"<s> /**<EOL> * Return a memoized version of the input function. The memoized function<EOL> * reduces unnecessary invocations of the input by keeping a cache of the<EOL> * return value of compute:<EOL> *<EOL> * <pre><EOL> * function compute(a, b) { return a + b }<EOL> * const memoizedCompute = memoize(compute);<EOL> *<EOL> * compute(3, 7) == 10<EOL> * compute(3, 7) == 10 // cache hit<EOL> * </pre><EOL> *<EOL> * Cache invalidation is complicated by mutable classes (Scales and Datasets).<EOL> * The Signature API is built to solve this issue by constructing an immutable<EOL> * snapshot of Scales/Datasets on memoized function invocation, which is itself<EOL> * a performance hit. Thus we introduce a \"doLocked\" method that momentarily<EOL> * bypasses sign/comparison logic and simply returns the cached value.<EOL> *<EOL> * See the Signature API for more information.<EOL> *<EOL> * @param {F} compute<EOL> * @returns {MemoizedFunction<F extends Function>}<EOL> */<EOL>export function memoize<F extends Function>(compute: F): MemoizedFunction<F> {<EOL>    let lastSignature: Signature = undefined;<EOL>    let lastValue: any;<EOL>    let locked = false;<EOL>","gt":"let logPerformance = false;"}
{"input":"<s> /**<EOL> * Return a memoized version of the input function. The memoized function<EOL> * reduces unnecessary invocations of the input by keeping a cache of the<EOL> * return value of compute:<EOL> *<EOL> * <pre><EOL> * function compute(a, b) { return a + b }<EOL> * const memoizedCompute = memoize(compute);<EOL> *<EOL> * compute(3, 7) == 10<EOL> * compute(3, 7) == 10 // cache hit<EOL> * </pre><EOL> *<EOL> * Cache invalidation is complicated by mutable classes (Scales and Datasets).<EOL> * The Signature API is built to solve this issue by constructing an immutable<EOL> * snapshot of Scales/Datasets on memoized function invocation, which is itself<EOL> * a performance hit. Thus we introduce a \"doLocked\" method that momentarily<EOL> * bypasses sign/comparison logic and simply returns the cached value.<EOL> *<EOL> * See the Signature API for more information.<EOL> *<EOL> * @param {F} compute<EOL> * @returns {MemoizedFunction<F extends Function>}<EOL> */<EOL>export function memoize<F extends Function>(compute: F): MemoizedFunction<F> {<EOL>    let lastSignature: Signature = undefined;<EOL>    let lastValue: any;<EOL>    let locked = false;<EOL>    let logPerformance = false;<EOL>    const memoizeFn =","gt":"function (...args: any[]) {"}
{"input":"<s> /**<EOL> * Return a memoized version of the input function. The memoized function<EOL> * reduces unnecessary invocations of the input by keeping a cache of the<EOL> * return value of compute:<EOL> *<EOL> * <pre><EOL> * function compute(a, b) { return a + b }<EOL> * const memoizedCompute = memoize(compute);<EOL> *<EOL> * compute(3, 7) == 10<EOL> * compute(3, 7) == 10 // cache hit<EOL> * </pre><EOL> *<EOL> * Cache invalidation is complicated by mutable classes (Scales and Datasets).<EOL> * The Signature API is built to solve this issue by constructing an immutable<EOL> * snapshot of Scales/Datasets on memoized function invocation, which is itself<EOL> * a performance hit. Thus we introduce a \"doLocked\" method that momentarily<EOL> * bypasses sign/comparison logic and simply returns the cached value.<EOL> *<EOL> * See the Signature API for more information.<EOL> *<EOL> * @param {F} compute<EOL> * @returns {MemoizedFunction<F extends Function>}<EOL> */<EOL>export function memoize<F extends Function>(compute: F): MemoizedFunction<F> {<EOL>    let lastSignature: Signature = undefined;<EOL>    let lastValue: any;<EOL>    let locked = false;<EOL>    let logPerformance = false;<EOL>    const memoizeFn = function (...args: any[]) {<EOL>        if (locked) {<EOL>","gt":"return lastValue;"}
{"input":"<s> /**<EOL> * Return a memoized version of the input function. The memoized function<EOL> * reduces unnecessary invocations of the input by keeping a cache of the<EOL> * return value of compute:<EOL> *<EOL> * <pre><EOL> * function compute(a, b) { return a + b }<EOL> * const memoizedCompute = memoize(compute);<EOL> *<EOL> * compute(3, 7) == 10<EOL> * compute(3, 7) == 10 // cache hit<EOL> * </pre><EOL> *<EOL> * Cache invalidation is complicated by mutable classes (Scales and Datasets).<EOL> * The Signature API is built to solve this issue by constructing an immutable<EOL> * snapshot of Scales/Datasets on memoized function invocation, which is itself<EOL> * a performance hit. Thus we introduce a \"doLocked\" method that momentarily<EOL> * bypasses sign/comparison logic and simply returns the cached value.<EOL> *<EOL> * See the Signature API for more information.<EOL> *<EOL> * @param {F} compute<EOL> * @returns {MemoizedFunction<F extends Function>}<EOL> */<EOL>export function memoize<F extends Function>(compute: F): MemoizedFunction<F> {<EOL>    let lastSignature: Signature = undefined;<EOL>    let lastValue: any;<EOL>    let locked = false;<EOL>    let logPerformance = false;<EOL>    const memoizeFn = function (...args: any[]) {<EOL>        if (locked) {<EOL>            return lastValue;<EOL>        }<EOL>        const inputSignature = signArray(args);<EOL>        if (lastSignature === undefined<EOL>            || lastSignature.isDifferent(inputSignature)) {<EOL>            if (","gt":"logPerformance) {"}
{"input":"<s> /**<EOL> * Return a memoized version of the input function. The memoized function<EOL> * reduces unnecessary invocations of the input by keeping a cache of the<EOL> * return value of compute:<EOL> *<EOL> * <pre><EOL> * function compute(a, b) { return a + b }<EOL> * const memoizedCompute = memoize(compute);<EOL> *<EOL> * compute(3, 7) == 10<EOL> * compute(3, 7) == 10 // cache hit<EOL> * </pre><EOL> *<EOL> * Cache invalidation is complicated by mutable classes (Scales and Datasets).<EOL> * The Signature API is built to solve this issue by constructing an immutable<EOL> * snapshot of Scales/Datasets on memoized function invocation, which is itself<EOL> * a performance hit. Thus we introduce a \"doLocked\" method that momentarily<EOL> * bypasses sign/comparison logic and simply returns the cached value.<EOL> *<EOL> * See the Signature API for more information.<EOL> *<EOL> * @param {F} compute<EOL> * @returns {MemoizedFunction<F extends Function>}<EOL> */<EOL>export function memoize<F extends Function>(compute: F): MemoizedFunction<F> {<EOL>    let lastSignature: Signature = undefined;<EOL>    let lastValue: any;<EOL>    let locked = false;<EOL>    let logPerformance = false;<EOL>    const memoizeFn = function (...args: any[]) {<EOL>        if (locked) {<EOL>            return lastValue;<EOL>        }<EOL>        const inputSignature = signArray(args);<EOL>        if (lastSignature === undefined<EOL>            || lastSignature.isDifferent(inputSignature)) {<EOL>            if (logPerformance) {<EOL>                console.log(\"<STR_LIT>\");<EOL>            }<EOL>            lastSignature = inputSignature;<EOL>","gt":"lastValue = compute.apply(this, args);"}
{"input":"<s> /**<EOL> * Return a memoized version of the input function. The memoized function<EOL> * reduces unnecessary invocations of the input by keeping a cache of the<EOL> * return value of compute:<EOL> *<EOL> * <pre><EOL> * function compute(a, b) { return a + b }<EOL> * const memoizedCompute = memoize(compute);<EOL> *<EOL> * compute(3, 7) == 10<EOL> * compute(3, 7) == 10 // cache hit<EOL> * </pre><EOL> *<EOL> * Cache invalidation is complicated by mutable classes (Scales and Datasets).<EOL> * The Signature API is built to solve this issue by constructing an immutable<EOL> * snapshot of Scales/Datasets on memoized function invocation, which is itself<EOL> * a performance hit. Thus we introduce a \"doLocked\" method that momentarily<EOL> * bypasses sign/comparison logic and simply returns the cached value.<EOL> *<EOL> * See the Signature API for more information.<EOL> *<EOL> * @param {F} compute<EOL> * @returns {MemoizedFunction<F extends Function>}<EOL> */<EOL>export function memoize<F extends Function>(compute: F): MemoizedFunction<F> {<EOL>    let lastSignature: Signature = undefined;<EOL>    let lastValue: any;<EOL>    let locked = false;<EOL>    let logPerformance = false;<EOL>    const memoizeFn = function (...args: any[]) {<EOL>        if (locked) {<EOL>            return lastValue;<EOL>        }<EOL>        const inputSignature = signArray(args);<EOL>        if (lastSignature === undefined<EOL>            || lastSignature.isDifferent(inputSignature)) {<EOL>            if (logPerformance) {<EOL>                console.log(\"<STR_LIT>\");<EOL>            }<EOL>            lastSignature = inputSignature;<EOL>            lastValue = compute.apply(this, args);<EOL>        }<EOL>        else {<EOL>            if (logPerformance) {<EOL>                console.log(","gt":"\"<STR_LIT>\");"}
{"input":"<s> /**<EOL> * Return a memoized version of the input function. The memoized function<EOL> * reduces unnecessary invocations of the input by keeping a cache of the<EOL> * return value of compute:<EOL> *<EOL> * <pre><EOL> * function compute(a, b) { return a + b }<EOL> * const memoizedCompute = memoize(compute);<EOL> *<EOL> * compute(3, 7) == 10<EOL> * compute(3, 7) == 10 // cache hit<EOL> * </pre><EOL> *<EOL> * Cache invalidation is complicated by mutable classes (Scales and Datasets).<EOL> * The Signature API is built to solve this issue by constructing an immutable<EOL> * snapshot of Scales/Datasets on memoized function invocation, which is itself<EOL> * a performance hit. Thus we introduce a \"doLocked\" method that momentarily<EOL> * bypasses sign/comparison logic and simply returns the cached value.<EOL> *<EOL> * See the Signature API for more information.<EOL> *<EOL> * @param {F} compute<EOL> * @returns {MemoizedFunction<F extends Function>}<EOL> */<EOL>export function memoize<F extends Function>(compute: F): MemoizedFunction<F> {<EOL>    let lastSignature: Signature = undefined;<EOL>    let lastValue: any;<EOL>    let locked = false;<EOL>    let logPerformance = false;<EOL>    const memoizeFn = function (...args: any[]) {<EOL>        if (locked) {<EOL>            return lastValue;<EOL>        }<EOL>        const inputSignature = signArray(args);<EOL>        if (lastSignature === undefined<EOL>            || lastSignature.isDifferent(inputSignature)) {<EOL>            if (logPerformance) {<EOL>                console.log(\"<STR_LIT>\");<EOL>            }<EOL>            lastSignature = inputSignature;<EOL>            lastValue = compute.apply(this, args);<EOL>        }<EOL>        else {<EOL>            if (logPerformance) {<EOL>                console.log(\"<STR_LIT>\");<EOL>            }<EOL>        }<EOL>        return lastValue;<EOL>    } as any as MemoizedFunction<F>;<EOL>    memoizeFn.doLocked = function <T>(cb: () => T) {<EOL>        if (locked) {<EOL>            throw new Error(\"<STR_LIT>\");<EOL>        }<EOL>","gt":"locked = true;"}
{"input":"<s> export function getProviders(): any[] {<EOL>    return [<EOL>        { provide: Modal_,","gt":"useClass: InAppModal },"}
{"input":"<s> function validateMethodName(name: string) {<EOL>    if (!name) {<EOL>","gt":"throw new Error(`<STR_LIT>`);"}
{"input":"<s> export async function reopenIssue(githubAccessToken: string, timeStamp: string, error: Error, fetcher: Fetcher): Promise<void> {<EOL>    await doUpdate(githubAccessToken, createContent(), fetcher);<EOL>    function createContent(): string {<EOL>        const lines: string[] = [];<EOL>        const l = lines.push.bind(lines);<EOL>        l(","gt":"timeStamp}**.`<STR_LIT>;"}
{"input":"<s> export async function reopenIssue(githubAccessToken: string, timeStamp: string, error: Error, fetcher: Fetcher): Promise<void> {<EOL>    await doUpdate(githubAccessToken, createContent(), fetcher);<EOL>    function createContent(): string {<EOL>        const lines: string[] = [];<EOL>        const l = lines.push.bind(lines);<EOL>        l(`<STR_LIT>`);<EOL>        l(\"<STR_LIT>\");<EOL>        l(\"<STR_LIT>\");<EOL>        l(\"<STR_LIT>\");<EOL>        const url = `<STR_LIT>`;<EOL>        l(`<STR_LIT>`);<EOL>        l(","gt":"\"<STR_LIT>\");"}
{"input":"<s> export function getNetworkTokens(state: AppState): Token[] {<EOL>","gt":"const network = getStaticNetworkConfig(state);"}
{"input":"<s> /**<EOL> * Creates an array of length `count`, filled with value or (if value is a function), value()<EOL> *<EOL> * @param {T | ((index?: number) => T)} value The value to fill the array with or a value generator (called with index as arg)<EOL> * @param {number} count The length of the array to generate<EOL> * @return {any[]}<EOL> */<EOL>export function createFilledArray<T>(value: T | ((index?: number) => T), count: number) {<EOL>    const out: T[] = [];<EOL>    for (let i = <NUM_LIT>; i <","gt":"count; i++) {"}
{"input":"<s> function _mixin<T>(target: any, source: any): T {<EOL>    for (var name in source) {<EOL>        var sourceValue: any = source[name];<EOL>        <EOL>        if (name","gt":"in target && target[name] === sourceValue) {"}
{"input":"<s> function _mixin<T>(target: any, source: any): T {<EOL>    for (var name in source) {<EOL>        var sourceValue: any = source[name];<EOL>        <EOL>        if (name in target && target[name] === sourceValue) {<EOL>            <EOL>            continue;<EOL>        }<EOL>        target[","gt":"name] = sourceValue;"}
{"input":"<s> <EOL>function executeLabeledPoint(ctx: Context, attrScale: number, point: Point, radius: number, color: string, text?: string) {<EOL>    <EOL>    <EOL>    <EOL>    point = MathUtil.transformPoint(point, Matrix.scaling(attrScale, attrScale));<EOL>","gt":"radius *= attrScale;"}
{"input":"<s> <EOL>function executeLabeledPoint(ctx: Context, attrScale: number, point: Point, radius: number, color: string, text?: string) {<EOL>    <EOL>    <EOL>    <EOL>    point = MathUtil.transformPoint(point, Matrix.scaling(attrScale, attrScale));<EOL>    radius *= attrScale;<EOL>    ctx.save();<EOL>    ctx.beginPath();<EOL>    ctx.arc(point.","gt":"x, point.y, radius * POINT_BORDER_FACTOR, <NUM_LIT>, <NUM_LIT> * Math.PI, false);"}
{"input":"<s> <EOL>function executeLabeledPoint(ctx: Context, attrScale: number, point: Point, radius: number, color: string, text?: string) {<EOL>    <EOL>    <EOL>    <EOL>    point = MathUtil.transformPoint(point, Matrix.scaling(attrScale, attrScale));<EOL>    radius *= attrScale;<EOL>    ctx.save();<EOL>    ctx.beginPath();<EOL>    ctx.arc(point.x, point.y, radius * POINT_BORDER_FACTOR, <NUM_LIT>, <NUM_LIT> * Math.PI, false);<EOL>    ctx.fillStyle = POINT_BORDER_COLOR;<EOL>    ctx.fill();<EOL>","gt":"ctx.beginPath();"}
{"input":"<s> <EOL>function executeLabeledPoint(ctx: Context, attrScale: number, point: Point, radius: number, color: string, text?: string) {<EOL>    <EOL>    <EOL>    <EOL>    point = MathUtil.transformPoint(point, Matrix.scaling(attrScale, attrScale));<EOL>    radius *= attrScale;<EOL>    ctx.save();<EOL>    ctx.beginPath();<EOL>    ctx.arc(point.x, point.y, radius * POINT_BORDER_FACTOR, <NUM_LIT>, <NUM_LIT> * Math.PI, false);<EOL>    ctx.fillStyle = POINT_BORDER_COLOR;<EOL>    ctx.fill();<EOL>    ctx.beginPath();<EOL>    ctx.arc(point.x, point.y, radius, <NUM_LIT>, <NUM_LIT> * Math.PI, false);<EOL>    ctx.fillStyle = color;<EOL>","gt":"ctx.fill();"}
{"input":"<s> <EOL>function executeLabeledPoint(ctx: Context, attrScale: number, point: Point, radius: number, color: string, text?: string) {<EOL>    <EOL>    <EOL>    <EOL>    point = MathUtil.transformPoint(point, Matrix.scaling(attrScale, attrScale));<EOL>    radius *= attrScale;<EOL>    ctx.save();<EOL>    ctx.beginPath();<EOL>    ctx.arc(point.x, point.y, radius * POINT_BORDER_FACTOR, <NUM_LIT>, <NUM_LIT> * Math.PI, false);<EOL>    ctx.fillStyle = POINT_BORDER_COLOR;<EOL>    ctx.fill();<EOL>    ctx.beginPath();<EOL>    ctx.arc(point.x, point.y, radius, <NUM_LIT>, <NUM_LIT> * Math.PI, false);<EOL>    ctx.fillStyle = color;<EOL>    ctx.fill();<EOL>    if (text) {<EOL>        ctx.beginPath();<EOL>        ctx.fillStyle = POINT_TEXT_COLOR;<EOL>        ctx.font = radius + '<STR_LIT>';<EOL>        const","gt":"width = ctx.measureText(text).width;"}
{"input":"<s> export function stripBOM(s: string): string {<EOL>    if (s && s[<NUM_LIT>] === '<STR_LIT>') {<EOL>        s =","gt":"s.substr(<NUM_LIT>);"}
{"input":"<s> export function resolveWebpackConfig(config: string | any, ...args: any[]): any {<EOL>    if (typeof config === '<STR_LIT>') {<EOL>        return resolveWebpackConfig(require(config), ...args);<EOL>    }<EOL>    else","gt":"if (typeof config === '<STR_LIT>') {"}
{"input":"<s> export function resolveWebpackConfig(config: string | any, ...args: any[]): any {<EOL>    if (typeof config === '<STR_LIT>') {<EOL>        return resolveWebpackConfig(require(config), ...args);<EOL>    }<EOL>    else if (typeof config === '<STR_LIT>') {<EOL>        return config(...args);<EOL>    }<EOL>    else if (config.__esModule === true && !!config.default) {<EOL>        return resolveWebpackConfig(config.default, ...args);<EOL>    }<EOL>","gt":"else {"}
{"input":"<s> export function deepMixin(target: any, source: any): any {<EOL>    if (source && typeof source === '<STR_LIT>') {<EOL>        if (Array.isArray(source)) {<EOL>            (<any>target).length = source.length;<EOL>        }<EOL>        for (var name in source) {<EOL>            var targetValue:","gt":"any = target[name];"}
{"input":"<s> export function deepMixin(target: any, source: any): any {<EOL>    if (source && typeof source === '<STR_LIT>') {<EOL>        if (Array.isArray(source)) {<EOL>            (<any>target).length = source.length;<EOL>        }<EOL>        for (var name in source) {<EOL>            var targetValue: any = target[name];<EOL>            var sourceValue: any = source[name];<EOL>            if (targetValue !== sourceValue) {<EOL>                if (sourceValue &&","gt":"typeof sourceValue === '<STR_LIT>') {"}
{"input":"<s> export function deepMixin(target: any, source: any): any {<EOL>    if (source && typeof source === '<STR_LIT>') {<EOL>        if (Array.isArray(source)) {<EOL>            (<any>target).length = source.length;<EOL>        }<EOL>        for (var name in source) {<EOL>            var targetValue: any = target[name];<EOL>            var sourceValue: any = source[name];<EOL>            if (targetValue !== sourceValue) {<EOL>                if (sourceValue && typeof sourceValue === '<STR_LIT>') {<EOL>                    if (sourceValue instanceof RegExp ||<EOL>                        sourceValue instanceof Date ||<EOL>","gt":"sourceValue instanceof String ||"}
{"input":"<s> export function deepMixin(target: any, source: any): any {<EOL>    if (source && typeof source === '<STR_LIT>') {<EOL>        if (Array.isArray(source)) {<EOL>            (<any>target).length = source.length;<EOL>        }<EOL>        for (var name in source) {<EOL>            var targetValue: any = target[name];<EOL>            var sourceValue: any = source[name];<EOL>            if (targetValue !== sourceValue) {<EOL>                if (sourceValue && typeof sourceValue === '<STR_LIT>') {<EOL>                    if (sourceValue instanceof RegExp ||<EOL>                        sourceValue instanceof Date ||<EOL>                        sourceValue instanceof String ||<EOL>                        sourceValue instanceof Number ||<EOL>                        sourceValue instanceof Boolean) {<EOL>","gt":"target[name] = targetValue = new sourceValue.constructor(sourceValue);"}
{"input":"<s> export function startPollShapeshiftOrderStatus(): interfaces.StartPollShapeshiftOrderStatusAction {<EOL>","gt":"return {"}
{"input":"<s> function b7({ a, b, c: { p1 } }, p2, p3): p1 is A {<EOL>","gt":"return true;"}
{"input":"<s> export function getAutoGasLimitEnabled(state: AppState): boolean {<EOL>    const meta = getMeta(","gt":"state);"}
{"input":"<s> /**<EOL> * Apply advice *after* the supplied joinPoint (function)<EOL> *<EOL> * @param joinPoint A function that should have advice applied to<EOL> * @param advice The after advice<EOL> */<EOL>function afterJoinPoint<F extends GenericFunction<T>, T>(joinPoint: F, advice: JoinPointAfterAdvice<T>): F {<EOL>    return","gt":"adviseJoinPoint(joinPoint, '<STR_LIT>', advice);"}
{"input":"<s> /**<EOL> * Attaches \"after\" advice to be executed after the original method.<EOL> * The advising function will receive the original method's return value and arguments object.<EOL> * The value it returns will be returned from the method when it is called (even if the return value is undefined).<EOL> *<EOL> * @param target Object whose method will be aspected<EOL> * @param methodName Name of method to aspect<EOL> * @param advice Advising function which will receive the original method's return value and arguments object<EOL> * @return A handle which will remove the aspect when destroy is called<EOL> */<EOL>function afterObject(target: Targetable, methodName: string | symbol, advice: (originalReturn: any, originalArgs: IArguments) => any): Handle {<EOL>    return","gt":"adviseObject(getDispatcherObject(target, methodName), '<STR_LIT>', advice);"}
{"input":"<s> function lcsTests(Algorithm: any) {<EOL>    lcsTest(Algorithm, '<STR_LIT>', '<STR_LIT>', '<STR_LIT>');<EOL>    lcsTest(Algorithm, '<STR_LIT>', '<STR_LIT>', '<STR_LIT>'); <EOL>    lcsTest(Algorithm, '<STR_LIT>', '<STR_LIT>', '<STR_LIT>'); <EOL>    lcsTest(Algorithm,","gt":"'<STR_LIT>', '<STR_LIT>', '<STR_LIT>');"}
{"input":"<s> function lcsTests(Algorithm: any) {<EOL>    lcsTest(Algorithm, '<STR_LIT>', '<STR_LIT>', '<STR_LIT>');<EOL>    lcsTest(Algorithm, '<STR_LIT>', '<STR_LIT>', '<STR_LIT>'); <EOL>    lcsTest(Algorithm, '<STR_LIT>', '<STR_LIT>', '<STR_LIT>'); <EOL>    lcsTest(Algorithm, '<STR_LIT>', '<STR_LIT>', '<STR_LIT>'); <EOL>    lcsTest(Algorithm, '<STR_LIT>', '<STR_LIT>', '<STR_LIT>'); <EOL>    lcsTest(Algorithm, '<STR_LIT>', '<STR_LIT>', '<STR_LIT>');<EOL>    lcsTest(Algorithm, '<STR_LIT>', '<STR_LIT>', '<STR_LIT>');<EOL>    lcsTest(Algorithm, '<STR_LIT>', '<STR_LIT>', '<STR_LIT>');<EOL>    lcsTest(Algorithm,","gt":"'<STR_LIT>', '<STR_LIT>', '<STR_LIT>');"}
{"input":"<s> export function confirm(modal: Modal): JSNativePresetBuilder {<EOL>    return modal.confirm().","gt":"message('<STR_LIT>');"}
{"input":"<s> /**<EOL> * An event handler factory for event handlers that bubble the event to a given handler<EOL> * if the event target is not an ancestor of the given element.<EOL> * @param element<EOL> * @param handler<EOL> */<EOL>function bubbleNonAncestorHandlerFactory(element: HTMLElement, handler: (event) => void) {<EOL>    return (event) => {<EOL>        let current = event.target;<EOL>","gt":"do {"}
{"input":"<s> /**<EOL> * Apply advice *around* the supplied joinPoint (function)<EOL> *<EOL> * @param joinPoint A function that should have advice applied to<EOL> * @param advice The around advice<EOL> */<EOL>export function aroundJoinPoint<F extends GenericFunction<T>, T>(joinPoint: F, advice: JoinPointAroundAdvice<T>): F {<EOL>    return adviseJoinPoint<F, T>(joinPoint,","gt":"'<STR_LIT>', advice);"}
{"input":"<s> /**<EOL> * Attaches \"around\" advice around the original method.<EOL> *<EOL> * @param target Object whose method will be aspected<EOL> * @param methodName Name of method to aspect<EOL> * @param advice Advising function which will receive the original function<EOL> * @return A handle which will remove the aspect when destroy is called<EOL> */<EOL>export function aroundObject(target: Targetable, methodName: string | symbol, advice: ((previous: Function) => Function)): Handle {<EOL>    let dispatcher: Dispatcher | undefined = getDispatcherObject(target, methodName);<EOL>    let previous = dispatcher.around;<EOL>    let advised: Function | undefined;<EOL>    if (advice) {<EOL>        advised = advice(function (this: Dispatcher): any {<EOL>            if (","gt":"previous && previous.advice) {"}
{"input":"<s> /**<EOL> * Returns true if a given value has a `then` method.<EOL> * @param {any} value The value to check if is Thenable<EOL> * @returns {is Thenable<T>} A type guard if the value is thenable<EOL> */<EOL>export function isThenable<T>(value: any): value is Thenable<T> {<EOL>    return value && typeof","gt":"value.then === '<STR_LIT>';"}
{"input":"<s> function foo3() {<EOL>","gt":"return foo3();"}
{"input":"<s> <EOL><EOL><EOL>export function toGitUri(uri: Uri, ref: string, options: GitUriOptions = {}): Uri {<EOL>    const params: GitUriParams = {<EOL>        path: uri.fsPath,<EOL>        ref<EOL>    };<EOL>    if (options.submoduleOf) {<EOL>        params.","gt":"submoduleOf = options.submoduleOf;"}
{"input":"<s> <EOL><EOL><EOL>export function toGitUri(uri: Uri, ref: string, options: GitUriOptions = {}): Uri {<EOL>    const params: GitUriParams = {<EOL>        path: uri.fsPath,<EOL>        ref<EOL>    };<EOL>    if (options.submoduleOf) {<EOL>        params.submoduleOf = options.submoduleOf;<EOL>    }<EOL>    let path = uri.path;<EOL>    if (options.replaceFileExtension) {<EOL>        path = `<STR_LIT>`;<EOL>    }<EOL>    else if (options.submoduleOf) {<EOL>        path = `<STR_LIT>`;<EOL>    }<EOL>","gt":"return uri.with({"}
{"input":"<s> function stateEqual(state, content) {<EOL>    assert.equal(","gt":"state.prevLineContent, content);"}
{"input":"<s> function statesEqual(model: Model, states: string[]) {<EOL>    var i, len = states.length - <NUM_LIT>;<EOL>    for (i = <NUM_LIT>; i < len;","gt":"i++) {"}
{"input":"<s> <EOL>export function hexEncodeData(value: string | Buffer): string {<EOL>","gt":"return bufferToHex(toBuffer(value));"}
{"input":"<s> /**<EOL> * Attaches \"before\" advice to be executed before the original method.<EOL> *<EOL> * @param target Object whose method will be aspected<EOL> * @param methodName Name of method to aspect<EOL> * @param advice Advising function which will receive the same arguments as the original, and may return new arguments<EOL> * @return A handle which will remove the aspect when destroy is called<EOL> */<EOL>export function beforeObject(target: Targetable, methodName: string | symbol, advice: (...originalArgs: any[]) => any[] | void): Handle {<EOL>    return adviseObject(getDispatcherObject(target, methodName),","gt":"'<STR_LIT>', advice);"}
{"input":"<s> export function runTest(testDirectory: string, rulesDirectory?: string | string[]): TestResult {<EOL>    const filesToLint = glob.sync(path.join(testDirectory, `<STR_LIT>`));<EOL>    const tslintConfig = Linter.","gt":"findConfiguration(path.join(testDirectory, \"<STR_LIT>\"), \"<STR_LIT>\").results;"}
{"input":"<s> export function runTest(testDirectory: string, rulesDirectory?: string | string[]): TestResult {<EOL>    const filesToLint = glob.sync(path.join(testDirectory, `<STR_LIT>`));<EOL>    const tslintConfig = Linter.findConfiguration(path.join(testDirectory, \"<STR_LIT>\"), \"<STR_LIT>\").results;<EOL>    const tsConfig = path.join(testDirectory, \"<STR_LIT>\");<EOL>    let compilerOptions: ts.CompilerOptions = { allowJs: true };<EOL>    const hasConfig = fs.existsSync(","gt":"tsConfig);"}
{"input":"<s> export function runTest(testDirectory: string, rulesDirectory?: string | string[]): TestResult {<EOL>    const filesToLint = glob.sync(path.join(testDirectory, `<STR_LIT>`));<EOL>    const tslintConfig = Linter.findConfiguration(path.join(testDirectory, \"<STR_LIT>\"), \"<STR_LIT>\").results;<EOL>    const tsConfig = path.join(testDirectory, \"<STR_LIT>\");<EOL>    let compilerOptions: ts.CompilerOptions = { allowJs: true };<EOL>    const hasConfig = fs.existsSync(tsConfig);<EOL>    if (hasConfig) {<EOL>        const { config, error } = ts.readConfigFile(tsConfig, ts.sys.readFile);<EOL>        if (error !== undefined) {<EOL>            throw new Error(JSON.stringify(error));<EOL>        }<EOL>        const parseConfigHost = {<EOL>            fileExists: fs.existsSync,<EOL>            readDirectory: ts.sys.readDirectory,<EOL>            readFile: (file: string) => fs.readFileSync(file, \"<STR_LIT>\"),<EOL>","gt":"useCaseSensitiveFileNames: true,"}
{"input":"<s> export function runTest(testDirectory: string, rulesDirectory?: string | string[]): TestResult {<EOL>    const filesToLint = glob.sync(path.join(testDirectory, `<STR_LIT>`));<EOL>    const tslintConfig = Linter.findConfiguration(path.join(testDirectory, \"<STR_LIT>\"), \"<STR_LIT>\").results;<EOL>    const tsConfig = path.join(testDirectory, \"<STR_LIT>\");<EOL>    let compilerOptions: ts.CompilerOptions = { allowJs: true };<EOL>    const hasConfig = fs.existsSync(tsConfig);<EOL>    if (hasConfig) {<EOL>        const { config, error } = ts.readConfigFile(tsConfig, ts.sys.readFile);<EOL>        if (error !== undefined) {<EOL>            throw new Error(JSON.stringify(error));<EOL>        }<EOL>        const parseConfigHost = {<EOL>            fileExists: fs.existsSync,<EOL>            readDirectory: ts.sys.readDirectory,<EOL>            readFile: (file: string) => fs.readFileSync(file, \"<STR_LIT>\"),<EOL>            useCaseSensitiveFileNames: true,<EOL>        };<EOL>        compilerOptions = ts.parseJsonConfigFileContent(config, parseConfigHost, testDirectory).options;<EOL>    }<EOL>    const results: TestResult = { directory: testDirectory, results: {} };<EOL>    for (const fileToLint of filesToLint) {<EOL>        const isEncodingRule = path.basename(testDirectory) === \"<STR_LIT>\";<EOL>        const fileCompileName = denormalizeWinPath(path.resolve(fileToLint.","gt":"replace(/\\.lint$/, \"<STR_LIT>\")));"}
{"input":"<s> export function runTest(testDirectory: string, rulesDirectory?: string | string[]): TestResult {<EOL>    const filesToLint = glob.sync(path.join(testDirectory, `<STR_LIT>`));<EOL>    const tslintConfig = Linter.findConfiguration(path.join(testDirectory, \"<STR_LIT>\"), \"<STR_LIT>\").results;<EOL>    const tsConfig = path.join(testDirectory, \"<STR_LIT>\");<EOL>    let compilerOptions: ts.CompilerOptions = { allowJs: true };<EOL>    const hasConfig = fs.existsSync(tsConfig);<EOL>    if (hasConfig) {<EOL>        const { config, error } = ts.readConfigFile(tsConfig, ts.sys.readFile);<EOL>        if (error !== undefined) {<EOL>            throw new Error(JSON.stringify(error));<EOL>        }<EOL>        const parseConfigHost = {<EOL>            fileExists: fs.existsSync,<EOL>            readDirectory: ts.sys.readDirectory,<EOL>            readFile: (file: string) => fs.readFileSync(file, \"<STR_LIT>\"),<EOL>            useCaseSensitiveFileNames: true,<EOL>        };<EOL>        compilerOptions = ts.parseJsonConfigFileContent(config, parseConfigHost, testDirectory).options;<EOL>    }<EOL>    const results: TestResult = { directory: testDirectory, results: {} };<EOL>    for (const fileToLint of filesToLint) {<EOL>        const isEncodingRule = path.basename(testDirectory) === \"<STR_LIT>\";<EOL>        const fileCompileName = denormalizeWinPath(path.resolve(fileToLint.replace(/\\.lint$/, \"<STR_LIT>\")));<EOL>        let fileText = isEncodingRule ? readBufferWithDetectedEncoding(fs.readFileSync(fileToLint)) : fs.readFileSync(fileToLint,","gt":"\"<STR_LIT>\");"}
{"input":"<s> export function runTest(testDirectory: string, rulesDirectory?: string | string[]): TestResult {<EOL>    const filesToLint = glob.sync(path.join(testDirectory, `<STR_LIT>`));<EOL>    const tslintConfig = Linter.findConfiguration(path.join(testDirectory, \"<STR_LIT>\"), \"<STR_LIT>\").results;<EOL>    const tsConfig = path.join(testDirectory, \"<STR_LIT>\");<EOL>    let compilerOptions: ts.CompilerOptions = { allowJs: true };<EOL>    const hasConfig = fs.existsSync(tsConfig);<EOL>    if (hasConfig) {<EOL>        const { config, error } = ts.readConfigFile(tsConfig, ts.sys.readFile);<EOL>        if (error !== undefined) {<EOL>            throw new Error(JSON.stringify(error));<EOL>        }<EOL>        const parseConfigHost = {<EOL>            fileExists: fs.existsSync,<EOL>            readDirectory: ts.sys.readDirectory,<EOL>            readFile: (file: string) => fs.readFileSync(file, \"<STR_LIT>\"),<EOL>            useCaseSensitiveFileNames: true,<EOL>        };<EOL>        compilerOptions = ts.parseJsonConfigFileContent(config, parseConfigHost, testDirectory).options;<EOL>    }<EOL>    const results: TestResult = { directory: testDirectory, results: {} };<EOL>    for (const fileToLint of filesToLint) {<EOL>        const isEncodingRule = path.basename(testDirectory) === \"<STR_LIT>\";<EOL>        const fileCompileName = denormalizeWinPath(path.resolve(fileToLint.replace(/\\.lint$/, \"<STR_LIT>\")));<EOL>        let fileText = isEncodingRule ? readBufferWithDetectedEncoding(fs.readFileSync(fileToLint)) : fs.readFileSync(fileToLint, \"<STR_LIT>\");<EOL>        const tsVersionRequirement = parse.getTypescriptVersionRequirement(fileText);<EOL>        if (tsVersionRequirement !== undefined) {<EOL>            <EOL>            if (!semver.satisfies(parse.getNormalizedTypescriptVersion(), tsVersionRequirement)) {<EOL>                results.results[fileToLint] = {<EOL>                    requirement: tsVersionRequirement,<EOL>                    skipped: true,<EOL>                };<EOL>                continue;<EOL>            }<EOL>            <EOL>            const lineBreak = fileText.search(/\\n/);<EOL>            fileText = lineBreak === -<NUM_LIT> ? \"<STR_LIT>\" :","gt":"fileText.substr(lineBreak + <NUM_LIT>);"}
{"input":"<s> export function runTest(testDirectory: string, rulesDirectory?: string | string[]): TestResult {<EOL>    const filesToLint = glob.sync(path.join(testDirectory, `<STR_LIT>`));<EOL>    const tslintConfig = Linter.findConfiguration(path.join(testDirectory, \"<STR_LIT>\"), \"<STR_LIT>\").results;<EOL>    const tsConfig = path.join(testDirectory, \"<STR_LIT>\");<EOL>    let compilerOptions: ts.CompilerOptions = { allowJs: true };<EOL>    const hasConfig = fs.existsSync(tsConfig);<EOL>    if (hasConfig) {<EOL>        const { config, error } = ts.readConfigFile(tsConfig, ts.sys.readFile);<EOL>        if (error !== undefined) {<EOL>            throw new Error(JSON.stringify(error));<EOL>        }<EOL>        const parseConfigHost = {<EOL>            fileExists: fs.existsSync,<EOL>            readDirectory: ts.sys.readDirectory,<EOL>            readFile: (file: string) => fs.readFileSync(file, \"<STR_LIT>\"),<EOL>            useCaseSensitiveFileNames: true,<EOL>        };<EOL>        compilerOptions = ts.parseJsonConfigFileContent(config, parseConfigHost, testDirectory).options;<EOL>    }<EOL>    const results: TestResult = { directory: testDirectory, results: {} };<EOL>    for (const fileToLint of filesToLint) {<EOL>        const isEncodingRule = path.basename(testDirectory) === \"<STR_LIT>\";<EOL>        const fileCompileName = denormalizeWinPath(path.resolve(fileToLint.replace(/\\.lint$/, \"<STR_LIT>\")));<EOL>        let fileText = isEncodingRule ? readBufferWithDetectedEncoding(fs.readFileSync(fileToLint)) : fs.readFileSync(fileToLint, \"<STR_LIT>\");<EOL>        const tsVersionRequirement = parse.getTypescriptVersionRequirement(fileText);<EOL>        if (tsVersionRequirement !== undefined) {<EOL>            <EOL>            if (!semver.satisfies(parse.getNormalizedTypescriptVersion(), tsVersionRequirement)) {<EOL>                results.results[fileToLint] = {<EOL>                    requirement: tsVersionRequirement,<EOL>                    skipped: true,<EOL>                };<EOL>                continue;<EOL>            }<EOL>            <EOL>            const lineBreak = fileText.search(/\\n/);<EOL>            fileText = lineBreak === -<NUM_LIT> ? \"<STR_LIT>\" : fileText.substr(lineBreak + <NUM_LIT>);<EOL>        }<EOL>        fileText = parse.preprocessDirectives(fileText);<EOL>        const fileTextWithoutMarkup = parse.removeErrorMarkup(fileText);<EOL>        const errorsFromMarkup = parse.parseErrorsFromMarkup(fileText);<EOL>        let program: ts.Program | undefined;<EOL>        if (hasConfig) {<EOL>            const compilerHost: ts.CompilerHost = {<EOL>                fileExists: (file) => file === fileCompileName || fs.existsSync(file),<EOL>                getCanonicalFileName: (filename) => filename,<EOL>                getCurrentDirectory: () => process.cwd(),<EOL>                getDefaultLibFileName: () => ts.getDefaultLibFileName(compilerOptions),<EOL>                getDirectories: (dir) => fs.readdirSync(dir),<EOL>","gt":"getNewLine: () => \"<STR_LIT>\","}
{"input":"<s> export function runTest(testDirectory: string, rulesDirectory?: string | string[]): TestResult {<EOL>    const filesToLint = glob.sync(path.join(testDirectory, `<STR_LIT>`));<EOL>    const tslintConfig = Linter.findConfiguration(path.join(testDirectory, \"<STR_LIT>\"), \"<STR_LIT>\").results;<EOL>    const tsConfig = path.join(testDirectory, \"<STR_LIT>\");<EOL>    let compilerOptions: ts.CompilerOptions = { allowJs: true };<EOL>    const hasConfig = fs.existsSync(tsConfig);<EOL>    if (hasConfig) {<EOL>        const { config, error } = ts.readConfigFile(tsConfig, ts.sys.readFile);<EOL>        if (error !== undefined) {<EOL>            throw new Error(JSON.stringify(error));<EOL>        }<EOL>        const parseConfigHost = {<EOL>            fileExists: fs.existsSync,<EOL>            readDirectory: ts.sys.readDirectory,<EOL>            readFile: (file: string) => fs.readFileSync(file, \"<STR_LIT>\"),<EOL>            useCaseSensitiveFileNames: true,<EOL>        };<EOL>        compilerOptions = ts.parseJsonConfigFileContent(config, parseConfigHost, testDirectory).options;<EOL>    }<EOL>    const results: TestResult = { directory: testDirectory, results: {} };<EOL>    for (const fileToLint of filesToLint) {<EOL>        const isEncodingRule = path.basename(testDirectory) === \"<STR_LIT>\";<EOL>        const fileCompileName = denormalizeWinPath(path.resolve(fileToLint.replace(/\\.lint$/, \"<STR_LIT>\")));<EOL>        let fileText = isEncodingRule ? readBufferWithDetectedEncoding(fs.readFileSync(fileToLint)) : fs.readFileSync(fileToLint, \"<STR_LIT>\");<EOL>        const tsVersionRequirement = parse.getTypescriptVersionRequirement(fileText);<EOL>        if (tsVersionRequirement !== undefined) {<EOL>            <EOL>            if (!semver.satisfies(parse.getNormalizedTypescriptVersion(), tsVersionRequirement)) {<EOL>                results.results[fileToLint] = {<EOL>                    requirement: tsVersionRequirement,<EOL>                    skipped: true,<EOL>                };<EOL>                continue;<EOL>            }<EOL>            <EOL>            const lineBreak = fileText.search(/\\n/);<EOL>            fileText = lineBreak === -<NUM_LIT> ? \"<STR_LIT>\" : fileText.substr(lineBreak + <NUM_LIT>);<EOL>        }<EOL>        fileText = parse.preprocessDirectives(fileText);<EOL>        const fileTextWithoutMarkup = parse.removeErrorMarkup(fileText);<EOL>        const errorsFromMarkup = parse.parseErrorsFromMarkup(fileText);<EOL>        let program: ts.Program | undefined;<EOL>        if (hasConfig) {<EOL>            const compilerHost: ts.CompilerHost = {<EOL>                fileExists: (file) => file === fileCompileName || fs.existsSync(file),<EOL>                getCanonicalFileName: (filename) => filename,<EOL>                getCurrentDirectory: () => process.cwd(),<EOL>                getDefaultLibFileName: () => ts.getDefaultLibFileName(compilerOptions),<EOL>                getDirectories: (dir) => fs.readdirSync(dir),<EOL>                getNewLine: () => \"<STR_LIT>\",<EOL>                getSourceFile(filenameToGet, target) {<EOL>                    if (denormalizeWinPath(filenameToGet) === fileCompileName) {<EOL>                        return ts.createSourceFile(filenameToGet, fileTextWithoutMarkup, target, true);<EOL>                    }<EOL>                    if (path.basename(filenameToGet) === filenameToGet) {<EOL>                        <EOL>                        filenameToGet = path.join(path.dirname(ts.getDefaultLibFilePath(compilerOptions)), filenameToGet);<EOL>                    }<EOL>                    const text = fs.readFileSync(filenameToGet, \"<STR_LIT>\");<EOL>                    return ts.createSourceFile(filenameToGet, text, target, true);<EOL>                },<EOL>                readFile: (x) => x,<EOL>                useCaseSensitiveFileNames: () => true,<EOL>                writeFile: () => null,<EOL>            };<EOL>            program = ts.createProgram([fileCompileName], compilerOptions, compilerHost);<EOL>        }<EOL>        const lintOptions = {<EOL>            fix: false,<EOL>            formatter: \"<STR_LIT>\",<EOL>            formattersDirectory:","gt":"\"<STR_LIT>\","}
{"input":"<s> export function runTest(testDirectory: string, rulesDirectory?: string | string[]): TestResult {<EOL>    const filesToLint = glob.sync(path.join(testDirectory, `<STR_LIT>`));<EOL>    const tslintConfig = Linter.findConfiguration(path.join(testDirectory, \"<STR_LIT>\"), \"<STR_LIT>\").results;<EOL>    const tsConfig = path.join(testDirectory, \"<STR_LIT>\");<EOL>    let compilerOptions: ts.CompilerOptions = { allowJs: true };<EOL>    const hasConfig = fs.existsSync(tsConfig);<EOL>    if (hasConfig) {<EOL>        const { config, error } = ts.readConfigFile(tsConfig, ts.sys.readFile);<EOL>        if (error !== undefined) {<EOL>            throw new Error(JSON.stringify(error));<EOL>        }<EOL>        const parseConfigHost = {<EOL>            fileExists: fs.existsSync,<EOL>            readDirectory: ts.sys.readDirectory,<EOL>            readFile: (file: string) => fs.readFileSync(file, \"<STR_LIT>\"),<EOL>            useCaseSensitiveFileNames: true,<EOL>        };<EOL>        compilerOptions = ts.parseJsonConfigFileContent(config, parseConfigHost, testDirectory).options;<EOL>    }<EOL>    const results: TestResult = { directory: testDirectory, results: {} };<EOL>    for (const fileToLint of filesToLint) {<EOL>        const isEncodingRule = path.basename(testDirectory) === \"<STR_LIT>\";<EOL>        const fileCompileName = denormalizeWinPath(path.resolve(fileToLint.replace(/\\.lint$/, \"<STR_LIT>\")));<EOL>        let fileText = isEncodingRule ? readBufferWithDetectedEncoding(fs.readFileSync(fileToLint)) : fs.readFileSync(fileToLint, \"<STR_LIT>\");<EOL>        const tsVersionRequirement = parse.getTypescriptVersionRequirement(fileText);<EOL>        if (tsVersionRequirement !== undefined) {<EOL>            <EOL>            if (!semver.satisfies(parse.getNormalizedTypescriptVersion(), tsVersionRequirement)) {<EOL>                results.results[fileToLint] = {<EOL>                    requirement: tsVersionRequirement,<EOL>                    skipped: true,<EOL>                };<EOL>                continue;<EOL>            }<EOL>            <EOL>            const lineBreak = fileText.search(/\\n/);<EOL>            fileText = lineBreak === -<NUM_LIT> ? \"<STR_LIT>\" : fileText.substr(lineBreak + <NUM_LIT>);<EOL>        }<EOL>        fileText = parse.preprocessDirectives(fileText);<EOL>        const fileTextWithoutMarkup = parse.removeErrorMarkup(fileText);<EOL>        const errorsFromMarkup = parse.parseErrorsFromMarkup(fileText);<EOL>        let program: ts.Program | undefined;<EOL>        if (hasConfig) {<EOL>            const compilerHost: ts.CompilerHost = {<EOL>                fileExists: (file) => file === fileCompileName || fs.existsSync(file),<EOL>                getCanonicalFileName: (filename) => filename,<EOL>                getCurrentDirectory: () => process.cwd(),<EOL>                getDefaultLibFileName: () => ts.getDefaultLibFileName(compilerOptions),<EOL>                getDirectories: (dir) => fs.readdirSync(dir),<EOL>                getNewLine: () => \"<STR_LIT>\",<EOL>                getSourceFile(filenameToGet, target) {<EOL>                    if (denormalizeWinPath(filenameToGet) === fileCompileName) {<EOL>                        return ts.createSourceFile(filenameToGet, fileTextWithoutMarkup, target, true);<EOL>                    }<EOL>                    if (path.basename(filenameToGet) === filenameToGet) {<EOL>                        <EOL>                        filenameToGet = path.join(path.dirname(ts.getDefaultLibFilePath(compilerOptions)), filenameToGet);<EOL>                    }<EOL>                    const text = fs.readFileSync(filenameToGet, \"<STR_LIT>\");<EOL>                    return ts.createSourceFile(filenameToGet, text, target, true);<EOL>                },<EOL>                readFile: (x) => x,<EOL>                useCaseSensitiveFileNames: () => true,<EOL>                writeFile: () => null,<EOL>            };<EOL>            program = ts.createProgram([fileCompileName], compilerOptions, compilerHost);<EOL>        }<EOL>        const lintOptions = {<EOL>            fix: false,<EOL>            formatter: \"<STR_LIT>\",<EOL>            formattersDirectory: \"<STR_LIT>\",<EOL>            rulesDirectory,<EOL>        };<EOL>        const linter = new Linter(lintOptions, program);<EOL>        <EOL>        linter.lint(isEncodingRule ? fileToLint : fileCompileName, fileTextWithoutMarkup, tslintConfig);<EOL>        const failures = linter.getResult().failures;<EOL>        const errorsFromLinter: LintError[] = failures.map((failure) => {<EOL>            const startLineAndCharacter = failure.getStartPosition().getLineAndCharacter();<EOL>            const endLineAndCharacter = failure.getEndPosition().getLineAndCharacter();<EOL>            return {<EOL>                endPos: {<EOL>                    col: endLineAndCharacter.character,<EOL>                    line: endLineAndCharacter.line,<EOL>                },<EOL>                message: failure.getFailure(),<EOL>                startPos: {<EOL>                    col: startLineAndCharacter.character,<EOL>","gt":"line: startLineAndCharacter.line,"}
{"input":"<s> export function runTest(testDirectory: string, rulesDirectory?: string | string[]): TestResult {<EOL>    const filesToLint = glob.sync(path.join(testDirectory, `<STR_LIT>`));<EOL>    const tslintConfig = Linter.findConfiguration(path.join(testDirectory, \"<STR_LIT>\"), \"<STR_LIT>\").results;<EOL>    const tsConfig = path.join(testDirectory, \"<STR_LIT>\");<EOL>    let compilerOptions: ts.CompilerOptions = { allowJs: true };<EOL>    const hasConfig = fs.existsSync(tsConfig);<EOL>    if (hasConfig) {<EOL>        const { config, error } = ts.readConfigFile(tsConfig, ts.sys.readFile);<EOL>        if (error !== undefined) {<EOL>            throw new Error(JSON.stringify(error));<EOL>        }<EOL>        const parseConfigHost = {<EOL>            fileExists: fs.existsSync,<EOL>            readDirectory: ts.sys.readDirectory,<EOL>            readFile: (file: string) => fs.readFileSync(file, \"<STR_LIT>\"),<EOL>            useCaseSensitiveFileNames: true,<EOL>        };<EOL>        compilerOptions = ts.parseJsonConfigFileContent(config, parseConfigHost, testDirectory).options;<EOL>    }<EOL>    const results: TestResult = { directory: testDirectory, results: {} };<EOL>    for (const fileToLint of filesToLint) {<EOL>        const isEncodingRule = path.basename(testDirectory) === \"<STR_LIT>\";<EOL>        const fileCompileName = denormalizeWinPath(path.resolve(fileToLint.replace(/\\.lint$/, \"<STR_LIT>\")));<EOL>        let fileText = isEncodingRule ? readBufferWithDetectedEncoding(fs.readFileSync(fileToLint)) : fs.readFileSync(fileToLint, \"<STR_LIT>\");<EOL>        const tsVersionRequirement = parse.getTypescriptVersionRequirement(fileText);<EOL>        if (tsVersionRequirement !== undefined) {<EOL>            <EOL>            if (!semver.satisfies(parse.getNormalizedTypescriptVersion(), tsVersionRequirement)) {<EOL>                results.results[fileToLint] = {<EOL>                    requirement: tsVersionRequirement,<EOL>                    skipped: true,<EOL>                };<EOL>                continue;<EOL>            }<EOL>            <EOL>            const lineBreak = fileText.search(/\\n/);<EOL>            fileText = lineBreak === -<NUM_LIT> ? \"<STR_LIT>\" : fileText.substr(lineBreak + <NUM_LIT>);<EOL>        }<EOL>        fileText = parse.preprocessDirectives(fileText);<EOL>        const fileTextWithoutMarkup = parse.removeErrorMarkup(fileText);<EOL>        const errorsFromMarkup = parse.parseErrorsFromMarkup(fileText);<EOL>        let program: ts.Program | undefined;<EOL>        if (hasConfig) {<EOL>            const compilerHost: ts.CompilerHost = {<EOL>                fileExists: (file) => file === fileCompileName || fs.existsSync(file),<EOL>                getCanonicalFileName: (filename) => filename,<EOL>                getCurrentDirectory: () => process.cwd(),<EOL>                getDefaultLibFileName: () => ts.getDefaultLibFileName(compilerOptions),<EOL>                getDirectories: (dir) => fs.readdirSync(dir),<EOL>                getNewLine: () => \"<STR_LIT>\",<EOL>                getSourceFile(filenameToGet, target) {<EOL>                    if (denormalizeWinPath(filenameToGet) === fileCompileName) {<EOL>                        return ts.createSourceFile(filenameToGet, fileTextWithoutMarkup, target, true);<EOL>                    }<EOL>                    if (path.basename(filenameToGet) === filenameToGet) {<EOL>                        <EOL>                        filenameToGet = path.join(path.dirname(ts.getDefaultLibFilePath(compilerOptions)), filenameToGet);<EOL>                    }<EOL>                    const text = fs.readFileSync(filenameToGet, \"<STR_LIT>\");<EOL>                    return ts.createSourceFile(filenameToGet, text, target, true);<EOL>                },<EOL>                readFile: (x) => x,<EOL>                useCaseSensitiveFileNames: () => true,<EOL>                writeFile: () => null,<EOL>            };<EOL>            program = ts.createProgram([fileCompileName], compilerOptions, compilerHost);<EOL>        }<EOL>        const lintOptions = {<EOL>            fix: false,<EOL>            formatter: \"<STR_LIT>\",<EOL>            formattersDirectory: \"<STR_LIT>\",<EOL>            rulesDirectory,<EOL>        };<EOL>        const linter = new Linter(lintOptions, program);<EOL>        <EOL>        linter.lint(isEncodingRule ? fileToLint : fileCompileName, fileTextWithoutMarkup, tslintConfig);<EOL>        const failures = linter.getResult().failures;<EOL>        const errorsFromLinter: LintError[] = failures.map((failure) => {<EOL>            const startLineAndCharacter = failure.getStartPosition().getLineAndCharacter();<EOL>            const endLineAndCharacter = failure.getEndPosition().getLineAndCharacter();<EOL>            return {<EOL>                endPos: {<EOL>                    col: endLineAndCharacter.character,<EOL>                    line: endLineAndCharacter.line,<EOL>                },<EOL>                message: failure.getFailure(),<EOL>                startPos: {<EOL>                    col: startLineAndCharacter.character,<EOL>                    line: startLineAndCharacter.line,<EOL>                },<EOL>            };<EOL>        });<EOL>        <EOL>        let fixedFileText = \"<STR_LIT>\";<EOL>        let newFileText = \"<STR_LIT>\";<EOL>        try {<EOL>            const fixedFile = fileToLint.","gt":"replace(/\\.lint$/, FIXES_FILE_EXTENSION);"}
{"input":"<s> export function runTest(testDirectory: string, rulesDirectory?: string | string[]): TestResult {<EOL>    const filesToLint = glob.sync(path.join(testDirectory, `<STR_LIT>`));<EOL>    const tslintConfig = Linter.findConfiguration(path.join(testDirectory, \"<STR_LIT>\"), \"<STR_LIT>\").results;<EOL>    const tsConfig = path.join(testDirectory, \"<STR_LIT>\");<EOL>    let compilerOptions: ts.CompilerOptions = { allowJs: true };<EOL>    const hasConfig = fs.existsSync(tsConfig);<EOL>    if (hasConfig) {<EOL>        const { config, error } = ts.readConfigFile(tsConfig, ts.sys.readFile);<EOL>        if (error !== undefined) {<EOL>            throw new Error(JSON.stringify(error));<EOL>        }<EOL>        const parseConfigHost = {<EOL>            fileExists: fs.existsSync,<EOL>            readDirectory: ts.sys.readDirectory,<EOL>            readFile: (file: string) => fs.readFileSync(file, \"<STR_LIT>\"),<EOL>            useCaseSensitiveFileNames: true,<EOL>        };<EOL>        compilerOptions = ts.parseJsonConfigFileContent(config, parseConfigHost, testDirectory).options;<EOL>    }<EOL>    const results: TestResult = { directory: testDirectory, results: {} };<EOL>    for (const fileToLint of filesToLint) {<EOL>        const isEncodingRule = path.basename(testDirectory) === \"<STR_LIT>\";<EOL>        const fileCompileName = denormalizeWinPath(path.resolve(fileToLint.replace(/\\.lint$/, \"<STR_LIT>\")));<EOL>        let fileText = isEncodingRule ? readBufferWithDetectedEncoding(fs.readFileSync(fileToLint)) : fs.readFileSync(fileToLint, \"<STR_LIT>\");<EOL>        const tsVersionRequirement = parse.getTypescriptVersionRequirement(fileText);<EOL>        if (tsVersionRequirement !== undefined) {<EOL>            <EOL>            if (!semver.satisfies(parse.getNormalizedTypescriptVersion(), tsVersionRequirement)) {<EOL>                results.results[fileToLint] = {<EOL>                    requirement: tsVersionRequirement,<EOL>                    skipped: true,<EOL>                };<EOL>                continue;<EOL>            }<EOL>            <EOL>            const lineBreak = fileText.search(/\\n/);<EOL>            fileText = lineBreak === -<NUM_LIT> ? \"<STR_LIT>\" : fileText.substr(lineBreak + <NUM_LIT>);<EOL>        }<EOL>        fileText = parse.preprocessDirectives(fileText);<EOL>        const fileTextWithoutMarkup = parse.removeErrorMarkup(fileText);<EOL>        const errorsFromMarkup = parse.parseErrorsFromMarkup(fileText);<EOL>        let program: ts.Program | undefined;<EOL>        if (hasConfig) {<EOL>            const compilerHost: ts.CompilerHost = {<EOL>                fileExists: (file) => file === fileCompileName || fs.existsSync(file),<EOL>                getCanonicalFileName: (filename) => filename,<EOL>                getCurrentDirectory: () => process.cwd(),<EOL>                getDefaultLibFileName: () => ts.getDefaultLibFileName(compilerOptions),<EOL>                getDirectories: (dir) => fs.readdirSync(dir),<EOL>                getNewLine: () => \"<STR_LIT>\",<EOL>                getSourceFile(filenameToGet, target) {<EOL>                    if (denormalizeWinPath(filenameToGet) === fileCompileName) {<EOL>                        return ts.createSourceFile(filenameToGet, fileTextWithoutMarkup, target, true);<EOL>                    }<EOL>                    if (path.basename(filenameToGet) === filenameToGet) {<EOL>                        <EOL>                        filenameToGet = path.join(path.dirname(ts.getDefaultLibFilePath(compilerOptions)), filenameToGet);<EOL>                    }<EOL>                    const text = fs.readFileSync(filenameToGet, \"<STR_LIT>\");<EOL>                    return ts.createSourceFile(filenameToGet, text, target, true);<EOL>                },<EOL>                readFile: (x) => x,<EOL>                useCaseSensitiveFileNames: () => true,<EOL>                writeFile: () => null,<EOL>            };<EOL>            program = ts.createProgram([fileCompileName], compilerOptions, compilerHost);<EOL>        }<EOL>        const lintOptions = {<EOL>            fix: false,<EOL>            formatter: \"<STR_LIT>\",<EOL>            formattersDirectory: \"<STR_LIT>\",<EOL>            rulesDirectory,<EOL>        };<EOL>        const linter = new Linter(lintOptions, program);<EOL>        <EOL>        linter.lint(isEncodingRule ? fileToLint : fileCompileName, fileTextWithoutMarkup, tslintConfig);<EOL>        const failures = linter.getResult().failures;<EOL>        const errorsFromLinter: LintError[] = failures.map((failure) => {<EOL>            const startLineAndCharacter = failure.getStartPosition().getLineAndCharacter();<EOL>            const endLineAndCharacter = failure.getEndPosition().getLineAndCharacter();<EOL>            return {<EOL>                endPos: {<EOL>                    col: endLineAndCharacter.character,<EOL>                    line: endLineAndCharacter.line,<EOL>                },<EOL>                message: failure.getFailure(),<EOL>                startPos: {<EOL>                    col: startLineAndCharacter.character,<EOL>                    line: startLineAndCharacter.line,<EOL>                },<EOL>            };<EOL>        });<EOL>        <EOL>        let fixedFileText = \"<STR_LIT>\";<EOL>        let newFileText = \"<STR_LIT>\";<EOL>        try {<EOL>            const fixedFile = fileToLint.replace(/\\.lint$/, FIXES_FILE_EXTENSION);<EOL>            const stat = fs.statSync(fixedFile);<EOL>","gt":"if (stat.isFile()) {"}
{"input":"<s> export function runTest(testDirectory: string, rulesDirectory?: string | string[]): TestResult {<EOL>    const filesToLint = glob.sync(path.join(testDirectory, `<STR_LIT>`));<EOL>    const tslintConfig = Linter.findConfiguration(path.join(testDirectory, \"<STR_LIT>\"), \"<STR_LIT>\").results;<EOL>    const tsConfig = path.join(testDirectory, \"<STR_LIT>\");<EOL>    let compilerOptions: ts.CompilerOptions = { allowJs: true };<EOL>    const hasConfig = fs.existsSync(tsConfig);<EOL>    if (hasConfig) {<EOL>        const { config, error } = ts.readConfigFile(tsConfig, ts.sys.readFile);<EOL>        if (error !== undefined) {<EOL>            throw new Error(JSON.stringify(error));<EOL>        }<EOL>        const parseConfigHost = {<EOL>            fileExists: fs.existsSync,<EOL>            readDirectory: ts.sys.readDirectory,<EOL>            readFile: (file: string) => fs.readFileSync(file, \"<STR_LIT>\"),<EOL>            useCaseSensitiveFileNames: true,<EOL>        };<EOL>        compilerOptions = ts.parseJsonConfigFileContent(config, parseConfigHost, testDirectory).options;<EOL>    }<EOL>    const results: TestResult = { directory: testDirectory, results: {} };<EOL>    for (const fileToLint of filesToLint) {<EOL>        const isEncodingRule = path.basename(testDirectory) === \"<STR_LIT>\";<EOL>        const fileCompileName = denormalizeWinPath(path.resolve(fileToLint.replace(/\\.lint$/, \"<STR_LIT>\")));<EOL>        let fileText = isEncodingRule ? readBufferWithDetectedEncoding(fs.readFileSync(fileToLint)) : fs.readFileSync(fileToLint, \"<STR_LIT>\");<EOL>        const tsVersionRequirement = parse.getTypescriptVersionRequirement(fileText);<EOL>        if (tsVersionRequirement !== undefined) {<EOL>            <EOL>            if (!semver.satisfies(parse.getNormalizedTypescriptVersion(), tsVersionRequirement)) {<EOL>                results.results[fileToLint] = {<EOL>                    requirement: tsVersionRequirement,<EOL>                    skipped: true,<EOL>                };<EOL>                continue;<EOL>            }<EOL>            <EOL>            const lineBreak = fileText.search(/\\n/);<EOL>            fileText = lineBreak === -<NUM_LIT> ? \"<STR_LIT>\" : fileText.substr(lineBreak + <NUM_LIT>);<EOL>        }<EOL>        fileText = parse.preprocessDirectives(fileText);<EOL>        const fileTextWithoutMarkup = parse.removeErrorMarkup(fileText);<EOL>        const errorsFromMarkup = parse.parseErrorsFromMarkup(fileText);<EOL>        let program: ts.Program | undefined;<EOL>        if (hasConfig) {<EOL>            const compilerHost: ts.CompilerHost = {<EOL>                fileExists: (file) => file === fileCompileName || fs.existsSync(file),<EOL>                getCanonicalFileName: (filename) => filename,<EOL>                getCurrentDirectory: () => process.cwd(),<EOL>                getDefaultLibFileName: () => ts.getDefaultLibFileName(compilerOptions),<EOL>                getDirectories: (dir) => fs.readdirSync(dir),<EOL>                getNewLine: () => \"<STR_LIT>\",<EOL>                getSourceFile(filenameToGet, target) {<EOL>                    if (denormalizeWinPath(filenameToGet) === fileCompileName) {<EOL>                        return ts.createSourceFile(filenameToGet, fileTextWithoutMarkup, target, true);<EOL>                    }<EOL>                    if (path.basename(filenameToGet) === filenameToGet) {<EOL>                        <EOL>                        filenameToGet = path.join(path.dirname(ts.getDefaultLibFilePath(compilerOptions)), filenameToGet);<EOL>                    }<EOL>                    const text = fs.readFileSync(filenameToGet, \"<STR_LIT>\");<EOL>                    return ts.createSourceFile(filenameToGet, text, target, true);<EOL>                },<EOL>                readFile: (x) => x,<EOL>                useCaseSensitiveFileNames: () => true,<EOL>                writeFile: () => null,<EOL>            };<EOL>            program = ts.createProgram([fileCompileName], compilerOptions, compilerHost);<EOL>        }<EOL>        const lintOptions = {<EOL>            fix: false,<EOL>            formatter: \"<STR_LIT>\",<EOL>            formattersDirectory: \"<STR_LIT>\",<EOL>            rulesDirectory,<EOL>        };<EOL>        const linter = new Linter(lintOptions, program);<EOL>        <EOL>        linter.lint(isEncodingRule ? fileToLint : fileCompileName, fileTextWithoutMarkup, tslintConfig);<EOL>        const failures = linter.getResult().failures;<EOL>        const errorsFromLinter: LintError[] = failures.map((failure) => {<EOL>            const startLineAndCharacter = failure.getStartPosition().getLineAndCharacter();<EOL>            const endLineAndCharacter = failure.getEndPosition().getLineAndCharacter();<EOL>            return {<EOL>                endPos: {<EOL>                    col: endLineAndCharacter.character,<EOL>                    line: endLineAndCharacter.line,<EOL>                },<EOL>                message: failure.getFailure(),<EOL>                startPos: {<EOL>                    col: startLineAndCharacter.character,<EOL>                    line: startLineAndCharacter.line,<EOL>                },<EOL>            };<EOL>        });<EOL>        <EOL>        let fixedFileText = \"<STR_LIT>\";<EOL>        let newFileText = \"<STR_LIT>\";<EOL>        try {<EOL>            const fixedFile = fileToLint.replace(/\\.lint$/, FIXES_FILE_EXTENSION);<EOL>            const stat = fs.statSync(fixedFile);<EOL>            if (stat.isFile()) {<EOL>                fixedFileText = fs.readFileSync(","gt":"fixedFile, \"<STR_LIT>\");"}
{"input":"<s> export function runTest(testDirectory: string, rulesDirectory?: string | string[]): TestResult {<EOL>    const filesToLint = glob.sync(path.join(testDirectory, `<STR_LIT>`));<EOL>    const tslintConfig = Linter.findConfiguration(path.join(testDirectory, \"<STR_LIT>\"), \"<STR_LIT>\").results;<EOL>    const tsConfig = path.join(testDirectory, \"<STR_LIT>\");<EOL>    let compilerOptions: ts.CompilerOptions = { allowJs: true };<EOL>    const hasConfig = fs.existsSync(tsConfig);<EOL>    if (hasConfig) {<EOL>        const { config, error } = ts.readConfigFile(tsConfig, ts.sys.readFile);<EOL>        if (error !== undefined) {<EOL>            throw new Error(JSON.stringify(error));<EOL>        }<EOL>        const parseConfigHost = {<EOL>            fileExists: fs.existsSync,<EOL>            readDirectory: ts.sys.readDirectory,<EOL>            readFile: (file: string) => fs.readFileSync(file, \"<STR_LIT>\"),<EOL>            useCaseSensitiveFileNames: true,<EOL>        };<EOL>        compilerOptions = ts.parseJsonConfigFileContent(config, parseConfigHost, testDirectory).options;<EOL>    }<EOL>    const results: TestResult = { directory: testDirectory, results: {} };<EOL>    for (const fileToLint of filesToLint) {<EOL>        const isEncodingRule = path.basename(testDirectory) === \"<STR_LIT>\";<EOL>        const fileCompileName = denormalizeWinPath(path.resolve(fileToLint.replace(/\\.lint$/, \"<STR_LIT>\")));<EOL>        let fileText = isEncodingRule ? readBufferWithDetectedEncoding(fs.readFileSync(fileToLint)) : fs.readFileSync(fileToLint, \"<STR_LIT>\");<EOL>        const tsVersionRequirement = parse.getTypescriptVersionRequirement(fileText);<EOL>        if (tsVersionRequirement !== undefined) {<EOL>            <EOL>            if (!semver.satisfies(parse.getNormalizedTypescriptVersion(), tsVersionRequirement)) {<EOL>                results.results[fileToLint] = {<EOL>                    requirement: tsVersionRequirement,<EOL>                    skipped: true,<EOL>                };<EOL>                continue;<EOL>            }<EOL>            <EOL>            const lineBreak = fileText.search(/\\n/);<EOL>            fileText = lineBreak === -<NUM_LIT> ? \"<STR_LIT>\" : fileText.substr(lineBreak + <NUM_LIT>);<EOL>        }<EOL>        fileText = parse.preprocessDirectives(fileText);<EOL>        const fileTextWithoutMarkup = parse.removeErrorMarkup(fileText);<EOL>        const errorsFromMarkup = parse.parseErrorsFromMarkup(fileText);<EOL>        let program: ts.Program | undefined;<EOL>        if (hasConfig) {<EOL>            const compilerHost: ts.CompilerHost = {<EOL>                fileExists: (file) => file === fileCompileName || fs.existsSync(file),<EOL>                getCanonicalFileName: (filename) => filename,<EOL>                getCurrentDirectory: () => process.cwd(),<EOL>                getDefaultLibFileName: () => ts.getDefaultLibFileName(compilerOptions),<EOL>                getDirectories: (dir) => fs.readdirSync(dir),<EOL>                getNewLine: () => \"<STR_LIT>\",<EOL>                getSourceFile(filenameToGet, target) {<EOL>                    if (denormalizeWinPath(filenameToGet) === fileCompileName) {<EOL>                        return ts.createSourceFile(filenameToGet, fileTextWithoutMarkup, target, true);<EOL>                    }<EOL>                    if (path.basename(filenameToGet) === filenameToGet) {<EOL>                        <EOL>                        filenameToGet = path.join(path.dirname(ts.getDefaultLibFilePath(compilerOptions)), filenameToGet);<EOL>                    }<EOL>                    const text = fs.readFileSync(filenameToGet, \"<STR_LIT>\");<EOL>                    return ts.createSourceFile(filenameToGet, text, target, true);<EOL>                },<EOL>                readFile: (x) => x,<EOL>                useCaseSensitiveFileNames: () => true,<EOL>                writeFile: () => null,<EOL>            };<EOL>            program = ts.createProgram([fileCompileName], compilerOptions, compilerHost);<EOL>        }<EOL>        const lintOptions = {<EOL>            fix: false,<EOL>            formatter: \"<STR_LIT>\",<EOL>            formattersDirectory: \"<STR_LIT>\",<EOL>            rulesDirectory,<EOL>        };<EOL>        const linter = new Linter(lintOptions, program);<EOL>        <EOL>        linter.lint(isEncodingRule ? fileToLint : fileCompileName, fileTextWithoutMarkup, tslintConfig);<EOL>        const failures = linter.getResult().failures;<EOL>        const errorsFromLinter: LintError[] = failures.map((failure) => {<EOL>            const startLineAndCharacter = failure.getStartPosition().getLineAndCharacter();<EOL>            const endLineAndCharacter = failure.getEndPosition().getLineAndCharacter();<EOL>            return {<EOL>                endPos: {<EOL>                    col: endLineAndCharacter.character,<EOL>                    line: endLineAndCharacter.line,<EOL>                },<EOL>                message: failure.getFailure(),<EOL>                startPos: {<EOL>                    col: startLineAndCharacter.character,<EOL>                    line: startLineAndCharacter.line,<EOL>                },<EOL>            };<EOL>        });<EOL>        <EOL>        let fixedFileText = \"<STR_LIT>\";<EOL>        let newFileText = \"<STR_LIT>\";<EOL>        try {<EOL>            const fixedFile = fileToLint.replace(/\\.lint$/, FIXES_FILE_EXTENSION);<EOL>            const stat = fs.statSync(fixedFile);<EOL>            if (stat.isFile()) {<EOL>                fixedFileText = fs.readFileSync(fixedFile, \"<STR_LIT>\");<EOL>                const fixes = mapDefined(failures, (f) => f.getFix());<EOL>                newFileText = Replacement.applyFixes(fileTextWithoutMarkup, fixes);<EOL>            }<EOL>        }<EOL>","gt":"catch (e) {"}
{"input":"<s> export function runTest(testDirectory: string, rulesDirectory?: string | string[]): TestResult {<EOL>    const filesToLint = glob.sync(path.join(testDirectory, `<STR_LIT>`));<EOL>    const tslintConfig = Linter.findConfiguration(path.join(testDirectory, \"<STR_LIT>\"), \"<STR_LIT>\").results;<EOL>    const tsConfig = path.join(testDirectory, \"<STR_LIT>\");<EOL>    let compilerOptions: ts.CompilerOptions = { allowJs: true };<EOL>    const hasConfig = fs.existsSync(tsConfig);<EOL>    if (hasConfig) {<EOL>        const { config, error } = ts.readConfigFile(tsConfig, ts.sys.readFile);<EOL>        if (error !== undefined) {<EOL>            throw new Error(JSON.stringify(error));<EOL>        }<EOL>        const parseConfigHost = {<EOL>            fileExists: fs.existsSync,<EOL>            readDirectory: ts.sys.readDirectory,<EOL>            readFile: (file: string) => fs.readFileSync(file, \"<STR_LIT>\"),<EOL>            useCaseSensitiveFileNames: true,<EOL>        };<EOL>        compilerOptions = ts.parseJsonConfigFileContent(config, parseConfigHost, testDirectory).options;<EOL>    }<EOL>    const results: TestResult = { directory: testDirectory, results: {} };<EOL>    for (const fileToLint of filesToLint) {<EOL>        const isEncodingRule = path.basename(testDirectory) === \"<STR_LIT>\";<EOL>        const fileCompileName = denormalizeWinPath(path.resolve(fileToLint.replace(/\\.lint$/, \"<STR_LIT>\")));<EOL>        let fileText = isEncodingRule ? readBufferWithDetectedEncoding(fs.readFileSync(fileToLint)) : fs.readFileSync(fileToLint, \"<STR_LIT>\");<EOL>        const tsVersionRequirement = parse.getTypescriptVersionRequirement(fileText);<EOL>        if (tsVersionRequirement !== undefined) {<EOL>            <EOL>            if (!semver.satisfies(parse.getNormalizedTypescriptVersion(), tsVersionRequirement)) {<EOL>                results.results[fileToLint] = {<EOL>                    requirement: tsVersionRequirement,<EOL>                    skipped: true,<EOL>                };<EOL>                continue;<EOL>            }<EOL>            <EOL>            const lineBreak = fileText.search(/\\n/);<EOL>            fileText = lineBreak === -<NUM_LIT> ? \"<STR_LIT>\" : fileText.substr(lineBreak + <NUM_LIT>);<EOL>        }<EOL>        fileText = parse.preprocessDirectives(fileText);<EOL>        const fileTextWithoutMarkup = parse.removeErrorMarkup(fileText);<EOL>        const errorsFromMarkup = parse.parseErrorsFromMarkup(fileText);<EOL>        let program: ts.Program | undefined;<EOL>        if (hasConfig) {<EOL>            const compilerHost: ts.CompilerHost = {<EOL>                fileExists: (file) => file === fileCompileName || fs.existsSync(file),<EOL>                getCanonicalFileName: (filename) => filename,<EOL>                getCurrentDirectory: () => process.cwd(),<EOL>                getDefaultLibFileName: () => ts.getDefaultLibFileName(compilerOptions),<EOL>                getDirectories: (dir) => fs.readdirSync(dir),<EOL>                getNewLine: () => \"<STR_LIT>\",<EOL>                getSourceFile(filenameToGet, target) {<EOL>                    if (denormalizeWinPath(filenameToGet) === fileCompileName) {<EOL>                        return ts.createSourceFile(filenameToGet, fileTextWithoutMarkup, target, true);<EOL>                    }<EOL>                    if (path.basename(filenameToGet) === filenameToGet) {<EOL>                        <EOL>                        filenameToGet = path.join(path.dirname(ts.getDefaultLibFilePath(compilerOptions)), filenameToGet);<EOL>                    }<EOL>                    const text = fs.readFileSync(filenameToGet, \"<STR_LIT>\");<EOL>                    return ts.createSourceFile(filenameToGet, text, target, true);<EOL>                },<EOL>                readFile: (x) => x,<EOL>                useCaseSensitiveFileNames: () => true,<EOL>                writeFile: () => null,<EOL>            };<EOL>            program = ts.createProgram([fileCompileName], compilerOptions, compilerHost);<EOL>        }<EOL>        const lintOptions = {<EOL>            fix: false,<EOL>            formatter: \"<STR_LIT>\",<EOL>            formattersDirectory: \"<STR_LIT>\",<EOL>            rulesDirectory,<EOL>        };<EOL>        const linter = new Linter(lintOptions, program);<EOL>        <EOL>        linter.lint(isEncodingRule ? fileToLint : fileCompileName, fileTextWithoutMarkup, tslintConfig);<EOL>        const failures = linter.getResult().failures;<EOL>        const errorsFromLinter: LintError[] = failures.map((failure) => {<EOL>            const startLineAndCharacter = failure.getStartPosition().getLineAndCharacter();<EOL>            const endLineAndCharacter = failure.getEndPosition().getLineAndCharacter();<EOL>            return {<EOL>                endPos: {<EOL>                    col: endLineAndCharacter.character,<EOL>                    line: endLineAndCharacter.line,<EOL>                },<EOL>                message: failure.getFailure(),<EOL>                startPos: {<EOL>                    col: startLineAndCharacter.character,<EOL>                    line: startLineAndCharacter.line,<EOL>                },<EOL>            };<EOL>        });<EOL>        <EOL>        let fixedFileText = \"<STR_LIT>\";<EOL>        let newFileText = \"<STR_LIT>\";<EOL>        try {<EOL>            const fixedFile = fileToLint.replace(/\\.lint$/, FIXES_FILE_EXTENSION);<EOL>            const stat = fs.statSync(fixedFile);<EOL>            if (stat.isFile()) {<EOL>                fixedFileText = fs.readFileSync(fixedFile, \"<STR_LIT>\");<EOL>                const fixes = mapDefined(failures, (f) => f.getFix());<EOL>                newFileText = Replacement.applyFixes(fileTextWithoutMarkup, fixes);<EOL>            }<EOL>        }<EOL>        catch (e) {<EOL>","gt":"fixedFileText = \"<STR_LIT>\";"}
{"input":"<s> export function runTest(testDirectory: string, rulesDirectory?: string | string[]): TestResult {<EOL>    const filesToLint = glob.sync(path.join(testDirectory, `<STR_LIT>`));<EOL>    const tslintConfig = Linter.findConfiguration(path.join(testDirectory, \"<STR_LIT>\"), \"<STR_LIT>\").results;<EOL>    const tsConfig = path.join(testDirectory, \"<STR_LIT>\");<EOL>    let compilerOptions: ts.CompilerOptions = { allowJs: true };<EOL>    const hasConfig = fs.existsSync(tsConfig);<EOL>    if (hasConfig) {<EOL>        const { config, error } = ts.readConfigFile(tsConfig, ts.sys.readFile);<EOL>        if (error !== undefined) {<EOL>            throw new Error(JSON.stringify(error));<EOL>        }<EOL>        const parseConfigHost = {<EOL>            fileExists: fs.existsSync,<EOL>            readDirectory: ts.sys.readDirectory,<EOL>            readFile: (file: string) => fs.readFileSync(file, \"<STR_LIT>\"),<EOL>            useCaseSensitiveFileNames: true,<EOL>        };<EOL>        compilerOptions = ts.parseJsonConfigFileContent(config, parseConfigHost, testDirectory).options;<EOL>    }<EOL>    const results: TestResult = { directory: testDirectory, results: {} };<EOL>    for (const fileToLint of filesToLint) {<EOL>        const isEncodingRule = path.basename(testDirectory) === \"<STR_LIT>\";<EOL>        const fileCompileName = denormalizeWinPath(path.resolve(fileToLint.replace(/\\.lint$/, \"<STR_LIT>\")));<EOL>        let fileText = isEncodingRule ? readBufferWithDetectedEncoding(fs.readFileSync(fileToLint)) : fs.readFileSync(fileToLint, \"<STR_LIT>\");<EOL>        const tsVersionRequirement = parse.getTypescriptVersionRequirement(fileText);<EOL>        if (tsVersionRequirement !== undefined) {<EOL>            <EOL>            if (!semver.satisfies(parse.getNormalizedTypescriptVersion(), tsVersionRequirement)) {<EOL>                results.results[fileToLint] = {<EOL>                    requirement: tsVersionRequirement,<EOL>                    skipped: true,<EOL>                };<EOL>                continue;<EOL>            }<EOL>            <EOL>            const lineBreak = fileText.search(/\\n/);<EOL>            fileText = lineBreak === -<NUM_LIT> ? \"<STR_LIT>\" : fileText.substr(lineBreak + <NUM_LIT>);<EOL>        }<EOL>        fileText = parse.preprocessDirectives(fileText);<EOL>        const fileTextWithoutMarkup = parse.removeErrorMarkup(fileText);<EOL>        const errorsFromMarkup = parse.parseErrorsFromMarkup(fileText);<EOL>        let program: ts.Program | undefined;<EOL>        if (hasConfig) {<EOL>            const compilerHost: ts.CompilerHost = {<EOL>                fileExists: (file) => file === fileCompileName || fs.existsSync(file),<EOL>                getCanonicalFileName: (filename) => filename,<EOL>                getCurrentDirectory: () => process.cwd(),<EOL>                getDefaultLibFileName: () => ts.getDefaultLibFileName(compilerOptions),<EOL>                getDirectories: (dir) => fs.readdirSync(dir),<EOL>                getNewLine: () => \"<STR_LIT>\",<EOL>                getSourceFile(filenameToGet, target) {<EOL>                    if (denormalizeWinPath(filenameToGet) === fileCompileName) {<EOL>                        return ts.createSourceFile(filenameToGet, fileTextWithoutMarkup, target, true);<EOL>                    }<EOL>                    if (path.basename(filenameToGet) === filenameToGet) {<EOL>                        <EOL>                        filenameToGet = path.join(path.dirname(ts.getDefaultLibFilePath(compilerOptions)), filenameToGet);<EOL>                    }<EOL>                    const text = fs.readFileSync(filenameToGet, \"<STR_LIT>\");<EOL>                    return ts.createSourceFile(filenameToGet, text, target, true);<EOL>                },<EOL>                readFile: (x) => x,<EOL>                useCaseSensitiveFileNames: () => true,<EOL>                writeFile: () => null,<EOL>            };<EOL>            program = ts.createProgram([fileCompileName], compilerOptions, compilerHost);<EOL>        }<EOL>        const lintOptions = {<EOL>            fix: false,<EOL>            formatter: \"<STR_LIT>\",<EOL>            formattersDirectory: \"<STR_LIT>\",<EOL>            rulesDirectory,<EOL>        };<EOL>        const linter = new Linter(lintOptions, program);<EOL>        <EOL>        linter.lint(isEncodingRule ? fileToLint : fileCompileName, fileTextWithoutMarkup, tslintConfig);<EOL>        const failures = linter.getResult().failures;<EOL>        const errorsFromLinter: LintError[] = failures.map((failure) => {<EOL>            const startLineAndCharacter = failure.getStartPosition().getLineAndCharacter();<EOL>            const endLineAndCharacter = failure.getEndPosition().getLineAndCharacter();<EOL>            return {<EOL>                endPos: {<EOL>                    col: endLineAndCharacter.character,<EOL>                    line: endLineAndCharacter.line,<EOL>                },<EOL>                message: failure.getFailure(),<EOL>                startPos: {<EOL>                    col: startLineAndCharacter.character,<EOL>                    line: startLineAndCharacter.line,<EOL>                },<EOL>            };<EOL>        });<EOL>        <EOL>        let fixedFileText = \"<STR_LIT>\";<EOL>        let newFileText = \"<STR_LIT>\";<EOL>        try {<EOL>            const fixedFile = fileToLint.replace(/\\.lint$/, FIXES_FILE_EXTENSION);<EOL>            const stat = fs.statSync(fixedFile);<EOL>            if (stat.isFile()) {<EOL>                fixedFileText = fs.readFileSync(fixedFile, \"<STR_LIT>\");<EOL>                const fixes = mapDefined(failures, (f) => f.getFix());<EOL>                newFileText = Replacement.applyFixes(fileTextWithoutMarkup, fixes);<EOL>            }<EOL>        }<EOL>        catch (e) {<EOL>            fixedFileText = \"<STR_LIT>\";<EOL>","gt":"newFileText = \"<STR_LIT>\";"}
{"input":"<s> export function profanity_filter(str) {<EOL>    for (let lang in filters) {<EOL>","gt":"str = str.replace(profanity_regex[lang], \"<STR_LIT>\", str);"}
{"input":"<s> export function is_rank_bounded(user_or_rank: any): boolean {<EOL>    let rank =","gt":"overall_rank(user_or_rank);"}
{"input":"<s> export function buildExtensionMetadata(pkg: PackageMetadata): Array<PackageMetadata> {<EOL>    return pkg.libExtensions.map(ext => {<EOL>        normalizeLibExtension(ext);<EOL>        const meta: PackageMetadata = deepcopy(pkg);<EOL>        meta.parent = pkg;<EOL>","gt":"meta.extension = ext;"}
{"input":"<s> export function buildExtensionMetadata(pkg: PackageMetadata): Array<PackageMetadata> {<EOL>    return pkg.libExtensions.map(ext => {<EOL>        normalizeLibExtension(ext);<EOL>        const meta: PackageMetadata = deepcopy(pkg);<EOL>        meta.parent = pkg;<EOL>        meta.extension = ext;<EOL>        meta.name = meta.name + titleCamelCase(ext.name);<EOL>","gt":"meta.umd = meta.umd + '<STR_LIT>' + ext.name;"}
{"input":"<s> export function buildExtensionMetadata(pkg: PackageMetadata): Array<PackageMetadata> {<EOL>    return pkg.libExtensions.map(ext => {<EOL>        normalizeLibExtension(ext);<EOL>        const meta: PackageMetadata = deepcopy(pkg);<EOL>        meta.parent = pkg;<EOL>        meta.extension = ext;<EOL>        meta.name = meta.name + titleCamelCase(ext.name);<EOL>        meta.umd = meta.umd + '<STR_LIT>' + ext.name;<EOL>        meta.dirName = ext.name;<EOL>        meta.dir = meta.dir + '<STR_LIT>' + ext.dir;<EOL>        meta.moduleName = meta.moduleName + '<STR_LIT>' + voca.camelCase(ext.name);<EOL>        meta.externals.push(meta.parent.dir);<EOL>        meta.externalsWebpack.","gt":"push(getExternalsWebpack(meta.dir)[<NUM_LIT>]);"}
{"input":"<s> function f11<T extends () => void>(x: T) {<EOL>    var r7 = true ? () => { } :","gt":"x;"}
{"input":"<s> function isRule(ruleName: string): boolean {<EOL>    let result = cache.get(ruleName);<EOL>","gt":"if (result === undefined) {"}
{"input":"<s> function* g3() {<EOL>    yield;<EOL>    yield","gt":"new Foo;"}
{"input":"<s> export function stat(path: string): TPromise<fs.Stats> {<EOL>","gt":"return nfcall(fs.stat, path);"}
{"input":"<s> function assignNonLibPaths(oldPaths: MapLike<string[]>, paths: MapLike<string[]>): void {<EOL>    const automatedPaths = tsConfigPaths();<EOL>    Object.keys(","gt":"oldPaths)"}
{"input":"<s> export function dispatchTouchEvent(target: EventTarget, eventType = \"<STR_LIT>\", clientX = <NUM_LIT>, clientY = <NUM_LIT>) {<EOL>    target.dispatchEvent(createTouchEvent(eventType, clientX,","gt":"clientY));"}
{"input":"<s> export function acceptTournamentInvite(id) {<EOL>    return post(","gt":"\"<STR_LIT>\", { \"<STR_LIT>\": id }).catch(errorAlerter);"}
{"input":"<s> export function getFormatter(formatterName: string): Lint.FormatterConstructor {<EOL>    const formattersDirectory = path.join(","gt":"__dirname, \"<STR_LIT>\");"}
{"input":"<s> export function lookup(player_id: number): PlayerCacheEntry {<EOL>    if (player_id in cache) {<EOL>        return","gt":"cache[player_id];"}
{"input":"<s> function ping() {<EOL>    if (termination_socket.connected) {<EOL>        termination_socket.send(\"<STR_LIT>\", {<EOL>            client: Date.","gt":"now(),"}
{"input":"<s> function* flattenData(data: ReadonlyMap<string, TypingsVersions>): Iterable<TypingsData> {<EOL>    for (const versions","gt":"of data.values()) {"}
{"input":"<s> export function rmdir(path: string): Promise {<EOL>    return nfcall(fs.rmdir,","gt":"path);"}
{"input":"<s> function other<T, U>(t: T, u: U) {<EOL>    var r10 = foo2(<NUM_LIT>, (x: T) => '<STR_LIT>'); <EOL>    var r10 =","gt":"foo2(<NUM_LIT>, (x) => '<STR_LIT>');"}
{"input":"<s> export function bomLength(encoding: string): number {<EOL>    switch (encoding) {<EOL>        case UTF8:<EOL>","gt":"return <NUM_LIT>;"}
{"input":"<s> export function createKeyEventHandler(actions: IKeyEventMap, preventDefault = false) {<EOL>    return (e: React.KeyboardEvent<HTMLElement>) => {<EOL>        for (const k of Object.keys(actions)) {<EOL>            const key = Number(k);<EOL>            if (","gt":"e.which === key) {"}
{"input":"<s> function isSubPathSplit(map: ReadonlyArray<SubPathState>, spsIdx: number) {<EOL>","gt":"return !!findSubPathState(map, spsIdx).getSplitSubPaths().length;"}
{"input":"<s> /**<EOL> * Colorize `text` using language `languageId`.<EOL> */<EOL>export function colorize(text: string, languageId: string, options: IColorizerOptions): TPromise<string> {<EOL>    startup.","gt":"initStaticServicesIfNecessary();"}
{"input":"<s> function positionEqual(position: IPosition, lineNumber: number, column: number) {<EOL>    assert.deepEqual({<EOL>        lineNumber: position.lineNumber,<EOL>        column: position.","gt":"column"}
{"input":"<s> export function existsWithResult<T>(path: string, successResult: T): TPromise<T> {<EOL>    return exists(path).then((exists) => {<EOL>        return","gt":"exists ? successResult : null;"}
{"input":"<s> function f11() {<EOL>    return cond ?","gt":"<NUM_LIT> : \"<STR_LIT>\";"}
{"input":"<s> export function toSelection(selection: ISelection): types.Selection {<EOL>    let { selectionStartLineNumber, selectionStartColumn, positionLineNumber, positionColumn } = selection;<EOL>    let start = new types.Position(selectionStartLineNumber - <NUM_LIT>, selectionStartColumn -","gt":"<NUM_LIT>);"}
{"input":"<s> export function fromDiagnosticSeverity(value: number): Severity {<EOL>    switch (value) {<EOL>        case types.DiagnosticSeverity.Error:<EOL>            return Severity.Error;<EOL>","gt":"case types.DiagnosticSeverity.Warning:"}
{"input":"<s> export function fromDiagnosticSeverity(value: number): Severity {<EOL>    switch (value) {<EOL>        case types.DiagnosticSeverity.Error:<EOL>            return Severity.Error;<EOL>        case types.DiagnosticSeverity.Warning:<EOL>            return Severity.Warning;<EOL>        case types.DiagnosticSeverity.Information:<EOL>            return Severity.Info;<EOL>        case types.DiagnosticSeverity.Hint:<EOL>","gt":"return Severity.Ignore;"}
{"input":"<s> export function removeAll(): void {<EOL>    let keys = [];<EOL>    for (let key in store) {<EOL>        keys.push(key);<EOL>    }<EOL>    for (let key of keys) {<EOL>        try {<EOL>            remove(key);<EOL>        }<EOL>        catch (e) {<EOL>            console.","gt":"error(e);"}
{"input":"<s> export function hide(...elements: HTMLElement[]): void {<EOL>    for (let element","gt":"of elements) {"}
{"input":"<s> export function removeTabIndexAndUpdateFocus(node: HTMLElement): void {<EOL>    if (!node || !node.hasAttribute('<STR_LIT>')) {<EOL>        return;<EOL>    }<EOL>    <EOL>    <EOL>    <EOL>    <EOL>    if (document.activeElement === node) {<EOL>        let parentFocusable = findParentWithAttribute(node.parentElement, '<STR_LIT>');<EOL>        if (parentFocusable) {<EOL>","gt":"parentFocusable.focus();"}
{"input":"<s> export function are_in_browser(): boolean {<EOL>    return process.","gt":"platform === '<STR_LIT>';"}
{"input":"<s> /**<EOL> * Returns the last element of an array.<EOL> * @param array The array.<EOL> * @param n Which element from the end (default ist zero).<EOL> */<EOL>export function tail<T>(array: T[], n: number = <NUM_LIT>): T {<EOL>    return","gt":"array[array.length - (<NUM_LIT> + n)];"}
{"input":"<s> /**<EOL> * Have a JavaClassLoaderObject and need its ClassLoader object? Use this method!<EOL> * @todo Install on Java ClassLoader objects.<EOL> */<EOL>export function getLoader(thread: JVMThread, jclo: JVMTypes.java_lang_ClassLoader): ClassLoader {<EOL>    if ((jclo != null) && (jclo.$loader != null)) {<EOL>        return jclo.","gt":"$loader;"}
{"input":"<s> export function initString(cl: ClassLoader, str: string): JVMTypes.java_lang_String {<EOL>    var carr = initCarr(cl, str);<EOL>","gt":"var strCons = (<ReferenceClassData<JVMTypes.java_lang_String>>cl.getResolvedClass('<STR_LIT>')).getConstructor(null);"}
{"input":"<s> function stringRepeat(str: string, numTimes: number) {<EOL>    return new Array(numTimes + <NUM_LIT>).","gt":"join(str);"}
{"input":"<s> function assertAPISurface(traceAPI) {<EOL>    assert.strictEqual(typeof traceAPI.enhancedDatabaseReportingEnabled(), '<STR_LIT>');<EOL>    traceAPI.runInRootSpan({ name: '<STR_LIT>' }, function (root) {<EOL>        <EOL>        <EOL>","gt":"if (root) {"}
{"input":"<s> function assertAPISurface(traceAPI) {<EOL>    assert.strictEqual(typeof traceAPI.enhancedDatabaseReportingEnabled(), '<STR_LIT>');<EOL>    traceAPI.runInRootSpan({ name: '<STR_LIT>' }, function (root) {<EOL>        <EOL>        <EOL>        if (root) {<EOL>            assert.strictEqual(typeof root.addLabel, '<STR_LIT>');<EOL>            assert.strictEqual(typeof root.endSpan, '<STR_LIT>');<EOL>            assert.strictEqual(","gt":"typeof root.getTraceContext(), '<STR_LIT>');"}
{"input":"<s> function assertAPISurface(traceAPI) {<EOL>    assert.strictEqual(typeof traceAPI.enhancedDatabaseReportingEnabled(), '<STR_LIT>');<EOL>    traceAPI.runInRootSpan({ name: '<STR_LIT>' }, function (root) {<EOL>        <EOL>        <EOL>        if (root) {<EOL>            assert.strictEqual(typeof root.addLabel, '<STR_LIT>');<EOL>            assert.strictEqual(typeof root.endSpan, '<STR_LIT>');<EOL>            assert.strictEqual(typeof root.getTraceContext(), '<STR_LIT>');<EOL>        }<EOL>    });<EOL>    assert.strictEqual(typeof traceAPI.getCurrentContextId, '<STR_LIT>');<EOL>    assert.strictEqual(typeof traceAPI.getWriterProjectId, '<STR_LIT>');<EOL>    var child = traceAPI.","gt":"createChildSpan({ name: '<STR_LIT>' });"}
{"input":"<s> function assertAPISurface(traceAPI) {<EOL>    assert.strictEqual(typeof traceAPI.enhancedDatabaseReportingEnabled(), '<STR_LIT>');<EOL>    traceAPI.runInRootSpan({ name: '<STR_LIT>' }, function (root) {<EOL>        <EOL>        <EOL>        if (root) {<EOL>            assert.strictEqual(typeof root.addLabel, '<STR_LIT>');<EOL>            assert.strictEqual(typeof root.endSpan, '<STR_LIT>');<EOL>            assert.strictEqual(typeof root.getTraceContext(), '<STR_LIT>');<EOL>        }<EOL>    });<EOL>    assert.strictEqual(typeof traceAPI.getCurrentContextId, '<STR_LIT>');<EOL>    assert.strictEqual(typeof traceAPI.getWriterProjectId, '<STR_LIT>');<EOL>    var child = traceAPI.createChildSpan({ name: '<STR_LIT>' });<EOL>    <EOL>    if (child) {<EOL>        assert.strictEqual(typeof child.addLabel, '<STR_LIT>');<EOL>        assert.strictEqual(typeof child.endSpan, '<STR_LIT>');<EOL>        assert.strictEqual(typeof","gt":"child.getTraceContext(), '<STR_LIT>');"}
{"input":"<s> export function deviceCanvasScalingRatio() {<EOL>    if (!__deviceCanvasScalingRatio) {<EOL>        let canvas = $(\"<STR_LIT>\").attr(\"<STR_LIT>\", <NUM_LIT>).attr(\"<STR_LIT>\", <NUM_LIT>)[<NUM_LIT>];<EOL>        let context = (canvas as HTMLCanvasElement).getContext(\"<STR_LIT>\");<EOL>        let","gt":"devicePixelRatio = window.devicePixelRatio || <NUM_LIT>;"}
{"input":"<s> export function deviceCanvasScalingRatio() {<EOL>    if (!__deviceCanvasScalingRatio) {<EOL>        let canvas = $(\"<STR_LIT>\").attr(\"<STR_LIT>\", <NUM_LIT>).attr(\"<STR_LIT>\", <NUM_LIT>)[<NUM_LIT>];<EOL>        let context = (canvas as HTMLCanvasElement).getContext(\"<STR_LIT>\");<EOL>        let devicePixelRatio = window.devicePixelRatio || <NUM_LIT>;<EOL>        let backingStoreRatio = (context as any).webkitBackingStorePixelRatio ||<EOL>            (context as any).mozBackingStorePixelRatio ||<EOL>            (context as any).msBackingStorePixelRatio ||<EOL>            (context as any).oBackingStorePixelRatio ||<EOL>            (context as any).backingStorePixelRatio || <NUM_LIT>;<EOL>","gt":"let ratio = devicePixelRatio / backingStoreRatio;"}
{"input":"<s> function createWrapGetConnection(api) {<EOL>    return function wrapGetConnection(getConnection) {<EOL>","gt":"return function getConnection_trace(cb) {"}
{"input":"<s> function selection_attrs(map: any) {<EOL>    return (typeof map === \"<STR_LIT>\" ? attrsFunction :","gt":"attrsObject)(this, map);"}
{"input":"<s> function CreatePipeTransportString(pipeProgram: string, debuggerProgram: string): string {<EOL>    return","gt":"}\"<STR_LIT>,"}
{"input":"<s> export async function mapAsyncOrdered<T, U>(arr: ReadonlyArray<T>, mapper: (t: T) => Promise<U>): Promise<U[]> {<EOL>    const out = new Array(arr.length);<EOL>    await Promise.all(arr.map(async (em,","gt":"idx) => {"}
{"input":"<s> /**<EOL> * Returns the top N elements from the array.<EOL> *<EOL> * Faster than sorting the entire array when the array is a lot larger than N.<EOL> *<EOL> * @param array The unsorted array.<EOL> * @param compare A sort function for the elements.<EOL> * @param n The number of elements to return.<EOL> * @return The first n elemnts from array when sorted with compare.<EOL> */<EOL>export function top<T>(array: T[], compare: (a: T, b: T) => number, n: number): T[] {<EOL>    if (n === <NUM_LIT>) {<EOL>","gt":"return [];"}
{"input":"<s> function stone_center_in_square(radius, scaled) {<EOL>    return","gt":"Math.ceil(radius) + (scaled ? <NUM_LIT> : <NUM_LIT>);"}
{"input":"<s> export function delayEach<TSource>(source: AsyncIterable<TSource>, dueTime: number): AsyncIterableX<TSource> {<EOL>    return","gt":"new DelayEachAsyncIterable<TSource>(source, dueTime);"}
{"input":"<s> function walk(ctx: Lint.WalkContext<void>, checker: ts.TypeChecker): void {<EOL>    return ts.forEachChild(ctx.sourceFile, function cb(node: ts.Node): void {<EOL>        const argsAndParams = getArgsAndParameters(node, checker);<EOL>        if (argsAndParams !== undefined) {<EOL>            checkArgsAndParameters(argsAndParams);<EOL>        }<EOL>        return ts.forEachChild(node, cb);<EOL>    });<EOL>    function checkArgsAndParameters({ typeArguments,","gt":"typeParameters }: ArgsAndParams): void {"}
{"input":"<s> function walk(ctx: Lint.WalkContext<void>, checker: ts.TypeChecker): void {<EOL>    return ts.forEachChild(ctx.sourceFile, function cb(node: ts.Node): void {<EOL>        const argsAndParams = getArgsAndParameters(node, checker);<EOL>        if (argsAndParams !== undefined) {<EOL>            checkArgsAndParameters(argsAndParams);<EOL>        }<EOL>        return ts.forEachChild(node, cb);<EOL>    });<EOL>    function checkArgsAndParameters({ typeArguments, typeParameters }: ArgsAndParams): void {<EOL>        <EOL>        const i = typeArguments.length - <NUM_LIT>;<EOL>        const arg =","gt":"typeArguments[i];"}
{"input":"<s> function walk(ctx: Lint.WalkContext<void>, checker: ts.TypeChecker): void {<EOL>    return ts.forEachChild(ctx.sourceFile, function cb(node: ts.Node): void {<EOL>        const argsAndParams = getArgsAndParameters(node, checker);<EOL>        if (argsAndParams !== undefined) {<EOL>            checkArgsAndParameters(argsAndParams);<EOL>        }<EOL>        return ts.forEachChild(node, cb);<EOL>    });<EOL>    function checkArgsAndParameters({ typeArguments, typeParameters }: ArgsAndParams): void {<EOL>        <EOL>        const i = typeArguments.length - <NUM_LIT>;<EOL>        const arg = typeArguments[i];<EOL>        const param = typeParameters[i];<EOL>        <EOL>        if (param.default !== undefined &&","gt":"param.default.getText() === arg.getText()) {"}
{"input":"<s> function walk(ctx: Lint.WalkContext<void>, checker: ts.TypeChecker): void {<EOL>    return ts.forEachChild(ctx.sourceFile, function cb(node: ts.Node): void {<EOL>        const argsAndParams = getArgsAndParameters(node, checker);<EOL>        if (argsAndParams !== undefined) {<EOL>            checkArgsAndParameters(argsAndParams);<EOL>        }<EOL>        return ts.forEachChild(node, cb);<EOL>    });<EOL>    function checkArgsAndParameters({ typeArguments, typeParameters }: ArgsAndParams): void {<EOL>        <EOL>        const i = typeArguments.length - <NUM_LIT>;<EOL>        const arg = typeArguments[i];<EOL>        const param = typeParameters[i];<EOL>        <EOL>        if (param.default !== undefined && param.default.getText() === arg.getText()) {<EOL>            ctx.addFailureAtNode(arg, Rule.FAILURE_STRING, createFix());<EOL>        }<EOL>        function createFix(): Lint.Fix {<EOL>            if (i === <NUM_LIT>) {<EOL>","gt":"return Lint.Replacement.deleteFromTo(typeArguments.pos - <NUM_LIT>, typeArguments.end + <NUM_LIT>);"}
{"input":"<s> function getPath(arg1: uri | string | IWorkspaceProvider): string {<EOL>    if (!arg1) {<EOL>        return null;<EOL>    }<EOL>    if (typeof arg1 ===","gt":"'<STR_LIT>') {"}
{"input":"<s> function getPath(arg1: uri | string | IWorkspaceProvider): string {<EOL>    if (!arg1) {<EOL>        return null;<EOL>    }<EOL>    if (typeof arg1 === '<STR_LIT>') {<EOL>        return arg1;<EOL>    }<EOL>    if (types.isFunction((<IWorkspaceProvider>arg1).getWorkspace)) {<EOL>        let ws = (<IWorkspaceProvider>arg1).getWorkspace();<EOL>        return ws ? ws.","gt":"resource.fsPath : void <NUM_LIT>;"}
{"input":"<s> function stylesObject(selection: any, map: any, priority: any) {<EOL>","gt":"for (const name in map)"}
{"input":"<s> export function encodingExists(encoding: string): boolean {<EOL>    return iconv.encodingExists(","gt":"toNodeEncoding(encoding));"}
{"input":"<s> export function clearTraceData(): void {<EOL>","gt":"traces.clear();"}
{"input":"<s> /**<EOL> * Concatenates the input sequences.<EOL> * @param {Iterable<Iterable<TSource>>} source Source sequences.<EOL> * @return {Iterable<TSource>} Sequence with the elements of the source sequences concatenated.<EOL> */<EOL>export function concatAll<TSource>(source: Iterable<Iterable<TSource>>): IterableX<TSource> {<EOL>    return","gt":"new ConcatIterable<TSource>(source);"}
{"input":"<s> function wrapSendCommand(redis, api) {<EOL>    shimmer.wrap(redis.RedisClient.prototype, '<STR_LIT>',","gt":"createSendCommandWrap(api));"}
{"input":"<s> <EOL>export function debug_vars(arr: any[]): string[] {<EOL>","gt":"return arr.map<string>(debug_var);"}
{"input":"<s> export function encodeStream(encoding: string, options?: {<EOL>    addBOM?: boolean;<EOL>}): NodeJS.ReadWriteStream {<EOL>    return iconv.","gt":"encodeStream(toNodeEncoding(encoding), options);"}
{"input":"<s> export function onDidChangeAccessibilitySupport(callback: () => void): IDisposable {<EOL>","gt":"return WindowManager.INSTANCE.onDidChangeAccessibilitySupport(callback);"}
{"input":"<s> export function emptyScheduled(scheduler: IScheduler) {<EOL>    return new Observable<never>(subscriber =>","gt":"scheduler.schedule(() => subscriber.complete()));"}
{"input":"<s> function assertClassInitializedOrResolved(thread: JVMThread, cl: ClassLoader, type: string, initialized: boolean): ClassData {<EOL>    var cls: ClassData = null;<EOL>    <EOL>    while (cls === null) {<EOL>        cls = initialized ? cl.getInitializedClass(thread, type) : cl.getResolvedClass(type);<EOL>        if (cl.getLoaderObject() !== null) {<EOL>            if (cl.","gt":"getLoaderObject()['<STR_LIT>'] === null) {"}
{"input":"<s> function assertClassInitializedOrResolved(thread: JVMThread, cl: ClassLoader, type: string, initialized: boolean): ClassData {<EOL>    var cls: ClassData = null;<EOL>    <EOL>    while (cls === null) {<EOL>        cls = initialized ? cl.getInitializedClass(thread, type) : cl.getResolvedClass(type);<EOL>        if (cl.getLoaderObject() !== null) {<EOL>            if (cl.getLoaderObject()['<STR_LIT>'] === null) {<EOL>                cl = thread.getBsCl();<EOL>            }<EOL>            else {<EOL>                cl =","gt":"cl.getLoaderObject()['<STR_LIT>'].$loader;"}
{"input":"<s> function dispatchNext(subscriber: DebounceTimeSubscriber<any>) {<EOL>","gt":"subscriber.debouncedNext();"}
{"input":"<s> function patchHttp2(h2: NodeJS.Module, api: TraceAgent): void {<EOL>    shimmer.wrap(h2, '<STR_LIT>', (connect: typeof http2.connect): typeof http2.connect => function (this: NodeJS.Module, authority: string | URL) {<EOL>        const session:","gt":"http2.ClientHttp2Session = connect.apply(this, arguments);"}
{"input":"<s> export function safeBtoa(str: string): string {<EOL>    return btoa(","gt":"encodeURIComponent(str));"}
{"input":"<s> export function isIE() {<EOL>","gt":"const userAgent = window.navigator.userAgent;"}
{"input":"<s> function isInputElement(e: HTMLElement): boolean {<EOL>    return e.tagName === '<STR_LIT>' ||","gt":"e.tagName === '<STR_LIT>';"}
{"input":"<s> export function renderLine(context: CanvasRenderingContext2D, d3Line: d3.Line<any>, data: any[], style: IStrokeStyle) {<EOL>    context.save();<EOL>    context.beginPath();<EOL>    d3Line.context(","gt":"context);"}
{"input":"<s> <EOL>function f4() {<EOL>    let","gt":"a!;"}
{"input":"<s> <EOL>/**<EOL> * @returns A filter which combines the provided set<EOL> * of filters with an or. The *first* filters that<EOL> * matches defined the return value of the returned<EOL> * filter.<EOL> */<EOL>export function or(...filter: IFilter[]): IFilter {<EOL>    return function (word: string, wordToMatchAgainst: string): IMatch[] {<EOL>        for (let i = <NUM_LIT>, len = filter.length; i < len; i++) {<EOL>            let match = filter[","gt":"i](word, wordToMatchAgainst);"}
{"input":"<s> /***<EOL>This is modified from part of jsdifflib v1.0. <http://snowtide.com/jsdifflib><EOL><EOL>Copyright (c) 2007, Snowtide Informatics Systems, Inc.<EOL>All rights reserved.<EOL><EOL>Redistribution and use in source and binary forms, with or without modification,<EOL>are permitted provided that the following conditions are met:<EOL><EOL>    * Redistributions of source code must retain the above copyright notice, this<EOL>        list of conditions and the following disclaimer.<EOL>    * Redistributions in binary form must reproduce the above copyright notice,<EOL>        this list of conditions and the following disclaimer in the documentation<EOL>        and/or other materials provided with the distribution.<EOL>    * Neither the name of the Snowtide Informatics Systems nor the names of its<EOL>        contributors may be used to endorse or promote products derived from this<EOL>        software without specific prior written permission.<EOL><EOL>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY<EOL>EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES<EOL>OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT<EOL>SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,<EOL>INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED<EOL>TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR<EOL>BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN<EOL>CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN<EOL>ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH<EOL>DAMAGE.<EOL>***/<EOL><EOL>export function text_diff(a_lines: string[], b_lines: string[], context: number): string[] {<EOL>    return (new SequenceMatcher(a_lines,","gt":"b_lines)).text_diff(context);"}
{"input":"<s> function link(href, title, text): string {<EOL>    return","gt":"text}</a>`;"}
{"input":"<s> function _encode(ch: string): string {<EOL>    return '<STR_LIT>' + ch.charCodeAt(<NUM_LIT>).","gt":"toString(<NUM_LIT>).toUpperCase();"}
{"input":"<s> /**<EOL> * Make sure that we're dealing with a PNG file. Throws an error<EOL> * if the file does not start with the standard PNG header.<EOL> *<EOL> * @export<EOL> * @param {ArrayBufferWalker} walker<EOL> */<EOL>export function checkPreheader(walker: ArrayBufferWalker) {<EOL>    let value = walker.readString(PRE_HEADER.length);<EOL>    if (","gt":"value !== PRE_HEADER) {"}
{"input":"<s> /**<EOL> * PNG files can have palettes of varying sizes, up to 256 colors. If we want<EOL> * to try to save some space, we can use a smaller palette.<EOL> *<EOL> * @export<EOL> * @param {number} numColors<EOL> * @returns<EOL> */<EOL>export function calculatePaletteLength(numColors: number) {<EOL>    return (numColors * <NUM_LIT> + <EOL>        <NUM_LIT> + <EOL>","gt":"<NUM_LIT> +"}
{"input":"<s> function isValidHeaderAscii(val: number): boolean {<EOL>    return isAllowedControlChars(val) || (","gt":"val >= <NUM_LIT> && val <= <NUM_LIT>);"}
{"input":"<s> /**<EOL> * Quick function to convert a string to Base64, that works in both<EOL> * Node and the browser<EOL> *<EOL> * @export<EOL> * @param {string} str<EOL> * @returns<EOL> */<EOL>export function toBase64(str: string) {<EOL>    if (typeof btoa === \"<STR_LIT>\") {<EOL>        return new Buffer(str, '<STR_LIT>').toString(","gt":"'<STR_LIT>');"}
{"input":"<s> function dispatch(this: Action<TimerState>, state: TimerState) {<EOL>    const { index, period, subscriber } = state;<EOL>    subscriber.next(index);<EOL>    if (subscriber.closed) {<EOL>","gt":"return;"}
{"input":"<s> export function urlOfBlob(blobName: string): string {<EOL>    return","gt":"azureContainer}/${blobName}`;"}
{"input":"<s> export function printFileDescriptorTSD(fileDescriptor: FileDescriptorProto, exportMap: ExportMap) {<EOL>    const fileName = fileDescriptor.getName();<EOL>    const packageName = fileDescriptor.getPackage();<EOL>    const printer = new Printer(<NUM_LIT>);<EOL>    printer.printLn(`<STR_LIT>`);<EOL>    printer.printLn(`<STR_LIT>`);<EOL>    const upToRoot = getPathToRoot(","gt":"fileName);"}
{"input":"<s> export function printFileDescriptorTSD(fileDescriptor: FileDescriptorProto, exportMap: ExportMap) {<EOL>    const fileName = fileDescriptor.getName();<EOL>    const packageName = fileDescriptor.getPackage();<EOL>    const printer = new Printer(<NUM_LIT>);<EOL>    printer.printLn(`<STR_LIT>`);<EOL>    printer.printLn(`<STR_LIT>`);<EOL>    const upToRoot = getPathToRoot(fileName);<EOL>    printer.printEmptyLn();<EOL>    printer.printLn(`<STR_LIT>`);<EOL>","gt":"fileDescriptor.getDependencyList().forEach((dependency: string) => {"}
{"input":"<s> export function printFileDescriptorTSD(fileDescriptor: FileDescriptorProto, exportMap: ExportMap) {<EOL>    const fileName = fileDescriptor.getName();<EOL>    const packageName = fileDescriptor.getPackage();<EOL>    const printer = new Printer(<NUM_LIT>);<EOL>    printer.printLn(`<STR_LIT>`);<EOL>    printer.printLn(`<STR_LIT>`);<EOL>    const upToRoot = getPathToRoot(fileName);<EOL>    printer.printEmptyLn();<EOL>    printer.printLn(`<STR_LIT>`);<EOL>    fileDescriptor.getDependencyList().forEach((dependency: string) => {<EOL>        const pseudoNamespace = filePathToPseudoNamespace(dependency);<EOL>        if (dependency in WellKnownTypesMap) {<EOL>            printer.","gt":"printLn(`<STR_LIT>`);"}
{"input":"<s> export function printFileDescriptorTSD(fileDescriptor: FileDescriptorProto, exportMap: ExportMap) {<EOL>    const fileName = fileDescriptor.getName();<EOL>    const packageName = fileDescriptor.getPackage();<EOL>    const printer = new Printer(<NUM_LIT>);<EOL>    printer.printLn(`<STR_LIT>`);<EOL>    printer.printLn(`<STR_LIT>`);<EOL>    const upToRoot = getPathToRoot(fileName);<EOL>    printer.printEmptyLn();<EOL>    printer.printLn(`<STR_LIT>`);<EOL>    fileDescriptor.getDependencyList().forEach((dependency: string) => {<EOL>        const pseudoNamespace = filePathToPseudoNamespace(dependency);<EOL>        if (dependency in WellKnownTypesMap) {<EOL>            printer.printLn(`<STR_LIT>`);<EOL>        }<EOL>        else {<EOL>            const filePath = filePathFromProtoWithoutExtension(dependency);<EOL>            printer.","gt":"printLn(`<STR_LIT>`);"}
{"input":"<s> export function printFileDescriptorTSD(fileDescriptor: FileDescriptorProto, exportMap: ExportMap) {<EOL>    const fileName = fileDescriptor.getName();<EOL>    const packageName = fileDescriptor.getPackage();<EOL>    const printer = new Printer(<NUM_LIT>);<EOL>    printer.printLn(`<STR_LIT>`);<EOL>    printer.printLn(`<STR_LIT>`);<EOL>    const upToRoot = getPathToRoot(fileName);<EOL>    printer.printEmptyLn();<EOL>    printer.printLn(`<STR_LIT>`);<EOL>    fileDescriptor.getDependencyList().forEach((dependency: string) => {<EOL>        const pseudoNamespace = filePathToPseudoNamespace(dependency);<EOL>        if (dependency in WellKnownTypesMap) {<EOL>            printer.printLn(`<STR_LIT>`);<EOL>        }<EOL>        else {<EOL>            const filePath = filePathFromProtoWithoutExtension(dependency);<EOL>            printer.printLn(`<STR_LIT>`);<EOL>        }<EOL>    });<EOL>    fileDescriptor.getMessageTypeList().forEach(enumType => {<EOL>        printer.print(printMessage(fileName, exportMap, enumType, <NUM_LIT>, fileDescriptor));<EOL>    });<EOL>    fileDescriptor.getExtensionList().","gt":"forEach(extension => {"}
{"input":"<s> function msg(s: string): void {<EOL>    serial.writeString(","gt":"s);"}
{"input":"<s> /** Returns the number of decimal places in the given number. */<EOL>export function countDecimalPlaces(num: number) {<EOL>    if (typeof num !== \"<STR_LIT>\" || Math.floor(num) === num) {<EOL>        return","gt":"<NUM_LIT>;"}
{"input":"<s> function f74<T, U extends T, K extends keyof T>(x: {<EOL>    [P in K]: T[P];<EOL>}, y: {<EOL>    [P in keyof U]: U[P];<EOL>}) {<EOL>    x =","gt":"y;"}
{"input":"<s> <EOL>export default function xhrRequest(options: TransportOptions): Transport {<EOL>    options.debug && debug(","gt":"\"<STR_LIT>\", options);"}
{"input":"<s> export function printEnum(enumDescriptor: EnumDescriptorProto, indentLevel: number) {<EOL>    const printer = new Printer(indentLevel);<EOL>    printer.printEmptyLn();<EOL>    printer.","gt":"printLn(`<STR_LIT>`);"}
{"input":"<s> /**<EOL> * Debounces the supplied callback and returns a function with the same<EOL> * arguments.<EOL> *<EOL> * The callback is schedule for invocation every time the returned function is<EOL> * invoked. If the returned function is called within the debounce time, the<EOL> * previously scheduled call is canceled and the callback is schedule again.<EOL> *<EOL> * If debounced, the callback will be called with the most recent arguments.<EOL> *<EOL> * @param {number} msec - the debounce time in milliseconds<EOL> * @param {T} callback - the callback invoked after the debounce time<EOL> * @param {any} context  - the `this` argument used to invoke the callback<EOL> */<EOL>export function debounce<T extends Function>(msec: number, callback: T, context?: any): T {<EOL>    let timeoutToken: number = null;<EOL>    let args: any[] = [];<EOL>    const deferredCallback = function () {<EOL>        callback.apply(","gt":"context, args);"}
{"input":"<s> /**<EOL> * Debounces the supplied callback and returns a function with the same<EOL> * arguments.<EOL> *<EOL> * The callback is schedule for invocation every time the returned function is<EOL> * invoked. If the returned function is called within the debounce time, the<EOL> * previously scheduled call is canceled and the callback is schedule again.<EOL> *<EOL> * If debounced, the callback will be called with the most recent arguments.<EOL> *<EOL> * @param {number} msec - the debounce time in milliseconds<EOL> * @param {T} callback - the callback invoked after the debounce time<EOL> * @param {any} context  - the `this` argument used to invoke the callback<EOL> */<EOL>export function debounce<T extends Function>(msec: number, callback: T, context?: any): T {<EOL>    let timeoutToken: number = null;<EOL>    let args: any[] = [];<EOL>    const deferredCallback = function () {<EOL>        callback.apply(context, args);<EOL>    };<EOL>    <EOL>    return function () {<EOL>        args = Array.prototype.slice.call(arguments);<EOL>        clearTimeout(","gt":"timeoutToken);"}
{"input":"<s> export function isNodeArray(nodeOrArray: ts.Node | ts.NodeArray<ts.Node>): nodeOrArray is ts.NodeArray<ts.Node> {<EOL>    return Array.isArray(","gt":"nodeOrArray);"}
{"input":"<s> function testFloat() {<EOL>    if (!hasFloat)<EOL>        return;<EOL>","gt":"let v = <NUM_LIT> / <NUM_LIT>;"}
{"input":"<s> export function copy(source: string, target: string, callback: (error: Error) => void, copiedSources?: {<EOL>    [path: string]: boolean;<EOL>}): void {<EOL>    if (!copiedSources) {<EOL>        copiedSources = Object.create(null);<EOL>    }<EOL>    fs.stat(source, (error, stat) => {<EOL>","gt":"if (error) {"}
{"input":"<s> export function copy(source: string, target: string, callback: (error: Error) => void, copiedSources?: {<EOL>    [path: string]: boolean;<EOL>}): void {<EOL>    if (!copiedSources) {<EOL>        copiedSources = Object.create(null);<EOL>    }<EOL>    fs.stat(source, (error, stat) => {<EOL>        if (error) {<EOL>            return callback(error);<EOL>        }<EOL>","gt":"if (!stat.isDirectory()) {"}
{"input":"<s> export function copy(source: string, target: string, callback: (error: Error) => void, copiedSources?: {<EOL>    [path: string]: boolean;<EOL>}): void {<EOL>    if (!copiedSources) {<EOL>        copiedSources = Object.create(null);<EOL>    }<EOL>    fs.stat(source, (error, stat) => {<EOL>        if (error) {<EOL>            return callback(error);<EOL>        }<EOL>        if (!stat.isDirectory()) {<EOL>            return pipeFs(source, target, stat.mode & <NUM_LIT>, callback);<EOL>        }<EOL>        if (copiedSources[source]) {<EOL>            return callback(null); <EOL>        }<EOL>        copiedSources[source] = true; <EOL>        const proceed = function () {<EOL>            readdir(source, (err, files) => {<EOL>                loop(files, (file: string, clb: (error: Error, result: string[]) => void) => {<EOL>                    copy(paths.join(source, file), paths.join(target,","gt":"file), (error: Error) => clb(error, void <NUM_LIT>), copiedSources);"}
{"input":"<s> function foo1(...stuff: any[]): any {<EOL>","gt":"return undefined;"}
{"input":"<s> export default function reducer(state: AppState = initialState, action: any): AppState {<EOL>    switch (action.type) {<EOL>","gt":"default:"}
{"input":"<s> function reindexsearch(args: string[]) {<EOL>    if (args.length == <NUM_LIT>) {<EOL>        [\"<STR_LIT>\", \"<STR_LIT>\",","gt":"\"<STR_LIT>\", \"<STR_LIT>\", \"<STR_LIT>\", \"<STR_LIT>\", \"<STR_LIT>\"].forEach(k => reindexone(k));"}
{"input":"<s> export function readdir(path: string, callback: (error: Error, files: string[]) => void): void {<EOL>    <EOL>    <EOL>    if (platform.isMacintosh) {<EOL>        return","gt":"fs.readdir(path, (error, children) => {"}
{"input":"<s> export function hideDialog() {<EOL>    $(","gt":"'<STR_LIT>').modal(\"<STR_LIT>\");"}
{"input":"<s> export function buffer<TSource>(source: AsyncIterable<TSource>, count: number, skip?: number): AsyncIterableX<TSource[]> {<EOL>    if (skip == null) {<EOL>        skip =","gt":"count;"}
{"input":"<s> function foo<T>(t: T) {<EOL>    return","gt":"t;"}
{"input":"<s> /**<EOL> * @ignore<EOL> */<EOL>export function reduceProto<T, R = T>(this: IterableX<T>, accumulator: (previousValue: R, currentValue: T, currentIndex: number) => R, ...seed: R[]): R {<EOL>    return reduce(this, accumulator, ...","gt":"seed);"}
{"input":"<s> function litepost(args: string[]) {<EOL>    var k = tdliteKey();<EOL>    var dat = args[<NUM_LIT>] ? eval(\"<STR_LIT>\" +","gt":"args[<NUM_LIT>] + \"<STR_LIT>\") : {};"}
{"input":"<s> /**<EOL> * @ignore<EOL> */<EOL>export function mergeAllProto<T>(this: AsyncIterableX<AsyncIterable<T>>): AsyncIterableX<T> {<EOL>","gt":"return mergeAll(this);"}
{"input":"<s> /**<EOL> * Branch out the source Observable values as a nested Observable using a<EOL> * factory function of closing Observables to determine when to start a new<EOL> * window.<EOL> *<EOL> * <span class=\"informal\">It's like {@link bufferWhen}, but emits a nested<EOL> * Observable instead of an array.</span><EOL> *<EOL> * <img src=\"./img/windowWhen.png\" width=\"100%\"><EOL> *<EOL> * Returns an Observable that emits windows of items it collects from the source<EOL> * Observable. The output Observable emits connected, non-overlapping windows.<EOL> * It emits the current window and opens a new one whenever the Observable<EOL> * produced by the specified `closingSelector` function emits an item. The first<EOL> * window is opened immediately when subscribing to the output Observable.<EOL> *<EOL> * @example <caption>Emit only the first two clicks events in every window of [1-5] random seconds</caption><EOL> * var clicks = Rx.Observable.fromEvent(document, 'click');<EOL> * var result = clicks<EOL> *   .windowWhen(() => Rx.Observable.interval(1000 + Math.random() * 4000))<EOL> *   .map(win => win.take(2)) // each window has at most 2 emissions<EOL> *   .mergeAll(); // flatten the Observable-of-Observables<EOL> * result.subscribe(x => console.log(x));<EOL> *<EOL> * @see {@link window}<EOL> * @see {@link windowCount}<EOL> * @see {@link windowTime}<EOL> * @see {@link windowToggle}<EOL> * @see {@link bufferWhen}<EOL> *<EOL> * @param {function(): Observable} closingSelector A function that takes no<EOL> * arguments and returns an Observable that signals (on either `next` or<EOL> * `complete`) when to close the previous window and start a new one.<EOL> * @return {Observable<Observable<T>>} An observable of windows, which in turn<EOL> * are Observables.<EOL> * @method windowWhen<EOL> * @owner Observable<EOL> */<EOL>export function windowWhen<T>(this: Observable<T>, closingSelector: () => Observable<any>): Observable<Observable<T>> {<EOL>    return","gt":"higherOrder(closingSelector)(this) as Observable<Observable<T>>;"}
{"input":"<s> /**<EOL> * Get the boolean literal in jsx attribute initializer with following format:<EOL> * @example<EOL> * <div attribute={ true } /><EOL> * @example<EOL> * <div attribute='true' /><EOL> * @example<EOL> * <div attribute={ 'true' } /><EOL> */<EOL>export function getBooleanLiteral(node: ts.JsxAttribute): boolean {<EOL>    if (!isJsxAttribute(node)) {<EOL>        throw new Error('<STR_LIT>');<EOL>    }<EOL>    const initializer: ts.Expression = node == null ? null : node.initializer;<EOL>    const getBooleanFromString: (value: string) => boolean = (value: string) => {<EOL>        if (value.toLowerCase() === '<STR_LIT>') {<EOL>            return","gt":"true;"}
{"input":"<s> /**<EOL> * Get the boolean literal in jsx attribute initializer with following format:<EOL> * @example<EOL> * <div attribute={ true } /><EOL> * @example<EOL> * <div attribute='true' /><EOL> * @example<EOL> * <div attribute={ 'true' } /><EOL> */<EOL>export function getBooleanLiteral(node: ts.JsxAttribute): boolean {<EOL>    if (!isJsxAttribute(node)) {<EOL>        throw new Error('<STR_LIT>');<EOL>    }<EOL>    const initializer: ts.Expression = node == null ? null : node.initializer;<EOL>    const getBooleanFromString: (value: string) => boolean = (value: string) => {<EOL>        if (value.toLowerCase() === '<STR_LIT>') {<EOL>            return true;<EOL>        }<EOL>        else if (value.toLowerCase() === '<STR_LIT>') {<EOL>            return false;<EOL>        }<EOL>","gt":"else {"}
{"input":"<s> /**<EOL> * Get the boolean literal in jsx attribute initializer with following format:<EOL> * @example<EOL> * <div attribute={ true } /><EOL> * @example<EOL> * <div attribute='true' /><EOL> * @example<EOL> * <div attribute={ 'true' } /><EOL> */<EOL>export function getBooleanLiteral(node: ts.JsxAttribute): boolean {<EOL>    if (!isJsxAttribute(node)) {<EOL>        throw new Error('<STR_LIT>');<EOL>    }<EOL>    const initializer: ts.Expression = node == null ? null : node.initializer;<EOL>    const getBooleanFromString: (value: string) => boolean = (value: string) => {<EOL>        if (value.toLowerCase() === '<STR_LIT>') {<EOL>            return true;<EOL>        }<EOL>        else if (value.toLowerCase() === '<STR_LIT>') {<EOL>            return false;<EOL>        }<EOL>        else {<EOL>            return undefined;<EOL>        }<EOL>    };<EOL>    if (isStringLiteral(initializer)) {<EOL>        return getBooleanFromString(initializer.text);<EOL>    }<EOL>    else if (isJsxExpression(initializer)) {<EOL>","gt":"const expression: ts.Expression = initializer.expression;"}
{"input":"<s> /**<EOL> * Get the boolean literal in jsx attribute initializer with following format:<EOL> * @example<EOL> * <div attribute={ true } /><EOL> * @example<EOL> * <div attribute='true' /><EOL> * @example<EOL> * <div attribute={ 'true' } /><EOL> */<EOL>export function getBooleanLiteral(node: ts.JsxAttribute): boolean {<EOL>    if (!isJsxAttribute(node)) {<EOL>        throw new Error('<STR_LIT>');<EOL>    }<EOL>    const initializer: ts.Expression = node == null ? null : node.initializer;<EOL>    const getBooleanFromString: (value: string) => boolean = (value: string) => {<EOL>        if (value.toLowerCase() === '<STR_LIT>') {<EOL>            return true;<EOL>        }<EOL>        else if (value.toLowerCase() === '<STR_LIT>') {<EOL>            return false;<EOL>        }<EOL>        else {<EOL>            return undefined;<EOL>        }<EOL>    };<EOL>    if (isStringLiteral(initializer)) {<EOL>        return getBooleanFromString(initializer.text);<EOL>    }<EOL>    else if (isJsxExpression(initializer)) {<EOL>        const expression: ts.Expression = initializer.expression;<EOL>        if (isStringLiteral(expression)) {<EOL>            return getBooleanFromString(expression.text);<EOL>        }<EOL>        else {<EOL>            if (isTrueKeyword(expression)) {<EOL>                return true;<EOL>            }<EOL>            else if (","gt":"isFalseKeyword(expression)) {"}
{"input":"<s> export function uploadFiles(ctx: cm.IExecutionContext, stagingFolder: string, containerId: number, containerRoot: string, filePaths: string[]) {<EOL>    _ctx = ctx;<EOL>    _ensureTracing(_ctx, '<STR_LIT>');<EOL>    _stagingFolder = stagingFolder;<EOL>    _containerId =","gt":"containerId;"}
{"input":"<s> export function uploadFiles(ctx: cm.IExecutionContext, stagingFolder: string, containerId: number, containerRoot: string, filePaths: string[]) {<EOL>    _ctx = ctx;<EOL>    _ensureTracing(_ctx, '<STR_LIT>');<EOL>    _stagingFolder = stagingFolder;<EOL>    _containerId = containerId;<EOL>    _containerRoot = containerRoot;<EOL>    _ensureTemp(ctx.workingDirectory);<EOL>    return _uploadFiles(filePaths)<EOL>        .","gt":"then(() => {"}
{"input":"<s> export function createAsyncCommand(executionContext: cm.IExecutionContext, command: cm.ITaskCommand) {<EOL>    return","gt":"new ArtifactAssociateCommand(executionContext, command);"}
{"input":"<s> function isLineBreak(ch: number): boolean {<EOL>    return ch === CharacterCodes.lineFeed || ch === CharacterCodes.carriageReturn || ch === CharacterCodes.lineSeparator || ch === CharacterCodes.","gt":"paragraphSeparator;"}
{"input":"<s> /**<EOL> * Get image size from file on local file system<EOL> */<EOL>function getImageSizeFromFile(file: string) {<EOL>    return new Promise((resolve, reject) => {<EOL>        const isDataUrl = file.match(/^data:.+?;base64,/);<EOL>        if (isDataUrl) {<EOL>            <EOL>            try {<EOL>                const data = Buffer.from(file.slice(isDataUrl[<NUM_LIT>].length), '<STR_LIT>');<EOL>                return","gt":"resolve(sizeForFileName('<STR_LIT>', sizeOf(data)));"}
{"input":"<s> export function detectBufferEncoding(buffer: Buffer, length = buffer.length): Encoding {<EOL>    if (length < <NUM_LIT>) {<EOL>        return \"<STR_LIT>\";<EOL>    }<EOL>    switch (","gt":"buffer[<NUM_LIT>]) {"}
{"input":"<s> export function detectBufferEncoding(buffer: Buffer, length = buffer.length): Encoding {<EOL>    if (length < <NUM_LIT>) {<EOL>        return \"<STR_LIT>\";<EOL>    }<EOL>    switch (buffer[<NUM_LIT>]) {<EOL>        case <NUM_LIT>:<EOL>            if (buffer[<NUM_LIT>] === <NUM_LIT> && length >= <NUM_LIT> && buffer[<NUM_LIT>] === <NUM_LIT>) {<EOL>                return","gt":"\"<STR_LIT>\";"}
{"input":"<s> export function detectBufferEncoding(buffer: Buffer, length = buffer.length): Encoding {<EOL>    if (length < <NUM_LIT>) {<EOL>        return \"<STR_LIT>\";<EOL>    }<EOL>    switch (buffer[<NUM_LIT>]) {<EOL>        case <NUM_LIT>:<EOL>            if (buffer[<NUM_LIT>] === <NUM_LIT> && length >= <NUM_LIT> && buffer[<NUM_LIT>] === <NUM_LIT>) {<EOL>                return \"<STR_LIT>\";<EOL>            }<EOL>            break;<EOL>        case <NUM_LIT>:<EOL>            if (buffer[<NUM_LIT>] ===","gt":"<NUM_LIT>) {"}
{"input":"<s> export function detectBufferEncoding(buffer: Buffer, length = buffer.length): Encoding {<EOL>    if (length < <NUM_LIT>) {<EOL>        return \"<STR_LIT>\";<EOL>    }<EOL>    switch (buffer[<NUM_LIT>]) {<EOL>        case <NUM_LIT>:<EOL>            if (buffer[<NUM_LIT>] === <NUM_LIT> && length >= <NUM_LIT> && buffer[<NUM_LIT>] === <NUM_LIT>) {<EOL>                return \"<STR_LIT>\";<EOL>            }<EOL>            break;<EOL>        case <NUM_LIT>:<EOL>            if (buffer[<NUM_LIT>] === <NUM_LIT>) {<EOL>                return \"<STR_LIT>\";<EOL>            }<EOL>            break;<EOL>        case <NUM_LIT>:<EOL>","gt":"if (buffer[<NUM_LIT>] === <NUM_LIT>) {"}
{"input":"<s> function saveGlobalAction(): void {<EOL>    let s = \"<STR_LIT>\" + \"<STR_LIT>\";<EOL>","gt":"tot = \"<STR_LIT>\";"}
{"input":"<s> function x() {<EOL>    return","gt":"<NUM_LIT>;"}
{"input":"<s> <EOL><EOL><EOL><EOL><EOL>function doWriteFileAndFlush(path: string, data: string | NodeBuffer, options: IWriteFileOptions, callback: (error?: Error) => void): void {<EOL>    if (options.encoding) {<EOL>        data = encode(data, options.encoding.charset, { addBOM: options.encoding.addBOM });<EOL>    }<EOL>    if (!canFlush) {<EOL>        return fs.writeFile(path, data, { mode: options.mode, flag: options.flag }, callback);<EOL>    }<EOL>    <EOL>    fs.open(path, options.flag, options.mode, (openError, fd) => {<EOL>        if (","gt":"openError) {"}
{"input":"<s> <EOL><EOL><EOL><EOL><EOL>function doWriteFileAndFlush(path: string, data: string | NodeBuffer, options: IWriteFileOptions, callback: (error?: Error) => void): void {<EOL>    if (options.encoding) {<EOL>        data = encode(data, options.encoding.charset, { addBOM: options.encoding.addBOM });<EOL>    }<EOL>    if (!canFlush) {<EOL>        return fs.writeFile(path, data, { mode: options.mode, flag: options.flag }, callback);<EOL>    }<EOL>    <EOL>    fs.open(path, options.flag, options.mode, (openError, fd) => {<EOL>        if (openError) {<EOL>            return callback(openError);<EOL>        }<EOL>        <EOL>        fs.writeFile(fd, data, writeError => {<EOL>            if (writeError) {<EOL>                return fs.close(fd, () => callback(","gt":"writeError));"}
{"input":"<s> <EOL><EOL><EOL><EOL><EOL>function doWriteFileAndFlush(path: string, data: string | NodeBuffer, options: IWriteFileOptions, callback: (error?: Error) => void): void {<EOL>    if (options.encoding) {<EOL>        data = encode(data, options.encoding.charset, { addBOM: options.encoding.addBOM });<EOL>    }<EOL>    if (!canFlush) {<EOL>        return fs.writeFile(path, data, { mode: options.mode, flag: options.flag }, callback);<EOL>    }<EOL>    <EOL>    fs.open(path, options.flag, options.mode, (openError, fd) => {<EOL>        if (openError) {<EOL>            return callback(openError);<EOL>        }<EOL>        <EOL>        fs.writeFile(fd, data, writeError => {<EOL>            if (writeError) {<EOL>                return fs.close(fd, () => callback(writeError)); <EOL>            }<EOL>            <EOL>            fs.fdatasync(fd, (syncError: Error) => {<EOL>                <EOL>                <EOL>                if (syncError) {<EOL>                    console.warn('<STR_LIT>',","gt":"syncError);"}
{"input":"<s> function isLineBreak(ch: number): boolean {<EOL>    return ch ===","gt":"CharacterCodes.lineFeed || ch === CharacterCodes.carriageReturn || ch === CharacterCodes.lineSeparator || ch === CharacterCodes.paragraphSeparator;"}
{"input":"<s> <EOL>function f(a, []) {<EOL>    var x, y,","gt":"z;"}
{"input":"<s> /**<EOL> * Emits only the first value (or the first value that meets some condition)<EOL> * emitted by the source Observable.<EOL> *<EOL> * <span class=\"informal\">Emits only the first value. Or emits only the first<EOL> * value that passes some test.</span><EOL> *<EOL> * <img src=\"./img/first.png\" width=\"100%\"><EOL> *<EOL> * If called with no arguments, `first` emits the first value of the source<EOL> * Observable, then completes. If called with a `predicate` function, `first`<EOL> * emits the first value of the source that matches the specified condition. It<EOL> * may also take a `resultSelector` function to produce the output value from<EOL> * the input value, and a `defaultValue` to emit in case the source completes<EOL> * before it is able to emit a valid value. Throws an error if `defaultValue`<EOL> * was not provided and a matching element is not found.<EOL> *<EOL> * @example <caption>Emit only the first click that happens on the DOM</caption><EOL> * var clicks = Rx.Observable.fromEvent(document, 'click');<EOL> * var result = clicks.first();<EOL> * result.subscribe(x => console.log(x));<EOL> *<EOL> * @example <caption>Emits the first click that happens on a DIV</caption><EOL> * var clicks = Rx.Observable.fromEvent(document, 'click');<EOL> * var result = clicks.first(ev => ev.target.tagName === 'DIV');<EOL> * result.subscribe(x => console.log(x));<EOL> *<EOL> * @see {@link filter}<EOL> * @see {@link find}<EOL> * @see {@link take}<EOL> *<EOL> * @throws {EmptyError} Delivers an EmptyError to the Observer's `error`<EOL> * callback if the Observable completes before any `next` notification was sent.<EOL> *<EOL> * @param {function(value: T, index: number, source: Observable<T>): boolean} [predicate]<EOL> * An optional function called with each item to test for condition matching.<EOL> * @param {function(value: T, index: number): R} [resultSelector] A function to<EOL> * produce the value on the output Observable based on the values<EOL> * and the indices of the source Observable. The arguments passed to this<EOL> * function are:<EOL> * - `value`: the value that was emitted on the source.<EOL> * - `index`: the \"index\" of the value from the source.<EOL> * @param {R} [defaultValue] The default value emitted in case no valid value<EOL> * was found on the source.<EOL> * @return {Observable<T|R>} An Observable of the first item that matches the<EOL> * condition.<EOL> * @method first<EOL> * @owner Observable<EOL> */<EOL>export function first<T, R>(this: Observable<T>, predicate?: (value: T, index: number, source: Observable<T>) => boolean, resultSelector?: ((value: T, index: number) => R) | void, defaultValue?: R): Observable<T | R> {<EOL>    return higherOrder(predicate, resultSelector as any,","gt":"defaultValue)(this);"}
{"input":"<s> async function uploadDirectory(container: BlobWriter, uploadedDirPath: string, dirPath: string, log: Logger, filter?: (fileName: string) => boolean): Promise<string[]> {<EOL>    let files = await readdir(dirPath);<EOL>    if (filter) {<EOL>        files = files.filter(","gt":"filter);"}
{"input":"<s> <EOL>function fun<T>(item: {<EOL>    [P in keyof T]: T[P];<EOL>}) {<EOL>    const strings: string[] = [];<EOL>    for (const key in item) {<EOL>        const","gt":"value = item[key];"}
{"input":"<s> /**<EOL> * @Returns the implicit role for a datalist tag.<EOL> */<EOL>function getImplicitRoleForDatalist(): string {<EOL>    return","gt":"'<STR_LIT>';"}
{"input":"<s> export function realpath(path: string, callback: (error: Error, realpath: string) => void): void {<EOL>    return fs.realpath(path, (error, realpath) => {<EOL>        if (!error) {<EOL>            return callback(null, realpath);<EOL>        }<EOL>        <EOL>        <EOL>        <EOL>        <EOL>        <EOL>        const normalizedPath = normalizePath(path);<EOL>","gt":"return fs.access(normalizedPath, fs.constants.R_OK, error => {"}
{"input":"<s> export async function sleep(seconds: number): Promise<void> {<EOL>    return","gt":"new Promise<void>(resolve => setTimeout(resolve, seconds * <NUM_LIT>));"}
{"input":"<s> /**<EOL> * Returns the `ICssTransformMatrix` of an element, if defined in its computed<EOL> * style. Returns `null` if there is no transform on the element.<EOL> */<EOL>export function getElementTransform(elem: Element): ICssTransformMatrix | null {<EOL>    const style = window.getComputedStyle(elem, null);<EOL>    const transform = style.getPropertyValue(\"<STR_LIT>\") ||<EOL>        style.getPropertyValue(","gt":"\"<STR_LIT>\") ||"}
{"input":"<s> function isSuccess<T>(result: Result<T>): result is T {<EOL>","gt":"return !isFailure(result);"}
{"input":"<s> function isFailure<T>(result: Result<T>): result is FAILURE {<EOL>","gt":"return result === FAILURE;"}
{"input":"<s> export function removeProperty(text: string, path: JSONPath, formattingOptions: FormattingOptions): Edit[] {<EOL>    return setProperty(text, path, void","gt":"<NUM_LIT>, formattingOptions);"}
{"input":"<s> function isJsDoc(sourceText: string, kind: ts.SyntaxKind, range: ts.TextRange) {<EOL>    return kind === ts.SyntaxKind.MultiLineCommentTrivia && sourceText[range.pos + <NUM_LIT>] === \"<STR_LIT>\" && sourceText[range.","gt":"pos + <NUM_LIT>] !== \"<STR_LIT>\";"}
{"input":"<s> export function help() {<EOL>","gt":"return `<STR_LIT>`"}
{"input":"<s> function isTrue(value: string) {<EOL>    return value ===","gt":"'<STR_LIT>' || value === '<STR_LIT>';"}
{"input":"<s> export function fromNodeStream(stream: NodeJS.ReadableStream, size?: number): AsyncIterableX<string | Buffer> {<EOL>    return","gt":"new ReadableStreamAsyncIterable(stream, size);"}
{"input":"<s> function walk(ctx: Lint.WalkContext<void>): void {<EOL>    const { sourceFile } = ctx;<EOL>    visitStatements(sourceFile.statements);<EOL>    return ts.forEachChild(sourceFile, function cb(node: ts.Node): void {<EOL>        switch (node.kind) {<EOL>            case ts.SyntaxKind.","gt":"ModuleBlock:"}
{"input":"<s> function walk(ctx: Lint.WalkContext<void>): void {<EOL>    const { sourceFile } = ctx;<EOL>    visitStatements(sourceFile.statements);<EOL>    return ts.forEachChild(sourceFile, function cb(node: ts.Node): void {<EOL>        switch (node.kind) {<EOL>            case ts.SyntaxKind.ModuleBlock:<EOL>                visitStatements((node as ts.ModuleBlock).statements);<EOL>                break;<EOL>","gt":"case ts.SyntaxKind.InterfaceDeclaration:"}
{"input":"<s> function isExpressionNaN(node: ts.Node) {<EOL>    return node.kind === ts.SyntaxKind.Identifier && (node as ts.Identifier).","gt":"text === \"<STR_LIT>\";"}
{"input":"<s> /**<EOL> * Returns a sequence from a dictionary based on the result of evaluating a selector function.<EOL> * @example<EOL> * const map = new Map([<EOL> *   [1, [1, 2, 3]],<EOL> *   [2, [2, 3, 4]],<EOL> *   [3, [4, 5, 6]]<EOL> * ]);<EOL> * const result = case(<EOL> *   () => 2,<EOL> *   map,<EOL> *   [5, 6, 7]<EOL> * );<EOL> * const result = Ix.Iterable.case(<EOL> *   () => 2,<EOL> *   map,<EOL> *   [5, 6, 7]<EOL> * );<EOL> * for (const item of result) {<EOL> *   console.log(result);<EOL> * }<EOL> * @param {function(): TSource} selector Selector function used to pick a sequence from the given sources.<EOL> * @param {Map<TSource, Iterable<TResult>>} sources Dictionary mapping selector values onto resulting sequences.<EOL> * @param {Iterable<TResult>} [defaultSource] Default sequence to return in case there's no corresponding source<EOL> * for the computed selector value.  If not specified, defaults to an empty sequence.<EOL> * @return {Iterable<TResult>} The source sequence corresponding with the evaluated selector value; otherwise, the default source.<EOL> */<EOL>export function _case<TSource, TResult>(selector: () => TSource, sources: Map<TSource, Iterable<TResult>>, defaultSource: Iterable<TResult> = empty<TResult>()): IterableX<TResult> {<EOL>    return defer<TResult>(() => {<EOL>","gt":"const key = selector();"}
{"input":"<s> function walk(ctx: Lint.WalkContext<Options>) {<EOL>    return ts.forEachChild(ctx.sourceFile, function cb(node: ts.Node): void {<EOL>        if (isBinaryExpression(node)) {<EOL>            if ((node.operatorToken.kind === ts.SyntaxKind.EqualsEqualsToken ||<EOL>                node.operatorToken.kind ===","gt":"ts.SyntaxKind.ExclamationEqualsToken) &&"}
{"input":"<s> /** Returns a boolean value if that should always be the result of a type predicate. */<EOL>function getConstantBoolean(type: ts.Type, predicate: (t: ts.Type) => boolean): boolean | undefined {<EOL>    let anyTrue = false;<EOL>    let anyFalse = false;<EOL>    for (const ty of unionParts(type)) {<EOL>        if (predicate(ty)) {<EOL>            anyTrue =","gt":"true;"}
{"input":"<s> /** Returns a boolean value if that should always be the result of a type predicate. */<EOL>function getConstantBoolean(type: ts.Type, predicate: (t: ts.Type) => boolean): boolean | undefined {<EOL>    let anyTrue = false;<EOL>    let anyFalse = false;<EOL>    for (const ty of unionParts(type)) {<EOL>        if (predicate(ty)) {<EOL>            anyTrue = true;<EOL>        }<EOL>        else {<EOL>            anyFalse = true;<EOL>        }<EOL>        if (anyTrue && anyFalse) {<EOL>            return","gt":"undefined;"}
{"input":"<s> function isFunctionLiteral(node: ts.Node | undefined) {<EOL>    if (node === undefined) {<EOL>        return false;<EOL>    }<EOL>    switch (","gt":"node.kind) {"}
{"input":"<s> function isFunctionLiteral(node: ts.Node | undefined) {<EOL>    if (node === undefined) {<EOL>        return false;<EOL>    }<EOL>    switch (node.kind) {<EOL>        case ts.SyntaxKind.ArrowFunction:<EOL>        case ts.SyntaxKind.FunctionExpression:<EOL>            return true;<EOL>","gt":"default:"}
{"input":"<s> function walk(ctx: Lint.WalkContext<{<EOL>    never: boolean;<EOL>}>): void {<EOL>    const { options: { never } } = ctx;<EOL>    return ts.forEachChild(ctx.sourceFile, function cb(node: ts.Node): void {<EOL>        if (utils.isInterfaceDeclaration(node)) {<EOL>            const { name } = node;<EOL>            if (","gt":"never && hasPrefixI(name.text)) {"}
{"input":"<s> function walk(ctx: Lint.WalkContext<{<EOL>    never: boolean;<EOL>}>): void {<EOL>    const { options: { never } } = ctx;<EOL>    return ts.forEachChild(ctx.sourceFile, function cb(node: ts.Node): void {<EOL>        if (utils.isInterfaceDeclaration(node)) {<EOL>            const { name } = node;<EOL>            if (never && hasPrefixI(name.text)) {<EOL>                ctx.addFailureAtNode(name, Rule.FAILURE_STRING_NO_PREFIX);<EOL>            }<EOL>            else if (!never && name.text[<NUM_LIT>] !== \"<STR_LIT>\") {<EOL>                ctx.addFailureAtNode(name,","gt":"Rule.FAILURE_STRING);"}
{"input":"<s> function walk(ctx: Lint.WalkContext<{<EOL>    never: boolean;<EOL>}>): void {<EOL>    const { options: { never } } = ctx;<EOL>    return ts.forEachChild(ctx.sourceFile, function cb(node: ts.Node): void {<EOL>        if (utils.isInterfaceDeclaration(node)) {<EOL>            const { name } = node;<EOL>            if (never && hasPrefixI(name.text)) {<EOL>                ctx.addFailureAtNode(name, Rule.FAILURE_STRING_NO_PREFIX);<EOL>            }<EOL>            else if (!never && name.text[<NUM_LIT>] !== \"<STR_LIT>\") {<EOL>                ctx.addFailureAtNode(name, Rule.FAILURE_STRING);<EOL>            }<EOL>        }<EOL>","gt":"else {"}
{"input":"<s> function assertNever(x: never): never {<EOL>    throw","gt":"new Error(\"<STR_LIT>\");"}
{"input":"<s> /** Perform `moveLogs` for both parts of a LogWithErrors. */<EOL>export function moveLogsWithErrors(dest: LoggerWithErrors, { infos, errors }: LogWithErrors, mapper?: (message: string) => string): void {<EOL>    moveLogs(dest.info, infos,","gt":"mapper);"}
{"input":"<s> function isPossiblyVoidExpression(node: ts.Node): boolean {<EOL>    switch (node.kind) {<EOL>        case ts.SyntaxKind.AwaitExpression:<EOL>        case","gt":"ts.SyntaxKind.CallExpression:"}
{"input":"<s> function f13(x: UnknownYesNo) {<EOL>    if (x === Choice.Yes) {<EOL>","gt":"x;"}
{"input":"<s> function walk(ctx: Lint.WalkContext<void>): void {<EOL>    walkWorker(ctx, ctx.","gt":"sourceFile.statements, new Set());"}
{"input":"<s> /**<EOL> * Removes all occurrences of needle from the end of haystack.<EOL> * @param haystack string to trim<EOL> * @param needle the thing to trim<EOL> */<EOL>export function rtrim(haystack?: string, needle?: string): string {<EOL>    if (!haystack || !needle) {<EOL>        return haystack;<EOL>    }<EOL>    let needleLen = needle.length, haystackLen = haystack.length;<EOL>    if (needleLen === <NUM_LIT> || haystackLen === <NUM_LIT>) {<EOL>","gt":"return haystack;"}
{"input":"<s> /**<EOL> * Removes all occurrences of needle from the end of haystack.<EOL> * @param haystack string to trim<EOL> * @param needle the thing to trim<EOL> */<EOL>export function rtrim(haystack?: string, needle?: string): string {<EOL>    if (!haystack || !needle) {<EOL>        return haystack;<EOL>    }<EOL>    let needleLen = needle.length, haystackLen = haystack.length;<EOL>    if (needleLen === <NUM_LIT> || haystackLen === <NUM_LIT>) {<EOL>        return haystack;<EOL>    }<EOL>    let offset = haystackLen, idx = -<NUM_LIT>;<EOL>    while (true) {<EOL>        idx = haystack.lastIndexOf(needle, offset - <NUM_LIT>);<EOL>        if (idx === -<NUM_LIT> ||","gt":"idx + needleLen !== offset) {"}
{"input":"<s> /**<EOL> * Removes all occurrences of needle from the end of haystack.<EOL> * @param haystack string to trim<EOL> * @param needle the thing to trim<EOL> */<EOL>export function rtrim(haystack?: string, needle?: string): string {<EOL>    if (!haystack || !needle) {<EOL>        return haystack;<EOL>    }<EOL>    let needleLen = needle.length, haystackLen = haystack.length;<EOL>    if (needleLen === <NUM_LIT> || haystackLen === <NUM_LIT>) {<EOL>        return haystack;<EOL>    }<EOL>    let offset = haystackLen, idx = -<NUM_LIT>;<EOL>    while (true) {<EOL>        idx = haystack.lastIndexOf(needle, offset - <NUM_LIT>);<EOL>        if (idx === -<NUM_LIT> || idx + needleLen !== offset) {<EOL>            break;<EOL>        }<EOL>        if (idx === <NUM_LIT>) {<EOL>            return","gt":"'<STR_LIT>';"}
{"input":"<s> /**<EOL> * Removes all occurrences of needle from the beginning of haystack.<EOL> * @param haystack string to trim<EOL> * @param needle the thing to trim<EOL> */<EOL>export function ltrim(haystack?: string, needle?: string): string {<EOL>    if (!haystack || !needle) {<EOL>        return haystack;<EOL>    }<EOL>","gt":"let needleLen = needle.length;"}
{"input":"<s> /**<EOL> * Removes all occurrences of needle from the beginning of haystack.<EOL> * @param haystack string to trim<EOL> * @param needle the thing to trim<EOL> */<EOL>export function ltrim(haystack?: string, needle?: string): string {<EOL>    if (!haystack || !needle) {<EOL>        return haystack;<EOL>    }<EOL>    let needleLen = needle.length;<EOL>    if (needleLen === <NUM_LIT> || haystack.length === <NUM_LIT>) {<EOL>        return haystack;<EOL>    }<EOL>    let offset = <NUM_LIT>, idx = -<NUM_LIT>;<EOL>    while ((idx = haystack.indexOf(needle, offset)) === offset) {<EOL>","gt":"offset = offset + needleLen;"}
{"input":"<s> /**<EOL> * @ignore<EOL> */<EOL>export function countProto<T>(this: IterableX<T>, fn?: (value: T) => boolean): number {<EOL>    return count<T>(this,","gt":"fn);"}
{"input":"<s> function foo<T, U extends T>(t: T, t2: U) {<EOL>    return (x: T) =>","gt":"t2;"}
{"input":"<s> async function newExpression16() {<EOL>    new (await x[","gt":"a])(y, z);"}
{"input":"<s> function fillOptions<T>(value: T): Record<OptionName, T> {<EOL>    return {<EOL>        arrays: value,<EOL>","gt":"exports: value,"}
{"input":"<s> function walk(ctx: Lint.WalkContext<Options>): void {<EOL>    const { sourceFile, options: { multiline } } = ctx;<EOL>    return ts.forEachChild(sourceFile, function cb(node: ts.Node): void {<EOL>        if (utils.isArrowFunction(node) && utils.isBlock(node.body)) {<EOL>            const expr = getSimpleReturnExpression(","gt":"node.body);"}
{"input":"<s> async function newExpression18() {<EOL>","gt":"new x[await a](y, z);"}
{"input":"<s> function testLambdasWithMoreParams() {<EOL>    function a(f: (x: number, v: string, y: number) => void) {<EOL>","gt":"f(<NUM_LIT>, \"<STR_LIT>\" + \"<STR_LIT>\", <NUM_LIT>);"}
{"input":"<s> function walk(ctx: Lint.WalkContext<void>): void {<EOL>    const { sourceFile } = ctx;<EOL>    return ts.forEachChild(sourceFile, function cb(node: ts.Node): void {<EOL>        const parent = node.parent!;<EOL>        if (isVariableDeclarationList(node)<EOL>            && !isBlockScopedVariableDeclarationList(","gt":"node)"}
{"input":"<s> function walk(ctx: Lint.WalkContext<void>): void {<EOL>    const { sourceFile } = ctx;<EOL>    return ts.forEachChild(sourceFile, function cb(node: ts.Node): void {<EOL>        const parent = node.parent!;<EOL>        if (isVariableDeclarationList(node)<EOL>            && !isBlockScopedVariableDeclarationList(node)<EOL>            <EOL>            && (!isVariableStatement(parent) || !isGlobalVarDeclaration(parent))) {<EOL>            const start = node.getStart(sourceFile);<EOL>            const","gt":"width = \"<STR_LIT>\".length;"}
{"input":"<s> function walk(ctx: Lint.WalkContext<void>): void {<EOL>    const { sourceFile } = ctx;<EOL>    return ts.forEachChild(sourceFile, function cb(node: ts.Node): void {<EOL>        const parent = node.parent!;<EOL>        if (isVariableDeclarationList(node)<EOL>            && !isBlockScopedVariableDeclarationList(node)<EOL>            <EOL>            && (!isVariableStatement(parent) || !isGlobalVarDeclaration(parent))) {<EOL>            const start = node.getStart(sourceFile);<EOL>            const width = \"<STR_LIT>\".length;<EOL>            <EOL>            const fix = sourceFile.isDeclarationFile ? undefined : new Lint.Replacement(start, width, \"<STR_LIT>\");<EOL>            ctx.","gt":"addFailureAt(start, width, Rule.FAILURE_STRING, fix);"}
{"input":"<s> function f13(x: UnknownYesNo) {<EOL>    if (x === Choice.Yes) {<EOL>","gt":"x;"}
{"input":"<s> export function getFailureString(propName: string, expectedType: string, permittedValues: string[]): string {<EOL>    switch (expectedType) {<EOL>        case '<STR_LIT>':<EOL>            return `<STR_LIT>`;<EOL>        case '<STR_LIT>':<EOL>","gt":"return `<STR_LIT>`;"}
{"input":"<s> export function getFailureString(propName: string, expectedType: string, permittedValues: string[]): string {<EOL>    switch (expectedType) {<EOL>        case '<STR_LIT>':<EOL>            return `<STR_LIT>`;<EOL>        case '<STR_LIT>':<EOL>            return `<STR_LIT>`;<EOL>        case '<STR_LIT>':<EOL>            return `<STR_LIT>`;<EOL>        case '<STR_LIT>':<EOL>        case '<STR_LIT>':<EOL>        case '<STR_LIT>':<EOL>        case","gt":"'<STR_LIT>':"}
{"input":"<s> <EOL>/**<EOL> * Applies an accumulator function over the source Observable, and returns each<EOL> * intermediate result, with an optional seed value.<EOL> *<EOL> * <span class=\"informal\">It's like {@link reduce}, but emits the current<EOL> * accumulation whenever the source emits a value.</span><EOL> *<EOL> * <img src=\"./img/scan.png\" width=\"100%\"><EOL> *<EOL> * Combines together all values emitted on the source, using an accumulator<EOL> * function that knows how to join a new source value into the accumulation from<EOL> * the past. Is similar to {@link reduce}, but emits the intermediate<EOL> * accumulations.<EOL> *<EOL> * Returns an Observable that applies a specified `accumulator` function to each<EOL> * item emitted by the source Observable. If a `seed` value is specified, then<EOL> * that value will be used as the initial value for the accumulator. If no seed<EOL> * value is specified, the first item of the source is used as the seed.<EOL> *<EOL> * @example <caption>Count the number of click events</caption><EOL> * var clicks = Rx.Observable.fromEvent(document, 'click');<EOL> * var ones = clicks.mapTo(1);<EOL> * var seed = 0;<EOL> * var count = ones.scan((acc, one) => acc + one, seed);<EOL> * count.subscribe(x => console.log(x));<EOL> *<EOL> * @see {@link expand}<EOL> * @see {@link mergeScan}<EOL> * @see {@link reduce}<EOL> *<EOL> * @param {function(acc: R, value: T, index: number): R} accumulator<EOL> * The accumulator function called on each source value.<EOL> * @param {T|R} [seed] The initial accumulation value.<EOL> * @return {Observable<R>} An observable of the accumulated values.<EOL> * @method scan<EOL> * @owner Observable<EOL> */<EOL>export function scan<T, R>(accumulator: (acc: R, value: T, index: number) => R, seed?: T | R): OperatorFunction<T, R> {<EOL>    let hasSeed = false;<EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    if (arguments.length >= <NUM_LIT>) {<EOL>        hasSeed = true;<EOL>    }<EOL>    return function scanOperatorFunction(","gt":"source: Observable<T>): Observable<R> {"}
{"input":"<s> function isNodeAny(node: ts.Node, checker: ts.TypeChecker): boolean {<EOL>    let symbol = checker.getSymbolAtLocation(node);<EOL>    if (symbol !== undefined && isSymbolFlagSet(symbol, ts.SymbolFlags.Alias)) {<EOL>        symbol = checker.getAliasedSymbol(symbol);<EOL>    }<EOL>    if (symbol !==","gt":"undefined) {"}
{"input":"<s> function isNodeAny(node: ts.Node, checker: ts.TypeChecker): boolean {<EOL>    let symbol = checker.getSymbolAtLocation(node);<EOL>    if (symbol !== undefined && isSymbolFlagSet(symbol, ts.SymbolFlags.Alias)) {<EOL>        symbol = checker.getAliasedSymbol(symbol);<EOL>    }<EOL>    if (symbol !== undefined) {<EOL>        <EOL>        if (isSymbolFlagSet(symbol, ts.SymbolFlags.NamespaceModule)) {<EOL>            return false;<EOL>        }<EOL>        if (isSymbolFlagSet(symbol, ts.SymbolFlags.Type)) {<EOL>            return isAny(","gt":"checker.getDeclaredTypeOfSymbol(symbol));"}
{"input":"<s> function walk(ctx: Lint.WalkContext<void>, tc: ts.TypeChecker) {<EOL>    return ts.forEachChild(ctx.sourceFile, function cb(node): void {<EOL>        if (isIdentifier(node)) {<EOL>            if (!isDeclaration(node)) {<EOL>","gt":"const deprecation = getDeprecation(node, tc);"}
{"input":"<s> function walk(ctx: Lint.WalkContext<void>, tc: ts.TypeChecker) {<EOL>    return ts.forEachChild(ctx.sourceFile, function cb(node): void {<EOL>        if (isIdentifier(node)) {<EOL>            if (!isDeclaration(node)) {<EOL>                const deprecation = getDeprecation(node, tc);<EOL>                if (deprecation !== undefined) {<EOL>                    ctx.addFailureAtNode(node, Rule.FAILURE_STRING(node.text, deprecation));<EOL>                }<EOL>            }<EOL>        }<EOL>        else {<EOL>            switch (","gt":"node.kind) {"}
{"input":"<s> function getError(node: ts.Node, allowSingleConcat: boolean): string | undefined {<EOL>    if (!isPlusExpression(node)) {<EOL>        return undefined;<EOL>    }<EOL>    const { left, right } = node;<EOL>    const","gt":"l = isStringLike(left);"}
{"input":"<s> function getError(node: ts.Node, allowSingleConcat: boolean): string | undefined {<EOL>    if (!isPlusExpression(node)) {<EOL>        return undefined;<EOL>    }<EOL>    const { left, right } = node;<EOL>    const l = isStringLike(left);<EOL>    const r = isStringLike(right);<EOL>    if (l && r) {<EOL>        <EOL>        <EOL>        <EOL>        return containsNewline(left as StringLike) || containsNewline(right as StringLike) ?","gt":"Rule.FAILURE_STRING_MULTILINE : undefined;"}
{"input":"<s> function getError(node: ts.Node, allowSingleConcat: boolean): string | undefined {<EOL>    if (!isPlusExpression(node)) {<EOL>        return undefined;<EOL>    }<EOL>    const { left, right } = node;<EOL>    const l = isStringLike(left);<EOL>    const r = isStringLike(right);<EOL>    if (l && r) {<EOL>        <EOL>        <EOL>        <EOL>        return containsNewline(left as StringLike) || containsNewline(right as StringLike) ? Rule.FAILURE_STRING_MULTILINE : undefined;<EOL>    }<EOL>    else if (!l && !r) {<EOL>        <EOL>        return containsAnyStringLiterals(left) ? Rule.FAILURE_STRING : undefined;<EOL>    }<EOL>    else if (l) {<EOL>        <EOL>        return !allowSingleConcat ? Rule.","gt":"FAILURE_STRING : undefined;"}
{"input":"<s> export function getTextEditForAddImport(arg: string): vscode.TextEdit[] {<EOL>    <EOL>    if (arg === undefined) {<EOL>        return","gt":"null;"}
{"input":"<s> export function getTextEditForAddImport(arg: string): vscode.TextEdit[] {<EOL>    <EOL>    if (arg === undefined) {<EOL>        return null;<EOL>    }<EOL>    let { imports, pkg } = parseFilePrelude(vscode.window.activeTextEditor.document.getText());<EOL>    let multis = imports.filter(x => x.kind === '<STR_LIT>');<EOL>    if (multis.length >","gt":"<NUM_LIT>) {"}
{"input":"<s> export function getTextEditForAddImport(arg: string): vscode.TextEdit[] {<EOL>    <EOL>    if (arg === undefined) {<EOL>        return null;<EOL>    }<EOL>    let { imports, pkg } = parseFilePrelude(vscode.window.activeTextEditor.document.getText());<EOL>    let multis = imports.filter(x => x.kind === '<STR_LIT>');<EOL>    if (multis.length > <NUM_LIT>) {<EOL>        <EOL>        const lastImportSection = multis[multis.length - <NUM_LIT>];<EOL>        if (lastImportSection.end === -<NUM_LIT>) {<EOL>            <EOL>            return [vscode.TextEdit.","gt":"insert(new vscode.Position(lastImportSection.start + <NUM_LIT>, <NUM_LIT>), `<STR_LIT>`)];"}
{"input":"<s> export function getTextEditForAddImport(arg: string): vscode.TextEdit[] {<EOL>    <EOL>    if (arg === undefined) {<EOL>        return null;<EOL>    }<EOL>    let { imports, pkg } = parseFilePrelude(vscode.window.activeTextEditor.document.getText());<EOL>    let multis = imports.filter(x => x.kind === '<STR_LIT>');<EOL>    if (multis.length > <NUM_LIT>) {<EOL>        <EOL>        const lastImportSection = multis[multis.length - <NUM_LIT>];<EOL>        if (lastImportSection.end === -<NUM_LIT>) {<EOL>            <EOL>            return [vscode.TextEdit.insert(new vscode.Position(lastImportSection.start + <NUM_LIT>, <NUM_LIT>), `<STR_LIT>`)];<EOL>        }<EOL>        <EOL>        return [vscode.TextEdit.insert(new vscode.","gt":"Position(lastImportSection.start + <NUM_LIT>, <NUM_LIT>), '<STR_LIT>' + arg + '<STR_LIT>')];"}
{"input":"<s> export function getTextEditForAddImport(arg: string): vscode.TextEdit[] {<EOL>    <EOL>    if (arg === undefined) {<EOL>        return null;<EOL>    }<EOL>    let { imports, pkg } = parseFilePrelude(vscode.window.activeTextEditor.document.getText());<EOL>    let multis = imports.filter(x => x.kind === '<STR_LIT>');<EOL>    if (multis.length > <NUM_LIT>) {<EOL>        <EOL>        const lastImportSection = multis[multis.length - <NUM_LIT>];<EOL>        if (lastImportSection.end === -<NUM_LIT>) {<EOL>            <EOL>            return [vscode.TextEdit.insert(new vscode.Position(lastImportSection.start + <NUM_LIT>, <NUM_LIT>), `<STR_LIT>`)];<EOL>        }<EOL>        <EOL>        return [vscode.TextEdit.insert(new vscode.Position(lastImportSection.start + <NUM_LIT>, <NUM_LIT>), '<STR_LIT>' + arg + '<STR_LIT>')];<EOL>    }<EOL>    else if (imports.length > <NUM_LIT>) {<EOL>        <EOL>        const edits = [];<EOL>        edits.push(vscode.TextEdit.insert(new vscode.Position(imports[<NUM_LIT>].start, <NUM_LIT>), '<STR_LIT>' +","gt":"arg + '<STR_LIT>'));"}
{"input":"<s> export function getTextEditForAddImport(arg: string): vscode.TextEdit[] {<EOL>    <EOL>    if (arg === undefined) {<EOL>        return null;<EOL>    }<EOL>    let { imports, pkg } = parseFilePrelude(vscode.window.activeTextEditor.document.getText());<EOL>    let multis = imports.filter(x => x.kind === '<STR_LIT>');<EOL>    if (multis.length > <NUM_LIT>) {<EOL>        <EOL>        const lastImportSection = multis[multis.length - <NUM_LIT>];<EOL>        if (lastImportSection.end === -<NUM_LIT>) {<EOL>            <EOL>            return [vscode.TextEdit.insert(new vscode.Position(lastImportSection.start + <NUM_LIT>, <NUM_LIT>), `<STR_LIT>`)];<EOL>        }<EOL>        <EOL>        return [vscode.TextEdit.insert(new vscode.Position(lastImportSection.start + <NUM_LIT>, <NUM_LIT>), '<STR_LIT>' + arg + '<STR_LIT>')];<EOL>    }<EOL>    else if (imports.length > <NUM_LIT>) {<EOL>        <EOL>        const edits = [];<EOL>        edits.push(vscode.TextEdit.insert(new vscode.Position(imports[<NUM_LIT>].start, <NUM_LIT>), '<STR_LIT>' + arg + '<STR_LIT>'));<EOL>        imports.forEach(element => {<EOL>            const currentLine = vscode.window.activeTextEditor.document.lineAt(element.start).text;<EOL>            const updatedLine = currentLine.replace(/^\\s*import\\s*/, '<STR_LIT>');<EOL>            edits.push(vscode.TextEdit.replace(new vscode.Range(element.start, <NUM_LIT>, element.start, currentLine.length), updatedLine));<EOL>        });<EOL>        edits.push(vscode.TextEdit.insert(new vscode.Position(imports[imports.length - <NUM_LIT>].end + <NUM_LIT>, <NUM_LIT>), '<STR_LIT>'));<EOL>        return","gt":"edits;"}
{"input":"<s> <EOL>/**<EOL> * Projects each source value to an Observable which is merged in the output<EOL> * Observable, emitting values only from the most recently projected Observable.<EOL> *<EOL> * <span class=\"informal\">Maps each value to an Observable, then flattens all of<EOL> * these inner Observables using {@link switch}.</span><EOL> *<EOL> * <img src=\"./img/switchMap.png\" width=\"100%\"><EOL> *<EOL> * Returns an Observable that emits items based on applying a function that you<EOL> * supply to each item emitted by the source Observable, where that function<EOL> * returns an (so-called \"inner\") Observable. Each time it observes one of these<EOL> * inner Observables, the output Observable begins emitting the items emitted by<EOL> * that inner Observable. When a new inner Observable is emitted, `switchMap`<EOL> * stops emitting items from the earlier-emitted inner Observable and begins<EOL> * emitting items from the new one. It continues to behave like this for<EOL> * subsequent inner Observables.<EOL> *<EOL> * @example <caption>Rerun an interval Observable on every click event</caption><EOL> * var clicks = Rx.Observable.fromEvent(document, 'click');<EOL> * var result = clicks.switchMap((ev) => Rx.Observable.interval(1000));<EOL> * result.subscribe(x => console.log(x));<EOL> *<EOL> * @see {@link concatMap}<EOL> * @see {@link exhaustMap}<EOL> * @see {@link mergeMap}<EOL> * @see {@link switch}<EOL> * @see {@link switchMapTo}<EOL> *<EOL> * @param {function(value: T, ?index: number): ObservableInput} project A function<EOL> * that, when applied to an item emitted by the source Observable, returns an<EOL> * Observable.<EOL> * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]<EOL> * A function to produce the value on the output Observable based on the values<EOL> * and the indices of the source (outer) emission and the inner Observable<EOL> * emission. The arguments passed to this function are:<EOL> * - `outerValue`: the value that came from the source<EOL> * - `innerValue`: the value that came from the projected Observable<EOL> * - `outerIndex`: the \"index\" of the value that came from the source<EOL> * - `innerIndex`: the \"index\" of the value from the projected Observable<EOL> * @return {Observable} An Observable that emits the result of applying the<EOL> * projection function (and the optional `resultSelector`) to each item emitted<EOL> * by the source Observable and taking only the values from the most recently<EOL> * projected inner Observable.<EOL> * @method switchMap<EOL> * @owner Observable<EOL> */<EOL>export function switchMap<T, I, R>(this: Observable<T>, project: (value: T, index: number) => ObservableInput<I>, resultSelector?: (outerValue: T, innerValue: I, outerIndex: number, innerIndex: number) => R): Observable<I | R> {<EOL>    return higherOrderSwitchMap(project, resultSelector)(","gt":"this);"}
{"input":"<s> export function equalsIgnoreCase(a: string, b: string): boolean {<EOL>    const len1 = a ? a.length : <NUM_LIT>;<EOL>    const len2 = b ?","gt":"b.length : <NUM_LIT>;"}
{"input":"<s> function everyCase({ expression, elseStatement }: ts.IfStatement, test: (e: ts.Expression) => boolean): boolean {<EOL>    if (!everyCondition(expression, test)) {<EOL>        return","gt":"false;"}
{"input":"<s> function isSimple(node: ts.Node): boolean {<EOL>    switch (node.kind) {<EOL>        case ts.SyntaxKind.PropertyAccessExpression:<EOL>            return isSimple((node as ts.PropertyAccessExpression).expression);<EOL>        case ts.SyntaxKind.PrefixUnaryExpression:<EOL>","gt":"switch ((node as ts.PrefixUnaryExpression).operator) {"}
{"input":"<s> function isSimple(node: ts.Node): boolean {<EOL>    switch (node.kind) {<EOL>        case ts.SyntaxKind.PropertyAccessExpression:<EOL>            return isSimple((node as ts.PropertyAccessExpression).expression);<EOL>        case ts.SyntaxKind.PrefixUnaryExpression:<EOL>            switch ((node as ts.PrefixUnaryExpression).operator) {<EOL>                case ts.SyntaxKind.PlusPlusToken:<EOL>                case ts.SyntaxKind.MinusMinusToken:<EOL>                    return","gt":"false;"}
{"input":"<s> function isSimple(node: ts.Node): boolean {<EOL>    switch (node.kind) {<EOL>        case ts.SyntaxKind.PropertyAccessExpression:<EOL>            return isSimple((node as ts.PropertyAccessExpression).expression);<EOL>        case ts.SyntaxKind.PrefixUnaryExpression:<EOL>            switch ((node as ts.PrefixUnaryExpression).operator) {<EOL>                case ts.SyntaxKind.PlusPlusToken:<EOL>                case ts.SyntaxKind.MinusMinusToken:<EOL>                    return false;<EOL>                default:<EOL>                    return isSimple((node as ts.PrefixUnaryExpression).operand);<EOL>            }<EOL>        case ts.SyntaxKind.Identifier:<EOL>        case ts.SyntaxKind.","gt":"NumericLiteral:"}
{"input":"<s> function isSimple(node: ts.Node): boolean {<EOL>    switch (node.kind) {<EOL>        case ts.SyntaxKind.PropertyAccessExpression:<EOL>            return isSimple((node as ts.PropertyAccessExpression).expression);<EOL>        case ts.SyntaxKind.PrefixUnaryExpression:<EOL>            switch ((node as ts.PrefixUnaryExpression).operator) {<EOL>                case ts.SyntaxKind.PlusPlusToken:<EOL>                case ts.SyntaxKind.MinusMinusToken:<EOL>                    return false;<EOL>                default:<EOL>                    return isSimple((node as ts.PrefixUnaryExpression).operand);<EOL>            }<EOL>        case ts.SyntaxKind.Identifier:<EOL>        case ts.SyntaxKind.NumericLiteral:<EOL>        case ts.SyntaxKind.StringLiteral:<EOL>        case ts.SyntaxKind.ThisKeyword:<EOL>        case ts.SyntaxKind.NoSubstitutionTemplateLiteral:<EOL>        case ts.SyntaxKind.TrueKeyword:<EOL>        case ts.","gt":"SyntaxKind.FalseKeyword:"}
{"input":"<s> function newFunction() {<EOL>    const","gt":"x: number = <NUM_LIT>;"}
{"input":"<s> function substrEquals(a: string, aStart: number, aEnd: number, b: string, bStart: number, bEnd: number): boolean {<EOL>    while (aStart < aEnd && bStart < bEnd) {<EOL>        if (a[aStart] !== b[bStart]) {<EOL>","gt":"return false;"}
{"input":"<s> function f10(x: true | false) {<EOL>    switch (x) {<EOL>        case true:","gt":"return \"<STR_LIT>\";"}
{"input":"<s> export async function find<T>(source: AsyncIterable<T>, predicate: (value: T, index: number) => boolean | Promise<boolean>, thisArg?: any): Promise<T | undefined> {<EOL>    const fn = bindCallback(predicate, thisArg, <NUM_LIT>);<EOL>    let i = <NUM_LIT>;<EOL>    for await (let","gt":"item of source) {"}
{"input":"<s> function newFunction<T, T>(t1: T, t2: T) {<EOL>","gt":"t1.toString();"}
{"input":"<s> /**<EOL> * Returns an Observable that mirrors the source Observable, but will call a specified function when<EOL> * the source terminates on complete or error.<EOL> * @param {function} callback Function to be called when source terminates.<EOL> * @return {Observable} An Observable that mirrors the source, but will call the specified function on termination.<EOL> * @method finally<EOL> * @owner Observable<EOL> */<EOL>export function finalize<T>(callback: () => void): MonoTypeOperatorFunction<T> {<EOL>    return (source: Observable<T>) => source.lift(","gt":"new FinallyOperator(callback));"}
{"input":"<s> export function safeBtoa(str: string): string {<EOL>    return","gt":"btoa(encodeURIComponent(str));"}
{"input":"<s> function f1() {<EOL>    var a: A1;<EOL>","gt":"var a: A2;"}
{"input":"<s> function validateAllFilters(prototype: Object, attributes: AttributeRegistrationsMapping): void {<EOL>    for (const attributeMetadata of collectUniqueMetadatas(","gt":"attributes)) {"}
{"input":"<s> async function terminalCommandExecutor(terminal: Terminal, commandId: string, commandArguments?: object): Promise<any> {<EOL>    const scriptCommands = getScriptCommands(","gt":"terminal, commandId);"}
{"input":"<s> /**<EOL> * Emit a resize event.<EOL> *<EOL> * This utility function is meant for use by VirtualScrollable objects.<EOL> *<EOL> * @param el The element and VirtualScrollable object which needs to be resized.<EOL> */<EOL>export function emitResizeEvent(el: VirtualScrollable & HTMLElement): void {<EOL>    const event = new CustomEvent(EVENT_RESIZE, {","gt":"bubbles: true });"}
{"input":"<s> function f5(b: boolean) {<EOL>    var z1 =","gt":"g(true);"}
{"input":"<s> function subscribe(component: AnyComponent, path: string) {<EOL>    let e = lookup(path);<EOL>    let lst = e.","gt":"components;"}
{"input":"<s> function readDefaultUserShellFromEtcPasswd(userName: string): string {<EOL>    let shell = \"<STR_LIT>\";<EOL>    const passwdDb = readPasswd(\"<STR_LIT>\");<EOL>    const","gt":"userRecords = passwdDb.filter(row => row.username === userName);"}
{"input":"<s> /**<EOL> * Method decorator to apply a filter to the value set on a HTML attribute.<EOL> *<EOL> * The method can have one or two parameters. The first is the value which<EOL> * needs to be filtered. The second optional parameter is the name of the<EOL> * attribute the value is for. The method must return the new filtered value,<EOL> * or `undefined` to indicate that the<EOL> *<EOL> * Note that the filter doesn't affect the value of the HTML attribute set,<EOL> * but it does affect the internal value directly accessible via the JS field.<EOL> * Also these filters can only be used for attributes which have been created<EOL> * using the `Attribute` decorator.<EOL> *<EOL> * @param targets variable number of parameters naming the attributes which<EOL> *          this method filters.<EOL> */<EOL>export function Filter(...targets: string[]) {<EOL>    return function (proto: any, methodName: string, descriptor: PropertyDescriptor) {<EOL>        <EOL>        if (!proto.constructor.hasOwnProperty(ATTRIBUTES_REGISTRATION_KEY)) {<EOL>            proto.constructor[ATTRIBUTES_REGISTRATION_KEY] = new Map();<EOL>        }<EOL>        const attributes: AttributeRegistrationsMapping = proto.constructor[ATTRIBUTES_REGISTRATION_KEY];<EOL>        for (const target of targets) {<EOL>            if (!attributes.has(target)) {<EOL>                const metadata: AttributeRegistration = { name: target, attributeName: null, dataType: '<STR_LIT>', directSetter:","gt":"null, filterRegistrations: [] };"}
{"input":"<s> /**<EOL> * Method decorator to apply a filter to the value set on a HTML attribute.<EOL> *<EOL> * The method can have one or two parameters. The first is the value which<EOL> * needs to be filtered. The second optional parameter is the name of the<EOL> * attribute the value is for. The method must return the new filtered value,<EOL> * or `undefined` to indicate that the<EOL> *<EOL> * Note that the filter doesn't affect the value of the HTML attribute set,<EOL> * but it does affect the internal value directly accessible via the JS field.<EOL> * Also these filters can only be used for attributes which have been created<EOL> * using the `Attribute` decorator.<EOL> *<EOL> * @param targets variable number of parameters naming the attributes which<EOL> *          this method filters.<EOL> */<EOL>export function Filter(...targets: string[]) {<EOL>    return function (proto: any, methodName: string, descriptor: PropertyDescriptor) {<EOL>        <EOL>        if (!proto.constructor.hasOwnProperty(ATTRIBUTES_REGISTRATION_KEY)) {<EOL>            proto.constructor[ATTRIBUTES_REGISTRATION_KEY] = new Map();<EOL>        }<EOL>        const attributes: AttributeRegistrationsMapping = proto.constructor[ATTRIBUTES_REGISTRATION_KEY];<EOL>        for (const target of targets) {<EOL>            if (!attributes.has(target)) {<EOL>                const metadata: AttributeRegistration = { name: target, attributeName: null, dataType: '<STR_LIT>', directSetter: null, filterRegistrations: [] };<EOL>                attributes.set(target, metadata);<EOL>            }<EOL>            const metadata = attributes.get(target);<EOL>            metadata.filterRegistrations.push({ name: methodName, method: proto[","gt":"methodName] });"}
{"input":"<s> <EOL>function f() {<EOL>     let","gt":"x;"}
{"input":"<s> /**<EOL> * Decorator to log method calls.<EOL> *<EOL> * @param  {Object} target     [description]<EOL> * @param  {string} key        [description]<EOL> * @param  {any}    descriptor [description]<EOL> * @return {[type]}            [description]<EOL> */<EOL>export default function log(target: Object, key: string, descriptor: any) {<EOL>    const originalMethod = descriptor.value;<EOL>    descriptor.value = function (this: any, ...args: any[]) {<EOL>        var formatArgs = args.map(repr).join(\"<STR_LIT>\");<EOL>        if (\"<STR_LIT>\" in this) {<EOL>            const logger = <Logger>this._log;<EOL>            logger.","gt":"debug(`<STR_LIT>`);"}
{"input":"<s> /**<EOL> * Decorator to log method calls.<EOL> *<EOL> * @param  {Object} target     [description]<EOL> * @param  {string} key        [description]<EOL> * @param  {any}    descriptor [description]<EOL> * @return {[type]}            [description]<EOL> */<EOL>export default function log(target: Object, key: string, descriptor: any) {<EOL>    const originalMethod = descriptor.value;<EOL>    descriptor.value = function (this: any, ...args: any[]) {<EOL>        var formatArgs = args.map(repr).join(\"<STR_LIT>\");<EOL>        if (\"<STR_LIT>\" in this) {<EOL>            const logger = <Logger>this._log;<EOL>            logger.debug(`<STR_LIT>`);<EOL>            var result = originalMethod.apply(this, args);<EOL>            logger.debug(`<STR_LIT>`);<EOL>        }<EOL>","gt":"else {"}
{"input":"<s> /**<EOL> * Decorator to log method calls.<EOL> *<EOL> * @param  {Object} target     [description]<EOL> * @param  {string} key        [description]<EOL> * @param  {any}    descriptor [description]<EOL> * @return {[type]}            [description]<EOL> */<EOL>export default function log(target: Object, key: string, descriptor: any) {<EOL>    const originalMethod = descriptor.value;<EOL>    descriptor.value = function (this: any, ...args: any[]) {<EOL>        var formatArgs = args.map(repr).join(\"<STR_LIT>\");<EOL>        if (\"<STR_LIT>\" in this) {<EOL>            const logger = <Logger>this._log;<EOL>            logger.debug(`<STR_LIT>`);<EOL>            var result = originalMethod.apply(this, args);<EOL>            logger.debug(`<STR_LIT>`);<EOL>        }<EOL>        else {<EOL>            console.log(`<STR_LIT>`);<EOL>            var result = originalMethod.apply(this, args);<EOL>            console.log(","gt":"repr(result)}`<STR_LIT>;"}
{"input":"<s> <EOL>export function testRandom(test: nodeunit.Test): void {<EOL>    const result = MimeTypeDetector.detect(null, readTestFile(\"<STR_LIT>\"));<EOL>    test.notEqual(result,","gt":"null);"}
{"input":"<s> export function testFilter2StringAttributeViaJS(test: nodeunit.Test): void {<EOL>    filterStringTest((sc: FilterStringComponent): void => {<EOL>","gt":"sc.shortString = \"<STR_LIT>\";"}
{"input":"<s> function someNumberTest(guts: (sc: NumberComponent) => void): void {<EOL>    const sc = <NumberComponent>document.createElement(\"<STR_LIT>\");<EOL>    document.body.appendChild(sc);<EOL>","gt":"try {"}
{"input":"<s> /**<EOL> * Convert a length with 'px' suffix to a plain integer.<EOL> *<EOL> * @param length the length value as a string<EOL> * @return the length as a number<EOL> */<EOL>export function pixelLengthToInt(length: string | number): number {<EOL>    if (typeof length === \"<STR_LIT>\") {<EOL>        const lengthStr = length.indexOf(\"<STR_LIT>\") !== -<NUM_LIT> ? length.substr(<NUM_LIT>, length.length - <NUM_LIT>) : length;<EOL>        return parseInt(lengthStr,","gt":"<NUM_LIT>);"}
{"input":"<s> function handleWriteBulkFile(msg: Messages.BulkFileWriteMessage): void {<EOL>    bulkFileStorage.write(msg.","gt":"identifier, msg.data);"}
{"input":"<s> /**<EOL> * Converts an 8bit number to a 2 digit hexadecimal string.<EOL> *<EOL> * @param  {number} value An integer in the range 0-255 inclusive.<EOL> * @return {string}       the converted number.<EOL> */<EOL>export function to2DigitHex(value: number): string {<EOL>    const h =","gt":"value.toString(<NUM_LIT>);"}
{"input":"<s> function uploadBundledTranslationsAsync(crowdinDir: string, branch: string, prj: string, key: string): Promise<void> {<EOL>    const todo: string[] = [];<EOL>    pxt.appTarget.bundleddirs.forEach(dir => {<EOL>        const locdir = path.join(dir, \"<STR_LIT>\");<EOL>        if (fs.","gt":"existsSync(locdir))"}
{"input":"<s> function uploadBundledTranslationsAsync(crowdinDir: string, branch: string, prj: string, key: string): Promise<void> {<EOL>    const todo: string[] = [];<EOL>    pxt.appTarget.bundleddirs.forEach(dir => {<EOL>        const locdir = path.join(dir, \"<STR_LIT>\");<EOL>        if (fs.existsSync(locdir))<EOL>            fs.readdirSync(locdir)<EOL>                .filter(f => /strings\\.json$/i.test(f))<EOL>                .forEach(f => todo.","gt":"push(path.join(locdir, f)));"}
{"input":"<s> function uploadBundledTranslationsAsync(crowdinDir: string, branch: string, prj: string, key: string): Promise<void> {<EOL>    const todo: string[] = [];<EOL>    pxt.appTarget.bundleddirs.forEach(dir => {<EOL>        const locdir = path.join(dir, \"<STR_LIT>\");<EOL>        if (fs.existsSync(locdir))<EOL>            fs.readdirSync(locdir)<EOL>                .filter(f => /strings\\.json$/i.test(f))<EOL>                .forEach(f => todo.push(path.join(locdir, f)));<EOL>    });<EOL>    pxt.log(`<STR_LIT>`);<EOL>    const nextFileAsync = (): Promise<void> => {<EOL>","gt":"const f = todo.pop();"}
{"input":"<s> function uploadBundledTranslationsAsync(crowdinDir: string, branch: string, prj: string, key: string): Promise<void> {<EOL>    const todo: string[] = [];<EOL>    pxt.appTarget.bundleddirs.forEach(dir => {<EOL>        const locdir = path.join(dir, \"<STR_LIT>\");<EOL>        if (fs.existsSync(locdir))<EOL>            fs.readdirSync(locdir)<EOL>                .filter(f => /strings\\.json$/i.test(f))<EOL>                .forEach(f => todo.push(path.join(locdir, f)));<EOL>    });<EOL>    pxt.log(`<STR_LIT>`);<EOL>    const nextFileAsync = (): Promise<void> => {<EOL>        const f = todo.pop();<EOL>        if (!f)<EOL>            return Promise.resolve();<EOL>        const data = JSON.parse(fs.readFileSync(f, '<STR_LIT>')) as Map<string>;<EOL>        const crowdf = path.join(crowdinDir, path.basename(f));<EOL>        pxt.","gt":"log(`<STR_LIT>`);"}
{"input":"<s> function aggregateBasenameMatches(parsedPatterns: (ParsedStringPattern | ParsedExpressionPattern)[], result?: string): (ParsedStringPattern | ParsedExpressionPattern)[] {<EOL>    const basenamePatterns = parsedPatterns.filter(parsedPattern => !!(<ParsedStringPattern>parsedPattern).basenames);<EOL>    if (basenamePatterns.length < <NUM_LIT>) {<EOL>        return parsedPatterns;<EOL>    }<EOL>    const basenames = basenamePatterns.reduce<string[]>((all, current) =>","gt":"all.concat((<ParsedStringPattern>current).basenames), []);"}
{"input":"<s> function aggregateBasenameMatches(parsedPatterns: (ParsedStringPattern | ParsedExpressionPattern)[], result?: string): (ParsedStringPattern | ParsedExpressionPattern)[] {<EOL>    const basenamePatterns = parsedPatterns.filter(parsedPattern => !!(<ParsedStringPattern>parsedPattern).basenames);<EOL>    if (basenamePatterns.length < <NUM_LIT>) {<EOL>        return parsedPatterns;<EOL>    }<EOL>    const basenames = basenamePatterns.reduce<string[]>((all, current) => all.concat((<ParsedStringPattern>current).basenames), []);<EOL>    let patterns: string[];<EOL>    if (","gt":"result) {"}
{"input":"<s> function aggregateBasenameMatches(parsedPatterns: (ParsedStringPattern | ParsedExpressionPattern)[], result?: string): (ParsedStringPattern | ParsedExpressionPattern)[] {<EOL>    const basenamePatterns = parsedPatterns.filter(parsedPattern => !!(<ParsedStringPattern>parsedPattern).basenames);<EOL>    if (basenamePatterns.length < <NUM_LIT>) {<EOL>        return parsedPatterns;<EOL>    }<EOL>    const basenames = basenamePatterns.reduce<string[]>((all, current) => all.concat((<ParsedStringPattern>current).basenames), []);<EOL>    let patterns: string[];<EOL>    if (result) {<EOL>        patterns = [];<EOL>        for (let i = <NUM_LIT>, n = basenames.length; i < n; i++) {<EOL>            patterns.push(result);<EOL>        }<EOL>    }<EOL>    else {<EOL>        patterns = basenamePatterns.reduce((all, current) => all.concat((<ParsedStringPattern>current).patterns), []);<EOL>    }<EOL>","gt":"const aggregate: ParsedStringPattern = function (path, basename) {"}
{"input":"<s> function aggregateBasenameMatches(parsedPatterns: (ParsedStringPattern | ParsedExpressionPattern)[], result?: string): (ParsedStringPattern | ParsedExpressionPattern)[] {<EOL>    const basenamePatterns = parsedPatterns.filter(parsedPattern => !!(<ParsedStringPattern>parsedPattern).basenames);<EOL>    if (basenamePatterns.length < <NUM_LIT>) {<EOL>        return parsedPatterns;<EOL>    }<EOL>    const basenames = basenamePatterns.reduce<string[]>((all, current) => all.concat((<ParsedStringPattern>current).basenames), []);<EOL>    let patterns: string[];<EOL>    if (result) {<EOL>        patterns = [];<EOL>        for (let i = <NUM_LIT>, n = basenames.length; i < n; i++) {<EOL>            patterns.push(result);<EOL>        }<EOL>    }<EOL>    else {<EOL>        patterns = basenamePatterns.reduce((all, current) => all.concat((<ParsedStringPattern>current).patterns), []);<EOL>    }<EOL>    const aggregate: ParsedStringPattern = function (path, basename) {<EOL>        if (!path) {<EOL>            return null;<EOL>        }<EOL>        if (!basename) {<EOL>            let","gt":"i: number;"}
{"input":"<s> function aggregateBasenameMatches(parsedPatterns: (ParsedStringPattern | ParsedExpressionPattern)[], result?: string): (ParsedStringPattern | ParsedExpressionPattern)[] {<EOL>    const basenamePatterns = parsedPatterns.filter(parsedPattern => !!(<ParsedStringPattern>parsedPattern).basenames);<EOL>    if (basenamePatterns.length < <NUM_LIT>) {<EOL>        return parsedPatterns;<EOL>    }<EOL>    const basenames = basenamePatterns.reduce<string[]>((all, current) => all.concat((<ParsedStringPattern>current).basenames), []);<EOL>    let patterns: string[];<EOL>    if (result) {<EOL>        patterns = [];<EOL>        for (let i = <NUM_LIT>, n = basenames.length; i < n; i++) {<EOL>            patterns.push(result);<EOL>        }<EOL>    }<EOL>    else {<EOL>        patterns = basenamePatterns.reduce((all, current) => all.concat((<ParsedStringPattern>current).patterns), []);<EOL>    }<EOL>    const aggregate: ParsedStringPattern = function (path, basename) {<EOL>        if (!path) {<EOL>            return null;<EOL>        }<EOL>        if (!basename) {<EOL>            let i: number;<EOL>            for (i = path.length; i > <NUM_LIT>; i--) {<EOL>                const ch = path.charCodeAt(i - <NUM_LIT>);<EOL>                if (ch === CharCode.Slash || ch === CharCode.Backslash) {<EOL>                    break;<EOL>                }<EOL>            }<EOL>            basename = path.substr(","gt":"i);"}
{"input":"<s> function parseExpressionPattern(pattern: string, value: any, options: IGlobOptions): (ParsedStringPattern | ParsedExpressionPattern) {<EOL>    if (value === false) {<EOL>        return NULL; <EOL>    }<EOL>    const parsedPattern =","gt":"parsePattern(pattern, options);"}
{"input":"<s> function parseExpressionPattern(pattern: string, value: any, options: IGlobOptions): (ParsedStringPattern | ParsedExpressionPattern) {<EOL>    if (value === false) {<EOL>        return NULL; <EOL>    }<EOL>    const parsedPattern = parsePattern(pattern, options);<EOL>    if (parsedPattern === NULL) {<EOL>        return","gt":"NULL;"}
{"input":"<s> function parseExpressionPattern(pattern: string, value: any, options: IGlobOptions): (ParsedStringPattern | ParsedExpressionPattern) {<EOL>    if (value === false) {<EOL>        return NULL; <EOL>    }<EOL>    const parsedPattern = parsePattern(pattern, options);<EOL>    if (parsedPattern === NULL) {<EOL>        return NULL;<EOL>    }<EOL>    <EOL>    if (typeof value === '<STR_LIT>') {<EOL>        return parsedPattern;<EOL>    }<EOL>    <EOL>    if (","gt":"value) {"}
{"input":"<s> function parseExpressionPattern(pattern: string, value: any, options: IGlobOptions): (ParsedStringPattern | ParsedExpressionPattern) {<EOL>    if (value === false) {<EOL>        return NULL; <EOL>    }<EOL>    const parsedPattern = parsePattern(pattern, options);<EOL>    if (parsedPattern === NULL) {<EOL>        return NULL;<EOL>    }<EOL>    <EOL>    if (typeof value === '<STR_LIT>') {<EOL>        return parsedPattern;<EOL>    }<EOL>    <EOL>    if (value) {<EOL>        const when = (<SiblingClause>value).when;<EOL>        if (typeof when === '<STR_LIT>') {<EOL>            const siblingsPatternToMatchingPattern = (siblingsPattern: SiblingsPattern): string => {<EOL>                let clausePattern = when.replace('<STR_LIT>', siblingsPattern.name);<EOL>                if (","gt":"siblingsPattern.siblings.indexOf(clausePattern) !== -<NUM_LIT>) {"}
{"input":"<s> function parseExpressionPattern(pattern: string, value: any, options: IGlobOptions): (ParsedStringPattern | ParsedExpressionPattern) {<EOL>    if (value === false) {<EOL>        return NULL; <EOL>    }<EOL>    const parsedPattern = parsePattern(pattern, options);<EOL>    if (parsedPattern === NULL) {<EOL>        return NULL;<EOL>    }<EOL>    <EOL>    if (typeof value === '<STR_LIT>') {<EOL>        return parsedPattern;<EOL>    }<EOL>    <EOL>    if (value) {<EOL>        const when = (<SiblingClause>value).when;<EOL>        if (typeof when === '<STR_LIT>') {<EOL>            const siblingsPatternToMatchingPattern = (siblingsPattern: SiblingsPattern): string => {<EOL>                let clausePattern = when.replace('<STR_LIT>', siblingsPattern.name);<EOL>                if (siblingsPattern.siblings.indexOf(clausePattern) !== -<NUM_LIT>) {<EOL>                    return pattern;<EOL>                }<EOL>                else {<EOL>                    return null; <EOL>                }<EOL>            };<EOL>            const result: ParsedExpressionPattern = (path: string, basename: string, siblingsPatternFn: () => SiblingsPattern | TPromise<SiblingsPattern>) => {<EOL>                if (!parsedPattern(path, basename)) {<EOL>                    return null;<EOL>                }<EOL>                const siblingsPattern = siblingsPatternFn();<EOL>                if (!siblingsPattern) {<EOL>                    return null; <EOL>                }<EOL>                return TPromise.is(siblingsPattern) ?<EOL>                    siblingsPattern.then(siblingsPatternToMatchingPattern) :<EOL>","gt":"siblingsPatternToMatchingPattern(siblingsPattern);"}
{"input":"<s> <EOL>function* g(): IterableIterator<any> {<EOL>","gt":"return;"}
{"input":"<s> /**<EOL> * Loads key bindings in from a JSON style object.<EOL> *<EOL> * @param obj the JSON style object with keys being context names and values<EOL> *            being objects mapping key binding strings to command strings<EOL> * @return the object which maps context names to `KeyBindingMapping` objects<EOL> */<EOL>export function loadKeyBindingsFromObject(obj: Object, platform: string): KeyBindingContexts {<EOL>    return new KeyBindingContexts(","gt":"obj, platform);"}
{"input":"<s> export function runAsync() {<EOL>    return buildCoreAsync({ mode: BuildOption.","gt":"Run })"}
{"input":"<s> function saveToCloudAsync(h: Header) {<EOL>    return","gt":"Promise.resolve();"}
{"input":"<s> function fetchTextAsync(filename: string): Promise<Buffer> {<EOL>    if (filename == \"<STR_LIT>\" || !filename)<EOL>        return nodeutil.readResAsync(process.stdin);<EOL>","gt":"if (isScriptId(filename))"}
{"input":"<s> function fetchTextAsync(filename: string): Promise<Buffer> {<EOL>    if (filename == \"<STR_LIT>\" || !filename)<EOL>        return nodeutil.readResAsync(process.stdin);<EOL>    if (isScriptId(filename))<EOL>        filename = Cloud.apiRoot + filename + \"<STR_LIT>\";<EOL>    let m = /^(https:\\/\\/[^\\/]+\\/)([^\\/]+)$/.exec(filename);<EOL>","gt":"let fn2 = \"<STR_LIT>\";"}
{"input":"<s> function fetchTextAsync(filename: string): Promise<Buffer> {<EOL>    if (filename == \"<STR_LIT>\" || !filename)<EOL>        return nodeutil.readResAsync(process.stdin);<EOL>    if (isScriptId(filename))<EOL>        filename = Cloud.apiRoot + filename + \"<STR_LIT>\";<EOL>    let m = /^(https:\\/\\/[^\\/]+\\/)([^\\/]+)$/.exec(filename);<EOL>    let fn2 = \"<STR_LIT>\";<EOL>    if (m) {<EOL>        let id = m[<NUM_LIT>];<EOL>        if (/^api\\//.test(id))<EOL>            id =","gt":"id.slice(<NUM_LIT>);"}
{"input":"<s> function fetchTextAsync(filename: string): Promise<Buffer> {<EOL>    if (filename == \"<STR_LIT>\" || !filename)<EOL>        return nodeutil.readResAsync(process.stdin);<EOL>    if (isScriptId(filename))<EOL>        filename = Cloud.apiRoot + filename + \"<STR_LIT>\";<EOL>    let m = /^(https:\\/\\/[^\\/]+\\/)([^\\/]+)$/.exec(filename);<EOL>    let fn2 = \"<STR_LIT>\";<EOL>    if (m) {<EOL>        let id = m[<NUM_LIT>];<EOL>        if (/^api\\//.test(id))<EOL>            id = id.slice(<NUM_LIT>);<EOL>        if (isScriptId(id)) {<EOL>            fn2 = m[<NUM_LIT>] + \"<STR_LIT>\" + id + \"<STR_LIT>\";<EOL>        }<EOL>    }<EOL>    if (/^https?:/.test(filename)) {<EOL>        pxt.log(`<STR_LIT>`);<EOL>        if (/\\.json$/i.test(","gt":"filename))"}
{"input":"<s> function fetchTextAsync(filename: string): Promise<Buffer> {<EOL>    if (filename == \"<STR_LIT>\" || !filename)<EOL>        return nodeutil.readResAsync(process.stdin);<EOL>    if (isScriptId(filename))<EOL>        filename = Cloud.apiRoot + filename + \"<STR_LIT>\";<EOL>    let m = /^(https:\\/\\/[^\\/]+\\/)([^\\/]+)$/.exec(filename);<EOL>    let fn2 = \"<STR_LIT>\";<EOL>    if (m) {<EOL>        let id = m[<NUM_LIT>];<EOL>        if (/^api\\//.test(id))<EOL>            id = id.slice(<NUM_LIT>);<EOL>        if (isScriptId(id)) {<EOL>            fn2 = m[<NUM_LIT>] + \"<STR_LIT>\" + id + \"<STR_LIT>\";<EOL>        }<EOL>    }<EOL>    if (/^https?:/.test(filename)) {<EOL>        pxt.log(`<STR_LIT>`);<EOL>        if (/\\.json$/i.test(filename))<EOL>            pxt.log(`<STR_LIT>`);<EOL>        return U.requestAsync({ url: filename, allowHttpErrors: !!fn2 })<EOL>            .then(resp => {<EOL>            if (fn2 && (resp.statusCode != <NUM_LIT> || /html/.test(resp.headers[\"<STR_LIT>\"] as string))) {<EOL>                pxt.log(`<STR_LIT>`);<EOL>                return U.","gt":"requestAsync({ url: fn2 });"}
{"input":"<s> function test8(a: boolean | void) {<EOL>    if (typeof a !== \"<STR_LIT>\" && typeof a === \"<STR_LIT>\") {<EOL>","gt":"a;"}
{"input":"<s> function Foo() {<EOL>    this.","gt":"x = <NUM_LIT>;"}
{"input":"<s> /**<EOL> * @Returns the implicit role for a progress tag.<EOL> */<EOL>function getImplicitRoleForProgress(): string {<EOL>","gt":"return '<STR_LIT>';"}
{"input":"<s> function ensureApisInfoAsync(): Promise<void> {<EOL>    if (refreshApis || !cachedApis)<EOL>        return workerOpAsync(\"<STR_LIT>\", {})<EOL>            .then(apis => {<EOL>","gt":"refreshApis = false;"}
{"input":"<s> export function getParseErrorMessage(errorCode: ParseErrorCode): string {<EOL>    switch (errorCode) {<EOL>        case ParseErrorCode.InvalidSymbol: return localize('<STR_LIT>', '<STR_LIT>');<EOL>        case ParseErrorCode.InvalidNumberFormat: return localize('<STR_LIT>', '<STR_LIT>');<EOL>        case ParseErrorCode.PropertyNameExpected: return localize(","gt":"'<STR_LIT>', '<STR_LIT>');"}
{"input":"<s> export function getParseErrorMessage(errorCode: ParseErrorCode): string {<EOL>    switch (errorCode) {<EOL>        case ParseErrorCode.InvalidSymbol: return localize('<STR_LIT>', '<STR_LIT>');<EOL>        case ParseErrorCode.InvalidNumberFormat: return localize('<STR_LIT>', '<STR_LIT>');<EOL>        case ParseErrorCode.PropertyNameExpected: return localize('<STR_LIT>', '<STR_LIT>');<EOL>        case ParseErrorCode.ValueExpected: return localize('<STR_LIT>', '<STR_LIT>');<EOL>        case ParseErrorCode.ColonExpected: return localize('<STR_LIT>', '<STR_LIT>');<EOL>        case ParseErrorCode.CommaExpected: return localize('<STR_LIT>', '<STR_LIT>');<EOL>        case ParseErrorCode.CloseBraceExpected: return localize('<STR_LIT>', '<STR_LIT>');<EOL>        case ParseErrorCode.CloseBracketExpected: return localize('<STR_LIT>', '<STR_LIT>');<EOL>        case ParseErrorCode.","gt":"EndOfFileExpected: return localize('<STR_LIT>', '<STR_LIT>');"}
{"input":"<s> <EOL>function foo() {<EOL>    var","gt":"obj = {"}
{"input":"<s> <EOL>function f() {<EOL>    let a = <NUM_LIT>;<EOL>","gt":"let x: number | undefined;"}
{"input":"<s> /**<EOL> * @Returns the implicit role for a textarea tag.<EOL> */<EOL>function getImplicitRoleForTextarea(): string {<EOL>","gt":"return '<STR_LIT>';"}
{"input":"<s> export function compareByPrefix(one: string, other: string, lookFor: string): number {<EOL>    let elementAName = one.toLowerCase();<EOL>    let elementBName = other.toLowerCase();<EOL>    <EOL>    let elementAPrefixMatch = strings.startsWith(elementAName, lookFor);<EOL>    let elementBPrefixMatch = strings.startsWith(elementBName, lookFor);<EOL>","gt":"if (elementAPrefixMatch !== elementBPrefixMatch) {"}
{"input":"<s> export function compareByPrefix(one: string, other: string, lookFor: string): number {<EOL>    let elementAName = one.toLowerCase();<EOL>    let elementBName = other.toLowerCase();<EOL>    <EOL>    let elementAPrefixMatch = strings.startsWith(elementAName, lookFor);<EOL>    let elementBPrefixMatch = strings.startsWith(elementBName, lookFor);<EOL>    if (elementAPrefixMatch !== elementBPrefixMatch) {<EOL>        return elementAPrefixMatch ? -<NUM_LIT> : <NUM_LIT>;<EOL>    }<EOL>    <EOL>","gt":"else if (elementAPrefixMatch && elementBPrefixMatch) {"}
{"input":"<s> export function compareByPrefix(one: string, other: string, lookFor: string): number {<EOL>    let elementAName = one.toLowerCase();<EOL>    let elementBName = other.toLowerCase();<EOL>    <EOL>    let elementAPrefixMatch = strings.startsWith(elementAName, lookFor);<EOL>    let elementBPrefixMatch = strings.startsWith(elementBName, lookFor);<EOL>    if (elementAPrefixMatch !== elementBPrefixMatch) {<EOL>        return elementAPrefixMatch ? -<NUM_LIT> : <NUM_LIT>;<EOL>    }<EOL>    <EOL>    else if (elementAPrefixMatch && elementBPrefixMatch) {<EOL>        if (elementAName.length < elementBName.length) {<EOL>            return -<NUM_LIT>;<EOL>        }<EOL>        if (","gt":"elementAName.length > elementBName.length) {"}
{"input":"<s> export function dispose<T extends IDisposable>(first: T | T[], ...rest: T[]): T | T[] {<EOL>    if (Array.isArray(first)) {<EOL>        first.forEach(d => d && d.dispose());<EOL>        return [];<EOL>    }<EOL>","gt":"else if (rest.length === <NUM_LIT>) {"}
{"input":"<s> export function dispose<T extends IDisposable>(first: T | T[], ...rest: T[]): T | T[] {<EOL>    if (Array.isArray(first)) {<EOL>        first.forEach(d => d && d.dispose());<EOL>        return [];<EOL>    }<EOL>    else if (rest.length === <NUM_LIT>) {<EOL>        if (first) {<EOL>            first.dispose();<EOL>            return first;<EOL>        }<EOL>        return undefined;<EOL>    }<EOL>    else {<EOL>","gt":"dispose(first);"}
{"input":"<s> function getSplitterPanePositions(splitterNode: SplitterInfoNode, bounds: ClientRect): TabWidgetPosition[] {<EOL>    let result: TabWidgetPosition[] = [];<EOL>    const splitter = splitterNode.splitter;<EOL>    const dividerSize = splitter.getDividerSize();<EOL>    const sizes = splitter.","gt":"getPaneSizes();"}
{"input":"<s> function getSplitterPanePositions(splitterNode: SplitterInfoNode, bounds: ClientRect): TabWidgetPosition[] {<EOL>    let result: TabWidgetPosition[] = [];<EOL>    const splitter = splitterNode.splitter;<EOL>    const dividerSize = splitter.getDividerSize();<EOL>    const sizes = splitter.getPaneSizes();<EOL>","gt":"let edgePosition = <NUM_LIT>;"}
{"input":"<s> function getSplitterPanePositions(splitterNode: SplitterInfoNode, bounds: ClientRect): TabWidgetPosition[] {<EOL>    let result: TabWidgetPosition[] = [];<EOL>    const splitter = splitterNode.splitter;<EOL>    const dividerSize = splitter.getDividerSize();<EOL>    const sizes = splitter.getPaneSizes();<EOL>    let edgePosition = <NUM_LIT>;<EOL>    for (let i = <NUM_LIT>; i < splitterNode.children.length; i++) {<EOL>        const size = sizes[i] + (i !== splitterNode.children.length - <NUM_LIT> ? dividerSize : <NUM_LIT>);<EOL>","gt":"let childBounds: TabWidgetPosition;"}
{"input":"<s> function getSplitterPanePositions(splitterNode: SplitterInfoNode, bounds: ClientRect): TabWidgetPosition[] {<EOL>    let result: TabWidgetPosition[] = [];<EOL>    const splitter = splitterNode.splitter;<EOL>    const dividerSize = splitter.getDividerSize();<EOL>    const sizes = splitter.getPaneSizes();<EOL>    let edgePosition = <NUM_LIT>;<EOL>    for (let i = <NUM_LIT>; i < splitterNode.children.length; i++) {<EOL>        const size = sizes[i] + (i !== splitterNode.children.length - <NUM_LIT> ? dividerSize : <NUM_LIT>);<EOL>        let childBounds: TabWidgetPosition;<EOL>        if (splitterNode.orientation === SplitOrientation.VERTICAL) {<EOL>            childBounds = {<EOL>                top: bounds.top,<EOL>                bottom: bounds.bottom,<EOL>","gt":"height: bounds.height,"}
{"input":"<s> function getSplitterPanePositions(splitterNode: SplitterInfoNode, bounds: ClientRect): TabWidgetPosition[] {<EOL>    let result: TabWidgetPosition[] = [];<EOL>    const splitter = splitterNode.splitter;<EOL>    const dividerSize = splitter.getDividerSize();<EOL>    const sizes = splitter.getPaneSizes();<EOL>    let edgePosition = <NUM_LIT>;<EOL>    for (let i = <NUM_LIT>; i < splitterNode.children.length; i++) {<EOL>        const size = sizes[i] + (i !== splitterNode.children.length - <NUM_LIT> ? dividerSize : <NUM_LIT>);<EOL>        let childBounds: TabWidgetPosition;<EOL>        if (splitterNode.orientation === SplitOrientation.VERTICAL) {<EOL>            childBounds = {<EOL>                top: bounds.top,<EOL>                bottom: bounds.bottom,<EOL>                height: bounds.height,<EOL>                left: bounds.left + edgePosition,<EOL>                right: bounds.left + edgePosition + size,<EOL>                width: size,<EOL>","gt":"tabWidgetInfo: null"}
{"input":"<s> function getSplitterPanePositions(splitterNode: SplitterInfoNode, bounds: ClientRect): TabWidgetPosition[] {<EOL>    let result: TabWidgetPosition[] = [];<EOL>    const splitter = splitterNode.splitter;<EOL>    const dividerSize = splitter.getDividerSize();<EOL>    const sizes = splitter.getPaneSizes();<EOL>    let edgePosition = <NUM_LIT>;<EOL>    for (let i = <NUM_LIT>; i < splitterNode.children.length; i++) {<EOL>        const size = sizes[i] + (i !== splitterNode.children.length - <NUM_LIT> ? dividerSize : <NUM_LIT>);<EOL>        let childBounds: TabWidgetPosition;<EOL>        if (splitterNode.orientation === SplitOrientation.VERTICAL) {<EOL>            childBounds = {<EOL>                top: bounds.top,<EOL>                bottom: bounds.bottom,<EOL>                height: bounds.height,<EOL>                left: bounds.left + edgePosition,<EOL>                right: bounds.left + edgePosition + size,<EOL>                width: size,<EOL>                tabWidgetInfo: null<EOL>            };<EOL>        }<EOL>        else {<EOL>            childBounds = {<EOL>","gt":"left: bounds.left,"}
{"input":"<s> function getSplitterPanePositions(splitterNode: SplitterInfoNode, bounds: ClientRect): TabWidgetPosition[] {<EOL>    let result: TabWidgetPosition[] = [];<EOL>    const splitter = splitterNode.splitter;<EOL>    const dividerSize = splitter.getDividerSize();<EOL>    const sizes = splitter.getPaneSizes();<EOL>    let edgePosition = <NUM_LIT>;<EOL>    for (let i = <NUM_LIT>; i < splitterNode.children.length; i++) {<EOL>        const size = sizes[i] + (i !== splitterNode.children.length - <NUM_LIT> ? dividerSize : <NUM_LIT>);<EOL>        let childBounds: TabWidgetPosition;<EOL>        if (splitterNode.orientation === SplitOrientation.VERTICAL) {<EOL>            childBounds = {<EOL>                top: bounds.top,<EOL>                bottom: bounds.bottom,<EOL>                height: bounds.height,<EOL>                left: bounds.left + edgePosition,<EOL>                right: bounds.left + edgePosition + size,<EOL>                width: size,<EOL>                tabWidgetInfo: null<EOL>            };<EOL>        }<EOL>        else {<EOL>            childBounds = {<EOL>                left: bounds.left,<EOL>                right: bounds.right,<EOL>                width: bounds.width,<EOL>                top: bounds.top + edgePosition,<EOL>                bottom: bounds.top + edgePosition + size,<EOL>                height: size,<EOL>                tabWidgetInfo: null<EOL>            };<EOL>        }<EOL>        const","gt":"childInfo = splitterNode.children[i];"}
{"input":"<s> export function mergeObjects(obj1: any, obj2: any) {<EOL>    if (!obj1) {<EOL>        obj1 = {};<EOL>    }<EOL>    if (!obj2) {<EOL>","gt":"obj2 = {};"}
{"input":"<s> export function mergeObjects(obj1: any, obj2: any) {<EOL>    if (!obj1) {<EOL>        obj1 = {};<EOL>    }<EOL>    if (!obj2) {<EOL>        obj2 = {};<EOL>    }<EOL>    var obj3 = {};<EOL>    for (let attrname in obj1) {<EOL>        (<any>obj3)[attrname] = obj1[attrname];<EOL>    }<EOL>    for (let","gt":"attrname in obj2) {"}
{"input":"<s> function parsePrimaryExpression(): any {<EOL>","gt":"throw \"<STR_LIT>\";"}
{"input":"<s> function foo(...stuff: any[]): any {<EOL>    return","gt":"undefined;"}
{"input":"<s> /**<EOL> * NO DOM<EOL> */<EOL>export function populateNodeData(startCellIndex: number, endCellIndex: number, scrollingDown: boolean, cells: VirtualCell[], records: any[], nodes: VirtualNode[], viewContainer: ViewContainerRef, itmTmp: TemplateRef<VirtualContext>, hdrTmp: TemplateRef<VirtualContext>, ftrTmp: TemplateRef<VirtualContext>): boolean {<EOL>    if (!records || records.length === <NUM_LIT>) {<EOL>","gt":"nodes.length = <NUM_LIT>;"}
{"input":"<s> /**<EOL> * NO DOM<EOL> */<EOL>export function populateNodeData(startCellIndex: number, endCellIndex: number, scrollingDown: boolean, cells: VirtualCell[], records: any[], nodes: VirtualNode[], viewContainer: ViewContainerRef, itmTmp: TemplateRef<VirtualContext>, hdrTmp: TemplateRef<VirtualContext>, ftrTmp: TemplateRef<VirtualContext>): boolean {<EOL>    if (!records || records.length === <NUM_LIT>) {<EOL>        nodes.length = <NUM_LIT>;<EOL>        viewContainer.clear();<EOL>        return true;<EOL>    }<EOL>    const recordsLength = records.length;<EOL>    let hasChanges = false;<EOL>    <EOL>    let","gt":"availableNode: VirtualNode;"}
{"input":"<s> /**<EOL> * NO DOM<EOL> */<EOL>export function populateNodeData(startCellIndex: number, endCellIndex: number, scrollingDown: boolean, cells: VirtualCell[], records: any[], nodes: VirtualNode[], viewContainer: ViewContainerRef, itmTmp: TemplateRef<VirtualContext>, hdrTmp: TemplateRef<VirtualContext>, ftrTmp: TemplateRef<VirtualContext>): boolean {<EOL>    if (!records || records.length === <NUM_LIT>) {<EOL>        nodes.length = <NUM_LIT>;<EOL>        viewContainer.clear();<EOL>        return true;<EOL>    }<EOL>    const recordsLength = records.length;<EOL>    let hasChanges = false;<EOL>    <EOL>    let availableNode: VirtualNode;<EOL>    let cell: VirtualCell;<EOL>    let viewInsertIndex: number = null;<EOL>    let totalNodes = nodes.length;<EOL>    let templateRef: TemplateRef<VirtualContext>;<EOL>    startCellIndex = Math.max(startCellIndex,","gt":"<NUM_LIT>);"}
{"input":"<s> /**<EOL> * NO DOM<EOL> */<EOL>export function populateNodeData(startCellIndex: number, endCellIndex: number, scrollingDown: boolean, cells: VirtualCell[], records: any[], nodes: VirtualNode[], viewContainer: ViewContainerRef, itmTmp: TemplateRef<VirtualContext>, hdrTmp: TemplateRef<VirtualContext>, ftrTmp: TemplateRef<VirtualContext>): boolean {<EOL>    if (!records || records.length === <NUM_LIT>) {<EOL>        nodes.length = <NUM_LIT>;<EOL>        viewContainer.clear();<EOL>        return true;<EOL>    }<EOL>    const recordsLength = records.length;<EOL>    let hasChanges = false;<EOL>    <EOL>    let availableNode: VirtualNode;<EOL>    let cell: VirtualCell;<EOL>    let viewInsertIndex: number = null;<EOL>    let totalNodes = nodes.length;<EOL>    let templateRef: TemplateRef<VirtualContext>;<EOL>    startCellIndex = Math.max(startCellIndex, <NUM_LIT>);<EOL>    endCellIndex = Math.min(endCellIndex, cells.length - <NUM_LIT>);<EOL>    const usedNodes: VirtualNode[] = [];<EOL>    for (var cellIndex = startCellIndex; cellIndex <= endCellIndex; cellIndex++) {<EOL>        cell = cells[cellIndex];<EOL>        availableNode = null;<EOL>        <EOL>","gt":"const existingNode = nodes.find(n => n.cell === cellIndex && n.tmpl === cell.tmpl);"}
{"input":"<s> /**<EOL> * NO DOM<EOL> */<EOL>export function populateNodeData(startCellIndex: number, endCellIndex: number, scrollingDown: boolean, cells: VirtualCell[], records: any[], nodes: VirtualNode[], viewContainer: ViewContainerRef, itmTmp: TemplateRef<VirtualContext>, hdrTmp: TemplateRef<VirtualContext>, ftrTmp: TemplateRef<VirtualContext>): boolean {<EOL>    if (!records || records.length === <NUM_LIT>) {<EOL>        nodes.length = <NUM_LIT>;<EOL>        viewContainer.clear();<EOL>        return true;<EOL>    }<EOL>    const recordsLength = records.length;<EOL>    let hasChanges = false;<EOL>    <EOL>    let availableNode: VirtualNode;<EOL>    let cell: VirtualCell;<EOL>    let viewInsertIndex: number = null;<EOL>    let totalNodes = nodes.length;<EOL>    let templateRef: TemplateRef<VirtualContext>;<EOL>    startCellIndex = Math.max(startCellIndex, <NUM_LIT>);<EOL>    endCellIndex = Math.min(endCellIndex, cells.length - <NUM_LIT>);<EOL>    const usedNodes: VirtualNode[] = [];<EOL>    for (var cellIndex = startCellIndex; cellIndex <= endCellIndex; cellIndex++) {<EOL>        cell = cells[cellIndex];<EOL>        availableNode = null;<EOL>        <EOL>        const existingNode = nodes.find(n => n.cell === cellIndex && n.tmpl === cell.tmpl);<EOL>        if (","gt":"existingNode) {"}
{"input":"<s> /**<EOL> * NO DOM<EOL> */<EOL>export function populateNodeData(startCellIndex: number, endCellIndex: number, scrollingDown: boolean, cells: VirtualCell[], records: any[], nodes: VirtualNode[], viewContainer: ViewContainerRef, itmTmp: TemplateRef<VirtualContext>, hdrTmp: TemplateRef<VirtualContext>, ftrTmp: TemplateRef<VirtualContext>): boolean {<EOL>    if (!records || records.length === <NUM_LIT>) {<EOL>        nodes.length = <NUM_LIT>;<EOL>        viewContainer.clear();<EOL>        return true;<EOL>    }<EOL>    const recordsLength = records.length;<EOL>    let hasChanges = false;<EOL>    <EOL>    let availableNode: VirtualNode;<EOL>    let cell: VirtualCell;<EOL>    let viewInsertIndex: number = null;<EOL>    let totalNodes = nodes.length;<EOL>    let templateRef: TemplateRef<VirtualContext>;<EOL>    startCellIndex = Math.max(startCellIndex, <NUM_LIT>);<EOL>    endCellIndex = Math.min(endCellIndex, cells.length - <NUM_LIT>);<EOL>    const usedNodes: VirtualNode[] = [];<EOL>    for (var cellIndex = startCellIndex; cellIndex <= endCellIndex; cellIndex++) {<EOL>        cell = cells[cellIndex];<EOL>        availableNode = null;<EOL>        <EOL>        const existingNode = nodes.find(n => n.cell === cellIndex && n.tmpl === cell.tmpl);<EOL>        if (existingNode) {<EOL>            if (existingNode.view.context.$implicit === records[cell.record]) {<EOL>                usedNodes.push(existingNode);<EOL>                continue; <EOL>            }<EOL>            console.debug('<STR_LIT>', '<STR_LIT>');<EOL>            availableNode = existingNode; <EOL>        }<EOL>        else {<EOL>            console.debug(","gt":"'<STR_LIT>', '<STR_LIT>');"}
{"input":"<s> /**<EOL> * NO DOM<EOL> */<EOL>export function populateNodeData(startCellIndex: number, endCellIndex: number, scrollingDown: boolean, cells: VirtualCell[], records: any[], nodes: VirtualNode[], viewContainer: ViewContainerRef, itmTmp: TemplateRef<VirtualContext>, hdrTmp: TemplateRef<VirtualContext>, ftrTmp: TemplateRef<VirtualContext>): boolean {<EOL>    if (!records || records.length === <NUM_LIT>) {<EOL>        nodes.length = <NUM_LIT>;<EOL>        viewContainer.clear();<EOL>        return true;<EOL>    }<EOL>    const recordsLength = records.length;<EOL>    let hasChanges = false;<EOL>    <EOL>    let availableNode: VirtualNode;<EOL>    let cell: VirtualCell;<EOL>    let viewInsertIndex: number = null;<EOL>    let totalNodes = nodes.length;<EOL>    let templateRef: TemplateRef<VirtualContext>;<EOL>    startCellIndex = Math.max(startCellIndex, <NUM_LIT>);<EOL>    endCellIndex = Math.min(endCellIndex, cells.length - <NUM_LIT>);<EOL>    const usedNodes: VirtualNode[] = [];<EOL>    for (var cellIndex = startCellIndex; cellIndex <= endCellIndex; cellIndex++) {<EOL>        cell = cells[cellIndex];<EOL>        availableNode = null;<EOL>        <EOL>        const existingNode = nodes.find(n => n.cell === cellIndex && n.tmpl === cell.tmpl);<EOL>        if (existingNode) {<EOL>            if (existingNode.view.context.$implicit === records[cell.record]) {<EOL>                usedNodes.push(existingNode);<EOL>                continue; <EOL>            }<EOL>            console.debug('<STR_LIT>', '<STR_LIT>');<EOL>            availableNode = existingNode; <EOL>        }<EOL>        else {<EOL>            console.debug('<STR_LIT>', '<STR_LIT>');<EOL>            for (var i = <NUM_LIT>; i < totalNodes; i++) {<EOL>                const node = nodes[i];<EOL>                if (cell.tmpl !== node.","gt":"tmpl || i === <NUM_LIT> && cellIndex !== <NUM_LIT>) {"}
{"input":"<s> /**<EOL> * NO DOM<EOL> */<EOL>export function populateNodeData(startCellIndex: number, endCellIndex: number, scrollingDown: boolean, cells: VirtualCell[], records: any[], nodes: VirtualNode[], viewContainer: ViewContainerRef, itmTmp: TemplateRef<VirtualContext>, hdrTmp: TemplateRef<VirtualContext>, ftrTmp: TemplateRef<VirtualContext>): boolean {<EOL>    if (!records || records.length === <NUM_LIT>) {<EOL>        nodes.length = <NUM_LIT>;<EOL>        viewContainer.clear();<EOL>        return true;<EOL>    }<EOL>    const recordsLength = records.length;<EOL>    let hasChanges = false;<EOL>    <EOL>    let availableNode: VirtualNode;<EOL>    let cell: VirtualCell;<EOL>    let viewInsertIndex: number = null;<EOL>    let totalNodes = nodes.length;<EOL>    let templateRef: TemplateRef<VirtualContext>;<EOL>    startCellIndex = Math.max(startCellIndex, <NUM_LIT>);<EOL>    endCellIndex = Math.min(endCellIndex, cells.length - <NUM_LIT>);<EOL>    const usedNodes: VirtualNode[] = [];<EOL>    for (var cellIndex = startCellIndex; cellIndex <= endCellIndex; cellIndex++) {<EOL>        cell = cells[cellIndex];<EOL>        availableNode = null;<EOL>        <EOL>        const existingNode = nodes.find(n => n.cell === cellIndex && n.tmpl === cell.tmpl);<EOL>        if (existingNode) {<EOL>            if (existingNode.view.context.$implicit === records[cell.record]) {<EOL>                usedNodes.push(existingNode);<EOL>                continue; <EOL>            }<EOL>            console.debug('<STR_LIT>', '<STR_LIT>');<EOL>            availableNode = existingNode; <EOL>        }<EOL>        else {<EOL>            console.debug('<STR_LIT>', '<STR_LIT>');<EOL>            for (var i = <NUM_LIT>; i < totalNodes; i++) {<EOL>                const node = nodes[i];<EOL>                if (cell.tmpl !== node.tmpl || i === <NUM_LIT> && cellIndex !== <NUM_LIT>) {<EOL>                    <EOL>                    <EOL>                    <EOL>                    continue;<EOL>                }<EOL>                if (node.cell < startCellIndex || node.cell > endCellIndex) {<EOL>                    if (!availableNode) {<EOL>                        <EOL>                        availableNode = node;<EOL>                        console.debug('<STR_LIT>', '<STR_LIT>',","gt":"availableNode);"}
{"input":"<s> /**<EOL> * NO DOM<EOL> */<EOL>export function populateNodeData(startCellIndex: number, endCellIndex: number, scrollingDown: boolean, cells: VirtualCell[], records: any[], nodes: VirtualNode[], viewContainer: ViewContainerRef, itmTmp: TemplateRef<VirtualContext>, hdrTmp: TemplateRef<VirtualContext>, ftrTmp: TemplateRef<VirtualContext>): boolean {<EOL>    if (!records || records.length === <NUM_LIT>) {<EOL>        nodes.length = <NUM_LIT>;<EOL>        viewContainer.clear();<EOL>        return true;<EOL>    }<EOL>    const recordsLength = records.length;<EOL>    let hasChanges = false;<EOL>    <EOL>    let availableNode: VirtualNode;<EOL>    let cell: VirtualCell;<EOL>    let viewInsertIndex: number = null;<EOL>    let totalNodes = nodes.length;<EOL>    let templateRef: TemplateRef<VirtualContext>;<EOL>    startCellIndex = Math.max(startCellIndex, <NUM_LIT>);<EOL>    endCellIndex = Math.min(endCellIndex, cells.length - <NUM_LIT>);<EOL>    const usedNodes: VirtualNode[] = [];<EOL>    for (var cellIndex = startCellIndex; cellIndex <= endCellIndex; cellIndex++) {<EOL>        cell = cells[cellIndex];<EOL>        availableNode = null;<EOL>        <EOL>        const existingNode = nodes.find(n => n.cell === cellIndex && n.tmpl === cell.tmpl);<EOL>        if (existingNode) {<EOL>            if (existingNode.view.context.$implicit === records[cell.record]) {<EOL>                usedNodes.push(existingNode);<EOL>                continue; <EOL>            }<EOL>            console.debug('<STR_LIT>', '<STR_LIT>');<EOL>            availableNode = existingNode; <EOL>        }<EOL>        else {<EOL>            console.debug('<STR_LIT>', '<STR_LIT>');<EOL>            for (var i = <NUM_LIT>; i < totalNodes; i++) {<EOL>                const node = nodes[i];<EOL>                if (cell.tmpl !== node.tmpl || i === <NUM_LIT> && cellIndex !== <NUM_LIT>) {<EOL>                    <EOL>                    <EOL>                    <EOL>                    continue;<EOL>                }<EOL>                if (node.cell < startCellIndex || node.cell > endCellIndex) {<EOL>                    if (!availableNode) {<EOL>                        <EOL>                        availableNode = node;<EOL>                        console.debug('<STR_LIT>', '<STR_LIT>', availableNode);<EOL>                    }<EOL>                    else if (scrollingDown) {<EOL>                        <EOL>                        if (node.cell < availableNode.cell) {<EOL>                            availableNode = node;<EOL>                            console.debug('<STR_LIT>', '<STR_LIT>', availableNode);<EOL>                        }<EOL>                    }<EOL>                    else {<EOL>                        <EOL>                        if (node.cell > availableNode.cell) {<EOL>                            availableNode = node;<EOL>                            console.debug('<STR_LIT>', '<STR_LIT>',","gt":"availableNode);"}
{"input":"<s> /**<EOL> * NO DOM<EOL> */<EOL>export function populateNodeData(startCellIndex: number, endCellIndex: number, scrollingDown: boolean, cells: VirtualCell[], records: any[], nodes: VirtualNode[], viewContainer: ViewContainerRef, itmTmp: TemplateRef<VirtualContext>, hdrTmp: TemplateRef<VirtualContext>, ftrTmp: TemplateRef<VirtualContext>): boolean {<EOL>    if (!records || records.length === <NUM_LIT>) {<EOL>        nodes.length = <NUM_LIT>;<EOL>        viewContainer.clear();<EOL>        return true;<EOL>    }<EOL>    const recordsLength = records.length;<EOL>    let hasChanges = false;<EOL>    <EOL>    let availableNode: VirtualNode;<EOL>    let cell: VirtualCell;<EOL>    let viewInsertIndex: number = null;<EOL>    let totalNodes = nodes.length;<EOL>    let templateRef: TemplateRef<VirtualContext>;<EOL>    startCellIndex = Math.max(startCellIndex, <NUM_LIT>);<EOL>    endCellIndex = Math.min(endCellIndex, cells.length - <NUM_LIT>);<EOL>    const usedNodes: VirtualNode[] = [];<EOL>    for (var cellIndex = startCellIndex; cellIndex <= endCellIndex; cellIndex++) {<EOL>        cell = cells[cellIndex];<EOL>        availableNode = null;<EOL>        <EOL>        const existingNode = nodes.find(n => n.cell === cellIndex && n.tmpl === cell.tmpl);<EOL>        if (existingNode) {<EOL>            if (existingNode.view.context.$implicit === records[cell.record]) {<EOL>                usedNodes.push(existingNode);<EOL>                continue; <EOL>            }<EOL>            console.debug('<STR_LIT>', '<STR_LIT>');<EOL>            availableNode = existingNode; <EOL>        }<EOL>        else {<EOL>            console.debug('<STR_LIT>', '<STR_LIT>');<EOL>            for (var i = <NUM_LIT>; i < totalNodes; i++) {<EOL>                const node = nodes[i];<EOL>                if (cell.tmpl !== node.tmpl || i === <NUM_LIT> && cellIndex !== <NUM_LIT>) {<EOL>                    <EOL>                    <EOL>                    <EOL>                    continue;<EOL>                }<EOL>                if (node.cell < startCellIndex || node.cell > endCellIndex) {<EOL>                    if (!availableNode) {<EOL>                        <EOL>                        availableNode = node;<EOL>                        console.debug('<STR_LIT>', '<STR_LIT>', availableNode);<EOL>                    }<EOL>                    else if (scrollingDown) {<EOL>                        <EOL>                        if (node.cell < availableNode.cell) {<EOL>                            availableNode = node;<EOL>                            console.debug('<STR_LIT>', '<STR_LIT>', availableNode);<EOL>                        }<EOL>                    }<EOL>                    else {<EOL>                        <EOL>                        if (node.cell > availableNode.cell) {<EOL>                            availableNode = node;<EOL>                            console.debug('<STR_LIT>', '<STR_LIT>', availableNode);<EOL>                        }<EOL>                    }<EOL>                }<EOL>            }<EOL>        }<EOL>        if (!availableNode) {<EOL>            <EOL>            <EOL>            if (","gt":"viewInsertIndex === null) {"}
{"input":"<s> /**<EOL> * NO DOM<EOL> */<EOL>export function populateNodeData(startCellIndex: number, endCellIndex: number, scrollingDown: boolean, cells: VirtualCell[], records: any[], nodes: VirtualNode[], viewContainer: ViewContainerRef, itmTmp: TemplateRef<VirtualContext>, hdrTmp: TemplateRef<VirtualContext>, ftrTmp: TemplateRef<VirtualContext>): boolean {<EOL>    if (!records || records.length === <NUM_LIT>) {<EOL>        nodes.length = <NUM_LIT>;<EOL>        viewContainer.clear();<EOL>        return true;<EOL>    }<EOL>    const recordsLength = records.length;<EOL>    let hasChanges = false;<EOL>    <EOL>    let availableNode: VirtualNode;<EOL>    let cell: VirtualCell;<EOL>    let viewInsertIndex: number = null;<EOL>    let totalNodes = nodes.length;<EOL>    let templateRef: TemplateRef<VirtualContext>;<EOL>    startCellIndex = Math.max(startCellIndex, <NUM_LIT>);<EOL>    endCellIndex = Math.min(endCellIndex, cells.length - <NUM_LIT>);<EOL>    const usedNodes: VirtualNode[] = [];<EOL>    for (var cellIndex = startCellIndex; cellIndex <= endCellIndex; cellIndex++) {<EOL>        cell = cells[cellIndex];<EOL>        availableNode = null;<EOL>        <EOL>        const existingNode = nodes.find(n => n.cell === cellIndex && n.tmpl === cell.tmpl);<EOL>        if (existingNode) {<EOL>            if (existingNode.view.context.$implicit === records[cell.record]) {<EOL>                usedNodes.push(existingNode);<EOL>                continue; <EOL>            }<EOL>            console.debug('<STR_LIT>', '<STR_LIT>');<EOL>            availableNode = existingNode; <EOL>        }<EOL>        else {<EOL>            console.debug('<STR_LIT>', '<STR_LIT>');<EOL>            for (var i = <NUM_LIT>; i < totalNodes; i++) {<EOL>                const node = nodes[i];<EOL>                if (cell.tmpl !== node.tmpl || i === <NUM_LIT> && cellIndex !== <NUM_LIT>) {<EOL>                    <EOL>                    <EOL>                    <EOL>                    continue;<EOL>                }<EOL>                if (node.cell < startCellIndex || node.cell > endCellIndex) {<EOL>                    if (!availableNode) {<EOL>                        <EOL>                        availableNode = node;<EOL>                        console.debug('<STR_LIT>', '<STR_LIT>', availableNode);<EOL>                    }<EOL>                    else if (scrollingDown) {<EOL>                        <EOL>                        if (node.cell < availableNode.cell) {<EOL>                            availableNode = node;<EOL>                            console.debug('<STR_LIT>', '<STR_LIT>', availableNode);<EOL>                        }<EOL>                    }<EOL>                    else {<EOL>                        <EOL>                        if (node.cell > availableNode.cell) {<EOL>                            availableNode = node;<EOL>                            console.debug('<STR_LIT>', '<STR_LIT>', availableNode);<EOL>                        }<EOL>                    }<EOL>                }<EOL>            }<EOL>        }<EOL>        if (!availableNode) {<EOL>            <EOL>            <EOL>            if (viewInsertIndex === null) {<EOL>                viewInsertIndex = -<NUM_LIT>;<EOL>                for (var j = totalNodes - <NUM_LIT>; j >= <NUM_LIT>; j--) {<EOL>","gt":"const node = nodes[j];"}
{"input":"<s> /**<EOL> * NO DOM<EOL> */<EOL>export function populateNodeData(startCellIndex: number, endCellIndex: number, scrollingDown: boolean, cells: VirtualCell[], records: any[], nodes: VirtualNode[], viewContainer: ViewContainerRef, itmTmp: TemplateRef<VirtualContext>, hdrTmp: TemplateRef<VirtualContext>, ftrTmp: TemplateRef<VirtualContext>): boolean {<EOL>    if (!records || records.length === <NUM_LIT>) {<EOL>        nodes.length = <NUM_LIT>;<EOL>        viewContainer.clear();<EOL>        return true;<EOL>    }<EOL>    const recordsLength = records.length;<EOL>    let hasChanges = false;<EOL>    <EOL>    let availableNode: VirtualNode;<EOL>    let cell: VirtualCell;<EOL>    let viewInsertIndex: number = null;<EOL>    let totalNodes = nodes.length;<EOL>    let templateRef: TemplateRef<VirtualContext>;<EOL>    startCellIndex = Math.max(startCellIndex, <NUM_LIT>);<EOL>    endCellIndex = Math.min(endCellIndex, cells.length - <NUM_LIT>);<EOL>    const usedNodes: VirtualNode[] = [];<EOL>    for (var cellIndex = startCellIndex; cellIndex <= endCellIndex; cellIndex++) {<EOL>        cell = cells[cellIndex];<EOL>        availableNode = null;<EOL>        <EOL>        const existingNode = nodes.find(n => n.cell === cellIndex && n.tmpl === cell.tmpl);<EOL>        if (existingNode) {<EOL>            if (existingNode.view.context.$implicit === records[cell.record]) {<EOL>                usedNodes.push(existingNode);<EOL>                continue; <EOL>            }<EOL>            console.debug('<STR_LIT>', '<STR_LIT>');<EOL>            availableNode = existingNode; <EOL>        }<EOL>        else {<EOL>            console.debug('<STR_LIT>', '<STR_LIT>');<EOL>            for (var i = <NUM_LIT>; i < totalNodes; i++) {<EOL>                const node = nodes[i];<EOL>                if (cell.tmpl !== node.tmpl || i === <NUM_LIT> && cellIndex !== <NUM_LIT>) {<EOL>                    <EOL>                    <EOL>                    <EOL>                    continue;<EOL>                }<EOL>                if (node.cell < startCellIndex || node.cell > endCellIndex) {<EOL>                    if (!availableNode) {<EOL>                        <EOL>                        availableNode = node;<EOL>                        console.debug('<STR_LIT>', '<STR_LIT>', availableNode);<EOL>                    }<EOL>                    else if (scrollingDown) {<EOL>                        <EOL>                        if (node.cell < availableNode.cell) {<EOL>                            availableNode = node;<EOL>                            console.debug('<STR_LIT>', '<STR_LIT>', availableNode);<EOL>                        }<EOL>                    }<EOL>                    else {<EOL>                        <EOL>                        if (node.cell > availableNode.cell) {<EOL>                            availableNode = node;<EOL>                            console.debug('<STR_LIT>', '<STR_LIT>', availableNode);<EOL>                        }<EOL>                    }<EOL>                }<EOL>            }<EOL>        }<EOL>        if (!availableNode) {<EOL>            <EOL>            <EOL>            if (viewInsertIndex === null) {<EOL>                viewInsertIndex = -<NUM_LIT>;<EOL>                for (var j = totalNodes - <NUM_LIT>; j >= <NUM_LIT>; j--) {<EOL>                    const node = nodes[j];<EOL>                    if (node) {<EOL>                        viewInsertIndex = viewContainer.indexOf(node.view);<EOL>                        break;<EOL>                    }<EOL>                }<EOL>            }<EOL>            <EOL>            templateRef = cell.tmpl === TemplateType.Header ? hdrTmp : cell.tmpl === TemplateType.Footer ? ftrTmp : itmTmp;<EOL>            if (!templateRef) {<EOL>                console.error(`<STR_LIT>`);<EOL>","gt":"continue;"}
{"input":"<s> /**<EOL> * NO DOM<EOL> */<EOL>export function populateNodeData(startCellIndex: number, endCellIndex: number, scrollingDown: boolean, cells: VirtualCell[], records: any[], nodes: VirtualNode[], viewContainer: ViewContainerRef, itmTmp: TemplateRef<VirtualContext>, hdrTmp: TemplateRef<VirtualContext>, ftrTmp: TemplateRef<VirtualContext>): boolean {<EOL>    if (!records || records.length === <NUM_LIT>) {<EOL>        nodes.length = <NUM_LIT>;<EOL>        viewContainer.clear();<EOL>        return true;<EOL>    }<EOL>    const recordsLength = records.length;<EOL>    let hasChanges = false;<EOL>    <EOL>    let availableNode: VirtualNode;<EOL>    let cell: VirtualCell;<EOL>    let viewInsertIndex: number = null;<EOL>    let totalNodes = nodes.length;<EOL>    let templateRef: TemplateRef<VirtualContext>;<EOL>    startCellIndex = Math.max(startCellIndex, <NUM_LIT>);<EOL>    endCellIndex = Math.min(endCellIndex, cells.length - <NUM_LIT>);<EOL>    const usedNodes: VirtualNode[] = [];<EOL>    for (var cellIndex = startCellIndex; cellIndex <= endCellIndex; cellIndex++) {<EOL>        cell = cells[cellIndex];<EOL>        availableNode = null;<EOL>        <EOL>        const existingNode = nodes.find(n => n.cell === cellIndex && n.tmpl === cell.tmpl);<EOL>        if (existingNode) {<EOL>            if (existingNode.view.context.$implicit === records[cell.record]) {<EOL>                usedNodes.push(existingNode);<EOL>                continue; <EOL>            }<EOL>            console.debug('<STR_LIT>', '<STR_LIT>');<EOL>            availableNode = existingNode; <EOL>        }<EOL>        else {<EOL>            console.debug('<STR_LIT>', '<STR_LIT>');<EOL>            for (var i = <NUM_LIT>; i < totalNodes; i++) {<EOL>                const node = nodes[i];<EOL>                if (cell.tmpl !== node.tmpl || i === <NUM_LIT> && cellIndex !== <NUM_LIT>) {<EOL>                    <EOL>                    <EOL>                    <EOL>                    continue;<EOL>                }<EOL>                if (node.cell < startCellIndex || node.cell > endCellIndex) {<EOL>                    if (!availableNode) {<EOL>                        <EOL>                        availableNode = node;<EOL>                        console.debug('<STR_LIT>', '<STR_LIT>', availableNode);<EOL>                    }<EOL>                    else if (scrollingDown) {<EOL>                        <EOL>                        if (node.cell < availableNode.cell) {<EOL>                            availableNode = node;<EOL>                            console.debug('<STR_LIT>', '<STR_LIT>', availableNode);<EOL>                        }<EOL>                    }<EOL>                    else {<EOL>                        <EOL>                        if (node.cell > availableNode.cell) {<EOL>                            availableNode = node;<EOL>                            console.debug('<STR_LIT>', '<STR_LIT>', availableNode);<EOL>                        }<EOL>                    }<EOL>                }<EOL>            }<EOL>        }<EOL>        if (!availableNode) {<EOL>            <EOL>            <EOL>            if (viewInsertIndex === null) {<EOL>                viewInsertIndex = -<NUM_LIT>;<EOL>                for (var j = totalNodes - <NUM_LIT>; j >= <NUM_LIT>; j--) {<EOL>                    const node = nodes[j];<EOL>                    if (node) {<EOL>                        viewInsertIndex = viewContainer.indexOf(node.view);<EOL>                        break;<EOL>                    }<EOL>                }<EOL>            }<EOL>            <EOL>            templateRef = cell.tmpl === TemplateType.Header ? hdrTmp : cell.tmpl === TemplateType.Footer ? ftrTmp : itmTmp;<EOL>            if (!templateRef) {<EOL>                console.error(`<STR_LIT>`);<EOL>                continue;<EOL>            }<EOL>            availableNode = {<EOL>","gt":"tmpl: cell.tmpl,"}
{"input":"<s> /**<EOL> * NO DOM<EOL> */<EOL>export function populateNodeData(startCellIndex: number, endCellIndex: number, scrollingDown: boolean, cells: VirtualCell[], records: any[], nodes: VirtualNode[], viewContainer: ViewContainerRef, itmTmp: TemplateRef<VirtualContext>, hdrTmp: TemplateRef<VirtualContext>, ftrTmp: TemplateRef<VirtualContext>): boolean {<EOL>    if (!records || records.length === <NUM_LIT>) {<EOL>        nodes.length = <NUM_LIT>;<EOL>        viewContainer.clear();<EOL>        return true;<EOL>    }<EOL>    const recordsLength = records.length;<EOL>    let hasChanges = false;<EOL>    <EOL>    let availableNode: VirtualNode;<EOL>    let cell: VirtualCell;<EOL>    let viewInsertIndex: number = null;<EOL>    let totalNodes = nodes.length;<EOL>    let templateRef: TemplateRef<VirtualContext>;<EOL>    startCellIndex = Math.max(startCellIndex, <NUM_LIT>);<EOL>    endCellIndex = Math.min(endCellIndex, cells.length - <NUM_LIT>);<EOL>    const usedNodes: VirtualNode[] = [];<EOL>    for (var cellIndex = startCellIndex; cellIndex <= endCellIndex; cellIndex++) {<EOL>        cell = cells[cellIndex];<EOL>        availableNode = null;<EOL>        <EOL>        const existingNode = nodes.find(n => n.cell === cellIndex && n.tmpl === cell.tmpl);<EOL>        if (existingNode) {<EOL>            if (existingNode.view.context.$implicit === records[cell.record]) {<EOL>                usedNodes.push(existingNode);<EOL>                continue; <EOL>            }<EOL>            console.debug('<STR_LIT>', '<STR_LIT>');<EOL>            availableNode = existingNode; <EOL>        }<EOL>        else {<EOL>            console.debug('<STR_LIT>', '<STR_LIT>');<EOL>            for (var i = <NUM_LIT>; i < totalNodes; i++) {<EOL>                const node = nodes[i];<EOL>                if (cell.tmpl !== node.tmpl || i === <NUM_LIT> && cellIndex !== <NUM_LIT>) {<EOL>                    <EOL>                    <EOL>                    <EOL>                    continue;<EOL>                }<EOL>                if (node.cell < startCellIndex || node.cell > endCellIndex) {<EOL>                    if (!availableNode) {<EOL>                        <EOL>                        availableNode = node;<EOL>                        console.debug('<STR_LIT>', '<STR_LIT>', availableNode);<EOL>                    }<EOL>                    else if (scrollingDown) {<EOL>                        <EOL>                        if (node.cell < availableNode.cell) {<EOL>                            availableNode = node;<EOL>                            console.debug('<STR_LIT>', '<STR_LIT>', availableNode);<EOL>                        }<EOL>                    }<EOL>                    else {<EOL>                        <EOL>                        if (node.cell > availableNode.cell) {<EOL>                            availableNode = node;<EOL>                            console.debug('<STR_LIT>', '<STR_LIT>', availableNode);<EOL>                        }<EOL>                    }<EOL>                }<EOL>            }<EOL>        }<EOL>        if (!availableNode) {<EOL>            <EOL>            <EOL>            if (viewInsertIndex === null) {<EOL>                viewInsertIndex = -<NUM_LIT>;<EOL>                for (var j = totalNodes - <NUM_LIT>; j >= <NUM_LIT>; j--) {<EOL>                    const node = nodes[j];<EOL>                    if (node) {<EOL>                        viewInsertIndex = viewContainer.indexOf(node.view);<EOL>                        break;<EOL>                    }<EOL>                }<EOL>            }<EOL>            <EOL>            templateRef = cell.tmpl === TemplateType.Header ? hdrTmp : cell.tmpl === TemplateType.Footer ? ftrTmp : itmTmp;<EOL>            if (!templateRef) {<EOL>                console.error(`<STR_LIT>`);<EOL>                continue;<EOL>            }<EOL>            availableNode = {<EOL>                tmpl: cell.tmpl,<EOL>                view: viewContainer.createEmbeddedView(templateRef, new VirtualContext(null, null, null), viewInsertIndex)<EOL>            };<EOL>            totalNodes = nodes.push(availableNode);<EOL>        }<EOL>        <EOL>        availableNode.","gt":"cell ="}
{"input":"<s> /**<EOL> * NO DOM<EOL> */<EOL>export function populateNodeData(startCellIndex: number, endCellIndex: number, scrollingDown: boolean, cells: VirtualCell[], records: any[], nodes: VirtualNode[], viewContainer: ViewContainerRef, itmTmp: TemplateRef<VirtualContext>, hdrTmp: TemplateRef<VirtualContext>, ftrTmp: TemplateRef<VirtualContext>): boolean {<EOL>    if (!records || records.length === <NUM_LIT>) {<EOL>        nodes.length = <NUM_LIT>;<EOL>        viewContainer.clear();<EOL>        return true;<EOL>    }<EOL>    const recordsLength = records.length;<EOL>    let hasChanges = false;<EOL>    <EOL>    let availableNode: VirtualNode;<EOL>    let cell: VirtualCell;<EOL>    let viewInsertIndex: number = null;<EOL>    let totalNodes = nodes.length;<EOL>    let templateRef: TemplateRef<VirtualContext>;<EOL>    startCellIndex = Math.max(startCellIndex, <NUM_LIT>);<EOL>    endCellIndex = Math.min(endCellIndex, cells.length - <NUM_LIT>);<EOL>    const usedNodes: VirtualNode[] = [];<EOL>    for (var cellIndex = startCellIndex; cellIndex <= endCellIndex; cellIndex++) {<EOL>        cell = cells[cellIndex];<EOL>        availableNode = null;<EOL>        <EOL>        const existingNode = nodes.find(n => n.cell === cellIndex && n.tmpl === cell.tmpl);<EOL>        if (existingNode) {<EOL>            if (existingNode.view.context.$implicit === records[cell.record]) {<EOL>                usedNodes.push(existingNode);<EOL>                continue; <EOL>            }<EOL>            console.debug('<STR_LIT>', '<STR_LIT>');<EOL>            availableNode = existingNode; <EOL>        }<EOL>        else {<EOL>            console.debug('<STR_LIT>', '<STR_LIT>');<EOL>            for (var i = <NUM_LIT>; i < totalNodes; i++) {<EOL>                const node = nodes[i];<EOL>                if (cell.tmpl !== node.tmpl || i === <NUM_LIT> && cellIndex !== <NUM_LIT>) {<EOL>                    <EOL>                    <EOL>                    <EOL>                    continue;<EOL>                }<EOL>                if (node.cell < startCellIndex || node.cell > endCellIndex) {<EOL>                    if (!availableNode) {<EOL>                        <EOL>                        availableNode = node;<EOL>                        console.debug('<STR_LIT>', '<STR_LIT>', availableNode);<EOL>                    }<EOL>                    else if (scrollingDown) {<EOL>                        <EOL>                        if (node.cell < availableNode.cell) {<EOL>                            availableNode = node;<EOL>                            console.debug('<STR_LIT>', '<STR_LIT>', availableNode);<EOL>                        }<EOL>                    }<EOL>                    else {<EOL>                        <EOL>                        if (node.cell > availableNode.cell) {<EOL>                            availableNode = node;<EOL>                            console.debug('<STR_LIT>', '<STR_LIT>', availableNode);<EOL>                        }<EOL>                    }<EOL>                }<EOL>            }<EOL>        }<EOL>        if (!availableNode) {<EOL>            <EOL>            <EOL>            if (viewInsertIndex === null) {<EOL>                viewInsertIndex = -<NUM_LIT>;<EOL>                for (var j = totalNodes - <NUM_LIT>; j >= <NUM_LIT>; j--) {<EOL>                    const node = nodes[j];<EOL>                    if (node) {<EOL>                        viewInsertIndex = viewContainer.indexOf(node.view);<EOL>                        break;<EOL>                    }<EOL>                }<EOL>            }<EOL>            <EOL>            templateRef = cell.tmpl === TemplateType.Header ? hdrTmp : cell.tmpl === TemplateType.Footer ? ftrTmp : itmTmp;<EOL>            if (!templateRef) {<EOL>                console.error(`<STR_LIT>`);<EOL>                continue;<EOL>            }<EOL>            availableNode = {<EOL>                tmpl: cell.tmpl,<EOL>                view: viewContainer.createEmbeddedView(templateRef, new VirtualContext(null, null, null), viewInsertIndex)<EOL>            };<EOL>            totalNodes = nodes.push(availableNode);<EOL>        }<EOL>        <EOL>        availableNode.cell =","gt":"cellIndex;"}
{"input":"<s> /**<EOL> * NO DOM<EOL> */<EOL>export function populateNodeData(startCellIndex: number, endCellIndex: number, scrollingDown: boolean, cells: VirtualCell[], records: any[], nodes: VirtualNode[], viewContainer: ViewContainerRef, itmTmp: TemplateRef<VirtualContext>, hdrTmp: TemplateRef<VirtualContext>, ftrTmp: TemplateRef<VirtualContext>): boolean {<EOL>    if (!records || records.length === <NUM_LIT>) {<EOL>        nodes.length = <NUM_LIT>;<EOL>        viewContainer.clear();<EOL>        return true;<EOL>    }<EOL>    const recordsLength = records.length;<EOL>    let hasChanges = false;<EOL>    <EOL>    let availableNode: VirtualNode;<EOL>    let cell: VirtualCell;<EOL>    let viewInsertIndex: number = null;<EOL>    let totalNodes = nodes.length;<EOL>    let templateRef: TemplateRef<VirtualContext>;<EOL>    startCellIndex = Math.max(startCellIndex, <NUM_LIT>);<EOL>    endCellIndex = Math.min(endCellIndex, cells.length - <NUM_LIT>);<EOL>    const usedNodes: VirtualNode[] = [];<EOL>    for (var cellIndex = startCellIndex; cellIndex <= endCellIndex; cellIndex++) {<EOL>        cell = cells[cellIndex];<EOL>        availableNode = null;<EOL>        <EOL>        const existingNode = nodes.find(n => n.cell === cellIndex && n.tmpl === cell.tmpl);<EOL>        if (existingNode) {<EOL>            if (existingNode.view.context.$implicit === records[cell.record]) {<EOL>                usedNodes.push(existingNode);<EOL>                continue; <EOL>            }<EOL>            console.debug('<STR_LIT>', '<STR_LIT>');<EOL>            availableNode = existingNode; <EOL>        }<EOL>        else {<EOL>            console.debug('<STR_LIT>', '<STR_LIT>');<EOL>            for (var i = <NUM_LIT>; i < totalNodes; i++) {<EOL>                const node = nodes[i];<EOL>                if (cell.tmpl !== node.tmpl || i === <NUM_LIT> && cellIndex !== <NUM_LIT>) {<EOL>                    <EOL>                    <EOL>                    <EOL>                    continue;<EOL>                }<EOL>                if (node.cell < startCellIndex || node.cell > endCellIndex) {<EOL>                    if (!availableNode) {<EOL>                        <EOL>                        availableNode = node;<EOL>                        console.debug('<STR_LIT>', '<STR_LIT>', availableNode);<EOL>                    }<EOL>                    else if (scrollingDown) {<EOL>                        <EOL>                        if (node.cell < availableNode.cell) {<EOL>                            availableNode = node;<EOL>                            console.debug('<STR_LIT>', '<STR_LIT>', availableNode);<EOL>                        }<EOL>                    }<EOL>                    else {<EOL>                        <EOL>                        if (node.cell > availableNode.cell) {<EOL>                            availableNode = node;<EOL>                            console.debug('<STR_LIT>', '<STR_LIT>', availableNode);<EOL>                        }<EOL>                    }<EOL>                }<EOL>            }<EOL>        }<EOL>        if (!availableNode) {<EOL>            <EOL>            <EOL>            if (viewInsertIndex === null) {<EOL>                viewInsertIndex = -<NUM_LIT>;<EOL>                for (var j = totalNodes - <NUM_LIT>; j >= <NUM_LIT>; j--) {<EOL>                    const node = nodes[j];<EOL>                    if (node) {<EOL>                        viewInsertIndex = viewContainer.indexOf(node.view);<EOL>                        break;<EOL>                    }<EOL>                }<EOL>            }<EOL>            <EOL>            templateRef = cell.tmpl === TemplateType.Header ? hdrTmp : cell.tmpl === TemplateType.Footer ? ftrTmp : itmTmp;<EOL>            if (!templateRef) {<EOL>                console.error(`<STR_LIT>`);<EOL>                continue;<EOL>            }<EOL>            availableNode = {<EOL>                tmpl: cell.tmpl,<EOL>                view: viewContainer.createEmbeddedView(templateRef, new VirtualContext(null, null, null), viewInsertIndex)<EOL>            };<EOL>            totalNodes = nodes.push(availableNode);<EOL>        }<EOL>        <EOL>        availableNode.cell = cellIndex;<EOL>        <EOL>        var context = availableNode.view.context;<EOL>        context.$implicit = cell.data || records[cell.record];<EOL>        context.index = cellIndex;<EOL>","gt":"context.count = recordsLength;"}
{"input":"<s> /**<EOL> * NO DOM<EOL> */<EOL>export function populateNodeData(startCellIndex: number, endCellIndex: number, scrollingDown: boolean, cells: VirtualCell[], records: any[], nodes: VirtualNode[], viewContainer: ViewContainerRef, itmTmp: TemplateRef<VirtualContext>, hdrTmp: TemplateRef<VirtualContext>, ftrTmp: TemplateRef<VirtualContext>): boolean {<EOL>    if (!records || records.length === <NUM_LIT>) {<EOL>        nodes.length = <NUM_LIT>;<EOL>        viewContainer.clear();<EOL>        return true;<EOL>    }<EOL>    const recordsLength = records.length;<EOL>    let hasChanges = false;<EOL>    <EOL>    let availableNode: VirtualNode;<EOL>    let cell: VirtualCell;<EOL>    let viewInsertIndex: number = null;<EOL>    let totalNodes = nodes.length;<EOL>    let templateRef: TemplateRef<VirtualContext>;<EOL>    startCellIndex = Math.max(startCellIndex, <NUM_LIT>);<EOL>    endCellIndex = Math.min(endCellIndex, cells.length - <NUM_LIT>);<EOL>    const usedNodes: VirtualNode[] = [];<EOL>    for (var cellIndex = startCellIndex; cellIndex <= endCellIndex; cellIndex++) {<EOL>        cell = cells[cellIndex];<EOL>        availableNode = null;<EOL>        <EOL>        const existingNode = nodes.find(n => n.cell === cellIndex && n.tmpl === cell.tmpl);<EOL>        if (existingNode) {<EOL>            if (existingNode.view.context.$implicit === records[cell.record]) {<EOL>                usedNodes.push(existingNode);<EOL>                continue; <EOL>            }<EOL>            console.debug('<STR_LIT>', '<STR_LIT>');<EOL>            availableNode = existingNode; <EOL>        }<EOL>        else {<EOL>            console.debug('<STR_LIT>', '<STR_LIT>');<EOL>            for (var i = <NUM_LIT>; i < totalNodes; i++) {<EOL>                const node = nodes[i];<EOL>                if (cell.tmpl !== node.tmpl || i === <NUM_LIT> && cellIndex !== <NUM_LIT>) {<EOL>                    <EOL>                    <EOL>                    <EOL>                    continue;<EOL>                }<EOL>                if (node.cell < startCellIndex || node.cell > endCellIndex) {<EOL>                    if (!availableNode) {<EOL>                        <EOL>                        availableNode = node;<EOL>                        console.debug('<STR_LIT>', '<STR_LIT>', availableNode);<EOL>                    }<EOL>                    else if (scrollingDown) {<EOL>                        <EOL>                        if (node.cell < availableNode.cell) {<EOL>                            availableNode = node;<EOL>                            console.debug('<STR_LIT>', '<STR_LIT>', availableNode);<EOL>                        }<EOL>                    }<EOL>                    else {<EOL>                        <EOL>                        if (node.cell > availableNode.cell) {<EOL>                            availableNode = node;<EOL>                            console.debug('<STR_LIT>', '<STR_LIT>', availableNode);<EOL>                        }<EOL>                    }<EOL>                }<EOL>            }<EOL>        }<EOL>        if (!availableNode) {<EOL>            <EOL>            <EOL>            if (viewInsertIndex === null) {<EOL>                viewInsertIndex = -<NUM_LIT>;<EOL>                for (var j = totalNodes - <NUM_LIT>; j >= <NUM_LIT>; j--) {<EOL>                    const node = nodes[j];<EOL>                    if (node) {<EOL>                        viewInsertIndex = viewContainer.indexOf(node.view);<EOL>                        break;<EOL>                    }<EOL>                }<EOL>            }<EOL>            <EOL>            templateRef = cell.tmpl === TemplateType.Header ? hdrTmp : cell.tmpl === TemplateType.Footer ? ftrTmp : itmTmp;<EOL>            if (!templateRef) {<EOL>                console.error(`<STR_LIT>`);<EOL>                continue;<EOL>            }<EOL>            availableNode = {<EOL>                tmpl: cell.tmpl,<EOL>                view: viewContainer.createEmbeddedView(templateRef, new VirtualContext(null, null, null), viewInsertIndex)<EOL>            };<EOL>            totalNodes = nodes.push(availableNode);<EOL>        }<EOL>        <EOL>        availableNode.cell = cellIndex;<EOL>        <EOL>        var context = availableNode.view.context;<EOL>        context.$implicit = cell.data || records[cell.record];<EOL>        context.index = cellIndex;<EOL>        context.count = recordsLength;<EOL>        availableNode.hasChanges =","gt":"true;"}
{"input":"<s> /**<EOL> * NO DOM<EOL> */<EOL>export function populateNodeData(startCellIndex: number, endCellIndex: number, scrollingDown: boolean, cells: VirtualCell[], records: any[], nodes: VirtualNode[], viewContainer: ViewContainerRef, itmTmp: TemplateRef<VirtualContext>, hdrTmp: TemplateRef<VirtualContext>, ftrTmp: TemplateRef<VirtualContext>): boolean {<EOL>    if (!records || records.length === <NUM_LIT>) {<EOL>        nodes.length = <NUM_LIT>;<EOL>        viewContainer.clear();<EOL>        return true;<EOL>    }<EOL>    const recordsLength = records.length;<EOL>    let hasChanges = false;<EOL>    <EOL>    let availableNode: VirtualNode;<EOL>    let cell: VirtualCell;<EOL>    let viewInsertIndex: number = null;<EOL>    let totalNodes = nodes.length;<EOL>    let templateRef: TemplateRef<VirtualContext>;<EOL>    startCellIndex = Math.max(startCellIndex, <NUM_LIT>);<EOL>    endCellIndex = Math.min(endCellIndex, cells.length - <NUM_LIT>);<EOL>    const usedNodes: VirtualNode[] = [];<EOL>    for (var cellIndex = startCellIndex; cellIndex <= endCellIndex; cellIndex++) {<EOL>        cell = cells[cellIndex];<EOL>        availableNode = null;<EOL>        <EOL>        const existingNode = nodes.find(n => n.cell === cellIndex && n.tmpl === cell.tmpl);<EOL>        if (existingNode) {<EOL>            if (existingNode.view.context.$implicit === records[cell.record]) {<EOL>                usedNodes.push(existingNode);<EOL>                continue; <EOL>            }<EOL>            console.debug('<STR_LIT>', '<STR_LIT>');<EOL>            availableNode = existingNode; <EOL>        }<EOL>        else {<EOL>            console.debug('<STR_LIT>', '<STR_LIT>');<EOL>            for (var i = <NUM_LIT>; i < totalNodes; i++) {<EOL>                const node = nodes[i];<EOL>                if (cell.tmpl !== node.tmpl || i === <NUM_LIT> && cellIndex !== <NUM_LIT>) {<EOL>                    <EOL>                    <EOL>                    <EOL>                    continue;<EOL>                }<EOL>                if (node.cell < startCellIndex || node.cell > endCellIndex) {<EOL>                    if (!availableNode) {<EOL>                        <EOL>                        availableNode = node;<EOL>                        console.debug('<STR_LIT>', '<STR_LIT>', availableNode);<EOL>                    }<EOL>                    else if (scrollingDown) {<EOL>                        <EOL>                        if (node.cell < availableNode.cell) {<EOL>                            availableNode = node;<EOL>                            console.debug('<STR_LIT>', '<STR_LIT>', availableNode);<EOL>                        }<EOL>                    }<EOL>                    else {<EOL>                        <EOL>                        if (node.cell > availableNode.cell) {<EOL>                            availableNode = node;<EOL>                            console.debug('<STR_LIT>', '<STR_LIT>', availableNode);<EOL>                        }<EOL>                    }<EOL>                }<EOL>            }<EOL>        }<EOL>        if (!availableNode) {<EOL>            <EOL>            <EOL>            if (viewInsertIndex === null) {<EOL>                viewInsertIndex = -<NUM_LIT>;<EOL>                for (var j = totalNodes - <NUM_LIT>; j >= <NUM_LIT>; j--) {<EOL>                    const node = nodes[j];<EOL>                    if (node) {<EOL>                        viewInsertIndex = viewContainer.indexOf(node.view);<EOL>                        break;<EOL>                    }<EOL>                }<EOL>            }<EOL>            <EOL>            templateRef = cell.tmpl === TemplateType.Header ? hdrTmp : cell.tmpl === TemplateType.Footer ? ftrTmp : itmTmp;<EOL>            if (!templateRef) {<EOL>                console.error(`<STR_LIT>`);<EOL>                continue;<EOL>            }<EOL>            availableNode = {<EOL>                tmpl: cell.tmpl,<EOL>                view: viewContainer.createEmbeddedView(templateRef, new VirtualContext(null, null, null), viewInsertIndex)<EOL>            };<EOL>            totalNodes = nodes.push(availableNode);<EOL>        }<EOL>        <EOL>        availableNode.cell = cellIndex;<EOL>        <EOL>        var context = availableNode.view.context;<EOL>        context.$implicit = cell.data || records[cell.record];<EOL>        context.index = cellIndex;<EOL>        context.count = recordsLength;<EOL>        availableNode.hasChanges = true;<EOL>        availableNode.lastTransform = null;<EOL>        hasChanges = true;<EOL>","gt":"usedNodes.push(availableNode);"}
{"input":"<s> <EOL>export function matchesSubString(word: string, wordToMatchAgainst: string): IMatch[] {<EOL>    return _matchesSubString(word.","gt":"toLowerCase(), wordToMatchAgainst.toLowerCase(), <NUM_LIT>, <NUM_LIT>);"}
{"input":"<s> function sambaCmd(ch: string, addr: number, len?: number) {<EOL>    let r = ch + addr.toString(<NUM_LIT>);<EOL>","gt":"if (len != null)"}
{"input":"<s> function getUnitValue(val: any): string {<EOL>    if (isPresent(val)) {<EOL>        if (typeof val === '<STR_LIT>') {<EOL>            if (val.indexOf('<STR_LIT>') > -<NUM_LIT> || val.indexOf('<STR_LIT>') > -<NUM_LIT>) {<EOL>                return val;<EOL>            }<EOL>            if (val.length) {<EOL>                return val + '<STR_LIT>';<EOL>            }<EOL>        }<EOL>        else if (typeof val === '<STR_LIT>') {<EOL>            return","gt":"val + '<STR_LIT>';"}
{"input":"<s> /**<EOL> * Given an absolute system path, compile an array of paths working backwards<EOL> * one directory at a time, always ending in the root directory.<EOL> *<EOL> * For example, `'/some/dir'` => `['/some/dir', '/some', '/']`<EOL> */<EOL>export function compilePaths(filePath: string): string[] {<EOL>    filePath = path.normalize(filePath);<EOL>    if (!path.isAbsolute(filePath)) {<EOL>        throw new Error(`<STR_LIT>`);<EOL>    }<EOL>    const parsed = path.parse(filePath);<EOL>    if (filePath === parsed.root) {<EOL>        return [filePath];<EOL>    }<EOL>    return filePath<EOL>        .","gt":"slice(parsed.root.length)"}
{"input":"<s> function f15() {<EOL>    var a = \"<STR_LIT>\";<EOL>    var b =","gt":"<NUM_LIT>;"}
{"input":"<s> export function readPkgConfig(dir: string) {<EOL>    pxt.debug(\"<STR_LIT>\" + dir);<EOL>    const fn = path.join(dir, pxt.CONFIG_NAME);<EOL>    const js: pxt.PackageConfig = readJson(fn);<EOL>    if (js.additionalFilePath) {<EOL>","gt":"let addjson = path.join(dir, js.additionalFilePath, pxt.CONFIG_NAME);"}
{"input":"<s> function _findAllMatches(patternPos: number, wordPos: number, total: number, matches: LazyArray, lastMatched: boolean): void {<EOL>    if (_matchesCount >= <NUM_LIT> || total < -<NUM_LIT>) {<EOL>        <EOL>        <EOL>        return;<EOL>    }<EOL>","gt":"let simpleMatchCount = <NUM_LIT>;"}
{"input":"<s> function _findAllMatches(patternPos: number, wordPos: number, total: number, matches: LazyArray, lastMatched: boolean): void {<EOL>    if (_matchesCount >= <NUM_LIT> || total < -<NUM_LIT>) {<EOL>        <EOL>        <EOL>        return;<EOL>    }<EOL>    let simpleMatchCount = <NUM_LIT>;<EOL>    while (patternPos > _patternStartPos && wordPos > <NUM_LIT>) {<EOL>        let score =","gt":"_scores[patternPos][wordPos];"}
{"input":"<s> function _findAllMatches(patternPos: number, wordPos: number, total: number, matches: LazyArray, lastMatched: boolean): void {<EOL>    if (_matchesCount >= <NUM_LIT> || total < -<NUM_LIT>) {<EOL>        <EOL>        <EOL>        return;<EOL>    }<EOL>    let simpleMatchCount = <NUM_LIT>;<EOL>    while (patternPos > _patternStartPos && wordPos > <NUM_LIT>) {<EOL>        let score = _scores[patternPos][wordPos];<EOL>        let arrow = _arrows[patternPos][wordPos];<EOL>        if (arrow === Arrow.Left) {<EOL>            <EOL>","gt":"wordPos -= <NUM_LIT>;"}
{"input":"<s> function _findAllMatches(patternPos: number, wordPos: number, total: number, matches: LazyArray, lastMatched: boolean): void {<EOL>    if (_matchesCount >= <NUM_LIT> || total < -<NUM_LIT>) {<EOL>        <EOL>        <EOL>        return;<EOL>    }<EOL>    let simpleMatchCount = <NUM_LIT>;<EOL>    while (patternPos > _patternStartPos && wordPos > <NUM_LIT>) {<EOL>        let score = _scores[patternPos][wordPos];<EOL>        let arrow = _arrows[patternPos][wordPos];<EOL>        if (arrow === Arrow.Left) {<EOL>            <EOL>            wordPos -= <NUM_LIT>;<EOL>","gt":"if (lastMatched) {"}
{"input":"<s> function _findAllMatches(patternPos: number, wordPos: number, total: number, matches: LazyArray, lastMatched: boolean): void {<EOL>    if (_matchesCount >= <NUM_LIT> || total < -<NUM_LIT>) {<EOL>        <EOL>        <EOL>        return;<EOL>    }<EOL>    let simpleMatchCount = <NUM_LIT>;<EOL>    while (patternPos > _patternStartPos && wordPos > <NUM_LIT>) {<EOL>        let score = _scores[patternPos][wordPos];<EOL>        let arrow = _arrows[patternPos][wordPos];<EOL>        if (arrow === Arrow.Left) {<EOL>            <EOL>            wordPos -= <NUM_LIT>;<EOL>            if (lastMatched) {<EOL>                total -= <NUM_LIT>; <EOL>            }<EOL>            else if (!matches.isEmpty()) {<EOL>                total -= <NUM_LIT>; <EOL>            }<EOL>","gt":"lastMatched = false;"}
{"input":"<s> function _findAllMatches(patternPos: number, wordPos: number, total: number, matches: LazyArray, lastMatched: boolean): void {<EOL>    if (_matchesCount >= <NUM_LIT> || total < -<NUM_LIT>) {<EOL>        <EOL>        <EOL>        return;<EOL>    }<EOL>    let simpleMatchCount = <NUM_LIT>;<EOL>    while (patternPos > _patternStartPos && wordPos > <NUM_LIT>) {<EOL>        let score = _scores[patternPos][wordPos];<EOL>        let arrow = _arrows[patternPos][wordPos];<EOL>        if (arrow === Arrow.Left) {<EOL>            <EOL>            wordPos -= <NUM_LIT>;<EOL>            if (lastMatched) {<EOL>                total -= <NUM_LIT>; <EOL>            }<EOL>            else if (!matches.isEmpty()) {<EOL>                total -= <NUM_LIT>; <EOL>            }<EOL>            lastMatched = false;<EOL>            simpleMatchCount = <NUM_LIT>;<EOL>        }<EOL>        else if (arrow & Arrow.Diag) {<EOL>            if (arrow & Arrow.Left) {<EOL>                <EOL>                _findAllMatches(patternPos, wordPos - <NUM_LIT>, !matches.isEmpty() ? total - <NUM_LIT> : total, <EOL>                matches.","gt":"slice(), lastMatched);"}
{"input":"<s> function _findAllMatches(patternPos: number, wordPos: number, total: number, matches: LazyArray, lastMatched: boolean): void {<EOL>    if (_matchesCount >= <NUM_LIT> || total < -<NUM_LIT>) {<EOL>        <EOL>        <EOL>        return;<EOL>    }<EOL>    let simpleMatchCount = <NUM_LIT>;<EOL>    while (patternPos > _patternStartPos && wordPos > <NUM_LIT>) {<EOL>        let score = _scores[patternPos][wordPos];<EOL>        let arrow = _arrows[patternPos][wordPos];<EOL>        if (arrow === Arrow.Left) {<EOL>            <EOL>            wordPos -= <NUM_LIT>;<EOL>            if (lastMatched) {<EOL>                total -= <NUM_LIT>; <EOL>            }<EOL>            else if (!matches.isEmpty()) {<EOL>                total -= <NUM_LIT>; <EOL>            }<EOL>            lastMatched = false;<EOL>            simpleMatchCount = <NUM_LIT>;<EOL>        }<EOL>        else if (arrow & Arrow.Diag) {<EOL>            if (arrow & Arrow.Left) {<EOL>                <EOL>                _findAllMatches(patternPos, wordPos - <NUM_LIT>, !matches.isEmpty() ? total - <NUM_LIT> : total, <EOL>                matches.slice(), lastMatched);<EOL>            }<EOL>            <EOL>            total += score;<EOL>            patternPos -= <NUM_LIT>;<EOL>            wordPos -= <NUM_LIT>;<EOL>            matches.unshift(wordPos);<EOL>            lastMatched = true;<EOL>            <EOL>            <EOL>            <EOL>            if (","gt":"score === <NUM_LIT>) {"}
{"input":"<s> function _findAllMatches(patternPos: number, wordPos: number, total: number, matches: LazyArray, lastMatched: boolean): void {<EOL>    if (_matchesCount >= <NUM_LIT> || total < -<NUM_LIT>) {<EOL>        <EOL>        <EOL>        return;<EOL>    }<EOL>    let simpleMatchCount = <NUM_LIT>;<EOL>    while (patternPos > _patternStartPos && wordPos > <NUM_LIT>) {<EOL>        let score = _scores[patternPos][wordPos];<EOL>        let arrow = _arrows[patternPos][wordPos];<EOL>        if (arrow === Arrow.Left) {<EOL>            <EOL>            wordPos -= <NUM_LIT>;<EOL>            if (lastMatched) {<EOL>                total -= <NUM_LIT>; <EOL>            }<EOL>            else if (!matches.isEmpty()) {<EOL>                total -= <NUM_LIT>; <EOL>            }<EOL>            lastMatched = false;<EOL>            simpleMatchCount = <NUM_LIT>;<EOL>        }<EOL>        else if (arrow & Arrow.Diag) {<EOL>            if (arrow & Arrow.Left) {<EOL>                <EOL>                _findAllMatches(patternPos, wordPos - <NUM_LIT>, !matches.isEmpty() ? total - <NUM_LIT> : total, <EOL>                matches.slice(), lastMatched);<EOL>            }<EOL>            <EOL>            total += score;<EOL>            patternPos -= <NUM_LIT>;<EOL>            wordPos -= <NUM_LIT>;<EOL>            matches.unshift(wordPos);<EOL>            lastMatched = true;<EOL>            <EOL>            <EOL>            <EOL>            if (score === <NUM_LIT>) {<EOL>                simpleMatchCount += <NUM_LIT>;<EOL>                if (patternPos === _patternStartPos) {<EOL>                    <EOL>                    <EOL>                    return undefined;<EOL>                }<EOL>            }<EOL>            else {<EOL>                <EOL>                total +=","gt":"<NUM_LIT> + (simpleMatchCount * (score - <NUM_LIT>));"}
{"input":"<s> function _findAllMatches(patternPos: number, wordPos: number, total: number, matches: LazyArray, lastMatched: boolean): void {<EOL>    if (_matchesCount >= <NUM_LIT> || total < -<NUM_LIT>) {<EOL>        <EOL>        <EOL>        return;<EOL>    }<EOL>    let simpleMatchCount = <NUM_LIT>;<EOL>    while (patternPos > _patternStartPos && wordPos > <NUM_LIT>) {<EOL>        let score = _scores[patternPos][wordPos];<EOL>        let arrow = _arrows[patternPos][wordPos];<EOL>        if (arrow === Arrow.Left) {<EOL>            <EOL>            wordPos -= <NUM_LIT>;<EOL>            if (lastMatched) {<EOL>                total -= <NUM_LIT>; <EOL>            }<EOL>            else if (!matches.isEmpty()) {<EOL>                total -= <NUM_LIT>; <EOL>            }<EOL>            lastMatched = false;<EOL>            simpleMatchCount = <NUM_LIT>;<EOL>        }<EOL>        else if (arrow & Arrow.Diag) {<EOL>            if (arrow & Arrow.Left) {<EOL>                <EOL>                _findAllMatches(patternPos, wordPos - <NUM_LIT>, !matches.isEmpty() ? total - <NUM_LIT> : total, <EOL>                matches.slice(), lastMatched);<EOL>            }<EOL>            <EOL>            total += score;<EOL>            patternPos -= <NUM_LIT>;<EOL>            wordPos -= <NUM_LIT>;<EOL>            matches.unshift(wordPos);<EOL>            lastMatched = true;<EOL>            <EOL>            <EOL>            <EOL>            if (score === <NUM_LIT>) {<EOL>                simpleMatchCount += <NUM_LIT>;<EOL>                if (patternPos === _patternStartPos) {<EOL>                    <EOL>                    <EOL>                    return undefined;<EOL>                }<EOL>            }<EOL>            else {<EOL>                <EOL>                total += <NUM_LIT> + (simpleMatchCount * (score - <NUM_LIT>));<EOL>                simpleMatchCount = <NUM_LIT>;<EOL>            }<EOL>        }<EOL>        else {<EOL>","gt":"return undefined;"}
{"input":"<s> function _findAllMatches(patternPos: number, wordPos: number, total: number, matches: LazyArray, lastMatched: boolean): void {<EOL>    if (_matchesCount >= <NUM_LIT> || total < -<NUM_LIT>) {<EOL>        <EOL>        <EOL>        return;<EOL>    }<EOL>    let simpleMatchCount = <NUM_LIT>;<EOL>    while (patternPos > _patternStartPos && wordPos > <NUM_LIT>) {<EOL>        let score = _scores[patternPos][wordPos];<EOL>        let arrow = _arrows[patternPos][wordPos];<EOL>        if (arrow === Arrow.Left) {<EOL>            <EOL>            wordPos -= <NUM_LIT>;<EOL>            if (lastMatched) {<EOL>                total -= <NUM_LIT>; <EOL>            }<EOL>            else if (!matches.isEmpty()) {<EOL>                total -= <NUM_LIT>; <EOL>            }<EOL>            lastMatched = false;<EOL>            simpleMatchCount = <NUM_LIT>;<EOL>        }<EOL>        else if (arrow & Arrow.Diag) {<EOL>            if (arrow & Arrow.Left) {<EOL>                <EOL>                _findAllMatches(patternPos, wordPos - <NUM_LIT>, !matches.isEmpty() ? total - <NUM_LIT> : total, <EOL>                matches.slice(), lastMatched);<EOL>            }<EOL>            <EOL>            total += score;<EOL>            patternPos -= <NUM_LIT>;<EOL>            wordPos -= <NUM_LIT>;<EOL>            matches.unshift(wordPos);<EOL>            lastMatched = true;<EOL>            <EOL>            <EOL>            <EOL>            if (score === <NUM_LIT>) {<EOL>                simpleMatchCount += <NUM_LIT>;<EOL>                if (patternPos === _patternStartPos) {<EOL>                    <EOL>                    <EOL>                    return undefined;<EOL>                }<EOL>            }<EOL>            else {<EOL>                <EOL>                total += <NUM_LIT> + (simpleMatchCount * (score - <NUM_LIT>));<EOL>                simpleMatchCount = <NUM_LIT>;<EOL>            }<EOL>        }<EOL>        else {<EOL>            return undefined;<EOL>        }<EOL>    }<EOL>","gt":"total -= wordPos >= <NUM_LIT> ? <NUM_LIT> : wordPos * <NUM_LIT>;"}
{"input":"<s> <EOL>export function resolveMd(root: string, pathname: string): string {<EOL>    const docs = path.join(root, \"<STR_LIT>\");<EOL>    let tryRead = (fn: string) => {<EOL>        if (fileExistsSync(","gt":"fn + \"<STR_LIT>\"))"}
{"input":"<s> <EOL>export function resolveMd(root: string, pathname: string): string {<EOL>    const docs = path.join(root, \"<STR_LIT>\");<EOL>    let tryRead = (fn: string) => {<EOL>        if (fileExistsSync(fn + \"<STR_LIT>\"))<EOL>            return fs.readFileSync(fn + \"<STR_LIT>\", \"<STR_LIT>\");<EOL>        if (fileExistsSync(fn + \"<STR_LIT>\"))<EOL>","gt":"return fs.readFileSync(fn + \"<STR_LIT>\", \"<STR_LIT>\");"}
{"input":"<s> <EOL>export function resolveMd(root: string, pathname: string): string {<EOL>    const docs = path.join(root, \"<STR_LIT>\");<EOL>    let tryRead = (fn: string) => {<EOL>        if (fileExistsSync(fn + \"<STR_LIT>\"))<EOL>            return fs.readFileSync(fn + \"<STR_LIT>\", \"<STR_LIT>\");<EOL>        if (fileExistsSync(fn + \"<STR_LIT>\"))<EOL>            return fs.readFileSync(fn + \"<STR_LIT>\", \"<STR_LIT>\");<EOL>        return null;<EOL>    };<EOL>    let targetMd = tryRead(path.join(docs, pathname));<EOL>    if (targetMd && !/^\\s*#+\\s+@extends/m.test(","gt":"targetMd))"}
{"input":"<s> <EOL>export function resolveMd(root: string, pathname: string): string {<EOL>    const docs = path.join(root, \"<STR_LIT>\");<EOL>    let tryRead = (fn: string) => {<EOL>        if (fileExistsSync(fn + \"<STR_LIT>\"))<EOL>            return fs.readFileSync(fn + \"<STR_LIT>\", \"<STR_LIT>\");<EOL>        if (fileExistsSync(fn + \"<STR_LIT>\"))<EOL>            return fs.readFileSync(fn + \"<STR_LIT>\", \"<STR_LIT>\");<EOL>        return null;<EOL>    };<EOL>    let targetMd = tryRead(path.join(docs, pathname));<EOL>    if (targetMd && !/^\\s*#+\\s+@extends/m.test(targetMd))<EOL>        return targetMd;<EOL>    let dirs = [<EOL>        path.join(root,","gt":"\"<STR_LIT>\"),"}
{"input":"<s> <EOL>export function resolveMd(root: string, pathname: string): string {<EOL>    const docs = path.join(root, \"<STR_LIT>\");<EOL>    let tryRead = (fn: string) => {<EOL>        if (fileExistsSync(fn + \"<STR_LIT>\"))<EOL>            return fs.readFileSync(fn + \"<STR_LIT>\", \"<STR_LIT>\");<EOL>        if (fileExistsSync(fn + \"<STR_LIT>\"))<EOL>            return fs.readFileSync(fn + \"<STR_LIT>\", \"<STR_LIT>\");<EOL>        return null;<EOL>    };<EOL>    let targetMd = tryRead(path.join(docs, pathname));<EOL>    if (targetMd && !/^\\s*#+\\s+@extends/m.test(targetMd))<EOL>        return targetMd;<EOL>    let dirs = [<EOL>        path.join(root, \"<STR_LIT>\"),<EOL>    ];<EOL>    lastResolveMdDirs = dirs;<EOL>    for (let pkg of pxt.appTarget.bundleddirs) {<EOL>        let d = path.join(","gt":"pkg, \"<STR_LIT>\");"}
{"input":"<s> <EOL>export function resolveMd(root: string, pathname: string): string {<EOL>    const docs = path.join(root, \"<STR_LIT>\");<EOL>    let tryRead = (fn: string) => {<EOL>        if (fileExistsSync(fn + \"<STR_LIT>\"))<EOL>            return fs.readFileSync(fn + \"<STR_LIT>\", \"<STR_LIT>\");<EOL>        if (fileExistsSync(fn + \"<STR_LIT>\"))<EOL>            return fs.readFileSync(fn + \"<STR_LIT>\", \"<STR_LIT>\");<EOL>        return null;<EOL>    };<EOL>    let targetMd = tryRead(path.join(docs, pathname));<EOL>    if (targetMd && !/^\\s*#+\\s+@extends/m.test(targetMd))<EOL>        return targetMd;<EOL>    let dirs = [<EOL>        path.join(root, \"<STR_LIT>\"),<EOL>    ];<EOL>    lastResolveMdDirs = dirs;<EOL>    for (let pkg of pxt.appTarget.bundleddirs) {<EOL>        let d = path.join(pkg, \"<STR_LIT>\");<EOL>        if (!path.isAbsolute(d))<EOL>            d = path.join(root, d);<EOL>        dirs.push(d);<EOL>        let cfg = readPkgConfig(path.join(d, \"<STR_LIT>\"));<EOL>        if (cfg.additionalFilePath)<EOL>            dirs.push(path.","gt":"join(d, \"<STR_LIT>\", cfg.additionalFilePath, \"<STR_LIT>\"));"}
{"input":"<s> /**<EOL> * In **contrast** to just checking `typeof` this will return `false` for `NaN`.<EOL> * @returns whether the provided parameter is a JavaScript Number or not.<EOL> */<EOL>export function isNumber(obj: any): obj is number {<EOL>    if ((typeof (obj) === _typeof.number || obj instanceof Number) && !isNaN(obj)) {<EOL>","gt":"return true;"}
{"input":"<s> <EOL>function f() {<EOL>    let a = <NUM_LIT>;<EOL>    let x: \"<STR_LIT>\" | '<STR_LIT>' = newFunction();<EOL>","gt":"a;"}
{"input":"<s> /**<EOL> * In **contrast** to just checking `typeof` this will return `false` for `NaN`.<EOL> * @returns whether the provided parameter is a JavaScript Number or not.<EOL> */<EOL>export function isNumber(obj: any): obj is number {<EOL>    if ((typeof (obj) === _typeof.number || obj instanceof Number) && !isNaN(obj)) {<EOL>        return","gt":"true;"}
{"input":"<s> export function slug(str: string): string {<EOL>    return","gt":"_slug(str, { lower: true });"}
{"input":"<s> function inject(root: HeadingNode, title: string, level: number): HeadingNode {<EOL>    if (level === <NUM_LIT>) {<EOL>        root.title = title;<EOL>    }<EOL>    else {<EOL>        if (level === <NUM_LIT> || root.children.length ===","gt":"<NUM_LIT>) {"}
{"input":"<s> function inject(root: HeadingNode, title: string, level: number): HeadingNode {<EOL>    if (level === <NUM_LIT>) {<EOL>        root.title = title;<EOL>    }<EOL>    else {<EOL>        if (level === <NUM_LIT> || root.children.length === <NUM_LIT>) {<EOL>            root.children.push({<EOL>                title: null,<EOL>                children: [],<EOL>            });<EOL>        }<EOL>        const lastChild = root.children[root.","gt":"children.length - <NUM_LIT>];"}
{"input":"<s> <EOL>function F() {<EOL>     arguments.","gt":"length ;"}
{"input":"<s> function processLine(line: string): void {<EOL>    const matches = parseLine(line);<EOL>    if (matches) {<EOL>        <EOL>        <EOL>        const link = matches[<NUM_LIT>] + matches[<NUM_LIT>];<EOL>","gt":"const contributor = matches[<NUM_LIT>];"}
{"input":"<s> function processLine(line: string): void {<EOL>    const matches = parseLine(line);<EOL>    if (matches) {<EOL>        <EOL>        <EOL>        const link = matches[<NUM_LIT>] + matches[<NUM_LIT>];<EOL>        const contributor = matches[<NUM_LIT>];<EOL>        <EOL>        <EOL>        if (!(contributor in contributeMap)) {<EOL>","gt":"contributeMap[contributor] = [];"}
{"input":"<s> export function first<T>(promiseFactories: ITask<TPromise<T>>[], shouldStop: (t: T) => boolean = t => !!t): TPromise<T> {<EOL>    promiseFactories = [...promiseFactories.reverse()];<EOL>    const loop: () => TPromise<T> = () => {<EOL>        if (promiseFactories.length === <NUM_LIT>) {<EOL>            return TPromise.as(null);<EOL>        }<EOL>        const factory = promiseFactories.pop();<EOL>        const promise = factory();<EOL>        return promise.then(result => {<EOL>            if (","gt":"shouldStop(result)) {"}
{"input":"<s> export function first<T>(promiseFactories: ITask<TPromise<T>>[], shouldStop: (t: T) => boolean = t => !!t): TPromise<T> {<EOL>    promiseFactories = [...promiseFactories.reverse()];<EOL>    const loop: () => TPromise<T> = () => {<EOL>        if (promiseFactories.length === <NUM_LIT>) {<EOL>            return TPromise.as(null);<EOL>        }<EOL>        const factory = promiseFactories.pop();<EOL>        const promise = factory();<EOL>        return promise.then(result => {<EOL>            if (shouldStop(result)) {<EOL>                return TPromise.as(result);<EOL>            }<EOL>            return","gt":"loop();"}
{"input":"<s> function foo1(): F1 {<EOL>","gt":"return {"}
{"input":"<s> /**<EOL> * DOM READ<EOL> */<EOL>export function updateDimensions(plt: Platform, nodes: VirtualNode[], cells: VirtualCell[], data: VirtualData, initialUpdate: boolean) {<EOL>    let node: VirtualNode;<EOL>    let element: VirtualHtmlElement;<EOL>    let","gt":"cell: VirtualCell;"}
{"input":"<s> /**<EOL> * DOM READ<EOL> */<EOL>export function updateDimensions(plt: Platform, nodes: VirtualNode[], cells: VirtualCell[], data: VirtualData, initialUpdate: boolean) {<EOL>    let node: VirtualNode;<EOL>    let element: VirtualHtmlElement;<EOL>    let cell: VirtualCell;<EOL>    let previousCell: VirtualCell;<EOL>    const totalCells = cells.length;<EOL>    for (var i = <NUM_LIT>; i < nodes.length; i++) {<EOL>","gt":"node = nodes[i];"}
{"input":"<s> /**<EOL> * DOM READ<EOL> */<EOL>export function updateDimensions(plt: Platform, nodes: VirtualNode[], cells: VirtualCell[], data: VirtualData, initialUpdate: boolean) {<EOL>    let node: VirtualNode;<EOL>    let element: VirtualHtmlElement;<EOL>    let cell: VirtualCell;<EOL>    let previousCell: VirtualCell;<EOL>    const totalCells = cells.length;<EOL>    for (var i = <NUM_LIT>; i < nodes.length; i++) {<EOL>        node = nodes[i];<EOL>        cell = cells[node.cell];<EOL>        <EOL>        if (","gt":"cell && cell.reads < REQUIRED_DOM_READS) {"}
{"input":"<s> /**<EOL> * DOM READ<EOL> */<EOL>export function updateDimensions(plt: Platform, nodes: VirtualNode[], cells: VirtualCell[], data: VirtualData, initialUpdate: boolean) {<EOL>    let node: VirtualNode;<EOL>    let element: VirtualHtmlElement;<EOL>    let cell: VirtualCell;<EOL>    let previousCell: VirtualCell;<EOL>    const totalCells = cells.length;<EOL>    for (var i = <NUM_LIT>; i < nodes.length; i++) {<EOL>        node = nodes[i];<EOL>        cell = cells[node.cell];<EOL>        <EOL>        if (cell && cell.reads < REQUIRED_DOM_READS) {<EOL>            element = getElement(node);<EOL>            <EOL>            readElements(plt, cell, element);<EOL>","gt":"if (initialUpdate) {"}
{"input":"<s> /**<EOL> * DOM READ<EOL> */<EOL>export function updateDimensions(plt: Platform, nodes: VirtualNode[], cells: VirtualCell[], data: VirtualData, initialUpdate: boolean) {<EOL>    let node: VirtualNode;<EOL>    let element: VirtualHtmlElement;<EOL>    let cell: VirtualCell;<EOL>    let previousCell: VirtualCell;<EOL>    const totalCells = cells.length;<EOL>    for (var i = <NUM_LIT>; i < nodes.length; i++) {<EOL>        node = nodes[i];<EOL>        cell = cells[node.cell];<EOL>        <EOL>        if (cell && cell.reads < REQUIRED_DOM_READS) {<EOL>            element = getElement(node);<EOL>            <EOL>            readElements(plt, cell, element);<EOL>            if (initialUpdate) {<EOL>                <EOL>                if (cell.tmpl === TemplateType.Header) {<EOL>                    data.hdrHeight = cell.height;<EOL>                    if (cell.left === <NUM_LIT>) {<EOL>                        data.hdrWidth = cell.width;<EOL>                    }<EOL>                }<EOL>                else if (cell.tmpl === TemplateType.Footer) {<EOL>                    data.ftrHeight = cell.height;<EOL>                    if (","gt":"cell.left === <NUM_LIT>) {"}
{"input":"<s> /**<EOL> * DOM READ<EOL> */<EOL>export function updateDimensions(plt: Platform, nodes: VirtualNode[], cells: VirtualCell[], data: VirtualData, initialUpdate: boolean) {<EOL>    let node: VirtualNode;<EOL>    let element: VirtualHtmlElement;<EOL>    let cell: VirtualCell;<EOL>    let previousCell: VirtualCell;<EOL>    const totalCells = cells.length;<EOL>    for (var i = <NUM_LIT>; i < nodes.length; i++) {<EOL>        node = nodes[i];<EOL>        cell = cells[node.cell];<EOL>        <EOL>        if (cell && cell.reads < REQUIRED_DOM_READS) {<EOL>            element = getElement(node);<EOL>            <EOL>            readElements(plt, cell, element);<EOL>            if (initialUpdate) {<EOL>                <EOL>                if (cell.tmpl === TemplateType.Header) {<EOL>                    data.hdrHeight = cell.height;<EOL>                    if (cell.left === <NUM_LIT>) {<EOL>                        data.hdrWidth = cell.width;<EOL>                    }<EOL>                }<EOL>                else if (cell.tmpl === TemplateType.Footer) {<EOL>                    data.ftrHeight = cell.height;<EOL>                    if (cell.left === <NUM_LIT>) {<EOL>                        data.ftrWidth = cell.width;<EOL>                    }<EOL>                }<EOL>                else {<EOL>                    data.itmHeight = cell.height;<EOL>                    if (cell.left === <NUM_LIT>) {<EOL>                        data.itmWidth = cell.","gt":"width;"}
{"input":"<s> /**<EOL> * DOM READ<EOL> */<EOL>export function updateDimensions(plt: Platform, nodes: VirtualNode[], cells: VirtualCell[], data: VirtualData, initialUpdate: boolean) {<EOL>    let node: VirtualNode;<EOL>    let element: VirtualHtmlElement;<EOL>    let cell: VirtualCell;<EOL>    let previousCell: VirtualCell;<EOL>    const totalCells = cells.length;<EOL>    for (var i = <NUM_LIT>; i < nodes.length; i++) {<EOL>        node = nodes[i];<EOL>        cell = cells[node.cell];<EOL>        <EOL>        if (cell && cell.reads < REQUIRED_DOM_READS) {<EOL>            element = getElement(node);<EOL>            <EOL>            readElements(plt, cell, element);<EOL>            if (initialUpdate) {<EOL>                <EOL>                if (cell.tmpl === TemplateType.Header) {<EOL>                    data.hdrHeight = cell.height;<EOL>                    if (cell.left === <NUM_LIT>) {<EOL>                        data.hdrWidth = cell.width;<EOL>                    }<EOL>                }<EOL>                else if (cell.tmpl === TemplateType.Footer) {<EOL>                    data.ftrHeight = cell.height;<EOL>                    if (cell.left === <NUM_LIT>) {<EOL>                        data.ftrWidth = cell.width;<EOL>                    }<EOL>                }<EOL>                else {<EOL>                    data.itmHeight = cell.height;<EOL>                    if (cell.left === <NUM_LIT>) {<EOL>                        data.itmWidth = cell.width;<EOL>                    }<EOL>                }<EOL>            }<EOL>            cell.reads++;<EOL>        }<EOL>    }<EOL>    <EOL>    const viewableBottom = (data.scrollTop + data.viewHeight);<EOL>    data.topViewCell =","gt":"totalCells;"}
{"input":"<s> /**<EOL> * DOM READ<EOL> */<EOL>export function updateDimensions(plt: Platform, nodes: VirtualNode[], cells: VirtualCell[], data: VirtualData, initialUpdate: boolean) {<EOL>    let node: VirtualNode;<EOL>    let element: VirtualHtmlElement;<EOL>    let cell: VirtualCell;<EOL>    let previousCell: VirtualCell;<EOL>    const totalCells = cells.length;<EOL>    for (var i = <NUM_LIT>; i < nodes.length; i++) {<EOL>        node = nodes[i];<EOL>        cell = cells[node.cell];<EOL>        <EOL>        if (cell && cell.reads < REQUIRED_DOM_READS) {<EOL>            element = getElement(node);<EOL>            <EOL>            readElements(plt, cell, element);<EOL>            if (initialUpdate) {<EOL>                <EOL>                if (cell.tmpl === TemplateType.Header) {<EOL>                    data.hdrHeight = cell.height;<EOL>                    if (cell.left === <NUM_LIT>) {<EOL>                        data.hdrWidth = cell.width;<EOL>                    }<EOL>                }<EOL>                else if (cell.tmpl === TemplateType.Footer) {<EOL>                    data.ftrHeight = cell.height;<EOL>                    if (cell.left === <NUM_LIT>) {<EOL>                        data.ftrWidth = cell.width;<EOL>                    }<EOL>                }<EOL>                else {<EOL>                    data.itmHeight = cell.height;<EOL>                    if (cell.left === <NUM_LIT>) {<EOL>                        data.itmWidth = cell.width;<EOL>                    }<EOL>                }<EOL>            }<EOL>            cell.reads++;<EOL>        }<EOL>    }<EOL>    <EOL>    const viewableBottom = (data.scrollTop + data.viewHeight);<EOL>    data.topViewCell = totalCells;<EOL>    data.bottomViewCell = <NUM_LIT>;<EOL>    if (totalCells > <NUM_LIT>) {<EOL>        <EOL>        cell = cells[<NUM_LIT>];<EOL>","gt":"previousCell = {"}
{"input":"<s> /**<EOL> * DOM READ<EOL> */<EOL>export function updateDimensions(plt: Platform, nodes: VirtualNode[], cells: VirtualCell[], data: VirtualData, initialUpdate: boolean) {<EOL>    let node: VirtualNode;<EOL>    let element: VirtualHtmlElement;<EOL>    let cell: VirtualCell;<EOL>    let previousCell: VirtualCell;<EOL>    const totalCells = cells.length;<EOL>    for (var i = <NUM_LIT>; i < nodes.length; i++) {<EOL>        node = nodes[i];<EOL>        cell = cells[node.cell];<EOL>        <EOL>        if (cell && cell.reads < REQUIRED_DOM_READS) {<EOL>            element = getElement(node);<EOL>            <EOL>            readElements(plt, cell, element);<EOL>            if (initialUpdate) {<EOL>                <EOL>                if (cell.tmpl === TemplateType.Header) {<EOL>                    data.hdrHeight = cell.height;<EOL>                    if (cell.left === <NUM_LIT>) {<EOL>                        data.hdrWidth = cell.width;<EOL>                    }<EOL>                }<EOL>                else if (cell.tmpl === TemplateType.Footer) {<EOL>                    data.ftrHeight = cell.height;<EOL>                    if (cell.left === <NUM_LIT>) {<EOL>                        data.ftrWidth = cell.width;<EOL>                    }<EOL>                }<EOL>                else {<EOL>                    data.itmHeight = cell.height;<EOL>                    if (cell.left === <NUM_LIT>) {<EOL>                        data.itmWidth = cell.width;<EOL>                    }<EOL>                }<EOL>            }<EOL>            cell.reads++;<EOL>        }<EOL>    }<EOL>    <EOL>    const viewableBottom = (data.scrollTop + data.viewHeight);<EOL>    data.topViewCell = totalCells;<EOL>    data.bottomViewCell = <NUM_LIT>;<EOL>    if (totalCells > <NUM_LIT>) {<EOL>        <EOL>        cell = cells[<NUM_LIT>];<EOL>        previousCell = {<EOL>            row: <NUM_LIT>,<EOL>            width: <NUM_LIT>,<EOL>","gt":"height: <NUM_LIT>,"}
{"input":"<s> /**<EOL> * DOM READ<EOL> */<EOL>export function updateDimensions(plt: Platform, nodes: VirtualNode[], cells: VirtualCell[], data: VirtualData, initialUpdate: boolean) {<EOL>    let node: VirtualNode;<EOL>    let element: VirtualHtmlElement;<EOL>    let cell: VirtualCell;<EOL>    let previousCell: VirtualCell;<EOL>    const totalCells = cells.length;<EOL>    for (var i = <NUM_LIT>; i < nodes.length; i++) {<EOL>        node = nodes[i];<EOL>        cell = cells[node.cell];<EOL>        <EOL>        if (cell && cell.reads < REQUIRED_DOM_READS) {<EOL>            element = getElement(node);<EOL>            <EOL>            readElements(plt, cell, element);<EOL>            if (initialUpdate) {<EOL>                <EOL>                if (cell.tmpl === TemplateType.Header) {<EOL>                    data.hdrHeight = cell.height;<EOL>                    if (cell.left === <NUM_LIT>) {<EOL>                        data.hdrWidth = cell.width;<EOL>                    }<EOL>                }<EOL>                else if (cell.tmpl === TemplateType.Footer) {<EOL>                    data.ftrHeight = cell.height;<EOL>                    if (cell.left === <NUM_LIT>) {<EOL>                        data.ftrWidth = cell.width;<EOL>                    }<EOL>                }<EOL>                else {<EOL>                    data.itmHeight = cell.height;<EOL>                    if (cell.left === <NUM_LIT>) {<EOL>                        data.itmWidth = cell.width;<EOL>                    }<EOL>                }<EOL>            }<EOL>            cell.reads++;<EOL>        }<EOL>    }<EOL>    <EOL>    const viewableBottom = (data.scrollTop + data.viewHeight);<EOL>    data.topViewCell = totalCells;<EOL>    data.bottomViewCell = <NUM_LIT>;<EOL>    if (totalCells > <NUM_LIT>) {<EOL>        <EOL>        cell = cells[<NUM_LIT>];<EOL>        previousCell = {<EOL>            row: <NUM_LIT>,<EOL>            width: <NUM_LIT>,<EOL>            height: <NUM_LIT>,<EOL>            top: cell.top,<EOL>            left: <NUM_LIT>,<EOL>            tmpl: -<NUM_LIT><EOL>        };<EOL>        for (let i = <NUM_LIT>; i < totalCells; i++) {<EOL>            cell = cells[i];<EOL>            if (previousCell.left + previousCell.width + cell.width > data.viewWidth) {<EOL>                <EOL>","gt":"cell.row++;"}
{"input":"<s> /**<EOL> * DOM READ<EOL> */<EOL>export function updateDimensions(plt: Platform, nodes: VirtualNode[], cells: VirtualCell[], data: VirtualData, initialUpdate: boolean) {<EOL>    let node: VirtualNode;<EOL>    let element: VirtualHtmlElement;<EOL>    let cell: VirtualCell;<EOL>    let previousCell: VirtualCell;<EOL>    const totalCells = cells.length;<EOL>    for (var i = <NUM_LIT>; i < nodes.length; i++) {<EOL>        node = nodes[i];<EOL>        cell = cells[node.cell];<EOL>        <EOL>        if (cell && cell.reads < REQUIRED_DOM_READS) {<EOL>            element = getElement(node);<EOL>            <EOL>            readElements(plt, cell, element);<EOL>            if (initialUpdate) {<EOL>                <EOL>                if (cell.tmpl === TemplateType.Header) {<EOL>                    data.hdrHeight = cell.height;<EOL>                    if (cell.left === <NUM_LIT>) {<EOL>                        data.hdrWidth = cell.width;<EOL>                    }<EOL>                }<EOL>                else if (cell.tmpl === TemplateType.Footer) {<EOL>                    data.ftrHeight = cell.height;<EOL>                    if (cell.left === <NUM_LIT>) {<EOL>                        data.ftrWidth = cell.width;<EOL>                    }<EOL>                }<EOL>                else {<EOL>                    data.itmHeight = cell.height;<EOL>                    if (cell.left === <NUM_LIT>) {<EOL>                        data.itmWidth = cell.width;<EOL>                    }<EOL>                }<EOL>            }<EOL>            cell.reads++;<EOL>        }<EOL>    }<EOL>    <EOL>    const viewableBottom = (data.scrollTop + data.viewHeight);<EOL>    data.topViewCell = totalCells;<EOL>    data.bottomViewCell = <NUM_LIT>;<EOL>    if (totalCells > <NUM_LIT>) {<EOL>        <EOL>        cell = cells[<NUM_LIT>];<EOL>        previousCell = {<EOL>            row: <NUM_LIT>,<EOL>            width: <NUM_LIT>,<EOL>            height: <NUM_LIT>,<EOL>            top: cell.top,<EOL>            left: <NUM_LIT>,<EOL>            tmpl: -<NUM_LIT><EOL>        };<EOL>        for (let i = <NUM_LIT>; i < totalCells; i++) {<EOL>            cell = cells[i];<EOL>            if (previousCell.left + previousCell.width + cell.width > data.viewWidth) {<EOL>                <EOL>                cell.row++;<EOL>                cell.top = (previousCell.top + previousCell.height);<EOL>                cell.left = <NUM_LIT>;<EOL>            }<EOL>            else {<EOL>                <EOL>                cell.","gt":"row = previousCell.row;"}
{"input":"<s> function isA11yAttribute(attr) {<EOL>    <EOL>    <EOL>    <EOL>    switch (","gt":"attr.name.toLowerCase()) {"}
{"input":"<s> function isA11yAttribute(attr) {<EOL>    <EOL>    <EOL>    <EOL>    switch (attr.name.toLowerCase()) {<EOL>        case '<STR_LIT>':<EOL>","gt":"case '<STR_LIT>':"}
{"input":"<s> function isA11yAttribute(attr) {<EOL>    <EOL>    <EOL>    <EOL>    switch (attr.name.toLowerCase()) {<EOL>        case '<STR_LIT>':<EOL>        case '<STR_LIT>':<EOL>        case '<STR_LIT>':<EOL>","gt":"case '<STR_LIT>':"}
{"input":"<s> function isA11yAttribute(attr) {<EOL>    <EOL>    <EOL>    <EOL>    switch (attr.name.toLowerCase()) {<EOL>        case '<STR_LIT>':<EOL>        case '<STR_LIT>':<EOL>        case '<STR_LIT>':<EOL>        case '<STR_LIT>':<EOL>        case '<STR_LIT>':<EOL>        case '<STR_LIT>':<EOL>        case '<STR_LIT>':<EOL>        case '<STR_LIT>':<EOL>        case","gt":"'<STR_LIT>':"}
{"input":"<s> function isA11yAttribute(attr) {<EOL>    <EOL>    <EOL>    <EOL>    switch (attr.name.toLowerCase()) {<EOL>        case '<STR_LIT>':<EOL>        case '<STR_LIT>':<EOL>        case '<STR_LIT>':<EOL>        case '<STR_LIT>':<EOL>        case '<STR_LIT>':<EOL>        case '<STR_LIT>':<EOL>        case '<STR_LIT>':<EOL>        case '<STR_LIT>':<EOL>        case '<STR_LIT>':<EOL>        case '<STR_LIT>':<EOL>        case '<STR_LIT>':<EOL>        case '<STR_LIT>':<EOL>        case '<STR_LIT>':<EOL>","gt":"case '<STR_LIT>':"}
{"input":"<s> function isA11yAttribute(attr) {<EOL>    <EOL>    <EOL>    <EOL>    switch (attr.name.toLowerCase()) {<EOL>        case '<STR_LIT>':<EOL>        case '<STR_LIT>':<EOL>        case '<STR_LIT>':<EOL>        case '<STR_LIT>':<EOL>        case '<STR_LIT>':<EOL>        case '<STR_LIT>':<EOL>        case '<STR_LIT>':<EOL>        case '<STR_LIT>':<EOL>        case '<STR_LIT>':<EOL>        case '<STR_LIT>':<EOL>        case '<STR_LIT>':<EOL>        case '<STR_LIT>':<EOL>        case '<STR_LIT>':<EOL>        case '<STR_LIT>':<EOL>        case '<STR_LIT>':<EOL>        case '<STR_LIT>':<EOL>        case '<STR_LIT>':<EOL>        case '<STR_LIT>':<EOL>        case","gt":"'<STR_LIT>':"}
{"input":"<s> function isA11yAttribute(attr) {<EOL>    <EOL>    <EOL>    <EOL>    switch (attr.name.toLowerCase()) {<EOL>        case '<STR_LIT>':<EOL>        case '<STR_LIT>':<EOL>        case '<STR_LIT>':<EOL>        case '<STR_LIT>':<EOL>        case '<STR_LIT>':<EOL>        case '<STR_LIT>':<EOL>        case '<STR_LIT>':<EOL>        case '<STR_LIT>':<EOL>        case '<STR_LIT>':<EOL>        case '<STR_LIT>':<EOL>        case '<STR_LIT>':<EOL>        case '<STR_LIT>':<EOL>        case '<STR_LIT>':<EOL>        case '<STR_LIT>':<EOL>        case '<STR_LIT>':<EOL>        case '<STR_LIT>':<EOL>        case '<STR_LIT>':<EOL>        case '<STR_LIT>':<EOL>        case '<STR_LIT>':<EOL>        case '<STR_LIT>':<EOL>        case '<STR_LIT>':<EOL>        case '<STR_LIT>':<EOL>        case '<STR_LIT>':<EOL>        case '<STR_LIT>':<EOL>        case '<STR_LIT>':<EOL>        case '<STR_LIT>':<EOL>        case '<STR_LIT>':<EOL>        case","gt":"'<STR_LIT>':"}
{"input":"<s> function isA11yAttribute(attr) {<EOL>    <EOL>    <EOL>    <EOL>    switch (attr.name.toLowerCase()) {<EOL>        case '<STR_LIT>':<EOL>        case '<STR_LIT>':<EOL>        case '<STR_LIT>':<EOL>        case '<STR_LIT>':<EOL>        case '<STR_LIT>':<EOL>        case '<STR_LIT>':<EOL>        case '<STR_LIT>':<EOL>        case '<STR_LIT>':<EOL>        case '<STR_LIT>':<EOL>        case '<STR_LIT>':<EOL>        case '<STR_LIT>':<EOL>        case '<STR_LIT>':<EOL>        case '<STR_LIT>':<EOL>        case '<STR_LIT>':<EOL>        case '<STR_LIT>':<EOL>        case '<STR_LIT>':<EOL>        case '<STR_LIT>':<EOL>        case '<STR_LIT>':<EOL>        case '<STR_LIT>':<EOL>        case '<STR_LIT>':<EOL>        case '<STR_LIT>':<EOL>        case '<STR_LIT>':<EOL>        case '<STR_LIT>':<EOL>        case '<STR_LIT>':<EOL>        case '<STR_LIT>':<EOL>        case '<STR_LIT>':<EOL>        case '<STR_LIT>':<EOL>        case '<STR_LIT>':<EOL>        case '<STR_LIT>':<EOL>        case '<STR_LIT>':<EOL>        case '<STR_LIT>':<EOL>        case","gt":"'<STR_LIT>':"}
{"input":"<s> export function xyzToCIELab(x: number, y: number, z: number): Vec3 {<EOL>    let REF_X = <NUM_LIT>;<EOL>    let REF_Y = <NUM_LIT>;<EOL>    let REF_Z = <NUM_LIT>;<EOL>","gt":"x /= REF_X;"}
{"input":"<s> export function xyzToCIELab(x: number, y: number, z: number): Vec3 {<EOL>    let REF_X = <NUM_LIT>;<EOL>    let REF_Y = <NUM_LIT>;<EOL>    let REF_Z = <NUM_LIT>;<EOL>    x /= REF_X;<EOL>    y /= REF_Y;<EOL>    z /= REF_Z;<EOL>    x = x > <NUM_LIT> ? Math.pow(x, <NUM_LIT> / <NUM_LIT>) : <NUM_LIT> * x + <NUM_LIT> / <NUM_LIT>;<EOL>    y = y > <NUM_LIT> ? Math.pow(y, <NUM_LIT> / <NUM_LIT>) : <NUM_LIT> * y + <NUM_LIT> / <NUM_LIT>;<EOL>    z = z > <NUM_LIT> ? Math.pow(z, <NUM_LIT> / <NUM_LIT>) : <NUM_LIT> * z + <NUM_LIT> / <NUM_LIT>;<EOL>    let L = <NUM_LIT> * y -","gt":"<NUM_LIT>;"}
{"input":"<s> /**<EOL> * Create a `once` function wrapper.<EOL> */<EOL>function wrapOnce(target: Request, event: keyof Events, fn: (...args: any[]) => void) {<EOL>    let fired = false;<EOL>    const g: EventFn<typeof fn> = (...args: any[]) => {<EOL>        if (!fired) {<EOL>","gt":"fired = true;"}
{"input":"<s> <EOL>function onDatabaseInitDone() {<EOL>    const port = CONFIG.LISTEN.PORT;<EOL>    installApplication()<EOL>        .then(() => {<EOL>        <EOL>        server.listen(port, () => {<EOL>            <EOL>","gt":"Emailer.Instance.init();"}
{"input":"<s> <EOL>function onDatabaseInitDone() {<EOL>    const port = CONFIG.LISTEN.PORT;<EOL>    installApplication()<EOL>        .then(() => {<EOL>        <EOL>        server.listen(port, () => {<EOL>            <EOL>            Emailer.Instance.init();<EOL>            Emailer.Instance.checkConnectionOrDie()<EOL>                .then(() => JobQueue.Instance.init());<EOL>            <EOL>            VideosPreviewCache.Instance.","gt":"init(CONFIG.CACHE.PREVIEWS.SIZE);"}
{"input":"<s> <EOL>function onDatabaseInitDone() {<EOL>    const port = CONFIG.LISTEN.PORT;<EOL>    installApplication()<EOL>        .then(() => {<EOL>        <EOL>        server.listen(port, () => {<EOL>            <EOL>            Emailer.Instance.init();<EOL>            Emailer.Instance.checkConnectionOrDie()<EOL>                .then(() => JobQueue.Instance.init());<EOL>            <EOL>            VideosPreviewCache.Instance.init(CONFIG.CACHE.PREVIEWS.SIZE);<EOL>            <EOL>            BadActorFollowScheduler.Instance.enable();<EOL>            RemoveOldJobsScheduler.Instance.enable();<EOL>            <EOL>            Redis.Instance.","gt":"init();"}
{"input":"<s> export function platformPrettyName(platform: string) {<EOL>    if (platform === '<STR_LIT>') {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    else if (platform ===","gt":"'<STR_LIT>') {"}
{"input":"<s> export function platformPrettyName(platform: string) {<EOL>    if (platform === '<STR_LIT>') {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    else if (platform === '<STR_LIT>') {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    else if (platform === '<STR_LIT>') {<EOL>","gt":"return '<STR_LIT>';"}
{"input":"<s> export function links2md(str: string) {<EOL>    str = str.","gt":"replace(/((http|https):\\/\\/(\\w+:{0,1}\\w*@)?([^\\s\\*\\)`]+)(\\/|\\/([\\w#!:.?+=&%@!\\-\\/]))?)/g, '<STR_LIT>');"}
{"input":"<s> /**<EOL> * @private<EOL> *<EOL> *<EOL> * Before calling the original method, ensure Cordova and the plugin are installed.<EOL> */<EOL>export function CordovaProperty(target: any, key: string) {<EOL>    Object.defineProperty(target, key, {<EOL>        enumerable: true,<EOL>        get: () => {<EOL>            if (checkAvailability(target, key) === true) {<EOL>","gt":"return getPlugin(target.constructor.getPluginRef())[key];"}
{"input":"<s> /**<EOL> * @private<EOL> *<EOL> *<EOL> * Before calling the original method, ensure Cordova and the plugin are installed.<EOL> */<EOL>export function CordovaProperty(target: any, key: string) {<EOL>    Object.defineProperty(target, key, {<EOL>        enumerable: true,<EOL>        get: () => {<EOL>            if (checkAvailability(target, key) === true) {<EOL>                return getPlugin(target.constructor.getPluginRef())[key];<EOL>            }<EOL>            else {<EOL>                return null;<EOL>            }<EOL>        },<EOL>        set: (value) => {<EOL>            if (checkAvailability(target, key) === true) {<EOL>                getPlugin(target.constructor.getPluginRef())[","gt":"key] = value;"}
{"input":"<s> /**<EOL> * Create the external version of a uri<EOL> */<EOL>function _asFormatted(uri: URI, skipEncoding: boolean): string {<EOL>    const encoder = !skipEncoding<EOL>        ? encodeURIComponent2<EOL>        :","gt":"encodeNoop;"}
{"input":"<s> /**<EOL> * Create the external version of a uri<EOL> */<EOL>function _asFormatted(uri: URI, skipEncoding: boolean): string {<EOL>    const encoder = !skipEncoding<EOL>        ? encodeURIComponent2<EOL>        : encodeNoop;<EOL>    const parts: string[] = [];<EOL>    let { scheme, authority, path, query, fragment } = uri;<EOL>","gt":"if (scheme) {"}
{"input":"<s> /**<EOL> * Create the external version of a uri<EOL> */<EOL>function _asFormatted(uri: URI, skipEncoding: boolean): string {<EOL>    const encoder = !skipEncoding<EOL>        ? encodeURIComponent2<EOL>        : encodeNoop;<EOL>    const parts: string[] = [];<EOL>    let { scheme, authority, path, query, fragment } = uri;<EOL>    if (scheme) {<EOL>        parts.push(scheme, '<STR_LIT>');<EOL>    }<EOL>    if (authority ||","gt":"scheme === '<STR_LIT>') {"}
{"input":"<s> /**<EOL> * Create the external version of a uri<EOL> */<EOL>function _asFormatted(uri: URI, skipEncoding: boolean): string {<EOL>    const encoder = !skipEncoding<EOL>        ? encodeURIComponent2<EOL>        : encodeNoop;<EOL>    const parts: string[] = [];<EOL>    let { scheme, authority, path, query, fragment } = uri;<EOL>    if (scheme) {<EOL>        parts.push(scheme, '<STR_LIT>');<EOL>    }<EOL>    if (authority || scheme === '<STR_LIT>') {<EOL>        parts.push('<STR_LIT>');<EOL>    }<EOL>    if (authority) {<EOL>        let idx = authority.","gt":"indexOf('<STR_LIT>');"}
{"input":"<s> /**<EOL> * Create the external version of a uri<EOL> */<EOL>function _asFormatted(uri: URI, skipEncoding: boolean): string {<EOL>    const encoder = !skipEncoding<EOL>        ? encodeURIComponent2<EOL>        : encodeNoop;<EOL>    const parts: string[] = [];<EOL>    let { scheme, authority, path, query, fragment } = uri;<EOL>    if (scheme) {<EOL>        parts.push(scheme, '<STR_LIT>');<EOL>    }<EOL>    if (authority || scheme === '<STR_LIT>') {<EOL>        parts.push('<STR_LIT>');<EOL>    }<EOL>    if (authority) {<EOL>        let idx = authority.indexOf('<STR_LIT>');<EOL>        if (","gt":"idx !== -<NUM_LIT>) {"}
{"input":"<s> /**<EOL> * Create the external version of a uri<EOL> */<EOL>function _asFormatted(uri: URI, skipEncoding: boolean): string {<EOL>    const encoder = !skipEncoding<EOL>        ? encodeURIComponent2<EOL>        : encodeNoop;<EOL>    const parts: string[] = [];<EOL>    let { scheme, authority, path, query, fragment } = uri;<EOL>    if (scheme) {<EOL>        parts.push(scheme, '<STR_LIT>');<EOL>    }<EOL>    if (authority || scheme === '<STR_LIT>') {<EOL>        parts.push('<STR_LIT>');<EOL>    }<EOL>    if (authority) {<EOL>        let idx = authority.indexOf('<STR_LIT>');<EOL>        if (idx !== -<NUM_LIT>) {<EOL>            const userinfo = authority.substr(<NUM_LIT>, idx);<EOL>            authority = authority.substr(idx + <NUM_LIT>);<EOL>            idx = userinfo.indexOf('<STR_LIT>');<EOL>            if (idx === -<NUM_LIT>) {<EOL>                parts.push(encoder(userinfo));<EOL>            }<EOL>            else {<EOL>                parts.push(encoder(userinfo.substr(<NUM_LIT>, idx)), '<STR_LIT>', encoder(userinfo.substr(idx + <NUM_LIT>)));<EOL>            }<EOL>            parts.push('<STR_LIT>');<EOL>        }<EOL>        authority = authority.toLowerCase();<EOL>        idx = authority.indexOf(","gt":"'<STR_LIT>');"}
{"input":"<s> /**<EOL> * Create the external version of a uri<EOL> */<EOL>function _asFormatted(uri: URI, skipEncoding: boolean): string {<EOL>    const encoder = !skipEncoding<EOL>        ? encodeURIComponent2<EOL>        : encodeNoop;<EOL>    const parts: string[] = [];<EOL>    let { scheme, authority, path, query, fragment } = uri;<EOL>    if (scheme) {<EOL>        parts.push(scheme, '<STR_LIT>');<EOL>    }<EOL>    if (authority || scheme === '<STR_LIT>') {<EOL>        parts.push('<STR_LIT>');<EOL>    }<EOL>    if (authority) {<EOL>        let idx = authority.indexOf('<STR_LIT>');<EOL>        if (idx !== -<NUM_LIT>) {<EOL>            const userinfo = authority.substr(<NUM_LIT>, idx);<EOL>            authority = authority.substr(idx + <NUM_LIT>);<EOL>            idx = userinfo.indexOf('<STR_LIT>');<EOL>            if (idx === -<NUM_LIT>) {<EOL>                parts.push(encoder(userinfo));<EOL>            }<EOL>            else {<EOL>                parts.push(encoder(userinfo.substr(<NUM_LIT>, idx)), '<STR_LIT>', encoder(userinfo.substr(idx + <NUM_LIT>)));<EOL>            }<EOL>            parts.push('<STR_LIT>');<EOL>        }<EOL>        authority = authority.toLowerCase();<EOL>        idx = authority.indexOf('<STR_LIT>');<EOL>        if (idx === -<NUM_LIT>) {<EOL>            parts.push(encoder(authority));<EOL>        }<EOL>        else {<EOL>            parts.push(encoder(authority.substr(<NUM_LIT>, idx)), authority.substr(idx));<EOL>        }<EOL>    }<EOL>    if (","gt":"path) {"}
{"input":"<s> /**<EOL> * Create the external version of a uri<EOL> */<EOL>function _asFormatted(uri: URI, skipEncoding: boolean): string {<EOL>    const encoder = !skipEncoding<EOL>        ? encodeURIComponent2<EOL>        : encodeNoop;<EOL>    const parts: string[] = [];<EOL>    let { scheme, authority, path, query, fragment } = uri;<EOL>    if (scheme) {<EOL>        parts.push(scheme, '<STR_LIT>');<EOL>    }<EOL>    if (authority || scheme === '<STR_LIT>') {<EOL>        parts.push('<STR_LIT>');<EOL>    }<EOL>    if (authority) {<EOL>        let idx = authority.indexOf('<STR_LIT>');<EOL>        if (idx !== -<NUM_LIT>) {<EOL>            const userinfo = authority.substr(<NUM_LIT>, idx);<EOL>            authority = authority.substr(idx + <NUM_LIT>);<EOL>            idx = userinfo.indexOf('<STR_LIT>');<EOL>            if (idx === -<NUM_LIT>) {<EOL>                parts.push(encoder(userinfo));<EOL>            }<EOL>            else {<EOL>                parts.push(encoder(userinfo.substr(<NUM_LIT>, idx)), '<STR_LIT>', encoder(userinfo.substr(idx + <NUM_LIT>)));<EOL>            }<EOL>            parts.push('<STR_LIT>');<EOL>        }<EOL>        authority = authority.toLowerCase();<EOL>        idx = authority.indexOf('<STR_LIT>');<EOL>        if (idx === -<NUM_LIT>) {<EOL>            parts.push(encoder(authority));<EOL>        }<EOL>        else {<EOL>            parts.push(encoder(authority.substr(<NUM_LIT>, idx)), authority.substr(idx));<EOL>        }<EOL>    }<EOL>    if (path) {<EOL>        <EOL>        const m = _upperCaseDrive.exec(path);<EOL>        if (m) {<EOL>            if (m[<NUM_LIT>]) {<EOL>","gt":"path = '<STR_LIT>' + m[<NUM_LIT>].toLowerCase() + path.substr(<NUM_LIT>);"}
{"input":"<s> /**<EOL> * Create the external version of a uri<EOL> */<EOL>function _asFormatted(uri: URI, skipEncoding: boolean): string {<EOL>    const encoder = !skipEncoding<EOL>        ? encodeURIComponent2<EOL>        : encodeNoop;<EOL>    const parts: string[] = [];<EOL>    let { scheme, authority, path, query, fragment } = uri;<EOL>    if (scheme) {<EOL>        parts.push(scheme, '<STR_LIT>');<EOL>    }<EOL>    if (authority || scheme === '<STR_LIT>') {<EOL>        parts.push('<STR_LIT>');<EOL>    }<EOL>    if (authority) {<EOL>        let idx = authority.indexOf('<STR_LIT>');<EOL>        if (idx !== -<NUM_LIT>) {<EOL>            const userinfo = authority.substr(<NUM_LIT>, idx);<EOL>            authority = authority.substr(idx + <NUM_LIT>);<EOL>            idx = userinfo.indexOf('<STR_LIT>');<EOL>            if (idx === -<NUM_LIT>) {<EOL>                parts.push(encoder(userinfo));<EOL>            }<EOL>            else {<EOL>                parts.push(encoder(userinfo.substr(<NUM_LIT>, idx)), '<STR_LIT>', encoder(userinfo.substr(idx + <NUM_LIT>)));<EOL>            }<EOL>            parts.push('<STR_LIT>');<EOL>        }<EOL>        authority = authority.toLowerCase();<EOL>        idx = authority.indexOf('<STR_LIT>');<EOL>        if (idx === -<NUM_LIT>) {<EOL>            parts.push(encoder(authority));<EOL>        }<EOL>        else {<EOL>            parts.push(encoder(authority.substr(<NUM_LIT>, idx)), authority.substr(idx));<EOL>        }<EOL>    }<EOL>    if (path) {<EOL>        <EOL>        const m = _upperCaseDrive.exec(path);<EOL>        if (m) {<EOL>            if (m[<NUM_LIT>]) {<EOL>                path = '<STR_LIT>' + m[<NUM_LIT>].toLowerCase() + path.substr(<NUM_LIT>); <EOL>            }<EOL>","gt":"else {"}
{"input":"<s> /**<EOL> * Create the external version of a uri<EOL> */<EOL>function _asFormatted(uri: URI, skipEncoding: boolean): string {<EOL>    const encoder = !skipEncoding<EOL>        ? encodeURIComponent2<EOL>        : encodeNoop;<EOL>    const parts: string[] = [];<EOL>    let { scheme, authority, path, query, fragment } = uri;<EOL>    if (scheme) {<EOL>        parts.push(scheme, '<STR_LIT>');<EOL>    }<EOL>    if (authority || scheme === '<STR_LIT>') {<EOL>        parts.push('<STR_LIT>');<EOL>    }<EOL>    if (authority) {<EOL>        let idx = authority.indexOf('<STR_LIT>');<EOL>        if (idx !== -<NUM_LIT>) {<EOL>            const userinfo = authority.substr(<NUM_LIT>, idx);<EOL>            authority = authority.substr(idx + <NUM_LIT>);<EOL>            idx = userinfo.indexOf('<STR_LIT>');<EOL>            if (idx === -<NUM_LIT>) {<EOL>                parts.push(encoder(userinfo));<EOL>            }<EOL>            else {<EOL>                parts.push(encoder(userinfo.substr(<NUM_LIT>, idx)), '<STR_LIT>', encoder(userinfo.substr(idx + <NUM_LIT>)));<EOL>            }<EOL>            parts.push('<STR_LIT>');<EOL>        }<EOL>        authority = authority.toLowerCase();<EOL>        idx = authority.indexOf('<STR_LIT>');<EOL>        if (idx === -<NUM_LIT>) {<EOL>            parts.push(encoder(authority));<EOL>        }<EOL>        else {<EOL>            parts.push(encoder(authority.substr(<NUM_LIT>, idx)), authority.substr(idx));<EOL>        }<EOL>    }<EOL>    if (path) {<EOL>        <EOL>        const m = _upperCaseDrive.exec(path);<EOL>        if (m) {<EOL>            if (m[<NUM_LIT>]) {<EOL>                path = '<STR_LIT>' + m[<NUM_LIT>].toLowerCase() + path.substr(<NUM_LIT>); <EOL>            }<EOL>            else {<EOL>                path = m[<NUM_LIT>].toLowerCase() + path.substr(<NUM_LIT>); <EOL>            }<EOL>        }<EOL>        <EOL>        <EOL>        <EOL>        <EOL>        let","gt":"lastIdx = <NUM_LIT>;"}
{"input":"<s> /**<EOL> * Create the external version of a uri<EOL> */<EOL>function _asFormatted(uri: URI, skipEncoding: boolean): string {<EOL>    const encoder = !skipEncoding<EOL>        ? encodeURIComponent2<EOL>        : encodeNoop;<EOL>    const parts: string[] = [];<EOL>    let { scheme, authority, path, query, fragment } = uri;<EOL>    if (scheme) {<EOL>        parts.push(scheme, '<STR_LIT>');<EOL>    }<EOL>    if (authority || scheme === '<STR_LIT>') {<EOL>        parts.push('<STR_LIT>');<EOL>    }<EOL>    if (authority) {<EOL>        let idx = authority.indexOf('<STR_LIT>');<EOL>        if (idx !== -<NUM_LIT>) {<EOL>            const userinfo = authority.substr(<NUM_LIT>, idx);<EOL>            authority = authority.substr(idx + <NUM_LIT>);<EOL>            idx = userinfo.indexOf('<STR_LIT>');<EOL>            if (idx === -<NUM_LIT>) {<EOL>                parts.push(encoder(userinfo));<EOL>            }<EOL>            else {<EOL>                parts.push(encoder(userinfo.substr(<NUM_LIT>, idx)), '<STR_LIT>', encoder(userinfo.substr(idx + <NUM_LIT>)));<EOL>            }<EOL>            parts.push('<STR_LIT>');<EOL>        }<EOL>        authority = authority.toLowerCase();<EOL>        idx = authority.indexOf('<STR_LIT>');<EOL>        if (idx === -<NUM_LIT>) {<EOL>            parts.push(encoder(authority));<EOL>        }<EOL>        else {<EOL>            parts.push(encoder(authority.substr(<NUM_LIT>, idx)), authority.substr(idx));<EOL>        }<EOL>    }<EOL>    if (path) {<EOL>        <EOL>        const m = _upperCaseDrive.exec(path);<EOL>        if (m) {<EOL>            if (m[<NUM_LIT>]) {<EOL>                path = '<STR_LIT>' + m[<NUM_LIT>].toLowerCase() + path.substr(<NUM_LIT>); <EOL>            }<EOL>            else {<EOL>                path = m[<NUM_LIT>].toLowerCase() + path.substr(<NUM_LIT>); <EOL>            }<EOL>        }<EOL>        <EOL>        <EOL>        <EOL>        <EOL>        let lastIdx = <NUM_LIT>;<EOL>        while (true) {<EOL>            let idx = path.indexOf(_slash, lastIdx);<EOL>            if (idx === -<NUM_LIT>) {<EOL>                parts.push(encoder(path.substring(lastIdx)));<EOL>","gt":"break;"}
{"input":"<s> /**<EOL> * Create the external version of a uri<EOL> */<EOL>function _asFormatted(uri: URI, skipEncoding: boolean): string {<EOL>    const encoder = !skipEncoding<EOL>        ? encodeURIComponent2<EOL>        : encodeNoop;<EOL>    const parts: string[] = [];<EOL>    let { scheme, authority, path, query, fragment } = uri;<EOL>    if (scheme) {<EOL>        parts.push(scheme, '<STR_LIT>');<EOL>    }<EOL>    if (authority || scheme === '<STR_LIT>') {<EOL>        parts.push('<STR_LIT>');<EOL>    }<EOL>    if (authority) {<EOL>        let idx = authority.indexOf('<STR_LIT>');<EOL>        if (idx !== -<NUM_LIT>) {<EOL>            const userinfo = authority.substr(<NUM_LIT>, idx);<EOL>            authority = authority.substr(idx + <NUM_LIT>);<EOL>            idx = userinfo.indexOf('<STR_LIT>');<EOL>            if (idx === -<NUM_LIT>) {<EOL>                parts.push(encoder(userinfo));<EOL>            }<EOL>            else {<EOL>                parts.push(encoder(userinfo.substr(<NUM_LIT>, idx)), '<STR_LIT>', encoder(userinfo.substr(idx + <NUM_LIT>)));<EOL>            }<EOL>            parts.push('<STR_LIT>');<EOL>        }<EOL>        authority = authority.toLowerCase();<EOL>        idx = authority.indexOf('<STR_LIT>');<EOL>        if (idx === -<NUM_LIT>) {<EOL>            parts.push(encoder(authority));<EOL>        }<EOL>        else {<EOL>            parts.push(encoder(authority.substr(<NUM_LIT>, idx)), authority.substr(idx));<EOL>        }<EOL>    }<EOL>    if (path) {<EOL>        <EOL>        const m = _upperCaseDrive.exec(path);<EOL>        if (m) {<EOL>            if (m[<NUM_LIT>]) {<EOL>                path = '<STR_LIT>' + m[<NUM_LIT>].toLowerCase() + path.substr(<NUM_LIT>); <EOL>            }<EOL>            else {<EOL>                path = m[<NUM_LIT>].toLowerCase() + path.substr(<NUM_LIT>); <EOL>            }<EOL>        }<EOL>        <EOL>        <EOL>        <EOL>        <EOL>        let lastIdx = <NUM_LIT>;<EOL>        while (true) {<EOL>            let idx = path.indexOf(_slash, lastIdx);<EOL>            if (idx === -<NUM_LIT>) {<EOL>                parts.push(encoder(path.substring(lastIdx)));<EOL>                break;<EOL>            }<EOL>            parts.push(encoder(path.substring(lastIdx, idx)), _slash);<EOL>            lastIdx = idx +","gt":"<NUM_LIT>;"}
{"input":"<s> function fetchJson(fileName: string, parentAddress: string): Promise<string> {<EOL>    return Promise.resolve(JSON.stringify({ compilerOptions: { target:","gt":"'<STR_LIT>' } }));"}
{"input":"<s> export function hydrateHtml(config: Config, ctx: CompilerCtx, cmpRegistry: ComponentRegistry, opts: HydrateOptions): Promise<HydrateResults> {<EOL>    return new Promise(resolve => {<EOL>        <EOL>        opts = normalizeHydrateOptions(opts);<EOL>        <EOL>","gt":"const hydrateResults = generateHydrateResults(config, opts);"}
{"input":"<s> export function hydrateHtml(config: Config, ctx: CompilerCtx, cmpRegistry: ComponentRegistry, opts: HydrateOptions): Promise<HydrateResults> {<EOL>    return new Promise(resolve => {<EOL>        <EOL>        opts = normalizeHydrateOptions(opts);<EOL>        <EOL>        const hydrateResults = generateHydrateResults(config, opts);<EOL>        <EOL>        <EOL>        const dom = config.sys.createDom();<EOL>        const","gt":"win = dom.parse(opts);"}
{"input":"<s> export function hydrateHtml(config: Config, ctx: CompilerCtx, cmpRegistry: ComponentRegistry, opts: HydrateOptions): Promise<HydrateResults> {<EOL>    return new Promise(resolve => {<EOL>        <EOL>        opts = normalizeHydrateOptions(opts);<EOL>        <EOL>        const hydrateResults = generateHydrateResults(config, opts);<EOL>        <EOL>        <EOL>        const dom = config.sys.createDom();<EOL>        const win = dom.parse(opts);<EOL>        const doc = win.document;<EOL>        <EOL>        <EOL>        normalizeDirection(doc,","gt":"opts);"}
{"input":"<s> export function hydrateHtml(config: Config, ctx: CompilerCtx, cmpRegistry: ComponentRegistry, opts: HydrateOptions): Promise<HydrateResults> {<EOL>    return new Promise(resolve => {<EOL>        <EOL>        opts = normalizeHydrateOptions(opts);<EOL>        <EOL>        const hydrateResults = generateHydrateResults(config, opts);<EOL>        <EOL>        <EOL>        const dom = config.sys.createDom();<EOL>        const win = dom.parse(opts);<EOL>        const doc = win.document;<EOL>        <EOL>        <EOL>        normalizeDirection(doc, opts);<EOL>        normalizeLanguage(doc, opts);<EOL>        <EOL>        const plt = createPlatformServer(config, win, doc, cmpRegistry, hydrateResults, opts.isPrerender, ctx);<EOL>        <EOL>        <EOL>        plt.onAppLoad = async (rootElm, styles, failureDiagnostic) => {<EOL>            if (config.","gt":"_isTesting) {"}
{"input":"<s> export function hydrateHtml(config: Config, ctx: CompilerCtx, cmpRegistry: ComponentRegistry, opts: HydrateOptions): Promise<HydrateResults> {<EOL>    return new Promise(resolve => {<EOL>        <EOL>        opts = normalizeHydrateOptions(opts);<EOL>        <EOL>        const hydrateResults = generateHydrateResults(config, opts);<EOL>        <EOL>        <EOL>        const dom = config.sys.createDom();<EOL>        const win = dom.parse(opts);<EOL>        const doc = win.document;<EOL>        <EOL>        <EOL>        normalizeDirection(doc, opts);<EOL>        normalizeLanguage(doc, opts);<EOL>        <EOL>        const plt = createPlatformServer(config, win, doc, cmpRegistry, hydrateResults, opts.isPrerender, ctx);<EOL>        <EOL>        <EOL>        plt.onAppLoad = async (rootElm, styles, failureDiagnostic) => {<EOL>            if (config._isTesting) {<EOL>                (","gt":"hydrateResults as any).__testPlatform = plt;"}
{"input":"<s> export function hydrateHtml(config: Config, ctx: CompilerCtx, cmpRegistry: ComponentRegistry, opts: HydrateOptions): Promise<HydrateResults> {<EOL>    return new Promise(resolve => {<EOL>        <EOL>        opts = normalizeHydrateOptions(opts);<EOL>        <EOL>        const hydrateResults = generateHydrateResults(config, opts);<EOL>        <EOL>        <EOL>        const dom = config.sys.createDom();<EOL>        const win = dom.parse(opts);<EOL>        const doc = win.document;<EOL>        <EOL>        <EOL>        normalizeDirection(doc, opts);<EOL>        normalizeLanguage(doc, opts);<EOL>        <EOL>        const plt = createPlatformServer(config, win, doc, cmpRegistry, hydrateResults, opts.isPrerender, ctx);<EOL>        <EOL>        <EOL>        plt.onAppLoad = async (rootElm, styles, failureDiagnostic) => {<EOL>            if (config._isTesting) {<EOL>                (hydrateResults as any).__testPlatform = plt;<EOL>            }<EOL>            if (failureDiagnostic) {<EOL>                hydrateResults.html = generateFailureDiagnostic(failureDiagnostic);<EOL>                dom.destroy();<EOL>                resolve(hydrateResults);<EOL>                return;<EOL>            }<EOL>            <EOL>            if (","gt":"rootElm) {"}
{"input":"<s> export function hydrateHtml(config: Config, ctx: CompilerCtx, cmpRegistry: ComponentRegistry, opts: HydrateOptions): Promise<HydrateResults> {<EOL>    return new Promise(resolve => {<EOL>        <EOL>        opts = normalizeHydrateOptions(opts);<EOL>        <EOL>        const hydrateResults = generateHydrateResults(config, opts);<EOL>        <EOL>        <EOL>        const dom = config.sys.createDom();<EOL>        const win = dom.parse(opts);<EOL>        const doc = win.document;<EOL>        <EOL>        <EOL>        normalizeDirection(doc, opts);<EOL>        normalizeLanguage(doc, opts);<EOL>        <EOL>        const plt = createPlatformServer(config, win, doc, cmpRegistry, hydrateResults, opts.isPrerender, ctx);<EOL>        <EOL>        <EOL>        plt.onAppLoad = async (rootElm, styles, failureDiagnostic) => {<EOL>            if (config._isTesting) {<EOL>                (hydrateResults as any).__testPlatform = plt;<EOL>            }<EOL>            if (failureDiagnostic) {<EOL>                hydrateResults.html = generateFailureDiagnostic(failureDiagnostic);<EOL>                dom.destroy();<EOL>                resolve(hydrateResults);<EOL>                return;<EOL>            }<EOL>            <EOL>            if (rootElm) {<EOL>                try {<EOL>                    <EOL>                    await optimizeHtml(config, ctx,","gt":"doc, styles, opts, hydrateResults);"}
{"input":"<s> export function hydrateHtml(config: Config, ctx: CompilerCtx, cmpRegistry: ComponentRegistry, opts: HydrateOptions): Promise<HydrateResults> {<EOL>    return new Promise(resolve => {<EOL>        <EOL>        opts = normalizeHydrateOptions(opts);<EOL>        <EOL>        const hydrateResults = generateHydrateResults(config, opts);<EOL>        <EOL>        <EOL>        const dom = config.sys.createDom();<EOL>        const win = dom.parse(opts);<EOL>        const doc = win.document;<EOL>        <EOL>        <EOL>        normalizeDirection(doc, opts);<EOL>        normalizeLanguage(doc, opts);<EOL>        <EOL>        const plt = createPlatformServer(config, win, doc, cmpRegistry, hydrateResults, opts.isPrerender, ctx);<EOL>        <EOL>        <EOL>        plt.onAppLoad = async (rootElm, styles, failureDiagnostic) => {<EOL>            if (config._isTesting) {<EOL>                (hydrateResults as any).__testPlatform = plt;<EOL>            }<EOL>            if (failureDiagnostic) {<EOL>                hydrateResults.html = generateFailureDiagnostic(failureDiagnostic);<EOL>                dom.destroy();<EOL>                resolve(hydrateResults);<EOL>                return;<EOL>            }<EOL>            <EOL>            if (rootElm) {<EOL>                try {<EOL>                    <EOL>                    await optimizeHtml(config, ctx, doc, styles, opts, hydrateResults);<EOL>                    <EOL>                    if (opts.collectAnchors !== false && opts.hydrateComponents !== false) {<EOL>                        collectAnchors(config, doc, hydrateResults);<EOL>                    }<EOL>                    <EOL>                    if (opts.serializeHtml !== false) {<EOL>                        hydrateResults.html = dom.serialize();<EOL>                    }<EOL>                }<EOL>                catch (","gt":"e) {"}
{"input":"<s> export function hydrateHtml(config: Config, ctx: CompilerCtx, cmpRegistry: ComponentRegistry, opts: HydrateOptions): Promise<HydrateResults> {<EOL>    return new Promise(resolve => {<EOL>        <EOL>        opts = normalizeHydrateOptions(opts);<EOL>        <EOL>        const hydrateResults = generateHydrateResults(config, opts);<EOL>        <EOL>        <EOL>        const dom = config.sys.createDom();<EOL>        const win = dom.parse(opts);<EOL>        const doc = win.document;<EOL>        <EOL>        <EOL>        normalizeDirection(doc, opts);<EOL>        normalizeLanguage(doc, opts);<EOL>        <EOL>        const plt = createPlatformServer(config, win, doc, cmpRegistry, hydrateResults, opts.isPrerender, ctx);<EOL>        <EOL>        <EOL>        plt.onAppLoad = async (rootElm, styles, failureDiagnostic) => {<EOL>            if (config._isTesting) {<EOL>                (hydrateResults as any).__testPlatform = plt;<EOL>            }<EOL>            if (failureDiagnostic) {<EOL>                hydrateResults.html = generateFailureDiagnostic(failureDiagnostic);<EOL>                dom.destroy();<EOL>                resolve(hydrateResults);<EOL>                return;<EOL>            }<EOL>            <EOL>            if (rootElm) {<EOL>                try {<EOL>                    <EOL>                    await optimizeHtml(config, ctx, doc, styles, opts, hydrateResults);<EOL>                    <EOL>                    if (opts.collectAnchors !== false && opts.hydrateComponents !== false) {<EOL>                        collectAnchors(config, doc, hydrateResults);<EOL>                    }<EOL>                    <EOL>                    if (opts.serializeHtml !== false) {<EOL>                        hydrateResults.html = dom.serialize();<EOL>                    }<EOL>                }<EOL>                catch (e) {<EOL>                    <EOL>                    hydrateResults.diagnostics.push({<EOL>                        level: '<STR_LIT>',<EOL>                        type: '<STR_LIT>',<EOL>                        header: '<STR_LIT>',<EOL>                        messageText: e<EOL>                    });<EOL>                    <EOL>                    hydrateResults.html = opts.html;<EOL>                }<EOL>            }<EOL>            if (opts.destroyDom !== false) {<EOL>                <EOL>                dom.destroy();<EOL>            }<EOL>","gt":"else {"}
{"input":"<s> export function hydrateHtml(config: Config, ctx: CompilerCtx, cmpRegistry: ComponentRegistry, opts: HydrateOptions): Promise<HydrateResults> {<EOL>    return new Promise(resolve => {<EOL>        <EOL>        opts = normalizeHydrateOptions(opts);<EOL>        <EOL>        const hydrateResults = generateHydrateResults(config, opts);<EOL>        <EOL>        <EOL>        const dom = config.sys.createDom();<EOL>        const win = dom.parse(opts);<EOL>        const doc = win.document;<EOL>        <EOL>        <EOL>        normalizeDirection(doc, opts);<EOL>        normalizeLanguage(doc, opts);<EOL>        <EOL>        const plt = createPlatformServer(config, win, doc, cmpRegistry, hydrateResults, opts.isPrerender, ctx);<EOL>        <EOL>        <EOL>        plt.onAppLoad = async (rootElm, styles, failureDiagnostic) => {<EOL>            if (config._isTesting) {<EOL>                (hydrateResults as any).__testPlatform = plt;<EOL>            }<EOL>            if (failureDiagnostic) {<EOL>                hydrateResults.html = generateFailureDiagnostic(failureDiagnostic);<EOL>                dom.destroy();<EOL>                resolve(hydrateResults);<EOL>                return;<EOL>            }<EOL>            <EOL>            if (rootElm) {<EOL>                try {<EOL>                    <EOL>                    await optimizeHtml(config, ctx, doc, styles, opts, hydrateResults);<EOL>                    <EOL>                    if (opts.collectAnchors !== false && opts.hydrateComponents !== false) {<EOL>                        collectAnchors(config, doc, hydrateResults);<EOL>                    }<EOL>                    <EOL>                    if (opts.serializeHtml !== false) {<EOL>                        hydrateResults.html = dom.serialize();<EOL>                    }<EOL>                }<EOL>                catch (e) {<EOL>                    <EOL>                    hydrateResults.diagnostics.push({<EOL>                        level: '<STR_LIT>',<EOL>                        type: '<STR_LIT>',<EOL>                        header: '<STR_LIT>',<EOL>                        messageText: e<EOL>                    });<EOL>                    <EOL>                    hydrateResults.html = opts.html;<EOL>                }<EOL>            }<EOL>            if (opts.destroyDom !== false) {<EOL>                <EOL>                dom.destroy();<EOL>            }<EOL>            else {<EOL>                <EOL>                <EOL>                hydrateResults.root = rootElm;<EOL>            }<EOL>            <EOL>            <EOL>            resolve(hydrateResults);<EOL>        };<EOL>        if (opts.hydrateComponents === false) {<EOL>            plt.onAppLoad(win.document.body as any, []);<EOL>            return;<EOL>        }<EOL>        <EOL>        <EOL>        let ssrIds = <NUM_LIT>;<EOL>        const pltRender = plt.render;<EOL>        plt.render = function render(oldVNode: VNode, newVNode, isUpdate, defaultSlots, namedSlotsMap, encapsulation) {<EOL>            let ssrId: number;<EOL>            let existingSsrId: string;<EOL>            if (opts.ssrIds !== false) {<EOL>                <EOL>                <EOL>                if (oldVNode && oldVNode.elm) {<EOL>                    existingSsrId = (oldVNode.elm as HTMLElement).getAttribute(SSR_VNODE_ID);<EOL>                }<EOL>                if (existingSsrId) {<EOL>                    ssrId = parseInt(existingSsrId,","gt":"<NUM_LIT>);"}
{"input":"<s> export function hydrateHtml(config: Config, ctx: CompilerCtx, cmpRegistry: ComponentRegistry, opts: HydrateOptions): Promise<HydrateResults> {<EOL>    return new Promise(resolve => {<EOL>        <EOL>        opts = normalizeHydrateOptions(opts);<EOL>        <EOL>        const hydrateResults = generateHydrateResults(config, opts);<EOL>        <EOL>        <EOL>        const dom = config.sys.createDom();<EOL>        const win = dom.parse(opts);<EOL>        const doc = win.document;<EOL>        <EOL>        <EOL>        normalizeDirection(doc, opts);<EOL>        normalizeLanguage(doc, opts);<EOL>        <EOL>        const plt = createPlatformServer(config, win, doc, cmpRegistry, hydrateResults, opts.isPrerender, ctx);<EOL>        <EOL>        <EOL>        plt.onAppLoad = async (rootElm, styles, failureDiagnostic) => {<EOL>            if (config._isTesting) {<EOL>                (hydrateResults as any).__testPlatform = plt;<EOL>            }<EOL>            if (failureDiagnostic) {<EOL>                hydrateResults.html = generateFailureDiagnostic(failureDiagnostic);<EOL>                dom.destroy();<EOL>                resolve(hydrateResults);<EOL>                return;<EOL>            }<EOL>            <EOL>            if (rootElm) {<EOL>                try {<EOL>                    <EOL>                    await optimizeHtml(config, ctx, doc, styles, opts, hydrateResults);<EOL>                    <EOL>                    if (opts.collectAnchors !== false && opts.hydrateComponents !== false) {<EOL>                        collectAnchors(config, doc, hydrateResults);<EOL>                    }<EOL>                    <EOL>                    if (opts.serializeHtml !== false) {<EOL>                        hydrateResults.html = dom.serialize();<EOL>                    }<EOL>                }<EOL>                catch (e) {<EOL>                    <EOL>                    hydrateResults.diagnostics.push({<EOL>                        level: '<STR_LIT>',<EOL>                        type: '<STR_LIT>',<EOL>                        header: '<STR_LIT>',<EOL>                        messageText: e<EOL>                    });<EOL>                    <EOL>                    hydrateResults.html = opts.html;<EOL>                }<EOL>            }<EOL>            if (opts.destroyDom !== false) {<EOL>                <EOL>                dom.destroy();<EOL>            }<EOL>            else {<EOL>                <EOL>                <EOL>                hydrateResults.root = rootElm;<EOL>            }<EOL>            <EOL>            <EOL>            resolve(hydrateResults);<EOL>        };<EOL>        if (opts.hydrateComponents === false) {<EOL>            plt.onAppLoad(win.document.body as any, []);<EOL>            return;<EOL>        }<EOL>        <EOL>        <EOL>        let ssrIds = <NUM_LIT>;<EOL>        const pltRender = plt.render;<EOL>        plt.render = function render(oldVNode: VNode, newVNode, isUpdate, defaultSlots, namedSlotsMap, encapsulation) {<EOL>            let ssrId: number;<EOL>            let existingSsrId: string;<EOL>            if (opts.ssrIds !== false) {<EOL>                <EOL>                <EOL>                if (oldVNode && oldVNode.elm) {<EOL>                    existingSsrId = (oldVNode.elm as HTMLElement).getAttribute(SSR_VNODE_ID);<EOL>                }<EOL>                if (existingSsrId) {<EOL>                    ssrId = parseInt(existingSsrId, <NUM_LIT>);<EOL>                }<EOL>                else {<EOL>","gt":"ssrId = ssrIds++;"}
{"input":"<s> export function hydrateHtml(config: Config, ctx: CompilerCtx, cmpRegistry: ComponentRegistry, opts: HydrateOptions): Promise<HydrateResults> {<EOL>    return new Promise(resolve => {<EOL>        <EOL>        opts = normalizeHydrateOptions(opts);<EOL>        <EOL>        const hydrateResults = generateHydrateResults(config, opts);<EOL>        <EOL>        <EOL>        const dom = config.sys.createDom();<EOL>        const win = dom.parse(opts);<EOL>        const doc = win.document;<EOL>        <EOL>        <EOL>        normalizeDirection(doc, opts);<EOL>        normalizeLanguage(doc, opts);<EOL>        <EOL>        const plt = createPlatformServer(config, win, doc, cmpRegistry, hydrateResults, opts.isPrerender, ctx);<EOL>        <EOL>        <EOL>        plt.onAppLoad = async (rootElm, styles, failureDiagnostic) => {<EOL>            if (config._isTesting) {<EOL>                (hydrateResults as any).__testPlatform = plt;<EOL>            }<EOL>            if (failureDiagnostic) {<EOL>                hydrateResults.html = generateFailureDiagnostic(failureDiagnostic);<EOL>                dom.destroy();<EOL>                resolve(hydrateResults);<EOL>                return;<EOL>            }<EOL>            <EOL>            if (rootElm) {<EOL>                try {<EOL>                    <EOL>                    await optimizeHtml(config, ctx, doc, styles, opts, hydrateResults);<EOL>                    <EOL>                    if (opts.collectAnchors !== false && opts.hydrateComponents !== false) {<EOL>                        collectAnchors(config, doc, hydrateResults);<EOL>                    }<EOL>                    <EOL>                    if (opts.serializeHtml !== false) {<EOL>                        hydrateResults.html = dom.serialize();<EOL>                    }<EOL>                }<EOL>                catch (e) {<EOL>                    <EOL>                    hydrateResults.diagnostics.push({<EOL>                        level: '<STR_LIT>',<EOL>                        type: '<STR_LIT>',<EOL>                        header: '<STR_LIT>',<EOL>                        messageText: e<EOL>                    });<EOL>                    <EOL>                    hydrateResults.html = opts.html;<EOL>                }<EOL>            }<EOL>            if (opts.destroyDom !== false) {<EOL>                <EOL>                dom.destroy();<EOL>            }<EOL>            else {<EOL>                <EOL>                <EOL>                hydrateResults.root = rootElm;<EOL>            }<EOL>            <EOL>            <EOL>            resolve(hydrateResults);<EOL>        };<EOL>        if (opts.hydrateComponents === false) {<EOL>            plt.onAppLoad(win.document.body as any, []);<EOL>            return;<EOL>        }<EOL>        <EOL>        <EOL>        let ssrIds = <NUM_LIT>;<EOL>        const pltRender = plt.render;<EOL>        plt.render = function render(oldVNode: VNode, newVNode, isUpdate, defaultSlots, namedSlotsMap, encapsulation) {<EOL>            let ssrId: number;<EOL>            let existingSsrId: string;<EOL>            if (opts.ssrIds !== false) {<EOL>                <EOL>                <EOL>                if (oldVNode && oldVNode.elm) {<EOL>                    existingSsrId = (oldVNode.elm as HTMLElement).getAttribute(SSR_VNODE_ID);<EOL>                }<EOL>                if (existingSsrId) {<EOL>                    ssrId = parseInt(existingSsrId, <NUM_LIT>);<EOL>                }<EOL>                else {<EOL>                    ssrId = ssrIds++;<EOL>                }<EOL>            }<EOL>","gt":"newVNode = pltRender(oldVNode, newVNode, isUpdate, defaultSlots, namedSlotsMap, encapsulation, ssrId);"}
{"input":"<s> export function hydrateHtml(config: Config, ctx: CompilerCtx, cmpRegistry: ComponentRegistry, opts: HydrateOptions): Promise<HydrateResults> {<EOL>    return new Promise(resolve => {<EOL>        <EOL>        opts = normalizeHydrateOptions(opts);<EOL>        <EOL>        const hydrateResults = generateHydrateResults(config, opts);<EOL>        <EOL>        <EOL>        const dom = config.sys.createDom();<EOL>        const win = dom.parse(opts);<EOL>        const doc = win.document;<EOL>        <EOL>        <EOL>        normalizeDirection(doc, opts);<EOL>        normalizeLanguage(doc, opts);<EOL>        <EOL>        const plt = createPlatformServer(config, win, doc, cmpRegistry, hydrateResults, opts.isPrerender, ctx);<EOL>        <EOL>        <EOL>        plt.onAppLoad = async (rootElm, styles, failureDiagnostic) => {<EOL>            if (config._isTesting) {<EOL>                (hydrateResults as any).__testPlatform = plt;<EOL>            }<EOL>            if (failureDiagnostic) {<EOL>                hydrateResults.html = generateFailureDiagnostic(failureDiagnostic);<EOL>                dom.destroy();<EOL>                resolve(hydrateResults);<EOL>                return;<EOL>            }<EOL>            <EOL>            if (rootElm) {<EOL>                try {<EOL>                    <EOL>                    await optimizeHtml(config, ctx, doc, styles, opts, hydrateResults);<EOL>                    <EOL>                    if (opts.collectAnchors !== false && opts.hydrateComponents !== false) {<EOL>                        collectAnchors(config, doc, hydrateResults);<EOL>                    }<EOL>                    <EOL>                    if (opts.serializeHtml !== false) {<EOL>                        hydrateResults.html = dom.serialize();<EOL>                    }<EOL>                }<EOL>                catch (e) {<EOL>                    <EOL>                    hydrateResults.diagnostics.push({<EOL>                        level: '<STR_LIT>',<EOL>                        type: '<STR_LIT>',<EOL>                        header: '<STR_LIT>',<EOL>                        messageText: e<EOL>                    });<EOL>                    <EOL>                    hydrateResults.html = opts.html;<EOL>                }<EOL>            }<EOL>            if (opts.destroyDom !== false) {<EOL>                <EOL>                dom.destroy();<EOL>            }<EOL>            else {<EOL>                <EOL>                <EOL>                hydrateResults.root = rootElm;<EOL>            }<EOL>            <EOL>            <EOL>            resolve(hydrateResults);<EOL>        };<EOL>        if (opts.hydrateComponents === false) {<EOL>            plt.onAppLoad(win.document.body as any, []);<EOL>            return;<EOL>        }<EOL>        <EOL>        <EOL>        let ssrIds = <NUM_LIT>;<EOL>        const pltRender = plt.render;<EOL>        plt.render = function render(oldVNode: VNode, newVNode, isUpdate, defaultSlots, namedSlotsMap, encapsulation) {<EOL>            let ssrId: number;<EOL>            let existingSsrId: string;<EOL>            if (opts.ssrIds !== false) {<EOL>                <EOL>                <EOL>                if (oldVNode && oldVNode.elm) {<EOL>                    existingSsrId = (oldVNode.elm as HTMLElement).getAttribute(SSR_VNODE_ID);<EOL>                }<EOL>                if (existingSsrId) {<EOL>                    ssrId = parseInt(existingSsrId, <NUM_LIT>);<EOL>                }<EOL>                else {<EOL>                    ssrId = ssrIds++;<EOL>                }<EOL>            }<EOL>            newVNode = pltRender(oldVNode, newVNode, isUpdate, defaultSlots, namedSlotsMap, encapsulation, ssrId);<EOL>            connectChildElements(config,","gt":"plt, hydrateResults, newVNode.elm as Element);"}
{"input":"<s> export function hydrateHtml(config: Config, ctx: CompilerCtx, cmpRegistry: ComponentRegistry, opts: HydrateOptions): Promise<HydrateResults> {<EOL>    return new Promise(resolve => {<EOL>        <EOL>        opts = normalizeHydrateOptions(opts);<EOL>        <EOL>        const hydrateResults = generateHydrateResults(config, opts);<EOL>        <EOL>        <EOL>        const dom = config.sys.createDom();<EOL>        const win = dom.parse(opts);<EOL>        const doc = win.document;<EOL>        <EOL>        <EOL>        normalizeDirection(doc, opts);<EOL>        normalizeLanguage(doc, opts);<EOL>        <EOL>        const plt = createPlatformServer(config, win, doc, cmpRegistry, hydrateResults, opts.isPrerender, ctx);<EOL>        <EOL>        <EOL>        plt.onAppLoad = async (rootElm, styles, failureDiagnostic) => {<EOL>            if (config._isTesting) {<EOL>                (hydrateResults as any).__testPlatform = plt;<EOL>            }<EOL>            if (failureDiagnostic) {<EOL>                hydrateResults.html = generateFailureDiagnostic(failureDiagnostic);<EOL>                dom.destroy();<EOL>                resolve(hydrateResults);<EOL>                return;<EOL>            }<EOL>            <EOL>            if (rootElm) {<EOL>                try {<EOL>                    <EOL>                    await optimizeHtml(config, ctx, doc, styles, opts, hydrateResults);<EOL>                    <EOL>                    if (opts.collectAnchors !== false && opts.hydrateComponents !== false) {<EOL>                        collectAnchors(config, doc, hydrateResults);<EOL>                    }<EOL>                    <EOL>                    if (opts.serializeHtml !== false) {<EOL>                        hydrateResults.html = dom.serialize();<EOL>                    }<EOL>                }<EOL>                catch (e) {<EOL>                    <EOL>                    hydrateResults.diagnostics.push({<EOL>                        level: '<STR_LIT>',<EOL>                        type: '<STR_LIT>',<EOL>                        header: '<STR_LIT>',<EOL>                        messageText: e<EOL>                    });<EOL>                    <EOL>                    hydrateResults.html = opts.html;<EOL>                }<EOL>            }<EOL>            if (opts.destroyDom !== false) {<EOL>                <EOL>                dom.destroy();<EOL>            }<EOL>            else {<EOL>                <EOL>                <EOL>                hydrateResults.root = rootElm;<EOL>            }<EOL>            <EOL>            <EOL>            resolve(hydrateResults);<EOL>        };<EOL>        if (opts.hydrateComponents === false) {<EOL>            plt.onAppLoad(win.document.body as any, []);<EOL>            return;<EOL>        }<EOL>        <EOL>        <EOL>        let ssrIds = <NUM_LIT>;<EOL>        const pltRender = plt.render;<EOL>        plt.render = function render(oldVNode: VNode, newVNode, isUpdate, defaultSlots, namedSlotsMap, encapsulation) {<EOL>            let ssrId: number;<EOL>            let existingSsrId: string;<EOL>            if (opts.ssrIds !== false) {<EOL>                <EOL>                <EOL>                if (oldVNode && oldVNode.elm) {<EOL>                    existingSsrId = (oldVNode.elm as HTMLElement).getAttribute(SSR_VNODE_ID);<EOL>                }<EOL>                if (existingSsrId) {<EOL>                    ssrId = parseInt(existingSsrId, <NUM_LIT>);<EOL>                }<EOL>                else {<EOL>                    ssrId = ssrIds++;<EOL>                }<EOL>            }<EOL>            newVNode = pltRender(oldVNode, newVNode, isUpdate, defaultSlots, namedSlotsMap, encapsulation, ssrId);<EOL>            connectChildElements(config, plt, hydrateResults, newVNode.elm as Element);<EOL>            return","gt":"newVNode;"}
{"input":"<s> export default function run() {<EOL>    ICollectionTests.StringCollection('<STR_LIT>', new","gt":"Queue<string>());"}
{"input":"<s> function newFunction<U1a, T1a, U2a, T2a, U3a>(t1a: T1a, t2a: T2a, u1a: U1a, u2a: U2a, u3a: U3a) {<EOL>    t1a.toString();<EOL>","gt":"t2a.toString();"}
{"input":"<s> export function disposed(what: string): Error {<EOL>    const result = new Error(","gt":"what} has been disposed`<STR_LIT>;"}
{"input":"<s> async function fetchRemoteVideoDescription(video: VideoModel) {<EOL>    const host = video.VideoChannel.Account.Actor.Server.host;<EOL>    const path = video.getDescriptionPath();<EOL>","gt":"const options = {"}
{"input":"<s> /**<EOL> * Parse the response body.<EOL> */<EOL>export function parse(type: ParseType | ParseType[], strict?: boolean) {<EOL>    const types = Array.isArray(type) ? type : [type];<EOL>    for (const type of types) {<EOL>        if (type !== '<STR_LIT>' && type !== '<STR_LIT>') {<EOL>            throw new","gt":"TypeError(`<STR_LIT>`);"}
{"input":"<s> /**<EOL> * Parse the response body.<EOL> */<EOL>export function parse(type: ParseType | ParseType[], strict?: boolean) {<EOL>    const types = Array.isArray(type) ? type : [type];<EOL>    for (const type of types) {<EOL>        if (type !== '<STR_LIT>' && type !== '<STR_LIT>') {<EOL>            throw new TypeError(`<STR_LIT>`);<EOL>        }<EOL>    }<EOL>    return function (request: Request, next: () => Promise<Response>) {<EOL>        return next()<EOL>            .then(","gt":"function (response) {"}
{"input":"<s> /**<EOL> * Parse the response body.<EOL> */<EOL>export function parse(type: ParseType | ParseType[], strict?: boolean) {<EOL>    const types = Array.isArray(type) ? type : [type];<EOL>    for (const type of types) {<EOL>        if (type !== '<STR_LIT>' && type !== '<STR_LIT>') {<EOL>            throw new TypeError(`<STR_LIT>`);<EOL>        }<EOL>    }<EOL>    return function (request: Request, next: () => Promise<Response>) {<EOL>        return next()<EOL>            .then(function (response) {<EOL>            const { body } = response;<EOL>            const responseType = response.type();<EOL>            <EOL>            if (body == null || body === '<STR_LIT>') {<EOL>                response.body =","gt":"null;"}
{"input":"<s> /**<EOL> * Parse the response body.<EOL> */<EOL>export function parse(type: ParseType | ParseType[], strict?: boolean) {<EOL>    const types = Array.isArray(type) ? type : [type];<EOL>    for (const type of types) {<EOL>        if (type !== '<STR_LIT>' && type !== '<STR_LIT>') {<EOL>            throw new TypeError(`<STR_LIT>`);<EOL>        }<EOL>    }<EOL>    return function (request: Request, next: () => Promise<Response>) {<EOL>        return next()<EOL>            .then(function (response) {<EOL>            const { body } = response;<EOL>            const responseType = response.type();<EOL>            <EOL>            if (body == null || body === '<STR_LIT>') {<EOL>                response.body = null;<EOL>","gt":"return response;"}
{"input":"<s> /**<EOL> * Parse the response body.<EOL> */<EOL>export function parse(type: ParseType | ParseType[], strict?: boolean) {<EOL>    const types = Array.isArray(type) ? type : [type];<EOL>    for (const type of types) {<EOL>        if (type !== '<STR_LIT>' && type !== '<STR_LIT>') {<EOL>            throw new TypeError(`<STR_LIT>`);<EOL>        }<EOL>    }<EOL>    return function (request: Request, next: () => Promise<Response>) {<EOL>        return next()<EOL>            .then(function (response) {<EOL>            const { body } = response;<EOL>            const responseType = response.type();<EOL>            <EOL>            if (body == null || body === '<STR_LIT>') {<EOL>                response.body = null;<EOL>                return response;<EOL>            }<EOL>            <EOL>            if (responseType == null) {<EOL>                throw","gt":"request.error(`<STR_LIT>`, '<STR_LIT>');"}
{"input":"<s> /**<EOL> * Parse the response body.<EOL> */<EOL>export function parse(type: ParseType | ParseType[], strict?: boolean) {<EOL>    const types = Array.isArray(type) ? type : [type];<EOL>    for (const type of types) {<EOL>        if (type !== '<STR_LIT>' && type !== '<STR_LIT>') {<EOL>            throw new TypeError(`<STR_LIT>`);<EOL>        }<EOL>    }<EOL>    return function (request: Request, next: () => Promise<Response>) {<EOL>        return next()<EOL>            .then(function (response) {<EOL>            const { body } = response;<EOL>            const responseType = response.type();<EOL>            <EOL>            if (body == null || body === '<STR_LIT>') {<EOL>                response.body = null;<EOL>                return response;<EOL>            }<EOL>            <EOL>            if (responseType == null) {<EOL>                throw request.error(`<STR_LIT>`, '<STR_LIT>');<EOL>            }<EOL>            <EOL>            if (typeof body !== '<STR_LIT>') {<EOL>                throw request.error(`<STR_LIT>`, '<STR_LIT>');<EOL>            }<EOL>            <EOL>            for (const type of types) {<EOL>                if (type === '<STR_LIT>' && JSON_MIME_REGEXP.test(responseType)) {<EOL>                    try {<EOL>                        response.body = JSON.parse(body.replace(JSON_PROTECTION_PREFIX, '<STR_LIT>'));<EOL>                    }<EOL>                    catch (err) {<EOL>                        throw request.error(`<STR_LIT>`, '<STR_LIT>', err);<EOL>                    }<EOL>                    return","gt":"response;"}
{"input":"<s> function createStringSequence(a: string): ISequence {<EOL>    return {<EOL>        getLength() { return","gt":"a.length; },"}
{"input":"<s> export function isJSX(filename: string) {<EOL>    return jsxRegex.","gt":"test(filename);"}
{"input":"<s> function newFunction(a: number) {<EOL>    let x =","gt":"<NUM_LIT>;"}
{"input":"<s> export async function fsReadJsonFile(filePath: string, options: FSReadFileOptions = { encoding: '<STR_LIT>' }): Promise<{<EOL>    [key: string]: any;<EOL>}> {<EOL>    try {<EOL>        const f = await fsReadFile(filePath, options);<EOL>        return JSON.parse(f);<EOL>    }<EOL>    catch (e) {<EOL>        if (e.code === '<STR_LIT>') {<EOL>            throw ERROR_FILE_NOT_FOUND;<EOL>        }<EOL>        else if (e instanceof SyntaxError) {<EOL>            throw","gt":"ERROR_FILE_INVALID_JSON;"}
{"input":"<s> export function metaFactory(): MetaLoader {<EOL>    return new MetaStaticLoader({<EOL>        pageTitlePositioning: PageTitlePositioning.PrependPageTitle,<EOL>        pageTitleSeparator: '<STR_LIT>',<EOL>","gt":"applicationName: '<STR_LIT>',"}
{"input":"<s> export function metaFactory(): MetaLoader {<EOL>    return new MetaStaticLoader({<EOL>        pageTitlePositioning: PageTitlePositioning.PrependPageTitle,<EOL>        pageTitleSeparator: '<STR_LIT>',<EOL>        applicationName: '<STR_LIT>',<EOL>        defaults: {<EOL>            title: '<STR_LIT>',<EOL>            description: '<STR_LIT>' +<EOL>","gt":"'<STR_LIT>'"}
{"input":"<s> function getAsyncData() {<EOL>    <EOL>    return new Promise(resolve => {<EOL>        setTimeout(() => {<EOL>            let data:","gt":"string[] = [];"}
{"input":"<s> function getAsyncData() {<EOL>    <EOL>    return new Promise(resolve => {<EOL>        setTimeout(() => {<EOL>            let data: string[] = [];<EOL>            for (var i = <NUM_LIT>; i < <NUM_LIT>; i++) {<EOL>                data.push(getRandomData());<EOL>            }<EOL>            resolve(","gt":"data);"}
{"input":"<s> function F0() {<EOL>    function F1() {<EOL>        function F2(","gt":"x =  newLocal) {"}
{"input":"<s> /**<EOL> * decorator of an event-emitter function<EOL> * @param  event The name of the event<EOL> * @return MethodDecorator<EOL> */<EOL>export function Emit(event?: string): MethodDecorator {<EOL>    return function (target: Vue, key: string, descriptor: any) {<EOL>        key = hyphenate(key);<EOL>","gt":"const original = descriptor.value;"}
{"input":"<s> function removeOldSamples(property: any, maxNumSamples: number) {<EOL>    if (maxNumSamples === undefined)<EOL>        return;<EOL>    var removeCount = property.","gt":"_times.length - maxNumSamples;"}
{"input":"<s> /**<EOL> * Removes an element from the dictionary. Returns {{false}} if the property<EOL> * does not exists.<EOL> */<EOL>export function remove<T>(from: IStringDictionary<T> | INumberDictionary<T>, key: string): boolean {<EOL>    if (!hasOwnProperty.call(from, key)) {<EOL>","gt":"return false;"}
{"input":"<s> function check(file: string, args: string | string[], expected: string): void {<EOL>    assert.equal(argsToCommandLine(file,","gt":"args), expected);"}
{"input":"<s> export async function formatCommandDoc(env: IonicEnvironment, cmd: HydratedCommandMetadata) {<EOL>    const description = stripAnsi(cmd.description).split('<STR_LIT>').join('<STR_LIT>');<EOL>    const fullName = await generateFullName(cmd);<EOL>    return formatCommandHeader(","gt":"cmd, fullName) +"}
{"input":"<s> function updateCustomConfig(url: string, token: string, newCustomConfig: CustomConfig, statusCodeExpected = <NUM_LIT>) {<EOL>    const path = '<STR_LIT>';<EOL>    return makePutBodyRequest({<EOL>","gt":"url,"}
{"input":"<s> function f2<T extends Item | undefined>(obj: T | undefined) {<EOL>    if (obj) {<EOL>","gt":"obj.x;"}
{"input":"<s> async function sendLikeToOrigin(byActor: ActorModel, video: VideoModel, t: Transaction) {<EOL>    const url = getVideoLikeActivityPubUrl(byActor, video);<EOL>    const accountsInvolvedInVideo = await","gt":"getActorsInvolvedInVideo(video, t);"}
{"input":"<s> function hasDataCondition(config: any) {<EOL>    let hasData = false;<EOL>    if (!_.isEmpty(config.data)) {<EOL>        hasData = true;<EOL>    }<EOL>    if (!_.isNil(config.views)) {<EOL>        if (_.isPlainObject(config.views) && !_.","gt":"isEmpty(config.views.data)) {"}
{"input":"<s> function hasDataCondition(config: any) {<EOL>    let hasData = false;<EOL>    if (!_.isEmpty(config.data)) {<EOL>        hasData = true;<EOL>    }<EOL>    if (!_.isNil(config.views)) {<EOL>        if (_.isPlainObject(config.views) && !_.isEmpty(config.views.data)) {<EOL>            hasData = true;<EOL>        }<EOL>        if (_.isArray(config.views)) {<EOL>            for (let item","gt":"of config.views) {"}
{"input":"<s> export function initialize(config: any, securityConfig: any, appRoot?: string, entityServiceInst?: IEntityService, sqlServerInst?: IEntityService, server?: any) {<EOL>    <EOL>    <EOL>    <EOL>    <EOL>    _appRoot = appRoot || process.env.APP_ROOT || process.cwd();<EOL>    <EOL>    new Dynamic(config, securityConfig, server);<EOL>    <EOL>    components.","gt":"forEach(x => {"}
{"input":"<s> /** Socket factory */<EOL>export function SocketFactory(config: SocketIoConfig) {<EOL>    return new","gt":"WrappedSocket(config);"}
{"input":"<s> <EOL>function foo0(x) {<EOL>    for (let x of []) {<EOL>        var v = x;<EOL>        (","gt":"function () { return x + v; });"}
{"input":"<s> export async function readVersionOfDependencies(context: BuildContext) {<EOL>    <EOL>    const promises: Promise<any>[] = [];<EOL>    promises.push(readPackageVersion(context.angularCoreDir));<EOL>    if (!getBooleanPropertyValue(Constants.ENV_SKIP_IONIC_ANGULAR_VERSION)) {<EOL>        promises.push(","gt":"readPackageVersion(context.ionicAngularDir));"}
{"input":"<s> export async function readVersionOfDependencies(context: BuildContext) {<EOL>    <EOL>    const promises: Promise<any>[] = [];<EOL>    promises.push(readPackageVersion(context.angularCoreDir));<EOL>    if (!getBooleanPropertyValue(Constants.ENV_SKIP_IONIC_ANGULAR_VERSION)) {<EOL>        promises.push(readPackageVersion(context.ionicAngularDir));<EOL>    }<EOL>    promises.push(readPackageVersion(context.typescriptDir));<EOL>    const versions = await Promise.all(promises);<EOL>    context.angularVersion = semverStringToObject(versions[<NUM_LIT>]);<EOL>    if (!getBooleanPropertyValue(Constants.ENV_SKIP_IONIC_ANGULAR_VERSION)) {<EOL>        context.ionicAngularVersion =","gt":"semverStringToObject(versions[<NUM_LIT>]);"}
{"input":"<s> function immutableAssign<T, U>(target: T, source: U) {<EOL>    return","gt":"Object.assign<{}, T, U>({}, target, source);"}
{"input":"<s> function from<T>(arg: any): Query<T> {<EOL>    return","gt":"undefined;"}
{"input":"<s> export function isRelationDecorator(decorator: string) {<EOL>    return decorator === Decorators.ONETOMANY || decorator === Decorators.MANYTOONE ||","gt":"decorator === Decorators.MANYTOMANY || decorator === Decorators.ONETOONE;"}
{"input":"<s> async function doStatement9() {<EOL>    C: do {<EOL>        if (","gt":"<NUM_LIT>)"}
{"input":"<s> function dummy() {<EOL>    test(arrayResults,","gt":"nullSort);"}
{"input":"<s> export function getEmbeddedPropWithFlat(model: any) {<EOL>","gt":"let allReferencingEntities = CoreUtils.getAllRelationsForTargetInternal(getEntity(model.modelName));"}
{"input":"<s> export function GetSquare(val: number): number {<EOL>","gt":"return (val * val);"}
{"input":"<s> async function uploadVideoOnPeerTube(videoInfo: any, videoPath: string, language?: number) {<EOL>    const category = await getCategory(videoInfo.categories);<EOL>    const licence =","gt":"getLicence(videoInfo.license);"}
{"input":"<s> async function uploadVideoOnPeerTube(videoInfo: any, videoPath: string, language?: number) {<EOL>    const category = await getCategory(videoInfo.categories);<EOL>    const licence = getLicence(videoInfo.license);<EOL>    let tags = [];<EOL>    if (Array.isArray(videoInfo.tags)) {<EOL>        tags =","gt":"videoInfo.tags"}
{"input":"<s> async function uploadVideoOnPeerTube(videoInfo: any, videoPath: string, language?: number) {<EOL>    const category = await getCategory(videoInfo.categories);<EOL>    const licence = getLicence(videoInfo.license);<EOL>    let tags = [];<EOL>    if (Array.isArray(videoInfo.tags)) {<EOL>        tags = videoInfo.tags<EOL>            .filter(t => t.length < CONSTRAINTS_FIELDS.VIDEOS.TAG.max && t.length > CONSTRAINTS_FIELDS.VIDEOS.TAG.min)<EOL>            .map(t => t.","gt":"normalize())"}
{"input":"<s> async function uploadVideoOnPeerTube(videoInfo: any, videoPath: string, language?: number) {<EOL>    const category = await getCategory(videoInfo.categories);<EOL>    const licence = getLicence(videoInfo.license);<EOL>    let tags = [];<EOL>    if (Array.isArray(videoInfo.tags)) {<EOL>        tags = videoInfo.tags<EOL>            .filter(t => t.length < CONSTRAINTS_FIELDS.VIDEOS.TAG.max && t.length > CONSTRAINTS_FIELDS.VIDEOS.TAG.min)<EOL>            .map(t => t.normalize())<EOL>            .slice(<NUM_LIT>, <NUM_LIT>);<EOL>    }<EOL>","gt":"let thumbnailfile;"}
{"input":"<s> async function uploadVideoOnPeerTube(videoInfo: any, videoPath: string, language?: number) {<EOL>    const category = await getCategory(videoInfo.categories);<EOL>    const licence = getLicence(videoInfo.license);<EOL>    let tags = [];<EOL>    if (Array.isArray(videoInfo.tags)) {<EOL>        tags = videoInfo.tags<EOL>            .filter(t => t.length < CONSTRAINTS_FIELDS.VIDEOS.TAG.max && t.length > CONSTRAINTS_FIELDS.VIDEOS.TAG.min)<EOL>            .map(t => t.normalize())<EOL>            .slice(<NUM_LIT>, <NUM_LIT>);<EOL>    }<EOL>    let thumbnailfile;<EOL>    if (videoInfo.thumbnail) {<EOL>        thumbnailfile = join(__dirname, '<STR_LIT>');<EOL>        await doRequestAndSaveToFile({<EOL>            method: '<STR_LIT>',<EOL>            uri: videoInfo.","gt":"thumbnail"}
{"input":"<s> async function uploadVideoOnPeerTube(videoInfo: any, videoPath: string, language?: number) {<EOL>    const category = await getCategory(videoInfo.categories);<EOL>    const licence = getLicence(videoInfo.license);<EOL>    let tags = [];<EOL>    if (Array.isArray(videoInfo.tags)) {<EOL>        tags = videoInfo.tags<EOL>            .filter(t => t.length < CONSTRAINTS_FIELDS.VIDEOS.TAG.max && t.length > CONSTRAINTS_FIELDS.VIDEOS.TAG.min)<EOL>            .map(t => t.normalize())<EOL>            .slice(<NUM_LIT>, <NUM_LIT>);<EOL>    }<EOL>    let thumbnailfile;<EOL>    if (videoInfo.thumbnail) {<EOL>        thumbnailfile = join(__dirname, '<STR_LIT>');<EOL>        await doRequestAndSaveToFile({<EOL>            method: '<STR_LIT>',<EOL>            uri: videoInfo.thumbnail<EOL>        }, thumbnailfile);<EOL>    }<EOL>    const videoAttributes = {<EOL>        name: videoInfo.title,<EOL>","gt":"category,"}
{"input":"<s> async function uploadVideoOnPeerTube(videoInfo: any, videoPath: string, language?: number) {<EOL>    const category = await getCategory(videoInfo.categories);<EOL>    const licence = getLicence(videoInfo.license);<EOL>    let tags = [];<EOL>    if (Array.isArray(videoInfo.tags)) {<EOL>        tags = videoInfo.tags<EOL>            .filter(t => t.length < CONSTRAINTS_FIELDS.VIDEOS.TAG.max && t.length > CONSTRAINTS_FIELDS.VIDEOS.TAG.min)<EOL>            .map(t => t.normalize())<EOL>            .slice(<NUM_LIT>, <NUM_LIT>);<EOL>    }<EOL>    let thumbnailfile;<EOL>    if (videoInfo.thumbnail) {<EOL>        thumbnailfile = join(__dirname, '<STR_LIT>');<EOL>        await doRequestAndSaveToFile({<EOL>            method: '<STR_LIT>',<EOL>            uri: videoInfo.thumbnail<EOL>        }, thumbnailfile);<EOL>    }<EOL>    const videoAttributes = {<EOL>        name: videoInfo.title,<EOL>        category,<EOL>        licence,<EOL>        language,<EOL>        nsfw: isNSFW(videoInfo),<EOL>        commentsEnabled: true,<EOL>        description: videoInfo.description,<EOL>        tags,<EOL>        privacy:","gt":"VideoPrivacy.PUBLIC,"}
{"input":"<s> async function uploadVideoOnPeerTube(videoInfo: any, videoPath: string, language?: number) {<EOL>    const category = await getCategory(videoInfo.categories);<EOL>    const licence = getLicence(videoInfo.license);<EOL>    let tags = [];<EOL>    if (Array.isArray(videoInfo.tags)) {<EOL>        tags = videoInfo.tags<EOL>            .filter(t => t.length < CONSTRAINTS_FIELDS.VIDEOS.TAG.max && t.length > CONSTRAINTS_FIELDS.VIDEOS.TAG.min)<EOL>            .map(t => t.normalize())<EOL>            .slice(<NUM_LIT>, <NUM_LIT>);<EOL>    }<EOL>    let thumbnailfile;<EOL>    if (videoInfo.thumbnail) {<EOL>        thumbnailfile = join(__dirname, '<STR_LIT>');<EOL>        await doRequestAndSaveToFile({<EOL>            method: '<STR_LIT>',<EOL>            uri: videoInfo.thumbnail<EOL>        }, thumbnailfile);<EOL>    }<EOL>    const videoAttributes = {<EOL>        name: videoInfo.title,<EOL>        category,<EOL>        licence,<EOL>        language,<EOL>        nsfw: isNSFW(videoInfo),<EOL>        commentsEnabled: true,<EOL>        description: videoInfo.description,<EOL>        tags,<EOL>        privacy: VideoPrivacy.PUBLIC,<EOL>        fixture: videoPath,<EOL>        thumbnailfile,<EOL>        previewfile: thumbnailfile<EOL>    };<EOL>    console.log('<STR_LIT>', videoAttributes.name);<EOL>    try {<EOL>        await uploadVideo(program['<STR_LIT>'], accessToken, videoAttributes);<EOL>    }<EOL>    catch (err) {<EOL>        if (err.message.indexOf('<STR_LIT>') !== -<NUM_LIT>) {<EOL>            console.log('<STR_LIT>');<EOL>            const res = await login(","gt":"program['<STR_LIT>'], client, user);"}
{"input":"<s> async function uploadVideoOnPeerTube(videoInfo: any, videoPath: string, language?: number) {<EOL>    const category = await getCategory(videoInfo.categories);<EOL>    const licence = getLicence(videoInfo.license);<EOL>    let tags = [];<EOL>    if (Array.isArray(videoInfo.tags)) {<EOL>        tags = videoInfo.tags<EOL>            .filter(t => t.length < CONSTRAINTS_FIELDS.VIDEOS.TAG.max && t.length > CONSTRAINTS_FIELDS.VIDEOS.TAG.min)<EOL>            .map(t => t.normalize())<EOL>            .slice(<NUM_LIT>, <NUM_LIT>);<EOL>    }<EOL>    let thumbnailfile;<EOL>    if (videoInfo.thumbnail) {<EOL>        thumbnailfile = join(__dirname, '<STR_LIT>');<EOL>        await doRequestAndSaveToFile({<EOL>            method: '<STR_LIT>',<EOL>            uri: videoInfo.thumbnail<EOL>        }, thumbnailfile);<EOL>    }<EOL>    const videoAttributes = {<EOL>        name: videoInfo.title,<EOL>        category,<EOL>        licence,<EOL>        language,<EOL>        nsfw: isNSFW(videoInfo),<EOL>        commentsEnabled: true,<EOL>        description: videoInfo.description,<EOL>        tags,<EOL>        privacy: VideoPrivacy.PUBLIC,<EOL>        fixture: videoPath,<EOL>        thumbnailfile,<EOL>        previewfile: thumbnailfile<EOL>    };<EOL>    console.log('<STR_LIT>', videoAttributes.name);<EOL>    try {<EOL>        await uploadVideo(program['<STR_LIT>'], accessToken, videoAttributes);<EOL>    }<EOL>    catch (err) {<EOL>        if (err.message.indexOf('<STR_LIT>') !== -<NUM_LIT>) {<EOL>            console.log('<STR_LIT>');<EOL>            const res = await login(program['<STR_LIT>'], client, user);<EOL>            accessToken = res.body.access_token;<EOL>            await uploadVideo(program['<STR_LIT>'], accessToken, videoAttributes);<EOL>        }<EOL>","gt":"else {"}
{"input":"<s> function wait(milliseconds: number) {<EOL>    return new Promise(resolve => setTimeout(resolve,","gt":"milliseconds));"}
{"input":"<s> export function computeGroupBounds(g: ProjectionGroup): Rectangle {<EOL>    g.bounds = typeof g.leaves !== \"<STR_LIT>\" ?<EOL>        g.leaves.reduce((r: Rectangle, c) => c.bounds.union(r), Rectangle.empty()) :<EOL>","gt":"Rectangle.empty();"}
{"input":"<s> function comparer() {<EOL>","gt":"test(comparerResults, comparerSort);"}
{"input":"<s> export function getFunctionArgs(func) {<EOL>    return (func + '<STR_LIT>')<EOL>        .replace(/[/][/].*$/mg, '<STR_LIT>') <EOL>        .","gt":"replace(/\\s+/g, '<STR_LIT>')"}
{"input":"<s> export function CodeTemplate(tempString: string, nodeKind?: number | number[]): ClassDecorator {<EOL>    return function (target: Function) {<EOL>        let newConstructor = function (scope: IScope, ...rest: any[]) {<EOL>            let self = this;<EOL>            let retValue = target.apply(self,","gt":"arguments);"}
{"input":"<s> export function CodeTemplate(tempString: string, nodeKind?: number | number[]): ClassDecorator {<EOL>    return function (target: Function) {<EOL>        let newConstructor = function (scope: IScope, ...rest: any[]) {<EOL>            let self = this;<EOL>            let retValue = target.apply(self, arguments);<EOL>            let [code, statements] = processTemplate(tempString, self);<EOL>            if (statements)<EOL>                scope.","gt":"statements.push(statements);"}
{"input":"<s> /** Returns: [code, statements] */<EOL>function processTemplate(template: string, args: any): [<EOL>    string,<EOL>    string<EOL>] {<EOL>    let statements = \"<STR_LIT>\";<EOL>    if (template.indexOf(\"<STR_LIT>\") > -<NUM_LIT>) {<EOL>        let statementsStartPos = template.indexOf(\"<STR_LIT>\");<EOL>        let","gt":"statementsBodyStartPos = statementsStartPos + \"<STR_LIT>\".length;"}
{"input":"<s> /** Returns: [code, statements] */<EOL>function processTemplate(template: string, args: any): [<EOL>    string,<EOL>    string<EOL>] {<EOL>    let statements = \"<STR_LIT>\";<EOL>    if (template.indexOf(\"<STR_LIT>\") > -<NUM_LIT>) {<EOL>        let statementsStartPos = template.indexOf(\"<STR_LIT>\");<EOL>        let statementsBodyStartPos = statementsStartPos + \"<STR_LIT>\".length;<EOL>        let statementsBodyEndPos = template.indexOf(\"<STR_LIT>\");<EOL>        let statementsEndPos = statementsBodyEndPos + \"<STR_LIT>\".length;<EOL>        while (statementsStartPos > <NUM_LIT> && (template[statementsStartPos - <NUM_LIT>] == '<STR_LIT>' || template[statementsStartPos - <NUM_LIT>] ==","gt":"'<STR_LIT>'))"}
{"input":"<s> /** Returns: [code, statements] */<EOL>function processTemplate(template: string, args: any): [<EOL>    string,<EOL>    string<EOL>] {<EOL>    let statements = \"<STR_LIT>\";<EOL>    if (template.indexOf(\"<STR_LIT>\") > -<NUM_LIT>) {<EOL>        let statementsStartPos = template.indexOf(\"<STR_LIT>\");<EOL>        let statementsBodyStartPos = statementsStartPos + \"<STR_LIT>\".length;<EOL>        let statementsBodyEndPos = template.indexOf(\"<STR_LIT>\");<EOL>        let statementsEndPos = statementsBodyEndPos + \"<STR_LIT>\".length;<EOL>        while (statementsStartPos > <NUM_LIT> && (template[statementsStartPos - <NUM_LIT>] == '<STR_LIT>' || template[statementsStartPos - <NUM_LIT>] == '<STR_LIT>'))<EOL>            statementsStartPos--;<EOL>        if (statementsBodyEndPos > <NUM_LIT> && template[statementsBodyEndPos - <NUM_LIT>] == '<STR_LIT>')<EOL>            statementsBodyEndPos--;<EOL>        let","gt":"templateText = template.slice(statementsBodyStartPos, statementsBodyEndPos).replace(/\\n    /g, '<STR_LIT>');"}
{"input":"<s> /** Returns: [code, statements] */<EOL>function processTemplate(template: string, args: any): [<EOL>    string,<EOL>    string<EOL>] {<EOL>    let statements = \"<STR_LIT>\";<EOL>    if (template.indexOf(\"<STR_LIT>\") > -<NUM_LIT>) {<EOL>        let statementsStartPos = template.indexOf(\"<STR_LIT>\");<EOL>        let statementsBodyStartPos = statementsStartPos + \"<STR_LIT>\".length;<EOL>        let statementsBodyEndPos = template.indexOf(\"<STR_LIT>\");<EOL>        let statementsEndPos = statementsBodyEndPos + \"<STR_LIT>\".length;<EOL>        while (statementsStartPos > <NUM_LIT> && (template[statementsStartPos - <NUM_LIT>] == '<STR_LIT>' || template[statementsStartPos - <NUM_LIT>] == '<STR_LIT>'))<EOL>            statementsStartPos--;<EOL>        if (statementsBodyEndPos > <NUM_LIT> && template[statementsBodyEndPos - <NUM_LIT>] == '<STR_LIT>')<EOL>            statementsBodyEndPos--;<EOL>        let templateText = template.slice(statementsBodyStartPos, statementsBodyEndPos).replace(/\\n    /g, '<STR_LIT>');<EOL>        let [c, s] = processTemplate(templateText, args);<EOL>        statements += s + c;<EOL>        template = template.slice(<NUM_LIT>, statementsStartPos) + template.slice(statementsEndPos);<EOL>    }<EOL>    if (","gt":"typeof args === \"<STR_LIT>\")"}
{"input":"<s> /** Returns: [code, statements] */<EOL>function processTemplate(template: string, args: any): [<EOL>    string,<EOL>    string<EOL>] {<EOL>    let statements = \"<STR_LIT>\";<EOL>    if (template.indexOf(\"<STR_LIT>\") > -<NUM_LIT>) {<EOL>        let statementsStartPos = template.indexOf(\"<STR_LIT>\");<EOL>        let statementsBodyStartPos = statementsStartPos + \"<STR_LIT>\".length;<EOL>        let statementsBodyEndPos = template.indexOf(\"<STR_LIT>\");<EOL>        let statementsEndPos = statementsBodyEndPos + \"<STR_LIT>\".length;<EOL>        while (statementsStartPos > <NUM_LIT> && (template[statementsStartPos - <NUM_LIT>] == '<STR_LIT>' || template[statementsStartPos - <NUM_LIT>] == '<STR_LIT>'))<EOL>            statementsStartPos--;<EOL>        if (statementsBodyEndPos > <NUM_LIT> && template[statementsBodyEndPos - <NUM_LIT>] == '<STR_LIT>')<EOL>            statementsBodyEndPos--;<EOL>        let templateText = template.slice(statementsBodyStartPos, statementsBodyEndPos).replace(/\\n    /g, '<STR_LIT>');<EOL>        let [c, s] = processTemplate(templateText, args);<EOL>        statements += s + c;<EOL>        template = template.slice(<NUM_LIT>, statementsStartPos) + template.slice(statementsEndPos);<EOL>    }<EOL>    if (typeof args === \"<STR_LIT>\")<EOL>","gt":"return [template.replace(/{this}/g, () => args), statements];"}
{"input":"<s> /** Returns: [code, statements] */<EOL>function processTemplate(template: string, args: any): [<EOL>    string,<EOL>    string<EOL>] {<EOL>    let statements = \"<STR_LIT>\";<EOL>    if (template.indexOf(\"<STR_LIT>\") > -<NUM_LIT>) {<EOL>        let statementsStartPos = template.indexOf(\"<STR_LIT>\");<EOL>        let statementsBodyStartPos = statementsStartPos + \"<STR_LIT>\".length;<EOL>        let statementsBodyEndPos = template.indexOf(\"<STR_LIT>\");<EOL>        let statementsEndPos = statementsBodyEndPos + \"<STR_LIT>\".length;<EOL>        while (statementsStartPos > <NUM_LIT> && (template[statementsStartPos - <NUM_LIT>] == '<STR_LIT>' || template[statementsStartPos - <NUM_LIT>] == '<STR_LIT>'))<EOL>            statementsStartPos--;<EOL>        if (statementsBodyEndPos > <NUM_LIT> && template[statementsBodyEndPos - <NUM_LIT>] == '<STR_LIT>')<EOL>            statementsBodyEndPos--;<EOL>        let templateText = template.slice(statementsBodyStartPos, statementsBodyEndPos).replace(/\\n    /g, '<STR_LIT>');<EOL>        let [c, s] = processTemplate(templateText, args);<EOL>        statements += s + c;<EOL>        template = template.slice(<NUM_LIT>, statementsStartPos) + template.slice(statementsEndPos);<EOL>    }<EOL>    if (typeof args === \"<STR_LIT>\")<EOL>        return [template.replace(/{this}/g, () => args), statements];<EOL>    let ifPos;<EOL>    while ((ifPos = template.indexOf(\"<STR_LIT>\")) > -<NUM_LIT>) {<EOL>        let posBeforeIf = ifPos;<EOL>        while (posBeforeIf > <NUM_LIT> && (template[posBeforeIf - <NUM_LIT>] == '<STR_LIT>' || template[posBeforeIf - <NUM_LIT>] == '<STR_LIT>'))<EOL>            posBeforeIf--;<EOL>        ifPos += <NUM_LIT>;<EOL>        let conditionStartPos = ifPos;<EOL>        while (template[ifPos] !=","gt":"\"<STR_LIT>\")"}
{"input":"<s> /** Returns: [code, statements] */<EOL>function processTemplate(template: string, args: any): [<EOL>    string,<EOL>    string<EOL>] {<EOL>    let statements = \"<STR_LIT>\";<EOL>    if (template.indexOf(\"<STR_LIT>\") > -<NUM_LIT>) {<EOL>        let statementsStartPos = template.indexOf(\"<STR_LIT>\");<EOL>        let statementsBodyStartPos = statementsStartPos + \"<STR_LIT>\".length;<EOL>        let statementsBodyEndPos = template.indexOf(\"<STR_LIT>\");<EOL>        let statementsEndPos = statementsBodyEndPos + \"<STR_LIT>\".length;<EOL>        while (statementsStartPos > <NUM_LIT> && (template[statementsStartPos - <NUM_LIT>] == '<STR_LIT>' || template[statementsStartPos - <NUM_LIT>] == '<STR_LIT>'))<EOL>            statementsStartPos--;<EOL>        if (statementsBodyEndPos > <NUM_LIT> && template[statementsBodyEndPos - <NUM_LIT>] == '<STR_LIT>')<EOL>            statementsBodyEndPos--;<EOL>        let templateText = template.slice(statementsBodyStartPos, statementsBodyEndPos).replace(/\\n    /g, '<STR_LIT>');<EOL>        let [c, s] = processTemplate(templateText, args);<EOL>        statements += s + c;<EOL>        template = template.slice(<NUM_LIT>, statementsStartPos) + template.slice(statementsEndPos);<EOL>    }<EOL>    if (typeof args === \"<STR_LIT>\")<EOL>        return [template.replace(/{this}/g, () => args), statements];<EOL>    let ifPos;<EOL>    while ((ifPos = template.indexOf(\"<STR_LIT>\")) > -<NUM_LIT>) {<EOL>        let posBeforeIf = ifPos;<EOL>        while (posBeforeIf > <NUM_LIT> && (template[posBeforeIf - <NUM_LIT>] == '<STR_LIT>' || template[posBeforeIf - <NUM_LIT>] == '<STR_LIT>'))<EOL>            posBeforeIf--;<EOL>        ifPos += <NUM_LIT>;<EOL>        let conditionStartPos = ifPos;<EOL>        while (template[ifPos] != \"<STR_LIT>\")<EOL>","gt":"ifPos++;"}
{"input":"<s> /** Returns: [code, statements] */<EOL>function processTemplate(template: string, args: any): [<EOL>    string,<EOL>    string<EOL>] {<EOL>    let statements = \"<STR_LIT>\";<EOL>    if (template.indexOf(\"<STR_LIT>\") > -<NUM_LIT>) {<EOL>        let statementsStartPos = template.indexOf(\"<STR_LIT>\");<EOL>        let statementsBodyStartPos = statementsStartPos + \"<STR_LIT>\".length;<EOL>        let statementsBodyEndPos = template.indexOf(\"<STR_LIT>\");<EOL>        let statementsEndPos = statementsBodyEndPos + \"<STR_LIT>\".length;<EOL>        while (statementsStartPos > <NUM_LIT> && (template[statementsStartPos - <NUM_LIT>] == '<STR_LIT>' || template[statementsStartPos - <NUM_LIT>] == '<STR_LIT>'))<EOL>            statementsStartPos--;<EOL>        if (statementsBodyEndPos > <NUM_LIT> && template[statementsBodyEndPos - <NUM_LIT>] == '<STR_LIT>')<EOL>            statementsBodyEndPos--;<EOL>        let templateText = template.slice(statementsBodyStartPos, statementsBodyEndPos).replace(/\\n    /g, '<STR_LIT>');<EOL>        let [c, s] = processTemplate(templateText, args);<EOL>        statements += s + c;<EOL>        template = template.slice(<NUM_LIT>, statementsStartPos) + template.slice(statementsEndPos);<EOL>    }<EOL>    if (typeof args === \"<STR_LIT>\")<EOL>        return [template.replace(/{this}/g, () => args), statements];<EOL>    let ifPos;<EOL>    while ((ifPos = template.indexOf(\"<STR_LIT>\")) > -<NUM_LIT>) {<EOL>        let posBeforeIf = ifPos;<EOL>        while (posBeforeIf > <NUM_LIT> && (template[posBeforeIf - <NUM_LIT>] == '<STR_LIT>' || template[posBeforeIf - <NUM_LIT>] == '<STR_LIT>'))<EOL>            posBeforeIf--;<EOL>        ifPos += <NUM_LIT>;<EOL>        let conditionStartPos = ifPos;<EOL>        while (template[ifPos] != \"<STR_LIT>\")<EOL>            ifPos++;<EOL>        let endIfPos = template.indexOf(\"<STR_LIT>\", ifPos);<EOL>        let elseIfPos = template.indexOf(\"<STR_LIT>\", ifPos);<EOL>        let elsePos = template.indexOf(\"<STR_LIT>\", ifPos);<EOL>        let endIfBodyPos = endIfPos;<EOL>        if (elseIfPos != -<NUM_LIT> && elseIfPos < endIfBodyPos)<EOL>            endIfBodyPos = elseIfPos;<EOL>        if (elsePos != -<NUM_LIT> && elsePos < endIfBodyPos)<EOL>            endIfBodyPos = elsePos;<EOL>","gt":"if (endIfBodyPos > <NUM_LIT> && template[endIfBodyPos - <NUM_LIT>] == '<STR_LIT>')"}
{"input":"<s> /** Returns: [code, statements] */<EOL>function processTemplate(template: string, args: any): [<EOL>    string,<EOL>    string<EOL>] {<EOL>    let statements = \"<STR_LIT>\";<EOL>    if (template.indexOf(\"<STR_LIT>\") > -<NUM_LIT>) {<EOL>        let statementsStartPos = template.indexOf(\"<STR_LIT>\");<EOL>        let statementsBodyStartPos = statementsStartPos + \"<STR_LIT>\".length;<EOL>        let statementsBodyEndPos = template.indexOf(\"<STR_LIT>\");<EOL>        let statementsEndPos = statementsBodyEndPos + \"<STR_LIT>\".length;<EOL>        while (statementsStartPos > <NUM_LIT> && (template[statementsStartPos - <NUM_LIT>] == '<STR_LIT>' || template[statementsStartPos - <NUM_LIT>] == '<STR_LIT>'))<EOL>            statementsStartPos--;<EOL>        if (statementsBodyEndPos > <NUM_LIT> && template[statementsBodyEndPos - <NUM_LIT>] == '<STR_LIT>')<EOL>            statementsBodyEndPos--;<EOL>        let templateText = template.slice(statementsBodyStartPos, statementsBodyEndPos).replace(/\\n    /g, '<STR_LIT>');<EOL>        let [c, s] = processTemplate(templateText, args);<EOL>        statements += s + c;<EOL>        template = template.slice(<NUM_LIT>, statementsStartPos) + template.slice(statementsEndPos);<EOL>    }<EOL>    if (typeof args === \"<STR_LIT>\")<EOL>        return [template.replace(/{this}/g, () => args), statements];<EOL>    let ifPos;<EOL>    while ((ifPos = template.indexOf(\"<STR_LIT>\")) > -<NUM_LIT>) {<EOL>        let posBeforeIf = ifPos;<EOL>        while (posBeforeIf > <NUM_LIT> && (template[posBeforeIf - <NUM_LIT>] == '<STR_LIT>' || template[posBeforeIf - <NUM_LIT>] == '<STR_LIT>'))<EOL>            posBeforeIf--;<EOL>        ifPos += <NUM_LIT>;<EOL>        let conditionStartPos = ifPos;<EOL>        while (template[ifPos] != \"<STR_LIT>\")<EOL>            ifPos++;<EOL>        let endIfPos = template.indexOf(\"<STR_LIT>\", ifPos);<EOL>        let elseIfPos = template.indexOf(\"<STR_LIT>\", ifPos);<EOL>        let elsePos = template.indexOf(\"<STR_LIT>\", ifPos);<EOL>        let endIfBodyPos = endIfPos;<EOL>        if (elseIfPos != -<NUM_LIT> && elseIfPos < endIfBodyPos)<EOL>            endIfBodyPos = elseIfPos;<EOL>        if (elsePos != -<NUM_LIT> && elsePos < endIfBodyPos)<EOL>            endIfBodyPos = elsePos;<EOL>        if (endIfBodyPos > <NUM_LIT> && template[endIfBodyPos - <NUM_LIT>] == '<STR_LIT>')<EOL>            endIfBodyPos--;<EOL>        let posAfterIf = endIfPos + <NUM_LIT>;<EOL>        if (endIfPos > <NUM_LIT> && template[endIfPos - <NUM_LIT>] == '<STR_LIT>')<EOL>            endIfPos--;<EOL>        let evalText = template.slice(conditionStartPos, ifPos);<EOL>        for (let k in args)<EOL>            evalText = evalText.replace(new RegExp(\"<STR_LIT>\" + k + \"<STR_LIT>\", \"<STR_LIT>\"), function (m) { return \"<STR_LIT>\" + m; });<EOL>        let evalResult: boolean = eval(evalText);<EOL>        if (evalResult)<EOL>            template = template.slice(<NUM_LIT>, posBeforeIf) + template.slice(ifPos + <NUM_LIT>, endIfBodyPos).replace(/\\n    /g, '<STR_LIT>') + template.","gt":"slice(posAfterIf);"}
{"input":"<s> /** Returns: [code, statements] */<EOL>function processTemplate(template: string, args: any): [<EOL>    string,<EOL>    string<EOL>] {<EOL>    let statements = \"<STR_LIT>\";<EOL>    if (template.indexOf(\"<STR_LIT>\") > -<NUM_LIT>) {<EOL>        let statementsStartPos = template.indexOf(\"<STR_LIT>\");<EOL>        let statementsBodyStartPos = statementsStartPos + \"<STR_LIT>\".length;<EOL>        let statementsBodyEndPos = template.indexOf(\"<STR_LIT>\");<EOL>        let statementsEndPos = statementsBodyEndPos + \"<STR_LIT>\".length;<EOL>        while (statementsStartPos > <NUM_LIT> && (template[statementsStartPos - <NUM_LIT>] == '<STR_LIT>' || template[statementsStartPos - <NUM_LIT>] == '<STR_LIT>'))<EOL>            statementsStartPos--;<EOL>        if (statementsBodyEndPos > <NUM_LIT> && template[statementsBodyEndPos - <NUM_LIT>] == '<STR_LIT>')<EOL>            statementsBodyEndPos--;<EOL>        let templateText = template.slice(statementsBodyStartPos, statementsBodyEndPos).replace(/\\n    /g, '<STR_LIT>');<EOL>        let [c, s] = processTemplate(templateText, args);<EOL>        statements += s + c;<EOL>        template = template.slice(<NUM_LIT>, statementsStartPos) + template.slice(statementsEndPos);<EOL>    }<EOL>    if (typeof args === \"<STR_LIT>\")<EOL>        return [template.replace(/{this}/g, () => args), statements];<EOL>    let ifPos;<EOL>    while ((ifPos = template.indexOf(\"<STR_LIT>\")) > -<NUM_LIT>) {<EOL>        let posBeforeIf = ifPos;<EOL>        while (posBeforeIf > <NUM_LIT> && (template[posBeforeIf - <NUM_LIT>] == '<STR_LIT>' || template[posBeforeIf - <NUM_LIT>] == '<STR_LIT>'))<EOL>            posBeforeIf--;<EOL>        ifPos += <NUM_LIT>;<EOL>        let conditionStartPos = ifPos;<EOL>        while (template[ifPos] != \"<STR_LIT>\")<EOL>            ifPos++;<EOL>        let endIfPos = template.indexOf(\"<STR_LIT>\", ifPos);<EOL>        let elseIfPos = template.indexOf(\"<STR_LIT>\", ifPos);<EOL>        let elsePos = template.indexOf(\"<STR_LIT>\", ifPos);<EOL>        let endIfBodyPos = endIfPos;<EOL>        if (elseIfPos != -<NUM_LIT> && elseIfPos < endIfBodyPos)<EOL>            endIfBodyPos = elseIfPos;<EOL>        if (elsePos != -<NUM_LIT> && elsePos < endIfBodyPos)<EOL>            endIfBodyPos = elsePos;<EOL>        if (endIfBodyPos > <NUM_LIT> && template[endIfBodyPos - <NUM_LIT>] == '<STR_LIT>')<EOL>            endIfBodyPos--;<EOL>        let posAfterIf = endIfPos + <NUM_LIT>;<EOL>        if (endIfPos > <NUM_LIT> && template[endIfPos - <NUM_LIT>] == '<STR_LIT>')<EOL>            endIfPos--;<EOL>        let evalText = template.slice(conditionStartPos, ifPos);<EOL>        for (let k in args)<EOL>            evalText = evalText.replace(new RegExp(\"<STR_LIT>\" + k + \"<STR_LIT>\", \"<STR_LIT>\"), function (m) { return \"<STR_LIT>\" + m; });<EOL>        let evalResult: boolean = eval(evalText);<EOL>        if (evalResult)<EOL>            template = template.slice(<NUM_LIT>, posBeforeIf) + template.slice(ifPos + <NUM_LIT>, endIfBodyPos).replace(/\\n    /g, '<STR_LIT>') + template.slice(posAfterIf);<EOL>        else if (elseIfPos > -<NUM_LIT>)<EOL>            template = template.slice(<NUM_LIT>, posBeforeIf) + \"<STR_LIT>\" + template.slice(elseIfPos + <NUM_LIT>);<EOL>        else if (elsePos > -<NUM_LIT>)<EOL>            template = template.slice(<NUM_LIT>, posBeforeIf) + template.slice(elsePos + <NUM_LIT>, endIfPos).replace(/\\n    /g, '<STR_LIT>') + template.slice(posAfterIf);<EOL>        else<EOL>            template = template.slice(<NUM_LIT>, posBeforeIf) +","gt":"template.slice(posAfterIf);"}
{"input":"<s> /** Returns: [code, statements] */<EOL>function processTemplate(template: string, args: any): [<EOL>    string,<EOL>    string<EOL>] {<EOL>    let statements = \"<STR_LIT>\";<EOL>    if (template.indexOf(\"<STR_LIT>\") > -<NUM_LIT>) {<EOL>        let statementsStartPos = template.indexOf(\"<STR_LIT>\");<EOL>        let statementsBodyStartPos = statementsStartPos + \"<STR_LIT>\".length;<EOL>        let statementsBodyEndPos = template.indexOf(\"<STR_LIT>\");<EOL>        let statementsEndPos = statementsBodyEndPos + \"<STR_LIT>\".length;<EOL>        while (statementsStartPos > <NUM_LIT> && (template[statementsStartPos - <NUM_LIT>] == '<STR_LIT>' || template[statementsStartPos - <NUM_LIT>] == '<STR_LIT>'))<EOL>            statementsStartPos--;<EOL>        if (statementsBodyEndPos > <NUM_LIT> && template[statementsBodyEndPos - <NUM_LIT>] == '<STR_LIT>')<EOL>            statementsBodyEndPos--;<EOL>        let templateText = template.slice(statementsBodyStartPos, statementsBodyEndPos).replace(/\\n    /g, '<STR_LIT>');<EOL>        let [c, s] = processTemplate(templateText, args);<EOL>        statements += s + c;<EOL>        template = template.slice(<NUM_LIT>, statementsStartPos) + template.slice(statementsEndPos);<EOL>    }<EOL>    if (typeof args === \"<STR_LIT>\")<EOL>        return [template.replace(/{this}/g, () => args), statements];<EOL>    let ifPos;<EOL>    while ((ifPos = template.indexOf(\"<STR_LIT>\")) > -<NUM_LIT>) {<EOL>        let posBeforeIf = ifPos;<EOL>        while (posBeforeIf > <NUM_LIT> && (template[posBeforeIf - <NUM_LIT>] == '<STR_LIT>' || template[posBeforeIf - <NUM_LIT>] == '<STR_LIT>'))<EOL>            posBeforeIf--;<EOL>        ifPos += <NUM_LIT>;<EOL>        let conditionStartPos = ifPos;<EOL>        while (template[ifPos] != \"<STR_LIT>\")<EOL>            ifPos++;<EOL>        let endIfPos = template.indexOf(\"<STR_LIT>\", ifPos);<EOL>        let elseIfPos = template.indexOf(\"<STR_LIT>\", ifPos);<EOL>        let elsePos = template.indexOf(\"<STR_LIT>\", ifPos);<EOL>        let endIfBodyPos = endIfPos;<EOL>        if (elseIfPos != -<NUM_LIT> && elseIfPos < endIfBodyPos)<EOL>            endIfBodyPos = elseIfPos;<EOL>        if (elsePos != -<NUM_LIT> && elsePos < endIfBodyPos)<EOL>            endIfBodyPos = elsePos;<EOL>        if (endIfBodyPos > <NUM_LIT> && template[endIfBodyPos - <NUM_LIT>] == '<STR_LIT>')<EOL>            endIfBodyPos--;<EOL>        let posAfterIf = endIfPos + <NUM_LIT>;<EOL>        if (endIfPos > <NUM_LIT> && template[endIfPos - <NUM_LIT>] == '<STR_LIT>')<EOL>            endIfPos--;<EOL>        let evalText = template.slice(conditionStartPos, ifPos);<EOL>        for (let k in args)<EOL>            evalText = evalText.replace(new RegExp(\"<STR_LIT>\" + k + \"<STR_LIT>\", \"<STR_LIT>\"), function (m) { return \"<STR_LIT>\" + m; });<EOL>        let evalResult: boolean = eval(evalText);<EOL>        if (evalResult)<EOL>            template = template.slice(<NUM_LIT>, posBeforeIf) + template.slice(ifPos + <NUM_LIT>, endIfBodyPos).replace(/\\n    /g, '<STR_LIT>') + template.slice(posAfterIf);<EOL>        else if (elseIfPos > -<NUM_LIT>)<EOL>            template = template.slice(<NUM_LIT>, posBeforeIf) + \"<STR_LIT>\" + template.slice(elseIfPos + <NUM_LIT>);<EOL>        else if (elsePos > -<NUM_LIT>)<EOL>            template = template.slice(<NUM_LIT>, posBeforeIf) + template.slice(elsePos + <NUM_LIT>, endIfPos).replace(/\\n    /g, '<STR_LIT>') + template.slice(posAfterIf);<EOL>        else<EOL>            template = template.slice(<NUM_LIT>, posBeforeIf) + template.slice(posAfterIf);<EOL>    }<EOL>    let replaced = false;<EOL>    for (var k in","gt":"args) {"}
{"input":"<s> /** Returns: [code, statements] */<EOL>function processTemplate(template: string, args: any): [<EOL>    string,<EOL>    string<EOL>] {<EOL>    let statements = \"<STR_LIT>\";<EOL>    if (template.indexOf(\"<STR_LIT>\") > -<NUM_LIT>) {<EOL>        let statementsStartPos = template.indexOf(\"<STR_LIT>\");<EOL>        let statementsBodyStartPos = statementsStartPos + \"<STR_LIT>\".length;<EOL>        let statementsBodyEndPos = template.indexOf(\"<STR_LIT>\");<EOL>        let statementsEndPos = statementsBodyEndPos + \"<STR_LIT>\".length;<EOL>        while (statementsStartPos > <NUM_LIT> && (template[statementsStartPos - <NUM_LIT>] == '<STR_LIT>' || template[statementsStartPos - <NUM_LIT>] == '<STR_LIT>'))<EOL>            statementsStartPos--;<EOL>        if (statementsBodyEndPos > <NUM_LIT> && template[statementsBodyEndPos - <NUM_LIT>] == '<STR_LIT>')<EOL>            statementsBodyEndPos--;<EOL>        let templateText = template.slice(statementsBodyStartPos, statementsBodyEndPos).replace(/\\n    /g, '<STR_LIT>');<EOL>        let [c, s] = processTemplate(templateText, args);<EOL>        statements += s + c;<EOL>        template = template.slice(<NUM_LIT>, statementsStartPos) + template.slice(statementsEndPos);<EOL>    }<EOL>    if (typeof args === \"<STR_LIT>\")<EOL>        return [template.replace(/{this}/g, () => args), statements];<EOL>    let ifPos;<EOL>    while ((ifPos = template.indexOf(\"<STR_LIT>\")) > -<NUM_LIT>) {<EOL>        let posBeforeIf = ifPos;<EOL>        while (posBeforeIf > <NUM_LIT> && (template[posBeforeIf - <NUM_LIT>] == '<STR_LIT>' || template[posBeforeIf - <NUM_LIT>] == '<STR_LIT>'))<EOL>            posBeforeIf--;<EOL>        ifPos += <NUM_LIT>;<EOL>        let conditionStartPos = ifPos;<EOL>        while (template[ifPos] != \"<STR_LIT>\")<EOL>            ifPos++;<EOL>        let endIfPos = template.indexOf(\"<STR_LIT>\", ifPos);<EOL>        let elseIfPos = template.indexOf(\"<STR_LIT>\", ifPos);<EOL>        let elsePos = template.indexOf(\"<STR_LIT>\", ifPos);<EOL>        let endIfBodyPos = endIfPos;<EOL>        if (elseIfPos != -<NUM_LIT> && elseIfPos < endIfBodyPos)<EOL>            endIfBodyPos = elseIfPos;<EOL>        if (elsePos != -<NUM_LIT> && elsePos < endIfBodyPos)<EOL>            endIfBodyPos = elsePos;<EOL>        if (endIfBodyPos > <NUM_LIT> && template[endIfBodyPos - <NUM_LIT>] == '<STR_LIT>')<EOL>            endIfBodyPos--;<EOL>        let posAfterIf = endIfPos + <NUM_LIT>;<EOL>        if (endIfPos > <NUM_LIT> && template[endIfPos - <NUM_LIT>] == '<STR_LIT>')<EOL>            endIfPos--;<EOL>        let evalText = template.slice(conditionStartPos, ifPos);<EOL>        for (let k in args)<EOL>            evalText = evalText.replace(new RegExp(\"<STR_LIT>\" + k + \"<STR_LIT>\", \"<STR_LIT>\"), function (m) { return \"<STR_LIT>\" + m; });<EOL>        let evalResult: boolean = eval(evalText);<EOL>        if (evalResult)<EOL>            template = template.slice(<NUM_LIT>, posBeforeIf) + template.slice(ifPos + <NUM_LIT>, endIfBodyPos).replace(/\\n    /g, '<STR_LIT>') + template.slice(posAfterIf);<EOL>        else if (elseIfPos > -<NUM_LIT>)<EOL>            template = template.slice(<NUM_LIT>, posBeforeIf) + \"<STR_LIT>\" + template.slice(elseIfPos + <NUM_LIT>);<EOL>        else if (elsePos > -<NUM_LIT>)<EOL>            template = template.slice(<NUM_LIT>, posBeforeIf) + template.slice(elsePos + <NUM_LIT>, endIfPos).replace(/\\n    /g, '<STR_LIT>') + template.slice(posAfterIf);<EOL>        else<EOL>            template = template.slice(<NUM_LIT>, posBeforeIf) + template.slice(posAfterIf);<EOL>    }<EOL>    let replaced = false;<EOL>    for (var k in args) {<EOL>        if (k == \"<STR_LIT>\")<EOL>            continue;<EOL>        if (args[k] && args[k].push) {<EOL>            let data = { template };<EOL>            while (replaceArray(data, k, args[k], statements))<EOL>                replaced = true;<EOL>            template = data.template;<EOL>        }<EOL>","gt":"else {"}
{"input":"<s> /** Returns: [code, statements] */<EOL>function processTemplate(template: string, args: any): [<EOL>    string,<EOL>    string<EOL>] {<EOL>    let statements = \"<STR_LIT>\";<EOL>    if (template.indexOf(\"<STR_LIT>\") > -<NUM_LIT>) {<EOL>        let statementsStartPos = template.indexOf(\"<STR_LIT>\");<EOL>        let statementsBodyStartPos = statementsStartPos + \"<STR_LIT>\".length;<EOL>        let statementsBodyEndPos = template.indexOf(\"<STR_LIT>\");<EOL>        let statementsEndPos = statementsBodyEndPos + \"<STR_LIT>\".length;<EOL>        while (statementsStartPos > <NUM_LIT> && (template[statementsStartPos - <NUM_LIT>] == '<STR_LIT>' || template[statementsStartPos - <NUM_LIT>] == '<STR_LIT>'))<EOL>            statementsStartPos--;<EOL>        if (statementsBodyEndPos > <NUM_LIT> && template[statementsBodyEndPos - <NUM_LIT>] == '<STR_LIT>')<EOL>            statementsBodyEndPos--;<EOL>        let templateText = template.slice(statementsBodyStartPos, statementsBodyEndPos).replace(/\\n    /g, '<STR_LIT>');<EOL>        let [c, s] = processTemplate(templateText, args);<EOL>        statements += s + c;<EOL>        template = template.slice(<NUM_LIT>, statementsStartPos) + template.slice(statementsEndPos);<EOL>    }<EOL>    if (typeof args === \"<STR_LIT>\")<EOL>        return [template.replace(/{this}/g, () => args), statements];<EOL>    let ifPos;<EOL>    while ((ifPos = template.indexOf(\"<STR_LIT>\")) > -<NUM_LIT>) {<EOL>        let posBeforeIf = ifPos;<EOL>        while (posBeforeIf > <NUM_LIT> && (template[posBeforeIf - <NUM_LIT>] == '<STR_LIT>' || template[posBeforeIf - <NUM_LIT>] == '<STR_LIT>'))<EOL>            posBeforeIf--;<EOL>        ifPos += <NUM_LIT>;<EOL>        let conditionStartPos = ifPos;<EOL>        while (template[ifPos] != \"<STR_LIT>\")<EOL>            ifPos++;<EOL>        let endIfPos = template.indexOf(\"<STR_LIT>\", ifPos);<EOL>        let elseIfPos = template.indexOf(\"<STR_LIT>\", ifPos);<EOL>        let elsePos = template.indexOf(\"<STR_LIT>\", ifPos);<EOL>        let endIfBodyPos = endIfPos;<EOL>        if (elseIfPos != -<NUM_LIT> && elseIfPos < endIfBodyPos)<EOL>            endIfBodyPos = elseIfPos;<EOL>        if (elsePos != -<NUM_LIT> && elsePos < endIfBodyPos)<EOL>            endIfBodyPos = elsePos;<EOL>        if (endIfBodyPos > <NUM_LIT> && template[endIfBodyPos - <NUM_LIT>] == '<STR_LIT>')<EOL>            endIfBodyPos--;<EOL>        let posAfterIf = endIfPos + <NUM_LIT>;<EOL>        if (endIfPos > <NUM_LIT> && template[endIfPos - <NUM_LIT>] == '<STR_LIT>')<EOL>            endIfPos--;<EOL>        let evalText = template.slice(conditionStartPos, ifPos);<EOL>        for (let k in args)<EOL>            evalText = evalText.replace(new RegExp(\"<STR_LIT>\" + k + \"<STR_LIT>\", \"<STR_LIT>\"), function (m) { return \"<STR_LIT>\" + m; });<EOL>        let evalResult: boolean = eval(evalText);<EOL>        if (evalResult)<EOL>            template = template.slice(<NUM_LIT>, posBeforeIf) + template.slice(ifPos + <NUM_LIT>, endIfBodyPos).replace(/\\n    /g, '<STR_LIT>') + template.slice(posAfterIf);<EOL>        else if (elseIfPos > -<NUM_LIT>)<EOL>            template = template.slice(<NUM_LIT>, posBeforeIf) + \"<STR_LIT>\" + template.slice(elseIfPos + <NUM_LIT>);<EOL>        else if (elsePos > -<NUM_LIT>)<EOL>            template = template.slice(<NUM_LIT>, posBeforeIf) + template.slice(elsePos + <NUM_LIT>, endIfPos).replace(/\\n    /g, '<STR_LIT>') + template.slice(posAfterIf);<EOL>        else<EOL>            template = template.slice(<NUM_LIT>, posBeforeIf) + template.slice(posAfterIf);<EOL>    }<EOL>    let replaced = false;<EOL>    for (var k in args) {<EOL>        if (k == \"<STR_LIT>\")<EOL>            continue;<EOL>        if (args[k] && args[k].push) {<EOL>            let data = { template };<EOL>            while (replaceArray(data, k, args[k], statements))<EOL>                replaced = true;<EOL>            template = data.template;<EOL>        }<EOL>        else {<EOL>            let index = -<NUM_LIT>;<EOL>            while ((index = template.indexOf(\"<STR_LIT>\" + k + \"<STR_LIT>\")) > -<NUM_LIT>) {<EOL>                let spaces = '<STR_LIT>';<EOL>                while (template.length > index && template[index - <NUM_LIT>] == '<STR_LIT>') {<EOL>                    index--;<EOL>                    spaces +=","gt":"'<STR_LIT>';"}
{"input":"<s> /** Returns: [code, statements] */<EOL>function processTemplate(template: string, args: any): [<EOL>    string,<EOL>    string<EOL>] {<EOL>    let statements = \"<STR_LIT>\";<EOL>    if (template.indexOf(\"<STR_LIT>\") > -<NUM_LIT>) {<EOL>        let statementsStartPos = template.indexOf(\"<STR_LIT>\");<EOL>        let statementsBodyStartPos = statementsStartPos + \"<STR_LIT>\".length;<EOL>        let statementsBodyEndPos = template.indexOf(\"<STR_LIT>\");<EOL>        let statementsEndPos = statementsBodyEndPos + \"<STR_LIT>\".length;<EOL>        while (statementsStartPos > <NUM_LIT> && (template[statementsStartPos - <NUM_LIT>] == '<STR_LIT>' || template[statementsStartPos - <NUM_LIT>] == '<STR_LIT>'))<EOL>            statementsStartPos--;<EOL>        if (statementsBodyEndPos > <NUM_LIT> && template[statementsBodyEndPos - <NUM_LIT>] == '<STR_LIT>')<EOL>            statementsBodyEndPos--;<EOL>        let templateText = template.slice(statementsBodyStartPos, statementsBodyEndPos).replace(/\\n    /g, '<STR_LIT>');<EOL>        let [c, s] = processTemplate(templateText, args);<EOL>        statements += s + c;<EOL>        template = template.slice(<NUM_LIT>, statementsStartPos) + template.slice(statementsEndPos);<EOL>    }<EOL>    if (typeof args === \"<STR_LIT>\")<EOL>        return [template.replace(/{this}/g, () => args), statements];<EOL>    let ifPos;<EOL>    while ((ifPos = template.indexOf(\"<STR_LIT>\")) > -<NUM_LIT>) {<EOL>        let posBeforeIf = ifPos;<EOL>        while (posBeforeIf > <NUM_LIT> && (template[posBeforeIf - <NUM_LIT>] == '<STR_LIT>' || template[posBeforeIf - <NUM_LIT>] == '<STR_LIT>'))<EOL>            posBeforeIf--;<EOL>        ifPos += <NUM_LIT>;<EOL>        let conditionStartPos = ifPos;<EOL>        while (template[ifPos] != \"<STR_LIT>\")<EOL>            ifPos++;<EOL>        let endIfPos = template.indexOf(\"<STR_LIT>\", ifPos);<EOL>        let elseIfPos = template.indexOf(\"<STR_LIT>\", ifPos);<EOL>        let elsePos = template.indexOf(\"<STR_LIT>\", ifPos);<EOL>        let endIfBodyPos = endIfPos;<EOL>        if (elseIfPos != -<NUM_LIT> && elseIfPos < endIfBodyPos)<EOL>            endIfBodyPos = elseIfPos;<EOL>        if (elsePos != -<NUM_LIT> && elsePos < endIfBodyPos)<EOL>            endIfBodyPos = elsePos;<EOL>        if (endIfBodyPos > <NUM_LIT> && template[endIfBodyPos - <NUM_LIT>] == '<STR_LIT>')<EOL>            endIfBodyPos--;<EOL>        let posAfterIf = endIfPos + <NUM_LIT>;<EOL>        if (endIfPos > <NUM_LIT> && template[endIfPos - <NUM_LIT>] == '<STR_LIT>')<EOL>            endIfPos--;<EOL>        let evalText = template.slice(conditionStartPos, ifPos);<EOL>        for (let k in args)<EOL>            evalText = evalText.replace(new RegExp(\"<STR_LIT>\" + k + \"<STR_LIT>\", \"<STR_LIT>\"), function (m) { return \"<STR_LIT>\" + m; });<EOL>        let evalResult: boolean = eval(evalText);<EOL>        if (evalResult)<EOL>            template = template.slice(<NUM_LIT>, posBeforeIf) + template.slice(ifPos + <NUM_LIT>, endIfBodyPos).replace(/\\n    /g, '<STR_LIT>') + template.slice(posAfterIf);<EOL>        else if (elseIfPos > -<NUM_LIT>)<EOL>            template = template.slice(<NUM_LIT>, posBeforeIf) + \"<STR_LIT>\" + template.slice(elseIfPos + <NUM_LIT>);<EOL>        else if (elsePos > -<NUM_LIT>)<EOL>            template = template.slice(<NUM_LIT>, posBeforeIf) + template.slice(elsePos + <NUM_LIT>, endIfPos).replace(/\\n    /g, '<STR_LIT>') + template.slice(posAfterIf);<EOL>        else<EOL>            template = template.slice(<NUM_LIT>, posBeforeIf) + template.slice(posAfterIf);<EOL>    }<EOL>    let replaced = false;<EOL>    for (var k in args) {<EOL>        if (k == \"<STR_LIT>\")<EOL>            continue;<EOL>        if (args[k] && args[k].push) {<EOL>            let data = { template };<EOL>            while (replaceArray(data, k, args[k], statements))<EOL>                replaced = true;<EOL>            template = data.template;<EOL>        }<EOL>        else {<EOL>            let index = -<NUM_LIT>;<EOL>            while ((index = template.indexOf(\"<STR_LIT>\" + k + \"<STR_LIT>\")) > -<NUM_LIT>) {<EOL>                let spaces = '<STR_LIT>';<EOL>                while (template.length > index && template[index - <NUM_LIT>] == '<STR_LIT>') {<EOL>                    index--;<EOL>                    spaces += '<STR_LIT>';<EOL>                }<EOL>                let","gt":"value = args[k];"}
{"input":"<s> /** Returns: [code, statements] */<EOL>function processTemplate(template: string, args: any): [<EOL>    string,<EOL>    string<EOL>] {<EOL>    let statements = \"<STR_LIT>\";<EOL>    if (template.indexOf(\"<STR_LIT>\") > -<NUM_LIT>) {<EOL>        let statementsStartPos = template.indexOf(\"<STR_LIT>\");<EOL>        let statementsBodyStartPos = statementsStartPos + \"<STR_LIT>\".length;<EOL>        let statementsBodyEndPos = template.indexOf(\"<STR_LIT>\");<EOL>        let statementsEndPos = statementsBodyEndPos + \"<STR_LIT>\".length;<EOL>        while (statementsStartPos > <NUM_LIT> && (template[statementsStartPos - <NUM_LIT>] == '<STR_LIT>' || template[statementsStartPos - <NUM_LIT>] == '<STR_LIT>'))<EOL>            statementsStartPos--;<EOL>        if (statementsBodyEndPos > <NUM_LIT> && template[statementsBodyEndPos - <NUM_LIT>] == '<STR_LIT>')<EOL>            statementsBodyEndPos--;<EOL>        let templateText = template.slice(statementsBodyStartPos, statementsBodyEndPos).replace(/\\n    /g, '<STR_LIT>');<EOL>        let [c, s] = processTemplate(templateText, args);<EOL>        statements += s + c;<EOL>        template = template.slice(<NUM_LIT>, statementsStartPos) + template.slice(statementsEndPos);<EOL>    }<EOL>    if (typeof args === \"<STR_LIT>\")<EOL>        return [template.replace(/{this}/g, () => args), statements];<EOL>    let ifPos;<EOL>    while ((ifPos = template.indexOf(\"<STR_LIT>\")) > -<NUM_LIT>) {<EOL>        let posBeforeIf = ifPos;<EOL>        while (posBeforeIf > <NUM_LIT> && (template[posBeforeIf - <NUM_LIT>] == '<STR_LIT>' || template[posBeforeIf - <NUM_LIT>] == '<STR_LIT>'))<EOL>            posBeforeIf--;<EOL>        ifPos += <NUM_LIT>;<EOL>        let conditionStartPos = ifPos;<EOL>        while (template[ifPos] != \"<STR_LIT>\")<EOL>            ifPos++;<EOL>        let endIfPos = template.indexOf(\"<STR_LIT>\", ifPos);<EOL>        let elseIfPos = template.indexOf(\"<STR_LIT>\", ifPos);<EOL>        let elsePos = template.indexOf(\"<STR_LIT>\", ifPos);<EOL>        let endIfBodyPos = endIfPos;<EOL>        if (elseIfPos != -<NUM_LIT> && elseIfPos < endIfBodyPos)<EOL>            endIfBodyPos = elseIfPos;<EOL>        if (elsePos != -<NUM_LIT> && elsePos < endIfBodyPos)<EOL>            endIfBodyPos = elsePos;<EOL>        if (endIfBodyPos > <NUM_LIT> && template[endIfBodyPos - <NUM_LIT>] == '<STR_LIT>')<EOL>            endIfBodyPos--;<EOL>        let posAfterIf = endIfPos + <NUM_LIT>;<EOL>        if (endIfPos > <NUM_LIT> && template[endIfPos - <NUM_LIT>] == '<STR_LIT>')<EOL>            endIfPos--;<EOL>        let evalText = template.slice(conditionStartPos, ifPos);<EOL>        for (let k in args)<EOL>            evalText = evalText.replace(new RegExp(\"<STR_LIT>\" + k + \"<STR_LIT>\", \"<STR_LIT>\"), function (m) { return \"<STR_LIT>\" + m; });<EOL>        let evalResult: boolean = eval(evalText);<EOL>        if (evalResult)<EOL>            template = template.slice(<NUM_LIT>, posBeforeIf) + template.slice(ifPos + <NUM_LIT>, endIfBodyPos).replace(/\\n    /g, '<STR_LIT>') + template.slice(posAfterIf);<EOL>        else if (elseIfPos > -<NUM_LIT>)<EOL>            template = template.slice(<NUM_LIT>, posBeforeIf) + \"<STR_LIT>\" + template.slice(elseIfPos + <NUM_LIT>);<EOL>        else if (elsePos > -<NUM_LIT>)<EOL>            template = template.slice(<NUM_LIT>, posBeforeIf) + template.slice(elsePos + <NUM_LIT>, endIfPos).replace(/\\n    /g, '<STR_LIT>') + template.slice(posAfterIf);<EOL>        else<EOL>            template = template.slice(<NUM_LIT>, posBeforeIf) + template.slice(posAfterIf);<EOL>    }<EOL>    let replaced = false;<EOL>    for (var k in args) {<EOL>        if (k == \"<STR_LIT>\")<EOL>            continue;<EOL>        if (args[k] && args[k].push) {<EOL>            let data = { template };<EOL>            while (replaceArray(data, k, args[k], statements))<EOL>                replaced = true;<EOL>            template = data.template;<EOL>        }<EOL>        else {<EOL>            let index = -<NUM_LIT>;<EOL>            while ((index = template.indexOf(\"<STR_LIT>\" + k + \"<STR_LIT>\")) > -<NUM_LIT>) {<EOL>                let spaces = '<STR_LIT>';<EOL>                while (template.length > index && template[index - <NUM_LIT>] == '<STR_LIT>') {<EOL>                    index--;<EOL>                    spaces += '<STR_LIT>';<EOL>                }<EOL>                let value = args[k];<EOL>                if (value && value.resolve)<EOL>                    value = value.resolve();<EOL>                if (","gt":"value && typeof value === '<STR_LIT>')"}
{"input":"<s> /** Returns: [code, statements] */<EOL>function processTemplate(template: string, args: any): [<EOL>    string,<EOL>    string<EOL>] {<EOL>    let statements = \"<STR_LIT>\";<EOL>    if (template.indexOf(\"<STR_LIT>\") > -<NUM_LIT>) {<EOL>        let statementsStartPos = template.indexOf(\"<STR_LIT>\");<EOL>        let statementsBodyStartPos = statementsStartPos + \"<STR_LIT>\".length;<EOL>        let statementsBodyEndPos = template.indexOf(\"<STR_LIT>\");<EOL>        let statementsEndPos = statementsBodyEndPos + \"<STR_LIT>\".length;<EOL>        while (statementsStartPos > <NUM_LIT> && (template[statementsStartPos - <NUM_LIT>] == '<STR_LIT>' || template[statementsStartPos - <NUM_LIT>] == '<STR_LIT>'))<EOL>            statementsStartPos--;<EOL>        if (statementsBodyEndPos > <NUM_LIT> && template[statementsBodyEndPos - <NUM_LIT>] == '<STR_LIT>')<EOL>            statementsBodyEndPos--;<EOL>        let templateText = template.slice(statementsBodyStartPos, statementsBodyEndPos).replace(/\\n    /g, '<STR_LIT>');<EOL>        let [c, s] = processTemplate(templateText, args);<EOL>        statements += s + c;<EOL>        template = template.slice(<NUM_LIT>, statementsStartPos) + template.slice(statementsEndPos);<EOL>    }<EOL>    if (typeof args === \"<STR_LIT>\")<EOL>        return [template.replace(/{this}/g, () => args), statements];<EOL>    let ifPos;<EOL>    while ((ifPos = template.indexOf(\"<STR_LIT>\")) > -<NUM_LIT>) {<EOL>        let posBeforeIf = ifPos;<EOL>        while (posBeforeIf > <NUM_LIT> && (template[posBeforeIf - <NUM_LIT>] == '<STR_LIT>' || template[posBeforeIf - <NUM_LIT>] == '<STR_LIT>'))<EOL>            posBeforeIf--;<EOL>        ifPos += <NUM_LIT>;<EOL>        let conditionStartPos = ifPos;<EOL>        while (template[ifPos] != \"<STR_LIT>\")<EOL>            ifPos++;<EOL>        let endIfPos = template.indexOf(\"<STR_LIT>\", ifPos);<EOL>        let elseIfPos = template.indexOf(\"<STR_LIT>\", ifPos);<EOL>        let elsePos = template.indexOf(\"<STR_LIT>\", ifPos);<EOL>        let endIfBodyPos = endIfPos;<EOL>        if (elseIfPos != -<NUM_LIT> && elseIfPos < endIfBodyPos)<EOL>            endIfBodyPos = elseIfPos;<EOL>        if (elsePos != -<NUM_LIT> && elsePos < endIfBodyPos)<EOL>            endIfBodyPos = elsePos;<EOL>        if (endIfBodyPos > <NUM_LIT> && template[endIfBodyPos - <NUM_LIT>] == '<STR_LIT>')<EOL>            endIfBodyPos--;<EOL>        let posAfterIf = endIfPos + <NUM_LIT>;<EOL>        if (endIfPos > <NUM_LIT> && template[endIfPos - <NUM_LIT>] == '<STR_LIT>')<EOL>            endIfPos--;<EOL>        let evalText = template.slice(conditionStartPos, ifPos);<EOL>        for (let k in args)<EOL>            evalText = evalText.replace(new RegExp(\"<STR_LIT>\" + k + \"<STR_LIT>\", \"<STR_LIT>\"), function (m) { return \"<STR_LIT>\" + m; });<EOL>        let evalResult: boolean = eval(evalText);<EOL>        if (evalResult)<EOL>            template = template.slice(<NUM_LIT>, posBeforeIf) + template.slice(ifPos + <NUM_LIT>, endIfBodyPos).replace(/\\n    /g, '<STR_LIT>') + template.slice(posAfterIf);<EOL>        else if (elseIfPos > -<NUM_LIT>)<EOL>            template = template.slice(<NUM_LIT>, posBeforeIf) + \"<STR_LIT>\" + template.slice(elseIfPos + <NUM_LIT>);<EOL>        else if (elsePos > -<NUM_LIT>)<EOL>            template = template.slice(<NUM_LIT>, posBeforeIf) + template.slice(elsePos + <NUM_LIT>, endIfPos).replace(/\\n    /g, '<STR_LIT>') + template.slice(posAfterIf);<EOL>        else<EOL>            template = template.slice(<NUM_LIT>, posBeforeIf) + template.slice(posAfterIf);<EOL>    }<EOL>    let replaced = false;<EOL>    for (var k in args) {<EOL>        if (k == \"<STR_LIT>\")<EOL>            continue;<EOL>        if (args[k] && args[k].push) {<EOL>            let data = { template };<EOL>            while (replaceArray(data, k, args[k], statements))<EOL>                replaced = true;<EOL>            template = data.template;<EOL>        }<EOL>        else {<EOL>            let index = -<NUM_LIT>;<EOL>            while ((index = template.indexOf(\"<STR_LIT>\" + k + \"<STR_LIT>\")) > -<NUM_LIT>) {<EOL>                let spaces = '<STR_LIT>';<EOL>                while (template.length > index && template[index - <NUM_LIT>] == '<STR_LIT>') {<EOL>                    index--;<EOL>                    spaces += '<STR_LIT>';<EOL>                }<EOL>                let value = args[k];<EOL>                if (value && value.resolve)<EOL>                    value = value.resolve();<EOL>                if (value && typeof value === '<STR_LIT>')<EOL>                    value = value.replace(/\\n/g,","gt":"'<STR_LIT>' + spaces);"}
{"input":"<s> /** Returns: [code, statements] */<EOL>function processTemplate(template: string, args: any): [<EOL>    string,<EOL>    string<EOL>] {<EOL>    let statements = \"<STR_LIT>\";<EOL>    if (template.indexOf(\"<STR_LIT>\") > -<NUM_LIT>) {<EOL>        let statementsStartPos = template.indexOf(\"<STR_LIT>\");<EOL>        let statementsBodyStartPos = statementsStartPos + \"<STR_LIT>\".length;<EOL>        let statementsBodyEndPos = template.indexOf(\"<STR_LIT>\");<EOL>        let statementsEndPos = statementsBodyEndPos + \"<STR_LIT>\".length;<EOL>        while (statementsStartPos > <NUM_LIT> && (template[statementsStartPos - <NUM_LIT>] == '<STR_LIT>' || template[statementsStartPos - <NUM_LIT>] == '<STR_LIT>'))<EOL>            statementsStartPos--;<EOL>        if (statementsBodyEndPos > <NUM_LIT> && template[statementsBodyEndPos - <NUM_LIT>] == '<STR_LIT>')<EOL>            statementsBodyEndPos--;<EOL>        let templateText = template.slice(statementsBodyStartPos, statementsBodyEndPos).replace(/\\n    /g, '<STR_LIT>');<EOL>        let [c, s] = processTemplate(templateText, args);<EOL>        statements += s + c;<EOL>        template = template.slice(<NUM_LIT>, statementsStartPos) + template.slice(statementsEndPos);<EOL>    }<EOL>    if (typeof args === \"<STR_LIT>\")<EOL>        return [template.replace(/{this}/g, () => args), statements];<EOL>    let ifPos;<EOL>    while ((ifPos = template.indexOf(\"<STR_LIT>\")) > -<NUM_LIT>) {<EOL>        let posBeforeIf = ifPos;<EOL>        while (posBeforeIf > <NUM_LIT> && (template[posBeforeIf - <NUM_LIT>] == '<STR_LIT>' || template[posBeforeIf - <NUM_LIT>] == '<STR_LIT>'))<EOL>            posBeforeIf--;<EOL>        ifPos += <NUM_LIT>;<EOL>        let conditionStartPos = ifPos;<EOL>        while (template[ifPos] != \"<STR_LIT>\")<EOL>            ifPos++;<EOL>        let endIfPos = template.indexOf(\"<STR_LIT>\", ifPos);<EOL>        let elseIfPos = template.indexOf(\"<STR_LIT>\", ifPos);<EOL>        let elsePos = template.indexOf(\"<STR_LIT>\", ifPos);<EOL>        let endIfBodyPos = endIfPos;<EOL>        if (elseIfPos != -<NUM_LIT> && elseIfPos < endIfBodyPos)<EOL>            endIfBodyPos = elseIfPos;<EOL>        if (elsePos != -<NUM_LIT> && elsePos < endIfBodyPos)<EOL>            endIfBodyPos = elsePos;<EOL>        if (endIfBodyPos > <NUM_LIT> && template[endIfBodyPos - <NUM_LIT>] == '<STR_LIT>')<EOL>            endIfBodyPos--;<EOL>        let posAfterIf = endIfPos + <NUM_LIT>;<EOL>        if (endIfPos > <NUM_LIT> && template[endIfPos - <NUM_LIT>] == '<STR_LIT>')<EOL>            endIfPos--;<EOL>        let evalText = template.slice(conditionStartPos, ifPos);<EOL>        for (let k in args)<EOL>            evalText = evalText.replace(new RegExp(\"<STR_LIT>\" + k + \"<STR_LIT>\", \"<STR_LIT>\"), function (m) { return \"<STR_LIT>\" + m; });<EOL>        let evalResult: boolean = eval(evalText);<EOL>        if (evalResult)<EOL>            template = template.slice(<NUM_LIT>, posBeforeIf) + template.slice(ifPos + <NUM_LIT>, endIfBodyPos).replace(/\\n    /g, '<STR_LIT>') + template.slice(posAfterIf);<EOL>        else if (elseIfPos > -<NUM_LIT>)<EOL>            template = template.slice(<NUM_LIT>, posBeforeIf) + \"<STR_LIT>\" + template.slice(elseIfPos + <NUM_LIT>);<EOL>        else if (elsePos > -<NUM_LIT>)<EOL>            template = template.slice(<NUM_LIT>, posBeforeIf) + template.slice(elsePos + <NUM_LIT>, endIfPos).replace(/\\n    /g, '<STR_LIT>') + template.slice(posAfterIf);<EOL>        else<EOL>            template = template.slice(<NUM_LIT>, posBeforeIf) + template.slice(posAfterIf);<EOL>    }<EOL>    let replaced = false;<EOL>    for (var k in args) {<EOL>        if (k == \"<STR_LIT>\")<EOL>            continue;<EOL>        if (args[k] && args[k].push) {<EOL>            let data = { template };<EOL>            while (replaceArray(data, k, args[k], statements))<EOL>                replaced = true;<EOL>            template = data.template;<EOL>        }<EOL>        else {<EOL>            let index = -<NUM_LIT>;<EOL>            while ((index = template.indexOf(\"<STR_LIT>\" + k + \"<STR_LIT>\")) > -<NUM_LIT>) {<EOL>                let spaces = '<STR_LIT>';<EOL>                while (template.length > index && template[index - <NUM_LIT>] == '<STR_LIT>') {<EOL>                    index--;<EOL>                    spaces += '<STR_LIT>';<EOL>                }<EOL>                let value = args[k];<EOL>                if (value && value.resolve)<EOL>                    value = value.resolve();<EOL>                if (value && typeof value === '<STR_LIT>')<EOL>                    value = value.replace(/\\n/g, '<STR_LIT>' + spaces);<EOL>","gt":"template = template.replace(\"<STR_LIT>\" + k + \"<STR_LIT>\", () => value);"}
{"input":"<s> export function isAngularCLIJson(o: object): o is AngularCLIJson {<EOL>    const obj = <AngularCLIJson>o;<EOL>    return","gt":"obj &&"}
{"input":"<s> /**<EOL> * A factory function that creates a comparer to be used in multi-dimensional sorting.<EOL> *<EOL> * <h4>Example</h4><EOL> * ```typescript<EOL> * var myArray = [{a:1:b:2},{a:3,b:4},{a:1,b:3}];<EOL> *<EOL> * // First sort by a, then by b.<EOL> * myArray.sort(<EOL> *   createComparer(<EOL> *     (e)=> [e.a, e.b],<EOL> *     [Order.Ascending, Order.Descending]<EOL> *   )<EOL> * );<EOL> *<EOL> * // result: [{a:1,b:3},{a:1:b:2},{a:3,b:4}]<EOL> * ```<EOL> *<EOL> * @param selector<EOL> * @param order<EOL> * @param equivalentToNaN<EOL> * @returns {(a:TSource, b:TSource)=>CompareResult}<EOL> */<EOL>export function createComparer<TSource, TSelect extends Primitive>(selector: Selector<TSource, TSelect | TSelect[]>, order: Order | Order[] = Order.Ascending, equivalentToNaN: any = NaN): Comparison<TSource> {<EOL>    const nanHasEquivalent = !Type.isTrueNaN(equivalentToNaN);<EOL>    return (a: TSource, b: TSource): CompareResult => {<EOL>        <EOL>        const aValue = ensureArray(selector(a));<EOL>","gt":"const bValue = ensureArray(selector(b));"}
{"input":"<s> /**<EOL> * A factory function that creates a comparer to be used in multi-dimensional sorting.<EOL> *<EOL> * <h4>Example</h4><EOL> * ```typescript<EOL> * var myArray = [{a:1:b:2},{a:3,b:4},{a:1,b:3}];<EOL> *<EOL> * // First sort by a, then by b.<EOL> * myArray.sort(<EOL> *   createComparer(<EOL> *     (e)=> [e.a, e.b],<EOL> *     [Order.Ascending, Order.Descending]<EOL> *   )<EOL> * );<EOL> *<EOL> * // result: [{a:1,b:3},{a:1:b:2},{a:3,b:4}]<EOL> * ```<EOL> *<EOL> * @param selector<EOL> * @param order<EOL> * @param equivalentToNaN<EOL> * @returns {(a:TSource, b:TSource)=>CompareResult}<EOL> */<EOL>export function createComparer<TSource, TSelect extends Primitive>(selector: Selector<TSource, TSelect | TSelect[]>, order: Order | Order[] = Order.Ascending, equivalentToNaN: any = NaN): Comparison<TSource> {<EOL>    const nanHasEquivalent = !Type.isTrueNaN(equivalentToNaN);<EOL>    return (a: TSource, b: TSource): CompareResult => {<EOL>        <EOL>        const aValue = ensureArray(selector(a));<EOL>        const bValue = ensureArray(selector(b));<EOL>        const len = Math.min(aValue.length, bValue.length);<EOL>        const oArray = (order) instanceof (Array) ? order : null;<EOL>        for (let i = <NUM_LIT>;","gt":"i < len; i++) {"}
{"input":"<s> /**<EOL> * A factory function that creates a comparer to be used in multi-dimensional sorting.<EOL> *<EOL> * <h4>Example</h4><EOL> * ```typescript<EOL> * var myArray = [{a:1:b:2},{a:3,b:4},{a:1,b:3}];<EOL> *<EOL> * // First sort by a, then by b.<EOL> * myArray.sort(<EOL> *   createComparer(<EOL> *     (e)=> [e.a, e.b],<EOL> *     [Order.Ascending, Order.Descending]<EOL> *   )<EOL> * );<EOL> *<EOL> * // result: [{a:1,b:3},{a:1:b:2},{a:3,b:4}]<EOL> * ```<EOL> *<EOL> * @param selector<EOL> * @param order<EOL> * @param equivalentToNaN<EOL> * @returns {(a:TSource, b:TSource)=>CompareResult}<EOL> */<EOL>export function createComparer<TSource, TSelect extends Primitive>(selector: Selector<TSource, TSelect | TSelect[]>, order: Order | Order[] = Order.Ascending, equivalentToNaN: any = NaN): Comparison<TSource> {<EOL>    const nanHasEquivalent = !Type.isTrueNaN(equivalentToNaN);<EOL>    return (a: TSource, b: TSource): CompareResult => {<EOL>        <EOL>        const aValue = ensureArray(selector(a));<EOL>        const bValue = ensureArray(selector(b));<EOL>        const len = Math.min(aValue.length, bValue.length);<EOL>        const oArray = (order) instanceof (Array) ? order : null;<EOL>        for (let i = <NUM_LIT>; i < len; i++) {<EOL>            let vA = aValue[i], vB = bValue[i];<EOL>            const o = oArray<EOL>                ? (i < oArray.length ? oArray[i] : Order.Ascending)<EOL>                : <Order>order;<EOL>","gt":"if (nanHasEquivalent) {"}
{"input":"<s> /**<EOL> * A factory function that creates a comparer to be used in multi-dimensional sorting.<EOL> *<EOL> * <h4>Example</h4><EOL> * ```typescript<EOL> * var myArray = [{a:1:b:2},{a:3,b:4},{a:1,b:3}];<EOL> *<EOL> * // First sort by a, then by b.<EOL> * myArray.sort(<EOL> *   createComparer(<EOL> *     (e)=> [e.a, e.b],<EOL> *     [Order.Ascending, Order.Descending]<EOL> *   )<EOL> * );<EOL> *<EOL> * // result: [{a:1,b:3},{a:1:b:2},{a:3,b:4}]<EOL> * ```<EOL> *<EOL> * @param selector<EOL> * @param order<EOL> * @param equivalentToNaN<EOL> * @returns {(a:TSource, b:TSource)=>CompareResult}<EOL> */<EOL>export function createComparer<TSource, TSelect extends Primitive>(selector: Selector<TSource, TSelect | TSelect[]>, order: Order | Order[] = Order.Ascending, equivalentToNaN: any = NaN): Comparison<TSource> {<EOL>    const nanHasEquivalent = !Type.isTrueNaN(equivalentToNaN);<EOL>    return (a: TSource, b: TSource): CompareResult => {<EOL>        <EOL>        const aValue = ensureArray(selector(a));<EOL>        const bValue = ensureArray(selector(b));<EOL>        const len = Math.min(aValue.length, bValue.length);<EOL>        const oArray = (order) instanceof (Array) ? order : null;<EOL>        for (let i = <NUM_LIT>; i < len; i++) {<EOL>            let vA = aValue[i], vB = bValue[i];<EOL>            const o = oArray<EOL>                ? (i < oArray.length ? oArray[i] : Order.Ascending)<EOL>                : <Order>order;<EOL>            if (nanHasEquivalent) {<EOL>                if (Type.isTrueNaN(vA))<EOL>                    vA = equivalentToNaN;<EOL>                if (Type.isTrueNaN(vB))<EOL>                    vB = equivalentToNaN;<EOL>            }<EOL>            const r = compare(","gt":"vA, vB);"}
{"input":"<s> /** This is comment for function signature*/<EOL>export function fooWithParameters(/** this is comment about a*/ a: string, <EOL>/** this is comment for b*/<EOL>b: number) {<EOL>    var","gt":"d = a;"}
{"input":"<s> function globalfooWithOverloads(a: any): any {<EOL>    return","gt":"a;"}
{"input":"<s> /**<EOL> * @hidden<EOL> * Rewrites an absolute URL so it works across file and http based engines<EOL> */<EOL>export function normalizeURL(url: string): string {<EOL>    const ionic = (<any>window)['<STR_LIT>'];<EOL>    if (","gt":"ionic && ionic.normalizeURL) {"}
{"input":"<s> function getMultiRobot() {<EOL>    return","gt":"multiRobot;"}
{"input":"<s> export function getPropertiesFromObject(changedObj: any): Array<string> {<EOL>","gt":"return Enumerable.from(changedObj).select((x: any) => x.key).toArray();"}
{"input":"<s> export default function (config: any) {<EOL>    if (_.isNil(config) || _.isEmpty(config)) {<EOL>        return;<EOL>    }<EOL>    const hasData = hasDataCondition(","gt":"config);"}
{"input":"<s> export default function (config: any) {<EOL>    if (_.isNil(config) || _.isEmpty(config)) {<EOL>        return;<EOL>    }<EOL>    const hasData = hasDataCondition(config);<EOL>    if (!hasData) {<EOL>        return;<EOL>    }<EOL>    const commonChart =","gt":"new CommonChart(config);"}
{"input":"<s> export function isIterator<T>(instance: any): instance is IIterator<T> {<EOL>","gt":"return Type.hasMemberOfType<IIterator<T>>(instance, \"<STR_LIT>\", Type.FUNCTION);"}
{"input":"<s> export function defineMember(plt: PlatformApi, property: ComponentConstructorProperty, elm: HostElement, instance: ComponentInstance, memberName: string) {<EOL>    function getComponentProp(this: ComponentInstance, values?: any) {<EOL>        <EOL>        <EOL>","gt":"values = plt.valuesMap.get(plt.hostElementMap.get(this));"}
{"input":"<s> export function defineMember(plt: PlatformApi, property: ComponentConstructorProperty, elm: HostElement, instance: ComponentInstance, memberName: string) {<EOL>    function getComponentProp(this: ComponentInstance, values?: any) {<EOL>        <EOL>        <EOL>        values = plt.valuesMap.get(plt.hostElementMap.get(this));<EOL>        return values && values[memberName];<EOL>    }<EOL>    function setComponentProp(this: ComponentInstance, newValue: any, elm?: HostElement) {<EOL>        <EOL>        elm =","gt":"plt.hostElementMap.get(this);"}
{"input":"<s> export function defineMember(plt: PlatformApi, property: ComponentConstructorProperty, elm: HostElement, instance: ComponentInstance, memberName: string) {<EOL>    function getComponentProp(this: ComponentInstance, values?: any) {<EOL>        <EOL>        <EOL>        values = plt.valuesMap.get(plt.hostElementMap.get(this));<EOL>        return values && values[memberName];<EOL>    }<EOL>    function setComponentProp(this: ComponentInstance, newValue: any, elm?: HostElement) {<EOL>        <EOL>        elm = plt.hostElementMap.get(this);<EOL>        if (elm) {<EOL>            if (property.state || property.mutable) {<EOL>                setValue(plt, elm, memberName, newValue);<EOL>            }<EOL>            else if (Build.verboseError) {<EOL>                console.warn(`<STR_LIT>`);<EOL>            }<EOL>        }<EOL>    }<EOL>    if (property.type || property.state) {<EOL>        const values = plt.","gt":"valuesMap.get(elm);"}
{"input":"<s> export function defineMember(plt: PlatformApi, property: ComponentConstructorProperty, elm: HostElement, instance: ComponentInstance, memberName: string) {<EOL>    function getComponentProp(this: ComponentInstance, values?: any) {<EOL>        <EOL>        <EOL>        values = plt.valuesMap.get(plt.hostElementMap.get(this));<EOL>        return values && values[memberName];<EOL>    }<EOL>    function setComponentProp(this: ComponentInstance, newValue: any, elm?: HostElement) {<EOL>        <EOL>        elm = plt.hostElementMap.get(this);<EOL>        if (elm) {<EOL>            if (property.state || property.mutable) {<EOL>                setValue(plt, elm, memberName, newValue);<EOL>            }<EOL>            else if (Build.verboseError) {<EOL>                console.warn(`<STR_LIT>`);<EOL>            }<EOL>        }<EOL>    }<EOL>    if (property.type || property.state) {<EOL>        const values = plt.valuesMap.get(elm);<EOL>        if (!property.","gt":"state) {"}
{"input":"<s> export function defineMember(plt: PlatformApi, property: ComponentConstructorProperty, elm: HostElement, instance: ComponentInstance, memberName: string) {<EOL>    function getComponentProp(this: ComponentInstance, values?: any) {<EOL>        <EOL>        <EOL>        values = plt.valuesMap.get(plt.hostElementMap.get(this));<EOL>        return values && values[memberName];<EOL>    }<EOL>    function setComponentProp(this: ComponentInstance, newValue: any, elm?: HostElement) {<EOL>        <EOL>        elm = plt.hostElementMap.get(this);<EOL>        if (elm) {<EOL>            if (property.state || property.mutable) {<EOL>                setValue(plt, elm, memberName, newValue);<EOL>            }<EOL>            else if (Build.verboseError) {<EOL>                console.warn(`<STR_LIT>`);<EOL>            }<EOL>        }<EOL>    }<EOL>    if (property.type || property.state) {<EOL>        const values = plt.valuesMap.get(elm);<EOL>        if (!property.state) {<EOL>            if (property.attr && (values[memberName] === undefined || values[memberName] === '<STR_LIT>')) {<EOL>                <EOL>                const hostAttrValue = plt.domApi.$getAttribute(elm, property.attr);<EOL>                if (hostAttrValue != null) {<EOL>                    <EOL>                    <EOL>                    values[memberName] = parsePropertyValue(property.type, hostAttrValue);<EOL>                }<EOL>            }<EOL>            if (Build.clientSide) {<EOL>                <EOL>                <EOL>                <EOL>                <EOL>                <EOL>                <EOL>                <EOL>                if (elm.hasOwnProperty(memberName)) {<EOL>                    <EOL>                    <EOL>                    <EOL>                    if (values[memberName] === undefined) {<EOL>                        values[memberName] = (elm","gt":"as any)[memberName];"}
{"input":"<s> export function defineMember(plt: PlatformApi, property: ComponentConstructorProperty, elm: HostElement, instance: ComponentInstance, memberName: string) {<EOL>    function getComponentProp(this: ComponentInstance, values?: any) {<EOL>        <EOL>        <EOL>        values = plt.valuesMap.get(plt.hostElementMap.get(this));<EOL>        return values && values[memberName];<EOL>    }<EOL>    function setComponentProp(this: ComponentInstance, newValue: any, elm?: HostElement) {<EOL>        <EOL>        elm = plt.hostElementMap.get(this);<EOL>        if (elm) {<EOL>            if (property.state || property.mutable) {<EOL>                setValue(plt, elm, memberName, newValue);<EOL>            }<EOL>            else if (Build.verboseError) {<EOL>                console.warn(`<STR_LIT>`);<EOL>            }<EOL>        }<EOL>    }<EOL>    if (property.type || property.state) {<EOL>        const values = plt.valuesMap.get(elm);<EOL>        if (!property.state) {<EOL>            if (property.attr && (values[memberName] === undefined || values[memberName] === '<STR_LIT>')) {<EOL>                <EOL>                const hostAttrValue = plt.domApi.$getAttribute(elm, property.attr);<EOL>                if (hostAttrValue != null) {<EOL>                    <EOL>                    <EOL>                    values[memberName] = parsePropertyValue(property.type, hostAttrValue);<EOL>                }<EOL>            }<EOL>            if (Build.clientSide) {<EOL>                <EOL>                <EOL>                <EOL>                <EOL>                <EOL>                <EOL>                <EOL>                if (elm.hasOwnProperty(memberName)) {<EOL>                    <EOL>                    <EOL>                    <EOL>                    if (values[memberName] === undefined) {<EOL>                        values[memberName] = (elm as any)[memberName];<EOL>                    }<EOL>                    <EOL>                    <EOL>                    delete (elm as any)[memberName];<EOL>                }<EOL>            }<EOL>            else {<EOL>                <EOL>                <EOL>                <EOL>                <EOL>                <EOL>                <EOL>","gt":"if (elementHasProperty(plt, elm, memberName)) {"}
{"input":"<s> export function defineMember(plt: PlatformApi, property: ComponentConstructorProperty, elm: HostElement, instance: ComponentInstance, memberName: string) {<EOL>    function getComponentProp(this: ComponentInstance, values?: any) {<EOL>        <EOL>        <EOL>        values = plt.valuesMap.get(plt.hostElementMap.get(this));<EOL>        return values && values[memberName];<EOL>    }<EOL>    function setComponentProp(this: ComponentInstance, newValue: any, elm?: HostElement) {<EOL>        <EOL>        elm = plt.hostElementMap.get(this);<EOL>        if (elm) {<EOL>            if (property.state || property.mutable) {<EOL>                setValue(plt, elm, memberName, newValue);<EOL>            }<EOL>            else if (Build.verboseError) {<EOL>                console.warn(`<STR_LIT>`);<EOL>            }<EOL>        }<EOL>    }<EOL>    if (property.type || property.state) {<EOL>        const values = plt.valuesMap.get(elm);<EOL>        if (!property.state) {<EOL>            if (property.attr && (values[memberName] === undefined || values[memberName] === '<STR_LIT>')) {<EOL>                <EOL>                const hostAttrValue = plt.domApi.$getAttribute(elm, property.attr);<EOL>                if (hostAttrValue != null) {<EOL>                    <EOL>                    <EOL>                    values[memberName] = parsePropertyValue(property.type, hostAttrValue);<EOL>                }<EOL>            }<EOL>            if (Build.clientSide) {<EOL>                <EOL>                <EOL>                <EOL>                <EOL>                <EOL>                <EOL>                <EOL>                if (elm.hasOwnProperty(memberName)) {<EOL>                    <EOL>                    <EOL>                    <EOL>                    if (values[memberName] === undefined) {<EOL>                        values[memberName] = (elm as any)[memberName];<EOL>                    }<EOL>                    <EOL>                    <EOL>                    delete (elm as any)[memberName];<EOL>                }<EOL>            }<EOL>            else {<EOL>                <EOL>                <EOL>                <EOL>                <EOL>                <EOL>                <EOL>                if (elementHasProperty(plt, elm, memberName)) {<EOL>                    <EOL>                    <EOL>                    <EOL>                    if (values[memberName] === undefined) {<EOL>","gt":"values[memberName] = (elm as any)[memberName];"}
{"input":"<s> export function defineMember(plt: PlatformApi, property: ComponentConstructorProperty, elm: HostElement, instance: ComponentInstance, memberName: string) {<EOL>    function getComponentProp(this: ComponentInstance, values?: any) {<EOL>        <EOL>        <EOL>        values = plt.valuesMap.get(plt.hostElementMap.get(this));<EOL>        return values && values[memberName];<EOL>    }<EOL>    function setComponentProp(this: ComponentInstance, newValue: any, elm?: HostElement) {<EOL>        <EOL>        elm = plt.hostElementMap.get(this);<EOL>        if (elm) {<EOL>            if (property.state || property.mutable) {<EOL>                setValue(plt, elm, memberName, newValue);<EOL>            }<EOL>            else if (Build.verboseError) {<EOL>                console.warn(`<STR_LIT>`);<EOL>            }<EOL>        }<EOL>    }<EOL>    if (property.type || property.state) {<EOL>        const values = plt.valuesMap.get(elm);<EOL>        if (!property.state) {<EOL>            if (property.attr && (values[memberName] === undefined || values[memberName] === '<STR_LIT>')) {<EOL>                <EOL>                const hostAttrValue = plt.domApi.$getAttribute(elm, property.attr);<EOL>                if (hostAttrValue != null) {<EOL>                    <EOL>                    <EOL>                    values[memberName] = parsePropertyValue(property.type, hostAttrValue);<EOL>                }<EOL>            }<EOL>            if (Build.clientSide) {<EOL>                <EOL>                <EOL>                <EOL>                <EOL>                <EOL>                <EOL>                <EOL>                if (elm.hasOwnProperty(memberName)) {<EOL>                    <EOL>                    <EOL>                    <EOL>                    if (values[memberName] === undefined) {<EOL>                        values[memberName] = (elm as any)[memberName];<EOL>                    }<EOL>                    <EOL>                    <EOL>                    delete (elm as any)[memberName];<EOL>                }<EOL>            }<EOL>            else {<EOL>                <EOL>                <EOL>                <EOL>                <EOL>                <EOL>                <EOL>                if (elementHasProperty(plt, elm, memberName)) {<EOL>                    <EOL>                    <EOL>                    <EOL>                    if (values[memberName] === undefined) {<EOL>                        values[memberName] = (elm as any)[memberName];<EOL>                    }<EOL>                }<EOL>            }<EOL>        }<EOL>        if (instance.hasOwnProperty(memberName) && values[memberName] === undefined) {<EOL>            <EOL>            <EOL>            <EOL>            <EOL>            <EOL>            values[memberName] = (instance as any)[memberName];<EOL>        }<EOL>        if (property.watchCallbacks) {<EOL>            values[WATCH_CB_PREFIX + memberName] = property.watchCallbacks.slice();<EOL>        }<EOL>        <EOL>        <EOL>        definePropertyGetterSetter(instance, memberName, getComponentProp, setComponentProp);<EOL>    }<EOL>    else if (Build.element && property.elementRef) {<EOL>        <EOL>        <EOL>        <EOL>        definePropertyValue(instance,","gt":"memberName, elm);"}
{"input":"<s> function test1(x: number | string) {<EOL>    if (x instanceof","gt":"Object) {"}
{"input":"<s> function formatMembers(membersMeta: MembersMeta) {<EOL>    if (!membersMeta) {<EOL>        return <NUM_LIT>;<EOL>    }<EOL>    const observeAttrs:","gt":"any[] = [];"}
{"input":"<s> function formatMembers(membersMeta: MembersMeta) {<EOL>    if (!membersMeta) {<EOL>        return <NUM_LIT>;<EOL>    }<EOL>    const observeAttrs: any[] = [];<EOL>    const memberNames = Object.keys(membersMeta).","gt":"sort();"}
{"input":"<s> function formatMembers(membersMeta: MembersMeta) {<EOL>    if (!membersMeta) {<EOL>        return <NUM_LIT>;<EOL>    }<EOL>    const observeAttrs: any[] = [];<EOL>    const memberNames = Object.keys(membersMeta).sort();<EOL>    memberNames.forEach(memberName => {<EOL>        const memberMeta = membersMeta[memberName];<EOL>        const d:","gt":"any[] = ["}
{"input":"<s> function formatMembers(membersMeta: MembersMeta) {<EOL>    if (!membersMeta) {<EOL>        return <NUM_LIT>;<EOL>    }<EOL>    const observeAttrs: any[] = [];<EOL>    const memberNames = Object.keys(membersMeta).sort();<EOL>    memberNames.forEach(memberName => {<EOL>        const memberMeta = membersMeta[memberName];<EOL>        const d: any[] = [<EOL>            memberName,<EOL>            memberMeta.memberType<EOL>        ];<EOL>        if (memberMeta.propType === PROP_TYPE.Boolean || memberMeta.propType === PROP_TYPE.Number || memberMeta.propType === PROP_TYPE.String || memberMeta.propType === PROP_TYPE.Any) {<EOL>            <EOL>            if (memberMeta.attribName !== memberName) {<EOL>                <EOL>                <EOL>                d.push(","gt":"memberMeta.attribName);"}
{"input":"<s> function formatMembers(membersMeta: MembersMeta) {<EOL>    if (!membersMeta) {<EOL>        return <NUM_LIT>;<EOL>    }<EOL>    const observeAttrs: any[] = [];<EOL>    const memberNames = Object.keys(membersMeta).sort();<EOL>    memberNames.forEach(memberName => {<EOL>        const memberMeta = membersMeta[memberName];<EOL>        const d: any[] = [<EOL>            memberName,<EOL>            memberMeta.memberType<EOL>        ];<EOL>        if (memberMeta.propType === PROP_TYPE.Boolean || memberMeta.propType === PROP_TYPE.Number || memberMeta.propType === PROP_TYPE.String || memberMeta.propType === PROP_TYPE.Any) {<EOL>            <EOL>            if (memberMeta.attribName !== memberName) {<EOL>                <EOL>                <EOL>                d.push(memberMeta.attribName);<EOL>            }<EOL>            else {<EOL>                <EOL>                <EOL>                d.","gt":"push(<NUM_LIT>);"}
{"input":"<s> function formatMembers(membersMeta: MembersMeta) {<EOL>    if (!membersMeta) {<EOL>        return <NUM_LIT>;<EOL>    }<EOL>    const observeAttrs: any[] = [];<EOL>    const memberNames = Object.keys(membersMeta).sort();<EOL>    memberNames.forEach(memberName => {<EOL>        const memberMeta = membersMeta[memberName];<EOL>        const d: any[] = [<EOL>            memberName,<EOL>            memberMeta.memberType<EOL>        ];<EOL>        if (memberMeta.propType === PROP_TYPE.Boolean || memberMeta.propType === PROP_TYPE.Number || memberMeta.propType === PROP_TYPE.String || memberMeta.propType === PROP_TYPE.Any) {<EOL>            <EOL>            if (memberMeta.attribName !== memberName) {<EOL>                <EOL>                <EOL>                d.push(memberMeta.attribName);<EOL>            }<EOL>            else {<EOL>                <EOL>                <EOL>                d.push(<NUM_LIT>);<EOL>            }<EOL>            d.push(memberMeta.propType);<EOL>        }<EOL>        else {<EOL>            <EOL>            d.push(<NUM_LIT>);<EOL>            d.push(PROP_TYPE.Unknown);<EOL>        }<EOL>","gt":"if (memberMeta.ctrlId) {"}
{"input":"<s> function formatMembers(membersMeta: MembersMeta) {<EOL>    if (!membersMeta) {<EOL>        return <NUM_LIT>;<EOL>    }<EOL>    const observeAttrs: any[] = [];<EOL>    const memberNames = Object.keys(membersMeta).sort();<EOL>    memberNames.forEach(memberName => {<EOL>        const memberMeta = membersMeta[memberName];<EOL>        const d: any[] = [<EOL>            memberName,<EOL>            memberMeta.memberType<EOL>        ];<EOL>        if (memberMeta.propType === PROP_TYPE.Boolean || memberMeta.propType === PROP_TYPE.Number || memberMeta.propType === PROP_TYPE.String || memberMeta.propType === PROP_TYPE.Any) {<EOL>            <EOL>            if (memberMeta.attribName !== memberName) {<EOL>                <EOL>                <EOL>                d.push(memberMeta.attribName);<EOL>            }<EOL>            else {<EOL>                <EOL>                <EOL>                d.push(<NUM_LIT>);<EOL>            }<EOL>            d.push(memberMeta.propType);<EOL>        }<EOL>        else {<EOL>            <EOL>            d.push(<NUM_LIT>);<EOL>            d.push(PROP_TYPE.Unknown);<EOL>        }<EOL>        if (memberMeta.ctrlId) {<EOL>            d.push(memberMeta.ctrlId);<EOL>        }<EOL>        observeAttrs.push(","gt":"d);"}
{"input":"<s> async function emptyArrayLiteral(): Promise<int[]> {<EOL>","gt":"\"<STR_LIT>\";"}
{"input":"<s> /**<EOL> * Crate custom TranslateLoader since we have a diff dir structure for our json files<EOL> */<EOL>export function createTranslateLoader(httpClient: HttpClient): TranslateLoader {<EOL>    return new TranslateHttpLoader(","gt":"httpClient, '<STR_LIT>', '<STR_LIT>');"}
{"input":"<s> function drawHover() {<EOL>    if (!tangentPoint)<EOL>        return;<EOL>","gt":"drawTangentLine();"}
{"input":"<s> function drawHover() {<EOL>    if (!tangentPoint)<EOL>        return;<EOL>    drawTangentLine();<EOL>    let coord = tangentPoint.coord;<EOL>    let point = tangentPoint.point;<EOL>    let coordStyle = {<EOL>        dashed: [","gt":"<NUM_LIT>, <NUM_LIT>],"}
{"input":"<s> function drawHover() {<EOL>    if (!tangentPoint)<EOL>        return;<EOL>    drawTangentLine();<EOL>    let coord = tangentPoint.coord;<EOL>    let point = tangentPoint.point;<EOL>    let coordStyle = {<EOL>        dashed: [<NUM_LIT>, <NUM_LIT>],<EOL>        props: {<EOL>            lineWidth: <NUM_LIT>,<EOL>            strokeStyle: '<STR_LIT>',<EOL>        },<EOL>    };<EOL>    drawLine([<NUM_LIT>, coord[<NUM_LIT>]], [size.width, coord[<NUM_LIT>]], coordStyle);<EOL>    drawLine([coord[<NUM_LIT>], <NUM_LIT>], [coord[<NUM_LIT>], size.","gt":"height], coordStyle);"}
{"input":"<s> function drawHover() {<EOL>    if (!tangentPoint)<EOL>        return;<EOL>    drawTangentLine();<EOL>    let coord = tangentPoint.coord;<EOL>    let point = tangentPoint.point;<EOL>    let coordStyle = {<EOL>        dashed: [<NUM_LIT>, <NUM_LIT>],<EOL>        props: {<EOL>            lineWidth: <NUM_LIT>,<EOL>            strokeStyle: '<STR_LIT>',<EOL>        },<EOL>    };<EOL>    drawLine([<NUM_LIT>, coord[<NUM_LIT>]], [size.width, coord[<NUM_LIT>]], coordStyle);<EOL>    drawLine([coord[<NUM_LIT>], <NUM_LIT>], [coord[<NUM_LIT>], size.height], coordStyle);<EOL>    let date = new Date(point.time + point.reduce);<EOL>    let pointInfo = [<EOL>        '<STR_LIT>',<EOL>        date.getMinutes(),<EOL>        '<STR_LIT>',<EOL>        date.getSeconds(),<EOL>        '<STR_LIT>',<EOL>        date.getMilliseconds(),<EOL>        '<STR_LIT>',<EOL>        notation(point[monitorOptions.data]),<EOL>        '<STR_LIT>',<EOL>    ].","gt":"join('<STR_LIT>');"}
{"input":"<s> <EOL>function length2<A>(ar: A[]): number {<EOL>    return ar.","gt":"length;"}
{"input":"<s> async function revokeToken(tokenInfo: TokenInfo) {<EOL>    const token = await OAuthTokenModel.getByRefreshTokenAndPopulateUser(tokenInfo.refreshToken);<EOL>    if (token)<EOL>        token.","gt":"destroy();"}
{"input":"<s> export function keyboardHandler(scrollbar: I.Scrollbar) {<EOL>    const addEvent = eventScope(scrollbar);<EOL>    const container = scrollbar.containerEl;<EOL>    addEvent(container, '<STR_LIT>', (evt: KeyboardEvent) => {<EOL>        if (document.activeElement !== container) {<EOL>","gt":"return;"}
{"input":"<s> export function keyboardHandler(scrollbar: I.Scrollbar) {<EOL>    const addEvent = eventScope(scrollbar);<EOL>    const container = scrollbar.containerEl;<EOL>    addEvent(container, '<STR_LIT>', (evt: KeyboardEvent) => {<EOL>        if (document.activeElement !== container) {<EOL>            return;<EOL>        }<EOL>        const delta = getKeyDelta(scrollbar, evt.keyCode || evt.which);<EOL>","gt":"if (!delta) {"}
{"input":"<s> export function keyboardHandler(scrollbar: I.Scrollbar) {<EOL>    const addEvent = eventScope(scrollbar);<EOL>    const container = scrollbar.containerEl;<EOL>    addEvent(container, '<STR_LIT>', (evt: KeyboardEvent) => {<EOL>        if (document.activeElement !== container) {<EOL>            return;<EOL>        }<EOL>        const delta = getKeyDelta(scrollbar, evt.keyCode || evt.which);<EOL>        if (!delta) {<EOL>            return;<EOL>        }<EOL>        const [x, y] = delta;<EOL>        scrollbar.addTransformableMomentum(x, y, evt, (willScroll) => {<EOL>            if (","gt":"willScroll) {"}
{"input":"<s> export function keyboardHandler(scrollbar: I.Scrollbar) {<EOL>    const addEvent = eventScope(scrollbar);<EOL>    const container = scrollbar.containerEl;<EOL>    addEvent(container, '<STR_LIT>', (evt: KeyboardEvent) => {<EOL>        if (document.activeElement !== container) {<EOL>            return;<EOL>        }<EOL>        const delta = getKeyDelta(scrollbar, evt.keyCode || evt.which);<EOL>        if (!delta) {<EOL>            return;<EOL>        }<EOL>        const [x, y] = delta;<EOL>        scrollbar.addTransformableMomentum(x, y, evt, (willScroll) => {<EOL>            if (willScroll) {<EOL>                evt.preventDefault();<EOL>            }<EOL>            else {<EOL>                scrollbar.containerEl.blur();<EOL>","gt":"if (scrollbar.parent) {"}
{"input":"<s> export function findCompiledModule(fileName: string): CompiledModule {<EOL>    let baseFileName = fileName.replace(/(\\.ts|\\.tsx)$/, '<STR_LIT>');<EOL>    let compiledFileName = `<STR_LIT>`;<EOL>    if (fs.existsSync(compiledFileName)) {<EOL>        let mapFileName = `<STR_LIT>`;<EOL>        let isMapExists =","gt":"fs.existsSync(mapFileName);"}
{"input":"<s> export function findCompiledModule(fileName: string): CompiledModule {<EOL>    let baseFileName = fileName.replace(/(\\.ts|\\.tsx)$/, '<STR_LIT>');<EOL>    let compiledFileName = `<STR_LIT>`;<EOL>    if (fs.existsSync(compiledFileName)) {<EOL>        let mapFileName = `<STR_LIT>`;<EOL>        let isMapExists = fs.existsSync(mapFileName);<EOL>        let result = {<EOL>            fileName: compiledFileName,<EOL>            text: fs.readFileSync(compiledFileName).toString(),<EOL>            mapName:","gt":"isMapExists ? mapFileName : null,"}
{"input":"<s> /**<EOL> * Create an iterator which yields a value a single time.<EOL> *<EOL> * @param value - The value to wrap in an iterator.<EOL> *<EOL> * @returns A new iterator which yields the value a single time.<EOL> *<EOL> * #### Example<EOL> * ```typescript<EOL> * import { once, toArray } from '@phosphor/algorithm';<EOL> *<EOL> * let stream = once(7);<EOL> *<EOL> * toArray(stream);  // [7]<EOL> * ```<EOL> */<EOL>export function once<T>(value: T): IIterator<T> {<EOL>    return new","gt":"RepeatIterator<T>(value, <NUM_LIT>);"}
{"input":"<s> function computeCost(tour: Point[]) {<EOL>    \"<STR_LIT>\";<EOL>    let total = <NUM_LIT>;<EOL>    for (let i = <NUM_LIT>; i <","gt":"tour.length; ++i) {"}
{"input":"<s> /** Mixin to augment a component or directive with a `disabled` property. */<EOL>export function mixinDisabled<T extends Constructor<{}>>(base: T): Constructor<ICanDisable> & T {<EOL>    return class extends base {<EOL>        private _disabled: boolean = false;<EOL>        constructor(...args: any[]) {<EOL>            super(...args);<EOL>        }<EOL>","gt":"get disabled(): boolean {"}
{"input":"<s> /** Mixin to augment a component or directive with a `disabled` property. */<EOL>export function mixinDisabled<T extends Constructor<{}>>(base: T): Constructor<ICanDisable> & T {<EOL>    return class extends base {<EOL>        private _disabled: boolean = false;<EOL>        constructor(...args: any[]) {<EOL>            super(...args);<EOL>        }<EOL>        get disabled(): boolean {<EOL>            return this._disabled;<EOL>        }<EOL>        set disabled(value: boolean) {<EOL>            let newValue: boolean = coerceBooleanProperty(value);<EOL>            if (","gt":"this._disabled !== newValue) {"}
{"input":"<s> function ensureUserHasRight(userRight: UserRight) {<EOL>    return function (req: express.Request, res: express.Response, next: express.NextFunction) {<EOL>        const user = res.locals.oauth.token.user as UserModel;<EOL>        if (user.hasRight(userRight) === false) {<EOL>            const","gt":"message = `<STR_LIT>`;"}
{"input":"<s> function ensureUserHasRight(userRight: UserRight) {<EOL>    return function (req: express.Request, res: express.Response, next: express.NextFunction) {<EOL>        const user = res.locals.oauth.token.user as UserModel;<EOL>        if (user.hasRight(userRight) === false) {<EOL>            const message = `<STR_LIT>`;<EOL>            logger.info(message);<EOL>            return res.status(<NUM_LIT>)<EOL>                .json({<EOL>                error: message<EOL>            })<EOL>                .","gt":"end();"}
{"input":"<s> function setSeriesOpacity(chart: any, currSeries: ISeries) {<EOL>    const opacity = currSeries.opacity;<EOL>    if (_.isNumber(opacity) || _.isString(opacity)) {<EOL>        return chart.opacity(opacity);<EOL>    }<EOL>    if (_.isArray(opacity) && opacity.length >= <NUM_LIT>) {<EOL>        if (opacity[<NUM_LIT>]) {<EOL>            return chart.opacity(opacity[<NUM_LIT>], opacity[<NUM_LIT>]);<EOL>        }<EOL>        return chart.","gt":"opacity(opacity[<NUM_LIT>]);"}
{"input":"<s> async function firstAssignment() {<EOL>    \"<STR_LIT>\";<EOL>    let booleanVar: boolean;<EOL>    let intVar: int;<EOL>    let","gt":"numberVar: number;"}
{"input":"<s> async function firstAssignment() {<EOL>    \"<STR_LIT>\";<EOL>    let booleanVar: boolean;<EOL>    let intVar: int;<EOL>    let numberVar: number;<EOL>    let objectVar: MyClass;<EOL>    let objectOrUndefined: MyClass | undefined;<EOL>    booleanVar = true;<EOL>    intVar = <NUM_LIT>;<EOL>    numberVar = <NUM_LIT>;<EOL>","gt":"objectVar = new MyClass();"}
{"input":"<s> async function removeVideoFromBlacklistController(req: express.Request, res: express.Response, next: express.NextFunction) {<EOL>    const blacklistedVideo = res.locals.blacklistedVideo as VideoBlacklistModel;<EOL>    try {<EOL>        await blacklistedVideo.destroy();<EOL>","gt":"logger.info('<STR_LIT>', res.locals.video.uuid);"}
{"input":"<s> async function removeVideoFromBlacklistController(req: express.Request, res: express.Response, next: express.NextFunction) {<EOL>    const blacklistedVideo = res.locals.blacklistedVideo as VideoBlacklistModel;<EOL>    try {<EOL>        await blacklistedVideo.destroy();<EOL>        logger.info('<STR_LIT>', res.locals.video.uuid);<EOL>        return res.sendStatus(<NUM_LIT>);<EOL>    }<EOL>    catch (err) {<EOL>        logger.error('<STR_LIT>',","gt":"res.locals.video.uuid, err);"}
{"input":"<s> export function downsidetasukigap(data: StockData) {<EOL>    return","gt":"new DownsideTasukiGap().hasPattern(data);"}
{"input":"<s> function f6<T>(x: (a: T) => T) {<EOL>","gt":"return null;"}
{"input":"<s> export function compile(config): Promise<any> {<EOL>    return new Promise((resolve, reject) => {<EOL>        const compiler = webpack(config);<EOL>        compiler.run((err, stats) => {<EOL>            if (","gt":"err) {"}
{"input":"<s> /**<EOL> * Checks if _objectInstance exists and has the method/property<EOL> * @private<EOL> */<EOL>export function instanceAvailability(pluginObj: any, methodName?: string): boolean {<EOL>    return","gt":"pluginObj._objectInstance && (!methodName || typeof pluginObj._objectInstance[methodName] !== '<STR_LIT>');"}
{"input":"<s> <EOL>function defaultStyles() {<EOL>    let scaleFactor = Config.scaleFactor();<EOL>    return {<EOL>        font: \"<STR_LIT>\",<EOL>        fontStyle: '<STR_LIT>',<EOL>        overflow:","gt":"'<STR_LIT>',"}
{"input":"<s> <EOL>function defaultStyles() {<EOL>    let scaleFactor = Config.scaleFactor();<EOL>    return {<EOL>        font: \"<STR_LIT>\",<EOL>        fontStyle: '<STR_LIT>',<EOL>        overflow: '<STR_LIT>',<EOL>        fillColor: false,<EOL>        textColor: <NUM_LIT>,<EOL>        halign: '<STR_LIT>',<EOL>","gt":"valign: '<STR_LIT>',"}
{"input":"<s> <EOL>function defaultStyles() {<EOL>    let scaleFactor = Config.scaleFactor();<EOL>    return {<EOL>        font: \"<STR_LIT>\",<EOL>        fontStyle: '<STR_LIT>',<EOL>        overflow: '<STR_LIT>',<EOL>        fillColor: false,<EOL>        textColor: <NUM_LIT>,<EOL>        halign: '<STR_LIT>',<EOL>        valign: '<STR_LIT>',<EOL>        fontSize: <NUM_LIT>,<EOL>        cellPadding: <NUM_LIT> / scaleFactor,<EOL>        lineColor:","gt":"<NUM_LIT>,"}
{"input":"<s> /**<EOL> * Function TdJelloAnimation<EOL> *<EOL> * params:<EOL> * * anchor: Name of the anchor that will attach to a dom element in the components template that will contain the animation.<EOL> * * duration: Duration the animation will run in milliseconds. Defaults to 500 ms.<EOL> *<EOL> * Returns an [AnimationTriggerMetadata] object with states for a boolean trigger based jello animation.<EOL> *<EOL> * usage: [@myAnchorName]=\"true|false\"<EOL> */<EOL>export function TdJelloAnimation(jelloOptions: IAnimationOptions = {}): AnimationTriggerMetadata {<EOL>    return trigger(jelloOptions.anchor || '<STR_LIT>', [<EOL>        state('<STR_LIT>', style({<EOL>            transform: '<STR_LIT>',<EOL>        })),<EOL>","gt":"state('<STR_LIT>', style({"}
{"input":"<s> /**<EOL> * Function TdJelloAnimation<EOL> *<EOL> * params:<EOL> * * anchor: Name of the anchor that will attach to a dom element in the components template that will contain the animation.<EOL> * * duration: Duration the animation will run in milliseconds. Defaults to 500 ms.<EOL> *<EOL> * Returns an [AnimationTriggerMetadata] object with states for a boolean trigger based jello animation.<EOL> *<EOL> * usage: [@myAnchorName]=\"true|false\"<EOL> */<EOL>export function TdJelloAnimation(jelloOptions: IAnimationOptions = {}): AnimationTriggerMetadata {<EOL>    return trigger(jelloOptions.anchor || '<STR_LIT>', [<EOL>        state('<STR_LIT>', style({<EOL>            transform: '<STR_LIT>',<EOL>        })),<EOL>        state('<STR_LIT>', style({<EOL>            transform: '<STR_LIT>',<EOL>        })),<EOL>        transition(","gt":"'<STR_LIT>', ["}
{"input":"<s> /**<EOL> * Function TdJelloAnimation<EOL> *<EOL> * params:<EOL> * * anchor: Name of the anchor that will attach to a dom element in the components template that will contain the animation.<EOL> * * duration: Duration the animation will run in milliseconds. Defaults to 500 ms.<EOL> *<EOL> * Returns an [AnimationTriggerMetadata] object with states for a boolean trigger based jello animation.<EOL> *<EOL> * usage: [@myAnchorName]=\"true|false\"<EOL> */<EOL>export function TdJelloAnimation(jelloOptions: IAnimationOptions = {}): AnimationTriggerMetadata {<EOL>    return trigger(jelloOptions.anchor || '<STR_LIT>', [<EOL>        state('<STR_LIT>', style({<EOL>            transform: '<STR_LIT>',<EOL>        })),<EOL>        state('<STR_LIT>', style({<EOL>            transform: '<STR_LIT>',<EOL>        })),<EOL>        transition('<STR_LIT>', [<EOL>            group([<EOL>                query('<STR_LIT>', animateChild(), { optional: true }),<EOL>                animate((jelloOptions.duration || <NUM_LIT>) + '<STR_LIT>' + (jelloOptions.delay || <NUM_LIT>) + '<STR_LIT>', keyframes([<EOL>                    style({ transform: '<STR_LIT>', offset: <NUM_LIT> }),<EOL>                    style({","gt":"transform: '<STR_LIT>', offset: <NUM_LIT> }),"}
{"input":"<s> /**<EOL> * Function TdJelloAnimation<EOL> *<EOL> * params:<EOL> * * anchor: Name of the anchor that will attach to a dom element in the components template that will contain the animation.<EOL> * * duration: Duration the animation will run in milliseconds. Defaults to 500 ms.<EOL> *<EOL> * Returns an [AnimationTriggerMetadata] object with states for a boolean trigger based jello animation.<EOL> *<EOL> * usage: [@myAnchorName]=\"true|false\"<EOL> */<EOL>export function TdJelloAnimation(jelloOptions: IAnimationOptions = {}): AnimationTriggerMetadata {<EOL>    return trigger(jelloOptions.anchor || '<STR_LIT>', [<EOL>        state('<STR_LIT>', style({<EOL>            transform: '<STR_LIT>',<EOL>        })),<EOL>        state('<STR_LIT>', style({<EOL>            transform: '<STR_LIT>',<EOL>        })),<EOL>        transition('<STR_LIT>', [<EOL>            group([<EOL>                query('<STR_LIT>', animateChild(), { optional: true }),<EOL>                animate((jelloOptions.duration || <NUM_LIT>) + '<STR_LIT>' + (jelloOptions.delay || <NUM_LIT>) + '<STR_LIT>', keyframes([<EOL>                    style({ transform: '<STR_LIT>', offset: <NUM_LIT> }),<EOL>                    style({ transform: '<STR_LIT>', offset: <NUM_LIT> }),<EOL>                    style({ transform: '<STR_LIT>', offset: <NUM_LIT> }),<EOL>                    style({ transform: '<STR_LIT>', offset: <NUM_LIT> }),<EOL>                    style({ transform: '<STR_LIT>', offset: <NUM_LIT> }),<EOL>                    style({ transform: '<STR_LIT>', offset: <NUM_LIT> }),<EOL>                    style({ transform: '<STR_LIT>', offset: <NUM_LIT> }),<EOL>                    style({ transform: '<STR_LIT>', offset:","gt":"<NUM_LIT> }),"}
{"input":"<s> export function getNgModules(context: BuildContext, types: string[]): Promise<GlobResult[]> {<EOL>    const ngModuleSuffix =","gt":"getStringPropertyValue(Constants.ENV_NG_MODULE_FILE_NAME_SUFFIX);"}
{"input":"<s> async function broadcastToFollowers(data: any, byActor: ActorModel, toActorFollowers: ActorModel[], t: Transaction, actorsException: ActorModel[] = []) {<EOL>    const uris = await","gt":"computeFollowerUris(toActorFollowers, actorsException, t);"}
{"input":"<s> export function printFullRow(row, drawRowHooks, drawCellHooks) {<EOL>    let remainingRowHeight = <NUM_LIT>;<EOL>    let remainingTexts = {};<EOL>    let table =","gt":"Config.tableInstance();"}
{"input":"<s> export function printFullRow(row, drawRowHooks, drawCellHooks) {<EOL>    let remainingRowHeight = <NUM_LIT>;<EOL>    let remainingTexts = {};<EOL>    let table = Config.tableInstance();<EOL>    if (!canFitOnPage(row.height)) {<EOL>","gt":"if (row.maxLineCount <= <NUM_LIT>) {"}
{"input":"<s> export function printFullRow(row, drawRowHooks, drawCellHooks) {<EOL>    let remainingRowHeight = <NUM_LIT>;<EOL>    let remainingTexts = {};<EOL>    let table = Config.tableInstance();<EOL>    if (!canFitOnPage(row.height)) {<EOL>        if (row.maxLineCount <= <NUM_LIT>) {<EOL>            addPage();<EOL>        }<EOL>        else {<EOL>            <EOL>            row.spansMultiplePages = true;<EOL>            let pageHeight = table.","gt":"doc.internal.pageSize.height;"}
{"input":"<s> export function printFullRow(row, drawRowHooks, drawCellHooks) {<EOL>    let remainingRowHeight = <NUM_LIT>;<EOL>    let remainingTexts = {};<EOL>    let table = Config.tableInstance();<EOL>    if (!canFitOnPage(row.height)) {<EOL>        if (row.maxLineCount <= <NUM_LIT>) {<EOL>            addPage();<EOL>        }<EOL>        else {<EOL>            <EOL>            row.spansMultiplePages = true;<EOL>            let pageHeight = table.doc.internal.pageSize.height;<EOL>            let maxCellHeight = <NUM_LIT>;<EOL>            for (let j = <NUM_LIT>; j < table.columns.length; j++) {<EOL>                let col = table.columns[j];<EOL>                let cell = row.cells[col.dataKey];<EOL>                let fontHeight = cell.styles.fontSize / Config.scaleFactor() * FONT_ROW_RATIO;<EOL>","gt":"let vPadding = cell.padding('<STR_LIT>');"}
{"input":"<s> export function printFullRow(row, drawRowHooks, drawCellHooks) {<EOL>    let remainingRowHeight = <NUM_LIT>;<EOL>    let remainingTexts = {};<EOL>    let table = Config.tableInstance();<EOL>    if (!canFitOnPage(row.height)) {<EOL>        if (row.maxLineCount <= <NUM_LIT>) {<EOL>            addPage();<EOL>        }<EOL>        else {<EOL>            <EOL>            row.spansMultiplePages = true;<EOL>            let pageHeight = table.doc.internal.pageSize.height;<EOL>            let maxCellHeight = <NUM_LIT>;<EOL>            for (let j = <NUM_LIT>; j < table.columns.length; j++) {<EOL>                let col = table.columns[j];<EOL>                let cell = row.cells[col.dataKey];<EOL>                let fontHeight = cell.styles.fontSize / Config.scaleFactor() * FONT_ROW_RATIO;<EOL>                let vPadding = cell.padding('<STR_LIT>');<EOL>                let remainingPageSpace = pageHeight - table.cursor.y - table.margin('<STR_LIT>');<EOL>                let remainingLineCount = Math.floor((remainingPageSpace - vPadding) / fontHeight);<EOL>                <EOL>                <EOL>                if (remainingLineCount < <NUM_LIT>) {<EOL>","gt":"remainingLineCount = <NUM_LIT>;"}
{"input":"<s> export function printFullRow(row, drawRowHooks, drawCellHooks) {<EOL>    let remainingRowHeight = <NUM_LIT>;<EOL>    let remainingTexts = {};<EOL>    let table = Config.tableInstance();<EOL>    if (!canFitOnPage(row.height)) {<EOL>        if (row.maxLineCount <= <NUM_LIT>) {<EOL>            addPage();<EOL>        }<EOL>        else {<EOL>            <EOL>            row.spansMultiplePages = true;<EOL>            let pageHeight = table.doc.internal.pageSize.height;<EOL>            let maxCellHeight = <NUM_LIT>;<EOL>            for (let j = <NUM_LIT>; j < table.columns.length; j++) {<EOL>                let col = table.columns[j];<EOL>                let cell = row.cells[col.dataKey];<EOL>                let fontHeight = cell.styles.fontSize / Config.scaleFactor() * FONT_ROW_RATIO;<EOL>                let vPadding = cell.padding('<STR_LIT>');<EOL>                let remainingPageSpace = pageHeight - table.cursor.y - table.margin('<STR_LIT>');<EOL>                let remainingLineCount = Math.floor((remainingPageSpace - vPadding) / fontHeight);<EOL>                <EOL>                <EOL>                if (remainingLineCount < <NUM_LIT>) {<EOL>                    remainingLineCount = <NUM_LIT>;<EOL>                }<EOL>                if (Array.isArray(cell.text) && cell.text.length > remainingLineCount) {<EOL>                    let remainingLines = cell.text.splice(remainingLineCount, cell.text.length);<EOL>                    remainingTexts[col.dataKey] = remainingLines;<EOL>                    let cellHeight = cell.text.length * fontHeight + vPadding;<EOL>                    if (cellHeight > maxCellHeight) {<EOL>","gt":"maxCellHeight = cellHeight;"}
{"input":"<s> export function printFullRow(row, drawRowHooks, drawCellHooks) {<EOL>    let remainingRowHeight = <NUM_LIT>;<EOL>    let remainingTexts = {};<EOL>    let table = Config.tableInstance();<EOL>    if (!canFitOnPage(row.height)) {<EOL>        if (row.maxLineCount <= <NUM_LIT>) {<EOL>            addPage();<EOL>        }<EOL>        else {<EOL>            <EOL>            row.spansMultiplePages = true;<EOL>            let pageHeight = table.doc.internal.pageSize.height;<EOL>            let maxCellHeight = <NUM_LIT>;<EOL>            for (let j = <NUM_LIT>; j < table.columns.length; j++) {<EOL>                let col = table.columns[j];<EOL>                let cell = row.cells[col.dataKey];<EOL>                let fontHeight = cell.styles.fontSize / Config.scaleFactor() * FONT_ROW_RATIO;<EOL>                let vPadding = cell.padding('<STR_LIT>');<EOL>                let remainingPageSpace = pageHeight - table.cursor.y - table.margin('<STR_LIT>');<EOL>                let remainingLineCount = Math.floor((remainingPageSpace - vPadding) / fontHeight);<EOL>                <EOL>                <EOL>                if (remainingLineCount < <NUM_LIT>) {<EOL>                    remainingLineCount = <NUM_LIT>;<EOL>                }<EOL>                if (Array.isArray(cell.text) && cell.text.length > remainingLineCount) {<EOL>                    let remainingLines = cell.text.splice(remainingLineCount, cell.text.length);<EOL>                    remainingTexts[col.dataKey] = remainingLines;<EOL>                    let cellHeight = cell.text.length * fontHeight + vPadding;<EOL>                    if (cellHeight > maxCellHeight) {<EOL>                        maxCellHeight = cellHeight;<EOL>                    }<EOL>                    let rCellHeight = remainingLines.length * fontHeight + vPadding;<EOL>                    if (","gt":"rCellHeight > remainingRowHeight) {"}
{"input":"<s> export function printFullRow(row, drawRowHooks, drawCellHooks) {<EOL>    let remainingRowHeight = <NUM_LIT>;<EOL>    let remainingTexts = {};<EOL>    let table = Config.tableInstance();<EOL>    if (!canFitOnPage(row.height)) {<EOL>        if (row.maxLineCount <= <NUM_LIT>) {<EOL>            addPage();<EOL>        }<EOL>        else {<EOL>            <EOL>            row.spansMultiplePages = true;<EOL>            let pageHeight = table.doc.internal.pageSize.height;<EOL>            let maxCellHeight = <NUM_LIT>;<EOL>            for (let j = <NUM_LIT>; j < table.columns.length; j++) {<EOL>                let col = table.columns[j];<EOL>                let cell = row.cells[col.dataKey];<EOL>                let fontHeight = cell.styles.fontSize / Config.scaleFactor() * FONT_ROW_RATIO;<EOL>                let vPadding = cell.padding('<STR_LIT>');<EOL>                let remainingPageSpace = pageHeight - table.cursor.y - table.margin('<STR_LIT>');<EOL>                let remainingLineCount = Math.floor((remainingPageSpace - vPadding) / fontHeight);<EOL>                <EOL>                <EOL>                if (remainingLineCount < <NUM_LIT>) {<EOL>                    remainingLineCount = <NUM_LIT>;<EOL>                }<EOL>                if (Array.isArray(cell.text) && cell.text.length > remainingLineCount) {<EOL>                    let remainingLines = cell.text.splice(remainingLineCount, cell.text.length);<EOL>                    remainingTexts[col.dataKey] = remainingLines;<EOL>                    let cellHeight = cell.text.length * fontHeight + vPadding;<EOL>                    if (cellHeight > maxCellHeight) {<EOL>                        maxCellHeight = cellHeight;<EOL>                    }<EOL>                    let rCellHeight = remainingLines.length * fontHeight + vPadding;<EOL>                    if (rCellHeight > remainingRowHeight) {<EOL>                        remainingRowHeight = rCellHeight;<EOL>                    }<EOL>                }<EOL>            }<EOL>            <EOL>            row.height = maxCellHeight;<EOL>        }<EOL>    }<EOL>    printRow(","gt":"row, drawRowHooks, drawCellHooks);"}
{"input":"<s> export function printFullRow(row, drawRowHooks, drawCellHooks) {<EOL>    let remainingRowHeight = <NUM_LIT>;<EOL>    let remainingTexts = {};<EOL>    let table = Config.tableInstance();<EOL>    if (!canFitOnPage(row.height)) {<EOL>        if (row.maxLineCount <= <NUM_LIT>) {<EOL>            addPage();<EOL>        }<EOL>        else {<EOL>            <EOL>            row.spansMultiplePages = true;<EOL>            let pageHeight = table.doc.internal.pageSize.height;<EOL>            let maxCellHeight = <NUM_LIT>;<EOL>            for (let j = <NUM_LIT>; j < table.columns.length; j++) {<EOL>                let col = table.columns[j];<EOL>                let cell = row.cells[col.dataKey];<EOL>                let fontHeight = cell.styles.fontSize / Config.scaleFactor() * FONT_ROW_RATIO;<EOL>                let vPadding = cell.padding('<STR_LIT>');<EOL>                let remainingPageSpace = pageHeight - table.cursor.y - table.margin('<STR_LIT>');<EOL>                let remainingLineCount = Math.floor((remainingPageSpace - vPadding) / fontHeight);<EOL>                <EOL>                <EOL>                if (remainingLineCount < <NUM_LIT>) {<EOL>                    remainingLineCount = <NUM_LIT>;<EOL>                }<EOL>                if (Array.isArray(cell.text) && cell.text.length > remainingLineCount) {<EOL>                    let remainingLines = cell.text.splice(remainingLineCount, cell.text.length);<EOL>                    remainingTexts[col.dataKey] = remainingLines;<EOL>                    let cellHeight = cell.text.length * fontHeight + vPadding;<EOL>                    if (cellHeight > maxCellHeight) {<EOL>                        maxCellHeight = cellHeight;<EOL>                    }<EOL>                    let rCellHeight = remainingLines.length * fontHeight + vPadding;<EOL>                    if (rCellHeight > remainingRowHeight) {<EOL>                        remainingRowHeight = rCellHeight;<EOL>                    }<EOL>                }<EOL>            }<EOL>            <EOL>            row.height = maxCellHeight;<EOL>        }<EOL>    }<EOL>    printRow(row, drawRowHooks, drawCellHooks);<EOL>    <EOL>    <EOL>    if (Object.keys(remainingTexts).length > <NUM_LIT>) {<EOL>        for (let j = <NUM_LIT>; j < table.","gt":"columns.length; j++) {"}
{"input":"<s> export function printFullRow(row, drawRowHooks, drawCellHooks) {<EOL>    let remainingRowHeight = <NUM_LIT>;<EOL>    let remainingTexts = {};<EOL>    let table = Config.tableInstance();<EOL>    if (!canFitOnPage(row.height)) {<EOL>        if (row.maxLineCount <= <NUM_LIT>) {<EOL>            addPage();<EOL>        }<EOL>        else {<EOL>            <EOL>            row.spansMultiplePages = true;<EOL>            let pageHeight = table.doc.internal.pageSize.height;<EOL>            let maxCellHeight = <NUM_LIT>;<EOL>            for (let j = <NUM_LIT>; j < table.columns.length; j++) {<EOL>                let col = table.columns[j];<EOL>                let cell = row.cells[col.dataKey];<EOL>                let fontHeight = cell.styles.fontSize / Config.scaleFactor() * FONT_ROW_RATIO;<EOL>                let vPadding = cell.padding('<STR_LIT>');<EOL>                let remainingPageSpace = pageHeight - table.cursor.y - table.margin('<STR_LIT>');<EOL>                let remainingLineCount = Math.floor((remainingPageSpace - vPadding) / fontHeight);<EOL>                <EOL>                <EOL>                if (remainingLineCount < <NUM_LIT>) {<EOL>                    remainingLineCount = <NUM_LIT>;<EOL>                }<EOL>                if (Array.isArray(cell.text) && cell.text.length > remainingLineCount) {<EOL>                    let remainingLines = cell.text.splice(remainingLineCount, cell.text.length);<EOL>                    remainingTexts[col.dataKey] = remainingLines;<EOL>                    let cellHeight = cell.text.length * fontHeight + vPadding;<EOL>                    if (cellHeight > maxCellHeight) {<EOL>                        maxCellHeight = cellHeight;<EOL>                    }<EOL>                    let rCellHeight = remainingLines.length * fontHeight + vPadding;<EOL>                    if (rCellHeight > remainingRowHeight) {<EOL>                        remainingRowHeight = rCellHeight;<EOL>                    }<EOL>                }<EOL>            }<EOL>            <EOL>            row.height = maxCellHeight;<EOL>        }<EOL>    }<EOL>    printRow(row, drawRowHooks, drawCellHooks);<EOL>    <EOL>    <EOL>    if (Object.keys(remainingTexts).length > <NUM_LIT>) {<EOL>        for (let j = <NUM_LIT>; j < table.columns.length; j++) {<EOL>            let col = table.columns[j];<EOL>            let cell = row.cells[col.dataKey];<EOL>            cell.text =","gt":"remainingTexts[col.dataKey] || '<STR_LIT>';"}
{"input":"<s> async function isTherePendingRequests(servers: ServerInfo[]) {<EOL>    const states: JobState[] = ['<STR_LIT>', '<STR_LIT>', '<STR_LIT>'];<EOL>    const tasks: Promise<any>[] = [];<EOL>    let pendingRequests = false;<EOL>    <EOL>","gt":"for (const server of servers) {"}
{"input":"<s> async function isTherePendingRequests(servers: ServerInfo[]) {<EOL>    const states: JobState[] = ['<STR_LIT>', '<STR_LIT>', '<STR_LIT>'];<EOL>    const tasks: Promise<any>[] = [];<EOL>    let pendingRequests = false;<EOL>    <EOL>    for (const server of servers) {<EOL>        for (const state of states) {<EOL>            const p = getJobsListPaginationAndSort(server.url, server.accessToken, state, <NUM_LIT>, <NUM_LIT>, '<STR_LIT>')<EOL>                .then(res => {<EOL>                if (res.","gt":"body.total > <NUM_LIT>)"}
{"input":"<s> function setIndex(args: any[], opts: any = {}, resolve?: Function, reject?: Function): any {<EOL>    <EOL>    if (opts.sync) {<EOL>        return","gt":"args;"}
{"input":"<s> function setIndex(args: any[], opts: any = {}, resolve?: Function, reject?: Function): any {<EOL>    <EOL>    if (opts.sync) {<EOL>        return args;<EOL>    }<EOL>    <EOL>    if (opts.callbackOrder === '<STR_LIT>') {<EOL>        <EOL>","gt":"args.unshift(reject);"}
{"input":"<s> function setIndex(args: any[], opts: any = {}, resolve?: Function, reject?: Function): any {<EOL>    <EOL>    if (opts.sync) {<EOL>        return args;<EOL>    }<EOL>    <EOL>    if (opts.callbackOrder === '<STR_LIT>') {<EOL>        <EOL>        args.unshift(reject);<EOL>        args.unshift(resolve);<EOL>    }<EOL>    else if (opts.callbackStyle === '<STR_LIT>') {<EOL>","gt":"args.push((err: any, result: any) => {"}
{"input":"<s> function setIndex(args: any[], opts: any = {}, resolve?: Function, reject?: Function): any {<EOL>    <EOL>    if (opts.sync) {<EOL>        return args;<EOL>    }<EOL>    <EOL>    if (opts.callbackOrder === '<STR_LIT>') {<EOL>        <EOL>        args.unshift(reject);<EOL>        args.unshift(resolve);<EOL>    }<EOL>    else if (opts.callbackStyle === '<STR_LIT>') {<EOL>        args.push((err: any, result: any) => {<EOL>            if (err) {<EOL>                reject(err);<EOL>            }<EOL>            else {<EOL>                resolve(result);<EOL>            }<EOL>        });<EOL>    }<EOL>    else if (opts.callbackStyle === '<STR_LIT>' && opts.successName && opts.errorName) {<EOL>        let obj: any = {};<EOL>        obj[opts.successName] = resolve;<EOL>        obj[opts.errorName] = reject;<EOL>        args.push(obj);<EOL>    }<EOL>    else if (typeof opts.successIndex !== '<STR_LIT>' || typeof opts.errorIndex !== '<STR_LIT>') {<EOL>        const setSuccessIndex = () => {<EOL>            <EOL>            if (opts.successIndex > args.length) {<EOL>                args[opts.successIndex] = resolve;<EOL>            }<EOL>            else {<EOL>                args.splice(opts.successIndex, <NUM_LIT>, resolve);<EOL>            }<EOL>        };<EOL>","gt":"const setErrorIndex = () => {"}
{"input":"<s> function setIndex(args: any[], opts: any = {}, resolve?: Function, reject?: Function): any {<EOL>    <EOL>    if (opts.sync) {<EOL>        return args;<EOL>    }<EOL>    <EOL>    if (opts.callbackOrder === '<STR_LIT>') {<EOL>        <EOL>        args.unshift(reject);<EOL>        args.unshift(resolve);<EOL>    }<EOL>    else if (opts.callbackStyle === '<STR_LIT>') {<EOL>        args.push((err: any, result: any) => {<EOL>            if (err) {<EOL>                reject(err);<EOL>            }<EOL>            else {<EOL>                resolve(result);<EOL>            }<EOL>        });<EOL>    }<EOL>    else if (opts.callbackStyle === '<STR_LIT>' && opts.successName && opts.errorName) {<EOL>        let obj: any = {};<EOL>        obj[opts.successName] = resolve;<EOL>        obj[opts.errorName] = reject;<EOL>        args.push(obj);<EOL>    }<EOL>    else if (typeof opts.successIndex !== '<STR_LIT>' || typeof opts.errorIndex !== '<STR_LIT>') {<EOL>        const setSuccessIndex = () => {<EOL>            <EOL>            if (opts.successIndex > args.length) {<EOL>                args[opts.successIndex] = resolve;<EOL>            }<EOL>            else {<EOL>                args.splice(opts.successIndex, <NUM_LIT>, resolve);<EOL>            }<EOL>        };<EOL>        const setErrorIndex = () => {<EOL>            <EOL>            if (","gt":"opts.errorIndex > args.length) {"}
{"input":"<s> function setIndex(args: any[], opts: any = {}, resolve?: Function, reject?: Function): any {<EOL>    <EOL>    if (opts.sync) {<EOL>        return args;<EOL>    }<EOL>    <EOL>    if (opts.callbackOrder === '<STR_LIT>') {<EOL>        <EOL>        args.unshift(reject);<EOL>        args.unshift(resolve);<EOL>    }<EOL>    else if (opts.callbackStyle === '<STR_LIT>') {<EOL>        args.push((err: any, result: any) => {<EOL>            if (err) {<EOL>                reject(err);<EOL>            }<EOL>            else {<EOL>                resolve(result);<EOL>            }<EOL>        });<EOL>    }<EOL>    else if (opts.callbackStyle === '<STR_LIT>' && opts.successName && opts.errorName) {<EOL>        let obj: any = {};<EOL>        obj[opts.successName] = resolve;<EOL>        obj[opts.errorName] = reject;<EOL>        args.push(obj);<EOL>    }<EOL>    else if (typeof opts.successIndex !== '<STR_LIT>' || typeof opts.errorIndex !== '<STR_LIT>') {<EOL>        const setSuccessIndex = () => {<EOL>            <EOL>            if (opts.successIndex > args.length) {<EOL>                args[opts.successIndex] = resolve;<EOL>            }<EOL>            else {<EOL>                args.splice(opts.successIndex, <NUM_LIT>, resolve);<EOL>            }<EOL>        };<EOL>        const setErrorIndex = () => {<EOL>            <EOL>            if (opts.errorIndex > args.length) {<EOL>                args[opts.errorIndex] = reject; <EOL>            }<EOL>            else {<EOL>                args.splice(opts.errorIndex, <NUM_LIT>, reject); <EOL>            }<EOL>        };<EOL>        if (opts.successIndex >","gt":"opts.errorIndex) {"}
{"input":"<s> function setIndex(args: any[], opts: any = {}, resolve?: Function, reject?: Function): any {<EOL>    <EOL>    if (opts.sync) {<EOL>        return args;<EOL>    }<EOL>    <EOL>    if (opts.callbackOrder === '<STR_LIT>') {<EOL>        <EOL>        args.unshift(reject);<EOL>        args.unshift(resolve);<EOL>    }<EOL>    else if (opts.callbackStyle === '<STR_LIT>') {<EOL>        args.push((err: any, result: any) => {<EOL>            if (err) {<EOL>                reject(err);<EOL>            }<EOL>            else {<EOL>                resolve(result);<EOL>            }<EOL>        });<EOL>    }<EOL>    else if (opts.callbackStyle === '<STR_LIT>' && opts.successName && opts.errorName) {<EOL>        let obj: any = {};<EOL>        obj[opts.successName] = resolve;<EOL>        obj[opts.errorName] = reject;<EOL>        args.push(obj);<EOL>    }<EOL>    else if (typeof opts.successIndex !== '<STR_LIT>' || typeof opts.errorIndex !== '<STR_LIT>') {<EOL>        const setSuccessIndex = () => {<EOL>            <EOL>            if (opts.successIndex > args.length) {<EOL>                args[opts.successIndex] = resolve;<EOL>            }<EOL>            else {<EOL>                args.splice(opts.successIndex, <NUM_LIT>, resolve);<EOL>            }<EOL>        };<EOL>        const setErrorIndex = () => {<EOL>            <EOL>            if (opts.errorIndex > args.length) {<EOL>                args[opts.errorIndex] = reject; <EOL>            }<EOL>            else {<EOL>                args.splice(opts.errorIndex, <NUM_LIT>, reject); <EOL>            }<EOL>        };<EOL>        if (opts.successIndex > opts.errorIndex) {<EOL>            setErrorIndex();<EOL>            setSuccessIndex();<EOL>        }<EOL>        else {<EOL>","gt":"setSuccessIndex();"}
{"input":"<s> export function normalizeUrl(browserUrl: string): string {<EOL>    browserUrl = browserUrl.trim();<EOL>    if (browserUrl.charAt(<NUM_LIT>) !== '<STR_LIT>') {<EOL>        <EOL>        browserUrl =","gt":"'<STR_LIT>' + browserUrl;"}
{"input":"<s> export function normalizeUrl(browserUrl: string): string {<EOL>    browserUrl = browserUrl.trim();<EOL>    if (browserUrl.charAt(<NUM_LIT>) !== '<STR_LIT>') {<EOL>        <EOL>        browserUrl = '<STR_LIT>' + browserUrl;<EOL>    }<EOL>    if (browserUrl.length > <NUM_LIT> && browserUrl.charAt(browserUrl.length - <NUM_LIT>) === '<STR_LIT>') {<EOL>        <EOL>        browserUrl = browserUrl.substr(<NUM_LIT>, browserUrl.","gt":"length - <NUM_LIT>);"}
{"input":"<s> function splitAndMerge(array: number[], lower: int, upper: int, sorted: number[]) {<EOL>    \"<STR_LIT>\";<EOL>    if (upper - lower < <NUM_LIT>) {<EOL>","gt":"return;"}
{"input":"<s> function getAccount(url: string, accountId: number | string, statusCodeExpected = <NUM_LIT>) {<EOL>    const path = '<STR_LIT>' + accountId;<EOL>    return","gt":"makeGetRequest({"}
{"input":"<s> function isMeaningfulLine(line: string) {<EOL>    if (line) {<EOL>        line = line.trim();<EOL>        if (line.","gt":"length) {"}
{"input":"<s> <EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL>export function persistObject(target: any, schema: any) {<EOL>    const model = createModel(","gt":"schema);"}
{"input":"<s> <EOL>function objectToFormData(obj: any, form?: FormData, namespace?: string) {<EOL>    let fd = form || new FormData();<EOL>    let formKey;<EOL>    for (let key of Object.keys(obj)) {<EOL>        if (namespace)<EOL>            formKey = `<STR_LIT>`;<EOL>","gt":"else"}
{"input":"<s> <EOL>function objectToFormData(obj: any, form?: FormData, namespace?: string) {<EOL>    let fd = form || new FormData();<EOL>    let formKey;<EOL>    for (let key of Object.keys(obj)) {<EOL>        if (namespace)<EOL>            formKey = `<STR_LIT>`;<EOL>        else<EOL>            formKey = key;<EOL>        if (obj[key] === undefined)<EOL>            continue;<EOL>        if (typeof obj[key] === '<STR_LIT>' && !(obj[key] instanceof","gt":"File)) {"}
{"input":"<s> <EOL>function objectToFormData(obj: any, form?: FormData, namespace?: string) {<EOL>    let fd = form || new FormData();<EOL>    let formKey;<EOL>    for (let key of Object.keys(obj)) {<EOL>        if (namespace)<EOL>            formKey = `<STR_LIT>`;<EOL>        else<EOL>            formKey = key;<EOL>        if (obj[key] === undefined)<EOL>            continue;<EOL>        if (typeof obj[key] === '<STR_LIT>' && !(obj[key] instanceof File)) {<EOL>            objectToFormData(obj[key], fd, key);<EOL>        }<EOL>","gt":"else {"}
{"input":"<s> function foo3({ skills = { primary: \"<STR_LIT>\", secondary: \"<STR_LIT>\" } }: Robot = robotA) {<EOL>    console.log(skills.","gt":"primary);"}
{"input":"<s> <EOL>async function usersExist() {<EOL>    const totalUsers = await UserModel.","gt":"countTotal();"}
{"input":"<s> export function normalizePath(str: string) {<EOL>    <EOL>    <EOL>    <EOL>    if (typeof str !== '<STR_LIT>') {<EOL>        throw","gt":"new Error(`<STR_LIT>`);"}
{"input":"<s> export function normalizePath(str: string) {<EOL>    <EOL>    <EOL>    <EOL>    if (typeof str !== '<STR_LIT>') {<EOL>        throw new Error(`<STR_LIT>`);<EOL>    }<EOL>    str = str.trim();<EOL>    if (EXTENDED_PATH_REGEX.test(str) || NON_ASCII_REGEX.test(","gt":"str)) {"}
{"input":"<s> export function normalizePath(str: string) {<EOL>    <EOL>    <EOL>    <EOL>    if (typeof str !== '<STR_LIT>') {<EOL>        throw new Error(`<STR_LIT>`);<EOL>    }<EOL>    str = str.trim();<EOL>    if (EXTENDED_PATH_REGEX.test(str) || NON_ASCII_REGEX.test(str)) {<EOL>        return str;<EOL>    }<EOL>    str = str.replace(","gt":"SLASH_REGEX, '<STR_LIT>');"}
{"input":"<s> export function normalizePath(str: string) {<EOL>    <EOL>    <EOL>    <EOL>    if (typeof str !== '<STR_LIT>') {<EOL>        throw new Error(`<STR_LIT>`);<EOL>    }<EOL>    str = str.trim();<EOL>    if (EXTENDED_PATH_REGEX.test(str) || NON_ASCII_REGEX.test(str)) {<EOL>        return str;<EOL>    }<EOL>    str = str.replace(SLASH_REGEX, '<STR_LIT>');<EOL>    <EOL>    <EOL>","gt":"if (str.charAt(str.length - <NUM_LIT>) === '<STR_LIT>') {"}
{"input":"<s> function down(options) {<EOL>","gt":"throw new Error('<STR_LIT>');"}
{"input":"<s> function lineFeedToHtml(obj: object, keyToNormalize: string) {<EOL>    return immutableAssign(","gt":"obj, {"}
{"input":"<s> async function getUserVideoQuotaUsed(req: express.Request, res: express.Response, next: express.NextFunction) {<EOL>    <EOL>    const user = await UserModel.loadByUsernameAndPopulateChannels(res.locals.oauth.","gt":"token.user.username);"}
{"input":"<s> function getVideoViewActivityPubUrl(byActor: ActorModel, video: VideoModel) {<EOL>    return video.url + '<STR_LIT>' + byActor.uuid + '<STR_LIT>' +","gt":"new Date().toISOString();"}
{"input":"<s> function swap(array: number[], i1: int, i2: int) {<EOL>    \"<STR_LIT>\";<EOL>    const tmp =","gt":"array[i1];"}
{"input":"<s> async function listUsers(req: express.Request, res: express.Response, next: express.NextFunction) {<EOL>    const resultList = await UserModel.listForApi(req.query.start, req.query.","gt":"count, req.query.sort);"}
{"input":"<s> async function searchVideos(req: express.Request, res: express.Response, next: express.NextFunction) {<EOL>    const","gt":"resultList = await VideoModel.searchAndPopulateAccountAndServerAndTags(req.query.search, req.query.start, req.query.count, req.query.sort);"}
{"input":"<s> function getModule() {<EOL>    if (!module) {<EOL>        require([\"<STR_LIT>\"], (","gt":"m: typeof _CommandingSurface) => {"}
{"input":"<s> function down(options) {<EOL>","gt":"throw new Error('<STR_LIT>');"}
{"input":"<s> async function arraySpliceWithDeleteCount(array: int[], start: int, deleteCount: int) {<EOL>","gt":"\"<STR_LIT>\";"}
{"input":"<s> async function sendCreateVideoCommentToVideoFollowers(comment: VideoCommentModel, t: Transaction) {<EOL>    const byActor = comment.Account.Actor;<EOL>    const threadParentComments = await VideoCommentModel.listThreadParentComments(comment, t);<EOL>    const commentObject = comment.toActivityPubObject(threadParentComments);<EOL>    const actorsInvolvedInComment = await getActorsInvolvedInVideo(comment.Video, t);<EOL>","gt":"actorsInvolvedInComment.push(byActor);"}
{"input":"<s> export function formatComponentConstructorEvents(eventsMeta: EventMeta[]) {<EOL>    if (!eventsMeta || !eventsMeta.length) {<EOL>        return","gt":"null;"}
{"input":"<s> async function checkUserNameOrEmailDoesNotAlreadyExist(username: string, email: string, res: express.Response) {<EOL>    const user = await UserModel.loadByUsernameOrEmail(username, email);<EOL>    if (user) {<EOL>        res.","gt":"status(<NUM_LIT>)"}
{"input":"<s> export async function nonPageFileManipulation(context: BuildContext, name: string, ngModulePath: string, type: string) {<EOL>    const hydratedRequest = hydrateRequest(context, { type, name });<EOL>    const envVar = getStringPropertyValue(`<STR_LIT>`);<EOL>    let importPath;<EOL>    let fileContent: string;<EOL>    let","gt":"templatesArray: string[] = await generateTemplates(context, hydratedRequest, false);"}
{"input":"<s> export async function nonPageFileManipulation(context: BuildContext, name: string, ngModulePath: string, type: string) {<EOL>    const hydratedRequest = hydrateRequest(context, { type, name });<EOL>    const envVar = getStringPropertyValue(`<STR_LIT>`);<EOL>    let importPath;<EOL>    let fileContent: string;<EOL>    let templatesArray: string[] = await generateTemplates(context, hydratedRequest, false);<EOL>    if (hydratedRequest.type === '<STR_LIT>' || hydratedRequest.type === '<STR_LIT>' || hydratedRequest.type === '<STR_LIT>') {<EOL>        if (!existsSync(envVar))<EOL>","gt":"createCommonModule(envVar, hydratedRequest.type);"}
{"input":"<s> export async function nonPageFileManipulation(context: BuildContext, name: string, ngModulePath: string, type: string) {<EOL>    const hydratedRequest = hydrateRequest(context, { type, name });<EOL>    const envVar = getStringPropertyValue(`<STR_LIT>`);<EOL>    let importPath;<EOL>    let fileContent: string;<EOL>    let templatesArray: string[] = await generateTemplates(context, hydratedRequest, false);<EOL>    if (hydratedRequest.type === '<STR_LIT>' || hydratedRequest.type === '<STR_LIT>' || hydratedRequest.type === '<STR_LIT>') {<EOL>        if (!existsSync(envVar))<EOL>            createCommonModule(envVar, hydratedRequest.type);<EOL>    }<EOL>    const typescriptFilePath = changeExtension(templatesArray.filter(path => extname(path) === '<STR_LIT>')[<NUM_LIT>], '<STR_LIT>');<EOL>    readFileAsync(ngModulePath).then((","gt":"content) => {"}
{"input":"<s> export async function nonPageFileManipulation(context: BuildContext, name: string, ngModulePath: string, type: string) {<EOL>    const hydratedRequest = hydrateRequest(context, { type, name });<EOL>    const envVar = getStringPropertyValue(`<STR_LIT>`);<EOL>    let importPath;<EOL>    let fileContent: string;<EOL>    let templatesArray: string[] = await generateTemplates(context, hydratedRequest, false);<EOL>    if (hydratedRequest.type === '<STR_LIT>' || hydratedRequest.type === '<STR_LIT>' || hydratedRequest.type === '<STR_LIT>') {<EOL>        if (!existsSync(envVar))<EOL>            createCommonModule(envVar, hydratedRequest.type);<EOL>    }<EOL>    const typescriptFilePath = changeExtension(templatesArray.filter(path => extname(path) === '<STR_LIT>')[<NUM_LIT>], '<STR_LIT>');<EOL>    readFileAsync(ngModulePath).then((content) => {<EOL>        importPath = type === '<STR_LIT>' || type === '<STR_LIT>' || type === '<STR_LIT>'<EOL>            <EOL>            <EOL>            ? toUnixPath(`<STR_LIT>`)<EOL>            : toUnixPath(`<STR_LIT>`);<EOL>        content = insertNamedImportIfNeeded(ngModulePath, content, hydratedRequest.className, importPath);<EOL>        if (type === '<STR_LIT>' || type === '<STR_LIT>' || type === '<STR_LIT>') {<EOL>            content = appendNgModuleDeclaration(ngModulePath, content, hydratedRequest.className);<EOL>            content = appendNgModuleExports(ngModulePath, content, hydratedRequest.","gt":"className);"}
{"input":"<s> async function removeVideoComment(req: express.Request, res: express.Response) {<EOL>    const videoCommentInstance: VideoCommentModel = res.locals.videoComment;<EOL>    await","gt":"sequelizeTypescript.transaction(async (t) => {"}
{"input":"<s> <EOL>function processUndoLike(actorUrl: string, activity: ActivityUndo) {<EOL>    const options = {<EOL>        arguments: [","gt":"actorUrl, activity],"}
{"input":"<s> function checkUpdateActivity(activity: any) {<EOL>    return isVideoTorrentUpdateActivityValid(","gt":"activity) ||"}
{"input":"<s> function isFileValid(files: {<EOL>    [fieldname: string]: Express.Multer.File[];<EOL>} | Express.Multer.File[], mimeTypeRegex: string, field: string, optional = false) {<EOL>    <EOL>    if (!files)<EOL>        return optional;<EOL>    if (isArray(files))<EOL>","gt":"return optional;"}
{"input":"<s> function isFileValid(files: {<EOL>    [fieldname: string]: Express.Multer.File[];<EOL>} | Express.Multer.File[], mimeTypeRegex: string, field: string, optional = false) {<EOL>    <EOL>    if (!files)<EOL>        return optional;<EOL>    if (isArray(files))<EOL>        return optional;<EOL>    <EOL>    const fileArray = files[field];<EOL>    if (!fileArray || fileArray.length === <NUM_LIT>) {<EOL>        return","gt":"optional;"}
{"input":"<s> function isFileValid(files: {<EOL>    [fieldname: string]: Express.Multer.File[];<EOL>} | Express.Multer.File[], mimeTypeRegex: string, field: string, optional = false) {<EOL>    <EOL>    if (!files)<EOL>        return optional;<EOL>    if (isArray(files))<EOL>        return optional;<EOL>    <EOL>    const fileArray = files[field];<EOL>    if (!fileArray || fileArray.length === <NUM_LIT>) {<EOL>        return optional;<EOL>    }<EOL>    <EOL>    const","gt":"file = fileArray[<NUM_LIT>];"}
{"input":"<s> <EOL>async function processDeleteVideo(actor: ActorModel, videoToDelete: VideoModel) {<EOL>    const options = {<EOL>        arguments: [","gt":"actor, videoToDelete],"}
{"input":"<s> function euclideanDistance(x1: int, y1: int, x2: int, y2: int) {<EOL>","gt":"\"<STR_LIT>\";"}
{"input":"<s> export function setAccessor(plt: PlatformApi, elm: any, memberName: string, oldValue: any, newValue: any, isSvg: boolean, i?: any, ilen?: number) {<EOL>    if (memberName === '<STR_LIT>' && !isSvg) {<EOL>        <EOL>        if (oldValue !== newValue) {<EOL>            const oldList: string[] = (oldValue ==","gt":"null || oldValue === '<STR_LIT>') ? EMPTY_ARR : oldValue.trim().split(/\\s+/);"}
{"input":"<s> export function setAccessor(plt: PlatformApi, elm: any, memberName: string, oldValue: any, newValue: any, isSvg: boolean, i?: any, ilen?: number) {<EOL>    if (memberName === '<STR_LIT>' && !isSvg) {<EOL>        <EOL>        if (oldValue !== newValue) {<EOL>            const oldList: string[] = (oldValue == null || oldValue === '<STR_LIT>') ? EMPTY_ARR : oldValue.trim().split(/\\s+/);<EOL>            const newList: string[] = (newValue == null || newValue === '<STR_LIT>') ? EMPTY_ARR : newValue.trim().split(/\\s+/);<EOL>            let classList: string[] = (elm.className == null || elm.className === '<STR_LIT>') ? EMPTY_ARR : elm.className.trim().split(/\\s+/);<EOL>            for (i = <NUM_LIT>, ilen = oldList.length; i < ilen; i++) {<EOL>                if (","gt":"newList.indexOf(oldList[i]) === -<NUM_LIT>) {"}
{"input":"<s> export function setAccessor(plt: PlatformApi, elm: any, memberName: string, oldValue: any, newValue: any, isSvg: boolean, i?: any, ilen?: number) {<EOL>    if (memberName === '<STR_LIT>' && !isSvg) {<EOL>        <EOL>        if (oldValue !== newValue) {<EOL>            const oldList: string[] = (oldValue == null || oldValue === '<STR_LIT>') ? EMPTY_ARR : oldValue.trim().split(/\\s+/);<EOL>            const newList: string[] = (newValue == null || newValue === '<STR_LIT>') ? EMPTY_ARR : newValue.trim().split(/\\s+/);<EOL>            let classList: string[] = (elm.className == null || elm.className === '<STR_LIT>') ? EMPTY_ARR : elm.className.trim().split(/\\s+/);<EOL>            for (i = <NUM_LIT>, ilen = oldList.length; i < ilen; i++) {<EOL>                if (newList.indexOf(oldList[i]) === -<NUM_LIT>) {<EOL>                    classList = classList.filter((c: string) => c !== oldList[i]);<EOL>                }<EOL>            }<EOL>","gt":"for (i = <NUM_LIT>, ilen = newList.length; i < ilen; i++) {"}
{"input":"<s> export function setAccessor(plt: PlatformApi, elm: any, memberName: string, oldValue: any, newValue: any, isSvg: boolean, i?: any, ilen?: number) {<EOL>    if (memberName === '<STR_LIT>' && !isSvg) {<EOL>        <EOL>        if (oldValue !== newValue) {<EOL>            const oldList: string[] = (oldValue == null || oldValue === '<STR_LIT>') ? EMPTY_ARR : oldValue.trim().split(/\\s+/);<EOL>            const newList: string[] = (newValue == null || newValue === '<STR_LIT>') ? EMPTY_ARR : newValue.trim().split(/\\s+/);<EOL>            let classList: string[] = (elm.className == null || elm.className === '<STR_LIT>') ? EMPTY_ARR : elm.className.trim().split(/\\s+/);<EOL>            for (i = <NUM_LIT>, ilen = oldList.length; i < ilen; i++) {<EOL>                if (newList.indexOf(oldList[i]) === -<NUM_LIT>) {<EOL>                    classList = classList.filter((c: string) => c !== oldList[i]);<EOL>                }<EOL>            }<EOL>            for (i = <NUM_LIT>, ilen = newList.length; i < ilen; i++) {<EOL>                if (oldList.indexOf(newList[i]) === -<NUM_LIT>) {<EOL>                    classList = [...classList, newList[i]];<EOL>                }<EOL>            }<EOL>            elm.className = classList.join('<STR_LIT>');<EOL>        }<EOL>    }<EOL>    else if (memberName === '<STR_LIT>') {<EOL>        <EOL>        oldValue = oldValue || EMPTY_OBJ;<EOL>        newValue = newValue || EMPTY_OBJ;<EOL>        for (i in oldValue) {<EOL>            if (!newValue[i]) {<EOL>                (elm as any).style[i] = '<STR_LIT>';<EOL>            }<EOL>        }<EOL>        for (i","gt":"in newValue) {"}
{"input":"<s> export function setAccessor(plt: PlatformApi, elm: any, memberName: string, oldValue: any, newValue: any, isSvg: boolean, i?: any, ilen?: number) {<EOL>    if (memberName === '<STR_LIT>' && !isSvg) {<EOL>        <EOL>        if (oldValue !== newValue) {<EOL>            const oldList: string[] = (oldValue == null || oldValue === '<STR_LIT>') ? EMPTY_ARR : oldValue.trim().split(/\\s+/);<EOL>            const newList: string[] = (newValue == null || newValue === '<STR_LIT>') ? EMPTY_ARR : newValue.trim().split(/\\s+/);<EOL>            let classList: string[] = (elm.className == null || elm.className === '<STR_LIT>') ? EMPTY_ARR : elm.className.trim().split(/\\s+/);<EOL>            for (i = <NUM_LIT>, ilen = oldList.length; i < ilen; i++) {<EOL>                if (newList.indexOf(oldList[i]) === -<NUM_LIT>) {<EOL>                    classList = classList.filter((c: string) => c !== oldList[i]);<EOL>                }<EOL>            }<EOL>            for (i = <NUM_LIT>, ilen = newList.length; i < ilen; i++) {<EOL>                if (oldList.indexOf(newList[i]) === -<NUM_LIT>) {<EOL>                    classList = [...classList, newList[i]];<EOL>                }<EOL>            }<EOL>            elm.className = classList.join('<STR_LIT>');<EOL>        }<EOL>    }<EOL>    else if (memberName === '<STR_LIT>') {<EOL>        <EOL>        oldValue = oldValue || EMPTY_OBJ;<EOL>        newValue = newValue || EMPTY_OBJ;<EOL>        for (i in oldValue) {<EOL>            if (!newValue[i]) {<EOL>                (elm as any).style[i] = '<STR_LIT>';<EOL>            }<EOL>        }<EOL>        for (i in newValue) {<EOL>            if (newValue[i] !== oldValue[i]) {<EOL>                (elm as any).style[i] = newValue[i];<EOL>            }<EOL>        }<EOL>    }<EOL>    else if (memberName[<NUM_LIT>] === '<STR_LIT>' && memberName[<NUM_LIT>] === '<STR_LIT>' && (!(memberName in elm))) {<EOL>        <EOL>        <EOL>        memberName = toLowerCase(memberName.substring(<NUM_LIT>));<EOL>","gt":"if (newValue) {"}
{"input":"<s> export function setAccessor(plt: PlatformApi, elm: any, memberName: string, oldValue: any, newValue: any, isSvg: boolean, i?: any, ilen?: number) {<EOL>    if (memberName === '<STR_LIT>' && !isSvg) {<EOL>        <EOL>        if (oldValue !== newValue) {<EOL>            const oldList: string[] = (oldValue == null || oldValue === '<STR_LIT>') ? EMPTY_ARR : oldValue.trim().split(/\\s+/);<EOL>            const newList: string[] = (newValue == null || newValue === '<STR_LIT>') ? EMPTY_ARR : newValue.trim().split(/\\s+/);<EOL>            let classList: string[] = (elm.className == null || elm.className === '<STR_LIT>') ? EMPTY_ARR : elm.className.trim().split(/\\s+/);<EOL>            for (i = <NUM_LIT>, ilen = oldList.length; i < ilen; i++) {<EOL>                if (newList.indexOf(oldList[i]) === -<NUM_LIT>) {<EOL>                    classList = classList.filter((c: string) => c !== oldList[i]);<EOL>                }<EOL>            }<EOL>            for (i = <NUM_LIT>, ilen = newList.length; i < ilen; i++) {<EOL>                if (oldList.indexOf(newList[i]) === -<NUM_LIT>) {<EOL>                    classList = [...classList, newList[i]];<EOL>                }<EOL>            }<EOL>            elm.className = classList.join('<STR_LIT>');<EOL>        }<EOL>    }<EOL>    else if (memberName === '<STR_LIT>') {<EOL>        <EOL>        oldValue = oldValue || EMPTY_OBJ;<EOL>        newValue = newValue || EMPTY_OBJ;<EOL>        for (i in oldValue) {<EOL>            if (!newValue[i]) {<EOL>                (elm as any).style[i] = '<STR_LIT>';<EOL>            }<EOL>        }<EOL>        for (i in newValue) {<EOL>            if (newValue[i] !== oldValue[i]) {<EOL>                (elm as any).style[i] = newValue[i];<EOL>            }<EOL>        }<EOL>    }<EOL>    else if (memberName[<NUM_LIT>] === '<STR_LIT>' && memberName[<NUM_LIT>] === '<STR_LIT>' && (!(memberName in elm))) {<EOL>        <EOL>        <EOL>        memberName = toLowerCase(memberName.substring(<NUM_LIT>));<EOL>        if (newValue) {<EOL>            if (newValue !== oldValue) {<EOL>                <EOL>                plt.domApi.$addEventListener(elm, memberName, newValue);<EOL>            }<EOL>        }<EOL>        else {<EOL>            <EOL>            plt.domApi.$removeEventListener(elm, memberName);<EOL>        }<EOL>    }<EOL>    else if (memberName !== '<STR_LIT>' &&","gt":"memberName !== '<STR_LIT>' && !isSvg &&"}
{"input":"<s> export function setAccessor(plt: PlatformApi, elm: any, memberName: string, oldValue: any, newValue: any, isSvg: boolean, i?: any, ilen?: number) {<EOL>    if (memberName === '<STR_LIT>' && !isSvg) {<EOL>        <EOL>        if (oldValue !== newValue) {<EOL>            const oldList: string[] = (oldValue == null || oldValue === '<STR_LIT>') ? EMPTY_ARR : oldValue.trim().split(/\\s+/);<EOL>            const newList: string[] = (newValue == null || newValue === '<STR_LIT>') ? EMPTY_ARR : newValue.trim().split(/\\s+/);<EOL>            let classList: string[] = (elm.className == null || elm.className === '<STR_LIT>') ? EMPTY_ARR : elm.className.trim().split(/\\s+/);<EOL>            for (i = <NUM_LIT>, ilen = oldList.length; i < ilen; i++) {<EOL>                if (newList.indexOf(oldList[i]) === -<NUM_LIT>) {<EOL>                    classList = classList.filter((c: string) => c !== oldList[i]);<EOL>                }<EOL>            }<EOL>            for (i = <NUM_LIT>, ilen = newList.length; i < ilen; i++) {<EOL>                if (oldList.indexOf(newList[i]) === -<NUM_LIT>) {<EOL>                    classList = [...classList, newList[i]];<EOL>                }<EOL>            }<EOL>            elm.className = classList.join('<STR_LIT>');<EOL>        }<EOL>    }<EOL>    else if (memberName === '<STR_LIT>') {<EOL>        <EOL>        oldValue = oldValue || EMPTY_OBJ;<EOL>        newValue = newValue || EMPTY_OBJ;<EOL>        for (i in oldValue) {<EOL>            if (!newValue[i]) {<EOL>                (elm as any).style[i] = '<STR_LIT>';<EOL>            }<EOL>        }<EOL>        for (i in newValue) {<EOL>            if (newValue[i] !== oldValue[i]) {<EOL>                (elm as any).style[i] = newValue[i];<EOL>            }<EOL>        }<EOL>    }<EOL>    else if (memberName[<NUM_LIT>] === '<STR_LIT>' && memberName[<NUM_LIT>] === '<STR_LIT>' && (!(memberName in elm))) {<EOL>        <EOL>        <EOL>        memberName = toLowerCase(memberName.substring(<NUM_LIT>));<EOL>        if (newValue) {<EOL>            if (newValue !== oldValue) {<EOL>                <EOL>                plt.domApi.$addEventListener(elm, memberName, newValue);<EOL>            }<EOL>        }<EOL>        else {<EOL>            <EOL>            plt.domApi.$removeEventListener(elm, memberName);<EOL>        }<EOL>    }<EOL>    else if (memberName !== '<STR_LIT>' && memberName !== '<STR_LIT>' && !isSvg &&<EOL>        (memberName in elm || (['<STR_LIT>', '<STR_LIT>'].indexOf(typeof newValue) !== -<NUM_LIT>) && newValue !== null)<EOL>        || (!Build.clientSide && elementHasProperty(plt, elm, memberName))) {<EOL>        <EOL>        <EOL>        <EOL>        <EOL>        const cmpMeta = plt.getComponentMeta(elm);<EOL>        if (cmpMeta && cmpMeta.membersMeta && cmpMeta.membersMeta[memberName]) {<EOL>            <EOL>            <EOL>            <EOL>            setProperty(elm, memberName, newValue);<EOL>        }<EOL>        else if (memberName !== '<STR_LIT>') {<EOL>            <EOL>            <EOL>            <EOL>            setProperty(elm, memberName, newValue == null ? '<STR_LIT>' : newValue);<EOL>            if (newValue == null || newValue === false) {<EOL>","gt":"elm.removeAttribute(memberName);"}
{"input":"<s> export function setAccessor(plt: PlatformApi, elm: any, memberName: string, oldValue: any, newValue: any, isSvg: boolean, i?: any, ilen?: number) {<EOL>    if (memberName === '<STR_LIT>' && !isSvg) {<EOL>        <EOL>        if (oldValue !== newValue) {<EOL>            const oldList: string[] = (oldValue == null || oldValue === '<STR_LIT>') ? EMPTY_ARR : oldValue.trim().split(/\\s+/);<EOL>            const newList: string[] = (newValue == null || newValue === '<STR_LIT>') ? EMPTY_ARR : newValue.trim().split(/\\s+/);<EOL>            let classList: string[] = (elm.className == null || elm.className === '<STR_LIT>') ? EMPTY_ARR : elm.className.trim().split(/\\s+/);<EOL>            for (i = <NUM_LIT>, ilen = oldList.length; i < ilen; i++) {<EOL>                if (newList.indexOf(oldList[i]) === -<NUM_LIT>) {<EOL>                    classList = classList.filter((c: string) => c !== oldList[i]);<EOL>                }<EOL>            }<EOL>            for (i = <NUM_LIT>, ilen = newList.length; i < ilen; i++) {<EOL>                if (oldList.indexOf(newList[i]) === -<NUM_LIT>) {<EOL>                    classList = [...classList, newList[i]];<EOL>                }<EOL>            }<EOL>            elm.className = classList.join('<STR_LIT>');<EOL>        }<EOL>    }<EOL>    else if (memberName === '<STR_LIT>') {<EOL>        <EOL>        oldValue = oldValue || EMPTY_OBJ;<EOL>        newValue = newValue || EMPTY_OBJ;<EOL>        for (i in oldValue) {<EOL>            if (!newValue[i]) {<EOL>                (elm as any).style[i] = '<STR_LIT>';<EOL>            }<EOL>        }<EOL>        for (i in newValue) {<EOL>            if (newValue[i] !== oldValue[i]) {<EOL>                (elm as any).style[i] = newValue[i];<EOL>            }<EOL>        }<EOL>    }<EOL>    else if (memberName[<NUM_LIT>] === '<STR_LIT>' && memberName[<NUM_LIT>] === '<STR_LIT>' && (!(memberName in elm))) {<EOL>        <EOL>        <EOL>        memberName = toLowerCase(memberName.substring(<NUM_LIT>));<EOL>        if (newValue) {<EOL>            if (newValue !== oldValue) {<EOL>                <EOL>                plt.domApi.$addEventListener(elm, memberName, newValue);<EOL>            }<EOL>        }<EOL>        else {<EOL>            <EOL>            plt.domApi.$removeEventListener(elm, memberName);<EOL>        }<EOL>    }<EOL>    else if (memberName !== '<STR_LIT>' && memberName !== '<STR_LIT>' && !isSvg &&<EOL>        (memberName in elm || (['<STR_LIT>', '<STR_LIT>'].indexOf(typeof newValue) !== -<NUM_LIT>) && newValue !== null)<EOL>        || (!Build.clientSide && elementHasProperty(plt, elm, memberName))) {<EOL>        <EOL>        <EOL>        <EOL>        <EOL>        const cmpMeta = plt.getComponentMeta(elm);<EOL>        if (cmpMeta && cmpMeta.membersMeta && cmpMeta.membersMeta[memberName]) {<EOL>            <EOL>            <EOL>            <EOL>            setProperty(elm, memberName, newValue);<EOL>        }<EOL>        else if (memberName !== '<STR_LIT>') {<EOL>            <EOL>            <EOL>            <EOL>            setProperty(elm, memberName, newValue == null ? '<STR_LIT>' : newValue);<EOL>            if (newValue == null || newValue === false) {<EOL>                elm.removeAttribute(memberName);<EOL>            }<EOL>        }<EOL>    }<EOL>    else if (newValue != null) {<EOL>        <EOL>        i = (memberName !== (memberName = memberName.","gt":"replace(/^xlink\\:?/, '<STR_LIT>')));"}
{"input":"<s> export function setAccessor(plt: PlatformApi, elm: any, memberName: string, oldValue: any, newValue: any, isSvg: boolean, i?: any, ilen?: number) {<EOL>    if (memberName === '<STR_LIT>' && !isSvg) {<EOL>        <EOL>        if (oldValue !== newValue) {<EOL>            const oldList: string[] = (oldValue == null || oldValue === '<STR_LIT>') ? EMPTY_ARR : oldValue.trim().split(/\\s+/);<EOL>            const newList: string[] = (newValue == null || newValue === '<STR_LIT>') ? EMPTY_ARR : newValue.trim().split(/\\s+/);<EOL>            let classList: string[] = (elm.className == null || elm.className === '<STR_LIT>') ? EMPTY_ARR : elm.className.trim().split(/\\s+/);<EOL>            for (i = <NUM_LIT>, ilen = oldList.length; i < ilen; i++) {<EOL>                if (newList.indexOf(oldList[i]) === -<NUM_LIT>) {<EOL>                    classList = classList.filter((c: string) => c !== oldList[i]);<EOL>                }<EOL>            }<EOL>            for (i = <NUM_LIT>, ilen = newList.length; i < ilen; i++) {<EOL>                if (oldList.indexOf(newList[i]) === -<NUM_LIT>) {<EOL>                    classList = [...classList, newList[i]];<EOL>                }<EOL>            }<EOL>            elm.className = classList.join('<STR_LIT>');<EOL>        }<EOL>    }<EOL>    else if (memberName === '<STR_LIT>') {<EOL>        <EOL>        oldValue = oldValue || EMPTY_OBJ;<EOL>        newValue = newValue || EMPTY_OBJ;<EOL>        for (i in oldValue) {<EOL>            if (!newValue[i]) {<EOL>                (elm as any).style[i] = '<STR_LIT>';<EOL>            }<EOL>        }<EOL>        for (i in newValue) {<EOL>            if (newValue[i] !== oldValue[i]) {<EOL>                (elm as any).style[i] = newValue[i];<EOL>            }<EOL>        }<EOL>    }<EOL>    else if (memberName[<NUM_LIT>] === '<STR_LIT>' && memberName[<NUM_LIT>] === '<STR_LIT>' && (!(memberName in elm))) {<EOL>        <EOL>        <EOL>        memberName = toLowerCase(memberName.substring(<NUM_LIT>));<EOL>        if (newValue) {<EOL>            if (newValue !== oldValue) {<EOL>                <EOL>                plt.domApi.$addEventListener(elm, memberName, newValue);<EOL>            }<EOL>        }<EOL>        else {<EOL>            <EOL>            plt.domApi.$removeEventListener(elm, memberName);<EOL>        }<EOL>    }<EOL>    else if (memberName !== '<STR_LIT>' && memberName !== '<STR_LIT>' && !isSvg &&<EOL>        (memberName in elm || (['<STR_LIT>', '<STR_LIT>'].indexOf(typeof newValue) !== -<NUM_LIT>) && newValue !== null)<EOL>        || (!Build.clientSide && elementHasProperty(plt, elm, memberName))) {<EOL>        <EOL>        <EOL>        <EOL>        <EOL>        const cmpMeta = plt.getComponentMeta(elm);<EOL>        if (cmpMeta && cmpMeta.membersMeta && cmpMeta.membersMeta[memberName]) {<EOL>            <EOL>            <EOL>            <EOL>            setProperty(elm, memberName, newValue);<EOL>        }<EOL>        else if (memberName !== '<STR_LIT>') {<EOL>            <EOL>            <EOL>            <EOL>            setProperty(elm, memberName, newValue == null ? '<STR_LIT>' : newValue);<EOL>            if (newValue == null || newValue === false) {<EOL>                elm.removeAttribute(memberName);<EOL>            }<EOL>        }<EOL>    }<EOL>    else if (newValue != null) {<EOL>        <EOL>        i = (memberName !== (memberName = memberName.replace(/^xlink\\:?/, '<STR_LIT>')));<EOL>        if (","gt":"BOOLEAN_ATTRS[memberName] === <NUM_LIT> && (!newValue || newValue === '<STR_LIT>')) {"}
{"input":"<s> export function setAccessor(plt: PlatformApi, elm: any, memberName: string, oldValue: any, newValue: any, isSvg: boolean, i?: any, ilen?: number) {<EOL>    if (memberName === '<STR_LIT>' && !isSvg) {<EOL>        <EOL>        if (oldValue !== newValue) {<EOL>            const oldList: string[] = (oldValue == null || oldValue === '<STR_LIT>') ? EMPTY_ARR : oldValue.trim().split(/\\s+/);<EOL>            const newList: string[] = (newValue == null || newValue === '<STR_LIT>') ? EMPTY_ARR : newValue.trim().split(/\\s+/);<EOL>            let classList: string[] = (elm.className == null || elm.className === '<STR_LIT>') ? EMPTY_ARR : elm.className.trim().split(/\\s+/);<EOL>            for (i = <NUM_LIT>, ilen = oldList.length; i < ilen; i++) {<EOL>                if (newList.indexOf(oldList[i]) === -<NUM_LIT>) {<EOL>                    classList = classList.filter((c: string) => c !== oldList[i]);<EOL>                }<EOL>            }<EOL>            for (i = <NUM_LIT>, ilen = newList.length; i < ilen; i++) {<EOL>                if (oldList.indexOf(newList[i]) === -<NUM_LIT>) {<EOL>                    classList = [...classList, newList[i]];<EOL>                }<EOL>            }<EOL>            elm.className = classList.join('<STR_LIT>');<EOL>        }<EOL>    }<EOL>    else if (memberName === '<STR_LIT>') {<EOL>        <EOL>        oldValue = oldValue || EMPTY_OBJ;<EOL>        newValue = newValue || EMPTY_OBJ;<EOL>        for (i in oldValue) {<EOL>            if (!newValue[i]) {<EOL>                (elm as any).style[i] = '<STR_LIT>';<EOL>            }<EOL>        }<EOL>        for (i in newValue) {<EOL>            if (newValue[i] !== oldValue[i]) {<EOL>                (elm as any).style[i] = newValue[i];<EOL>            }<EOL>        }<EOL>    }<EOL>    else if (memberName[<NUM_LIT>] === '<STR_LIT>' && memberName[<NUM_LIT>] === '<STR_LIT>' && (!(memberName in elm))) {<EOL>        <EOL>        <EOL>        memberName = toLowerCase(memberName.substring(<NUM_LIT>));<EOL>        if (newValue) {<EOL>            if (newValue !== oldValue) {<EOL>                <EOL>                plt.domApi.$addEventListener(elm, memberName, newValue);<EOL>            }<EOL>        }<EOL>        else {<EOL>            <EOL>            plt.domApi.$removeEventListener(elm, memberName);<EOL>        }<EOL>    }<EOL>    else if (memberName !== '<STR_LIT>' && memberName !== '<STR_LIT>' && !isSvg &&<EOL>        (memberName in elm || (['<STR_LIT>', '<STR_LIT>'].indexOf(typeof newValue) !== -<NUM_LIT>) && newValue !== null)<EOL>        || (!Build.clientSide && elementHasProperty(plt, elm, memberName))) {<EOL>        <EOL>        <EOL>        <EOL>        <EOL>        const cmpMeta = plt.getComponentMeta(elm);<EOL>        if (cmpMeta && cmpMeta.membersMeta && cmpMeta.membersMeta[memberName]) {<EOL>            <EOL>            <EOL>            <EOL>            setProperty(elm, memberName, newValue);<EOL>        }<EOL>        else if (memberName !== '<STR_LIT>') {<EOL>            <EOL>            <EOL>            <EOL>            setProperty(elm, memberName, newValue == null ? '<STR_LIT>' : newValue);<EOL>            if (newValue == null || newValue === false) {<EOL>                elm.removeAttribute(memberName);<EOL>            }<EOL>        }<EOL>    }<EOL>    else if (newValue != null) {<EOL>        <EOL>        i = (memberName !== (memberName = memberName.replace(/^xlink\\:?/, '<STR_LIT>')));<EOL>        if (BOOLEAN_ATTRS[memberName] === <NUM_LIT> && (!newValue || newValue === '<STR_LIT>')) {<EOL>            if (i) {<EOL>                elm.removeAttributeNS(XLINK_NS, toLowerCase(memberName));<EOL>            }<EOL>","gt":"else {"}
{"input":"<s> export function setAccessor(plt: PlatformApi, elm: any, memberName: string, oldValue: any, newValue: any, isSvg: boolean, i?: any, ilen?: number) {<EOL>    if (memberName === '<STR_LIT>' && !isSvg) {<EOL>        <EOL>        if (oldValue !== newValue) {<EOL>            const oldList: string[] = (oldValue == null || oldValue === '<STR_LIT>') ? EMPTY_ARR : oldValue.trim().split(/\\s+/);<EOL>            const newList: string[] = (newValue == null || newValue === '<STR_LIT>') ? EMPTY_ARR : newValue.trim().split(/\\s+/);<EOL>            let classList: string[] = (elm.className == null || elm.className === '<STR_LIT>') ? EMPTY_ARR : elm.className.trim().split(/\\s+/);<EOL>            for (i = <NUM_LIT>, ilen = oldList.length; i < ilen; i++) {<EOL>                if (newList.indexOf(oldList[i]) === -<NUM_LIT>) {<EOL>                    classList = classList.filter((c: string) => c !== oldList[i]);<EOL>                }<EOL>            }<EOL>            for (i = <NUM_LIT>, ilen = newList.length; i < ilen; i++) {<EOL>                if (oldList.indexOf(newList[i]) === -<NUM_LIT>) {<EOL>                    classList = [...classList, newList[i]];<EOL>                }<EOL>            }<EOL>            elm.className = classList.join('<STR_LIT>');<EOL>        }<EOL>    }<EOL>    else if (memberName === '<STR_LIT>') {<EOL>        <EOL>        oldValue = oldValue || EMPTY_OBJ;<EOL>        newValue = newValue || EMPTY_OBJ;<EOL>        for (i in oldValue) {<EOL>            if (!newValue[i]) {<EOL>                (elm as any).style[i] = '<STR_LIT>';<EOL>            }<EOL>        }<EOL>        for (i in newValue) {<EOL>            if (newValue[i] !== oldValue[i]) {<EOL>                (elm as any).style[i] = newValue[i];<EOL>            }<EOL>        }<EOL>    }<EOL>    else if (memberName[<NUM_LIT>] === '<STR_LIT>' && memberName[<NUM_LIT>] === '<STR_LIT>' && (!(memberName in elm))) {<EOL>        <EOL>        <EOL>        memberName = toLowerCase(memberName.substring(<NUM_LIT>));<EOL>        if (newValue) {<EOL>            if (newValue !== oldValue) {<EOL>                <EOL>                plt.domApi.$addEventListener(elm, memberName, newValue);<EOL>            }<EOL>        }<EOL>        else {<EOL>            <EOL>            plt.domApi.$removeEventListener(elm, memberName);<EOL>        }<EOL>    }<EOL>    else if (memberName !== '<STR_LIT>' && memberName !== '<STR_LIT>' && !isSvg &&<EOL>        (memberName in elm || (['<STR_LIT>', '<STR_LIT>'].indexOf(typeof newValue) !== -<NUM_LIT>) && newValue !== null)<EOL>        || (!Build.clientSide && elementHasProperty(plt, elm, memberName))) {<EOL>        <EOL>        <EOL>        <EOL>        <EOL>        const cmpMeta = plt.getComponentMeta(elm);<EOL>        if (cmpMeta && cmpMeta.membersMeta && cmpMeta.membersMeta[memberName]) {<EOL>            <EOL>            <EOL>            <EOL>            setProperty(elm, memberName, newValue);<EOL>        }<EOL>        else if (memberName !== '<STR_LIT>') {<EOL>            <EOL>            <EOL>            <EOL>            setProperty(elm, memberName, newValue == null ? '<STR_LIT>' : newValue);<EOL>            if (newValue == null || newValue === false) {<EOL>                elm.removeAttribute(memberName);<EOL>            }<EOL>        }<EOL>    }<EOL>    else if (newValue != null) {<EOL>        <EOL>        i = (memberName !== (memberName = memberName.replace(/^xlink\\:?/, '<STR_LIT>')));<EOL>        if (BOOLEAN_ATTRS[memberName] === <NUM_LIT> && (!newValue || newValue === '<STR_LIT>')) {<EOL>            if (i) {<EOL>                elm.removeAttributeNS(XLINK_NS, toLowerCase(memberName));<EOL>            }<EOL>            else {<EOL>","gt":"elm.removeAttribute(memberName);"}
{"input":"<s> function getRandomInt(min, max) {<EOL>    return Math.floor(","gt":"Math.random() * (max - min)) + min;"}
{"input":"<s> function isVideoTorrentUpdateActivityValid(activity: any) {<EOL>","gt":"return isBaseActivityValid(activity, '<STR_LIT>') &&"}
{"input":"<s> function isVideoImage(files: {<EOL>    [fieldname: string]: Express.Multer.File[];<EOL>} | Express.Multer.File[], field: string) {<EOL>    return isFileValid(files, videoImageTypesRegex,","gt":"field, true);"}
{"input":"<s> async function processFollowActivity(activity: ActivityFollow) {<EOL>    const activityObject =","gt":"activity.object;"}
{"input":"<s> async function processUpdateActivity(activity: ActivityUpdate) {<EOL>    const actor = await getOrCreateActorAndServerAndModel(activity.actor);<EOL>    const objectType = activity.object.type;<EOL>    if (objectType ===","gt":"'<STR_LIT>') {"}
{"input":"<s> <EOL>function processVideoShare(actorAnnouncer: ActorModel, activity: ActivityAnnounce) {<EOL>    const options = {<EOL>","gt":"arguments: [actorAnnouncer, activity],"}
{"input":"<s> function isActorTypeValid(type: string) {<EOL>    return type === '<STR_LIT>' || type === '<STR_LIT>' || type ===","gt":"'<STR_LIT>';"}
{"input":"<s> async function up(utils: {<EOL>    transaction: Sequelize.Transaction;<EOL>    queryInterface: Sequelize.QueryInterface;<EOL>    sequelize: Sequelize.Sequelize;<EOL>}): Promise<void> {<EOL>    {<EOL>        const query =","gt":"'<STR_LIT>' +"}
{"input":"<s> function down(options) {<EOL>    throw","gt":"new Error('<STR_LIT>');"}
{"input":"<s> function test() {<EOL>    var x = () => {<EOL>        (() =>","gt":"this)();"}
{"input":"<s> /**<EOL> * Attempt to set a DOM property to the given value.<EOL> * IE & FF throw for certain property-value combinations.<EOL> */<EOL>function setProperty(elm: any, name: string, value: any) {<EOL>    try {<EOL>        elm[name] =","gt":"value;"}
{"input":"<s> export async function docs(config: Config, compilerCtx: CompilerCtx) {<EOL>    compilerCtx = getCompilerCtx(config, compilerCtx);<EOL>    const buildCtx = getBuildContext(config, compilerCtx, null);<EOL>    config.logger.info(config.logger.cyan(`<STR_LIT>`));<EOL>    <EOL>    const timeSpan = config.logger.createTimeSpan(`<STR_LIT>`);<EOL>","gt":"try {"}
{"input":"<s> export async function docs(config: Config, compilerCtx: CompilerCtx) {<EOL>    compilerCtx = getCompilerCtx(config, compilerCtx);<EOL>    const buildCtx = getBuildContext(config, compilerCtx, null);<EOL>    config.logger.info(config.logger.cyan(`<STR_LIT>`));<EOL>    <EOL>    const timeSpan = config.logger.createTimeSpan(`<STR_LIT>`);<EOL>    try {<EOL>        <EOL>        <EOL>        <EOL>        await transpileAppModules(config, compilerCtx, buildCtx);<EOL>        <EOL>        await generateReadmes(config,","gt":"compilerCtx);"}
{"input":"<s> export async function docs(config: Config, compilerCtx: CompilerCtx) {<EOL>    compilerCtx = getCompilerCtx(config, compilerCtx);<EOL>    const buildCtx = getBuildContext(config, compilerCtx, null);<EOL>    config.logger.info(config.logger.cyan(`<STR_LIT>`));<EOL>    <EOL>    const timeSpan = config.logger.createTimeSpan(`<STR_LIT>`);<EOL>    try {<EOL>        <EOL>        <EOL>        <EOL>        await transpileAppModules(config, compilerCtx, buildCtx);<EOL>        <EOL>        await generateReadmes(config, compilerCtx);<EOL>    }<EOL>    catch (e) {<EOL>        <EOL>        catchError(buildCtx.diagnostics, e);<EOL>    }<EOL>    <EOL>    buildCtx.diagnostics = cleanDiagnostics(buildCtx.diagnostics);<EOL>    config.logger.printDiagnostics(buildCtx.diagnostics);<EOL>    <EOL>    let","gt":"buildStatus = '<STR_LIT>';"}
{"input":"<s> export function validatePaths(config: Config) {<EOL>    const path = config.sys.path;<EOL>    if (typeof (config as any).global === '<STR_LIT>') {<EOL>        <EOL>        config.logger.warn(`<STR_LIT>`);<EOL>        config.globalScript = (config as any).global;<EOL>    }<EOL>    if (typeof config.globalScript === '<STR_LIT>' && !path.isAbsolute(","gt":"config.globalScript)) {"}
{"input":"<s> export function validatePaths(config: Config) {<EOL>    const path = config.sys.path;<EOL>    if (typeof (config as any).global === '<STR_LIT>') {<EOL>        <EOL>        config.logger.warn(`<STR_LIT>`);<EOL>        config.globalScript = (config as any).global;<EOL>    }<EOL>    if (typeof config.globalScript === '<STR_LIT>' && !path.isAbsolute(config.globalScript)) {<EOL>        config.globalScript = normalizePath(path.join(config.rootDir, config.globalScript));<EOL>    }<EOL>    if (","gt":"typeof config.globalStyle === '<STR_LIT>') {"}
{"input":"<s> export function validatePaths(config: Config) {<EOL>    const path = config.sys.path;<EOL>    if (typeof (config as any).global === '<STR_LIT>') {<EOL>        <EOL>        config.logger.warn(`<STR_LIT>`);<EOL>        config.globalScript = (config as any).global;<EOL>    }<EOL>    if (typeof config.globalScript === '<STR_LIT>' && !path.isAbsolute(config.globalScript)) {<EOL>        config.globalScript = normalizePath(path.join(config.rootDir, config.globalScript));<EOL>    }<EOL>    if (typeof config.globalStyle === '<STR_LIT>') {<EOL>        config.globalStyle = [config.globalStyle];<EOL>    }<EOL>    if (Array.isArray(config.globalStyle)) {<EOL>        config.globalStyle = config.globalStyle.filter(globalStyle => typeof","gt":"globalStyle === '<STR_LIT>');"}
{"input":"<s> export function validatePaths(config: Config) {<EOL>    const path = config.sys.path;<EOL>    if (typeof (config as any).global === '<STR_LIT>') {<EOL>        <EOL>        config.logger.warn(`<STR_LIT>`);<EOL>        config.globalScript = (config as any).global;<EOL>    }<EOL>    if (typeof config.globalScript === '<STR_LIT>' && !path.isAbsolute(config.globalScript)) {<EOL>        config.globalScript = normalizePath(path.join(config.rootDir, config.globalScript));<EOL>    }<EOL>    if (typeof config.globalStyle === '<STR_LIT>') {<EOL>        config.globalStyle = [config.globalStyle];<EOL>    }<EOL>    if (Array.isArray(config.globalStyle)) {<EOL>        config.globalStyle = config.globalStyle.filter(globalStyle => typeof globalStyle === '<STR_LIT>');<EOL>        config.globalStyle =","gt":"config.globalStyle.map(globalStyle => {"}
{"input":"<s> export function validatePaths(config: Config) {<EOL>    const path = config.sys.path;<EOL>    if (typeof (config as any).global === '<STR_LIT>') {<EOL>        <EOL>        config.logger.warn(`<STR_LIT>`);<EOL>        config.globalScript = (config as any).global;<EOL>    }<EOL>    if (typeof config.globalScript === '<STR_LIT>' && !path.isAbsolute(config.globalScript)) {<EOL>        config.globalScript = normalizePath(path.join(config.rootDir, config.globalScript));<EOL>    }<EOL>    if (typeof config.globalStyle === '<STR_LIT>') {<EOL>        config.globalStyle = [config.globalStyle];<EOL>    }<EOL>    if (Array.isArray(config.globalStyle)) {<EOL>        config.globalStyle = config.globalStyle.filter(globalStyle => typeof globalStyle === '<STR_LIT>');<EOL>        config.globalStyle = config.globalStyle.map(globalStyle => {<EOL>            if (path.isAbsolute(globalStyle)) {<EOL>                return normalizePath(globalStyle);<EOL>            }<EOL>            return normalizePath(path.join(config.rootDir, globalStyle));<EOL>        });<EOL>    }<EOL>    if (typeof (config as any).src === '<STR_LIT>') {<EOL>        <EOL>        config.logger.warn(`<STR_LIT>`);<EOL>        config.srcDir = (config as any).src;<EOL>    }<EOL>    setStringConfig(config, '<STR_LIT>', DEFAULT_SRC_DIR);<EOL>    if (!path.isAbsolute(config.srcDir)) {<EOL>        config.srcDir = normalizePath(path.join(config.rootDir, config.srcDir));<EOL>    }<EOL>","gt":"setStringConfig(config, '<STR_LIT>', DEFAULT_WWW_DIR);"}
{"input":"<s> export function validatePaths(config: Config) {<EOL>    const path = config.sys.path;<EOL>    if (typeof (config as any).global === '<STR_LIT>') {<EOL>        <EOL>        config.logger.warn(`<STR_LIT>`);<EOL>        config.globalScript = (config as any).global;<EOL>    }<EOL>    if (typeof config.globalScript === '<STR_LIT>' && !path.isAbsolute(config.globalScript)) {<EOL>        config.globalScript = normalizePath(path.join(config.rootDir, config.globalScript));<EOL>    }<EOL>    if (typeof config.globalStyle === '<STR_LIT>') {<EOL>        config.globalStyle = [config.globalStyle];<EOL>    }<EOL>    if (Array.isArray(config.globalStyle)) {<EOL>        config.globalStyle = config.globalStyle.filter(globalStyle => typeof globalStyle === '<STR_LIT>');<EOL>        config.globalStyle = config.globalStyle.map(globalStyle => {<EOL>            if (path.isAbsolute(globalStyle)) {<EOL>                return normalizePath(globalStyle);<EOL>            }<EOL>            return normalizePath(path.join(config.rootDir, globalStyle));<EOL>        });<EOL>    }<EOL>    if (typeof (config as any).src === '<STR_LIT>') {<EOL>        <EOL>        config.logger.warn(`<STR_LIT>`);<EOL>        config.srcDir = (config as any).src;<EOL>    }<EOL>    setStringConfig(config, '<STR_LIT>', DEFAULT_SRC_DIR);<EOL>    if (!path.isAbsolute(config.srcDir)) {<EOL>        config.srcDir = normalizePath(path.join(config.rootDir, config.srcDir));<EOL>    }<EOL>    setStringConfig(config, '<STR_LIT>', DEFAULT_WWW_DIR);<EOL>    if (!path.isAbsolute(config.wwwDir)) {<EOL>        config.wwwDir = normalizePath(path.join(config.rootDir, config.wwwDir));<EOL>    }<EOL>    setStringConfig(config, '<STR_LIT>', DEFAULT_BUILD_DIR);<EOL>    if (!path.isAbsolute(config.buildDir)) {<EOL>        config.buildDir = normalizePath(path.join(config.wwwDir, config.buildDir));<EOL>    }<EOL>    setStringConfig(config, '<STR_LIT>', DEFAULT_DIST_DIR);<EOL>    if (!path.isAbsolute(config.distDir)) {<EOL>        config.distDir = normalizePath(path.","gt":"join(config.rootDir, config.distDir));"}
{"input":"<s> export function validatePaths(config: Config) {<EOL>    const path = config.sys.path;<EOL>    if (typeof (config as any).global === '<STR_LIT>') {<EOL>        <EOL>        config.logger.warn(`<STR_LIT>`);<EOL>        config.globalScript = (config as any).global;<EOL>    }<EOL>    if (typeof config.globalScript === '<STR_LIT>' && !path.isAbsolute(config.globalScript)) {<EOL>        config.globalScript = normalizePath(path.join(config.rootDir, config.globalScript));<EOL>    }<EOL>    if (typeof config.globalStyle === '<STR_LIT>') {<EOL>        config.globalStyle = [config.globalStyle];<EOL>    }<EOL>    if (Array.isArray(config.globalStyle)) {<EOL>        config.globalStyle = config.globalStyle.filter(globalStyle => typeof globalStyle === '<STR_LIT>');<EOL>        config.globalStyle = config.globalStyle.map(globalStyle => {<EOL>            if (path.isAbsolute(globalStyle)) {<EOL>                return normalizePath(globalStyle);<EOL>            }<EOL>            return normalizePath(path.join(config.rootDir, globalStyle));<EOL>        });<EOL>    }<EOL>    if (typeof (config as any).src === '<STR_LIT>') {<EOL>        <EOL>        config.logger.warn(`<STR_LIT>`);<EOL>        config.srcDir = (config as any).src;<EOL>    }<EOL>    setStringConfig(config, '<STR_LIT>', DEFAULT_SRC_DIR);<EOL>    if (!path.isAbsolute(config.srcDir)) {<EOL>        config.srcDir = normalizePath(path.join(config.rootDir, config.srcDir));<EOL>    }<EOL>    setStringConfig(config, '<STR_LIT>', DEFAULT_WWW_DIR);<EOL>    if (!path.isAbsolute(config.wwwDir)) {<EOL>        config.wwwDir = normalizePath(path.join(config.rootDir, config.wwwDir));<EOL>    }<EOL>    setStringConfig(config, '<STR_LIT>', DEFAULT_BUILD_DIR);<EOL>    if (!path.isAbsolute(config.buildDir)) {<EOL>        config.buildDir = normalizePath(path.join(config.wwwDir, config.buildDir));<EOL>    }<EOL>    setStringConfig(config, '<STR_LIT>', DEFAULT_DIST_DIR);<EOL>    if (!path.isAbsolute(config.distDir)) {<EOL>        config.distDir = normalizePath(path.join(config.rootDir, config.distDir));<EOL>    }<EOL>    setStringConfig(config, '<STR_LIT>', DEFAULT_COLLECTION_DIR);<EOL>    if (!path.isAbsolute(config.collectionDir)) {<EOL>        config.collectionDir = normalizePath(path.join(config.distDir, config.","gt":"collectionDir));"}
{"input":"<s> export function validatePaths(config: Config) {<EOL>    const path = config.sys.path;<EOL>    if (typeof (config as any).global === '<STR_LIT>') {<EOL>        <EOL>        config.logger.warn(`<STR_LIT>`);<EOL>        config.globalScript = (config as any).global;<EOL>    }<EOL>    if (typeof config.globalScript === '<STR_LIT>' && !path.isAbsolute(config.globalScript)) {<EOL>        config.globalScript = normalizePath(path.join(config.rootDir, config.globalScript));<EOL>    }<EOL>    if (typeof config.globalStyle === '<STR_LIT>') {<EOL>        config.globalStyle = [config.globalStyle];<EOL>    }<EOL>    if (Array.isArray(config.globalStyle)) {<EOL>        config.globalStyle = config.globalStyle.filter(globalStyle => typeof globalStyle === '<STR_LIT>');<EOL>        config.globalStyle = config.globalStyle.map(globalStyle => {<EOL>            if (path.isAbsolute(globalStyle)) {<EOL>                return normalizePath(globalStyle);<EOL>            }<EOL>            return normalizePath(path.join(config.rootDir, globalStyle));<EOL>        });<EOL>    }<EOL>    if (typeof (config as any).src === '<STR_LIT>') {<EOL>        <EOL>        config.logger.warn(`<STR_LIT>`);<EOL>        config.srcDir = (config as any).src;<EOL>    }<EOL>    setStringConfig(config, '<STR_LIT>', DEFAULT_SRC_DIR);<EOL>    if (!path.isAbsolute(config.srcDir)) {<EOL>        config.srcDir = normalizePath(path.join(config.rootDir, config.srcDir));<EOL>    }<EOL>    setStringConfig(config, '<STR_LIT>', DEFAULT_WWW_DIR);<EOL>    if (!path.isAbsolute(config.wwwDir)) {<EOL>        config.wwwDir = normalizePath(path.join(config.rootDir, config.wwwDir));<EOL>    }<EOL>    setStringConfig(config, '<STR_LIT>', DEFAULT_BUILD_DIR);<EOL>    if (!path.isAbsolute(config.buildDir)) {<EOL>        config.buildDir = normalizePath(path.join(config.wwwDir, config.buildDir));<EOL>    }<EOL>    setStringConfig(config, '<STR_LIT>', DEFAULT_DIST_DIR);<EOL>    if (!path.isAbsolute(config.distDir)) {<EOL>        config.distDir = normalizePath(path.join(config.rootDir, config.distDir));<EOL>    }<EOL>    setStringConfig(config, '<STR_LIT>', DEFAULT_COLLECTION_DIR);<EOL>    if (!path.isAbsolute(config.collectionDir)) {<EOL>        config.collectionDir = normalizePath(path.join(config.distDir, config.collectionDir));<EOL>    }<EOL>    setStringConfig(","gt":"config, '<STR_LIT>', DEFAULT_TSCONFIG);"}
{"input":"<s> export function validatePaths(config: Config) {<EOL>    const path = config.sys.path;<EOL>    if (typeof (config as any).global === '<STR_LIT>') {<EOL>        <EOL>        config.logger.warn(`<STR_LIT>`);<EOL>        config.globalScript = (config as any).global;<EOL>    }<EOL>    if (typeof config.globalScript === '<STR_LIT>' && !path.isAbsolute(config.globalScript)) {<EOL>        config.globalScript = normalizePath(path.join(config.rootDir, config.globalScript));<EOL>    }<EOL>    if (typeof config.globalStyle === '<STR_LIT>') {<EOL>        config.globalStyle = [config.globalStyle];<EOL>    }<EOL>    if (Array.isArray(config.globalStyle)) {<EOL>        config.globalStyle = config.globalStyle.filter(globalStyle => typeof globalStyle === '<STR_LIT>');<EOL>        config.globalStyle = config.globalStyle.map(globalStyle => {<EOL>            if (path.isAbsolute(globalStyle)) {<EOL>                return normalizePath(globalStyle);<EOL>            }<EOL>            return normalizePath(path.join(config.rootDir, globalStyle));<EOL>        });<EOL>    }<EOL>    if (typeof (config as any).src === '<STR_LIT>') {<EOL>        <EOL>        config.logger.warn(`<STR_LIT>`);<EOL>        config.srcDir = (config as any).src;<EOL>    }<EOL>    setStringConfig(config, '<STR_LIT>', DEFAULT_SRC_DIR);<EOL>    if (!path.isAbsolute(config.srcDir)) {<EOL>        config.srcDir = normalizePath(path.join(config.rootDir, config.srcDir));<EOL>    }<EOL>    setStringConfig(config, '<STR_LIT>', DEFAULT_WWW_DIR);<EOL>    if (!path.isAbsolute(config.wwwDir)) {<EOL>        config.wwwDir = normalizePath(path.join(config.rootDir, config.wwwDir));<EOL>    }<EOL>    setStringConfig(config, '<STR_LIT>', DEFAULT_BUILD_DIR);<EOL>    if (!path.isAbsolute(config.buildDir)) {<EOL>        config.buildDir = normalizePath(path.join(config.wwwDir, config.buildDir));<EOL>    }<EOL>    setStringConfig(config, '<STR_LIT>', DEFAULT_DIST_DIR);<EOL>    if (!path.isAbsolute(config.distDir)) {<EOL>        config.distDir = normalizePath(path.join(config.rootDir, config.distDir));<EOL>    }<EOL>    setStringConfig(config, '<STR_LIT>', DEFAULT_COLLECTION_DIR);<EOL>    if (!path.isAbsolute(config.collectionDir)) {<EOL>        config.collectionDir = normalizePath(path.join(config.distDir, config.collectionDir));<EOL>    }<EOL>    setStringConfig(config, '<STR_LIT>', DEFAULT_TSCONFIG);<EOL>    if (!path.isAbsolute(config.tsconfig)) {<EOL>        config.tsconfig = normalizePath(path.join(config.rootDir, config.tsconfig));<EOL>    }<EOL>    setStringConfig(config, '<STR_LIT>', DEFAULT_TYPES_DIR);<EOL>    if (!path.isAbsolute(config.typesDir)) {<EOL>        config.typesDir = normalizePath(path.join(config.distDir, config.typesDir));<EOL>    }<EOL>    setStringConfig(config, '<STR_LIT>', normalizePath(path.join(config.srcDir, DEFAULT_INDEX_HTML)));<EOL>    if (!path.isAbsolute(config.srcIndexHtml)) {<EOL>        config.srcIndexHtml = normalizePath(path.","gt":"join(config.rootDir, config.srcIndexHtml));"}
{"input":"<s> export function validatePaths(config: Config) {<EOL>    const path = config.sys.path;<EOL>    if (typeof (config as any).global === '<STR_LIT>') {<EOL>        <EOL>        config.logger.warn(`<STR_LIT>`);<EOL>        config.globalScript = (config as any).global;<EOL>    }<EOL>    if (typeof config.globalScript === '<STR_LIT>' && !path.isAbsolute(config.globalScript)) {<EOL>        config.globalScript = normalizePath(path.join(config.rootDir, config.globalScript));<EOL>    }<EOL>    if (typeof config.globalStyle === '<STR_LIT>') {<EOL>        config.globalStyle = [config.globalStyle];<EOL>    }<EOL>    if (Array.isArray(config.globalStyle)) {<EOL>        config.globalStyle = config.globalStyle.filter(globalStyle => typeof globalStyle === '<STR_LIT>');<EOL>        config.globalStyle = config.globalStyle.map(globalStyle => {<EOL>            if (path.isAbsolute(globalStyle)) {<EOL>                return normalizePath(globalStyle);<EOL>            }<EOL>            return normalizePath(path.join(config.rootDir, globalStyle));<EOL>        });<EOL>    }<EOL>    if (typeof (config as any).src === '<STR_LIT>') {<EOL>        <EOL>        config.logger.warn(`<STR_LIT>`);<EOL>        config.srcDir = (config as any).src;<EOL>    }<EOL>    setStringConfig(config, '<STR_LIT>', DEFAULT_SRC_DIR);<EOL>    if (!path.isAbsolute(config.srcDir)) {<EOL>        config.srcDir = normalizePath(path.join(config.rootDir, config.srcDir));<EOL>    }<EOL>    setStringConfig(config, '<STR_LIT>', DEFAULT_WWW_DIR);<EOL>    if (!path.isAbsolute(config.wwwDir)) {<EOL>        config.wwwDir = normalizePath(path.join(config.rootDir, config.wwwDir));<EOL>    }<EOL>    setStringConfig(config, '<STR_LIT>', DEFAULT_BUILD_DIR);<EOL>    if (!path.isAbsolute(config.buildDir)) {<EOL>        config.buildDir = normalizePath(path.join(config.wwwDir, config.buildDir));<EOL>    }<EOL>    setStringConfig(config, '<STR_LIT>', DEFAULT_DIST_DIR);<EOL>    if (!path.isAbsolute(config.distDir)) {<EOL>        config.distDir = normalizePath(path.join(config.rootDir, config.distDir));<EOL>    }<EOL>    setStringConfig(config, '<STR_LIT>', DEFAULT_COLLECTION_DIR);<EOL>    if (!path.isAbsolute(config.collectionDir)) {<EOL>        config.collectionDir = normalizePath(path.join(config.distDir, config.collectionDir));<EOL>    }<EOL>    setStringConfig(config, '<STR_LIT>', DEFAULT_TSCONFIG);<EOL>    if (!path.isAbsolute(config.tsconfig)) {<EOL>        config.tsconfig = normalizePath(path.join(config.rootDir, config.tsconfig));<EOL>    }<EOL>    setStringConfig(config, '<STR_LIT>', DEFAULT_TYPES_DIR);<EOL>    if (!path.isAbsolute(config.typesDir)) {<EOL>        config.typesDir = normalizePath(path.join(config.distDir, config.typesDir));<EOL>    }<EOL>    setStringConfig(config, '<STR_LIT>', normalizePath(path.join(config.srcDir, DEFAULT_INDEX_HTML)));<EOL>    if (!path.isAbsolute(config.srcIndexHtml)) {<EOL>        config.srcIndexHtml = normalizePath(path.join(config.rootDir, config.srcIndexHtml));<EOL>    }<EOL>    setStringConfig(config, '<STR_LIT>', normalizePath(path.join(config.wwwDir, DEFAULT_INDEX_HTML)));<EOL>    if (!path.isAbsolute(config.wwwIndexHtml)) {<EOL>        config.wwwIndexHtml =","gt":"normalizePath(path.join(config.wwwDir, config.wwwIndexHtml));"}
{"input":"<s> export function validatePaths(config: Config) {<EOL>    const path = config.sys.path;<EOL>    if (typeof (config as any).global === '<STR_LIT>') {<EOL>        <EOL>        config.logger.warn(`<STR_LIT>`);<EOL>        config.globalScript = (config as any).global;<EOL>    }<EOL>    if (typeof config.globalScript === '<STR_LIT>' && !path.isAbsolute(config.globalScript)) {<EOL>        config.globalScript = normalizePath(path.join(config.rootDir, config.globalScript));<EOL>    }<EOL>    if (typeof config.globalStyle === '<STR_LIT>') {<EOL>        config.globalStyle = [config.globalStyle];<EOL>    }<EOL>    if (Array.isArray(config.globalStyle)) {<EOL>        config.globalStyle = config.globalStyle.filter(globalStyle => typeof globalStyle === '<STR_LIT>');<EOL>        config.globalStyle = config.globalStyle.map(globalStyle => {<EOL>            if (path.isAbsolute(globalStyle)) {<EOL>                return normalizePath(globalStyle);<EOL>            }<EOL>            return normalizePath(path.join(config.rootDir, globalStyle));<EOL>        });<EOL>    }<EOL>    if (typeof (config as any).src === '<STR_LIT>') {<EOL>        <EOL>        config.logger.warn(`<STR_LIT>`);<EOL>        config.srcDir = (config as any).src;<EOL>    }<EOL>    setStringConfig(config, '<STR_LIT>', DEFAULT_SRC_DIR);<EOL>    if (!path.isAbsolute(config.srcDir)) {<EOL>        config.srcDir = normalizePath(path.join(config.rootDir, config.srcDir));<EOL>    }<EOL>    setStringConfig(config, '<STR_LIT>', DEFAULT_WWW_DIR);<EOL>    if (!path.isAbsolute(config.wwwDir)) {<EOL>        config.wwwDir = normalizePath(path.join(config.rootDir, config.wwwDir));<EOL>    }<EOL>    setStringConfig(config, '<STR_LIT>', DEFAULT_BUILD_DIR);<EOL>    if (!path.isAbsolute(config.buildDir)) {<EOL>        config.buildDir = normalizePath(path.join(config.wwwDir, config.buildDir));<EOL>    }<EOL>    setStringConfig(config, '<STR_LIT>', DEFAULT_DIST_DIR);<EOL>    if (!path.isAbsolute(config.distDir)) {<EOL>        config.distDir = normalizePath(path.join(config.rootDir, config.distDir));<EOL>    }<EOL>    setStringConfig(config, '<STR_LIT>', DEFAULT_COLLECTION_DIR);<EOL>    if (!path.isAbsolute(config.collectionDir)) {<EOL>        config.collectionDir = normalizePath(path.join(config.distDir, config.collectionDir));<EOL>    }<EOL>    setStringConfig(config, '<STR_LIT>', DEFAULT_TSCONFIG);<EOL>    if (!path.isAbsolute(config.tsconfig)) {<EOL>        config.tsconfig = normalizePath(path.join(config.rootDir, config.tsconfig));<EOL>    }<EOL>    setStringConfig(config, '<STR_LIT>', DEFAULT_TYPES_DIR);<EOL>    if (!path.isAbsolute(config.typesDir)) {<EOL>        config.typesDir = normalizePath(path.join(config.distDir, config.typesDir));<EOL>    }<EOL>    setStringConfig(config, '<STR_LIT>', normalizePath(path.join(config.srcDir, DEFAULT_INDEX_HTML)));<EOL>    if (!path.isAbsolute(config.srcIndexHtml)) {<EOL>        config.srcIndexHtml = normalizePath(path.join(config.rootDir, config.srcIndexHtml));<EOL>    }<EOL>    setStringConfig(config, '<STR_LIT>', normalizePath(path.join(config.wwwDir, DEFAULT_INDEX_HTML)));<EOL>    if (!path.isAbsolute(config.wwwIndexHtml)) {<EOL>        config.wwwIndexHtml = normalizePath(path.join(config.wwwDir, config.wwwIndexHtml));<EOL>    }<EOL>    if (config.writeLog) {<EOL>        setStringConfig(config, '<STR_LIT>', DEFAULT_BUILD_LOG_FILE_NAME);<EOL>        if (!path.","gt":"isAbsolute(config.buildLogFilePath)) {"}
{"input":"<s> export function validatePaths(config: Config) {<EOL>    const path = config.sys.path;<EOL>    if (typeof (config as any).global === '<STR_LIT>') {<EOL>        <EOL>        config.logger.warn(`<STR_LIT>`);<EOL>        config.globalScript = (config as any).global;<EOL>    }<EOL>    if (typeof config.globalScript === '<STR_LIT>' && !path.isAbsolute(config.globalScript)) {<EOL>        config.globalScript = normalizePath(path.join(config.rootDir, config.globalScript));<EOL>    }<EOL>    if (typeof config.globalStyle === '<STR_LIT>') {<EOL>        config.globalStyle = [config.globalStyle];<EOL>    }<EOL>    if (Array.isArray(config.globalStyle)) {<EOL>        config.globalStyle = config.globalStyle.filter(globalStyle => typeof globalStyle === '<STR_LIT>');<EOL>        config.globalStyle = config.globalStyle.map(globalStyle => {<EOL>            if (path.isAbsolute(globalStyle)) {<EOL>                return normalizePath(globalStyle);<EOL>            }<EOL>            return normalizePath(path.join(config.rootDir, globalStyle));<EOL>        });<EOL>    }<EOL>    if (typeof (config as any).src === '<STR_LIT>') {<EOL>        <EOL>        config.logger.warn(`<STR_LIT>`);<EOL>        config.srcDir = (config as any).src;<EOL>    }<EOL>    setStringConfig(config, '<STR_LIT>', DEFAULT_SRC_DIR);<EOL>    if (!path.isAbsolute(config.srcDir)) {<EOL>        config.srcDir = normalizePath(path.join(config.rootDir, config.srcDir));<EOL>    }<EOL>    setStringConfig(config, '<STR_LIT>', DEFAULT_WWW_DIR);<EOL>    if (!path.isAbsolute(config.wwwDir)) {<EOL>        config.wwwDir = normalizePath(path.join(config.rootDir, config.wwwDir));<EOL>    }<EOL>    setStringConfig(config, '<STR_LIT>', DEFAULT_BUILD_DIR);<EOL>    if (!path.isAbsolute(config.buildDir)) {<EOL>        config.buildDir = normalizePath(path.join(config.wwwDir, config.buildDir));<EOL>    }<EOL>    setStringConfig(config, '<STR_LIT>', DEFAULT_DIST_DIR);<EOL>    if (!path.isAbsolute(config.distDir)) {<EOL>        config.distDir = normalizePath(path.join(config.rootDir, config.distDir));<EOL>    }<EOL>    setStringConfig(config, '<STR_LIT>', DEFAULT_COLLECTION_DIR);<EOL>    if (!path.isAbsolute(config.collectionDir)) {<EOL>        config.collectionDir = normalizePath(path.join(config.distDir, config.collectionDir));<EOL>    }<EOL>    setStringConfig(config, '<STR_LIT>', DEFAULT_TSCONFIG);<EOL>    if (!path.isAbsolute(config.tsconfig)) {<EOL>        config.tsconfig = normalizePath(path.join(config.rootDir, config.tsconfig));<EOL>    }<EOL>    setStringConfig(config, '<STR_LIT>', DEFAULT_TYPES_DIR);<EOL>    if (!path.isAbsolute(config.typesDir)) {<EOL>        config.typesDir = normalizePath(path.join(config.distDir, config.typesDir));<EOL>    }<EOL>    setStringConfig(config, '<STR_LIT>', normalizePath(path.join(config.srcDir, DEFAULT_INDEX_HTML)));<EOL>    if (!path.isAbsolute(config.srcIndexHtml)) {<EOL>        config.srcIndexHtml = normalizePath(path.join(config.rootDir, config.srcIndexHtml));<EOL>    }<EOL>    setStringConfig(config, '<STR_LIT>', normalizePath(path.join(config.wwwDir, DEFAULT_INDEX_HTML)));<EOL>    if (!path.isAbsolute(config.wwwIndexHtml)) {<EOL>        config.wwwIndexHtml = normalizePath(path.join(config.wwwDir, config.wwwIndexHtml));<EOL>    }<EOL>    if (config.writeLog) {<EOL>        setStringConfig(config, '<STR_LIT>', DEFAULT_BUILD_LOG_FILE_NAME);<EOL>        if (!path.isAbsolute(config.buildLogFilePath)) {<EOL>            config.buildLogFilePath =","gt":"normalizePath(path.join(config.rootDir, config.buildLogFilePath));"}
{"input":"<s> function Jupiter(): Body {<EOL>    return new Body(<NUM_LIT>, -<NUM_LIT>, -<NUM_LIT>, <NUM_LIT> * DAYS_PER_YEAR, <NUM_LIT> * DAYS_PER_YEAR, -<NUM_LIT> * DAYS_PER_YEAR, <NUM_LIT> *","gt":"SOLAR_MASS);"}
{"input":"<s> export async function processCopyTasks(config: Config, compilerCtx: CompilerCtx, allCopyTasks: CopyTask[], copyTask: CopyTask): Promise<any> {<EOL>    if (!copyTask) {<EOL>        <EOL>        return;<EOL>    }<EOL>    if (!copyTask.src) {<EOL>        throw new Error(`<STR_LIT>`);<EOL>    }<EOL>    if (copyTask.dest && config.sys.isGlob(copyTask.dest)) {<EOL>        throw new Error(`<STR_LIT>`);<EOL>    }<EOL>    if (config.sys.isGlob(copyTask.src)) {<EOL>        const copyTasks = await","gt":"processGlob(config, copyTask);"}
{"input":"<s> export async function processCopyTasks(config: Config, compilerCtx: CompilerCtx, allCopyTasks: CopyTask[], copyTask: CopyTask): Promise<any> {<EOL>    if (!copyTask) {<EOL>        <EOL>        return;<EOL>    }<EOL>    if (!copyTask.src) {<EOL>        throw new Error(`<STR_LIT>`);<EOL>    }<EOL>    if (copyTask.dest && config.sys.isGlob(copyTask.dest)) {<EOL>        throw new Error(`<STR_LIT>`);<EOL>    }<EOL>    if (config.sys.isGlob(copyTask.src)) {<EOL>        const copyTasks = await processGlob(config, copyTask);<EOL>        allCopyTasks.push(...copyTasks);<EOL>        return;<EOL>    }<EOL>    if (","gt":"config.generateWWW) {"}
{"input":"<s> /**<EOL> * Generates a condition statement that takes the whenTrue branch if the condition evaluates to a truthy value and to the whenFalse branch otherwise.<EOL> * The implementation optimizes conditions. E.g. && and || are optimized to not store the value and instead just evaluate<EOL> * if the expression is truthy (the value is not needed)<EOL> * @param condition the condition<EOL> * @param whenTrue the block to take if the condition is true<EOL> * @param whenFalse the block to take if the condition is false<EOL> * @param context the context<EOL> */<EOL>export function generateCondition(condition: ts.Node, whenTrue: llvm.BasicBlock, whenFalse: llvm.BasicBlock, context: CodeGenerationContext): void {<EOL>    if (condition.kind === ts.SyntaxKind.ParenthesizedExpression) {<EOL>        return generateCondition((condition as ts.ParenthesizedExpression).expression, whenTrue, whenFalse, context);<EOL>    }<EOL>    if (condition.kind === ts.SyntaxKind.BinaryExpression) {<EOL>        const binaryExpression = condition as ts.BinaryExpression;<EOL>        <EOL>        if (binaryExpression.","gt":"operatorToken.kind === ts.SyntaxKind.AmpersandAmpersandToken) {"}
{"input":"<s> /**<EOL> * Generates a condition statement that takes the whenTrue branch if the condition evaluates to a truthy value and to the whenFalse branch otherwise.<EOL> * The implementation optimizes conditions. E.g. && and || are optimized to not store the value and instead just evaluate<EOL> * if the expression is truthy (the value is not needed)<EOL> * @param condition the condition<EOL> * @param whenTrue the block to take if the condition is true<EOL> * @param whenFalse the block to take if the condition is false<EOL> * @param context the context<EOL> */<EOL>export function generateCondition(condition: ts.Node, whenTrue: llvm.BasicBlock, whenFalse: llvm.BasicBlock, context: CodeGenerationContext): void {<EOL>    if (condition.kind === ts.SyntaxKind.ParenthesizedExpression) {<EOL>        return generateCondition((condition as ts.ParenthesizedExpression).expression, whenTrue, whenFalse, context);<EOL>    }<EOL>    if (condition.kind === ts.SyntaxKind.BinaryExpression) {<EOL>        const binaryExpression = condition as ts.BinaryExpression;<EOL>        <EOL>        if (binaryExpression.operatorToken.kind === ts.SyntaxKind.AmpersandAmpersandToken) {<EOL>            const rhsBlock = llvm.BasicBlock.create(context.llvmContext, \"<STR_LIT>\");<EOL>            generateCondition(binaryExpression.left, rhsBlock, whenFalse, context);<EOL>            context.scope.enclosingFunction.addBasicBlock(rhsBlock);<EOL>            context.builder.","gt":"setInsertionPoint(rhsBlock);"}
{"input":"<s> /**<EOL> * Generates a condition statement that takes the whenTrue branch if the condition evaluates to a truthy value and to the whenFalse branch otherwise.<EOL> * The implementation optimizes conditions. E.g. && and || are optimized to not store the value and instead just evaluate<EOL> * if the expression is truthy (the value is not needed)<EOL> * @param condition the condition<EOL> * @param whenTrue the block to take if the condition is true<EOL> * @param whenFalse the block to take if the condition is false<EOL> * @param context the context<EOL> */<EOL>export function generateCondition(condition: ts.Node, whenTrue: llvm.BasicBlock, whenFalse: llvm.BasicBlock, context: CodeGenerationContext): void {<EOL>    if (condition.kind === ts.SyntaxKind.ParenthesizedExpression) {<EOL>        return generateCondition((condition as ts.ParenthesizedExpression).expression, whenTrue, whenFalse, context);<EOL>    }<EOL>    if (condition.kind === ts.SyntaxKind.BinaryExpression) {<EOL>        const binaryExpression = condition as ts.BinaryExpression;<EOL>        <EOL>        if (binaryExpression.operatorToken.kind === ts.SyntaxKind.AmpersandAmpersandToken) {<EOL>            const rhsBlock = llvm.BasicBlock.create(context.llvmContext, \"<STR_LIT>\");<EOL>            generateCondition(binaryExpression.left, rhsBlock, whenFalse, context);<EOL>            context.scope.enclosingFunction.addBasicBlock(rhsBlock);<EOL>            context.builder.setInsertionPoint(rhsBlock);<EOL>            generateCondition(binaryExpression.right, whenTrue, whenFalse, context);<EOL>            return;<EOL>        }<EOL>        else if (binaryExpression.operatorToken.kind === ts.SyntaxKind.BarBarToken) {<EOL>            const rhsBlock = llvm.BasicBlock.create(context.llvmContext, \"<STR_LIT>\");<EOL>            generateCondition(binaryExpression.left, whenTrue, rhsBlock, context);<EOL>            context.scope.enclosingFunction.addBasicBlock(rhsBlock);<EOL>            context.builder.","gt":"setInsertionPoint(rhsBlock);"}
{"input":"<s> /**<EOL> * Generates a condition statement that takes the whenTrue branch if the condition evaluates to a truthy value and to the whenFalse branch otherwise.<EOL> * The implementation optimizes conditions. E.g. && and || are optimized to not store the value and instead just evaluate<EOL> * if the expression is truthy (the value is not needed)<EOL> * @param condition the condition<EOL> * @param whenTrue the block to take if the condition is true<EOL> * @param whenFalse the block to take if the condition is false<EOL> * @param context the context<EOL> */<EOL>export function generateCondition(condition: ts.Node, whenTrue: llvm.BasicBlock, whenFalse: llvm.BasicBlock, context: CodeGenerationContext): void {<EOL>    if (condition.kind === ts.SyntaxKind.ParenthesizedExpression) {<EOL>        return generateCondition((condition as ts.ParenthesizedExpression).expression, whenTrue, whenFalse, context);<EOL>    }<EOL>    if (condition.kind === ts.SyntaxKind.BinaryExpression) {<EOL>        const binaryExpression = condition as ts.BinaryExpression;<EOL>        <EOL>        if (binaryExpression.operatorToken.kind === ts.SyntaxKind.AmpersandAmpersandToken) {<EOL>            const rhsBlock = llvm.BasicBlock.create(context.llvmContext, \"<STR_LIT>\");<EOL>            generateCondition(binaryExpression.left, rhsBlock, whenFalse, context);<EOL>            context.scope.enclosingFunction.addBasicBlock(rhsBlock);<EOL>            context.builder.setInsertionPoint(rhsBlock);<EOL>            generateCondition(binaryExpression.right, whenTrue, whenFalse, context);<EOL>            return;<EOL>        }<EOL>        else if (binaryExpression.operatorToken.kind === ts.SyntaxKind.BarBarToken) {<EOL>            const rhsBlock = llvm.BasicBlock.create(context.llvmContext, \"<STR_LIT>\");<EOL>            generateCondition(binaryExpression.left, whenTrue, rhsBlock, context);<EOL>            context.scope.enclosingFunction.addBasicBlock(rhsBlock);<EOL>            context.builder.setInsertionPoint(rhsBlock);<EOL>            generateCondition(binaryExpression.right, whenTrue, whenFalse, context);<EOL>            return;<EOL>        }<EOL>    }<EOL>    else if (condition.kind === ts.SyntaxKind.PrefixUnaryExpression) {<EOL>        const unaryExpression = condition as ts.PrefixUnaryExpression;<EOL>        if (unaryExpression.operator === ts.","gt":"SyntaxKind.ExclamationToken) {"}
{"input":"<s> async function percentImplicitCast() {<EOL>","gt":"\"<STR_LIT>\";"}
{"input":"<s> export function validate(input: string, key: string, validators: Validator[]) {<EOL>    const errors: ValidationError[] = [];<EOL>    for (const validator of validators) {<EOL>        const message = validator(input, key);<EOL>        if (","gt":"message !== true) {"}
{"input":"<s> export function validate(input: string, key: string, validators: Validator[]) {<EOL>    const errors: ValidationError[] = [];<EOL>    for (const validator of validators) {<EOL>        const message = validator(input, key);<EOL>        if (message !== true) {<EOL>            errors.push({ key, message, validator });<EOL>        }<EOL>    }<EOL>    if (errors.length >","gt":"<NUM_LIT>) {"}
{"input":"<s> async function processCopyTaskDestDir(config: Config, compilerCtx: CompilerCtx, allCopyTasks: CopyTask[], copyTask: CopyTask, destAbsDir: string) {<EOL>    const processedCopyTask = processCopyTask(config, copyTask, destAbsDir);<EOL>    try {<EOL>        const stats = await compilerCtx.fs.stat(processedCopyTask.src);<EOL>        processedCopyTask.isDirectory =","gt":"stats.isDirectory;"}
{"input":"<s> async function processCopyTaskDestDir(config: Config, compilerCtx: CompilerCtx, allCopyTasks: CopyTask[], copyTask: CopyTask, destAbsDir: string) {<EOL>    const processedCopyTask = processCopyTask(config, copyTask, destAbsDir);<EOL>    try {<EOL>        const stats = await compilerCtx.fs.stat(processedCopyTask.src);<EOL>        processedCopyTask.isDirectory = stats.isDirectory;<EOL>        config.logger.debug(`<STR_LIT>`);<EOL>        allCopyTasks.push(processedCopyTask);<EOL>    }<EOL>    catch (e) {<EOL>        if (copyTask.warn !== false) {<EOL>            config.logger.","gt":"warn(`<STR_LIT>`);"}
{"input":"<s> export async function simjs(seed: int, runs: int) {<EOL>    \"<STR_LIT>\";<EOL>    const random = new Random(seed);<EOL>","gt":"let sum = <NUM_LIT>;"}
{"input":"<s> export function createExportedWidget3() {<EOL>    return Widgets1.","gt":"createWidget3();"}
{"input":"<s> export function parseExpression(content: string): SyntaxTree.Expression {<EOL>    let result: SyntaxTree.Expression = null;<EOL>    try {<EOL>        result = parser_pegjs.parse(content, { startRule: \"<STR_LIT>\" }) as SyntaxTree.Expression;<EOL>    }<EOL>    catch (e) {<EOL>        if (e.location) {<EOL>            throw new ParseError(e.message, e.location.start, e.location.end);<EOL>        }<EOL>        else {<EOL>            throw new","gt":"ParseError(e.message);"}
{"input":"<s> export function getTypeConversion(srcType: string, destType: string): TypeConversionInfo {<EOL>    return typeConversions.get(","gt":"}:${destType}`<STR_LIT>;"}
{"input":"<s> export function greaterThan(a1: Specification.Expression, a2: Specification.Expression) {<EOL>    return op(\"<STR_LIT>\", \"<STR_LIT>\",","gt":"a1, a2);"}
{"input":"<s> export function pauseAutoplay(s: Slides, plt: Platform, speed?: number) {<EOL>    if (s._autoplayPaused)<EOL>        return;<EOL>    if (s._autoplayTimeoutId)<EOL>        clearTimeout(s._autoplayTimeoutId);<EOL>    s._autoplayPaused =","gt":"true;"}
{"input":"<s> export function pauseAutoplay(s: Slides, plt: Platform, speed?: number) {<EOL>    if (s._autoplayPaused)<EOL>        return;<EOL>    if (s._autoplayTimeoutId)<EOL>        clearTimeout(s._autoplayTimeoutId);<EOL>    s._autoplayPaused = true;<EOL>    if (speed === <NUM_LIT>) {<EOL>        s._autoplayPaused =","gt":"false;"}
{"input":"<s> export function pauseAutoplay(s: Slides, plt: Platform, speed?: number) {<EOL>    if (s._autoplayPaused)<EOL>        return;<EOL>    if (s._autoplayTimeoutId)<EOL>        clearTimeout(s._autoplayTimeoutId);<EOL>    s._autoplayPaused = true;<EOL>    if (speed === <NUM_LIT>) {<EOL>        s._autoplayPaused = false;<EOL>        autoplay(s, plt);<EOL>    }<EOL>    else {<EOL>        plt.transitionEnd(s._wrapper, () => {<EOL>","gt":"if (!s)"}
{"input":"<s> export async function doAdd(config: Config, platformName: string) {<EOL>    await runTask(chalk `<STR_LIT>`, async () => {<EOL>        if (platformName === config.ios.name) {<EOL>","gt":"await addIOS(config);"}
{"input":"<s> function f18() {<EOL>","gt":"return \"<STR_LIT>\";"}
{"input":"<s> async function callExpression17() {<EOL>    (await x)[a](y,","gt":"z);"}
{"input":"<s> /**<EOL> * Create a task that serves a given directory in the project.<EOL> * The server rewrites all node_module/ or dist/ requests to the correct directory.<EOL> */<EOL>export function serverTask(packagePath: string, livereload = true) {<EOL>    <EOL>    const relativePath = path.relative(projectDir, packagePath);<EOL>    return () => {<EOL>        gulpConnect.server({<EOL>            root: projectDir,<EOL>            livereload:","gt":"livereload,"}
{"input":"<s> /**<EOL> * Create a task that serves a given directory in the project.<EOL> * The server rewrites all node_module/ or dist/ requests to the correct directory.<EOL> */<EOL>export function serverTask(packagePath: string, livereload = true) {<EOL>    <EOL>    const relativePath = path.relative(projectDir, packagePath);<EOL>    return () => {<EOL>        gulpConnect.server({<EOL>            root: projectDir,<EOL>            livereload: livereload,<EOL>            port: <NUM_LIT>,<EOL>            fallback: path.join(packagePath, '<STR_LIT>'),<EOL>            middleware: () => {<EOL>                return [httpRewrite.","gt":"getMiddleware(["}
{"input":"<s> /**<EOL> * Create a task that serves a given directory in the project.<EOL> * The server rewrites all node_module/ or dist/ requests to the correct directory.<EOL> */<EOL>export function serverTask(packagePath: string, livereload = true) {<EOL>    <EOL>    const relativePath = path.relative(projectDir, packagePath);<EOL>    return () => {<EOL>        gulpConnect.server({<EOL>            root: projectDir,<EOL>            livereload: livereload,<EOL>            port: <NUM_LIT>,<EOL>            fallback: path.join(packagePath, '<STR_LIT>'),<EOL>            middleware: () => {<EOL>                return [httpRewrite.getMiddleware([<EOL>                        { from: '<STR_LIT>', to: '<STR_LIT>' },<EOL>                        { from: '<STR_LIT>', to: '<STR_LIT>' },<EOL>                        { from: '<STR_LIT>', to:","gt":"relativePath}/$1` }"}
{"input":"<s> async function breakToLabelWithReturnInNormalEnd() {<EOL>    \"<STR_LIT>\";<EOL>    let i = <NUM_LIT>;<EOL>    <EOL>","gt":"outer_block: {"}
{"input":"<s> function yieldString() {<EOL>    yield","gt":"'<STR_LIT>';"}
{"input":"<s> function foo1({ skills: { primary: primaryA, secondary: secondaryA } }: Robot) {<EOL>    console.log(","gt":"primaryA);"}
{"input":"<s> export function rebuild(config: Config, compilerCtx: CompilerCtx, watcher: WatcherResults): Promise<BuildResults> {<EOL>    <EOL>    printWatcherMessage(config, watcher);<EOL>    if (watcher.","gt":"configUpdated) {"}
{"input":"<s> export async function runPluginTransforms(config: Config, compilerCtx: CompilerCtx, buildCtx: BuildCtx, id: string) {<EOL>    const pluginCtx: PluginCtx = {<EOL>        config: config,<EOL>        sys: config.sys,<EOL>","gt":"fs: compilerCtx.fs,"}
{"input":"<s> export async function runPluginTransforms(config: Config, compilerCtx: CompilerCtx, buildCtx: BuildCtx, id: string) {<EOL>    const pluginCtx: PluginCtx = {<EOL>        config: config,<EOL>        sys: config.sys,<EOL>        fs: compilerCtx.fs,<EOL>        cache: compilerCtx.cache,<EOL>","gt":"diagnostics: []"}
{"input":"<s> export async function runPluginTransforms(config: Config, compilerCtx: CompilerCtx, buildCtx: BuildCtx, id: string) {<EOL>    const pluginCtx: PluginCtx = {<EOL>        config: config,<EOL>        sys: config.sys,<EOL>        fs: compilerCtx.fs,<EOL>        cache: compilerCtx.cache,<EOL>        diagnostics: []<EOL>    };<EOL>    const resolvedId = await runPluginResolveId(pluginCtx, id);<EOL>    const sourceText =","gt":"await runPluginLoad(pluginCtx, resolvedId);"}
{"input":"<s> export async function runPluginTransforms(config: Config, compilerCtx: CompilerCtx, buildCtx: BuildCtx, id: string) {<EOL>    const pluginCtx: PluginCtx = {<EOL>        config: config,<EOL>        sys: config.sys,<EOL>        fs: compilerCtx.fs,<EOL>        cache: compilerCtx.cache,<EOL>        diagnostics: []<EOL>    };<EOL>    const resolvedId = await runPluginResolveId(pluginCtx, id);<EOL>    const sourceText = await runPluginLoad(pluginCtx, resolvedId);<EOL>    const transformResults: PluginTransformResults = {<EOL>        code: sourceText,<EOL>        id: id<EOL>    };<EOL>    for (const plugin of pluginCtx.config.plugins) {<EOL>        if (typeof plugin.","gt":"transform === '<STR_LIT>') {"}
{"input":"<s> export async function runPluginTransforms(config: Config, compilerCtx: CompilerCtx, buildCtx: BuildCtx, id: string) {<EOL>    const pluginCtx: PluginCtx = {<EOL>        config: config,<EOL>        sys: config.sys,<EOL>        fs: compilerCtx.fs,<EOL>        cache: compilerCtx.cache,<EOL>        diagnostics: []<EOL>    };<EOL>    const resolvedId = await runPluginResolveId(pluginCtx, id);<EOL>    const sourceText = await runPluginLoad(pluginCtx, resolvedId);<EOL>    const transformResults: PluginTransformResults = {<EOL>        code: sourceText,<EOL>        id: id<EOL>    };<EOL>    for (const plugin of pluginCtx.config.plugins) {<EOL>        if (typeof plugin.transform === '<STR_LIT>') {<EOL>            try {<EOL>                let pluginTransformResults: PluginTransformResults;<EOL>                const results = plugin.transform(transformResults.code, transformResults.id, pluginCtx);<EOL>                if (results != null) {<EOL>","gt":"if (typeof results.then === '<STR_LIT>') {"}
{"input":"<s> export async function runPluginTransforms(config: Config, compilerCtx: CompilerCtx, buildCtx: BuildCtx, id: string) {<EOL>    const pluginCtx: PluginCtx = {<EOL>        config: config,<EOL>        sys: config.sys,<EOL>        fs: compilerCtx.fs,<EOL>        cache: compilerCtx.cache,<EOL>        diagnostics: []<EOL>    };<EOL>    const resolvedId = await runPluginResolveId(pluginCtx, id);<EOL>    const sourceText = await runPluginLoad(pluginCtx, resolvedId);<EOL>    const transformResults: PluginTransformResults = {<EOL>        code: sourceText,<EOL>        id: id<EOL>    };<EOL>    for (const plugin of pluginCtx.config.plugins) {<EOL>        if (typeof plugin.transform === '<STR_LIT>') {<EOL>            try {<EOL>                let pluginTransformResults: PluginTransformResults;<EOL>                const results = plugin.transform(transformResults.code, transformResults.id, pluginCtx);<EOL>                if (results != null) {<EOL>                    if (typeof results.then === '<STR_LIT>') {<EOL>                        pluginTransformResults = await results;<EOL>                    }<EOL>                    else {<EOL>                        pluginTransformResults = results as PluginTransformResults;<EOL>                    }<EOL>                    if (","gt":"pluginTransformResults != null) {"}
{"input":"<s> export async function runPluginTransforms(config: Config, compilerCtx: CompilerCtx, buildCtx: BuildCtx, id: string) {<EOL>    const pluginCtx: PluginCtx = {<EOL>        config: config,<EOL>        sys: config.sys,<EOL>        fs: compilerCtx.fs,<EOL>        cache: compilerCtx.cache,<EOL>        diagnostics: []<EOL>    };<EOL>    const resolvedId = await runPluginResolveId(pluginCtx, id);<EOL>    const sourceText = await runPluginLoad(pluginCtx, resolvedId);<EOL>    const transformResults: PluginTransformResults = {<EOL>        code: sourceText,<EOL>        id: id<EOL>    };<EOL>    for (const plugin of pluginCtx.config.plugins) {<EOL>        if (typeof plugin.transform === '<STR_LIT>') {<EOL>            try {<EOL>                let pluginTransformResults: PluginTransformResults;<EOL>                const results = plugin.transform(transformResults.code, transformResults.id, pluginCtx);<EOL>                if (results != null) {<EOL>                    if (typeof results.then === '<STR_LIT>') {<EOL>                        pluginTransformResults = await results;<EOL>                    }<EOL>                    else {<EOL>                        pluginTransformResults = results as PluginTransformResults;<EOL>                    }<EOL>                    if (pluginTransformResults != null) {<EOL>                        if (typeof pluginTransformResults === '<STR_LIT>') {<EOL>                            transformResults.code = pluginTransformResults as string;<EOL>                        }<EOL>                        else {<EOL>                            if (typeof pluginTransformResults.code === '<STR_LIT>') {<EOL>                                transformResults.code = pluginTransformResults.code;<EOL>                            }<EOL>                            if (typeof pluginTransformResults.id === '<STR_LIT>') {<EOL>                                transformResults.id = pluginTransformResults.id;<EOL>                            }<EOL>                        }<EOL>                    }<EOL>                }<EOL>            }<EOL>            catch (e) {<EOL>","gt":"const d = catchError(buildCtx.diagnostics, e);"}
{"input":"<s> <EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL>function getVerify(isTypeLocation?: boolean) {<EOL>    return {<EOL>        verifyValue: isTypeLocation ? verify.","gt":"not : verify,"}
{"input":"<s> function mockXMLParse(func) {<EOL>    return prequire(\"<STR_LIT>\", {<EOL>        \"<STR_LIT>\": {<EOL>            default: {<EOL>                parseXML: (","gt":"srcHtml) => {"}
{"input":"<s> export function readXML(path: string): Promise<any> {<EOL>    return new Promise((resolve, reject) => {<EOL>        readFile(path, '<STR_LIT>', async (err, xmlStr) => {<EOL>            if (err) {<EOL>                reject(`<STR_LIT>`);<EOL>            }<EOL>","gt":"else {"}
{"input":"<s> export function readXML(path: string): Promise<any> {<EOL>    return new Promise((resolve, reject) => {<EOL>        readFile(path, '<STR_LIT>', async (err, xmlStr) => {<EOL>            if (err) {<EOL>                reject(`<STR_LIT>`);<EOL>            }<EOL>            else {<EOL>                const xml2js = await import('<STR_LIT>');<EOL>                xml2js.parseString(xmlStr, (err, result) => {<EOL>                    if (err) {<EOL>                        reject(","gt":"err}`<STR_LIT>;"}
{"input":"<s> async function addInts(x: int, y: int) {<EOL>","gt":"\"<STR_LIT>\";"}
{"input":"<s> function goToMarkAndGeneralVerify(marker: string) {<EOL>    goTo.marker(marker);<EOL>    verify.not.completionListContains('<STR_LIT>');<EOL>    verify.not.completionListContains('<STR_LIT>');<EOL>","gt":"verify.not.completionListContains('<STR_LIT>');"}
{"input":"<s> function goToMarkAndGeneralVerify(marker: string) {<EOL>    goTo.marker(marker);<EOL>    verify.not.completionListContains('<STR_LIT>');<EOL>    verify.not.completionListContains('<STR_LIT>');<EOL>    verify.not.completionListContains('<STR_LIT>');<EOL>    verify.not.completionListContains('<STR_LIT>');<EOL>    verify.not.completionListContains('<STR_LIT>');<EOL>    verify.not.completionListContains('<STR_LIT>');<EOL>    verify.not.completionListContains('<STR_LIT>');<EOL>    verify.not.completionListContains('<STR_LIT>');<EOL>    verify.not.","gt":"completionListContains('<STR_LIT>');"}
{"input":"<s> export function isInstanceOfObjectMap(object: any): object is ObjectMap {<EOL>    return (!object.hasOwnProperty('<STR_LIT>') &&<EOL>        !object.hasOwnProperty(","gt":"'<STR_LIT>') &&"}
{"input":"<s> function handleColorsChanged() {<EOL>    var UIColorType = _WinRT.Windows.UI.ViewManagement.UIColorType;<EOL>    var uiColor = UISettings.getColorValue(_WinRT.Windows.UI.ViewManagement.UIColorType.accent);<EOL>    var accent = colorToString(uiColor, <NUM_LIT>);<EOL>    if (","gt":"colors[<NUM_LIT>] === accent) {"}
{"input":"<s> function handleColorsChanged() {<EOL>    var UIColorType = _WinRT.Windows.UI.ViewManagement.UIColorType;<EOL>    var uiColor = UISettings.getColorValue(_WinRT.Windows.UI.ViewManagement.UIColorType.accent);<EOL>    var accent = colorToString(uiColor, <NUM_LIT>);<EOL>    if (colors[<NUM_LIT>] === accent) {<EOL>        return;<EOL>    }<EOL>    <EOL>    <EOL>    colors.","gt":"length = <NUM_LIT>;"}
{"input":"<s> async function forInStatement8() {<EOL>    for (var c","gt":"in y) {"}
{"input":"<s> async function runNextPrerenderUrl(config: Config, compilerCtx: CompilerCtx, buildCtx: BuildCtx, prerenderQueue: PrerenderLocation[], indexSrcHtml: string, hydrateResults: HydrateResults[], resolve: Function) {<EOL>    const p = prerenderQueue.find(p => p.status === '<STR_LIT>');<EOL>    if (!p)<EOL>        return;<EOL>    <EOL>    <EOL>    p.status = '<STR_LIT>';<EOL>    try {<EOL>        <EOL>        const results = await prerenderPath(config,","gt":"compilerCtx, buildCtx, indexSrcHtml, p);"}
{"input":"<s> async function runNextPrerenderUrl(config: Config, compilerCtx: CompilerCtx, buildCtx: BuildCtx, prerenderQueue: PrerenderLocation[], indexSrcHtml: string, hydrateResults: HydrateResults[], resolve: Function) {<EOL>    const p = prerenderQueue.find(p => p.status === '<STR_LIT>');<EOL>    if (!p)<EOL>        return;<EOL>    <EOL>    <EOL>    p.status = '<STR_LIT>';<EOL>    try {<EOL>        <EOL>        const results = await prerenderPath(config, compilerCtx, buildCtx, indexSrcHtml, p);<EOL>        <EOL>        <EOL>        config.logger.","gt":"printDiagnostics(results.diagnostics);"}
{"input":"<s> async function runNextPrerenderUrl(config: Config, compilerCtx: CompilerCtx, buildCtx: BuildCtx, prerenderQueue: PrerenderLocation[], indexSrcHtml: string, hydrateResults: HydrateResults[], resolve: Function) {<EOL>    const p = prerenderQueue.find(p => p.status === '<STR_LIT>');<EOL>    if (!p)<EOL>        return;<EOL>    <EOL>    <EOL>    p.status = '<STR_LIT>';<EOL>    try {<EOL>        <EOL>        const results = await prerenderPath(config, compilerCtx, buildCtx, indexSrcHtml, p);<EOL>        <EOL>        <EOL>        config.logger.printDiagnostics(results.diagnostics);<EOL>        if ((config.prerender as PrerenderConfig).crawl !== false) {<EOL>            crawlAnchorsForNextUrls(config, prerenderQueue, results);<EOL>        }<EOL>        hydrateResults.push(results);<EOL>        await writePrerenderDest(config, compilerCtx, results);<EOL>    }<EOL>    catch (e) {<EOL>        <EOL>        catchError(buildCtx.","gt":"diagnostics, e);"}
{"input":"<s> async function ampersand() {<EOL>    \"<STR_LIT>\";<EOL>","gt":"<NUM_LIT> & <NUM_LIT>;"}
{"input":"<s> <EOL><EOL><EOL><EOL><EOL><EOL><EOL>function cancelablePromise(animationPromise: Promise<any>) {<EOL>    return Promise._cancelBlocker(","gt":"animationPromise, function () {"}
{"input":"<s> async function writePrerenderDest(config: Config, ctx: CompilerCtx, results: HydrateResults) {<EOL>    const parsedUrl = config.sys.url.parse(results.url);<EOL>    <EOL>    const dir = config.sys.path.join((config.prerender as PrerenderConfig).","gt":"prerenderDir, parsedUrl.pathname);"}
{"input":"<s> async function powEqualsNumbers(base: number, exponent: number) {<EOL>","gt":"\"<STR_LIT>\";"}
{"input":"<s> async function createBundleJsText(config: Config, compilerCtx: CompilerCtx, buildCtx: BuildCtx, entryModules: EntryModule, jsText: string, modeName: string, isScopedStyles: boolean, sourceTarget?: SourceTarget) {<EOL>    if (sourceTarget === '<STR_LIT>') {<EOL>        <EOL>        <EOL>        jsText = await transpileEs5Bundle(compilerCtx, buildCtx, jsText);<EOL>    }<EOL>    if (config.","gt":"minifyJs) {"}
{"input":"<s> async function createBundleJsText(config: Config, compilerCtx: CompilerCtx, buildCtx: BuildCtx, entryModules: EntryModule, jsText: string, modeName: string, isScopedStyles: boolean, sourceTarget?: SourceTarget) {<EOL>    if (sourceTarget === '<STR_LIT>') {<EOL>        <EOL>        <EOL>        jsText = await transpileEs5Bundle(compilerCtx, buildCtx, jsText);<EOL>    }<EOL>    if (config.minifyJs) {<EOL>        <EOL>        const minifyJsResults = await minifyJs(config, compilerCtx, jsText, sourceTarget, true);<EOL>        if (minifyJsResults.diagnostics.length) {<EOL>            minifyJsResults.diagnostics.","gt":"forEach(d => {"}
{"input":"<s> async function createBundleJsText(config: Config, compilerCtx: CompilerCtx, buildCtx: BuildCtx, entryModules: EntryModule, jsText: string, modeName: string, isScopedStyles: boolean, sourceTarget?: SourceTarget) {<EOL>    if (sourceTarget === '<STR_LIT>') {<EOL>        <EOL>        <EOL>        jsText = await transpileEs5Bundle(compilerCtx, buildCtx, jsText);<EOL>    }<EOL>    if (config.minifyJs) {<EOL>        <EOL>        const minifyJsResults = await minifyJs(config, compilerCtx, jsText, sourceTarget, true);<EOL>        if (minifyJsResults.diagnostics.length) {<EOL>            minifyJsResults.diagnostics.forEach(d => {<EOL>                buildCtx.diagnostics.push(d);<EOL>            });<EOL>        }<EOL>","gt":"else {"}
{"input":"<s> export function isIntegrationName(name: string): name is IntegrationName {<EOL>","gt":"const n = <IntegrationName>name;"}
{"input":"<s> async function arrayLiteral7() {<EOL>    x = [await y, z, await","gt":"a];"}
{"input":"<s> export async function prerenderPath(config: Config, compilerCtx: CompilerCtx, buildCtx: BuildCtx, indexSrcHtml: string, prerenderLocation: PrerenderLocation) {<EOL>    const msg = (config.prerender as PrerenderConfig).hydrateComponents ? '<STR_LIT>' : '<STR_LIT>';<EOL>    const timeSpan = config.logger.createTimeSpan(`<STR_LIT>`);<EOL>    const results: HydrateResults = {<EOL>        diagnostics: []<EOL>    };<EOL>","gt":"try {"}
{"input":"<s> export async function prerenderPath(config: Config, compilerCtx: CompilerCtx, buildCtx: BuildCtx, indexSrcHtml: string, prerenderLocation: PrerenderLocation) {<EOL>    const msg = (config.prerender as PrerenderConfig).hydrateComponents ? '<STR_LIT>' : '<STR_LIT>';<EOL>    const timeSpan = config.logger.createTimeSpan(`<STR_LIT>`);<EOL>    const results: HydrateResults = {<EOL>        diagnostics: []<EOL>    };<EOL>    try {<EOL>        <EOL>        const rendererConfig = Object.assign({}, config);<EOL>        <EOL>        const hydrateOpts: HydrateOptions = rendererConfig.prerender as HydrateOptions;<EOL>        hydrateOpts.url = prerenderLocation.url;<EOL>","gt":"hydrateOpts.isPrerender = true;"}
{"input":"<s> export async function prerenderPath(config: Config, compilerCtx: CompilerCtx, buildCtx: BuildCtx, indexSrcHtml: string, prerenderLocation: PrerenderLocation) {<EOL>    const msg = (config.prerender as PrerenderConfig).hydrateComponents ? '<STR_LIT>' : '<STR_LIT>';<EOL>    const timeSpan = config.logger.createTimeSpan(`<STR_LIT>`);<EOL>    const results: HydrateResults = {<EOL>        diagnostics: []<EOL>    };<EOL>    try {<EOL>        <EOL>        const rendererConfig = Object.assign({}, config);<EOL>        <EOL>        const hydrateOpts: HydrateOptions = rendererConfig.prerender as HydrateOptions;<EOL>        hydrateOpts.url = prerenderLocation.url;<EOL>        hydrateOpts.isPrerender = true;<EOL>        <EOL>        hydrateOpts.html = indexSrcHtml;<EOL>        <EOL>        const renderer =","gt":"new Renderer(rendererConfig, null, compilerCtx);"}
{"input":"<s> export async function prerenderPath(config: Config, compilerCtx: CompilerCtx, buildCtx: BuildCtx, indexSrcHtml: string, prerenderLocation: PrerenderLocation) {<EOL>    const msg = (config.prerender as PrerenderConfig).hydrateComponents ? '<STR_LIT>' : '<STR_LIT>';<EOL>    const timeSpan = config.logger.createTimeSpan(`<STR_LIT>`);<EOL>    const results: HydrateResults = {<EOL>        diagnostics: []<EOL>    };<EOL>    try {<EOL>        <EOL>        const rendererConfig = Object.assign({}, config);<EOL>        <EOL>        const hydrateOpts: HydrateOptions = rendererConfig.prerender as HydrateOptions;<EOL>        hydrateOpts.url = prerenderLocation.url;<EOL>        hydrateOpts.isPrerender = true;<EOL>        <EOL>        hydrateOpts.html = indexSrcHtml;<EOL>        <EOL>        const renderer = new Renderer(rendererConfig, null, compilerCtx);<EOL>        <EOL>        <EOL>        const hydratedResults = await renderer.hydrate(hydrateOpts);<EOL>        <EOL>        <EOL>","gt":"Object.assign(results, hydratedResults);"}
{"input":"<s> function groupForValuePredicate(value) {<EOL>","gt":"\"<STR_LIT>\";"}
{"input":"<s> async function boolGreaterThanEquals(x: boolean, y: boolean) {<EOL>","gt":"\"<STR_LIT>\";"}
{"input":"<s> export async function monteCarlo() {<EOL>","gt":"\"<STR_LIT>\";"}
{"input":"<s> async function numberAssignment(value: number) {<EOL>    \"<STR_LIT>\";<EOL>    let","gt":"result: number;"}
{"input":"<s> export function logWarn(...args: any[]) {<EOL>    const chalk = require(","gt":"'<STR_LIT>');"}
{"input":"<s> <EOL>function f1(a: <T>() => keyof T, b: <U>() => keyof U) {<EOL>    a =","gt":"b;"}
{"input":"<s> <EOL>function f() {<EOL>    return function (s) {<EOL>","gt":"var x = s;"}
{"input":"<s> function writeFileInMemory(config: Config, ctx: CompilerCtx, sourceFile: ts.SourceFile, distFilePath: string, outputText: string) {<EOL>    let tsFilePath = normalizePath(sourceFile.fileName);<EOL>    if (!config.sys.path.isAbsolute(tsFilePath)) {<EOL>        tsFilePath = normalizePath(config.sys.path.join(config.","gt":"rootDir, tsFilePath));"}
{"input":"<s> function writeFileInMemory(config: Config, ctx: CompilerCtx, sourceFile: ts.SourceFile, distFilePath: string, outputText: string) {<EOL>    let tsFilePath = normalizePath(sourceFile.fileName);<EOL>    if (!config.sys.path.isAbsolute(tsFilePath)) {<EOL>        tsFilePath = normalizePath(config.sys.path.join(config.rootDir, tsFilePath));<EOL>    }<EOL>    distFilePath = normalizePath(distFilePath);<EOL>    <EOL>    <EOL>    <EOL>    <EOL>    const isInMemoryOnly = !config.generateDistribution;<EOL>    <EOL>    if (!ctx.moduleFiles[tsFilePath]) {<EOL>        <EOL>        ctx.moduleFiles[","gt":"tsFilePath] = {};"}
{"input":"<s> function writeFileInMemory(config: Config, ctx: CompilerCtx, sourceFile: ts.SourceFile, distFilePath: string, outputText: string) {<EOL>    let tsFilePath = normalizePath(sourceFile.fileName);<EOL>    if (!config.sys.path.isAbsolute(tsFilePath)) {<EOL>        tsFilePath = normalizePath(config.sys.path.join(config.rootDir, tsFilePath));<EOL>    }<EOL>    distFilePath = normalizePath(distFilePath);<EOL>    <EOL>    <EOL>    <EOL>    <EOL>    const isInMemoryOnly = !config.generateDistribution;<EOL>    <EOL>    if (!ctx.moduleFiles[tsFilePath]) {<EOL>        <EOL>        ctx.moduleFiles[tsFilePath] = {};<EOL>    }<EOL>    <EOL>    if (isJsFile(distFilePath)) {<EOL>        <EOL>        ctx.moduleFiles[tsFilePath].","gt":"jsFilePath = distFilePath;"}
{"input":"<s> export function validateComponentTag(tag: string) {<EOL>    if (typeof tag !== '<STR_LIT>') {<EOL>        throw new Error(`<STR_LIT>`);<EOL>    }<EOL>    tag = tag.trim().toLowerCase();<EOL>    if (tag.length === <NUM_LIT>) {<EOL>        throw new","gt":"Error(`<STR_LIT>`);"}
{"input":"<s> /**<EOL> * create a simple clone from the input used for storage of firstInput and firstMultiple<EOL> * @param {Object} input<EOL> * @returns {Object} clonedInputData<EOL> */<EOL>function simpleCloneInputData(input: any) {<EOL>    <EOL>    <EOL>    var pointers: any = [];<EOL>    var i = <NUM_LIT>;<EOL>    while (i < input.pointers.length) {<EOL>        pointers[","gt":"i] = {"}
{"input":"<s> /**<EOL> * create a simple clone from the input used for storage of firstInput and firstMultiple<EOL> * @param {Object} input<EOL> * @returns {Object} clonedInputData<EOL> */<EOL>function simpleCloneInputData(input: any) {<EOL>    <EOL>    <EOL>    var pointers: any = [];<EOL>    var i = <NUM_LIT>;<EOL>    while (i < input.pointers.length) {<EOL>        pointers[i] = {<EOL>            clientX: round(input.pointers[i].clientX),<EOL>            clientY: round(input.pointers[i].clientY)<EOL>        };<EOL>","gt":"i++;"}
{"input":"<s> /**<EOL> * create a simple clone from the input used for storage of firstInput and firstMultiple<EOL> * @param {Object} input<EOL> * @returns {Object} clonedInputData<EOL> */<EOL>function simpleCloneInputData(input: any) {<EOL>    <EOL>    <EOL>    var pointers: any = [];<EOL>    var i = <NUM_LIT>;<EOL>    while (i < input.pointers.length) {<EOL>        pointers[i] = {<EOL>            clientX: round(input.pointers[i].clientX),<EOL>            clientY: round(input.pointers[i].clientY)<EOL>        };<EOL>        i++;<EOL>    }<EOL>    return {<EOL>        timeStamp: now(),<EOL>","gt":"pointers: pointers,"}
{"input":"<s> function getComponentDepsFromImports(moduleGraphs: ModuleGraph[], componentRefs: ComponentRef[], importsInspected: string[], moduleGraph: ModuleGraph, cmpMeta: ComponentMeta) {<EOL>    moduleGraph.importPaths.forEach(importPath => {<EOL>        if (importsInspected.includes(importPath)) {<EOL>            return;<EOL>        }<EOL>        importsInspected.push(importPath);<EOL>        const subModuleGraph = moduleGraphs.find(mg => {<EOL>            return (mg.filePath ===","gt":"importPath) ||"}
{"input":"<s> function getComponentDepsFromImports(moduleGraphs: ModuleGraph[], componentRefs: ComponentRef[], importsInspected: string[], moduleGraph: ModuleGraph, cmpMeta: ComponentMeta) {<EOL>    moduleGraph.importPaths.forEach(importPath => {<EOL>        if (importsInspected.includes(importPath)) {<EOL>            return;<EOL>        }<EOL>        importsInspected.push(importPath);<EOL>        const subModuleGraph = moduleGraphs.find(mg => {<EOL>            return (mg.filePath === importPath) ||<EOL>                (mg.filePath === importPath + '<STR_LIT>') ||<EOL>                (mg.filePath === importPath + '<STR_LIT>') ||<EOL>                (mg.filePath === importPath + '<STR_LIT>');<EOL>        });<EOL>","gt":"if (subModuleGraph) {"}
{"input":"<s> function getComponentDepsFromImports(moduleGraphs: ModuleGraph[], componentRefs: ComponentRef[], importsInspected: string[], moduleGraph: ModuleGraph, cmpMeta: ComponentMeta) {<EOL>    moduleGraph.importPaths.forEach(importPath => {<EOL>        if (importsInspected.includes(importPath)) {<EOL>            return;<EOL>        }<EOL>        importsInspected.push(importPath);<EOL>        const subModuleGraph = moduleGraphs.find(mg => {<EOL>            return (mg.filePath === importPath) ||<EOL>                (mg.filePath === importPath + '<STR_LIT>') ||<EOL>                (mg.filePath === importPath + '<STR_LIT>') ||<EOL>                (mg.filePath === importPath + '<STR_LIT>');<EOL>        });<EOL>        if (subModuleGraph) {<EOL>            const tags = componentRefs.filter(cr => cr.filePath === subModuleGraph.filePath).map(cr => cr.tag);<EOL>            tags.forEach(tag => {<EOL>                if (!cmpMeta.dependencies.includes(tag)) {<EOL>                    cmpMeta.","gt":"dependencies.push(tag);"}
{"input":"<s> /**<EOL> * The full TS build for all app files.<EOL> */<EOL>export function transpileWorker(context: BuildContext, workerConfig: TranspileWorkerConfig) {<EOL>    <EOL>    return new Promise((resolve, reject) => {<EOL>        clearDiagnostics(context, DiagnosticsType.","gt":"TypeScript);"}
{"input":"<s> /**<EOL> * The full TS build for all app files.<EOL> */<EOL>export function transpileWorker(context: BuildContext, workerConfig: TranspileWorkerConfig) {<EOL>    <EOL>    return new Promise((resolve, reject) => {<EOL>        clearDiagnostics(context, DiagnosticsType.TypeScript);<EOL>        <EOL>        const tsConfig = getTsConfig(context, workerConfig.","gt":"configFile);"}
{"input":"<s> /**<EOL> * The full TS build for all app files.<EOL> */<EOL>export function transpileWorker(context: BuildContext, workerConfig: TranspileWorkerConfig) {<EOL>    <EOL>    return new Promise((resolve, reject) => {<EOL>        clearDiagnostics(context, DiagnosticsType.TypeScript);<EOL>        <EOL>        const tsConfig = getTsConfig(context, workerConfig.configFile);<EOL>        if (workerConfig.sourceMaps === false) {<EOL>            <EOL>            tsConfig.","gt":"options.sourceMap = false;"}
{"input":"<s> /**<EOL> * The full TS build for all app files.<EOL> */<EOL>export function transpileWorker(context: BuildContext, workerConfig: TranspileWorkerConfig) {<EOL>    <EOL>    return new Promise((resolve, reject) => {<EOL>        clearDiagnostics(context, DiagnosticsType.TypeScript);<EOL>        <EOL>        const tsConfig = getTsConfig(context, workerConfig.configFile);<EOL>        if (workerConfig.sourceMaps === false) {<EOL>            <EOL>            tsConfig.options.sourceMap = false;<EOL>        }<EOL>        else {<EOL>            <EOL>            tsConfig.","gt":"options.sourceMap = buildJsSourceMaps(context);"}
{"input":"<s> /**<EOL> * The full TS build for all app files.<EOL> */<EOL>export function transpileWorker(context: BuildContext, workerConfig: TranspileWorkerConfig) {<EOL>    <EOL>    return new Promise((resolve, reject) => {<EOL>        clearDiagnostics(context, DiagnosticsType.TypeScript);<EOL>        <EOL>        const tsConfig = getTsConfig(context, workerConfig.configFile);<EOL>        if (workerConfig.sourceMaps === false) {<EOL>            <EOL>            tsConfig.options.sourceMap = false;<EOL>        }<EOL>        else {<EOL>            <EOL>            tsConfig.options.sourceMap = buildJsSourceMaps(context);<EOL>        }<EOL>        <EOL>        const tsFileNames = cleanFileNames(context, tsConfig.fileNames);<EOL>        <EOL>        tsConfig.options.declaration = undefined;<EOL>        <EOL>        const host =","gt":"getInMemoryCompilerHostInstance(tsConfig.options);"}
{"input":"<s> /**<EOL> * The full TS build for all app files.<EOL> */<EOL>export function transpileWorker(context: BuildContext, workerConfig: TranspileWorkerConfig) {<EOL>    <EOL>    return new Promise((resolve, reject) => {<EOL>        clearDiagnostics(context, DiagnosticsType.TypeScript);<EOL>        <EOL>        const tsConfig = getTsConfig(context, workerConfig.configFile);<EOL>        if (workerConfig.sourceMaps === false) {<EOL>            <EOL>            tsConfig.options.sourceMap = false;<EOL>        }<EOL>        else {<EOL>            <EOL>            tsConfig.options.sourceMap = buildJsSourceMaps(context);<EOL>        }<EOL>        <EOL>        const tsFileNames = cleanFileNames(context, tsConfig.fileNames);<EOL>        <EOL>        tsConfig.options.declaration = undefined;<EOL>        <EOL>        const host = getInMemoryCompilerHostInstance(tsConfig.options);<EOL>        if (workerConfig.useTransforms && getBooleanPropertyValue(Constants.ENV_PARSE_DEEPLINKS)) {<EOL>            <EOL>            <EOL>            <EOL>            copyOriginalSourceFiles(context.fileCache);<EOL>            <EOL>            const deepLinkFiles = filterTypescriptFilesForDeepLinks(context.fileCache);<EOL>            deepLinkFiles.forEach(file => {<EOL>                file.content = purgeDeepLinkDecorator(file.content);<EOL>            });<EOL>            const file = context.fileCache.get(getStringPropertyValue(Constants.ENV_APP_NG_MODULE_PATH));<EOL>            const hasExisting = hasExistingDeepLinkConfig(file.path, file.content);<EOL>            if (!hasExisting) {<EOL>","gt":"const deepLinkString = convertDeepLinkConfigEntriesToString(getParsedDeepLinkConfig());"}
{"input":"<s> /**<EOL> * The full TS build for all app files.<EOL> */<EOL>export function transpileWorker(context: BuildContext, workerConfig: TranspileWorkerConfig) {<EOL>    <EOL>    return new Promise((resolve, reject) => {<EOL>        clearDiagnostics(context, DiagnosticsType.TypeScript);<EOL>        <EOL>        const tsConfig = getTsConfig(context, workerConfig.configFile);<EOL>        if (workerConfig.sourceMaps === false) {<EOL>            <EOL>            tsConfig.options.sourceMap = false;<EOL>        }<EOL>        else {<EOL>            <EOL>            tsConfig.options.sourceMap = buildJsSourceMaps(context);<EOL>        }<EOL>        <EOL>        const tsFileNames = cleanFileNames(context, tsConfig.fileNames);<EOL>        <EOL>        tsConfig.options.declaration = undefined;<EOL>        <EOL>        const host = getInMemoryCompilerHostInstance(tsConfig.options);<EOL>        if (workerConfig.useTransforms && getBooleanPropertyValue(Constants.ENV_PARSE_DEEPLINKS)) {<EOL>            <EOL>            <EOL>            <EOL>            copyOriginalSourceFiles(context.fileCache);<EOL>            <EOL>            const deepLinkFiles = filterTypescriptFilesForDeepLinks(context.fileCache);<EOL>            deepLinkFiles.forEach(file => {<EOL>                file.content = purgeDeepLinkDecorator(file.content);<EOL>            });<EOL>            const file = context.fileCache.get(getStringPropertyValue(Constants.ENV_APP_NG_MODULE_PATH));<EOL>            const hasExisting = hasExistingDeepLinkConfig(file.path, file.content);<EOL>            if (!hasExisting) {<EOL>                const deepLinkString = convertDeepLinkConfigEntriesToString(getParsedDeepLinkConfig());<EOL>                file.content = getUpdatedAppNgModuleContentWithDeepLinkConfig(file.path, file.content, deepLinkString);<EOL>            }<EOL>        }<EOL>        const program = ts.createProgram(tsFileNames, tsConfig.options, host, cachedProgram);<EOL>","gt":"resetSourceFiles(context.fileCache);"}
{"input":"<s> /**<EOL> * The full TS build for all app files.<EOL> */<EOL>export function transpileWorker(context: BuildContext, workerConfig: TranspileWorkerConfig) {<EOL>    <EOL>    return new Promise((resolve, reject) => {<EOL>        clearDiagnostics(context, DiagnosticsType.TypeScript);<EOL>        <EOL>        const tsConfig = getTsConfig(context, workerConfig.configFile);<EOL>        if (workerConfig.sourceMaps === false) {<EOL>            <EOL>            tsConfig.options.sourceMap = false;<EOL>        }<EOL>        else {<EOL>            <EOL>            tsConfig.options.sourceMap = buildJsSourceMaps(context);<EOL>        }<EOL>        <EOL>        const tsFileNames = cleanFileNames(context, tsConfig.fileNames);<EOL>        <EOL>        tsConfig.options.declaration = undefined;<EOL>        <EOL>        const host = getInMemoryCompilerHostInstance(tsConfig.options);<EOL>        if (workerConfig.useTransforms && getBooleanPropertyValue(Constants.ENV_PARSE_DEEPLINKS)) {<EOL>            <EOL>            <EOL>            <EOL>            copyOriginalSourceFiles(context.fileCache);<EOL>            <EOL>            const deepLinkFiles = filterTypescriptFilesForDeepLinks(context.fileCache);<EOL>            deepLinkFiles.forEach(file => {<EOL>                file.content = purgeDeepLinkDecorator(file.content);<EOL>            });<EOL>            const file = context.fileCache.get(getStringPropertyValue(Constants.ENV_APP_NG_MODULE_PATH));<EOL>            const hasExisting = hasExistingDeepLinkConfig(file.path, file.content);<EOL>            if (!hasExisting) {<EOL>                const deepLinkString = convertDeepLinkConfigEntriesToString(getParsedDeepLinkConfig());<EOL>                file.content = getUpdatedAppNgModuleContentWithDeepLinkConfig(file.path, file.content, deepLinkString);<EOL>            }<EOL>        }<EOL>        const program = ts.createProgram(tsFileNames, tsConfig.options, host, cachedProgram);<EOL>        resetSourceFiles(context.fileCache);<EOL>        const beforeArray: ts.TransformerFactory<ts.SourceFile>[] = [];<EOL>        program.emit(undefined, (path: string, data: string, writeByteOrderMark: boolean, onError: Function, sourceFiles: ts.SourceFile[]) => {<EOL>            if (workerConfig.writeInMemory) {<EOL>                writeTranspiledFilesCallback(context.fileCache, path, data, workerConfig.inlineTemplate);<EOL>            }<EOL>        });<EOL>        <EOL>        cachedProgram = program;<EOL>        const tsDiagnostics = program.getSyntacticDiagnostics()<EOL>            .concat(program.getSemanticDiagnostics())<EOL>            .concat(program.getOptionsDiagnostics());<EOL>        const diagnostics = runTypeScriptDiagnostics(","gt":"context, tsDiagnostics);"}
{"input":"<s> /**<EOL> * The full TS build for all app files.<EOL> */<EOL>export function transpileWorker(context: BuildContext, workerConfig: TranspileWorkerConfig) {<EOL>    <EOL>    return new Promise((resolve, reject) => {<EOL>        clearDiagnostics(context, DiagnosticsType.TypeScript);<EOL>        <EOL>        const tsConfig = getTsConfig(context, workerConfig.configFile);<EOL>        if (workerConfig.sourceMaps === false) {<EOL>            <EOL>            tsConfig.options.sourceMap = false;<EOL>        }<EOL>        else {<EOL>            <EOL>            tsConfig.options.sourceMap = buildJsSourceMaps(context);<EOL>        }<EOL>        <EOL>        const tsFileNames = cleanFileNames(context, tsConfig.fileNames);<EOL>        <EOL>        tsConfig.options.declaration = undefined;<EOL>        <EOL>        const host = getInMemoryCompilerHostInstance(tsConfig.options);<EOL>        if (workerConfig.useTransforms && getBooleanPropertyValue(Constants.ENV_PARSE_DEEPLINKS)) {<EOL>            <EOL>            <EOL>            <EOL>            copyOriginalSourceFiles(context.fileCache);<EOL>            <EOL>            const deepLinkFiles = filterTypescriptFilesForDeepLinks(context.fileCache);<EOL>            deepLinkFiles.forEach(file => {<EOL>                file.content = purgeDeepLinkDecorator(file.content);<EOL>            });<EOL>            const file = context.fileCache.get(getStringPropertyValue(Constants.ENV_APP_NG_MODULE_PATH));<EOL>            const hasExisting = hasExistingDeepLinkConfig(file.path, file.content);<EOL>            if (!hasExisting) {<EOL>                const deepLinkString = convertDeepLinkConfigEntriesToString(getParsedDeepLinkConfig());<EOL>                file.content = getUpdatedAppNgModuleContentWithDeepLinkConfig(file.path, file.content, deepLinkString);<EOL>            }<EOL>        }<EOL>        const program = ts.createProgram(tsFileNames, tsConfig.options, host, cachedProgram);<EOL>        resetSourceFiles(context.fileCache);<EOL>        const beforeArray: ts.TransformerFactory<ts.SourceFile>[] = [];<EOL>        program.emit(undefined, (path: string, data: string, writeByteOrderMark: boolean, onError: Function, sourceFiles: ts.SourceFile[]) => {<EOL>            if (workerConfig.writeInMemory) {<EOL>                writeTranspiledFilesCallback(context.fileCache, path, data, workerConfig.inlineTemplate);<EOL>            }<EOL>        });<EOL>        <EOL>        cachedProgram = program;<EOL>        const tsDiagnostics = program.getSyntacticDiagnostics()<EOL>            .concat(program.getSemanticDiagnostics())<EOL>            .concat(program.getOptionsDiagnostics());<EOL>        const diagnostics = runTypeScriptDiagnostics(context, tsDiagnostics);<EOL>        if (diagnostics.length) {<EOL>            <EOL>","gt":"printDiagnostics(context, DiagnosticsType.TypeScript, diagnostics, true, true);"}
{"input":"<s> /**<EOL> * Type check a TS program<EOL> * @param {BuildContext} context<EOL> * @param {Program} program<EOL> * @param {LinterOptions} linterOptions<EOL> * @return {Promise<Diagnostic[]>}<EOL> */<EOL>export function typeCheck(context: BuildContext, program: Program, linterOptions?: LinterOptions): Promise<Diagnostic[]> {<EOL>    if (isObject(linterOptions) && linterOptions.typeCheck) {<EOL>        return Promise.","gt":"resolve(getPreEmitDiagnostics(program));"}
{"input":"<s> /**<EOL> * calculate the absolute distance between two points<EOL> * @param {Object} p1 {x, y}<EOL> * @param {Object} p2 {x, y}<EOL> * @param {Array} [props] containing x and y keys<EOL> * @return {Number} distance<EOL> */<EOL>function getDistance(p1: any, p2: any, props?: any) {<EOL>    if (!props) {<EOL>","gt":"props = PROPS_XY;"}
{"input":"<s> function RelationResolver(model) {<EOL>    let resolver = {};<EOL>    _.forEach(utils.sharedRelations(model), rel => {<EOL>","gt":"resolver[rel.name] = (obj, args) => {"}
{"input":"<s> function foo2() {<EOL>    return","gt":"asdf;"}
{"input":"<s> function ff<T extends Date, U extends Date, V>(x: T, y: U, z: V) {<EOL>    var zz: Object;<EOL>    x = x; <EOL>","gt":"x = y;"}
{"input":"<s> <EOL>function escape(value: string) {<EOL>","gt":"return value.replace(/[&<>]/gm, function (character: any) {"}
{"input":"<s> <EOL>function f(a) {<EOL>","gt":"defered(() => {"}
{"input":"<s> export async function createBundle(config: Config, compilerCtx: CompilerCtx, buildCtx: BuildCtx, entryModules: EntryModule[]) {<EOL>    const builtins = require('<STR_LIT>');<EOL>    const globals = require('<STR_LIT>');<EOL>    let rollupBundle: OutputChunk;<EOL>","gt":"const rollupConfig: InputOptions = {"}
{"input":"<s> export async function createBundle(config: Config, compilerCtx: CompilerCtx, buildCtx: BuildCtx, entryModules: EntryModule[]) {<EOL>    const builtins = require('<STR_LIT>');<EOL>    const globals = require('<STR_LIT>');<EOL>    let rollupBundle: OutputChunk;<EOL>    const rollupConfig: InputOptions = {<EOL>","gt":"input: entryModules.map(b => b.entryKey),"}
{"input":"<s> export async function createBundle(config: Config, compilerCtx: CompilerCtx, buildCtx: BuildCtx, entryModules: EntryModule[]) {<EOL>    const builtins = require('<STR_LIT>');<EOL>    const globals = require('<STR_LIT>');<EOL>    let rollupBundle: OutputChunk;<EOL>    const rollupConfig: InputOptions = {<EOL>        input: entryModules.map(b => b.entryKey),<EOL>        experimentalCodeSplitting: true,<EOL>        preserveSymlinks: false,<EOL>","gt":"plugins: ["}
{"input":"<s> export async function createBundle(config: Config, compilerCtx: CompilerCtx, buildCtx: BuildCtx, entryModules: EntryModule[]) {<EOL>    const builtins = require('<STR_LIT>');<EOL>    const globals = require('<STR_LIT>');<EOL>    let rollupBundle: OutputChunk;<EOL>    const rollupConfig: InputOptions = {<EOL>        input: entryModules.map(b => b.entryKey),<EOL>        experimentalCodeSplitting: true,<EOL>        preserveSymlinks: false,<EOL>        plugins: [<EOL>            resolveCollections(compilerCtx),<EOL>            config.sys.rollup.plugins.nodeResolve({<EOL>                jsnext: true,<EOL>                main:","gt":"true"}
{"input":"<s> export async function createBundle(config: Config, compilerCtx: CompilerCtx, buildCtx: BuildCtx, entryModules: EntryModule[]) {<EOL>    const builtins = require('<STR_LIT>');<EOL>    const globals = require('<STR_LIT>');<EOL>    let rollupBundle: OutputChunk;<EOL>    const rollupConfig: InputOptions = {<EOL>        input: entryModules.map(b => b.entryKey),<EOL>        experimentalCodeSplitting: true,<EOL>        preserveSymlinks: false,<EOL>        plugins: [<EOL>            resolveCollections(compilerCtx),<EOL>            config.sys.rollup.plugins.nodeResolve({<EOL>                jsnext: true,<EOL>                main: true<EOL>            }),<EOL>            config.sys.rollup.plugins.commonjs({<EOL>                include: '<STR_LIT>',<EOL>                sourceMap:","gt":"false"}
{"input":"<s> export async function createBundle(config: Config, compilerCtx: CompilerCtx, buildCtx: BuildCtx, entryModules: EntryModule[]) {<EOL>    const builtins = require('<STR_LIT>');<EOL>    const globals = require('<STR_LIT>');<EOL>    let rollupBundle: OutputChunk;<EOL>    const rollupConfig: InputOptions = {<EOL>        input: entryModules.map(b => b.entryKey),<EOL>        experimentalCodeSplitting: true,<EOL>        preserveSymlinks: false,<EOL>        plugins: [<EOL>            resolveCollections(compilerCtx),<EOL>            config.sys.rollup.plugins.nodeResolve({<EOL>                jsnext: true,<EOL>                main: true<EOL>            }),<EOL>            config.sys.rollup.plugins.commonjs({<EOL>                include: '<STR_LIT>',<EOL>                sourceMap: false<EOL>            }),<EOL>            bundleJson(config),<EOL>            globals(),<EOL>            builtins(),<EOL>            bundleEntryFile(config,","gt":"entryModules),"}
{"input":"<s> export async function createBundle(config: Config, compilerCtx: CompilerCtx, buildCtx: BuildCtx, entryModules: EntryModule[]) {<EOL>    const builtins = require('<STR_LIT>');<EOL>    const globals = require('<STR_LIT>');<EOL>    let rollupBundle: OutputChunk;<EOL>    const rollupConfig: InputOptions = {<EOL>        input: entryModules.map(b => b.entryKey),<EOL>        experimentalCodeSplitting: true,<EOL>        preserveSymlinks: false,<EOL>        plugins: [<EOL>            resolveCollections(compilerCtx),<EOL>            config.sys.rollup.plugins.nodeResolve({<EOL>                jsnext: true,<EOL>                main: true<EOL>            }),<EOL>            config.sys.rollup.plugins.commonjs({<EOL>                include: '<STR_LIT>',<EOL>                sourceMap: false<EOL>            }),<EOL>            bundleJson(config),<EOL>            globals(),<EOL>            builtins(),<EOL>            bundleEntryFile(config, entryModules),<EOL>            inMemoryFsRead(config, compilerCtx),<EOL>            await pathsResolution(config, compilerCtx),<EOL>            localResolution(config, compilerCtx),<EOL>            nodeEnvVars(config),<EOL>            ...config.plugins<EOL>        ],<EOL>        onwarn: createOnWarnFn(config, buildCtx.diagnostics)<EOL>    };<EOL>","gt":"try {"}
{"input":"<s> export async function createBundle(config: Config, compilerCtx: CompilerCtx, buildCtx: BuildCtx, entryModules: EntryModule[]) {<EOL>    const builtins = require('<STR_LIT>');<EOL>    const globals = require('<STR_LIT>');<EOL>    let rollupBundle: OutputChunk;<EOL>    const rollupConfig: InputOptions = {<EOL>        input: entryModules.map(b => b.entryKey),<EOL>        experimentalCodeSplitting: true,<EOL>        preserveSymlinks: false,<EOL>        plugins: [<EOL>            resolveCollections(compilerCtx),<EOL>            config.sys.rollup.plugins.nodeResolve({<EOL>                jsnext: true,<EOL>                main: true<EOL>            }),<EOL>            config.sys.rollup.plugins.commonjs({<EOL>                include: '<STR_LIT>',<EOL>                sourceMap: false<EOL>            }),<EOL>            bundleJson(config),<EOL>            globals(),<EOL>            builtins(),<EOL>            bundleEntryFile(config, entryModules),<EOL>            inMemoryFsRead(config, compilerCtx),<EOL>            await pathsResolution(config, compilerCtx),<EOL>            localResolution(config, compilerCtx),<EOL>            nodeEnvVars(config),<EOL>            ...config.plugins<EOL>        ],<EOL>        onwarn: createOnWarnFn(config, buildCtx.diagnostics)<EOL>    };<EOL>    try {<EOL>        rollupBundle = await rollup(rollupConfig);<EOL>    }<EOL>    catch (err) {<EOL>        console.","gt":"log(err);"}
{"input":"<s> function foo() {<EOL>","gt":"new C();"}
{"input":"<s> export async function saveFile(image: IImageFile, filePath: string) {<EOL>    await fs.copy(fu.getFilePath(image),","gt":"filePath);"}
{"input":"<s> function getMainDiv(rootControl: JQuery): JQuery {<EOL>    return rootControl.","gt":"find('<STR_LIT>');"}
{"input":"<s> function transpileFileContent(fileName: string, sourceText: string, options: CompilerOptions): TranspileOutput {<EOL>    const transpileOptions: TranspileOptions = {<EOL>        compilerOptions:","gt":"options,"}
{"input":"<s> /**<EOL> * Mouse events input<EOL> * @constructor<EOL> * @extends Input<EOL> */<EOL>function MouseInput(_manager: any, _handler: any) {<EOL>    this.evEl = MOUSE_ELEMENT_EVENTS;<EOL>    this.","gt":"evWin = MOUSE_WINDOW_EVENTS;"}
{"input":"<s> function merge<T, U>(a: T, b: U): T & U {<EOL>    const res: any = {};<EOL>    [a, b].forEach((obj: any) => {<EOL>        Object.","gt":"keys(obj).forEach(key => {"}
{"input":"<s> function generateDotGraph(digraph: string) {<EOL>    const plain: string = vizLite(digraph, {<EOL>","gt":"format: '<STR_LIT>',"}
{"input":"<s> export function setNumberConfig(config: any, configName: string, defaultValue: number) {<EOL>    const userConfigName = getUserConfigName(config, configName);<EOL>    if (typeof config[userConfigName] === '<STR_LIT>') {<EOL>        config[userConfigName] = config[userConfigName]();<EOL>    }<EOL>    if (typeof config[userConfigName] === '<STR_LIT>') {<EOL>        config[configName] = config[userConfigName];<EOL>    }<EOL>","gt":"else {"}
{"input":"<s> export async function generateBundleModules(config: Config, compilerCtx: CompilerCtx, buildCtx: BuildCtx, entryModules: EntryModule[]): Promise<JSModuleMap> {<EOL>    const results: JSModuleMap = {};<EOL>    try {<EOL>        <EOL>        <EOL>        const rollupBundle = await createBundle(config, compilerCtx, buildCtx, entryModules);<EOL>        <EOL>        results.esm = await writeEsModules(config,","gt":"rollupBundle);"}
{"input":"<s> export async function generateBundleModules(config: Config, compilerCtx: CompilerCtx, buildCtx: BuildCtx, entryModules: EntryModule[]): Promise<JSModuleMap> {<EOL>    const results: JSModuleMap = {};<EOL>    try {<EOL>        <EOL>        <EOL>        const rollupBundle = await createBundle(config, compilerCtx, buildCtx, entryModules);<EOL>        <EOL>        results.esm = await writeEsModules(config, rollupBundle);<EOL>        buildCtx.bundleBuildCount = Object.keys(results.esm).length;<EOL>        if (config.buildEs5) {<EOL>            <EOL>            <EOL>            results.es5 = await writeLegacyModules(","gt":"config, rollupBundle, entryModules);"}
{"input":"<s> export function getWorkspaceRootPath(): string {<EOL>    let editor = window.activeTextEditor;<EOL>    if (editor && editor.document) {<EOL>        let fileUri = window.","gt":"activeTextEditor.document.uri;"}
{"input":"<s> export function processWrapper(process: child_process.ChildProcess, pipeFilePath?: string): Promise<[<EOL>    Buffer,<EOL>    Buffer<EOL>]> {<EOL>    return new Promise<[<EOL>        Buffer,<EOL>        Buffer<EOL>    ]>((resolve, reject) => {<EOL>        let buffOut: Buffer[] = [];<EOL>        let","gt":"buffOutLen = <NUM_LIT>;"}
{"input":"<s> export function processWrapper(process: child_process.ChildProcess, pipeFilePath?: string): Promise<[<EOL>    Buffer,<EOL>    Buffer<EOL>]> {<EOL>    return new Promise<[<EOL>        Buffer,<EOL>        Buffer<EOL>    ]>((resolve, reject) => {<EOL>        let buffOut: Buffer[] = [];<EOL>        let buffOutLen = <NUM_LIT>;<EOL>        let buffErr: Buffer[] = [];<EOL>        let buffErrLen = <NUM_LIT>;<EOL>        <EOL>        <EOL>        process.stdout.on('<STR_LIT>', function (x: Buffer) {<EOL>","gt":"buffOut.push(x);"}
{"input":"<s> export function processWrapper(process: child_process.ChildProcess, pipeFilePath?: string): Promise<[<EOL>    Buffer,<EOL>    Buffer<EOL>]> {<EOL>    return new Promise<[<EOL>        Buffer,<EOL>        Buffer<EOL>    ]>((resolve, reject) => {<EOL>        let buffOut: Buffer[] = [];<EOL>        let buffOutLen = <NUM_LIT>;<EOL>        let buffErr: Buffer[] = [];<EOL>        let buffErrLen = <NUM_LIT>;<EOL>        <EOL>        <EOL>        process.stdout.on('<STR_LIT>', function (x: Buffer) {<EOL>            buffOut.push(x);<EOL>            buffOutLen += x.length;<EOL>        });<EOL>        process.stderr.on('<STR_LIT>', function (","gt":"x: Buffer) {"}
{"input":"<s> export function processWrapper(process: child_process.ChildProcess, pipeFilePath?: string): Promise<[<EOL>    Buffer,<EOL>    Buffer<EOL>]> {<EOL>    return new Promise<[<EOL>        Buffer,<EOL>        Buffer<EOL>    ]>((resolve, reject) => {<EOL>        let buffOut: Buffer[] = [];<EOL>        let buffOutLen = <NUM_LIT>;<EOL>        let buffErr: Buffer[] = [];<EOL>        let buffErrLen = <NUM_LIT>;<EOL>        <EOL>        <EOL>        process.stdout.on('<STR_LIT>', function (x: Buffer) {<EOL>            buffOut.push(x);<EOL>            buffOutLen += x.length;<EOL>        });<EOL>        process.stderr.on('<STR_LIT>', function (x: Buffer) {<EOL>            buffErr.push(x);<EOL>            buffErrLen += x.length;<EOL>        });<EOL>        process.stdout.on('<STR_LIT>', () => {<EOL>            let stdout = Buffer.concat(buffOut, buffOutLen);<EOL>            if (pipeFilePath && stdout.length) {<EOL>                fs.writeFileSync(","gt":"pipeFilePath, stdout);"}
{"input":"<s> function filterDemosEntryPoints() {<EOL>    return getDemosEntryPoints().then((entryPoints: string[]) => {<EOL>        const folderInfo = getFolderInfo();<EOL>        if (folderInfo && folderInfo.componentName) {<EOL>            const filtered = entryPoints.","gt":"filter(entryPoint => {"}
{"input":"<s> function serializeProps(cmpData: ComponentData, cmpMeta: ComponentMeta) {<EOL>    if (!cmpMeta.membersMeta)<EOL>        return;<EOL>    Object.keys(cmpMeta.membersMeta).sort(nameSort).","gt":"forEach(memberName => {"}
{"input":"<s> function serializeProps(cmpData: ComponentData, cmpMeta: ComponentMeta) {<EOL>    if (!cmpMeta.membersMeta)<EOL>        return;<EOL>    Object.keys(cmpMeta.membersMeta).sort(nameSort).forEach(memberName => {<EOL>        const memberMeta = cmpMeta.membersMeta[memberName];<EOL>        if (memberMeta.memberType === MEMBER_TYPE.Prop || memberMeta.memberType === MEMBER_TYPE.PropMutable) {<EOL>","gt":"cmpData.props = cmpData.props || [];"}
{"input":"<s> function serializeProps(cmpData: ComponentData, cmpMeta: ComponentMeta) {<EOL>    if (!cmpMeta.membersMeta)<EOL>        return;<EOL>    Object.keys(cmpMeta.membersMeta).sort(nameSort).forEach(memberName => {<EOL>        const memberMeta = cmpMeta.membersMeta[memberName];<EOL>        if (memberMeta.memberType === MEMBER_TYPE.Prop || memberMeta.memberType === MEMBER_TYPE.PropMutable) {<EOL>            cmpData.props = cmpData.props || [];<EOL>            const propData: PropData = {<EOL>                name: memberName<EOL>            };<EOL>            if (","gt":"memberMeta.propType === PROP_TYPE.Boolean) {"}
{"input":"<s> function serializeProps(cmpData: ComponentData, cmpMeta: ComponentMeta) {<EOL>    if (!cmpMeta.membersMeta)<EOL>        return;<EOL>    Object.keys(cmpMeta.membersMeta).sort(nameSort).forEach(memberName => {<EOL>        const memberMeta = cmpMeta.membersMeta[memberName];<EOL>        if (memberMeta.memberType === MEMBER_TYPE.Prop || memberMeta.memberType === MEMBER_TYPE.PropMutable) {<EOL>            cmpData.props = cmpData.props || [];<EOL>            const propData: PropData = {<EOL>                name: memberName<EOL>            };<EOL>            if (memberMeta.propType === PROP_TYPE.Boolean) {<EOL>                propData.type = BOOLEAN_KEY;<EOL>            }<EOL>            else if (memberMeta.propType === PROP_TYPE.","gt":"Number) {"}
{"input":"<s> function serializeProps(cmpData: ComponentData, cmpMeta: ComponentMeta) {<EOL>    if (!cmpMeta.membersMeta)<EOL>        return;<EOL>    Object.keys(cmpMeta.membersMeta).sort(nameSort).forEach(memberName => {<EOL>        const memberMeta = cmpMeta.membersMeta[memberName];<EOL>        if (memberMeta.memberType === MEMBER_TYPE.Prop || memberMeta.memberType === MEMBER_TYPE.PropMutable) {<EOL>            cmpData.props = cmpData.props || [];<EOL>            const propData: PropData = {<EOL>                name: memberName<EOL>            };<EOL>            if (memberMeta.propType === PROP_TYPE.Boolean) {<EOL>                propData.type = BOOLEAN_KEY;<EOL>            }<EOL>            else if (memberMeta.propType === PROP_TYPE.Number) {<EOL>                propData.type = NUMBER_KEY;<EOL>            }<EOL>            else if (memberMeta.propType === PROP_TYPE.String) {<EOL>                propData.","gt":"type = STRING_KEY;"}
{"input":"<s> function serializeProps(cmpData: ComponentData, cmpMeta: ComponentMeta) {<EOL>    if (!cmpMeta.membersMeta)<EOL>        return;<EOL>    Object.keys(cmpMeta.membersMeta).sort(nameSort).forEach(memberName => {<EOL>        const memberMeta = cmpMeta.membersMeta[memberName];<EOL>        if (memberMeta.memberType === MEMBER_TYPE.Prop || memberMeta.memberType === MEMBER_TYPE.PropMutable) {<EOL>            cmpData.props = cmpData.props || [];<EOL>            const propData: PropData = {<EOL>                name: memberName<EOL>            };<EOL>            if (memberMeta.propType === PROP_TYPE.Boolean) {<EOL>                propData.type = BOOLEAN_KEY;<EOL>            }<EOL>            else if (memberMeta.propType === PROP_TYPE.Number) {<EOL>                propData.type = NUMBER_KEY;<EOL>            }<EOL>            else if (memberMeta.propType === PROP_TYPE.String) {<EOL>                propData.type = STRING_KEY;<EOL>            }<EOL>            else if (memberMeta.propType === PROP_TYPE.Any) {<EOL>                propData.type = ANY_KEY;<EOL>            }<EOL>            if (memberMeta.memberType === MEMBER_TYPE.PropMutable) {<EOL>","gt":"propData.mutable = true;"}
{"input":"<s> export function disconnectedCallback(plt: PlatformApi, elm: HostElement, instance?: ComponentInstance) {<EOL>    <EOL>    <EOL>    if (!plt.tmpDisconnected && isDisconnected(plt.domApi, elm)) {<EOL>        <EOL>        <EOL>        <EOL>        <EOL>        plt.isDisconnectedMap.set(elm, true);<EOL>        <EOL>        <EOL>        propagateComponentLoaded(plt, elm);<EOL>        <EOL>        callNodeRefs(plt.vnodeMap.get(elm), true);<EOL>        <EOL>        <EOL>        <EOL>        plt.domApi.$removeEventListener(elm);<EOL>        plt.hasListenersMap.delete(elm);<EOL>        if (Build.cmpDidUnload) {<EOL>            <EOL>            <EOL>","gt":"instance = plt.instanceMap.get(elm);"}
{"input":"<s> function getDisabledMessageScript() {<EOL>    const html = `<STR_LIT>`;<EOL>    const script =","gt":"'<STR_LIT>').replace(/\\'/g, `<STR_LIT>`).trim()}'<STR_LIT>;"}
{"input":"<s> function chunkArrayInGroups(arr, size) {<EOL>    const result = [];<EOL>    for (let i = <NUM_LIT>; i < arr.length; i++) {<EOL>        if (!Array.isArray(result[i %","gt":"size])) {"}
{"input":"<s> function checkForPlatformDynamicBrowser(filePath: string, fileContent: string) {<EOL>    const sourceFile = getTypescriptSourceFile(filePath, fileContent, ScriptTarget.Latest, false);<EOL>    const allCalls = findNodes(sourceFile, sourceFile, SyntaxKind.CallExpression, true) as CallExpression[];<EOL>    const bootstraps = getBootstrapNodes(allCalls);<EOL>","gt":"const calls: CallExpression[] = bootstraps.reduce((previous, access) => {"}
{"input":"<s> function checkForPlatformDynamicBrowser(filePath: string, fileContent: string) {<EOL>    const sourceFile = getTypescriptSourceFile(filePath, fileContent, ScriptTarget.Latest, false);<EOL>    const allCalls = findNodes(sourceFile, sourceFile, SyntaxKind.CallExpression, true) as CallExpression[];<EOL>    const bootstraps = getBootstrapNodes(allCalls);<EOL>    const calls: CallExpression[] = bootstraps.reduce((previous, access) => {<EOL>        const expressions = findNodes(sourceFile, access, SyntaxKind.CallExpression, true) as CallExpression[];<EOL>        return previous.concat(expressions);<EOL>    }, [])<EOL>        .filter((call: CallExpression) => {<EOL>        return call.expression.kind === SyntaxKind.Identifier<EOL>            && (call.expression","gt":"as Identifier).text === '<STR_LIT>';"}
{"input":"<s> function isset(value) {<EOL>    return","gt":"typeof value != '<STR_LIT>';"}
{"input":"<s> export function OverArgs(...transforms: Function[]): LodashMethodDecorator {<EOL>    return","gt":"decorator(...transforms);"}
{"input":"<s> /**<EOL> * Defers invoking the func until the current call stack has cleared. Any additional arguments are provided to func when it's invoked.<EOL> *<EOL> * @param {...*} [args] Additional arguments to invoke the function with<EOL> * @example<EOL> *<EOL> * class MyClass {<EOL> *   value = 100;<EOL> *<EOL> *   @Defer()<EOL> *   add(a) {<EOL> *     this.value += a;<EOL> *   }<EOL> * }<EOL> *<EOL> * const myClass = new MyClass();<EOL> *<EOL> * myClass.add(10);<EOL> *<EOL> * myClass.value; // => 100;<EOL> *<EOL> * setTimeout(() => {<EOL> *   myClass.value; // => 110;<EOL> * }, 0);<EOL> */<EOL>export function Defer(...args: any[]): LodashMethodDecorator {<EOL>    return decorator(...","gt":"args);"}
{"input":"<s> function upgradeChild(child: ts.Expression): ts.Expression {<EOL>    if (ts.isCallExpression(child) && (<ts.Identifier>child.expression).text === '<STR_LIT>') {<EOL>        return (<ts.CallExpression>child).arguments[","gt":"<NUM_LIT>];"}
{"input":"<s> function importAndEnableProdMode(filePath: string, fileContent: string) {<EOL>    let modifiedFileContent = fileContent;<EOL>    modifiedFileContent = insertNamedImportIfNeeded(filePath, modifiedFileContent, '<STR_LIT>', '<STR_LIT>');<EOL>    const isCalled =","gt":"checkIfFunctionIsCalled(filePath, modifiedFileContent, '<STR_LIT>');"}
{"input":"<s> /**<EOL> * @returns Electron<EOL> */<EOL>export function getNewRemoteElectronMenu(): Electron.Menu {<EOL>    let electron =","gt":"getElectron();"}
{"input":"<s> /**<EOL> * Remaps one icon name to another.<EOL> */<EOL>export function registerIconAlias(iconName: string, mappedToName: string): void {<EOL>","gt":"_iconSettings.__remapped[iconName.toLowerCase()] = mappedToName.toLowerCase();"}
{"input":"<s> async function printExistingProjectMessage(config: Config) {<EOL>    log('<STR_LIT>');<EOL>    log(`<STR_LIT>`);<EOL>","gt":"log(`<STR_LIT>`);"}
{"input":"<s> /** Gets a child DebugElements by tag name. */<EOL>export function getChildDebugElementAll(parent, tagName) {<EOL>    return parent.queryAll(By.","gt":"css(tagName));"}
{"input":"<s> export function mockViews(nav: NavControllerBase, views: ViewController[]) {<EOL>    nav._views = views;<EOL>    views.","gt":"forEach(v => {"}
{"input":"<s> function callExpression(buildCtx: BuildCtx, filePath: string, node: ts.CallExpression) {<EOL>    if (node.arguments && node.arguments[<NUM_LIT>]) {<EOL>        if (node.expression.kind === ts.SyntaxKind.Identifier) {<EOL>            <EOL>","gt":"callExpressionArg(buildCtx, filePath, node.expression as ts.Identifier, node.arguments);"}
{"input":"<s> function callExpression(buildCtx: BuildCtx, filePath: string, node: ts.CallExpression) {<EOL>    if (node.arguments && node.arguments[<NUM_LIT>]) {<EOL>        if (node.expression.kind === ts.SyntaxKind.Identifier) {<EOL>            <EOL>            callExpressionArg(buildCtx, filePath, node.expression as ts.Identifier, node.arguments);<EOL>        }<EOL>        else if (node.expression.kind === ts.SyntaxKind.PropertyAccessExpression) {<EOL>            <EOL>            if ((node.expression as ts.PropertyAccessExpression).name) {<EOL>                <EOL>","gt":"callExpressionArg(buildCtx, filePath, (node.expression as ts.PropertyAccessExpression).name as ts.Identifier, node.arguments);"}
{"input":"<s> export function copy(context: BuildContext, configFile?: string) {<EOL>    configFile = getUserConfigFile(context, taskInfo, configFile);<EOL>    const logger = new Logger('<STR_LIT>');<EOL>","gt":"return copyWorker(context, configFile)"}
{"input":"<s> function proxyConfigToMiddlewareConfig(proxy: ProjectFileProxy): proxyMiddlewareType.Config {<EOL>    const config: proxyMiddlewareType.Config = {<EOL>        pathRewrite: { [proxy.path]: '<STR_LIT>' },<EOL>        target: proxy.proxyUrl,<EOL>    };<EOL>    if (proxy.proxyNoAgent) {<EOL>        config.agent = <any>false; <EOL>    }<EOL>    if (proxy.rejectUnauthorized === false) {<EOL>        config.","gt":"secure = false;"}
{"input":"<s> /**<EOL> * trigger dom event<EOL> * @param {String} event<EOL> * @param {Object} data<EOL> */<EOL>function triggerDomEvent(event: any, data: any) {<EOL>    var gestureEvent: any = doc.createEvent('<STR_LIT>');<EOL>    gestureEvent.","gt":"initEvent(event, true, true);"}
{"input":"<s> /**<EOL> * @param  {string} pollPeriod<EOL> */<EOL>export function configurePollingScheduler(pollPeriod: string) {<EOL>    let scheduler = InstaceCache.getInstance<IScheduler>('<STR_LIT>');<EOL>    <EOL>    scheduler.clearAllJobs();<EOL>    <EOL>    let name = scheduler.scheduleJob(getCronPeriodByName(pollPeriod), {<EOL>","gt":"accountIds: getAccountIds()"}
{"input":"<s> /**<EOL> * @param  {string} pollPeriod<EOL> */<EOL>export function configurePollingScheduler(pollPeriod: string) {<EOL>    let scheduler = InstaceCache.getInstance<IScheduler>('<STR_LIT>');<EOL>    <EOL>    scheduler.clearAllJobs();<EOL>    <EOL>    let name = scheduler.scheduleJob(getCronPeriodByName(pollPeriod), {<EOL>        accountIds: getAccountIds()<EOL>    }, () => {<EOL>        if (isPolling()) {<EOL>            return;<EOL>        }<EOL>        <EOL>        let params = scheduler.getJobParameters(name);<EOL>","gt":"if (typeof params.accountIds === '<STR_LIT>') {"}
{"input":"<s> function stringifyPattern(value) {<EOL>    if (value === undefined)<EOL>        return '<STR_LIT>';<EOL>    if (value ===","gt":"null)"}
{"input":"<s> export function mockTabs(app?: App): Tabs {<EOL>    let platform = mockPlatform();<EOL>    let config = mockConfig(null, '<STR_LIT>', platform);<EOL>    app =","gt":"app || mockApp(config, platform);"}
{"input":"<s> async function fGenericIndexedTypeForStringProp<TObj extends Obj>(obj: TObj): Promise<TObj[\"<STR_LIT>\"]> {<EOL>    return obj.","gt":"stringProp;"}
{"input":"<s> function readE2ETestFiles(mainFilePaths: string[]): Promise<Map<string, string>> {<EOL>    const e2eFiles = mainFilePaths.map(mainFilePath => {<EOL>        return join(dirname(mainFilePath), '<STR_LIT>');<EOL>    });<EOL>    const promises: Promise<any>[] = [];<EOL>    const map =","gt":"new Map<string, string>();"}
{"input":"<s> function readE2ETestFiles(mainFilePaths: string[]): Promise<Map<string, string>> {<EOL>    const e2eFiles = mainFilePaths.map(mainFilePath => {<EOL>        return join(dirname(mainFilePath), '<STR_LIT>');<EOL>    });<EOL>    const promises: Promise<any>[] = [];<EOL>    const map = new Map<string, string>();<EOL>    for (const e2eFile of e2eFiles) {<EOL>        const promise = readE2EFile(e2eFile);<EOL>        promises.push(promise);<EOL>        promise.","gt":"then((content: string) => {"}
{"input":"<s> export async function generateAppGlobalContents(config: Config, compilerCtx: CompilerCtx, buildCtx: BuildCtx, sourceTarget: SourceTarget) {<EOL>    let globalJsContents: string[] = [];<EOL>    const results = await Promise.all([<EOL>        loadDependentGlobalJsContents(config, compilerCtx, buildCtx, sourceTarget),<EOL>        bundleProjectGlobal(config, compilerCtx, buildCtx, sourceTarget, config.","gt":"namespace, config.globalScript)"}
{"input":"<s> export async function generateAppGlobalContents(config: Config, compilerCtx: CompilerCtx, buildCtx: BuildCtx, sourceTarget: SourceTarget) {<EOL>    let globalJsContents: string[] = [];<EOL>    const results = await Promise.all([<EOL>        loadDependentGlobalJsContents(config, compilerCtx, buildCtx, sourceTarget),<EOL>        bundleProjectGlobal(config, compilerCtx, buildCtx, sourceTarget, config.namespace, config.globalScript)<EOL>    ]);<EOL>    const dependentGlobalJsContents = results[<NUM_LIT>];<EOL>    const projectGlobalJsContent = results[<NUM_LIT>];<EOL>    globalJsContents = globalJsContents.concat(dependentGlobalJsContents);<EOL>    if (projectGlobalJsContent) {<EOL>        globalJsContents.","gt":"push(projectGlobalJsContent);"}
{"input":"<s> export function initializeIcons(baseUrl: string = '<STR_LIT>', options?: IIconOptions): void {<EOL>    const subset: IIconSubset = {<EOL>        style: {<EOL>            MozOsxFontSmoothing: '<STR_LIT>',<EOL>            WebkitFontSmoothing: '<STR_LIT>',<EOL>            fontStyle: '<STR_LIT>',<EOL>            fontWeight:","gt":"'<STR_LIT>',"}
{"input":"<s> export function initializeIcons(baseUrl: string = '<STR_LIT>', options?: IIconOptions): void {<EOL>    const subset: IIconSubset = {<EOL>        style: {<EOL>            MozOsxFontSmoothing: '<STR_LIT>',<EOL>            WebkitFontSmoothing: '<STR_LIT>',<EOL>            fontStyle: '<STR_LIT>',<EOL>            fontWeight: '<STR_LIT>',<EOL>            speak: '<STR_LIT>'<EOL>        },<EOL>        fontFace: {<EOL>","gt":"fontFamily: `<STR_LIT>`,"}
{"input":"<s> export function initializeIcons(baseUrl: string = '<STR_LIT>', options?: IIconOptions): void {<EOL>    const subset: IIconSubset = {<EOL>        style: {<EOL>            MozOsxFontSmoothing: '<STR_LIT>',<EOL>            WebkitFontSmoothing: '<STR_LIT>',<EOL>            fontStyle: '<STR_LIT>',<EOL>            fontWeight: '<STR_LIT>',<EOL>            speak: '<STR_LIT>'<EOL>        },<EOL>        fontFace: {<EOL>            fontFamily: `<STR_LIT>`,<EOL>            src: `<STR_LIT>`,<EOL>        },<EOL>        icons: {<EOL>","gt":"'<STR_LIT>': '<STR_LIT>',"}
{"input":"<s> /**<EOL> * @param  {IStateRepositoryMuteFiltersAccount} accountState<EOL> * @param  {string} repoId<EOL> * @returns IStateRepositoryMuteFiltersAccountRepo<EOL> */<EOL>function getRepositoryState(accountState: IStateRepositoryMuteFiltersAccount, repoId: string): IStateRepositoryMuteFiltersAccountRepo {<EOL>    return accountState[","gt":"repoId] || defaultRepositoryMuteFilter;"}
{"input":"<s> /**<EOL> * @param  {string} token<EOL> * @param  {string} before<EOL> * @param  {boolean=false} all<EOL> */<EOL>export function pollBeforeNotifications(accountId: string, token: string, before: string, all: boolean = false) {<EOL>    let service = InstanceCache.getInstance<IGitHubNotificationsService>('<STR_LIT>');<EOL>    return dispatch => {<EOL>        dispatch(","gt":"setIsPolling(true));"}
{"input":"<s> export function mockNgModuleLoader(): NgModuleLoader {<EOL>","gt":"return new NgModuleLoader(null);"}
{"input":"<s> export function uglifyjs(context: BuildContext, configFile?: string) {<EOL>    configFile = getUserConfigFile(context, taskInfo, configFile);<EOL>    const logger = new Logger('<STR_LIT>');<EOL>    return runWorker(","gt":"'<STR_LIT>', '<STR_LIT>', context, configFile)"}
{"input":"<s> export function getEventDecoratorMeta(checker: ts.TypeChecker, classNode: ts.ClassDeclaration): EventMeta[] {<EOL>    return classNode.members<EOL>        .filter(isPropertyWithDecorators)<EOL>        .reduce((membersMeta, member) => {<EOL>        const elementDecorator = member.decorators.find(isDecoratorNamed('<STR_LIT>'));<EOL>","gt":"if (elementDecorator == null) {"}
{"input":"<s> export function getEventDecoratorMeta(checker: ts.TypeChecker, classNode: ts.ClassDeclaration): EventMeta[] {<EOL>    return classNode.members<EOL>        .filter(isPropertyWithDecorators)<EOL>        .reduce((membersMeta, member) => {<EOL>        const elementDecorator = member.decorators.find(isDecoratorNamed('<STR_LIT>'));<EOL>        if (elementDecorator == null) {<EOL>            return membersMeta;<EOL>        }<EOL>        const [eventOptions] = getDeclarationParameters<EventOptions>(elementDecorator);<EOL>        const","gt":"metadata = convertOptionsToMeta(eventOptions, member.name.getText());"}
{"input":"<s> export function getEventDecoratorMeta(checker: ts.TypeChecker, classNode: ts.ClassDeclaration): EventMeta[] {<EOL>    return classNode.members<EOL>        .filter(isPropertyWithDecorators)<EOL>        .reduce((membersMeta, member) => {<EOL>        const elementDecorator = member.decorators.find(isDecoratorNamed('<STR_LIT>'));<EOL>        if (elementDecorator == null) {<EOL>            return membersMeta;<EOL>        }<EOL>        const [eventOptions] = getDeclarationParameters<EventOptions>(elementDecorator);<EOL>        const metadata = convertOptionsToMeta(eventOptions, member.name.getText());<EOL>        if (metadata) {<EOL>            const symbol = checker.getSymbolAtLocation(member.name);<EOL>            metadata.jsdoc = serializeSymbol(checker, symbol);<EOL>            membersMeta.","gt":"push(metadata);"}
{"input":"<s> /**<EOL> * @param  {IAppAlert} appAlert<EOL> */<EOL>export function addAppAlert(appAlert: IAppAlert) {<EOL>    return {<EOL>        type: ActionConstants.appAlerts.","gt":"ADD_APP_ALERT,"}
{"input":"<s> /**<EOL> * @param  {string} rendererName<EOL> * @returns boolean<EOL> */<EOL>export function rendererExists(rendererName: string): boolean {<EOL>    return typeof renderers[rendererName.toUpperCase()] !==","gt":"'<STR_LIT>';"}
{"input":"<s> export function getGlobalProxy(): [<EOL>    string,<EOL>    string<EOL>] | [<EOL>    undefined,<EOL>    undefined<EOL>] {<EOL>    const envvars = ['<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>'];<EOL>    for (const envvar of envvars) {<EOL>        if (","gt":"process.env[envvar]) {"}
{"input":"<s> export function formatAPISuccess(req: superagentType.SuperAgentRequest, r: APIResponseSuccess): string {<EOL>    return","gt":"} ${req.url}\\n`<STR_LIT>`"}
{"input":"<s> /**<EOL> * Memoize decorator to be used on class methods. Note that the \"this\" reference<EOL> * will be inaccessible within a memoized method, given that a cached method's this<EOL> * would not be instance specific.<EOL> *<EOL> * @public<EOL> */<EOL>export function memoize<T extends Function>(target: any, key: string, descriptor: TypedPropertyDescriptor<T>): {<EOL>    configurable: boolean;<EOL>    get(): T;<EOL>} {<EOL>    <EOL>    <EOL>    let fn = memoizeFunction(descriptor.value && descriptor.","gt":"value.bind(null));"}
{"input":"<s> export async function getIOSPlugins(config: Config, allPlugins: Plugin[]): Promise<Plugin[]> {<EOL>    const","gt":"resolved = await Promise.all(allPlugins.map(p => resolvePlugin(config, p)));"}
{"input":"<s> export function setLastPoll(lastPoll: string) {<EOL>    return {<EOL>        type: ActionConstants.","gt":"app.SET_APP_LAST_POLL,"}
{"input":"<s> /**<EOL> * @todo: lol more callback hell...fix this.<EOL> */<EOL>export function appSetupFlow() {<EOL>    return dispatch => {<EOL>        <EOL>        dispatch(setSetupRenderApp(true));<EOL>        wait(<NUM_LIT>)<EOL>            .then(() => {<EOL>            <EOL>            dispatch(updateAccounts(() => {<EOL>                pollingMethod(getAccountIds());<EOL>                <EOL>","gt":"configurePollingScheduler(getCurrentPollPeriod());"}
{"input":"<s> /**<EOL> * @todo: lol more callback hell...fix this.<EOL> */<EOL>export function appSetupFlow() {<EOL>    return dispatch => {<EOL>        <EOL>        dispatch(setSetupRenderApp(true));<EOL>        wait(<NUM_LIT>)<EOL>            .then(() => {<EOL>            <EOL>            dispatch(updateAccounts(() => {<EOL>                pollingMethod(getAccountIds());<EOL>                <EOL>                configurePollingScheduler(getCurrentPollPeriod());<EOL>                <EOL>                dispatch(setSetupShowLoading(false));<EOL>","gt":"wait(<NUM_LIT>)"}
{"input":"<s> /**<EOL> * @param  {string} action<EOL> */<EOL>export function setNotificationDoubleClickAction(action: string) {<EOL>    return {<EOL>        type:","gt":"ActionConstants.settings.SET_NOTIFICATIONS_DOUBLE_CLICK_ACTION,"}
{"input":"<s> export function foo(): require.I {<EOL>","gt":"return null;"}
{"input":"<s> function expectNameOnAllInputs(element: HTMLElement, name: string) {<EOL>    const inputs = element.querySelectorAll('<STR_LIT>');<EOL>    for (let","gt":"i = <NUM_LIT>; i < inputs.length; i++) {"}
{"input":"<s> export function format(fileName: string, text: string, options = createDefaultFormatCodeSettings()) {<EOL>    const host = new LanguageServiceHost();<EOL>    host.addFile(fileName, text);<EOL>    const languageService = ts.createLanguageService(host);<EOL>    const edits = languageService.getFormattingEditsForDocument(fileName,","gt":"options);"}
{"input":"<s> export function format(fileName: string, text: string, options = createDefaultFormatCodeSettings()) {<EOL>    const host = new LanguageServiceHost();<EOL>    host.addFile(fileName, text);<EOL>    const languageService = ts.createLanguageService(host);<EOL>    const edits = languageService.getFormattingEditsForDocument(fileName, options);<EOL>    edits<EOL>        .sort((a, b) => a.span.start - b.span.start)<EOL>        .reverse()<EOL>        .forEach(edit => {<EOL>        const head = text.slice(<NUM_LIT>, edit.span.start);<EOL>        const tail = text.","gt":"slice(edit.span.start + edit.span.length);"}
{"input":"<s> function twoDigit(val: number): string {<EOL>    return ('<STR_LIT>' + (isPresent(val) ? Math.abs(val) :","gt":"'<STR_LIT>')).slice(-<NUM_LIT>);"}
{"input":"<s> async function formatUsage(env: IonicEnvironment, ns: INamespace) {<EOL>    const metadata = await ns.getMetadata();<EOL>    let name = metadata.name;<EOL>    if (ns.parent) {<EOL>        name =","gt":"name}`<STR_LIT>n"}
{"input":"<s> async function formatUsage(env: IonicEnvironment, ns: INamespace) {<EOL>    const metadata = await ns.getMetadata();<EOL>    let name = metadata.name;<EOL>    if (ns.parent) {<EOL>        name = `<STR_LIT>`; <EOL>    }<EOL>    const options = ['<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>'];<EOL>    const usageLines = [<EOL>","gt":"dim('<STR_LIT>')}`<STR_LIT>,"}
{"input":"<s> export function getComponentsDtsDistTypesFilePath(config: Config) {<EOL>    return pathJoin(config,","gt":"config.typesDir, COMPONENTS_DTS);"}
{"input":"<s> function getRobots() {<EOL>","gt":"return robots;"}
{"input":"<s> export function hsv2rgb(h: number, s: number, v: number): IRGB {<EOL>    s = s / <NUM_LIT>;<EOL>    v = v / <NUM_LIT>;<EOL>    let rgb:","gt":"number[] = [];"}
{"input":"<s> export function hsv2rgb(h: number, s: number, v: number): IRGB {<EOL>    s = s / <NUM_LIT>;<EOL>    v = v / <NUM_LIT>;<EOL>    let rgb: number[] = [];<EOL>    const c = v * s;<EOL>    const hh = h / <NUM_LIT>;<EOL>    const x = c * (<NUM_LIT> - Math.abs(","gt":"hh % <NUM_LIT> - <NUM_LIT>));"}
{"input":"<s> export function hsv2rgb(h: number, s: number, v: number): IRGB {<EOL>    s = s / <NUM_LIT>;<EOL>    v = v / <NUM_LIT>;<EOL>    let rgb: number[] = [];<EOL>    const c = v * s;<EOL>    const hh = h / <NUM_LIT>;<EOL>    const x = c * (<NUM_LIT> - Math.abs(hh % <NUM_LIT> - <NUM_LIT>));<EOL>    const m = v - c;<EOL>    switch (Math.floor(hh)) {<EOL>        case <NUM_LIT>:<EOL>","gt":"rgb = [c, x, <NUM_LIT>];"}
{"input":"<s> export function hsv2rgb(h: number, s: number, v: number): IRGB {<EOL>    s = s / <NUM_LIT>;<EOL>    v = v / <NUM_LIT>;<EOL>    let rgb: number[] = [];<EOL>    const c = v * s;<EOL>    const hh = h / <NUM_LIT>;<EOL>    const x = c * (<NUM_LIT> - Math.abs(hh % <NUM_LIT> - <NUM_LIT>));<EOL>    const m = v - c;<EOL>    switch (Math.floor(hh)) {<EOL>        case <NUM_LIT>:<EOL>            rgb = [c, x, <NUM_LIT>];<EOL>            break;<EOL>        case <NUM_LIT>:<EOL>            rgb = [x, c, <NUM_LIT>];<EOL>","gt":"break;"}
{"input":"<s> export function hsv2rgb(h: number, s: number, v: number): IRGB {<EOL>    s = s / <NUM_LIT>;<EOL>    v = v / <NUM_LIT>;<EOL>    let rgb: number[] = [];<EOL>    const c = v * s;<EOL>    const hh = h / <NUM_LIT>;<EOL>    const x = c * (<NUM_LIT> - Math.abs(hh % <NUM_LIT> - <NUM_LIT>));<EOL>    const m = v - c;<EOL>    switch (Math.floor(hh)) {<EOL>        case <NUM_LIT>:<EOL>            rgb = [c, x, <NUM_LIT>];<EOL>            break;<EOL>        case <NUM_LIT>:<EOL>            rgb = [x, c, <NUM_LIT>];<EOL>            break;<EOL>        case <NUM_LIT>:<EOL>            rgb = [<NUM_LIT>, c, x];<EOL>","gt":"break;"}
{"input":"<s> export function hsv2rgb(h: number, s: number, v: number): IRGB {<EOL>    s = s / <NUM_LIT>;<EOL>    v = v / <NUM_LIT>;<EOL>    let rgb: number[] = [];<EOL>    const c = v * s;<EOL>    const hh = h / <NUM_LIT>;<EOL>    const x = c * (<NUM_LIT> - Math.abs(hh % <NUM_LIT> - <NUM_LIT>));<EOL>    const m = v - c;<EOL>    switch (Math.floor(hh)) {<EOL>        case <NUM_LIT>:<EOL>            rgb = [c, x, <NUM_LIT>];<EOL>            break;<EOL>        case <NUM_LIT>:<EOL>            rgb = [x, c, <NUM_LIT>];<EOL>            break;<EOL>        case <NUM_LIT>:<EOL>            rgb = [<NUM_LIT>, c, x];<EOL>            break;<EOL>        case <NUM_LIT>:<EOL>            rgb = [<NUM_LIT>, x, c];<EOL>            break;<EOL>        case <NUM_LIT>:<EOL>            rgb = [x, <NUM_LIT>, c];<EOL>            break;<EOL>        case <NUM_LIT>:<EOL>            rgb = [c,","gt":"<NUM_LIT>, x];"}
{"input":"<s> function assertEqual(a: any, b: any, message: string) {<EOL>    if (!equal(a,","gt":"b)) {"}
{"input":"<s> /**<EOL> * Helper to find the first item within an array that satisfies the callback.<EOL> * @param array - Array to search<EOL> * @param cb - Callback which returns true on matches<EOL> */<EOL>export function find<T>(array: T[], cb: (item: T, index: number) => boolean): T | undefined {<EOL>    let index = findIndex(array, cb);<EOL>    if (index <","gt":"<NUM_LIT>) {"}
{"input":"<s> /**<EOL> * Creates an array of a given size and helper method to populate.<EOL> *<EOL> * @public<EOL> * @param size - Size of array.<EOL> * @param getItem - Callback to populate given cell index.<EOL> */<EOL>export function createArray<T>(size: number, getItem: (index: number) => T): T[] {<EOL>    let array: T[] = [];<EOL>    for (let i = <NUM_LIT>; i < size;","gt":"i++) {"}
{"input":"<s> export function getVendorSettings(): IVendorSettings {<EOL>    if (!_vendorSettings) {<EOL>        const doc = typeof document !== '<STR_LIT>' ? document : undefined;<EOL>        const nav = typeof navigator !== '<STR_LIT>' ? navigator : undefined;<EOL>        const userAgent = nav ? nav.userAgent.toLowerCase() : undefined;<EOL>","gt":"if (!doc) {"}
{"input":"<s> export function getVendorSettings(): IVendorSettings {<EOL>    if (!_vendorSettings) {<EOL>        const doc = typeof document !== '<STR_LIT>' ? document : undefined;<EOL>        const nav = typeof navigator !== '<STR_LIT>' ? navigator : undefined;<EOL>        const userAgent = nav ? nav.userAgent.toLowerCase() : undefined;<EOL>        if (!doc) {<EOL>            _vendorSettings = {<EOL>","gt":"isWebkit: true,"}
{"input":"<s> export function getVendorSettings(): IVendorSettings {<EOL>    if (!_vendorSettings) {<EOL>        const doc = typeof document !== '<STR_LIT>' ? document : undefined;<EOL>        const nav = typeof navigator !== '<STR_LIT>' ? navigator : undefined;<EOL>        const userAgent = nav ? nav.userAgent.toLowerCase() : undefined;<EOL>        if (!doc) {<EOL>            _vendorSettings = {<EOL>                isWebkit: true,<EOL>                isMoz: true,<EOL>                isOpera: true,<EOL>                isMs: true<EOL>            };<EOL>        }<EOL>        else {<EOL>            _vendorSettings = {<EOL>                isWebkit: !!(doc && '<STR_LIT>' in doc.documentElement.style),<EOL>                isMoz: !!(userAgent && userAgent.indexOf('<STR_LIT>') > -<NUM_LIT>),<EOL>                isOpera: !!(userAgent &&","gt":"userAgent.indexOf('<STR_LIT>') > -<NUM_LIT>),"}
{"input":"<s> <EOL>function configure(user_options: any) {<EOL>    options = inherit(","gt":"options, user_options);"}
{"input":"<s> function createKeyDownEvent(key: number) {<EOL>    const event = { which: key, preventDefault: () => { }, stopPropagation: () => { } };<EOL>    spyOn(event,","gt":"'<STR_LIT>');"}
{"input":"<s> function exec() {<EOL>    var canv = document.createElement(\"<STR_LIT>\");<EOL>    canv.width = <NUM_LIT>;<EOL>","gt":"canv.height = <NUM_LIT>;"}
{"input":"<s> async function legacyMain(autorestArgs: string[]): Promise<number> {<EOL>    <EOL>    const currentDirUri = CreateFolderUri(currentDirectory());<EOL>    const","gt":"dataStore = new DataStore();"}
{"input":"<s> async function legacyMain(autorestArgs: string[]): Promise<number> {<EOL>    <EOL>    const currentDirUri = CreateFolderUri(currentDirectory());<EOL>    const dataStore = new DataStore();<EOL>    let config: AutoRestConfigurationImpl = {};<EOL>    try {<EOL>        config = await CreateConfiguration(","gt":"currentDirUri, dataStore.GetReadThroughScope(new RealFileSystem()), autorestArgs);"}
{"input":"<s> async function legacyMain(autorestArgs: string[]): Promise<number> {<EOL>    <EOL>    const currentDirUri = CreateFolderUri(currentDirectory());<EOL>    const dataStore = new DataStore();<EOL>    let config: AutoRestConfigurationImpl = {};<EOL>    try {<EOL>        config = await CreateConfiguration(currentDirUri, dataStore.GetReadThroughScope(new RealFileSystem()), autorestArgs);<EOL>    }<EOL>    catch (e) {<EOL>        console.error(","gt":"color(\"<STR_LIT>\"));"}
{"input":"<s> async function legacyMain(autorestArgs: string[]): Promise<number> {<EOL>    <EOL>    const currentDirUri = CreateFolderUri(currentDirectory());<EOL>    const dataStore = new DataStore();<EOL>    let config: AutoRestConfigurationImpl = {};<EOL>    try {<EOL>        config = await CreateConfiguration(currentDirUri, dataStore.GetReadThroughScope(new RealFileSystem()), autorestArgs);<EOL>    }<EOL>    catch (e) {<EOL>        console.error(color(\"<STR_LIT>\"));<EOL>        console.error(\"<STR_LIT>\");<EOL>        console.error(color(\"<STR_LIT>\" +<EOL>            \"<STR_LIT>\" +<EOL>            \"<STR_LIT>\" +<EOL>","gt":"\"<STR_LIT>\"));"}
{"input":"<s> async function legacyMain(autorestArgs: string[]): Promise<number> {<EOL>    <EOL>    const currentDirUri = CreateFolderUri(currentDirectory());<EOL>    const dataStore = new DataStore();<EOL>    let config: AutoRestConfigurationImpl = {};<EOL>    try {<EOL>        config = await CreateConfiguration(currentDirUri, dataStore.GetReadThroughScope(new RealFileSystem()), autorestArgs);<EOL>    }<EOL>    catch (e) {<EOL>        console.error(color(\"<STR_LIT>\"));<EOL>        console.error(\"<STR_LIT>\");<EOL>        console.error(color(\"<STR_LIT>\" +<EOL>            \"<STR_LIT>\" +<EOL>            \"<STR_LIT>\" +<EOL>            \"<STR_LIT>\"));<EOL>        console.error(\"<STR_LIT>\");<EOL>        console.error(color(\"<STR_LIT>\" + e));<EOL>        await showHelp();<EOL>        return <NUM_LIT>;<EOL>    }<EOL>    <EOL>    if (autorestArgs[<NUM_LIT>] === \"<STR_LIT>\") {<EOL>","gt":"const clientNameGuess = (config[\"<STR_LIT>\"] || {}).title || Parse<any>(await ReadUri((config[\"<STR_LIT>\"] as any)[<NUM_LIT>])).info.title;"}
{"input":"<s> async function legacyMain(autorestArgs: string[]): Promise<number> {<EOL>    <EOL>    const currentDirUri = CreateFolderUri(currentDirectory());<EOL>    const dataStore = new DataStore();<EOL>    let config: AutoRestConfigurationImpl = {};<EOL>    try {<EOL>        config = await CreateConfiguration(currentDirUri, dataStore.GetReadThroughScope(new RealFileSystem()), autorestArgs);<EOL>    }<EOL>    catch (e) {<EOL>        console.error(color(\"<STR_LIT>\"));<EOL>        console.error(\"<STR_LIT>\");<EOL>        console.error(color(\"<STR_LIT>\" +<EOL>            \"<STR_LIT>\" +<EOL>            \"<STR_LIT>\" +<EOL>            \"<STR_LIT>\"));<EOL>        console.error(\"<STR_LIT>\");<EOL>        console.error(color(\"<STR_LIT>\" + e));<EOL>        await showHelp();<EOL>        return <NUM_LIT>;<EOL>    }<EOL>    <EOL>    if (autorestArgs[<NUM_LIT>] === \"<STR_LIT>\") {<EOL>        const clientNameGuess = (config[\"<STR_LIT>\"] || {}).title || Parse<any>(await ReadUri((config[\"<STR_LIT>\"] as any)[<NUM_LIT>])).info.title;<EOL>        await autorestInit(clientNameGuess, Array.isArray(config[\"<STR_LIT>\"]) ? config[\"<STR_LIT>\"] as any : []);<EOL>        return <NUM_LIT>;<EOL>    }<EOL>    <EOL>    if (autorestArgs[<NUM_LIT>] === \"<STR_LIT>\") {<EOL>        console.log(`<STR_LIT>`.replace(/~/g, \"<STR_LIT>\"));<EOL>        return","gt":"<NUM_LIT>;"}
{"input":"<s> async function legacyMain(autorestArgs: string[]): Promise<number> {<EOL>    <EOL>    const currentDirUri = CreateFolderUri(currentDirectory());<EOL>    const dataStore = new DataStore();<EOL>    let config: AutoRestConfigurationImpl = {};<EOL>    try {<EOL>        config = await CreateConfiguration(currentDirUri, dataStore.GetReadThroughScope(new RealFileSystem()), autorestArgs);<EOL>    }<EOL>    catch (e) {<EOL>        console.error(color(\"<STR_LIT>\"));<EOL>        console.error(\"<STR_LIT>\");<EOL>        console.error(color(\"<STR_LIT>\" +<EOL>            \"<STR_LIT>\" +<EOL>            \"<STR_LIT>\" +<EOL>            \"<STR_LIT>\"));<EOL>        console.error(\"<STR_LIT>\");<EOL>        console.error(color(\"<STR_LIT>\" + e));<EOL>        await showHelp();<EOL>        return <NUM_LIT>;<EOL>    }<EOL>    <EOL>    if (autorestArgs[<NUM_LIT>] === \"<STR_LIT>\") {<EOL>        const clientNameGuess = (config[\"<STR_LIT>\"] || {}).title || Parse<any>(await ReadUri((config[\"<STR_LIT>\"] as any)[<NUM_LIT>])).info.title;<EOL>        await autorestInit(clientNameGuess, Array.isArray(config[\"<STR_LIT>\"]) ? config[\"<STR_LIT>\"] as any : []);<EOL>        return <NUM_LIT>;<EOL>    }<EOL>    <EOL>    if (autorestArgs[<NUM_LIT>] === \"<STR_LIT>\") {<EOL>        console.log(`<STR_LIT>`.replace(/~/g, \"<STR_LIT>\"));<EOL>        return <NUM_LIT>;<EOL>    }<EOL>    <EOL>    if (autorestArgs[<NUM_LIT>] === \"<STR_LIT>\") {<EOL>        const args: string[] = [];<EOL>        for (const node of nodes(config, \"<STR_LIT>\")) {<EOL>            const path = node.path.join(\"<STR_LIT>\");<EOL>            const values = node.value instanceof Array ? node.value : (typeof node.value === \"<STR_LIT>\" ? [] : [node.value]);<EOL>            for (const value of values) {<EOL>                args.push(","gt":"value}`<STR_LIT>;"}
{"input":"<s> async function legacyMain(autorestArgs: string[]): Promise<number> {<EOL>    <EOL>    const currentDirUri = CreateFolderUri(currentDirectory());<EOL>    const dataStore = new DataStore();<EOL>    let config: AutoRestConfigurationImpl = {};<EOL>    try {<EOL>        config = await CreateConfiguration(currentDirUri, dataStore.GetReadThroughScope(new RealFileSystem()), autorestArgs);<EOL>    }<EOL>    catch (e) {<EOL>        console.error(color(\"<STR_LIT>\"));<EOL>        console.error(\"<STR_LIT>\");<EOL>        console.error(color(\"<STR_LIT>\" +<EOL>            \"<STR_LIT>\" +<EOL>            \"<STR_LIT>\" +<EOL>            \"<STR_LIT>\"));<EOL>        console.error(\"<STR_LIT>\");<EOL>        console.error(color(\"<STR_LIT>\" + e));<EOL>        await showHelp();<EOL>        return <NUM_LIT>;<EOL>    }<EOL>    <EOL>    if (autorestArgs[<NUM_LIT>] === \"<STR_LIT>\") {<EOL>        const clientNameGuess = (config[\"<STR_LIT>\"] || {}).title || Parse<any>(await ReadUri((config[\"<STR_LIT>\"] as any)[<NUM_LIT>])).info.title;<EOL>        await autorestInit(clientNameGuess, Array.isArray(config[\"<STR_LIT>\"]) ? config[\"<STR_LIT>\"] as any : []);<EOL>        return <NUM_LIT>;<EOL>    }<EOL>    <EOL>    if (autorestArgs[<NUM_LIT>] === \"<STR_LIT>\") {<EOL>        console.log(`<STR_LIT>`.replace(/~/g, \"<STR_LIT>\"));<EOL>        return <NUM_LIT>;<EOL>    }<EOL>    <EOL>    if (autorestArgs[<NUM_LIT>] === \"<STR_LIT>\") {<EOL>        const args: string[] = [];<EOL>        for (const node of nodes(config, \"<STR_LIT>\")) {<EOL>            const path = node.path.join(\"<STR_LIT>\");<EOL>            const values = node.value instanceof Array ? node.value : (typeof node.value === \"<STR_LIT>\" ? [] : [node.value]);<EOL>            for (const value of values) {<EOL>                args.push(`<STR_LIT>`);<EOL>            }<EOL>        }<EOL>        console.log(args.join(\"<STR_LIT>\"));<EOL>","gt":"return <NUM_LIT>;"}
{"input":"<s> async function legacyMain(autorestArgs: string[]): Promise<number> {<EOL>    <EOL>    const currentDirUri = CreateFolderUri(currentDirectory());<EOL>    const dataStore = new DataStore();<EOL>    let config: AutoRestConfigurationImpl = {};<EOL>    try {<EOL>        config = await CreateConfiguration(currentDirUri, dataStore.GetReadThroughScope(new RealFileSystem()), autorestArgs);<EOL>    }<EOL>    catch (e) {<EOL>        console.error(color(\"<STR_LIT>\"));<EOL>        console.error(\"<STR_LIT>\");<EOL>        console.error(color(\"<STR_LIT>\" +<EOL>            \"<STR_LIT>\" +<EOL>            \"<STR_LIT>\" +<EOL>            \"<STR_LIT>\"));<EOL>        console.error(\"<STR_LIT>\");<EOL>        console.error(color(\"<STR_LIT>\" + e));<EOL>        await showHelp();<EOL>        return <NUM_LIT>;<EOL>    }<EOL>    <EOL>    if (autorestArgs[<NUM_LIT>] === \"<STR_LIT>\") {<EOL>        const clientNameGuess = (config[\"<STR_LIT>\"] || {}).title || Parse<any>(await ReadUri((config[\"<STR_LIT>\"] as any)[<NUM_LIT>])).info.title;<EOL>        await autorestInit(clientNameGuess, Array.isArray(config[\"<STR_LIT>\"]) ? config[\"<STR_LIT>\"] as any : []);<EOL>        return <NUM_LIT>;<EOL>    }<EOL>    <EOL>    if (autorestArgs[<NUM_LIT>] === \"<STR_LIT>\") {<EOL>        console.log(`<STR_LIT>`.replace(/~/g, \"<STR_LIT>\"));<EOL>        return <NUM_LIT>;<EOL>    }<EOL>    <EOL>    if (autorestArgs[<NUM_LIT>] === \"<STR_LIT>\") {<EOL>        const args: string[] = [];<EOL>        for (const node of nodes(config, \"<STR_LIT>\")) {<EOL>            const path = node.path.join(\"<STR_LIT>\");<EOL>            const values = node.value instanceof Array ? node.value : (typeof node.value === \"<STR_LIT>\" ? [] : [node.value]);<EOL>            for (const value of values) {<EOL>                args.push(`<STR_LIT>`);<EOL>            }<EOL>        }<EOL>        console.log(args.join(\"<STR_LIT>\"));<EOL>        return <NUM_LIT>;<EOL>    }<EOL>    config[\"<STR_LIT>\"] = currentDirUri;<EOL>    const api = new","gt":"AutoRest(new RealFileSystem());"}
{"input":"<s> async function legacyMain(autorestArgs: string[]): Promise<number> {<EOL>    <EOL>    const currentDirUri = CreateFolderUri(currentDirectory());<EOL>    const dataStore = new DataStore();<EOL>    let config: AutoRestConfigurationImpl = {};<EOL>    try {<EOL>        config = await CreateConfiguration(currentDirUri, dataStore.GetReadThroughScope(new RealFileSystem()), autorestArgs);<EOL>    }<EOL>    catch (e) {<EOL>        console.error(color(\"<STR_LIT>\"));<EOL>        console.error(\"<STR_LIT>\");<EOL>        console.error(color(\"<STR_LIT>\" +<EOL>            \"<STR_LIT>\" +<EOL>            \"<STR_LIT>\" +<EOL>            \"<STR_LIT>\"));<EOL>        console.error(\"<STR_LIT>\");<EOL>        console.error(color(\"<STR_LIT>\" + e));<EOL>        await showHelp();<EOL>        return <NUM_LIT>;<EOL>    }<EOL>    <EOL>    if (autorestArgs[<NUM_LIT>] === \"<STR_LIT>\") {<EOL>        const clientNameGuess = (config[\"<STR_LIT>\"] || {}).title || Parse<any>(await ReadUri((config[\"<STR_LIT>\"] as any)[<NUM_LIT>])).info.title;<EOL>        await autorestInit(clientNameGuess, Array.isArray(config[\"<STR_LIT>\"]) ? config[\"<STR_LIT>\"] as any : []);<EOL>        return <NUM_LIT>;<EOL>    }<EOL>    <EOL>    if (autorestArgs[<NUM_LIT>] === \"<STR_LIT>\") {<EOL>        console.log(`<STR_LIT>`.replace(/~/g, \"<STR_LIT>\"));<EOL>        return <NUM_LIT>;<EOL>    }<EOL>    <EOL>    if (autorestArgs[<NUM_LIT>] === \"<STR_LIT>\") {<EOL>        const args: string[] = [];<EOL>        for (const node of nodes(config, \"<STR_LIT>\")) {<EOL>            const path = node.path.join(\"<STR_LIT>\");<EOL>            const values = node.value instanceof Array ? node.value : (typeof node.value === \"<STR_LIT>\" ? [] : [node.value]);<EOL>            for (const value of values) {<EOL>                args.push(`<STR_LIT>`);<EOL>            }<EOL>        }<EOL>        console.log(args.join(\"<STR_LIT>\"));<EOL>        return <NUM_LIT>;<EOL>    }<EOL>    config[\"<STR_LIT>\"] = currentDirUri;<EOL>    const api = new AutoRest(new RealFileSystem());<EOL>    api.AddConfiguration(config);<EOL>    const view = await api.view;<EOL>    let outstanding: Promise<void> = Promise.resolve();<EOL>    api.GeneratedFile.Subscribe((_, file) => outstanding = outstanding.then(() => WriteString(file.uri, file.content)));<EOL>    api.ClearFolder.Subscribe((_, folder) => outstanding = outstanding.then(async () => { try {<EOL>        await ClearFolder(folder);<EOL>    }<EOL>    catch (e) { } }));<EOL>","gt":"subscribeMessages(api, () => { });"}
{"input":"<s> async function legacyMain(autorestArgs: string[]): Promise<number> {<EOL>    <EOL>    const currentDirUri = CreateFolderUri(currentDirectory());<EOL>    const dataStore = new DataStore();<EOL>    let config: AutoRestConfigurationImpl = {};<EOL>    try {<EOL>        config = await CreateConfiguration(currentDirUri, dataStore.GetReadThroughScope(new RealFileSystem()), autorestArgs);<EOL>    }<EOL>    catch (e) {<EOL>        console.error(color(\"<STR_LIT>\"));<EOL>        console.error(\"<STR_LIT>\");<EOL>        console.error(color(\"<STR_LIT>\" +<EOL>            \"<STR_LIT>\" +<EOL>            \"<STR_LIT>\" +<EOL>            \"<STR_LIT>\"));<EOL>        console.error(\"<STR_LIT>\");<EOL>        console.error(color(\"<STR_LIT>\" + e));<EOL>        await showHelp();<EOL>        return <NUM_LIT>;<EOL>    }<EOL>    <EOL>    if (autorestArgs[<NUM_LIT>] === \"<STR_LIT>\") {<EOL>        const clientNameGuess = (config[\"<STR_LIT>\"] || {}).title || Parse<any>(await ReadUri((config[\"<STR_LIT>\"] as any)[<NUM_LIT>])).info.title;<EOL>        await autorestInit(clientNameGuess, Array.isArray(config[\"<STR_LIT>\"]) ? config[\"<STR_LIT>\"] as any : []);<EOL>        return <NUM_LIT>;<EOL>    }<EOL>    <EOL>    if (autorestArgs[<NUM_LIT>] === \"<STR_LIT>\") {<EOL>        console.log(`<STR_LIT>`.replace(/~/g, \"<STR_LIT>\"));<EOL>        return <NUM_LIT>;<EOL>    }<EOL>    <EOL>    if (autorestArgs[<NUM_LIT>] === \"<STR_LIT>\") {<EOL>        const args: string[] = [];<EOL>        for (const node of nodes(config, \"<STR_LIT>\")) {<EOL>            const path = node.path.join(\"<STR_LIT>\");<EOL>            const values = node.value instanceof Array ? node.value : (typeof node.value === \"<STR_LIT>\" ? [] : [node.value]);<EOL>            for (const value of values) {<EOL>                args.push(`<STR_LIT>`);<EOL>            }<EOL>        }<EOL>        console.log(args.join(\"<STR_LIT>\"));<EOL>        return <NUM_LIT>;<EOL>    }<EOL>    config[\"<STR_LIT>\"] = currentDirUri;<EOL>    const api = new AutoRest(new RealFileSystem());<EOL>    api.AddConfiguration(config);<EOL>    const view = await api.view;<EOL>    let outstanding: Promise<void> = Promise.resolve();<EOL>    api.GeneratedFile.Subscribe((_, file) => outstanding = outstanding.then(() => WriteString(file.uri, file.content)));<EOL>    api.ClearFolder.Subscribe((_, folder) => outstanding = outstanding.then(async () => { try {<EOL>        await ClearFolder(folder);<EOL>    }<EOL>    catch (e) { } }));<EOL>    subscribeMessages(api, () => { });<EOL>    <EOL>    for (var arg of autorestArgs) {<EOL>        if (arg.startsWith(\"<STR_LIT>\")) {<EOL>            view.","gt":"Message({"}
{"input":"<s> async function legacyMain(autorestArgs: string[]): Promise<number> {<EOL>    <EOL>    const currentDirUri = CreateFolderUri(currentDirectory());<EOL>    const dataStore = new DataStore();<EOL>    let config: AutoRestConfigurationImpl = {};<EOL>    try {<EOL>        config = await CreateConfiguration(currentDirUri, dataStore.GetReadThroughScope(new RealFileSystem()), autorestArgs);<EOL>    }<EOL>    catch (e) {<EOL>        console.error(color(\"<STR_LIT>\"));<EOL>        console.error(\"<STR_LIT>\");<EOL>        console.error(color(\"<STR_LIT>\" +<EOL>            \"<STR_LIT>\" +<EOL>            \"<STR_LIT>\" +<EOL>            \"<STR_LIT>\"));<EOL>        console.error(\"<STR_LIT>\");<EOL>        console.error(color(\"<STR_LIT>\" + e));<EOL>        await showHelp();<EOL>        return <NUM_LIT>;<EOL>    }<EOL>    <EOL>    if (autorestArgs[<NUM_LIT>] === \"<STR_LIT>\") {<EOL>        const clientNameGuess = (config[\"<STR_LIT>\"] || {}).title || Parse<any>(await ReadUri((config[\"<STR_LIT>\"] as any)[<NUM_LIT>])).info.title;<EOL>        await autorestInit(clientNameGuess, Array.isArray(config[\"<STR_LIT>\"]) ? config[\"<STR_LIT>\"] as any : []);<EOL>        return <NUM_LIT>;<EOL>    }<EOL>    <EOL>    if (autorestArgs[<NUM_LIT>] === \"<STR_LIT>\") {<EOL>        console.log(`<STR_LIT>`.replace(/~/g, \"<STR_LIT>\"));<EOL>        return <NUM_LIT>;<EOL>    }<EOL>    <EOL>    if (autorestArgs[<NUM_LIT>] === \"<STR_LIT>\") {<EOL>        const args: string[] = [];<EOL>        for (const node of nodes(config, \"<STR_LIT>\")) {<EOL>            const path = node.path.join(\"<STR_LIT>\");<EOL>            const values = node.value instanceof Array ? node.value : (typeof node.value === \"<STR_LIT>\" ? [] : [node.value]);<EOL>            for (const value of values) {<EOL>                args.push(`<STR_LIT>`);<EOL>            }<EOL>        }<EOL>        console.log(args.join(\"<STR_LIT>\"));<EOL>        return <NUM_LIT>;<EOL>    }<EOL>    config[\"<STR_LIT>\"] = currentDirUri;<EOL>    const api = new AutoRest(new RealFileSystem());<EOL>    api.AddConfiguration(config);<EOL>    const view = await api.view;<EOL>    let outstanding: Promise<void> = Promise.resolve();<EOL>    api.GeneratedFile.Subscribe((_, file) => outstanding = outstanding.then(() => WriteString(file.uri, file.content)));<EOL>    api.ClearFolder.Subscribe((_, folder) => outstanding = outstanding.then(async () => { try {<EOL>        await ClearFolder(folder);<EOL>    }<EOL>    catch (e) { } }));<EOL>    subscribeMessages(api, () => { });<EOL>    <EOL>    for (var arg of autorestArgs) {<EOL>        if (arg.startsWith(\"<STR_LIT>\")) {<EOL>            view.Message({<EOL>","gt":"Channel: Channel.Warning,"}
{"input":"<s> async function legacyMain(autorestArgs: string[]): Promise<number> {<EOL>    <EOL>    const currentDirUri = CreateFolderUri(currentDirectory());<EOL>    const dataStore = new DataStore();<EOL>    let config: AutoRestConfigurationImpl = {};<EOL>    try {<EOL>        config = await CreateConfiguration(currentDirUri, dataStore.GetReadThroughScope(new RealFileSystem()), autorestArgs);<EOL>    }<EOL>    catch (e) {<EOL>        console.error(color(\"<STR_LIT>\"));<EOL>        console.error(\"<STR_LIT>\");<EOL>        console.error(color(\"<STR_LIT>\" +<EOL>            \"<STR_LIT>\" +<EOL>            \"<STR_LIT>\" +<EOL>            \"<STR_LIT>\"));<EOL>        console.error(\"<STR_LIT>\");<EOL>        console.error(color(\"<STR_LIT>\" + e));<EOL>        await showHelp();<EOL>        return <NUM_LIT>;<EOL>    }<EOL>    <EOL>    if (autorestArgs[<NUM_LIT>] === \"<STR_LIT>\") {<EOL>        const clientNameGuess = (config[\"<STR_LIT>\"] || {}).title || Parse<any>(await ReadUri((config[\"<STR_LIT>\"] as any)[<NUM_LIT>])).info.title;<EOL>        await autorestInit(clientNameGuess, Array.isArray(config[\"<STR_LIT>\"]) ? config[\"<STR_LIT>\"] as any : []);<EOL>        return <NUM_LIT>;<EOL>    }<EOL>    <EOL>    if (autorestArgs[<NUM_LIT>] === \"<STR_LIT>\") {<EOL>        console.log(`<STR_LIT>`.replace(/~/g, \"<STR_LIT>\"));<EOL>        return <NUM_LIT>;<EOL>    }<EOL>    <EOL>    if (autorestArgs[<NUM_LIT>] === \"<STR_LIT>\") {<EOL>        const args: string[] = [];<EOL>        for (const node of nodes(config, \"<STR_LIT>\")) {<EOL>            const path = node.path.join(\"<STR_LIT>\");<EOL>            const values = node.value instanceof Array ? node.value : (typeof node.value === \"<STR_LIT>\" ? [] : [node.value]);<EOL>            for (const value of values) {<EOL>                args.push(`<STR_LIT>`);<EOL>            }<EOL>        }<EOL>        console.log(args.join(\"<STR_LIT>\"));<EOL>        return <NUM_LIT>;<EOL>    }<EOL>    config[\"<STR_LIT>\"] = currentDirUri;<EOL>    const api = new AutoRest(new RealFileSystem());<EOL>    api.AddConfiguration(config);<EOL>    const view = await api.view;<EOL>    let outstanding: Promise<void> = Promise.resolve();<EOL>    api.GeneratedFile.Subscribe((_, file) => outstanding = outstanding.then(() => WriteString(file.uri, file.content)));<EOL>    api.ClearFolder.Subscribe((_, folder) => outstanding = outstanding.then(async () => { try {<EOL>        await ClearFolder(folder);<EOL>    }<EOL>    catch (e) { } }));<EOL>    subscribeMessages(api, () => { });<EOL>    <EOL>    for (var arg of autorestArgs) {<EOL>        if (arg.startsWith(\"<STR_LIT>\")) {<EOL>            view.Message({<EOL>                Channel: Channel.Warning,<EOL>                Text: `<STR_LIT>` +<EOL>                    \"<STR_LIT>\" +<EOL>","gt":"\"<STR_LIT>\""}
{"input":"<s> export function injectCoreHtml(indexHtml: string, inject: string) {<EOL>    <EOL>    const existingTag = indexHtml.match(/<script data-ionic=\"inject\">[\\s\\S]*?<\\/script>/gi);<EOL>    if (existingTag) {<EOL>        return indexHtml.replace(existingTag[<NUM_LIT>], inject.trim());<EOL>    }<EOL>    <EOL>    const headTag = indexHtml.match(/<head[^>]*>/gi);<EOL>    if (headTag) {<EOL>        return","gt":"indexHtml.replace(headTag[<NUM_LIT>], `<STR_LIT>`);"}
{"input":"<s> export function injectCoreHtml(indexHtml: string, inject: string) {<EOL>    <EOL>    const existingTag = indexHtml.match(/<script data-ionic=\"inject\">[\\s\\S]*?<\\/script>/gi);<EOL>    if (existingTag) {<EOL>        return indexHtml.replace(existingTag[<NUM_LIT>], inject.trim());<EOL>    }<EOL>    <EOL>    const headTag = indexHtml.match(/<head[^>]*>/gi);<EOL>    if (headTag) {<EOL>        return indexHtml.replace(headTag[<NUM_LIT>], `<STR_LIT>`);<EOL>    }<EOL>    <EOL>    const htmlTag = indexHtml.match(/<html[^>]*>/gi);<EOL>","gt":"if (htmlTag) {"}
{"input":"<s> /**<EOL> * Returns the number of days in the month<EOL> * @param {number} month - The month number to target (months 1-12).<EOL> * @param {number} year - The year to target.<EOL> * @return {Number} The number of days in the month.<EOL> */<EOL>function daysInMonth(month: number, year: number) {<EOL>    return new Date(year, month, <NUM_LIT>).","gt":"getDate();"}
{"input":"<s> export function main() {<EOL>    describe('<STR_LIT>', () => {<EOL>        beforeEach(() => {<EOL>            TestBed.configureTestingModule({<EOL>                declarations: [Infragistics.IgSparklineComponent, TestComponent]<EOL>            });<EOL>        });<EOL>        it(","gt":"'<STR_LIT>', (done) => {"}
{"input":"<s> export function main() {<EOL>    describe('<STR_LIT>', () => {<EOL>        beforeEach(() => {<EOL>            TestBed.configureTestingModule({<EOL>                declarations: [Infragistics.IgSparklineComponent, TestComponent]<EOL>            });<EOL>        });<EOL>        it('<STR_LIT>', (done) => {<EOL>            var template = '<STR_LIT>';<EOL>            TestBed.overrideComponent(TestComponent, {<EOL>                set: {<EOL>                    template: template<EOL>                }<EOL>            });<EOL>            TestBed.compileComponents().then(() => {<EOL>                let fixture = TestBed.createComponent(TestComponent);<EOL>                fixture.detectChanges();<EOL>                expect(","gt":"fixture.debugElement.componentInstance.viewChild instanceof Infragistics.IgSparklineComponent)"}
{"input":"<s> export function main() {<EOL>    describe('<STR_LIT>', () => {<EOL>        beforeEach(() => {<EOL>            TestBed.configureTestingModule({<EOL>                declarations: [Infragistics.IgSplitButtonComponent, TestComponent]<EOL>            });<EOL>        });<EOL>","gt":"it('<STR_LIT>', (done) => {"}
{"input":"<s> export function main() {<EOL>    describe('<STR_LIT>', () => {<EOL>        beforeEach(() => {<EOL>            TestBed.configureTestingModule({<EOL>                declarations: [Infragistics.IgSplitButtonComponent, TestComponent]<EOL>            });<EOL>        });<EOL>        it('<STR_LIT>', (done) => {<EOL>            var template = '<STR_LIT>';<EOL>            TestBed.overrideComponent(TestComponent, {<EOL>                set: {<EOL>                    template: template<EOL>                }<EOL>            });<EOL>            TestBed.compileComponents().then(() => {<EOL>                let fixture = TestBed.createComponent(TestComponent);<EOL>                fixture.detectChanges();<EOL>                expect(fixture.debugElement.componentInstance.","gt":"viewChild instanceof Infragistics.IgSplitButtonComponent)"}
{"input":"<s> <EOL><EOL>function f0(x): number {<EOL>    while (","gt":"true)"}
{"input":"<s> function f11(x): number {<EOL>    test: try {<EOL>        do {<EOL>            do {<EOL>                break","gt":"test;"}
{"input":"<s> function f11(x): number {<EOL>    test: try {<EOL>        do {<EOL>            do {<EOL>                break test;<EOL>            } while (true);<EOL>            x++;<EOL>        } while (true);<EOL>    }<EOL>    catch (","gt":"e) {"}
{"input":"<s> export function createDefaultFormatCodeSettings(): ts.FormatCodeSettings {<EOL>    return {<EOL>        baseIndentSize: <NUM_LIT>,<EOL>        indentSize: <NUM_LIT>,<EOL>        tabSize: <NUM_LIT>,<EOL>","gt":"indentStyle: ts.IndentStyle.Smart,"}
{"input":"<s> export function createDefaultFormatCodeSettings(): ts.FormatCodeSettings {<EOL>    return {<EOL>        baseIndentSize: <NUM_LIT>,<EOL>        indentSize: <NUM_LIT>,<EOL>        tabSize: <NUM_LIT>,<EOL>        indentStyle: ts.IndentStyle.Smart,<EOL>        newLineCharacter: \"<STR_LIT>\",<EOL>        convertTabsToSpaces: true,<EOL>","gt":"insertSpaceAfterCommaDelimiter: true,"}
{"input":"<s> export function createDefaultFormatCodeSettings(): ts.FormatCodeSettings {<EOL>    return {<EOL>        baseIndentSize: <NUM_LIT>,<EOL>        indentSize: <NUM_LIT>,<EOL>        tabSize: <NUM_LIT>,<EOL>        indentStyle: ts.IndentStyle.Smart,<EOL>        newLineCharacter: \"<STR_LIT>\",<EOL>        convertTabsToSpaces: true,<EOL>        insertSpaceAfterCommaDelimiter: true,<EOL>        insertSpaceAfterSemicolonInForStatements: true,<EOL>        insertSpaceBeforeAndAfterBinaryOperators: true,<EOL>        insertSpaceAfterConstructor: false,<EOL>        insertSpaceAfterKeywordsInControlFlowStatements: true,<EOL>        insertSpaceAfterFunctionKeywordForAnonymousFunctions:","gt":"false,"}
{"input":"<s> export function createDefaultFormatCodeSettings(): ts.FormatCodeSettings {<EOL>    return {<EOL>        baseIndentSize: <NUM_LIT>,<EOL>        indentSize: <NUM_LIT>,<EOL>        tabSize: <NUM_LIT>,<EOL>        indentStyle: ts.IndentStyle.Smart,<EOL>        newLineCharacter: \"<STR_LIT>\",<EOL>        convertTabsToSpaces: true,<EOL>        insertSpaceAfterCommaDelimiter: true,<EOL>        insertSpaceAfterSemicolonInForStatements: true,<EOL>        insertSpaceBeforeAndAfterBinaryOperators: true,<EOL>        insertSpaceAfterConstructor: false,<EOL>        insertSpaceAfterKeywordsInControlFlowStatements: true,<EOL>        insertSpaceAfterFunctionKeywordForAnonymousFunctions: false,<EOL>        insertSpaceAfterOpeningAndBeforeClosingNonemptyParenthesis: false,<EOL>        insertSpaceAfterOpeningAndBeforeClosingNonemptyBrackets: false,<EOL>        insertSpaceAfterOpeningAndBeforeClosingNonemptyBraces: true,<EOL>        insertSpaceAfterOpeningAndBeforeClosingTemplateStringBraces: false,<EOL>        insertSpaceAfterOpeningAndBeforeClosingJsxExpressionBraces: false,<EOL>","gt":"insertSpaceAfterTypeAssertion: false,"}
{"input":"<s> export function getConfigFileName(baseDir: string, configFileName: string): string | null {<EOL>    let configFilePath = path.resolve(baseDir, configFileName);<EOL>    if (fs.existsSync(configFilePath)) {<EOL>        return","gt":"configFilePath;"}
{"input":"<s> export function readFilesFromTsconfig(configPath: string): string[] {<EOL>    return","gt":"readTsconfig(configPath).fileNames;"}
{"input":"<s> function render(context: BuildContext, sassConfig: SassConfig): Promise<string> {<EOL>    return new Promise((resolve, reject) => {<EOL>        sassConfig.omitSourceMapUrl = false;<EOL>        if (sassConfig.sourceMap) {<EOL>            sassConfig.sourceMapContents = true;<EOL>        }<EOL>        nodeSassRender(sassConfig, (sassError: SassError, sassResult: Result) => {<EOL>            const diagnostics = runSassDiagnostics(","gt":"context, sassError);"}
{"input":"<s> function render(context: BuildContext, sassConfig: SassConfig): Promise<string> {<EOL>    return new Promise((resolve, reject) => {<EOL>        sassConfig.omitSourceMapUrl = false;<EOL>        if (sassConfig.sourceMap) {<EOL>            sassConfig.sourceMapContents = true;<EOL>        }<EOL>        nodeSassRender(sassConfig, (sassError: SassError, sassResult: Result) => {<EOL>            const diagnostics = runSassDiagnostics(context, sassError);<EOL>            if (diagnostics.length) {<EOL>                printDiagnostics(context, DiagnosticsType.Sass, diagnostics, true, true);<EOL>                <EOL>                reject(new BuildError('<STR_LIT>'));<EOL>            }<EOL>            else {<EOL>                <EOL>                renderSassSuccess(context, sassResult, sassConfig).then(outFile => {<EOL>                    resolve(outFile);<EOL>                }).","gt":"catch(err => {"}
{"input":"<s> function consoleLogDiagnostic(d: Diagnostic) {<EOL>    if (d.level === '<STR_LIT>') {<EOL>        Logger.warn(d.header);<EOL>    }<EOL>","gt":"else {"}
{"input":"<s> function consoleLogDiagnostic(d: Diagnostic) {<EOL>    if (d.level === '<STR_LIT>') {<EOL>        Logger.warn(d.header);<EOL>    }<EOL>    else {<EOL>","gt":"Logger.error(d.header);"}
{"input":"<s> function consoleLogDiagnostic(d: Diagnostic) {<EOL>    if (d.level === '<STR_LIT>') {<EOL>        Logger.warn(d.header);<EOL>    }<EOL>    else {<EOL>        Logger.error(d.header);<EOL>    }<EOL>","gt":"Logger.wordWrap([d.messageText]).forEach(m => {"}
{"input":"<s> function consoleLogDiagnostic(d: Diagnostic) {<EOL>    if (d.level === '<STR_LIT>') {<EOL>        Logger.warn(d.header);<EOL>    }<EOL>    else {<EOL>        Logger.error(d.header);<EOL>    }<EOL>    Logger.wordWrap([d.messageText]).forEach(m => {<EOL>        console.log(m);<EOL>    });<EOL>    console.log('<STR_LIT>');<EOL>    if (d.lines && d.lines.length) {<EOL>        const lines = prepareLines(","gt":"d.lines, '<STR_LIT>');"}
{"input":"<s> function consoleLogDiagnostic(d: Diagnostic) {<EOL>    if (d.level === '<STR_LIT>') {<EOL>        Logger.warn(d.header);<EOL>    }<EOL>    else {<EOL>        Logger.error(d.header);<EOL>    }<EOL>    Logger.wordWrap([d.messageText]).forEach(m => {<EOL>        console.log(m);<EOL>    });<EOL>    console.log('<STR_LIT>');<EOL>    if (d.lines && d.lines.length) {<EOL>        const lines = prepareLines(d.lines, '<STR_LIT>');<EOL>        lines.forEach(l => {<EOL>            if (!isMeaningfulLine(l.text)) {<EOL>                return;<EOL>            }<EOL>            let msg = `<STR_LIT>`;<EOL>            while (msg.length < Logger.INDENT.length) {<EOL>                msg = '<STR_LIT>' + msg;<EOL>            }<EOL>            let","gt":"text = l.text;"}
{"input":"<s> function consoleLogDiagnostic(d: Diagnostic) {<EOL>    if (d.level === '<STR_LIT>') {<EOL>        Logger.warn(d.header);<EOL>    }<EOL>    else {<EOL>        Logger.error(d.header);<EOL>    }<EOL>    Logger.wordWrap([d.messageText]).forEach(m => {<EOL>        console.log(m);<EOL>    });<EOL>    console.log('<STR_LIT>');<EOL>    if (d.lines && d.lines.length) {<EOL>        const lines = prepareLines(d.lines, '<STR_LIT>');<EOL>        lines.forEach(l => {<EOL>            if (!isMeaningfulLine(l.text)) {<EOL>                return;<EOL>            }<EOL>            let msg = `<STR_LIT>`;<EOL>            while (msg.length < Logger.INDENT.length) {<EOL>                msg = '<STR_LIT>' + msg;<EOL>            }<EOL>            let text = l.text;<EOL>            if (l.errorCharStart > -<NUM_LIT>) {<EOL>                text = consoleHighlightError(text, l.errorCharStart, l.errorLength);<EOL>            }<EOL>            msg = chalk.dim(msg);<EOL>            if (d.language === '<STR_LIT>') {<EOL>                msg += jsConsoleSyntaxHighlight(text);<EOL>            }<EOL>            else","gt":"if (d.language === '<STR_LIT>') {"}
{"input":"<s> /**<EOL> * Returns the Style corresponding to the label position<EOL> */<EOL>function _getStyleForLabelBasedOnPosition(labelPosition: Position, styles: ISpinButtonStyles): IStyle {<EOL>    switch (labelPosition) {<EOL>        case Position.start:<EOL>            return styles.labelWrapperStart;<EOL>","gt":"case Position.end:"}
{"input":"<s> /**<EOL> * Returns the Style corresponding to the label position<EOL> */<EOL>function _getStyleForLabelBasedOnPosition(labelPosition: Position, styles: ISpinButtonStyles): IStyle {<EOL>    switch (labelPosition) {<EOL>        case Position.start:<EOL>            return styles.labelWrapperStart;<EOL>        case Position.end:<EOL>            return styles.labelWrapperEnd;<EOL>        case Position.top:<EOL>            return styles.labelWrapperTop;<EOL>        case Position.","gt":"bottom:"}
{"input":"<s> export function copyUpdate(event: string, filePath: string, context: BuildContext) {<EOL>    const changedFile: ChangedFile = {<EOL>        event: event,<EOL>        filePath: filePath,<EOL>        ext: extname(filePath).toLowerCase()<EOL>    };<EOL>    <EOL>    if (!queuedCopyChanges.some(f =>","gt":"f.filePath === filePath)) {"}
{"input":"<s> export function copyUpdate(event: string, filePath: string, context: BuildContext) {<EOL>    const changedFile: ChangedFile = {<EOL>        event: event,<EOL>        filePath: filePath,<EOL>        ext: extname(filePath).toLowerCase()<EOL>    };<EOL>    <EOL>    if (!queuedCopyChanges.some(f => f.filePath === filePath)) {<EOL>        queuedCopyChanges.push(changedFile);<EOL>        <EOL>        clearTimeout(queuedCopyTimerId);<EOL>        <EOL>","gt":"queuedCopyTimerId = setTimeout(() => {"}
{"input":"<s> export function updateTemplate(componentDir: string, match: TemplateUrlMatch): string {<EOL>    const htmlFilePath = join(componentDir, match.templateUrl);<EOL>    try {<EOL>        const templateContent = readFileSync(htmlFilePath,","gt":"'<STR_LIT>');"}
{"input":"<s> export function setBundledFiles(context: BuildContext) {<EOL>    const bundledFilesToWrite = context.fileCache.getAll().filter(file => {<EOL>        return dirname(file.path).indexOf(context.buildDir) >=","gt":"<NUM_LIT> && (file.path.endsWith('<STR_LIT>') || file.path.endsWith('<STR_LIT>'));"}
{"input":"<s> /**<EOL> *<EOL> * @param {(schema: JsonSchema, parameters: DecoratorParameters) => void} fn<EOL> * @returns {(...parameters: any[]) => any}<EOL> */<EOL>export function decoratorSchemaFactory(fn: (schema: JsonSchema, parameters: DecoratorParameters) => void) {<EOL>    return (...parameters: any[]): any => {<EOL>        let schema: JsonSchema;<EOL>        switch (getDecoratorType(parameters)) {<EOL>            case \"<STR_LIT>\":<EOL>                schema = PropertyRegistry.get(parameters[<NUM_LIT>], parameters[<NUM_LIT>]).","gt":"schema;"}
{"input":"<s> /**<EOL> *<EOL> * @param {(schema: JsonSchema, parameters: DecoratorParameters) => void} fn<EOL> * @returns {(...parameters: any[]) => any}<EOL> */<EOL>export function decoratorSchemaFactory(fn: (schema: JsonSchema, parameters: DecoratorParameters) => void) {<EOL>    return (...parameters: any[]): any => {<EOL>        let schema: JsonSchema;<EOL>        switch (getDecoratorType(parameters)) {<EOL>            case \"<STR_LIT>\":<EOL>                schema = PropertyRegistry.get(parameters[<NUM_LIT>], parameters[<NUM_LIT>]).schema;<EOL>                break;<EOL>            case \"<STR_LIT>\":<EOL>                schema = JsonSchemesRegistry.createIfNotExists(parameters[<NUM_LIT>]);<EOL>","gt":"break;"}
{"input":"<s> /**<EOL> *<EOL> * @param {(schema: JsonSchema, parameters: DecoratorParameters) => void} fn<EOL> * @returns {(...parameters: any[]) => any}<EOL> */<EOL>export function decoratorSchemaFactory(fn: (schema: JsonSchema, parameters: DecoratorParameters) => void) {<EOL>    return (...parameters: any[]): any => {<EOL>        let schema: JsonSchema;<EOL>        switch (getDecoratorType(parameters)) {<EOL>            case \"<STR_LIT>\":<EOL>                schema = PropertyRegistry.get(parameters[<NUM_LIT>], parameters[<NUM_LIT>]).schema;<EOL>                break;<EOL>            case \"<STR_LIT>\":<EOL>                schema = JsonSchemesRegistry.createIfNotExists(parameters[<NUM_LIT>]);<EOL>                break;<EOL>        }<EOL>        const result: any = fn(schema!, parameters as DecoratorParameters);<EOL>        if (typeof result === \"<STR_LIT>\") {<EOL>            result(...","gt":"parameters);"}
{"input":"<s> function getUserPackageJson(userRootDir: string) {<EOL>    try {<EOL>","gt":"return readJsonSync(join(userRootDir, '<STR_LIT>'));"}
{"input":"<s> export function getSystemData(userRootDir: string) {<EOL>    const d = {<EOL>        ionicAppScripts: getAppScriptsVersion(),<EOL>        ionicFramework: '<STR_LIT>',<EOL>        ionicNative: '<STR_LIT>',<EOL>","gt":"angularCore: '<STR_LIT>',"}
{"input":"<s> export function getSystemData(userRootDir: string) {<EOL>    const d = {<EOL>        ionicAppScripts: getAppScriptsVersion(),<EOL>        ionicFramework: '<STR_LIT>',<EOL>        ionicNative: '<STR_LIT>',<EOL>        angularCore: '<STR_LIT>',<EOL>        angularCompilerCli: '<STR_LIT>',<EOL>        node: process.version.replace('<STR_LIT>', '<STR_LIT>'),<EOL>","gt":"osName: osName()"}
{"input":"<s> export function getSystemData(userRootDir: string) {<EOL>    const d = {<EOL>        ionicAppScripts: getAppScriptsVersion(),<EOL>        ionicFramework: '<STR_LIT>',<EOL>        ionicNative: '<STR_LIT>',<EOL>        angularCore: '<STR_LIT>',<EOL>        angularCompilerCli: '<STR_LIT>',<EOL>        node: process.version.replace('<STR_LIT>', '<STR_LIT>'),<EOL>        osName: osName()<EOL>    };<EOL>    try {<EOL>        const userPackageJson = getUserPackageJson(userRootDir);<EOL>        if (userPackageJson) {<EOL>","gt":"const userDependencies = userPackageJson.dependencies;"}
{"input":"<s> export function getSystemData(userRootDir: string) {<EOL>    const d = {<EOL>        ionicAppScripts: getAppScriptsVersion(),<EOL>        ionicFramework: '<STR_LIT>',<EOL>        ionicNative: '<STR_LIT>',<EOL>        angularCore: '<STR_LIT>',<EOL>        angularCompilerCli: '<STR_LIT>',<EOL>        node: process.version.replace('<STR_LIT>', '<STR_LIT>'),<EOL>        osName: osName()<EOL>    };<EOL>    try {<EOL>        const userPackageJson = getUserPackageJson(userRootDir);<EOL>        if (userPackageJson) {<EOL>            const userDependencies = userPackageJson.dependencies;<EOL>            if (userDependencies) {<EOL>                d.ionicFramework = userDependencies['<STR_LIT>'];<EOL>                d.ionicNative = userDependencies['<STR_LIT>'];<EOL>                d.angularCore = userDependencies['<STR_LIT>'];<EOL>                d.","gt":"angularCompilerCli = userDependencies['<STR_LIT>'];"}
{"input":"<s> export function stringSplice(source: string, startIndex: number, numToDelete: number, newContent: string) {<EOL>    return source.slice(<NUM_LIT>,","gt":"startIndex) + newContent + source.slice(startIndex + Math.abs(numToDelete));"}
{"input":"<s> export function getIntPropertyValue(propertyName: string): number {<EOL>    const","gt":"result = process.env[propertyName];"}
{"input":"<s> export function semverStringToObject(semverString: string): SemverVersion {<EOL>    const versionArray = semverString.split('<STR_LIT>');<EOL>","gt":"return {"}
{"input":"<s> export function getNodeBinExecutable(context: BuildContext, cmd: string) {<EOL>    let cmdPath = join(context.rootDir, '<STR_LIT>', '<STR_LIT>', cmd);<EOL>    try {<EOL>        accessSync(","gt":"cmdPath);"}
{"input":"<s> function isNegatedGlob(pattern: string) {<EOL>    var glob = { negated: false, pattern: pattern, original: pattern };<EOL>","gt":"if (pattern.charAt(<NUM_LIT>) === '<STR_LIT>' && pattern.charAt(<NUM_LIT>) !== '<STR_LIT>') {"}
{"input":"<s> <EOL>function testSort() {<EOL>    let data: any[] = [];<EOL>    let dataGenerator: DataGenerator;<EOL>    beforeEach(","gt":"async(() => {"}
{"input":"<s> <EOL>function testSort() {<EOL>    let data: any[] = [];<EOL>    let dataGenerator: DataGenerator;<EOL>    beforeEach(async(() => {<EOL>        dataGenerator = new DataGenerator();<EOL>","gt":"data = dataGenerator.data;"}
{"input":"<s> <EOL>function testSort() {<EOL>    let data: any[] = [];<EOL>    let dataGenerator: DataGenerator;<EOL>    beforeEach(async(() => {<EOL>        dataGenerator = new DataGenerator();<EOL>        data = dataGenerator.data;<EOL>    }));<EOL>    describe(","gt":"\"<STR_LIT>\", () => {"}
{"input":"<s> <EOL>function testSort() {<EOL>    let data: any[] = [];<EOL>    let dataGenerator: DataGenerator;<EOL>    beforeEach(async(() => {<EOL>        dataGenerator = new DataGenerator();<EOL>        data = dataGenerator.data;<EOL>    }));<EOL>    describe(\"<STR_LIT>\", () => {<EOL>        it(\"<STR_LIT>\", () => {<EOL>            const se: ISortingExpression = {<EOL>                dir: SortingDirection.Desc,<EOL>","gt":"fieldName: \"<STR_LIT>\""}
{"input":"<s> <EOL>function testSort() {<EOL>    let data: any[] = [];<EOL>    let dataGenerator: DataGenerator;<EOL>    beforeEach(async(() => {<EOL>        dataGenerator = new DataGenerator();<EOL>        data = dataGenerator.data;<EOL>    }));<EOL>    describe(\"<STR_LIT>\", () => {<EOL>        it(\"<STR_LIT>\", () => {<EOL>            const se: ISortingExpression = {<EOL>                dir: SortingDirection.Desc,<EOL>                fieldName: \"<STR_LIT>\"<EOL>            };<EOL>            const res = DataUtil.sort(data, { expressions: [se] });<EOL>            expect(dataGenerator.getValuesForColumn(res, \"<STR_LIT>\"))<EOL>                .toEqual(dataGenerator.generateArray(<NUM_LIT>, <NUM_LIT>));<EOL>        });<EOL>        it(\"<STR_LIT>\", () => {<EOL>","gt":"const se: ISortingExpression = {"}
{"input":"<s> <EOL>function testSort() {<EOL>    let data: any[] = [];<EOL>    let dataGenerator: DataGenerator;<EOL>    beforeEach(async(() => {<EOL>        dataGenerator = new DataGenerator();<EOL>        data = dataGenerator.data;<EOL>    }));<EOL>    describe(\"<STR_LIT>\", () => {<EOL>        it(\"<STR_LIT>\", () => {<EOL>            const se: ISortingExpression = {<EOL>                dir: SortingDirection.Desc,<EOL>                fieldName: \"<STR_LIT>\"<EOL>            };<EOL>            const res = DataUtil.sort(data, { expressions: [se] });<EOL>            expect(dataGenerator.getValuesForColumn(res, \"<STR_LIT>\"))<EOL>                .toEqual(dataGenerator.generateArray(<NUM_LIT>, <NUM_LIT>));<EOL>        });<EOL>        it(\"<STR_LIT>\", () => {<EOL>            const se: ISortingExpression = {<EOL>                dir: SortingDirection.Asc,<EOL>                fieldName: \"<STR_LIT>\"<EOL>            };<EOL>            const res = DataUtil.sort(data, { expressions: [se] });<EOL>            expect(dataGenerator.getValuesForColumn(res, \"<STR_LIT>\"))<EOL>                .toEqual([false, false, false, true,","gt":"true]);"}
{"input":"<s> <EOL>function testSort() {<EOL>    let data: any[] = [];<EOL>    let dataGenerator: DataGenerator;<EOL>    beforeEach(async(() => {<EOL>        dataGenerator = new DataGenerator();<EOL>        data = dataGenerator.data;<EOL>    }));<EOL>    describe(\"<STR_LIT>\", () => {<EOL>        it(\"<STR_LIT>\", () => {<EOL>            const se: ISortingExpression = {<EOL>                dir: SortingDirection.Desc,<EOL>                fieldName: \"<STR_LIT>\"<EOL>            };<EOL>            const res = DataUtil.sort(data, { expressions: [se] });<EOL>            expect(dataGenerator.getValuesForColumn(res, \"<STR_LIT>\"))<EOL>                .toEqual(dataGenerator.generateArray(<NUM_LIT>, <NUM_LIT>));<EOL>        });<EOL>        it(\"<STR_LIT>\", () => {<EOL>            const se: ISortingExpression = {<EOL>                dir: SortingDirection.Asc,<EOL>                fieldName: \"<STR_LIT>\"<EOL>            };<EOL>            const res = DataUtil.sort(data, { expressions: [se] });<EOL>            expect(dataGenerator.getValuesForColumn(res, \"<STR_LIT>\"))<EOL>                .toEqual([false, false, false, true, true]);<EOL>        });<EOL>        <EOL>        it(\"<STR_LIT>\", () => {<EOL>            const se0: ISortingExpression = {<EOL>                dir: SortingDirection.Desc,<EOL>                fieldName: \"<STR_LIT>\"<EOL>            };<EOL>            const","gt":"se1: ISortingExpression = {"}
{"input":"<s> <EOL>function testSort() {<EOL>    let data: any[] = [];<EOL>    let dataGenerator: DataGenerator;<EOL>    beforeEach(async(() => {<EOL>        dataGenerator = new DataGenerator();<EOL>        data = dataGenerator.data;<EOL>    }));<EOL>    describe(\"<STR_LIT>\", () => {<EOL>        it(\"<STR_LIT>\", () => {<EOL>            const se: ISortingExpression = {<EOL>                dir: SortingDirection.Desc,<EOL>                fieldName: \"<STR_LIT>\"<EOL>            };<EOL>            const res = DataUtil.sort(data, { expressions: [se] });<EOL>            expect(dataGenerator.getValuesForColumn(res, \"<STR_LIT>\"))<EOL>                .toEqual(dataGenerator.generateArray(<NUM_LIT>, <NUM_LIT>));<EOL>        });<EOL>        it(\"<STR_LIT>\", () => {<EOL>            const se: ISortingExpression = {<EOL>                dir: SortingDirection.Asc,<EOL>                fieldName: \"<STR_LIT>\"<EOL>            };<EOL>            const res = DataUtil.sort(data, { expressions: [se] });<EOL>            expect(dataGenerator.getValuesForColumn(res, \"<STR_LIT>\"))<EOL>                .toEqual([false, false, false, true, true]);<EOL>        });<EOL>        <EOL>        it(\"<STR_LIT>\", () => {<EOL>            const se0: ISortingExpression = {<EOL>                dir: SortingDirection.Desc,<EOL>                fieldName: \"<STR_LIT>\"<EOL>            };<EOL>            const se1: ISortingExpression = {<EOL>                dir: SortingDirection.Asc,<EOL>                fieldName: \"<STR_LIT>\"<EOL>            };<EOL>            const res = DataUtil.sort(data, { expressions: [se0, se1] });<EOL>            expect(dataGenerator.getValuesForColumn(res, \"<STR_LIT>\"))<EOL>                .toEqual([<NUM_LIT>, <NUM_LIT>, <NUM_LIT>, <NUM_LIT>, <NUM_LIT>]);<EOL>        });<EOL>        it(\"<STR_LIT>\", () => {<EOL>            data[<NUM_LIT>].string = data[<NUM_LIT>].string.toUpperCase();<EOL>            const se0: ISortingExpression = {<EOL>                dir: SortingDirection.","gt":"Desc,"}
{"input":"<s> <EOL>function testSort() {<EOL>    let data: any[] = [];<EOL>    let dataGenerator: DataGenerator;<EOL>    beforeEach(async(() => {<EOL>        dataGenerator = new DataGenerator();<EOL>        data = dataGenerator.data;<EOL>    }));<EOL>    describe(\"<STR_LIT>\", () => {<EOL>        it(\"<STR_LIT>\", () => {<EOL>            const se: ISortingExpression = {<EOL>                dir: SortingDirection.Desc,<EOL>                fieldName: \"<STR_LIT>\"<EOL>            };<EOL>            const res = DataUtil.sort(data, { expressions: [se] });<EOL>            expect(dataGenerator.getValuesForColumn(res, \"<STR_LIT>\"))<EOL>                .toEqual(dataGenerator.generateArray(<NUM_LIT>, <NUM_LIT>));<EOL>        });<EOL>        it(\"<STR_LIT>\", () => {<EOL>            const se: ISortingExpression = {<EOL>                dir: SortingDirection.Asc,<EOL>                fieldName: \"<STR_LIT>\"<EOL>            };<EOL>            const res = DataUtil.sort(data, { expressions: [se] });<EOL>            expect(dataGenerator.getValuesForColumn(res, \"<STR_LIT>\"))<EOL>                .toEqual([false, false, false, true, true]);<EOL>        });<EOL>        <EOL>        it(\"<STR_LIT>\", () => {<EOL>            const se0: ISortingExpression = {<EOL>                dir: SortingDirection.Desc,<EOL>                fieldName: \"<STR_LIT>\"<EOL>            };<EOL>            const se1: ISortingExpression = {<EOL>                dir: SortingDirection.Asc,<EOL>                fieldName: \"<STR_LIT>\"<EOL>            };<EOL>            const res = DataUtil.sort(data, { expressions: [se0, se1] });<EOL>            expect(dataGenerator.getValuesForColumn(res, \"<STR_LIT>\"))<EOL>                .toEqual([<NUM_LIT>, <NUM_LIT>, <NUM_LIT>, <NUM_LIT>, <NUM_LIT>]);<EOL>        });<EOL>        it(\"<STR_LIT>\", () => {<EOL>            data[<NUM_LIT>].string = data[<NUM_LIT>].string.toUpperCase();<EOL>            const se0: ISortingExpression = {<EOL>                dir: SortingDirection.Desc,<EOL>                fieldName: \"<STR_LIT>\"<EOL>            };<EOL>            let res = DataUtil.sort(data, {<EOL>                expressions: [se0]<EOL>            });<EOL>            expect(dataGenerator.getValuesForColumn(res, \"<STR_LIT>\"))<EOL>                .toEqual([<NUM_LIT>, <NUM_LIT>, <NUM_LIT>, <NUM_LIT>, <NUM_LIT>], \"<STR_LIT>\");<EOL>","gt":"se0.ignoreCase = true;"}
{"input":"<s> function customizeConfig(config: NgbTimepickerConfig) {<EOL>    config.meridian = true;<EOL>    config.spinners = false;<EOL>    config.seconds =","gt":"true;"}
{"input":"<s> function* ParseCodeblocks(markdown: string): Iterable<commonmark.Node> {<EOL>    const parsed = ParseCommonmark(markdown);<EOL>    const walker = parsed.walker();<EOL>    let","gt":"event;"}
{"input":"<s> export function findObjectLiteralElementByName(properties: NodeArray<ObjectLiteralElement>, identifierToLookFor: string) {<EOL>","gt":"return properties.filter((propertyNode) => {"}
{"input":"<s> export function appendNgModuleExports(filePath: string, fileContent: string, declaration: string): string {<EOL>    const sourceFile = getTypescriptSourceFile(filePath, fileContent, ScriptTarget.Latest, false);<EOL>    const decorator = getNgModuleDecorator(path.basename(filePath), sourceFile);<EOL>    const obj = getNgModuleObjectLiteralArg(decorator);<EOL>","gt":"const properties = (findObjectLiteralElementByName(obj.properties, '<STR_LIT>') as PropertyAssignment);"}
{"input":"<s> export function appendNgModuleExports(filePath: string, fileContent: string, declaration: string): string {<EOL>    const sourceFile = getTypescriptSourceFile(filePath, fileContent, ScriptTarget.Latest, false);<EOL>    const decorator = getNgModuleDecorator(path.basename(filePath), sourceFile);<EOL>    const obj = getNgModuleObjectLiteralArg(decorator);<EOL>    const properties = (findObjectLiteralElementByName(obj.properties, '<STR_LIT>') as PropertyAssignment);<EOL>    const exportsProp = (properties.initializer as ArrayLiteralExpression).elements;<EOL>    if (exportsProp.length === <NUM_LIT>) {<EOL>        return appendEmpty(fileContent, exportsProp['<STR_LIT>'], declaration);<EOL>    }<EOL>","gt":"else {"}
{"input":"<s> export async function copySourcemaps(context: BuildContext, shouldPurge: boolean) {<EOL>    const copyBeforePurge = getBooleanPropertyValue(Constants.ENV_VAR_MOVE_SOURCE_MAPS);<EOL>    if (copyBeforePurge) {<EOL>        await mkDirpAsync(context.sourcemapDir);<EOL>    }<EOL>    const","gt":"fileNames = await readDirAsync(context.buildDir);"}
{"input":"<s> export async function copySourcemaps(context: BuildContext, shouldPurge: boolean) {<EOL>    const copyBeforePurge = getBooleanPropertyValue(Constants.ENV_VAR_MOVE_SOURCE_MAPS);<EOL>    if (copyBeforePurge) {<EOL>        await mkDirpAsync(context.sourcemapDir);<EOL>    }<EOL>    const fileNames = await readDirAsync(context.buildDir);<EOL>    <EOL>    const sourceMaps = fileNames.filter(fileName => fileName.endsWith('<STR_LIT>'));<EOL>    const toCopy = sourceMaps.filter(fileName => fileName.indexOf('<STR_LIT>') < <NUM_LIT> &&","gt":"fileName.endsWith('<STR_LIT>'));"}
{"input":"<s> export async function copySourcemaps(context: BuildContext, shouldPurge: boolean) {<EOL>    const copyBeforePurge = getBooleanPropertyValue(Constants.ENV_VAR_MOVE_SOURCE_MAPS);<EOL>    if (copyBeforePurge) {<EOL>        await mkDirpAsync(context.sourcemapDir);<EOL>    }<EOL>    const fileNames = await readDirAsync(context.buildDir);<EOL>    <EOL>    const sourceMaps = fileNames.filter(fileName => fileName.endsWith('<STR_LIT>'));<EOL>    const toCopy = sourceMaps.filter(fileName => fileName.indexOf('<STR_LIT>') < <NUM_LIT> && fileName.endsWith('<STR_LIT>'));<EOL>    const toCopyFullPaths = toCopy.map(fileName => join(context.buildDir, fileName));<EOL>    const toPurge = sourceMaps.map(sourceMap => join(context.buildDir, sourceMap));<EOL>","gt":"const copyFilePromises: Promise<any>[] = [];"}
{"input":"<s> export async function copySourcemaps(context: BuildContext, shouldPurge: boolean) {<EOL>    const copyBeforePurge = getBooleanPropertyValue(Constants.ENV_VAR_MOVE_SOURCE_MAPS);<EOL>    if (copyBeforePurge) {<EOL>        await mkDirpAsync(context.sourcemapDir);<EOL>    }<EOL>    const fileNames = await readDirAsync(context.buildDir);<EOL>    <EOL>    const sourceMaps = fileNames.filter(fileName => fileName.endsWith('<STR_LIT>'));<EOL>    const toCopy = sourceMaps.filter(fileName => fileName.indexOf('<STR_LIT>') < <NUM_LIT> && fileName.endsWith('<STR_LIT>'));<EOL>    const toCopyFullPaths = toCopy.map(fileName => join(context.buildDir, fileName));<EOL>    const toPurge = sourceMaps.map(sourceMap => join(context.buildDir, sourceMap));<EOL>    const copyFilePromises: Promise<any>[] = [];<EOL>    if (copyBeforePurge) {<EOL>        for (const fullPath of toCopyFullPaths) {<EOL>            const fileName =","gt":"basename(fullPath);"}
{"input":"<s> export async function copySourcemaps(context: BuildContext, shouldPurge: boolean) {<EOL>    const copyBeforePurge = getBooleanPropertyValue(Constants.ENV_VAR_MOVE_SOURCE_MAPS);<EOL>    if (copyBeforePurge) {<EOL>        await mkDirpAsync(context.sourcemapDir);<EOL>    }<EOL>    const fileNames = await readDirAsync(context.buildDir);<EOL>    <EOL>    const sourceMaps = fileNames.filter(fileName => fileName.endsWith('<STR_LIT>'));<EOL>    const toCopy = sourceMaps.filter(fileName => fileName.indexOf('<STR_LIT>') < <NUM_LIT> && fileName.endsWith('<STR_LIT>'));<EOL>    const toCopyFullPaths = toCopy.map(fileName => join(context.buildDir, fileName));<EOL>    const toPurge = sourceMaps.map(sourceMap => join(context.buildDir, sourceMap));<EOL>    const copyFilePromises: Promise<any>[] = [];<EOL>    if (copyBeforePurge) {<EOL>        for (const fullPath of toCopyFullPaths) {<EOL>            const fileName = basename(fullPath);<EOL>            copyFilePromises.push(copyFileAsync(fullPath, join(context.sourcemapDir, fileName)));<EOL>        }<EOL>    }<EOL>    await Promise.all(copyFilePromises);<EOL>    <EOL>    const purgeFilePromises:","gt":"Promise<any>[] = [];"}
{"input":"<s> function getWeekNumbers(element: HTMLElement): HTMLElement[] {<EOL>","gt":"return <HTMLElement[]>Array.from(element.querySelectorAll('<STR_LIT>'));"}
{"input":"<s> function getDates(element: HTMLElement): HTMLElement[] {<EOL>    return <HTMLElement[]>Array.from(element.","gt":"querySelectorAll('<STR_LIT>'));"}
{"input":"<s> /**<EOL> *<EOL> * @param target<EOL> * @returns {Boolean}<EOL> */<EOL>export function isArray(target: any): boolean {<EOL>    return Array.","gt":"isArray(target);"}
{"input":"<s> function CommonmarkParentHeading(startNode: commonmark.Node): commonmark.Node | null {<EOL>    const currentLevel = startNode.type === commonmarkHeadingNodeType<EOL>        ? startNode.level<EOL>        :","gt":"commonmarkHeadingMaxLevel;"}
{"input":"<s> function f7() {<EOL>    let x = []; <EOL>    x.","gt":"push(<NUM_LIT>);"}
{"input":"<s> /**<EOL> * Compute the difference in times, measured in ms<EOL> */<EOL>export function compareTimes(date1: Date, date2: Date) {<EOL>    return (<NUM_LIT> * (date1.getHours() - date2.getHours()) +<EOL>        <NUM_LIT> * (date1.getMinutes() -","gt":"date2.getMinutes()) +"}
{"input":"<s> /**<EOL> * Return true if the target.<EOL> * @param target<EOL> * @returns {boolean}<EOL> */<EOL>export function isCollection(target: any): boolean {<EOL>    return isArrayOrArrayClass(target)<EOL>        || target === Map<EOL>        ||","gt":"target instanceof Map"}
{"input":"<s> /**<EOL> *<EOL> * @param {string | any} obj<EOL> * @param {Function} value<EOL> */<EOL>export function extendsRequest(obj: string | any, value?: Function | any) {<EOL>    if (typeof obj === \"<STR_LIT>\") {<EOL>        Object.keys(obj).forEach((key) => {<EOL>            extendsRequest(","gt":"key, obj[key]);"}
{"input":"<s> export function View_IgCheckboxEditorComponent_0(l: any): import0.ɵViewDefinition {<EOL>    return import0.","gt":"ɵvid(<NUM_LIT>, [import0.ɵncd((null as any), <NUM_LIT>)], (null as any), (null as any));"}
{"input":"<s> /**<EOL> * Return true if the value is an empty string, null or undefined.<EOL> * @param value<EOL> * @returns {boolean}<EOL> */<EOL>export function isEmpty(value: any): boolean {<EOL>    return value === \"<STR_LIT>\" || value ===","gt":"null || value === undefined;"}
{"input":"<s> function foo7(x) {<EOL>    do {<EOL>        let x,","gt":"y;"}
{"input":"<s> /**<EOL> * Gets the last tabbable element.<EOL> *<EOL> * @public<EOL> */<EOL>export function getLastTabbable(rootElement: HTMLElement, currentElement: HTMLElement, includeElementsInFocusZones?: boolean): HTMLElement | null {<EOL>    return getPreviousElement(rootElement,","gt":"currentElement, true, false, true, includeElementsInFocusZones, false, true);"}
{"input":"<s> /**<EOL> * Determines if an, or any of its ancestors, sepcificies that it doesn't want focus to wrap<EOL> * @param element - element to start searching from<EOL> * @param noWrapDataAttribute - the no wrap data attribute to match (either)<EOL> * @returns true if focus should wrap, false otherwise<EOL> */<EOL>export function shouldWrapFocus(element: HTMLElement, noWrapDataAttribute: '<STR_LIT>' | '<STR_LIT>'): boolean {<EOL>    return elementContainsAttribute(","gt":"element, noWrapDataAttribute) === '<STR_LIT>' ? false : true;"}
{"input":"<s> /**<EOL> * Specify the behavior of the router controller.<EOL> *<EOL> * ```typescript<EOL> * @Controller(\"/\")<EOL> * @RouterSettings({mergeParams: true})<EOL> * class MyCtrl {<EOL> *<EOL> * }<EOL> * ```<EOL> *<EOL> * Property | Description | Default<EOL> * ---|---|---<EOL> * caseSensitive | Enable case sensitivity. | Disabled by default, treating “/Foo” and “/foo” as the same.<EOL> * mergeParams | Preserve the req.params values from the parent router. If the parent and the child have conflicting param names, the child’s value take precedence. | false<EOL> * strict | Enable strict routing. | Disabled by default, “/foo” and “/foo/” are treated the same by the router.<EOL> *<EOL> * @returns {(target:any)=>void}<EOL> * @decorator<EOL> * @param routerOptions<EOL> * @express<EOL> */<EOL>export function RouterSettings(routerOptions: IRouterOptions): Function {<EOL>    return (","gt":"target: any): void => {"}
{"input":"<s> function compare<T extends Comparable<T>>(x: T, y: T): number {<EOL>    if (x == null)<EOL>        return y ==","gt":"null ? <NUM_LIT> : -<NUM_LIT>;"}
{"input":"<s> /**<EOL> * Add a example metadata on the decorated element.<EOL> *<EOL> * @param {string} name<EOL> * @param {string} description<EOL> * @returns {(...args: any[]) => any}<EOL> * @decorator<EOL> * @swagger<EOL> */<EOL>export function Example(name: string | any, description?: string) {<EOL>    return (...args: any[]) => {<EOL>        let example;<EOL>        if (description) {<EOL>","gt":"example = { [name]: description };"}
{"input":"<s> /**<EOL> * Inject the list of arguments in the decorated parameter.<EOL> *<EOL> * `@Args` accept an index parameter to pick up directly the item in the arguments list.<EOL> *<EOL> * ### Example<EOL> *<EOL> * ```typescript<EOL> * @SocketService(\"/nsp\")<EOL> * export class MyWS {<EOL> *<EOL> *   @Input(\"event\")<EOL> *   myMethod(@Args() arguments: any[]) {<EOL> *<EOL> *   }<EOL> *<EOL> *   @Input(\"event2\")<EOL> *   myMethod2(@Args(0) data: any) {<EOL> *<EOL> *   }<EOL> * }<EOL> * ```<EOL> *<EOL> * @experimental<EOL> * @decorator<EOL> * @param mapIndex<EOL> */<EOL>export function Args(mapIndex?: number): any {<EOL>    return SocketFilter(SocketFilters.ARGS,","gt":"mapIndex);"}
{"input":"<s> function View_IgPivotDataSelectorComponent_Host_0(l: any): import0.ɵViewDefinition {<EOL>    return import0.ɵvid(<NUM_LIT>, [<EOL>        (l()(), import0.ɵeld(<NUM_LIT>, (null as any), (null as any), <NUM_LIT>, '<STR_LIT>', ([] as any[]), (null as any), (null as any), (null as any), View_IgPivotDataSelectorComponent_0, RenderType_IgPivotDataSelectorComponent)),<EOL>        import0.ɵdid(<NUM_LIT>, (null as any), <NUM_LIT>, import1.IgPivotDataSelectorComponent, [<EOL>            import0.","gt":"ElementRef,"}
{"input":"<s> function View_IgPivotDataSelectorComponent_Host_0(l: any): import0.ɵViewDefinition {<EOL>    return import0.ɵvid(<NUM_LIT>, [<EOL>        (l()(), import0.ɵeld(<NUM_LIT>, (null as any), (null as any), <NUM_LIT>, '<STR_LIT>', ([] as any[]), (null as any), (null as any), (null as any), View_IgPivotDataSelectorComponent_0, RenderType_IgPivotDataSelectorComponent)),<EOL>        import0.ɵdid(<NUM_LIT>, (null as any), <NUM_LIT>, import1.IgPivotDataSelectorComponent, [<EOL>            import0.ElementRef,<EOL>            import0.Renderer,<EOL>            import0.IterableDiffers<EOL>        ], (null as any), (null as any))<EOL>    ], (ck,","gt":"v) => {"}
{"input":"<s> /**<EOL> * The value of `minimum` MUST be a number, representing an inclusive upper limit for a numeric instance.<EOL> *<EOL> * If the instance is a number, then this keyword validates only if the instance is greater than or exactly equal to `minimum`.<EOL> *<EOL> * ## Example<EOL> * ### With primitive type<EOL> *<EOL> * ```typescript<EOL> * class Model {<EOL> *    @Minimum(10)<EOL> *    property: number;<EOL> * }<EOL> * ```<EOL> *<EOL> * Will produce:<EOL> *<EOL> * ```json<EOL> * {<EOL> *   \"type\": \"object\",<EOL> *   \"properties\": {<EOL> *     \"property\": {<EOL> *       \"type\": \"number\",<EOL> *       \"minimum\": 10<EOL> *     }<EOL> *   }<EOL> * }<EOL> * ```<EOL> *<EOL> * ### With array type<EOL> *<EOL> * ```typescript<EOL> * class Model {<EOL> *    @Minimum(10)<EOL> *    @PropertyType(Number)<EOL> *    property: number[];<EOL> * }<EOL> * ```<EOL> *<EOL> * Will produce:<EOL> *<EOL> * ```json<EOL> * {<EOL> *   \"type\": \"object\",<EOL> *   \"properties\": {<EOL> *     \"property\": {<EOL> *       \"type\": \"array\",<EOL> *       \"items\": {<EOL> *          \"type\": \"number\",<EOL> *          \"minimum\": 10<EOL> *       }<EOL> *     }<EOL> *   }<EOL> * }<EOL> * ```<EOL> *<EOL> * @param {number} minimum<EOL> * @param {boolean} exclusive<EOL> * @returns {Function}<EOL> * @decorator<EOL> * @ajv<EOL> * @jsonschema<EOL> * @auto-map The data will be stored on the right place according to the type and collectionType (primitive or collection).<EOL> */<EOL>export function Minimum(minimum: number, exclusive: boolean = false) {<EOL>    return decoratorSchemaFactory((schema) => {<EOL>        if (exclusive) {<EOL>            schema.mapper.exclusiveMinimum =","gt":"minimum;"}
{"input":"<s> export function View_IgUploadComponent_0(l: any): import0.ɵViewDefinition {<EOL>    return import0.ɵvid(<NUM_LIT>, [","gt":"import0.ɵncd((null as any), <NUM_LIT>)], (null as any), (null as any));"}
{"input":"<s> /**<EOL> * Mounts the specified middleware function or functions at the specified path: the middleware function is executed when<EOL> * the base of the requested path matches `path.<EOL> *<EOL> * ```typescript<EOL> * @Controller('/')<EOL> * @Use(Middleware1)<EOL> * export class Ctrl {<EOL> *<EOL> *    @Get('/')<EOL> *    @Use(Middleware2)<EOL> *    get() { }<EOL> * }<EOL> *<EOL> * ```<EOL> *<EOL> * @returns {Function}<EOL> * @param args<EOL> * @decorator<EOL> */<EOL>export function Use(...args: any[]): Function {<EOL>    return <T>(target: Type<any>, targetKey?: string, descriptor?: TypedPropertyDescriptor<T>): TypedPropertyDescriptor<T> | void => {<EOL>        if (getDecoratorType([target, targetKey, descriptor]) === \"<STR_LIT>\") {<EOL>            EndpointRegistry.use(target, targetKey!, args);<EOL>","gt":"return descriptor;"}
{"input":"<s> /**<EOL> * An object instance is valid against `maxProperties` if its number of properties is less than, or equal to, the value of this keyword.<EOL> *<EOL> * !> The value of this keyword MUST be a non-negative integer.<EOL> *<EOL> * ## Example<EOL> *<EOL> * ```typescript<EOL> * class Model {<EOL> *    @Any()<EOL> *    @MaxProperties(10)<EOL> *    property: any;<EOL> * }<EOL> * ```<EOL> *<EOL> * Will produce:<EOL> *<EOL> * ```json<EOL> * {<EOL> *   \"type\": \"object\",<EOL> *   \"properties\": {<EOL> *     \"property\": {<EOL> *       \"type\": \"any\",<EOL> *       \"maxProperties\": 10<EOL> *     }<EOL> *   }<EOL> * }<EOL> * ```<EOL> *<EOL> * @param {number} maxProperties<EOL> * @returns {Function}<EOL> * @decorator<EOL> * @ajv<EOL> * @jsonschema<EOL> */<EOL>export function MaxProperties(maxProperties: number) {<EOL>    if (maxProperties < <NUM_LIT>) {<EOL>","gt":"throw new Error(\"<STR_LIT>\");"}
{"input":"<s> export function hasChrome() {<EOL>    return typeof","gt":"chrome !== '<STR_LIT>';"}
{"input":"<s> export function assign<A extends B, B extends {}>(source: A, assignments: B): A {<EOL>","gt":"return Object.assign({}, source, assignments);"}
{"input":"<s> export function changeCoverImgUrl(arr, width = <NUM_LIT>) {<EOL>    return arr.map((item) => ({<EOL>        ...","gt":"item,"}
{"input":"<s> export async function getSetting(): Promise<Setting> {<EOL>    let setting: Setting;<EOL>    try {<EOL>        setting = await getSync();<EOL>    }<EOL>    catch (e) {<EOL>    }<EOL>    if (!setting) {<EOL>        setting = {};<EOL>    }<EOL>","gt":"if (!setting.blacklist) {"}
{"input":"<s> function IsFoo(value: any): boolean {<EOL>    return value instanceof","gt":"Bar.Foo;"}
{"input":"<s> export function* toCreatePlaylistPage() {<EOL>    while (true ) {<EOL>        const { payload } = yield take('<STR_LIT>');<EOL>        if (payload) {<EOL>            yield","gt":"put({"}
{"input":"<s> export function* toCreatePlaylistPage() {<EOL>    while (true ) {<EOL>        const { payload } = yield take('<STR_LIT>');<EOL>        if (payload) {<EOL>            yield put({<EOL>                type: '<STR_LIT>'<EOL>            });<EOL>            yield call(InteractionManager.runAfterInteractions);<EOL>        }<EOL>        yield fork(Router.toCreatePlaylist, { route: { trackId:","gt":"payload } });"}
{"input":"<s> function toFavoriteArtists(passProps?: IRouterPassProps) {<EOL>","gt":"navigator['<STR_LIT>'](passProps);"}
{"input":"<s> /**<EOL> * rewrites $id/$ref/$$ref to anchors<EOL> */<EOL>export function ConvertJsonx2Yaml(ast: YAMLNode): YAMLNode {<EOL>    ast = CloneAst(ast);<EOL>    for (const nodeWithPath of Descendants(ast)) {<EOL>        const node = nodeWithPath.node;<EOL>        if (node.kind === Kind.MAP) {<EOL>","gt":"const yamlNodeMapping = node as YAMLMap;"}
{"input":"<s> /**<EOL> * rewrites $id/$ref/$$ref to anchors<EOL> */<EOL>export function ConvertJsonx2Yaml(ast: YAMLNode): YAMLNode {<EOL>    ast = CloneAst(ast);<EOL>    for (const nodeWithPath of Descendants(ast)) {<EOL>        const node = nodeWithPath.node;<EOL>        if (node.kind === Kind.MAP) {<EOL>            const yamlNodeMapping = node as YAMLMap;<EOL>            const propId = ResolveMapProperty(yamlNodeMapping, \"<STR_LIT>\");<EOL>            let propRef = ResolveMapProperty(yamlNodeMapping,","gt":"\"<STR_LIT>\");"}
{"input":"<s> /**<EOL> * rewrites $id/$ref/$$ref to anchors<EOL> */<EOL>export function ConvertJsonx2Yaml(ast: YAMLNode): YAMLNode {<EOL>    ast = CloneAst(ast);<EOL>    for (const nodeWithPath of Descendants(ast)) {<EOL>        const node = nodeWithPath.node;<EOL>        if (node.kind === Kind.MAP) {<EOL>            const yamlNodeMapping = node as YAMLMap;<EOL>            const propId = ResolveMapProperty(yamlNodeMapping, \"<STR_LIT>\");<EOL>            let propRef = ResolveMapProperty(yamlNodeMapping, \"<STR_LIT>\");<EOL>            const propReff = ResolveMapProperty(yamlNodeMapping, \"<STR_LIT>\");<EOL>            if (propRef && isNaN(parseInt(ParseNode<any>(propRef.value) + \"<STR_LIT>\"))) {<EOL>                propRef = null;<EOL>            }<EOL>","gt":"propRef = propRef || propReff;"}
{"input":"<s> /**<EOL> * rewrites $id/$ref/$$ref to anchors<EOL> */<EOL>export function ConvertJsonx2Yaml(ast: YAMLNode): YAMLNode {<EOL>    ast = CloneAst(ast);<EOL>    for (const nodeWithPath of Descendants(ast)) {<EOL>        const node = nodeWithPath.node;<EOL>        if (node.kind === Kind.MAP) {<EOL>            const yamlNodeMapping = node as YAMLMap;<EOL>            const propId = ResolveMapProperty(yamlNodeMapping, \"<STR_LIT>\");<EOL>            let propRef = ResolveMapProperty(yamlNodeMapping, \"<STR_LIT>\");<EOL>            const propReff = ResolveMapProperty(yamlNodeMapping, \"<STR_LIT>\");<EOL>            if (propRef && isNaN(parseInt(ParseNode<any>(propRef.value) + \"<STR_LIT>\"))) {<EOL>                propRef = null;<EOL>            }<EOL>            propRef = propRef || propReff;<EOL>            if (propId) {<EOL>                yamlNodeMapping.anchorId = ParseNode<any>(propId.value) + \"<STR_LIT>\";<EOL>                ReplaceNode(ast, propId, undefined);<EOL>            }<EOL>","gt":"else if (propRef) {"}
{"input":"<s> function needLogin() {<EOL>    return","gt":"getUserId() ? null : {"}
{"input":"<s> export function syncSearchResource(type: number, reducerType: string, picSize = <NUM_LIT>) {<EOL>    return function* () {<EOL>        while (true ) {<EOL>            yield take(`<STR_LIT>`);<EOL>            const","gt":"resourceKey = reducerType + '<STR_LIT>';"}
{"input":"<s> export function syncSearchResource(type: number, reducerType: string, picSize = <NUM_LIT>) {<EOL>    return function* () {<EOL>        while (true ) {<EOL>            yield take(`<STR_LIT>`);<EOL>            const resourceKey = reducerType + '<STR_LIT>';<EOL>            const searchState =","gt":"yield select(searchSelector);"}
{"input":"<s> export function syncSearchResource(type: number, reducerType: string, picSize = <NUM_LIT>) {<EOL>    return function* () {<EOL>        while (true ) {<EOL>            yield take(`<STR_LIT>`);<EOL>            const resourceKey = reducerType + '<STR_LIT>';<EOL>            const searchState = yield select(searchSelector);<EOL>            const { query = '<STR_LIT>' } = searchState;<EOL>            const state = searchState[","gt":"reducerType];"}
{"input":"<s> export function syncSearchResource(type: number, reducerType: string, picSize = <NUM_LIT>) {<EOL>    return function* () {<EOL>        while (true ) {<EOL>            yield take(`<STR_LIT>`);<EOL>            const resourceKey = reducerType + '<STR_LIT>';<EOL>            const searchState = yield select(searchSelector);<EOL>            const { query = '<STR_LIT>' } = searchState;<EOL>            const state = searchState[reducerType];<EOL>            const counterKey = `<STR_LIT>`;<EOL>            if (state && state.more && query) {<EOL>                yield put({<EOL>                    type:","gt":"reducerType}/start`"}
{"input":"<s> export function syncSearchResource(type: number, reducerType: string, picSize = <NUM_LIT>) {<EOL>    return function* () {<EOL>        while (true ) {<EOL>            yield take(`<STR_LIT>`);<EOL>            const resourceKey = reducerType + '<STR_LIT>';<EOL>            const searchState = yield select(searchSelector);<EOL>            const { query = '<STR_LIT>' } = searchState;<EOL>            const state = searchState[reducerType];<EOL>            const counterKey = `<STR_LIT>`;<EOL>            if (state && state.more && query) {<EOL>                yield put({<EOL>                    type: `<STR_LIT>`<EOL>                });<EOL>                const offsetState = state.offset + <NUM_LIT>;<EOL>                const response = yield* ajaxCall(api.search, query, type.toString(), '<STR_LIT>', state.offset);<EOL>                if (response.code === <NUM_LIT>) {<EOL>                    const","gt":"result = response.result;"}
{"input":"<s> export function syncSearchResource(type: number, reducerType: string, picSize = <NUM_LIT>) {<EOL>    return function* () {<EOL>        while (true ) {<EOL>            yield take(`<STR_LIT>`);<EOL>            const resourceKey = reducerType + '<STR_LIT>';<EOL>            const searchState = yield select(searchSelector);<EOL>            const { query = '<STR_LIT>' } = searchState;<EOL>            const state = searchState[reducerType];<EOL>            const counterKey = `<STR_LIT>`;<EOL>            if (state && state.more && query) {<EOL>                yield put({<EOL>                    type: `<STR_LIT>`<EOL>                });<EOL>                const offsetState = state.offset + <NUM_LIT>;<EOL>                const response = yield* ajaxCall(api.search, query, type.toString(), '<STR_LIT>', state.offset);<EOL>                if (response.code === <NUM_LIT>) {<EOL>                    const result = response.result;<EOL>                    const resource: any[] = result[resourceKey];<EOL>                    if (resource) {<EOL>                        yield","gt":"put({"}
{"input":"<s> function toCamelCase(text: string): string {<EOL>    return","gt":"text[<NUM_LIT>].toLowerCase() + text.substring(<NUM_LIT>);"}
{"input":"<s> function printError(error: ts.Diagnostic): void {<EOL>    if (!error) {<EOL>","gt":"return;"}
{"input":"<s> <EOL>export function IsUri(uri: string): boolean {<EOL>","gt":"return /^([a-z0-9+.-]+):(?:\\/\\/(?:((?:[a-z0-9-._~!$&'()*+,;=:]|%[0-9A-F]{2})*)@)?((?:[a-z0-9-._~!$&'()*+,;=]|%[0-9A-F]{2})*)(?::(\\d*))?(\\/(?:[a-z0-9-._~!$&'()*+,;=:@/]|%[0-9A-F]{2})*)?|(\\/?(?:[a-z0-9-._~!$&'()*+,;=:@]|%[0-9A-F]{2})+(?:[a-z0-9-._~!$&'()*+,;=:@/]|%[0-9A-F]{2})*)?)(?:\\?((?:[a-z0-9-._~!$&'()*+,;=:/?@]|%[0-9A-F]{2})*))?(?:#((?:[a-z0-9-._~!$&'()*+,;=:/?@]|%[0-9A-F]{2})*))?$/i.test(uri);"}
{"input":"<s> function foo(a: number) {<EOL>    if (a === <NUM_LIT>) {<EOL>        function foo() { }<EOL>        foo();<EOL>        foo(","gt":"<NUM_LIT>);"}
{"input":"<s> function f5_private() {<EOL>","gt":"return new C6_public();"}
{"input":"<s> function f9_private(): C6_public {<EOL>    return new","gt":"C6_public();"}
{"input":"<s> async function StripExternalReferences(swagger: DataHandle, sink: DataSink): Promise<DataHandle> {<EOL>    const ast = CloneAst(swagger.ReadYamlAst());<EOL>    const mapping = IdentitySourceMapping(swagger.key, ast);<EOL>    for (const node of Descendants(ast)) {<EOL>","gt":"if (isReferenceNode(node)) {"}
{"input":"<s> export async function LoadLiterateSwaggerOverride(config: ConfigurationView, inputScope: DataSource, inputFileUri: string, sink: DataSink): Promise<DataHandle> {<EOL>    const commonmark = await inputScope.ReadStrict(inputFileUri);<EOL>    const rawCommonmark = commonmark.ReadData();<EOL>    const commonmarkNode = await ParseCommonmark(rawCommonmark);<EOL>    const directives: any[] = [];<EOL>    const","gt":"mappings: Mappings = [];"}
{"input":"<s> export async function LoadLiterateSwaggerOverride(config: ConfigurationView, inputScope: DataSource, inputFileUri: string, sink: DataSink): Promise<DataHandle> {<EOL>    const commonmark = await inputScope.ReadStrict(inputFileUri);<EOL>    const rawCommonmark = commonmark.ReadData();<EOL>    const commonmarkNode = await ParseCommonmark(rawCommonmark);<EOL>    const directives: any[] = [];<EOL>    const mappings: Mappings = [];<EOL>    let transformer: string[] = [];<EOL>    const state = [...CommonmarkSubHeadings(commonmarkNode.firstChild)].map(x => { return { node: x, query: \"<STR_LIT>\" }; });<EOL>","gt":"while (state.length > <NUM_LIT>) {"}
{"input":"<s> export async function LoadLiterateSwaggerOverride(config: ConfigurationView, inputScope: DataSource, inputFileUri: string, sink: DataSink): Promise<DataHandle> {<EOL>    const commonmark = await inputScope.ReadStrict(inputFileUri);<EOL>    const rawCommonmark = commonmark.ReadData();<EOL>    const commonmarkNode = await ParseCommonmark(rawCommonmark);<EOL>    const directives: any[] = [];<EOL>    const mappings: Mappings = [];<EOL>    let transformer: string[] = [];<EOL>    const state = [...CommonmarkSubHeadings(commonmarkNode.firstChild)].map(x => { return { node: x, query: \"<STR_LIT>\" }; });<EOL>    while (state.length > <NUM_LIT>) {<EOL>        const x = state.pop();<EOL>        if (x === undefined)<EOL>","gt":"throw \"<STR_LIT>\";"}
{"input":"<s> export async function LoadLiterateSwaggerOverride(config: ConfigurationView, inputScope: DataSource, inputFileUri: string, sink: DataSink): Promise<DataHandle> {<EOL>    const commonmark = await inputScope.ReadStrict(inputFileUri);<EOL>    const rawCommonmark = commonmark.ReadData();<EOL>    const commonmarkNode = await ParseCommonmark(rawCommonmark);<EOL>    const directives: any[] = [];<EOL>    const mappings: Mappings = [];<EOL>    let transformer: string[] = [];<EOL>    const state = [...CommonmarkSubHeadings(commonmarkNode.firstChild)].map(x => { return { node: x, query: \"<STR_LIT>\" }; });<EOL>    while (state.length > <NUM_LIT>) {<EOL>        const x = state.pop();<EOL>        if (x === undefined)<EOL>            throw \"<STR_LIT>\";<EOL>        <EOL>        <EOL>        <EOL>        <EOL>        <EOL>        let clue: string | null = null;<EOL>        let","gt":"node = x.node."}
{"input":"<s> export async function LoadLiterateSwaggerOverride(config: ConfigurationView, inputScope: DataSource, inputFileUri: string, sink: DataSink): Promise<DataHandle> {<EOL>    const commonmark = await inputScope.ReadStrict(inputFileUri);<EOL>    const rawCommonmark = commonmark.ReadData();<EOL>    const commonmarkNode = await ParseCommonmark(rawCommonmark);<EOL>    const directives: any[] = [];<EOL>    const mappings: Mappings = [];<EOL>    let transformer: string[] = [];<EOL>    const state = [...CommonmarkSubHeadings(commonmarkNode.firstChild)].map(x => { return { node: x, query: \"<STR_LIT>\" }; });<EOL>    while (state.length > <NUM_LIT>) {<EOL>        const x = state.pop();<EOL>        if (x === undefined)<EOL>            throw \"<STR_LIT>\";<EOL>        <EOL>        <EOL>        <EOL>        <EOL>        <EOL>        let clue: string | null = null;<EOL>        let node = x.node.","gt":"firstChild;"}
{"input":"<s> export async function LoadLiterateSwaggerOverride(config: ConfigurationView, inputScope: DataSource, inputFileUri: string, sink: DataSink): Promise<DataHandle> {<EOL>    const commonmark = await inputScope.ReadStrict(inputFileUri);<EOL>    const rawCommonmark = commonmark.ReadData();<EOL>    const commonmarkNode = await ParseCommonmark(rawCommonmark);<EOL>    const directives: any[] = [];<EOL>    const mappings: Mappings = [];<EOL>    let transformer: string[] = [];<EOL>    const state = [...CommonmarkSubHeadings(commonmarkNode.firstChild)].map(x => { return { node: x, query: \"<STR_LIT>\" }; });<EOL>    while (state.length > <NUM_LIT>) {<EOL>        const x = state.pop();<EOL>        if (x === undefined)<EOL>            throw \"<STR_LIT>\";<EOL>        <EOL>        <EOL>        <EOL>        <EOL>        <EOL>        let clue: string | null = null;<EOL>        let node = x.node.firstChild;<EOL>        while (node) {<EOL>            if ((node.literal || \"<STR_LIT>\").endsWith(\"<STR_LIT>\")<EOL>                && (((node.next || <any>{}).next || {}).literal || \"<STR_LIT>\").startsWith(\"<STR_LIT>\")<EOL>                && node.next<EOL>                && node.next.type === \"<STR_LIT>\") {<EOL>                clue = node.next.","gt":"literal;"}
{"input":"<s> export async function LoadLiterateSwaggerOverride(config: ConfigurationView, inputScope: DataSource, inputFileUri: string, sink: DataSink): Promise<DataHandle> {<EOL>    const commonmark = await inputScope.ReadStrict(inputFileUri);<EOL>    const rawCommonmark = commonmark.ReadData();<EOL>    const commonmarkNode = await ParseCommonmark(rawCommonmark);<EOL>    const directives: any[] = [];<EOL>    const mappings: Mappings = [];<EOL>    let transformer: string[] = [];<EOL>    const state = [...CommonmarkSubHeadings(commonmarkNode.firstChild)].map(x => { return { node: x, query: \"<STR_LIT>\" }; });<EOL>    while (state.length > <NUM_LIT>) {<EOL>        const x = state.pop();<EOL>        if (x === undefined)<EOL>            throw \"<STR_LIT>\";<EOL>        <EOL>        <EOL>        <EOL>        <EOL>        <EOL>        let clue: string | null = null;<EOL>        let node = x.node.firstChild;<EOL>        while (node) {<EOL>            if ((node.literal || \"<STR_LIT>\").endsWith(\"<STR_LIT>\")<EOL>                && (((node.next || <any>{}).next || {}).literal || \"<STR_LIT>\").startsWith(\"<STR_LIT>\")<EOL>                && node.next<EOL>                && node.next.type === \"<STR_LIT>\") {<EOL>                clue = node.next.literal;<EOL>                break;<EOL>            }<EOL>            node = node.next;<EOL>        }<EOL>        <EOL>        if (clue) {<EOL>            <EOL>            if (!clue.startsWith(\"<STR_LIT>\") && !clue.","gt":"startsWith(\"<STR_LIT>\")) {"}
{"input":"<s> export async function LoadLiterateSwaggerOverride(config: ConfigurationView, inputScope: DataSource, inputFileUri: string, sink: DataSink): Promise<DataHandle> {<EOL>    const commonmark = await inputScope.ReadStrict(inputFileUri);<EOL>    const rawCommonmark = commonmark.ReadData();<EOL>    const commonmarkNode = await ParseCommonmark(rawCommonmark);<EOL>    const directives: any[] = [];<EOL>    const mappings: Mappings = [];<EOL>    let transformer: string[] = [];<EOL>    const state = [...CommonmarkSubHeadings(commonmarkNode.firstChild)].map(x => { return { node: x, query: \"<STR_LIT>\" }; });<EOL>    while (state.length > <NUM_LIT>) {<EOL>        const x = state.pop();<EOL>        if (x === undefined)<EOL>            throw \"<STR_LIT>\";<EOL>        <EOL>        <EOL>        <EOL>        <EOL>        <EOL>        let clue: string | null = null;<EOL>        let node = x.node.firstChild;<EOL>        while (node) {<EOL>            if ((node.literal || \"<STR_LIT>\").endsWith(\"<STR_LIT>\")<EOL>                && (((node.next || <any>{}).next || {}).literal || \"<STR_LIT>\").startsWith(\"<STR_LIT>\")<EOL>                && node.next<EOL>                && node.next.type === \"<STR_LIT>\") {<EOL>                clue = node.next.literal;<EOL>                break;<EOL>            }<EOL>            node = node.next;<EOL>        }<EOL>        <EOL>        if (clue) {<EOL>            <EOL>            if (!clue.startsWith(\"<STR_LIT>\") && !clue.startsWith(\"<STR_LIT>\")) {<EOL>                clue = \"<STR_LIT>\" + clue;<EOL>            }<EOL>            <EOL>            if (clue.startsWith(\"<STR_LIT>\")) {<EOL>                clue = x.query + clue.slice(<NUM_LIT>);<EOL>            }<EOL>            <EOL>            const candidProperties = [\"<STR_LIT>\", \"<STR_LIT>\", \"<STR_LIT>\"];<EOL>            clue = clue.replace(/\\.\\#(.+?)\\b/g, (_, match) => `<STR_LIT>`);<EOL>            <EOL>            <EOL>            const allowedTargetFields = [\"<STR_LIT>\", \"<STR_LIT>\"];<EOL>            const","gt":"targetField = allowedTargetFields.filter(f => (clue || \"<STR_LIT>\").endsWith(\"<STR_LIT>\" + f))[<NUM_LIT>] || \"<STR_LIT>\";"}
{"input":"<s> export async function LoadLiterateSwaggerOverride(config: ConfigurationView, inputScope: DataSource, inputFileUri: string, sink: DataSink): Promise<DataHandle> {<EOL>    const commonmark = await inputScope.ReadStrict(inputFileUri);<EOL>    const rawCommonmark = commonmark.ReadData();<EOL>    const commonmarkNode = await ParseCommonmark(rawCommonmark);<EOL>    const directives: any[] = [];<EOL>    const mappings: Mappings = [];<EOL>    let transformer: string[] = [];<EOL>    const state = [...CommonmarkSubHeadings(commonmarkNode.firstChild)].map(x => { return { node: x, query: \"<STR_LIT>\" }; });<EOL>    while (state.length > <NUM_LIT>) {<EOL>        const x = state.pop();<EOL>        if (x === undefined)<EOL>            throw \"<STR_LIT>\";<EOL>        <EOL>        <EOL>        <EOL>        <EOL>        <EOL>        let clue: string | null = null;<EOL>        let node = x.node.firstChild;<EOL>        while (node) {<EOL>            if ((node.literal || \"<STR_LIT>\").endsWith(\"<STR_LIT>\")<EOL>                && (((node.next || <any>{}).next || {}).literal || \"<STR_LIT>\").startsWith(\"<STR_LIT>\")<EOL>                && node.next<EOL>                && node.next.type === \"<STR_LIT>\") {<EOL>                clue = node.next.literal;<EOL>                break;<EOL>            }<EOL>            node = node.next;<EOL>        }<EOL>        <EOL>        if (clue) {<EOL>            <EOL>            if (!clue.startsWith(\"<STR_LIT>\") && !clue.startsWith(\"<STR_LIT>\")) {<EOL>                clue = \"<STR_LIT>\" + clue;<EOL>            }<EOL>            <EOL>            if (clue.startsWith(\"<STR_LIT>\")) {<EOL>                clue = x.query + clue.slice(<NUM_LIT>);<EOL>            }<EOL>            <EOL>            const candidProperties = [\"<STR_LIT>\", \"<STR_LIT>\", \"<STR_LIT>\"];<EOL>            clue = clue.replace(/\\.\\#(.+?)\\b/g, (_, match) => `<STR_LIT>`);<EOL>            <EOL>            <EOL>            const allowedTargetFields = [\"<STR_LIT>\", \"<STR_LIT>\"];<EOL>            const targetField = allowedTargetFields.filter(f => (clue || \"<STR_LIT>\").endsWith(\"<STR_LIT>\" + f))[<NUM_LIT>] || \"<STR_LIT>\";<EOL>            const targetPath = clue.endsWith(\"<STR_LIT>\" + targetField) ? clue.slice(<NUM_LIT>, clue.length - targetField.length - <NUM_LIT>) : clue;<EOL>            if (targetPath !== \"<STR_LIT>\" && targetPath !== \"<STR_LIT>\") {<EOL>                <EOL>                const headingTextRange = CommonmarkHeadingFollowingText(","gt":"x.node);"}
{"input":"<s> export async function LoadLiterateSwaggerOverride(config: ConfigurationView, inputScope: DataSource, inputFileUri: string, sink: DataSink): Promise<DataHandle> {<EOL>    const commonmark = await inputScope.ReadStrict(inputFileUri);<EOL>    const rawCommonmark = commonmark.ReadData();<EOL>    const commonmarkNode = await ParseCommonmark(rawCommonmark);<EOL>    const directives: any[] = [];<EOL>    const mappings: Mappings = [];<EOL>    let transformer: string[] = [];<EOL>    const state = [...CommonmarkSubHeadings(commonmarkNode.firstChild)].map(x => { return { node: x, query: \"<STR_LIT>\" }; });<EOL>    while (state.length > <NUM_LIT>) {<EOL>        const x = state.pop();<EOL>        if (x === undefined)<EOL>            throw \"<STR_LIT>\";<EOL>        <EOL>        <EOL>        <EOL>        <EOL>        <EOL>        let clue: string | null = null;<EOL>        let node = x.node.firstChild;<EOL>        while (node) {<EOL>            if ((node.literal || \"<STR_LIT>\").endsWith(\"<STR_LIT>\")<EOL>                && (((node.next || <any>{}).next || {}).literal || \"<STR_LIT>\").startsWith(\"<STR_LIT>\")<EOL>                && node.next<EOL>                && node.next.type === \"<STR_LIT>\") {<EOL>                clue = node.next.literal;<EOL>                break;<EOL>            }<EOL>            node = node.next;<EOL>        }<EOL>        <EOL>        if (clue) {<EOL>            <EOL>            if (!clue.startsWith(\"<STR_LIT>\") && !clue.startsWith(\"<STR_LIT>\")) {<EOL>                clue = \"<STR_LIT>\" + clue;<EOL>            }<EOL>            <EOL>            if (clue.startsWith(\"<STR_LIT>\")) {<EOL>                clue = x.query + clue.slice(<NUM_LIT>);<EOL>            }<EOL>            <EOL>            const candidProperties = [\"<STR_LIT>\", \"<STR_LIT>\", \"<STR_LIT>\"];<EOL>            clue = clue.replace(/\\.\\#(.+?)\\b/g, (_, match) => `<STR_LIT>`);<EOL>            <EOL>            <EOL>            const allowedTargetFields = [\"<STR_LIT>\", \"<STR_LIT>\"];<EOL>            const targetField = allowedTargetFields.filter(f => (clue || \"<STR_LIT>\").endsWith(\"<STR_LIT>\" + f))[<NUM_LIT>] || \"<STR_LIT>\";<EOL>            const targetPath = clue.endsWith(\"<STR_LIT>\" + targetField) ? clue.slice(<NUM_LIT>, clue.length - targetField.length - <NUM_LIT>) : clue;<EOL>            if (targetPath !== \"<STR_LIT>\" && targetPath !== \"<STR_LIT>\") {<EOL>                <EOL>                const headingTextRange = CommonmarkHeadingFollowingText(x.node);<EOL>                const documentation = Lines(rawCommonmark).slice(headingTextRange[<NUM_LIT>] - <NUM_LIT>, headingTextRange[<NUM_LIT>]).join(\"<STR_LIT>\");<EOL>                directives.push({<EOL>                    where:","gt":"targetPath,"}
{"input":"<s> export async function LoadLiterateSwaggerOverrides(config: ConfigurationView, inputScope: DataSource, inputFileUris: string[], sink: DataSink): Promise<DataHandle[]> {<EOL>    const rawSwaggers: DataHandle[] = [];<EOL>    let i = <NUM_LIT>;<EOL>    for (","gt":"const inputFileUri of inputFileUris) {"}
{"input":"<s> export function foo() {<EOL>    use(","gt":"TopLevelConstEnum.X);"}
{"input":"<s> export function not(cond: boolean, message?: string): void {<EOL>    return fns.ok(!cond,","gt":"message);"}
{"input":"<s> export function not(cond: boolean, message?: string): void {<EOL>    return fns.","gt":"ok(!cond, message);"}
{"input":"<s> export function applyCheck<F, A, B, C>(genFA: jv.Arbitrary<HK<F, A>>, genAtoB: jv.Arbitrary<(a: A) => B>, genBtoC: jv.Arbitrary<(b: B) => C>, genFAtoB: jv.Arbitrary<HK<F, (a: A) => B>>, genFBtoC: jv.Arbitrary<HK<F, (b: B) => C>>, check: <T>(e: Equiv<HK<F, T>>) => boolean, F: Apply<F>, lawsRef?: ApplyLaws<F>, includeSuperTypes: boolean = true) {<EOL>    const laws = lawsRef || new ApplyLaws<F>(F);<EOL>    if (","gt":"includeSuperTypes) {"}
{"input":"<s> /** @Hidden */<EOL>function futureCancelAll<A>(list: Future<A>[], ec: Scheduler, skip: number = -<NUM_LIT>): void {<EOL>    const errors = [];<EOL>    for (let i = <NUM_LIT>; i < list.length; i++) {<EOL>        if (i !== skip)<EOL>            try {<EOL>                list[i].","gt":"cancel();"}
{"input":"<s> /** @Hidden */<EOL>function futureCancelAll<A>(list: Future<A>[], ec: Scheduler, skip: number = -<NUM_LIT>): void {<EOL>    const errors = [];<EOL>    for (let i = <NUM_LIT>; i < list.length; i++) {<EOL>        if (i !== skip)<EOL>            try {<EOL>                list[i].cancel();<EOL>            }<EOL>            catch (e) {<EOL>                errors.push(e);<EOL>            }<EOL>    }<EOL>","gt":"if (errors.length > <NUM_LIT>) {"}
{"input":"<s> function config($stateProvider) {<EOL>    '<STR_LIT>';<EOL>","gt":"$stateProvider"}
{"input":"<s> function func6({ a: { b, c } = { b: <NUM_LIT>, c: <NUM_LIT> }, d }: {<EOL>    a: {<EOL>        b: number;<EOL>        c?: number;<EOL>    };<EOL>    d: number;<EOL>} = { a: { b: <NUM_LIT>, c: <NUM_LIT> }, d: <NUM_LIT> }) {<EOL>    f(b,","gt":"c);"}
{"input":"<s> async function whileStatement15() {<EOL>","gt":"E: while (x) {"}
{"input":"<s> function convertDVD(dvdPath) {<EOL>    dvdPath = dvdPath.split(path.sep);<EOL>    <EOL>    var part = dvdPath.pop();<EOL>    if (part !==","gt":"'<STR_LIT>') {"}
{"input":"<s> function convertDVD(dvdPath) {<EOL>    dvdPath = dvdPath.split(path.sep);<EOL>    <EOL>    var part = dvdPath.pop();<EOL>    if (part !== '<STR_LIT>') {<EOL>        dvdPath.","gt":"push(part);"}
{"input":"<s> function convertDVD(dvdPath) {<EOL>    dvdPath = dvdPath.split(path.sep);<EOL>    <EOL>    var part = dvdPath.pop();<EOL>    if (part !== '<STR_LIT>') {<EOL>        dvdPath.push(part);<EOL>    }<EOL>    dvdPath = dvdPath.join(path.","gt":"sep);"}
{"input":"<s> function convertDVD(dvdPath) {<EOL>    dvdPath = dvdPath.split(path.sep);<EOL>    <EOL>    var part = dvdPath.pop();<EOL>    if (part !== '<STR_LIT>') {<EOL>        dvdPath.push(part);<EOL>    }<EOL>    dvdPath = dvdPath.join(path.sep);<EOL>    <EOL>    createDir(dvdPath, function () {<EOL>        <EOL>        convertIfo(dvdPath, function () {<EOL>            <EOL>            generateChapters(dvdPath, function () {<EOL>                <EOL>                extractNavPackets(dvdPath, function () {<EOL>                    <EOL>                    generateJavaScript(dvdPath, function () {<EOL>                        <EOL>                        extractMenu(dvdPath, function () {<EOL>                            <EOL>                            generateMenuCellTable(","gt":"dvdPath, function () {"}
{"input":"<s> function convertDVD(dvdPath) {<EOL>    dvdPath = dvdPath.split(path.sep);<EOL>    <EOL>    var part = dvdPath.pop();<EOL>    if (part !== '<STR_LIT>') {<EOL>        dvdPath.push(part);<EOL>    }<EOL>    dvdPath = dvdPath.join(path.sep);<EOL>    <EOL>    createDir(dvdPath, function () {<EOL>        <EOL>        convertIfo(dvdPath, function () {<EOL>            <EOL>            generateChapters(dvdPath, function () {<EOL>                <EOL>                extractNavPackets(dvdPath, function () {<EOL>                    <EOL>                    generateJavaScript(dvdPath, function () {<EOL>                        <EOL>                        extractMenu(dvdPath, function () {<EOL>                            <EOL>                            generateMenuCellTable(dvdPath, function () {<EOL>                                <EOL>                                generateButtons(dvdPath, function () {<EOL>                                    <EOL>                                    encodeVideo(dvdPath, function () {<EOL>                                        <EOL>                                        generateCatalogue(function () {<EOL>                                            console.log(","gt":"'<STR_LIT>');"}
{"input":"<s> /**<EOL> * Display a sprintf formatted string.<EOL> *<EOL> * @param {string} str<EOL> * @param {*=} arg1<EOL> * @param {*=} arg2<EOL> * @param {*=} arg3<EOL> * @param {*=} arg4<EOL> * @param {*=} arg5<EOL> * @param {*=} arg6<EOL> * @param {*=} arg7<EOL> * @param {*=} arg8<EOL> * @param {*=} arg9<EOL> * @param {*=} arg10<EOL> * @param {*=} arg11<EOL> * @param {*=} arg12<EOL> */<EOL>export function printf(str: string, arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: number, arg6?: any, arg7?: any, arg8?: any, arg9?: any, arg10?: number, arg11?: any, arg12?: number) {<EOL>    console.log(sprintf.apply(undefined,","gt":"arguments));"}
{"input":"<s> <EOL><EOL>async function f<T>(source: Iterable<T> | AsyncIterable<T>) {<EOL>    for await (const x","gt":"of source) {"}
{"input":"<s> /**<EOL> * Quick title formatting function.<EOL> *<EOL> * @param {string} title<EOL> * @return {string} A formatted title.<EOL> */<EOL>export function formatTitle(title: string): string {<EOL>    return title<EOL>        .replace(/_/g, '<STR_LIT>')<EOL>        .split(","gt":"'<STR_LIT>')"}
{"input":"<s> /**<EOL> * @param {Array.<number>} arg<EOL> */<EOL>export function CHECK_ZERO(arg) {<EOL>    if (!DEBUG)<EOL>","gt":"return;"}
{"input":"<s> /**<EOL> * Creates a new Uint8Array based on an array of ArrayBuffer.<EOL> *<EOL> * @param {Array.<ArrayBuffer>} buffers An array of ArrayBuffer.<EOL> * @return {ArrayBuffer} The new ArrayBuffer created out of the two.<EOL> */<EOL>export function concatBuffer(buffers) {<EOL>    var byteLength = buffers<EOL>        .map(function (buffer) {<EOL>        return buffer.byteLength;<EOL>    })<EOL>        .","gt":"reduce(function (bufferA, bufferB) {"}
{"input":"<s> /**<EOL> * Creates a new Uint8Array based on an array of ArrayBuffer.<EOL> *<EOL> * @param {Array.<ArrayBuffer>} buffers An array of ArrayBuffer.<EOL> * @return {ArrayBuffer} The new ArrayBuffer created out of the two.<EOL> */<EOL>export function concatBuffer(buffers) {<EOL>    var byteLength = buffers<EOL>        .map(function (buffer) {<EOL>        return buffer.byteLength;<EOL>    })<EOL>        .reduce(function (bufferA, bufferB) {<EOL>        return bufferA + bufferB;<EOL>    }, <NUM_LIT>);<EOL>    var tmp = new Uint8Array(byteLength);<EOL>    var prevByteLength = <NUM_LIT>;<EOL>    buffers.forEach(function (buffer) {<EOL>        tmp.set(new","gt":"Uint8Array(buffer), prevByteLength);"}
{"input":"<s> /**<EOL> * Reads in the VTS Time Map Table, this data is only located in the video<EOL> * title set information file. This fills the ifofile.vts_tmapt structure<EOL> * and all its substructures. When pressent enables VOBU level time-based<EOL> * seeking for One_Sequential_PGC_Titles.<EOL> *<EOL> * @param {ifo_handle_t} ifofile (passed as reference).<EOL> * @return {?ifo_handle_t}<EOL> */<EOL>function ifoRead_VTS_TMAPT(ifofile) {<EOL>    if (!ifofile || !ifofile.vtsi_mat)<EOL>        return null;<EOL>","gt":"if (ifofile.vtsi_mat.vts_tmapt === <NUM_LIT>) {"}
{"input":"<s> /**<EOL> * Reads in the VTS Time Map Table, this data is only located in the video<EOL> * title set information file. This fills the ifofile.vts_tmapt structure<EOL> * and all its substructures. When pressent enables VOBU level time-based<EOL> * seeking for One_Sequential_PGC_Titles.<EOL> *<EOL> * @param {ifo_handle_t} ifofile (passed as reference).<EOL> * @return {?ifo_handle_t}<EOL> */<EOL>function ifoRead_VTS_TMAPT(ifofile) {<EOL>    if (!ifofile || !ifofile.vtsi_mat)<EOL>        return null;<EOL>    if (ifofile.vtsi_mat.vts_tmapt === <NUM_LIT>) { <EOL>        console.error('<STR_LIT>');<EOL>        ifofile.vts_tmapt = null;<EOL>","gt":"return ifofile;"}
{"input":"<s> /**<EOL> * Reads in the VTS Time Map Table, this data is only located in the video<EOL> * title set information file. This fills the ifofile.vts_tmapt structure<EOL> * and all its substructures. When pressent enables VOBU level time-based<EOL> * seeking for One_Sequential_PGC_Titles.<EOL> *<EOL> * @param {ifo_handle_t} ifofile (passed as reference).<EOL> * @return {?ifo_handle_t}<EOL> */<EOL>function ifoRead_VTS_TMAPT(ifofile) {<EOL>    if (!ifofile || !ifofile.vtsi_mat)<EOL>        return null;<EOL>    if (ifofile.vtsi_mat.vts_tmapt === <NUM_LIT>) { <EOL>        console.error('<STR_LIT>');<EOL>        ifofile.vts_tmapt = null;<EOL>        return ifofile;<EOL>    }<EOL>    ifofile.file.view.seek(ifofile.vtsi_mat.vts_tmapt * DVD_BLOCK_LEN);<EOL>    <EOL>","gt":"var i, j;"}
{"input":"<s> /**<EOL> * Reads in the VTS Time Map Table, this data is only located in the video<EOL> * title set information file. This fills the ifofile.vts_tmapt structure<EOL> * and all its substructures. When pressent enables VOBU level time-based<EOL> * seeking for One_Sequential_PGC_Titles.<EOL> *<EOL> * @param {ifo_handle_t} ifofile (passed as reference).<EOL> * @return {?ifo_handle_t}<EOL> */<EOL>function ifoRead_VTS_TMAPT(ifofile) {<EOL>    if (!ifofile || !ifofile.vtsi_mat)<EOL>        return null;<EOL>    if (ifofile.vtsi_mat.vts_tmapt === <NUM_LIT>) { <EOL>        console.error('<STR_LIT>');<EOL>        ifofile.vts_tmapt = null;<EOL>        return ifofile;<EOL>    }<EOL>    ifofile.file.view.seek(ifofile.vtsi_mat.vts_tmapt * DVD_BLOCK_LEN);<EOL>    <EOL>    var i, j;<EOL>    var vts_tmapt = new BinaryParser(ifofile.file.view, ifoTypes.vts_tmapt_t()).parse('<STR_LIT>');<EOL>    <EOL>","gt":"CHECK_ZERO(vts_tmapt.zero_1);"}
{"input":"<s> /**<EOL> * Reads in the VTS Time Map Table, this data is only located in the video<EOL> * title set information file. This fills the ifofile.vts_tmapt structure<EOL> * and all its substructures. When pressent enables VOBU level time-based<EOL> * seeking for One_Sequential_PGC_Titles.<EOL> *<EOL> * @param {ifo_handle_t} ifofile (passed as reference).<EOL> * @return {?ifo_handle_t}<EOL> */<EOL>function ifoRead_VTS_TMAPT(ifofile) {<EOL>    if (!ifofile || !ifofile.vtsi_mat)<EOL>        return null;<EOL>    if (ifofile.vtsi_mat.vts_tmapt === <NUM_LIT>) { <EOL>        console.error('<STR_LIT>');<EOL>        ifofile.vts_tmapt = null;<EOL>        return ifofile;<EOL>    }<EOL>    ifofile.file.view.seek(ifofile.vtsi_mat.vts_tmapt * DVD_BLOCK_LEN);<EOL>    <EOL>    var i, j;<EOL>    var vts_tmapt = new BinaryParser(ifofile.file.view, ifoTypes.vts_tmapt_t()).parse('<STR_LIT>');<EOL>    <EOL>    CHECK_ZERO(vts_tmapt.zero_1);<EOL>    vts_tmapt.tmap = ifoTypes.vts_tmap_t();<EOL>    if (!vts_tmapt.tmap) {<EOL>        ifofile.vts_tmapt =","gt":"null;"}
{"input":"<s> /**<EOL> * Reads in the VTS Time Map Table, this data is only located in the video<EOL> * title set information file. This fills the ifofile.vts_tmapt structure<EOL> * and all its substructures. When pressent enables VOBU level time-based<EOL> * seeking for One_Sequential_PGC_Titles.<EOL> *<EOL> * @param {ifo_handle_t} ifofile (passed as reference).<EOL> * @return {?ifo_handle_t}<EOL> */<EOL>function ifoRead_VTS_TMAPT(ifofile) {<EOL>    if (!ifofile || !ifofile.vtsi_mat)<EOL>        return null;<EOL>    if (ifofile.vtsi_mat.vts_tmapt === <NUM_LIT>) { <EOL>        console.error('<STR_LIT>');<EOL>        ifofile.vts_tmapt = null;<EOL>        return ifofile;<EOL>    }<EOL>    ifofile.file.view.seek(ifofile.vtsi_mat.vts_tmapt * DVD_BLOCK_LEN);<EOL>    <EOL>    var i, j;<EOL>    var vts_tmapt = new BinaryParser(ifofile.file.view, ifoTypes.vts_tmapt_t()).parse('<STR_LIT>');<EOL>    <EOL>    CHECK_ZERO(vts_tmapt.zero_1);<EOL>    vts_tmapt.tmap = ifoTypes.vts_tmap_t();<EOL>    if (!vts_tmapt.tmap) {<EOL>        ifofile.vts_tmapt = null;<EOL>        return null;<EOL>    }<EOL>    for (i = <NUM_LIT>; i < vts_tmapt.nr_of_tmaps; i++) {<EOL>        ifofile.file.view.seek(ifofile.vtsi_mat.vts_tmapt * DVD_BLOCK_LEN +<EOL>            vts_tmapt.tmap_offset[i]);<EOL>        <EOL>        vts_tmapt.tmap[i] = new BinaryParser(ifofile.file.view, ifoTypes.vts_tmap_t()).parse(","gt":"'<STR_LIT>');"}
{"input":"<s> function dvdnav_vobu_t() {<EOL>    this.vobu_start = <NUM_LIT>; <EOL>    this.vobu_length = <NUM_LIT>;<EOL>    this.","gt":"blockN = <NUM_LIT>;"}
{"input":"<s> /**<EOL> * Reads in the program chain information table for the video title set. Fills<EOL> * in the ifofile.vts_pgcit structure and its substructures, which includes<EOL> * the data for each program chain in the set. This data is only located in<EOL> * the video title set information file. This structure is mandatory, and must<EOL> * be included in the VTSI file.<EOL> *<EOL> * @param {ifo_handle_t} ifofile (passed as reference).<EOL> * @return {?ifo_handle_t}<EOL> */<EOL>export function ifoRead_PGCIT(ifofile) {<EOL>    if (!ifofile || !ifofile.vtsi_mat)<EOL>","gt":"return null;"}
{"input":"<s> async function hoistingWithAwait() {<EOL>    var a0, a1 = <NUM_LIT>;<EOL>    function z() {<EOL>        var b0, b1 = <NUM_LIT>;<EOL>    }<EOL>","gt":"await <NUM_LIT>;"}
{"input":"<s> async function hoistingWithAwait() {<EOL>    var a0, a1 = <NUM_LIT>;<EOL>    function z() {<EOL>        var b0, b1 = <NUM_LIT>;<EOL>    }<EOL>    await <NUM_LIT>;<EOL>    if (true) {<EOL>        var c0, c1 = <NUM_LIT>;<EOL>    }<EOL>    for (var a = <NUM_LIT>; y;) {<EOL>    }<EOL>","gt":"for (var b in y) {"}
{"input":"<s> <EOL>export function dvdnav_cell_change_event_t() {<EOL>    this.cellN = <NUM_LIT>; <EOL>    this.pgN = <NUM_LIT>; <EOL>","gt":"this.cell_length = <NUM_LIT>;"}
{"input":"<s> function foo(so: any) {<EOL>","gt":"const val = so as FooBar;"}
{"input":"<s> /**<EOL> * Seamless Angle Information for one angle<EOL> */<EOL>function sml_agl_data_t() {<EOL>    return {<EOL>        address:","gt":"'<STR_LIT>',"}
{"input":"<s> /**<EOL> * VOBU Search Information<EOL> */<EOL>function vobu_sri_t() {<EOL>    return {<EOL>        next_video: '<STR_LIT>',<EOL>        fwda: ['<STR_LIT>',","gt":"'<STR_LIT>', <NUM_LIT>],"}
{"input":"<s> /**<EOL> * Common<EOL> *<EOL> * The following structures are used in both the VMGI and VTSI.<EOL> */<EOL>/**<EOL> * DVD Time Information.<EOL> * Exported for dvdread/nav_types.ts.<EOL> */<EOL>export function dvd_time_t() {<EOL>    return {<EOL>","gt":"hour: '<STR_LIT>',"}
{"input":"<s> /**<EOL> * Parental Management Information Table.<EOL> */<EOL>export function ptl_mait_t() {<EOL>    return {<EOL>        '<STR_LIT>': ptl_mait_country_t(),<EOL>        <EOL>","gt":"'<STR_LIT>': {"}
{"input":"<s> function expectSubscriptions() {<EOL>    if (!global.rxTestScheduler) {<EOL>        throw","gt":"'<STR_LIT>';"}
{"input":"<s> function foo1(x: C1 | C2 | C3): string {<EOL>    if (x instanceof C1) {<EOL>        return x.item;<EOL>    }<EOL>","gt":"else if (x instanceof C2) {"}
{"input":"<s> function foo1(x: C1 | C2 | C3): string {<EOL>    if (x instanceof C1) {<EOL>        return x.item;<EOL>    }<EOL>    else if (x instanceof C2) {<EOL>        return x.item[<NUM_LIT>];<EOL>    }<EOL>    else if (x instanceof C3) {<EOL>        return x.","gt":"item;"}
{"input":"<s> <EOL>export function getValuePreview(type: string, object: Object, value: string): string {<EOL>    if (type === '<STR_LIT>' || type === '<STR_LIT>') {<EOL>        return type;<EOL>    }<EOL>    if (type === '<STR_LIT>' || type ===","gt":"'<STR_LIT>') {"}
{"input":"<s> <EOL>export function getValuePreview(type: string, object: Object, value: string): string {<EOL>    if (type === '<STR_LIT>' || type === '<STR_LIT>') {<EOL>        return type;<EOL>    }<EOL>    if (type === '<STR_LIT>' || type === '<STR_LIT>') {<EOL>        value = '<STR_LIT>' + escapeString(value) + '<STR_LIT>';<EOL>    }<EOL>    if (type === '<STR_LIT>') {<EOL>        <EOL>        return object.toString()<EOL>            .replace(/[\\r\\n]/g,","gt":"'<STR_LIT>')"}
{"input":"<s> /**<EOL> * Repeats a string a certain number of times.<EOL> * Also: the future is bright and consists of native string repetition:<EOL> * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/repeat<EOL> *<EOL> * @param {string} string  String to repeat<EOL> * @param {number} times   Number of times to repeat string. Integer.<EOL> * @see http://jsperf.com/string-repeater/2<EOL> */<EOL>function repeatString(string, times) {<EOL>    if (times === <NUM_LIT>) {<EOL>        return string;<EOL>    }<EOL>    if (times < <NUM_LIT>) {<EOL>","gt":"throw new Error();"}
{"input":"<s> /**<EOL> * Repeats a string a certain number of times.<EOL> * Also: the future is bright and consists of native string repetition:<EOL> * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/repeat<EOL> *<EOL> * @param {string} string  String to repeat<EOL> * @param {number} times   Number of times to repeat string. Integer.<EOL> * @see http://jsperf.com/string-repeater/2<EOL> */<EOL>function repeatString(string, times) {<EOL>    if (times === <NUM_LIT>) {<EOL>        return string;<EOL>    }<EOL>    if (times < <NUM_LIT>) {<EOL>        throw new Error();<EOL>    }<EOL>    var repeated = '<STR_LIT>';<EOL>    while (times) {<EOL>","gt":"if (times & <NUM_LIT>) {"}
{"input":"<s> /**<EOL> * Repeats a string a certain number of times.<EOL> * Also: the future is bright and consists of native string repetition:<EOL> * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/repeat<EOL> *<EOL> * @param {string} string  String to repeat<EOL> * @param {number} times   Number of times to repeat string. Integer.<EOL> * @see http://jsperf.com/string-repeater/2<EOL> */<EOL>function repeatString(string, times) {<EOL>    if (times === <NUM_LIT>) {<EOL>        return string;<EOL>    }<EOL>    if (times < <NUM_LIT>) {<EOL>        throw new Error();<EOL>    }<EOL>    var repeated = '<STR_LIT>';<EOL>    while (times) {<EOL>        if (times & <NUM_LIT>) {<EOL>            repeated += string;<EOL>        }<EOL>        if (times >>= <NUM_LIT>) {<EOL>","gt":"string += string;"}
{"input":"<s> function isA(x: any): x is A {<EOL>    return","gt":"x instanceof A;"}
{"input":"<s> function B() {<EOL>    var someLocal:","gt":"any = {};"}
{"input":"<s> <EOL>function base<T>() {<EOL>    class Base {<EOL>        static","gt":"prop: T;"}
{"input":"<s> <EOL>export async function hello(event, context, callback) {<EOL>    <EOL>    console.log(_.VERSION);<EOL>    <EOL>    await new Promise((resolve,","gt":"reject) => setTimeout(resolve, <NUM_LIT>));"}
{"input":"<s> /**<EOL> * Code to execute before the page navigation.<EOL> *<EOL> * @param {CreateOptions} options the generation options.<EOL> * @param {*} client the Chrome client.<EOL> * @returns {Promise<void>} resolves if there we no errors or cancellations.<EOL> */<EOL>async function beforeNavigate(options: CreateOptions, client: any): Promise<void> {<EOL>    const { Network, Page, Runtime } = client;<EOL>    await throwIfCanceledOrFailed(options);<EOL>","gt":"if (options.clearCache) {"}
{"input":"<s> /**<EOL> * Code to execute before the page navigation.<EOL> *<EOL> * @param {CreateOptions} options the generation options.<EOL> * @param {*} client the Chrome client.<EOL> * @returns {Promise<void>} resolves if there we no errors or cancellations.<EOL> */<EOL>async function beforeNavigate(options: CreateOptions, client: any): Promise<void> {<EOL>    const { Network, Page, Runtime } = client;<EOL>    await throwIfCanceledOrFailed(options);<EOL>    if (options.clearCache) {<EOL>        await Network.clearBrowserCache();<EOL>    }<EOL>    <EOL>    await Promise.all([<EOL>        Network.enable(),<EOL>        Page.enable(),<EOL>        Runtime.","gt":"enable(),"}
{"input":"<s> /**<EOL> * Code to execute before the page navigation.<EOL> *<EOL> * @param {CreateOptions} options the generation options.<EOL> * @param {*} client the Chrome client.<EOL> * @returns {Promise<void>} resolves if there we no errors or cancellations.<EOL> */<EOL>async function beforeNavigate(options: CreateOptions, client: any): Promise<void> {<EOL>    const { Network, Page, Runtime } = client;<EOL>    await throwIfCanceledOrFailed(options);<EOL>    if (options.clearCache) {<EOL>        await Network.clearBrowserCache();<EOL>    }<EOL>    <EOL>    await Promise.all([<EOL>        Network.enable(),<EOL>        Page.enable(),<EOL>        Runtime.enable(),<EOL>    ]);<EOL>    if (options.runtimeConsoleHandler) {<EOL>        Runtime.consoleAPICalled(options.","gt":"runtimeConsoleHandler);"}
{"input":"<s> /**<EOL> * Code to execute before the page navigation.<EOL> *<EOL> * @param {CreateOptions} options the generation options.<EOL> * @param {*} client the Chrome client.<EOL> * @returns {Promise<void>} resolves if there we no errors or cancellations.<EOL> */<EOL>async function beforeNavigate(options: CreateOptions, client: any): Promise<void> {<EOL>    const { Network, Page, Runtime } = client;<EOL>    await throwIfCanceledOrFailed(options);<EOL>    if (options.clearCache) {<EOL>        await Network.clearBrowserCache();<EOL>    }<EOL>    <EOL>    await Promise.all([<EOL>        Network.enable(),<EOL>        Page.enable(),<EOL>        Runtime.enable(),<EOL>    ]);<EOL>    if (options.runtimeConsoleHandler) {<EOL>        Runtime.consoleAPICalled(options.runtimeConsoleHandler);<EOL>    }<EOL>    if (options.runtimeExceptionHandler) {<EOL>        Runtime.exceptionThrown(options.runtimeExceptionHandler);<EOL>    }<EOL>    Network.requestWillBeSent((e) => {<EOL>        options._mainRequestId = options._mainRequestId || e.requestId;<EOL>    });<EOL>    Network.loadingFailed((e) => {<EOL>        if (e.requestId === options._mainRequestId) {<EOL>","gt":"options._navigateFailed = true;"}
{"input":"<s> function isImplementedViaMixins(node: TsNode) {<EOL>    switch (node.getName()) {<EOL>        case \"<STR_LIT>\":<EOL>","gt":"case \"<STR_LIT>\":"}
{"input":"<s> /**<EOL> * Replaces the text in a source file based on rename locations.<EOL> */<EOL>export function replaceSourceFileTextForRename(opts: {<EOL>    sourceFile: SourceFile;<EOL>    renameLocations: RenameLocation[];<EOL>    newName: string;<EOL>}) {<EOL>    const {","gt":"sourceFile, renameLocations, newName } = opts;"}
{"input":"<s> function updateNotifications() {<EOL>    const notificationContainer = $(\"<STR_LIT>\");<EOL>    if (appState.notifications.length > <NUM_LIT>) {<EOL>        notificationContainer.classList.remove(\"<STR_LIT>\");<EOL>    }<EOL>","gt":"else {"}
{"input":"<s> function updateNotifications() {<EOL>    const notificationContainer = $(\"<STR_LIT>\");<EOL>    if (appState.notifications.length > <NUM_LIT>) {<EOL>        notificationContainer.classList.remove(\"<STR_LIT>\");<EOL>    }<EOL>    else {<EOL>        notificationContainer.classList.add(\"<STR_LIT>\");<EOL>    }<EOL>    while (notificationContainer.hasChildNodes()) {<EOL>        notificationContainer.removeChild(notificationContainer.lastChild);<EOL>    }<EOL>    for (const notificationData of","gt":"appState.notifications) {"}
{"input":"<s> function showSiteProperties(e: Event) {<EOL>    const value = (document.getElementById(\"<STR_LIT>\") as HTMLInputElement);<EOL>    value.value = (document.getElementById(\"<STR_LIT>\") as HTMLInputElement).value;<EOL>    validateSitePropertiesValue();<EOL>    let radio = Array.from(document.querySelectorAll(\"<STR_LIT>\"));<EOL>    const checkedTarget = specificSite ? specificSite.target :","gt":"\"<STR_LIT>\";"}
{"input":"<s> function showSiteProperties(e: Event) {<EOL>    const value = (document.getElementById(\"<STR_LIT>\") as HTMLInputElement);<EOL>    value.value = (document.getElementById(\"<STR_LIT>\") as HTMLInputElement).value;<EOL>    validateSitePropertiesValue();<EOL>    let radio = Array.from(document.querySelectorAll(\"<STR_LIT>\"));<EOL>    const checkedTarget = specificSite ? specificSite.target : \"<STR_LIT>\";<EOL>    radio.forEach((r: HTMLInputElement) => {<EOL>        if (r.value === checkedTarget)<EOL>            r.","gt":"checked = true;"}
{"input":"<s> function showSiteProperties(e: Event) {<EOL>    const value = (document.getElementById(\"<STR_LIT>\") as HTMLInputElement);<EOL>    value.value = (document.getElementById(\"<STR_LIT>\") as HTMLInputElement).value;<EOL>    validateSitePropertiesValue();<EOL>    let radio = Array.from(document.querySelectorAll(\"<STR_LIT>\"));<EOL>    const checkedTarget = specificSite ? specificSite.target : \"<STR_LIT>\";<EOL>    radio.forEach((r: HTMLInputElement) => {<EOL>        if (r.value === checkedTarget)<EOL>            r.checked = true;<EOL>        else<EOL>            r.checked = null;<EOL>    });<EOL>    radio = Array.from(document.querySelectorAll(\"<STR_LIT>\"));<EOL>    const checkedMethod = specificSite ? specificSite.","gt":"method : \"<STR_LIT>\";"}
{"input":"<s> export default function stubImport(data: {<EOL>    type?: ImportType;<EOL>    moduleName?: string;<EOL>    defaultMember?: string;<EOL>    namespaceMember?: string;<EOL>    namedMembers?: Array<NamedMember>;<EOL>}): IImport {<EOL>    const imported = {<EOL>        start: <NUM_LIT>,<EOL>        end: <NUM_LIT>,<EOL>        type: data.","gt":"type || \"<STR_LIT>\","}
{"input":"<s> export default function stubImport(data: {<EOL>    type?: ImportType;<EOL>    moduleName?: string;<EOL>    defaultMember?: string;<EOL>    namespaceMember?: string;<EOL>    namedMembers?: Array<NamedMember>;<EOL>}): IImport {<EOL>    const imported = {<EOL>        start: <NUM_LIT>,<EOL>        end: <NUM_LIT>,<EOL>        type: data.type || \"<STR_LIT>\",<EOL>        moduleName: data.moduleName || \"<STR_LIT>\",<EOL>        defaultMember: data.defaultMember,<EOL>        namespaceMember: data.namespaceMember,<EOL>        namedMembers:","gt":"data.namedMembers || [],"}
{"input":"<s> export function formatImport(code: string, imported: IImport, eol = \"<STR_LIT>\"): string {<EOL>    const importStart = imported.importStart || imported.start;<EOL>    const importEnd = imported.importEnd || imported.end;<EOL>    const importCode = code.substring(importStart, importEnd);<EOL>    const { namedMembers } = imported;<EOL>","gt":"if (namedMembers.length === <NUM_LIT>) {"}
{"input":"<s> export function formatImport(code: string, imported: IImport, eol = \"<STR_LIT>\"): string {<EOL>    const importStart = imported.importStart || imported.start;<EOL>    const importEnd = imported.importEnd || imported.end;<EOL>    const importCode = code.substring(importStart, importEnd);<EOL>    const { namedMembers } = imported;<EOL>    if (namedMembers.length === <NUM_LIT>) {<EOL>        return code.substring(imported.start, imported.end);<EOL>    }<EOL>    const newImportCode =","gt":"importCode.replace(/\\{[\\s\\S]*\\}/g, namedMembersString => {"}
{"input":"<s> export function formatImport(code: string, imported: IImport, eol = \"<STR_LIT>\"): string {<EOL>    const importStart = imported.importStart || imported.start;<EOL>    const importEnd = imported.importEnd || imported.end;<EOL>    const importCode = code.substring(importStart, importEnd);<EOL>    const { namedMembers } = imported;<EOL>    if (namedMembers.length === <NUM_LIT>) {<EOL>        return code.substring(imported.start, imported.end);<EOL>    }<EOL>    const newImportCode = importCode.replace(/\\{[\\s\\S]*\\}/g, namedMembersString => {<EOL>        const useMultipleLines = namedMembersString.indexOf(eol) !== -<NUM_LIT>;<EOL>        let prefix: string | undefined;<EOL>        if (useMultipleLines) {<EOL>            prefix = namedMembersString.split(eol)[<NUM_LIT>].match(/^\\s*/)![<NUM_LIT>];<EOL>        }<EOL>        let useSpaces = namedMembersString.charAt(<NUM_LIT>) === \"<STR_LIT>\";<EOL>        let userTrailingComma = namedMembersString<EOL>            .replace(\"<STR_LIT>\", \"<STR_LIT>\")<EOL>            .trim()<EOL>            .","gt":"endsWith(\"<STR_LIT>\");"}
{"input":"<s> function handleFilePathError(filePath, e) {<EOL>","gt":"console.error(`<STR_LIT>`);"}
{"input":"<s> /**<EOL> * Turn a callback function into a promise function.<EOL> */<EOL>export default function run(context: any, method: Function, args?: any): Promise<any> {<EOL>    if (!Array.isArray(args)) {<EOL>        args = [args];<EOL>    }<EOL>    return new Promise((resolve, reject) => {<EOL>        method.","gt":"apply(context, args.concat(["}
{"input":"<s> /**<EOL> * Turn a callback function into a promise function.<EOL> */<EOL>export default function run(context: any, method: Function, args?: any): Promise<any> {<EOL>    if (!Array.isArray(args)) {<EOL>        args = [args];<EOL>    }<EOL>    return new Promise((resolve, reject) => {<EOL>        method.apply(context, args.concat([<EOL>            (err: any, ...rest: any[]) => {<EOL>                if (err) {<EOL>                    reject(err);<EOL>                    return;<EOL>                }<EOL>","gt":"resolve.apply(null, rest);"}
{"input":"<s> export default function reborm(ActorClass: ActorConstructor, snap: Snap, events: Event[]): Actor {<EOL>    const actor = ActorClass.parse(snap.","gt":"data);"}
{"input":"<s> /**<EOL> * 获取长id<EOL> *<EOL> * @param {number} roomID<EOL> * @returns {number}<EOL> */<EOL>function getLongRoomID(roomID: number): number {<EOL>    return longRoomID.","gt":"get(roomID) || roomID;"}
{"input":"<s> function copyStringToClipboard(value) {<EOL>    const copyFrom = document.createElement(\"<STR_LIT>\");<EOL>    copyFrom.textContent = value;<EOL>    const body =","gt":"document.getElementsByTagName(\"<STR_LIT>\")[<NUM_LIT>];"}
{"input":"<s> function always() {<EOL>    return","gt":"true;"}
{"input":"<s> export function getTypescriptConfig(cwd: string, logger?: {<EOL>    log: (str: string) => void;<EOL>}): ts.CompilerOptions {<EOL>    const configFilePath = path.join(cwd, '<STR_LIT>');<EOL>    if (fs.existsSync(configFilePath)) {<EOL>        const configFileText = fs.readFileSync(configFilePath).toString();<EOL>        const result = ts.parseConfigFileTextToJson(configFilePath, configFileText);<EOL>        if (","gt":"result.error) {"}
{"input":"<s> export function getTypescriptConfig(cwd: string, logger?: {<EOL>    log: (str: string) => void;<EOL>}): ts.CompilerOptions {<EOL>    const configFilePath = path.join(cwd, '<STR_LIT>');<EOL>    if (fs.existsSync(configFilePath)) {<EOL>        const configFileText = fs.readFileSync(configFilePath).toString();<EOL>        const result = ts.parseConfigFileTextToJson(configFilePath, configFileText);<EOL>        if (result.error) {<EOL>            throw new Error(JSON.stringify(result.error));<EOL>        }<EOL>        const configParseResult = ts.parseJsonConfigFileContent(result.config, ts.sys, path.dirname(configFilePath));<EOL>        if (configParseResult.errors.length > <NUM_LIT>) {<EOL>            throw new Error(JSON.stringify(configParseResult.errors));<EOL>        }<EOL>","gt":"if (logger) {"}
{"input":"<s> export function getTypescriptConfig(cwd: string, logger?: {<EOL>    log: (str: string) => void;<EOL>}): ts.CompilerOptions {<EOL>    const configFilePath = path.join(cwd, '<STR_LIT>');<EOL>    if (fs.existsSync(configFilePath)) {<EOL>        const configFileText = fs.readFileSync(configFilePath).toString();<EOL>        const result = ts.parseConfigFileTextToJson(configFilePath, configFileText);<EOL>        if (result.error) {<EOL>            throw new Error(JSON.stringify(result.error));<EOL>        }<EOL>        const configParseResult = ts.parseJsonConfigFileContent(result.config, ts.sys, path.dirname(configFilePath));<EOL>        if (configParseResult.errors.length > <NUM_LIT>) {<EOL>            throw new Error(JSON.stringify(configParseResult.errors));<EOL>        }<EOL>        if (logger) {<EOL>            logger.log(`<STR_LIT>`);<EOL>        }<EOL>        <EOL>        if (configParseResult.options.rootDir && path.resolve(configParseResult.options.rootDir) !== path.resolve(cwd) && logger) {<EOL>            logger.","gt":"log('<STR_LIT>');"}
{"input":"<s> function startsWithUpperCase(text: string): boolean {<EOL>    let start = text.charAt(","gt":"<NUM_LIT>);"}
{"input":"<s> function execCopy(data: DT): boolean {<EOL>    var tracker = new FallbackTracker();<EOL>    var listener = copyListener.bind(this, tracker, data);<EOL>    document.addEventListener(\"<STR_LIT>\", listener);<EOL>","gt":"try {"}
{"input":"<s> function execCopy(data: DT): boolean {<EOL>    var tracker = new FallbackTracker();<EOL>    var listener = copyListener.bind(this, tracker, data);<EOL>    document.addEventListener(\"<STR_LIT>\", listener);<EOL>    try {<EOL>        <EOL>        <EOL>        <EOL>        document.execCommand(\"<STR_LIT>\");<EOL>    }<EOL>","gt":"finally {"}
{"input":"<s> /**<EOL> * 格式化输出, 配合PM2凑合用<EOL> *<EOL> * @param {...any[]} message<EOL> */<EOL>function ErrorLog(...message: any[]) {<EOL>    console.error(","gt":"<NUM_LIT>, <NUM_LIT>)} :`<STR_LIT>;"}
{"input":"<s> function track(category: '<STR_LIT>' | '<STR_LIT>' | '<STR_LIT>' | '<STR_LIT>' | '<STR_LIT>' | '<STR_LIT>', action: string) {<EOL>","gt":"if (isProduction() && typeof ga === '<STR_LIT>') {"}
{"input":"<s> function invoke(item: ADT) {<EOL>    if (item.kind === \"<STR_LIT>\") {<EOL>","gt":"item.method(\"<STR_LIT>\");"}
{"input":"<s> function f4(x: Foo | Bar | string | number | null) {<EOL>    if (x && typeof x === \"<STR_LIT>\") {<EOL>","gt":"switch (x.kind) {"}
{"input":"<s> export function initStandalone(app, url, version?: string) {<EOL>    /**<EOL>     * This should allow the firebase-admin package to provide a custom version<EOL>     * to the backend<EOL>     */<EOL>    CONSTANTS.NODE_ADMIN = true;<EOL>    if (version) {<EOL>        firebase.SDK_VERSION = version;<EOL>    }<EOL>","gt":"return {"}
{"input":"<s> export function initStandalone(app, url, version?: string) {<EOL>    /**<EOL>     * This should allow the firebase-admin package to provide a custom version<EOL>     * to the backend<EOL>     */<EOL>    CONSTANTS.NODE_ADMIN = true;<EOL>    if (version) {<EOL>        firebase.SDK_VERSION = version;<EOL>    }<EOL>    return {<EOL>        instance: RepoManager.getInstance().databaseFromApp(app, url),<EOL>        namespace: {<EOL>            Reference,<EOL>","gt":"Query,"}
{"input":"<s> export function initStandalone(app, url, version?: string) {<EOL>    /**<EOL>     * This should allow the firebase-admin package to provide a custom version<EOL>     * to the backend<EOL>     */<EOL>    CONSTANTS.NODE_ADMIN = true;<EOL>    if (version) {<EOL>        firebase.SDK_VERSION = version;<EOL>    }<EOL>    return {<EOL>        instance: RepoManager.getInstance().databaseFromApp(app, url),<EOL>        namespace: {<EOL>            Reference,<EOL>            Query,<EOL>            Database,<EOL>            enableLogging,<EOL>","gt":"INTERNAL,"}
{"input":"<s> function switchToSpecificSitesMode(e) {<EOL>    e.preventDefault();<EOL>    if (e.target.checked) {<EOL>        siteModeAll = false;<EOL>        document.getElementById(\"<STR_LIT>\").style.display = \"<STR_LIT>\";<EOL>        <EOL>        document.getElementById(\"<STR_LIT>\").style.display = \"<STR_LIT>\";<EOL>        document.getElementById(\"<STR_LIT>\").style.display = \"<STR_LIT>\";<EOL>        document.getElementById(\"<STR_LIT>\").style.display = \"<STR_LIT>\";<EOL>        document.getElementById(\"<STR_LIT>\").style.display = \"<STR_LIT>\";<EOL>        document.getElementById(\"<STR_LIT>\").style.display = \"<STR_LIT>\";<EOL>        [].","gt":"forEach.call($$(\"<STR_LIT>\"), node => (node as HTMLElement).style.display = null);"}
{"input":"<s> function getTransitionCandidates(transition: Transition): TargetTransitionConfig[] {<EOL>    if (typeof transition === '<STR_LIT>') {<EOL>        return [<EOL>            {<EOL>                target: transition<EOL>            }<EOL>        ];<EOL>    }<EOL>    if (Array.isArray(transition)) {<EOL>        return transition;<EOL>    }<EOL>","gt":"return Object.keys(transition).map(target => ({"}
{"input":"<s> function foo2() {<EOL>","gt":"return \"<STR_LIT>\";"}
{"input":"<s> function logError(err: CommandError) {<EOL>    console.log(chalk.bgBlack.red('<STR_LIT>'), err.message);<EOL>","gt":"if (err.stack && !err.pretty) {"}
{"input":"<s> function handleUncaughtException(error: Error) {<EOL>    if (mainWindow) {<EOL>","gt":"mainWindow.destroy();"}
{"input":"<s> export function assert_can_read(who: string, where: string, expected: any, test: nodeunit.Test, cb) {<EOL>    firebase_io.loginAs(who, false, function (err) {<EOL>        if (err) {<EOL>            test.ok(false, \"<STR_LIT>\");<EOL>            cb(\"<STR_LIT>\");<EOL>        }<EOL>        else {<EOL>            firebase_io.sandbox.child(where).once(\"<STR_LIT>\", function (data) {<EOL>                test.deepEqual(data.val(), expected);<EOL>                cb(","gt":"null);"}
{"input":"<s> export function assert_can_read(who: string, where: string, expected: any, test: nodeunit.Test, cb) {<EOL>    firebase_io.loginAs(who, false, function (err) {<EOL>        if (err) {<EOL>            test.ok(false, \"<STR_LIT>\");<EOL>            cb(\"<STR_LIT>\");<EOL>        }<EOL>        else {<EOL>            firebase_io.sandbox.child(where).once(\"<STR_LIT>\", function (data) {<EOL>                test.deepEqual(data.val(), expected);<EOL>                cb(null);<EOL>            }, function (error) {<EOL>                test.ok(error == null, \"<STR_LIT>\" +<EOL>                    JSON.stringify({ function: \"<STR_LIT>\", who: who, where: where, expected: expected }));<EOL>","gt":"cb(error);"}
{"input":"<s> export function toTrie(stateValue: State | StateValue): StateValue {<EOL>    if (stateValue instanceof State) {<EOL>        return stateValue.value;<EOL>    }<EOL>    if (typeof stateValue === '<STR_LIT>' && !(stateValue instanceof State)) {<EOL>        return","gt":"stateValue;"}
{"input":"<s> export function toTrie(stateValue: State | StateValue): StateValue {<EOL>    if (stateValue instanceof State) {<EOL>        return stateValue.value;<EOL>    }<EOL>    if (typeof stateValue === '<STR_LIT>' && !(stateValue instanceof State)) {<EOL>        return stateValue;<EOL>    }<EOL>    const statePath =","gt":"toStatePath(stateValue as string);"}
{"input":"<s> export function toTrie(stateValue: State | StateValue): StateValue {<EOL>    if (stateValue instanceof State) {<EOL>        return stateValue.value;<EOL>    }<EOL>    if (typeof stateValue === '<STR_LIT>' && !(stateValue instanceof State)) {<EOL>        return stateValue;<EOL>    }<EOL>    const statePath = toStatePath(stateValue as string);<EOL>    if (statePath.length === <NUM_LIT>) {<EOL>        return statePath[<NUM_LIT>];<EOL>    }<EOL>    const value = {};<EOL>    let","gt":"marker = value;"}
{"input":"<s> export function toTrie(stateValue: State | StateValue): StateValue {<EOL>    if (stateValue instanceof State) {<EOL>        return stateValue.value;<EOL>    }<EOL>    if (typeof stateValue === '<STR_LIT>' && !(stateValue instanceof State)) {<EOL>        return stateValue;<EOL>    }<EOL>    const statePath = toStatePath(stateValue as string);<EOL>    if (statePath.length === <NUM_LIT>) {<EOL>        return statePath[<NUM_LIT>];<EOL>    }<EOL>    const value = {};<EOL>    let marker = value;<EOL>    for (let i = <NUM_LIT>; i < statePath.length - <NUM_LIT>; i++) {<EOL>        if (i === statePath.length - <NUM_LIT>) {<EOL>            marker[statePath[i]] = statePath[i + <NUM_LIT>];<EOL>        }<EOL>","gt":"else {"}
{"input":"<s> export function getRandomItem(array: any[]) {<EOL>    return","gt":"array[getRandomInt(<NUM_LIT>, array.length - <NUM_LIT>)];"}
{"input":"<s> function edgesTo(id: String) {<EOL>    return _.toArray(","gt":"document.querySelectorAll(`<STR_LIT>`));"}
{"input":"<s> /** Parses output from git status --porcelain -z into file status entries */<EOL>export function parsePorcelainStatus(output: string): ReadonlyArray<StatusItem> {<EOL>    const entries = new Array<StatusItem>();<EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    const fields = output.split('<STR_LIT>');<EOL>    let field: string | undefined;<EOL>    while ((","gt":"field = fields.shift())) {"}
{"input":"<s> /** Parses output from git status --porcelain -z into file status entries */<EOL>export function parsePorcelainStatus(output: string): ReadonlyArray<StatusItem> {<EOL>    const entries = new Array<StatusItem>();<EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    const fields = output.split('<STR_LIT>');<EOL>    let field: string | undefined;<EOL>    while ((field = fields.shift())) {<EOL>        if (field.startsWith('<STR_LIT>') && field.length > <NUM_LIT>) {<EOL>            entries.push({ kind: '<STR_LIT>', value: field.substr(<NUM_LIT>) });<EOL>            continue;<EOL>        }<EOL>        const entryKind = field.substr(<NUM_LIT>, <NUM_LIT>);<EOL>        if (entryKind === ChangedEntryType) {<EOL>            entries.push(parseChangedEntry(field));<EOL>        }<EOL>        else if (entryKind === RenamedOrCopiedEntryType) {<EOL>            entries.push(parsedRenamedOrCopiedEntry(field, fields.shift()));<EOL>        }<EOL>        else if (entryKind === UnmergedEntryType) {<EOL>","gt":"entries.push(parseUnmergedEntry(field));"}
{"input":"<s> export function changeNaDisplayOptions(options: any) {<EOL>    return {<EOL>","gt":"type: CHANGE_NOT_APPLIED_DISPLAY_OPTIONS,"}
{"input":"<s> function foo4() {<EOL>    return","gt":"new m.c();"}
{"input":"<s> function snd<A, B>(a: [<EOL>    A,<EOL>    B<EOL>]): B {<EOL>    return a[","gt":"<NUM_LIT>];"}
{"input":"<s> /**<EOL> * Button click handler<EOL> */<EOL>function clickHandler(ev) {<EOL>    var windowId = listState[focusIndex].returnValue;<EOL>    if (windowId === -<NUM_LIT>) {<EOL>        returnMessage({","gt":"newWindow: true });"}
{"input":"<s> /**<EOL> * Draws the text inside the icon<EOL> *<EOL> * @param text: text to draw (String or Number)<EOL> */<EOL>export default function drawIcon(text: string) {<EOL>    text = text.toString();<EOL>    <EOL>    ctx.clearRect(BORDER_WIDTH, BORDER_WIDTH, INNER_SIZE, INNER_SIZE);<EOL>    <EOL>    if (text.length >= <NUM_LIT>) {<EOL>        ctx.font = SMALL_FONT;<EOL>        ctx.fillText(text, SIZE / <NUM_LIT>, TEXT_POSITION, INNER_SIZE);<EOL>    }<EOL>    else {<EOL>        ctx.font =","gt":"BIG_FONT;"}
{"input":"<s> /**<EOL> * Draws a rounded rectangle using the current state of the canvas.<EOL> *<EOL> * http://stackoverflow.com/questions/1255512/how-to-draw-a-rounded-rectangle-on-html-canvas<EOL> */<EOL>function roundedRect(ctx: CanvasRenderingContext2D, x: number, y: number, width: number, height: number, radius: number) {<EOL>    ctx.beginPath();<EOL>    ctx.moveTo(x + radius, y);<EOL>    ctx.lineTo(x + width - radius, y);<EOL>    ctx.quadraticCurveTo(","gt":"x + width, y, x + width, y + radius);"}
{"input":"<s> /**<EOL> * Draws a rounded rectangle using the current state of the canvas.<EOL> *<EOL> * http://stackoverflow.com/questions/1255512/how-to-draw-a-rounded-rectangle-on-html-canvas<EOL> */<EOL>function roundedRect(ctx: CanvasRenderingContext2D, x: number, y: number, width: number, height: number, radius: number) {<EOL>    ctx.beginPath();<EOL>    ctx.moveTo(x + radius, y);<EOL>    ctx.lineTo(x + width - radius, y);<EOL>    ctx.quadraticCurveTo(x + width, y, x + width, y + radius);<EOL>    ctx.lineTo(x + width, y + height - radius);<EOL>    ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);<EOL>    ctx.lineTo(x + radius, y + height);<EOL>    ctx.quadraticCurveTo(x, y + height, x, y + height - radius);<EOL>    ctx.lineTo(x,","gt":"y + radius);"}
{"input":"<s> function send(channel: string, arg: string) {<EOL>    const window = BrowserWindow.getAllWindows()[<NUM_LIT>];<EOL>    if (window) {<EOL>        log.info('<STR_LIT>',","gt":"channel, arg);"}
{"input":"<s> function generate_class(schema: schema.SchemaNode, output: string[]) {<EOL>    if (DEBUG)<EOL>        console.","gt":"log(\"<STR_LIT>\", schema);"}
{"input":"<s> /**<EOL> * Gets active tab in the last focused window.<EOL> */<EOL>export function getActive(): Promise<browser.tabs.Tab> {<EOL>    return browser.tabs.query({","gt":"lastFocusedWindow: true, active: true }).then(results => results[<NUM_LIT>]);"}
{"input":"<s> /**<EOL> * Iterates backwards over an array.<EOL> * Does not handle sparse arrays in a special way, just like<EOL> * the original iterator.<EOL> */<EOL>function valuesBackwards<X>(this: X[]): IterableIterator<X> {<EOL>    let i = this.length;<EOL>    return {<EOL>        [Symbol.iterator]() { return this; },<EOL>","gt":"next: () => {"}
{"input":"<s> function isDefined<X>(x: (X | null | undefined)): x is X {<EOL>    return","gt":"x != null;"}
{"input":"<s> /**<EOL> * Add a command listener.<EOL> * To unlisten: `onCommand('name', null)`<EOL> *<EOL> * Note: Currently this only accepts one listener per name. A subsequent<EOL> * call just overrides the previous listener.<EOL> */<EOL>export function onCommand(command: string, listener: () => void) {<EOL>    if (listeners.size === <NUM_LIT>) {<EOL>","gt":"browser.commands.onCommand.addListener(globalListener);"}
{"input":"<s> export async function scrollTo(client: Client, x: number, y: number): Promise<void> {<EOL>    const { Runtime } = client;<EOL>    const","gt":"browserCode = `<STR_LIT>{"}
{"input":"<s> function capitalized(str: string): string {<EOL>    return str.charAt(<NUM_LIT>).toUpperCase() + str.","gt":"slice(<NUM_LIT>);"}
{"input":"<s> <EOL><EOL>export function introspectionToSchema(introspection: IntrospectionResult | (IntrospectionQuery & {<EOL>    errors: undefined;<EOL>    data: undefined;<EOL>})) {<EOL>    if (introspection.errors != null) {<EOL>","gt":"throw new Error('<STR_LIT>');"}
{"input":"<s> function a0() {<EOL>    {<EOL>        let x = <NUM_LIT>;<EOL>        () =>","gt":"x;"}
{"input":"<s> <EOL>export function serialize(schema, field) {<EOL>    const obj: SerializedObj = {<EOL>        fields: [],<EOL>","gt":"interfaces: [],"}
{"input":"<s> <EOL>export function serialize(schema, field) {<EOL>    const obj: SerializedObj = {<EOL>        fields: [],<EOL>        interfaces: [],<EOL>        args: [],<EOL>        implementations: [],<EOL>    };<EOL>    let type = field.type || field;<EOL>    const isVarType = isType(type);<EOL>    if (type.ofType) {<EOL>","gt":"type = getDeeperType(type.ofType);"}
{"input":"<s> <EOL>export function serialize(schema, field) {<EOL>    const obj: SerializedObj = {<EOL>        fields: [],<EOL>        interfaces: [],<EOL>        args: [],<EOL>        implementations: [],<EOL>    };<EOL>    let type = field.type || field;<EOL>    const isVarType = isType(type);<EOL>    if (type.ofType) {<EOL>        type = getDeeperType(type.ofType);<EOL>    }<EOL>    <EOL>    if (type.getFields) {<EOL>","gt":"const fieldMap = type.getFields();"}
{"input":"<s> <EOL>export function serialize(schema, field) {<EOL>    const obj: SerializedObj = {<EOL>        fields: [],<EOL>        interfaces: [],<EOL>        args: [],<EOL>        implementations: [],<EOL>    };<EOL>    let type = field.type || field;<EOL>    const isVarType = isType(type);<EOL>    if (type.ofType) {<EOL>        type = getDeeperType(type.ofType);<EOL>    }<EOL>    <EOL>    if (type.getFields) {<EOL>        const fieldMap = type.getFields();<EOL>        obj.fields = Object.keys(fieldMap).map(name => {<EOL>            const f = fieldMap[name];<EOL>            f.parent = field;<EOL>","gt":"f.path = field.path + `<STR_LIT>`;"}
{"input":"<s> function message(action: PRESENCE_ACTIONS, user?: string): Message {<EOL>    if (user) {<EOL>        return {<EOL>            name: user,<EOL>            topic: TOPIC.","gt":"PRESENCE,"}
{"input":"<s> function message(action: PRESENCE_ACTIONS, user?: string): Message {<EOL>    if (user) {<EOL>        return {<EOL>            name: user,<EOL>            topic: TOPIC.PRESENCE,<EOL>            action<EOL>        };<EOL>    }<EOL>    else {<EOL>        return {<EOL>            topic:","gt":"TOPIC.PRESENCE,"}
{"input":"<s> function foo2() {<EOL>    {<EOL>        let x = <NUM_LIT>;<EOL>        use(","gt":"x);"}
{"input":"<s> async function initRepository(repository: any) {<EOL>    <EOL>    for (let BO_MODULE_INDEX = <NUM_LIT>; BO_MODULE_INDEX < BO_MODULE_COUNT; BO_MODULE_INDEX++) {<EOL>        let mod = await Module.create(BO_MODULE_FN({ creatorId: repository.creatorId, repositoryId: repository.id }));<EOL>        await repository.addModule(mod);<EOL>        <EOL>        for (let BO_INTERFACE_INDEX = <NUM_LIT>; BO_INTERFACE_INDEX < BO_INTERFACE_COUNT; BO_INTERFACE_INDEX++) {<EOL>            let itf = await Interface.create(BO_INTERFACE_FN({ creatorId: mod.creatorId, repositoryId: repository.id, moduleId: mod.id }));<EOL>            await mod.$add('<STR_LIT>', itf);<EOL>            <EOL>            for (let BO_PROPERTY_INDEX = <NUM_LIT>; BO_PROPERTY_INDEX < BO_PROPERTY_COUNT; BO_PROPERTY_INDEX++) {<EOL>                let prop = await Property.create(BO_PROPERTY_FN({ creatorId: itf.creatorId, repositoryId: repository.id, moduleId: mod.id, interfaceId: itf.id }));<EOL>                await itf.$add(","gt":"'<STR_LIT>', prop);"}
{"input":"<s> function parseRef(rawRef: string): {<EOL>    type: string;<EOL>    ref: string;<EOL>} {<EOL>    const [type, ref] =","gt":"rawRef.split(/\\s*:\\s*/);"}
{"input":"<s> export function validateCallback(fnName, argumentNumber, callback, optional) {<EOL>    if (optional && !callback)<EOL>","gt":"return;"}
{"input":"<s> export function getTsConfigParseResult(opts: TsConfigParseOptions) {<EOL>    const { encoding, fileSystemWrapper } = opts;<EOL>    const tsConfigFilePath = fileSystemWrapper.getStandardizedAbsolutePath(opts.tsConfigFilePath);<EOL>    errors.throwIfFileNotExists(","gt":"fileSystemWrapper, tsConfigFilePath);"}
{"input":"<s> function getReplacementText(node: Node) {<EOL>    const childSyntaxList = node.getChildSyntaxListOrThrow();<EOL>    const indentationText = node.getIndentationText();<EOL>    const childIndentationText = node.getChildIndentationText();<EOL>    const indentationDifference = childIndentationText.replace(indentationText, \"<STR_LIT>\");<EOL>    const replaceRegex = new RegExp(\"<STR_LIT>\" + indentationDifference);<EOL>    const originalText =","gt":"childSyntaxList.getFullText();"}
{"input":"<s> function getReplacementText(node: Node) {<EOL>    const childSyntaxList = node.getChildSyntaxListOrThrow();<EOL>    const indentationText = node.getIndentationText();<EOL>    const childIndentationText = node.getChildIndentationText();<EOL>    const indentationDifference = childIndentationText.replace(indentationText, \"<STR_LIT>\");<EOL>    const replaceRegex = new RegExp(\"<STR_LIT>\" + indentationDifference);<EOL>    const originalText = childSyntaxList.getFullText();<EOL>    const sourceFile = node.sourceFile;<EOL>    const lines = originalText.split(\"<STR_LIT>\");<EOL>    let pos = childSyntaxList.getPos();<EOL>    const newLines:","gt":"string[] = [];"}
{"input":"<s> function F<T>() {<EOL>    var","gt":"expr: T;"}
{"input":"<s> function getCachedGitIgnores(): Promise<Map<string, string>> {<EOL>    if (cachedGitIgnores) {<EOL>        return Promise.resolve(cachedGitIgnores);<EOL>    }<EOL>","gt":"else {"}
{"input":"<s> function getCachedGitIgnores(): Promise<Map<string, string>> {<EOL>    if (cachedGitIgnores) {<EOL>        return Promise.resolve(cachedGitIgnores);<EOL>    }<EOL>    else {<EOL>        return new Promise((resolve, reject) => {<EOL>            Fs.readdir(root, (err, files) => {<EOL>","gt":"if (err) {"}
{"input":"<s> function getCachedGitIgnores(): Promise<Map<string, string>> {<EOL>    if (cachedGitIgnores) {<EOL>        return Promise.resolve(cachedGitIgnores);<EOL>    }<EOL>    else {<EOL>        return new Promise((resolve, reject) => {<EOL>            Fs.readdir(root, (err, files) => {<EOL>                if (err) {<EOL>                    reject(err);<EOL>                }<EOL>                else {<EOL>","gt":"const ignoreFiles = files.filter(file => file.endsWith(GitIgnoreExtension));"}
{"input":"<s> function getCachedGitIgnores(): Promise<Map<string, string>> {<EOL>    if (cachedGitIgnores) {<EOL>        return Promise.resolve(cachedGitIgnores);<EOL>    }<EOL>    else {<EOL>        return new Promise((resolve, reject) => {<EOL>            Fs.readdir(root, (err, files) => {<EOL>                if (err) {<EOL>                    reject(err);<EOL>                }<EOL>                else {<EOL>                    const ignoreFiles = files.filter(file => file.endsWith(GitIgnoreExtension));<EOL>                    cachedGitIgnores = new Map();<EOL>                    for (const file of ignoreFiles) {<EOL>                        cachedGitIgnores.set(Path.basename(file, GitIgnoreExtension), Path.join(root, file));<EOL>                    }<EOL>                    resolve(","gt":"cachedGitIgnores);"}
{"input":"<s> function f2() {<EOL>    let x = [];<EOL>    x.push(","gt":"<NUM_LIT>);"}
{"input":"<s> function f8() {<EOL>    let x = [];<EOL>    x.push(<NUM_LIT>);<EOL>    if (","gt":"cond())"}
{"input":"<s> export async function getLogLines(previousVersion: string): Promise<ReadonlyArray<string>> {<EOL>    const log = await spawn('<STR_LIT>', [<EOL>        '<STR_LIT>',<EOL>        `<STR_LIT>`,<EOL>","gt":"'<STR_LIT>',"}
{"input":"<s> export async function getLogLines(previousVersion: string): Promise<ReadonlyArray<string>> {<EOL>    const log = await spawn('<STR_LIT>', [<EOL>        '<STR_LIT>',<EOL>        `<STR_LIT>`,<EOL>        '<STR_LIT>',<EOL>        '<STR_LIT>',<EOL>        '<STR_LIT>',<EOL>        '<STR_LIT>',<EOL>","gt":"'<STR_LIT>',"}
{"input":"<s> /**<EOL> * A wrapper around the http and https request libraries to simplify & promisify JSON requests.<EOL> * TODO(inlined): Create a type for \"transit\".<EOL> */<EOL>function requestAccessToken(transit, options: object, data?: any): Promise<GoogleOAuthAccessToken> {<EOL>    return new Promise((resolve, reject) => {<EOL>        const req = transit.request(options, (res) => {<EOL>","gt":"const buffers: Buffer[] = [];"}
{"input":"<s> /**<EOL> * A wrapper around the http and https request libraries to simplify & promisify JSON requests.<EOL> * TODO(inlined): Create a type for \"transit\".<EOL> */<EOL>function requestAccessToken(transit, options: object, data?: any): Promise<GoogleOAuthAccessToken> {<EOL>    return new Promise((resolve, reject) => {<EOL>        const req = transit.request(options, (res) => {<EOL>            const buffers: Buffer[] = [];<EOL>            res.on('<STR_LIT>', (buffer) => buffers.push(buffer));<EOL>            res.on('<STR_LIT>', () => {<EOL>","gt":"try {"}
{"input":"<s> /**<EOL> * A wrapper around the http and https request libraries to simplify & promisify JSON requests.<EOL> * TODO(inlined): Create a type for \"transit\".<EOL> */<EOL>function requestAccessToken(transit, options: object, data?: any): Promise<GoogleOAuthAccessToken> {<EOL>    return new Promise((resolve, reject) => {<EOL>        const req = transit.request(options, (res) => {<EOL>            const buffers: Buffer[] = [];<EOL>            res.on('<STR_LIT>', (buffer) => buffers.push(buffer));<EOL>            res.on('<STR_LIT>', () => {<EOL>                try {<EOL>                    const json = JSON.parse(Buffer.concat(buffers).toString());<EOL>                    if (json.error) {<EOL>                        let errorMessage = '<STR_LIT>' + json.error;<EOL>                        if (","gt":"json.error_description) {"}
{"input":"<s> /**<EOL> * A wrapper around the http and https request libraries to simplify & promisify JSON requests.<EOL> * TODO(inlined): Create a type for \"transit\".<EOL> */<EOL>function requestAccessToken(transit, options: object, data?: any): Promise<GoogleOAuthAccessToken> {<EOL>    return new Promise((resolve, reject) => {<EOL>        const req = transit.request(options, (res) => {<EOL>            const buffers: Buffer[] = [];<EOL>            res.on('<STR_LIT>', (buffer) => buffers.push(buffer));<EOL>            res.on('<STR_LIT>', () => {<EOL>                try {<EOL>                    const json = JSON.parse(Buffer.concat(buffers).toString());<EOL>                    if (json.error) {<EOL>                        let errorMessage = '<STR_LIT>' + json.error;<EOL>                        if (json.error_description) {<EOL>                            errorMessage += '<STR_LIT>' + json.error_description + '<STR_LIT>';<EOL>                        }<EOL>                        reject(new FirebaseAppError(AppErrorCodes.INVALID_CREDENTIAL, errorMessage));<EOL>                    }<EOL>                    else if (!json.access_token || !json.expires_in) {<EOL>                        reject(new FirebaseAppError(AppErrorCodes.INVALID_CREDENTIAL, `<STR_LIT>`));<EOL>                    }<EOL>","gt":"else {"}
{"input":"<s> /**<EOL> * Generate a random string of the specified length, optionally using the specified alphabet.<EOL> *<EOL> * @param {number} length The length of the string to generate.<EOL> * @return {string} A random string of the provided length.<EOL> */<EOL>export function generateRandomString(length: number): string {<EOL>    const alphabet = '<STR_LIT>';<EOL>","gt":"let text = '<STR_LIT>';"}
{"input":"<s> /**<EOL> * Maps an error Code from GRPC status code number, like 0, 1, or 14. These<EOL> * are not the same as HTTP status codes.<EOL> *<EOL> * @returns The Code equivalent to the given GRPC status code. Fails if there<EOL> *     is no match.<EOL> */<EOL>export function mapCodeFromRpcCode(code: number | undefined): Code {<EOL>    if (code === undefined) {<EOL>        <EOL>        <EOL>        log.error(","gt":"'<STR_LIT>');"}
{"input":"<s> /**<EOL> * Maps an error Code from GRPC status code number, like 0, 1, or 14. These<EOL> * are not the same as HTTP status codes.<EOL> *<EOL> * @returns The Code equivalent to the given GRPC status code. Fails if there<EOL> *     is no match.<EOL> */<EOL>export function mapCodeFromRpcCode(code: number | undefined): Code {<EOL>    if (code === undefined) {<EOL>        <EOL>        <EOL>        log.error('<STR_LIT>');<EOL>        return Code.UNKNOWN;<EOL>    }<EOL>    switch (code) {<EOL>        case RpcCode.OK:<EOL>","gt":"return Code.OK;"}
{"input":"<s> /**<EOL> * Maps an error Code from GRPC status code number, like 0, 1, or 14. These<EOL> * are not the same as HTTP status codes.<EOL> *<EOL> * @returns The Code equivalent to the given GRPC status code. Fails if there<EOL> *     is no match.<EOL> */<EOL>export function mapCodeFromRpcCode(code: number | undefined): Code {<EOL>    if (code === undefined) {<EOL>        <EOL>        <EOL>        log.error('<STR_LIT>');<EOL>        return Code.UNKNOWN;<EOL>    }<EOL>    switch (code) {<EOL>        case RpcCode.OK:<EOL>            return Code.OK;<EOL>        case RpcCode.CANCELLED:<EOL>            return Code.CANCELLED;<EOL>        case RpcCode.UNKNOWN:<EOL>            return Code.UNKNOWN;<EOL>        case","gt":"RpcCode.DEADLINE_EXCEEDED:"}
{"input":"<s> /**<EOL> * Maps an error Code from GRPC status code number, like 0, 1, or 14. These<EOL> * are not the same as HTTP status codes.<EOL> *<EOL> * @returns The Code equivalent to the given GRPC status code. Fails if there<EOL> *     is no match.<EOL> */<EOL>export function mapCodeFromRpcCode(code: number | undefined): Code {<EOL>    if (code === undefined) {<EOL>        <EOL>        <EOL>        log.error('<STR_LIT>');<EOL>        return Code.UNKNOWN;<EOL>    }<EOL>    switch (code) {<EOL>        case RpcCode.OK:<EOL>            return Code.OK;<EOL>        case RpcCode.CANCELLED:<EOL>            return Code.CANCELLED;<EOL>        case RpcCode.UNKNOWN:<EOL>            return Code.UNKNOWN;<EOL>        case RpcCode.DEADLINE_EXCEEDED:<EOL>            return Code.DEADLINE_EXCEEDED;<EOL>        case RpcCode.RESOURCE_EXHAUSTED:<EOL>            return Code.RESOURCE_EXHAUSTED;<EOL>        case RpcCode.INTERNAL:<EOL>            return Code.","gt":"INTERNAL;"}
{"input":"<s> /**<EOL> * Maps an error Code from GRPC status code number, like 0, 1, or 14. These<EOL> * are not the same as HTTP status codes.<EOL> *<EOL> * @returns The Code equivalent to the given GRPC status code. Fails if there<EOL> *     is no match.<EOL> */<EOL>export function mapCodeFromRpcCode(code: number | undefined): Code {<EOL>    if (code === undefined) {<EOL>        <EOL>        <EOL>        log.error('<STR_LIT>');<EOL>        return Code.UNKNOWN;<EOL>    }<EOL>    switch (code) {<EOL>        case RpcCode.OK:<EOL>            return Code.OK;<EOL>        case RpcCode.CANCELLED:<EOL>            return Code.CANCELLED;<EOL>        case RpcCode.UNKNOWN:<EOL>            return Code.UNKNOWN;<EOL>        case RpcCode.DEADLINE_EXCEEDED:<EOL>            return Code.DEADLINE_EXCEEDED;<EOL>        case RpcCode.RESOURCE_EXHAUSTED:<EOL>            return Code.RESOURCE_EXHAUSTED;<EOL>        case RpcCode.INTERNAL:<EOL>            return Code.INTERNAL;<EOL>        case RpcCode.UNAVAILABLE:<EOL>            return Code.UNAVAILABLE;<EOL>        case RpcCode.UNAUTHENTICATED:<EOL>            return Code.UNAUTHENTICATED;<EOL>","gt":"case RpcCode.INVALID_ARGUMENT:"}
{"input":"<s> /**<EOL> * Maps an error Code from GRPC status code number, like 0, 1, or 14. These<EOL> * are not the same as HTTP status codes.<EOL> *<EOL> * @returns The Code equivalent to the given GRPC status code. Fails if there<EOL> *     is no match.<EOL> */<EOL>export function mapCodeFromRpcCode(code: number | undefined): Code {<EOL>    if (code === undefined) {<EOL>        <EOL>        <EOL>        log.error('<STR_LIT>');<EOL>        return Code.UNKNOWN;<EOL>    }<EOL>    switch (code) {<EOL>        case RpcCode.OK:<EOL>            return Code.OK;<EOL>        case RpcCode.CANCELLED:<EOL>            return Code.CANCELLED;<EOL>        case RpcCode.UNKNOWN:<EOL>            return Code.UNKNOWN;<EOL>        case RpcCode.DEADLINE_EXCEEDED:<EOL>            return Code.DEADLINE_EXCEEDED;<EOL>        case RpcCode.RESOURCE_EXHAUSTED:<EOL>            return Code.RESOURCE_EXHAUSTED;<EOL>        case RpcCode.INTERNAL:<EOL>            return Code.INTERNAL;<EOL>        case RpcCode.UNAVAILABLE:<EOL>            return Code.UNAVAILABLE;<EOL>        case RpcCode.UNAUTHENTICATED:<EOL>            return Code.UNAUTHENTICATED;<EOL>        case RpcCode.INVALID_ARGUMENT:<EOL>            return Code.INVALID_ARGUMENT;<EOL>        case RpcCode.NOT_FOUND:<EOL>            return Code.NOT_FOUND;<EOL>        case RpcCode.ALREADY_EXISTS:<EOL>            return Code.ALREADY_EXISTS;<EOL>        case RpcCode.PERMISSION_DENIED:<EOL>            return Code.PERMISSION_DENIED;<EOL>        case RpcCode.FAILED_PRECONDITION:<EOL>            return Code.","gt":"FAILED_PRECONDITION;"}
{"input":"<s> /**<EOL> * Maps an error Code from GRPC status code number, like 0, 1, or 14. These<EOL> * are not the same as HTTP status codes.<EOL> *<EOL> * @returns The Code equivalent to the given GRPC status code. Fails if there<EOL> *     is no match.<EOL> */<EOL>export function mapCodeFromRpcCode(code: number | undefined): Code {<EOL>    if (code === undefined) {<EOL>        <EOL>        <EOL>        log.error('<STR_LIT>');<EOL>        return Code.UNKNOWN;<EOL>    }<EOL>    switch (code) {<EOL>        case RpcCode.OK:<EOL>            return Code.OK;<EOL>        case RpcCode.CANCELLED:<EOL>            return Code.CANCELLED;<EOL>        case RpcCode.UNKNOWN:<EOL>            return Code.UNKNOWN;<EOL>        case RpcCode.DEADLINE_EXCEEDED:<EOL>            return Code.DEADLINE_EXCEEDED;<EOL>        case RpcCode.RESOURCE_EXHAUSTED:<EOL>            return Code.RESOURCE_EXHAUSTED;<EOL>        case RpcCode.INTERNAL:<EOL>            return Code.INTERNAL;<EOL>        case RpcCode.UNAVAILABLE:<EOL>            return Code.UNAVAILABLE;<EOL>        case RpcCode.UNAUTHENTICATED:<EOL>            return Code.UNAUTHENTICATED;<EOL>        case RpcCode.INVALID_ARGUMENT:<EOL>            return Code.INVALID_ARGUMENT;<EOL>        case RpcCode.NOT_FOUND:<EOL>            return Code.NOT_FOUND;<EOL>        case RpcCode.ALREADY_EXISTS:<EOL>            return Code.ALREADY_EXISTS;<EOL>        case RpcCode.PERMISSION_DENIED:<EOL>            return Code.PERMISSION_DENIED;<EOL>        case RpcCode.FAILED_PRECONDITION:<EOL>            return Code.FAILED_PRECONDITION;<EOL>        case RpcCode.ABORTED:<EOL>            return Code.ABORTED;<EOL>        case RpcCode.OUT_OF_RANGE:<EOL>","gt":"return Code.OUT_OF_RANGE;"}
{"input":"<s> export function list<A, B>(c: (a: A) => Component<any>, list: Behavior<A[]>, optional1: any): Component<Behavior<B[]> | Record<string, Behavior<B[]>>> {<EOL>    const last = arguments[arguments.length - <NUM_LIT>];<EOL>    const getKey =","gt":"typeof last === \"<STR_LIT>\" ? last : id;"}
{"input":"<s> export function getDomain(values, scaleType, autoScale, minVal?, maxVal?): number[] {<EOL>    let domain: number[] = [];<EOL>    if (scaleType === '<STR_LIT>') {<EOL>        values = values.map(v => Number(v));<EOL>        if (!autoScale) {<EOL>            values.","gt":"push(<NUM_LIT>);"}
{"input":"<s> export function getDomain(values, scaleType, autoScale, minVal?, maxVal?): number[] {<EOL>    let domain: number[] = [];<EOL>    if (scaleType === '<STR_LIT>') {<EOL>        values = values.map(v => Number(v));<EOL>        if (!autoScale) {<EOL>            values.push(<NUM_LIT>);<EOL>        }<EOL>    }<EOL>    if (scaleType === '<STR_LIT>' || scaleType === '<STR_LIT>') {<EOL>        const","gt":"min = minVal ? minVal : Math.min(...values);"}
{"input":"<s> export function getDomain(values, scaleType, autoScale, minVal?, maxVal?): number[] {<EOL>    let domain: number[] = [];<EOL>    if (scaleType === '<STR_LIT>') {<EOL>        values = values.map(v => Number(v));<EOL>        if (!autoScale) {<EOL>            values.push(<NUM_LIT>);<EOL>        }<EOL>    }<EOL>    if (scaleType === '<STR_LIT>' || scaleType === '<STR_LIT>') {<EOL>        const min = minVal ? minVal : Math.min(...values);<EOL>        const max = maxVal ? maxVal : Math.max(...values);<EOL>        domain = [min, max];<EOL>    }<EOL>","gt":"else {"}
{"input":"<s> /**<EOL> * Resolve the current OAuth request with the given account.<EOL> *<EOL> * Note that this can only be called after `askUserToOAuth` has been called and<EOL> * must only be called once.<EOL> */<EOL>export function resolveOAuthRequest(account: Account) {<EOL>    if (!oauthState) {<EOL>","gt":"fatalError('<STR_LIT>');"}
{"input":"<s> /** Get the hostname to use for the given remote. */<EOL>export function getGenericHostname(remoteURL: string): string {<EOL>    const parsed = parseRemote(remoteURL);<EOL>    if (parsed) {<EOL>        return","gt":"parsed.hostname;"}
{"input":"<s> <EOL>function f1() {<EOL>    let x;<EOL>    if (cond) {<EOL>","gt":"x = <NUM_LIT>;"}
{"input":"<s> <EOL>function f6() {<EOL>    var x = undefined;<EOL>    if (cond) {<EOL>        x =","gt":"<NUM_LIT>;"}
{"input":"<s> function handleClass(desc: ClassDescription | ClassDescription[], elm: HTMLElement): void {<EOL>    if (isBehavior(desc)) {<EOL>        let previousClasses: string[];<EOL>        viewObserve((value) => {<EOL>            if (previousClasses !== undefined) {<EOL>                elm.classList.remove(...","gt":"previousClasses);"}
{"input":"<s> function handleClass(desc: ClassDescription | ClassDescription[], elm: HTMLElement): void {<EOL>    if (isBehavior(desc)) {<EOL>        let previousClasses: string[];<EOL>        viewObserve((value) => {<EOL>            if (previousClasses !== undefined) {<EOL>                elm.classList.remove(...previousClasses);<EOL>            }<EOL>            previousClasses = value.","gt":"split(\"<STR_LIT>\");"}
{"input":"<s> function handleClass(desc: ClassDescription | ClassDescription[], elm: HTMLElement): void {<EOL>    if (isBehavior(desc)) {<EOL>        let previousClasses: string[];<EOL>        viewObserve((value) => {<EOL>            if (previousClasses !== undefined) {<EOL>                elm.classList.remove(...previousClasses);<EOL>            }<EOL>            previousClasses = value.split(\"<STR_LIT>\");<EOL>            elm.classList.add(...previousClasses);<EOL>        }, desc);<EOL>    }<EOL>    else if (Array.isArray(desc)) {<EOL>        for (const","gt":"d of desc) {"}
{"input":"<s> function handleClass(desc: ClassDescription | ClassDescription[], elm: HTMLElement): void {<EOL>    if (isBehavior(desc)) {<EOL>        let previousClasses: string[];<EOL>        viewObserve((value) => {<EOL>            if (previousClasses !== undefined) {<EOL>                elm.classList.remove(...previousClasses);<EOL>            }<EOL>            previousClasses = value.split(\"<STR_LIT>\");<EOL>            elm.classList.add(...previousClasses);<EOL>        }, desc);<EOL>    }<EOL>    else if (Array.isArray(desc)) {<EOL>        for (const d of desc) {<EOL>            handleClass(d, elm);<EOL>        }<EOL>    }<EOL>    else if (typeof desc === \"<STR_LIT>\") {<EOL>        const classes =","gt":"desc.split(\"<STR_LIT>\");"}
{"input":"<s> async function I() {<EOL>    try {<EOL>        const a = await p;<EOL>        return","gt":"a;"}
{"input":"<s> /**<EOL> * 'uniqueItems' function<EOL> *<EOL> * Accepts any number of string value inputs,<EOL> * and returns an array of all input vaues, excluding duplicates.<EOL> *<EOL> * @param {...string} ...items -<EOL> * @return {string[]} -<EOL> */<EOL>export function uniqueItems(...items): string[] {<EOL>    const returnItems = [];<EOL>    for (const item of items) {<EOL>        if (!returnItems.includes(","gt":"item)) {"}
{"input":"<s> /**<EOL> * Returns a promise that resolves after ms.<EOL> */<EOL>export function sleep(ms: number): Promise<void> {<EOL>    return new Promise(resolve =>","gt":"setTimeout(resolve, ms));"}
{"input":"<s> function square(n: number): number {<EOL>    return","gt":"n * n;"}
{"input":"<s> export function list<A>(...elements: A[]): List<A> {<EOL>    let l = empty();<EOL>","gt":"for (const element of elements) {"}
{"input":"<s> function foldrSuffix<A, B>(f: (value: A, acc: B) => B, initial: B, array: A[], length: number): B {<EOL>    let acc = initial;<EOL>    for (let i = length -","gt":"<NUM_LIT>; <NUM_LIT> <= i; --i) {"}
{"input":"<s> function someCb<A>(value: A, state: any): boolean {<EOL>","gt":"return !(state.result = state.predicate(value));"}
{"input":"<s> /**<EOL> * Takes a RRB-tree and a node tail. It then appends the node to the<EOL> * tree.<EOL> * @param l The subject for appending. `l` will be mutated. Nodes in<EOL> * the tree will _not_ be mutated.<EOL> * @param node The node that should be appended to the tree.<EOL> */<EOL>function appendNodeToTree<A>(l: List<A>, node: Node): List<A> {<EOL>    if (l.root === undefined) {<EOL>        <EOL>        if (getPrefixSize(l) ===","gt":"<NUM_LIT>) {"}
{"input":"<s> /**<EOL> * Takes a RRB-tree and a node tail. It then appends the node to the<EOL> * tree.<EOL> * @param l The subject for appending. `l` will be mutated. Nodes in<EOL> * the tree will _not_ be mutated.<EOL> * @param node The node that should be appended to the tree.<EOL> */<EOL>function appendNodeToTree<A>(l: List<A>, node: Node): List<A> {<EOL>    if (l.root === undefined) {<EOL>        <EOL>        if (getPrefixSize(l) === <NUM_LIT>) {<EOL>            l.bits = setPrefix(node.array.length, l.bits);<EOL>            l.prefix = reverseArray(node.array);<EOL>        }<EOL>        else {<EOL>            l.root = node;<EOL>        }<EOL>        return l;<EOL>    }<EOL>    const depth = getDepth(l);<EOL>    let index =","gt":"l.length - <NUM_LIT> - getPrefixSize(l);"}
{"input":"<s> /**<EOL> * Takes a RRB-tree and a node tail. It then appends the node to the<EOL> * tree.<EOL> * @param l The subject for appending. `l` will be mutated. Nodes in<EOL> * the tree will _not_ be mutated.<EOL> * @param node The node that should be appended to the tree.<EOL> */<EOL>function appendNodeToTree<A>(l: List<A>, node: Node): List<A> {<EOL>    if (l.root === undefined) {<EOL>        <EOL>        if (getPrefixSize(l) === <NUM_LIT>) {<EOL>            l.bits = setPrefix(node.array.length, l.bits);<EOL>            l.prefix = reverseArray(node.array);<EOL>        }<EOL>        else {<EOL>            l.root = node;<EOL>        }<EOL>        return l;<EOL>    }<EOL>    const depth = getDepth(l);<EOL>    let index = l.length - <NUM_LIT> - getPrefixSize(l);<EOL>    let","gt":"nodesToCopy = <NUM_LIT>;"}
{"input":"<s> /**<EOL> * Takes a RRB-tree and a node tail. It then appends the node to the<EOL> * tree.<EOL> * @param l The subject for appending. `l` will be mutated. Nodes in<EOL> * the tree will _not_ be mutated.<EOL> * @param node The node that should be appended to the tree.<EOL> */<EOL>function appendNodeToTree<A>(l: List<A>, node: Node): List<A> {<EOL>    if (l.root === undefined) {<EOL>        <EOL>        if (getPrefixSize(l) === <NUM_LIT>) {<EOL>            l.bits = setPrefix(node.array.length, l.bits);<EOL>            l.prefix = reverseArray(node.array);<EOL>        }<EOL>        else {<EOL>            l.root = node;<EOL>        }<EOL>        return l;<EOL>    }<EOL>    const depth = getDepth(l);<EOL>    let index = l.length - <NUM_LIT> - getPrefixSize(l);<EOL>    let nodesToCopy = <NUM_LIT>;<EOL>    let nodesVisited = <NUM_LIT>;<EOL>    let shift = depth * <NUM_LIT>;<EOL>    let currentNode = l.root;<EOL>    if (<NUM_LIT> ** (depth + <NUM_LIT>) < index) {<EOL>        shift = <NUM_LIT>; <EOL>        nodesVisited =","gt":"depth;"}
{"input":"<s> /**<EOL> * Takes a RRB-tree and a node tail. It then appends the node to the<EOL> * tree.<EOL> * @param l The subject for appending. `l` will be mutated. Nodes in<EOL> * the tree will _not_ be mutated.<EOL> * @param node The node that should be appended to the tree.<EOL> */<EOL>function appendNodeToTree<A>(l: List<A>, node: Node): List<A> {<EOL>    if (l.root === undefined) {<EOL>        <EOL>        if (getPrefixSize(l) === <NUM_LIT>) {<EOL>            l.bits = setPrefix(node.array.length, l.bits);<EOL>            l.prefix = reverseArray(node.array);<EOL>        }<EOL>        else {<EOL>            l.root = node;<EOL>        }<EOL>        return l;<EOL>    }<EOL>    const depth = getDepth(l);<EOL>    let index = l.length - <NUM_LIT> - getPrefixSize(l);<EOL>    let nodesToCopy = <NUM_LIT>;<EOL>    let nodesVisited = <NUM_LIT>;<EOL>    let shift = depth * <NUM_LIT>;<EOL>    let currentNode = l.root;<EOL>    if (<NUM_LIT> ** (depth + <NUM_LIT>) < index) {<EOL>        shift = <NUM_LIT>; <EOL>        nodesVisited = depth;<EOL>    }<EOL>    while (shift > <NUM_LIT>) {<EOL>        let childIndex: number;<EOL>        if (currentNode.sizes === undefined) {<EOL>            <EOL>            childIndex = (index >> shift) & mask;<EOL>            index &= ~(mask << shift); <EOL>        }<EOL>        else {<EOL>            childIndex = currentNode.array.length - <NUM_LIT>;<EOL>            index -= currentNode.sizes[childIndex - <NUM_LIT>];<EOL>        }<EOL>        nodesVisited++;<EOL>        if (childIndex < mask) {<EOL>            <EOL>            <EOL>            nodesToCopy = nodesVisited;<EOL>        }<EOL>        currentNode = currentNode.array[childIndex];<EOL>        if (","gt":"currentNode === undefined) {"}
{"input":"<s> /**<EOL> * Takes a RRB-tree and a node tail. It then appends the node to the<EOL> * tree.<EOL> * @param l The subject for appending. `l` will be mutated. Nodes in<EOL> * the tree will _not_ be mutated.<EOL> * @param node The node that should be appended to the tree.<EOL> */<EOL>function appendNodeToTree<A>(l: List<A>, node: Node): List<A> {<EOL>    if (l.root === undefined) {<EOL>        <EOL>        if (getPrefixSize(l) === <NUM_LIT>) {<EOL>            l.bits = setPrefix(node.array.length, l.bits);<EOL>            l.prefix = reverseArray(node.array);<EOL>        }<EOL>        else {<EOL>            l.root = node;<EOL>        }<EOL>        return l;<EOL>    }<EOL>    const depth = getDepth(l);<EOL>    let index = l.length - <NUM_LIT> - getPrefixSize(l);<EOL>    let nodesToCopy = <NUM_LIT>;<EOL>    let nodesVisited = <NUM_LIT>;<EOL>    let shift = depth * <NUM_LIT>;<EOL>    let currentNode = l.root;<EOL>    if (<NUM_LIT> ** (depth + <NUM_LIT>) < index) {<EOL>        shift = <NUM_LIT>; <EOL>        nodesVisited = depth;<EOL>    }<EOL>    while (shift > <NUM_LIT>) {<EOL>        let childIndex: number;<EOL>        if (currentNode.sizes === undefined) {<EOL>            <EOL>            childIndex = (index >> shift) & mask;<EOL>            index &= ~(mask << shift); <EOL>        }<EOL>        else {<EOL>            childIndex = currentNode.array.length - <NUM_LIT>;<EOL>            index -= currentNode.sizes[childIndex - <NUM_LIT>];<EOL>        }<EOL>        nodesVisited++;<EOL>        if (childIndex < mask) {<EOL>            <EOL>            <EOL>            nodesToCopy = nodesVisited;<EOL>        }<EOL>        currentNode = currentNode.array[childIndex];<EOL>        if (currentNode === undefined) {<EOL>            <EOL>            <EOL>            nodesToCopy = nodesVisited;<EOL>            shift = <NUM_LIT>; <EOL>        }<EOL>        shift -= <NUM_LIT>;<EOL>    }<EOL>    if (shift !== <NUM_LIT>) {<EOL>        nodesVisited++;<EOL>        if (currentNode.array.length < branchingFactor) {<EOL>            <EOL>            nodesToCopy = nodesVisited;<EOL>        }<EOL>    }<EOL>    if (nodesToCopy === <NUM_LIT>) {<EOL>        <EOL>        const newPath = nodesVisited === <NUM_LIT> ? node : createPath(nodesVisited, node);<EOL>        const newRoot = new Node(undefined, [l.root, newPath]);<EOL>","gt":"l.root = newRoot;"}
{"input":"<s> export function update<A>(index: number, a: A, l: List<A>): List<A> {<EOL>    const prefixSize = getPrefixSize(l);<EOL>    const suffixSize = getSuffixSize(l);<EOL>    const newList = cloneList(l);<EOL>    if (index < prefixSize) {<EOL>        const newPrefix = copyArray(newList.prefix);<EOL>        newPrefix[newPrefix.length - index -","gt":"<NUM_LIT>] = a;"}
{"input":"<s> export function update<A>(index: number, a: A, l: List<A>): List<A> {<EOL>    const prefixSize = getPrefixSize(l);<EOL>    const suffixSize = getSuffixSize(l);<EOL>    const newList = cloneList(l);<EOL>    if (index < prefixSize) {<EOL>        const newPrefix = copyArray(newList.prefix);<EOL>        newPrefix[newPrefix.length - index - <NUM_LIT>] = a;<EOL>        newList.prefix = newPrefix;<EOL>    }<EOL>    else if (index >= l.length - suffixSize) {<EOL>        const newSuffix = copyArray(newList.","gt":"suffix);"}
{"input":"<s> export function insert<A>(index: number, element: A, l: List<A>): List<A> {<EOL>    return concat(append(","gt":"element, slice(<NUM_LIT>, index, l)), slice(index, l.length, l));"}
{"input":"<s> function asEditorError(error: Error): ExternalEditorError | null {<EOL>    if (error instanceof ExternalEditorError) {<EOL>","gt":"return error;"}
{"input":"<s> /**<EOL> * Retrieve some or all binary contents of a blob from the repository<EOL> * at a given reference, commit, or tree. This is almost identical<EOL> * to the getBlobContents method except that it supports only reading<EOL> * a maximum number of bytes.<EOL> *<EOL> * Returns a promise that will produce a Buffer instance containing<EOL> * the binary contents of the blob or an error if the file doesn't<EOL> * exists in the given revision.<EOL> *<EOL> * @param repository - The repository from where to read the blob<EOL> *<EOL> * @param commitish  - A commit SHA or some other identifier that<EOL> *                     ultimately dereferences to a commit/tree.<EOL> *<EOL> * @param path       - The file path, relative to the repository<EOL> *                     root from where to read the blob contents<EOL> *<EOL> * @param length     - The maximum number of bytes to read from<EOL> *                     the blob. Note that the number of bytes<EOL> *                     returned may always be less than this number.<EOL> */<EOL>export async function getPartialBlobContents(repository: Repository, commitish: string, path: string, length: number): Promise<Buffer> {<EOL>    const successExitCodes = new Set([<NUM_LIT>, <NUM_LIT>]);<EOL>","gt":"const args = ['<STR_LIT>', `<STR_LIT>`];"}
{"input":"<s> function setupTest() {<EOL>    return TestBed.configureTestingModule({<EOL>        declarations: [TestFixtureComponent],<EOL>","gt":"imports: [NgxDatatableModule]"}
{"input":"<s> /**<EOL> * Creates an array of VTTCue/TextTrackCue from a given array of cue objects.<EOL> * @param {Array.<Object>} cuesArray - Objects containing the start, end and<EOL> * text.<EOL> * @returns {Array.<VTTCue>}<EOL> */<EOL>function createCuesFromArray(cuesArray: ISubs[]): Array<TextTrackCue | VTTCue> {<EOL>    const nativeCues: Array<TextTrackCue | VTTCue> = [];<EOL>    for (let i = <NUM_LIT>; i < cuesArray.length; i++) {<EOL>        const { start, end, text } = cuesArray[i];<EOL>        if (text &&","gt":"end != null) {"}
{"input":"<s> function injectable() {<EOL>    return function (target: any) {<EOL>        if (Reflect.hasOwnMetadata(METADATA_KEY.PARAM_TYPES, target)) {<EOL>            throw new Error(","gt":"ERRORS_MSGS.DUPLICATED_INJECTABLE_DECORATOR);"}
{"input":"<s> function getCachedKeySystemAccess(keySystems: IKeySystemOption[], instanceInfos: IInstanceInfo): null | undefined | {<EOL>    keySystem: IKeySystemOption;<EOL>    keySystemAccess: KeySystemAccess;<EOL>} {<EOL>    const { $keySystem, $mediaKeys, $mediaKeySystemConfiguration, } = instanceInfos;<EOL>    <EOL>    <EOL>    if (!$keySystem || !$mediaKeys || shouldRenewMediaKeys()) {<EOL>        return null;<EOL>    }<EOL>    if ($mediaKeySystemConfiguration) {<EOL>        const configuration = $mediaKeySystemConfiguration;<EOL>        const foundKeySystem = keySystems.filter((ks) => {<EOL>            if (ks.type !==","gt":"$keySystem.type) {"}
{"input":"<s> function getCachedKeySystemAccess(keySystems: IKeySystemOption[], instanceInfos: IInstanceInfo): null | undefined | {<EOL>    keySystem: IKeySystemOption;<EOL>    keySystemAccess: KeySystemAccess;<EOL>} {<EOL>    const { $keySystem, $mediaKeys, $mediaKeySystemConfiguration, } = instanceInfos;<EOL>    <EOL>    <EOL>    if (!$keySystem || !$mediaKeys || shouldRenewMediaKeys()) {<EOL>        return null;<EOL>    }<EOL>    if ($mediaKeySystemConfiguration) {<EOL>        const configuration = $mediaKeySystemConfiguration;<EOL>        const foundKeySystem = keySystems.filter((ks) => {<EOL>            if (ks.type !== $keySystem.type) {<EOL>                return false;<EOL>            }<EOL>            if (ks.persistentLicense &&<EOL>","gt":"configuration.persistentState !== \"<STR_LIT>\") {"}
{"input":"<s> function getCachedKeySystemAccess(keySystems: IKeySystemOption[], instanceInfos: IInstanceInfo): null | undefined | {<EOL>    keySystem: IKeySystemOption;<EOL>    keySystemAccess: KeySystemAccess;<EOL>} {<EOL>    const { $keySystem, $mediaKeys, $mediaKeySystemConfiguration, } = instanceInfos;<EOL>    <EOL>    <EOL>    if (!$keySystem || !$mediaKeys || shouldRenewMediaKeys()) {<EOL>        return null;<EOL>    }<EOL>    if ($mediaKeySystemConfiguration) {<EOL>        const configuration = $mediaKeySystemConfiguration;<EOL>        const foundKeySystem = keySystems.filter((ks) => {<EOL>            if (ks.type !== $keySystem.type) {<EOL>                return false;<EOL>            }<EOL>            if (ks.persistentLicense &&<EOL>                configuration.persistentState !== \"<STR_LIT>\") {<EOL>                return false;<EOL>            }<EOL>            if (ks.distinctiveIdentifierRequired &&<EOL>                configuration.","gt":"distinctiveIdentifier !== \"<STR_LIT>\") {"}
{"input":"<s> function getCachedKeySystemAccess(keySystems: IKeySystemOption[], instanceInfos: IInstanceInfo): null | undefined | {<EOL>    keySystem: IKeySystemOption;<EOL>    keySystemAccess: KeySystemAccess;<EOL>} {<EOL>    const { $keySystem, $mediaKeys, $mediaKeySystemConfiguration, } = instanceInfos;<EOL>    <EOL>    <EOL>    if (!$keySystem || !$mediaKeys || shouldRenewMediaKeys()) {<EOL>        return null;<EOL>    }<EOL>    if ($mediaKeySystemConfiguration) {<EOL>        const configuration = $mediaKeySystemConfiguration;<EOL>        const foundKeySystem = keySystems.filter((ks) => {<EOL>            if (ks.type !== $keySystem.type) {<EOL>                return false;<EOL>            }<EOL>            if (ks.persistentLicense &&<EOL>                configuration.persistentState !== \"<STR_LIT>\") {<EOL>                return false;<EOL>            }<EOL>            if (ks.distinctiveIdentifierRequired &&<EOL>                configuration.distinctiveIdentifier !== \"<STR_LIT>\") {<EOL>                return false;<EOL>            }<EOL>            return true;<EOL>        })[<NUM_LIT>];<EOL>        if (foundKeySystem) {<EOL>            return {<EOL>","gt":"keySystem: foundKeySystem,"}
{"input":"<s> export function cloneEnums(node: StatementedNode, cloningEnums: EnumDeclaration[]) {<EOL>    node.addEnums(cloningEnums.map(cloningEnum => ({<EOL>        name: cloningEnum.getName(),<EOL>        isExported:","gt":"true,"}
{"input":"<s> /**<EOL> * Parse whole srt file into an array of cues, to be inserted in a video's<EOL> * TrackElement.<EOL> * @param {string} srtStr<EOL> * @param {Number} timeOffset<EOL> * @returns {Array.<VTTCue|TextTrackCue>}<EOL> */<EOL>export default function parseSRTStringToVTTCues(srtStr: string, timeOffset: number): Array<VTTCue | TextTrackCue> {<EOL>    <EOL>    <EOL>    const lines = srtStr.split(/\\r\\n|\\n|\\r/);<EOL>    const cueBlocks: string[][] = [];<EOL>    for (let i =","gt":"<NUM_LIT>; i < lines.length; i++) {"}
{"input":"<s> /**<EOL> * Parse whole srt file into an array of cues, to be inserted in a video's<EOL> * TrackElement.<EOL> * @param {string} srtStr<EOL> * @param {Number} timeOffset<EOL> * @returns {Array.<VTTCue|TextTrackCue>}<EOL> */<EOL>export default function parseSRTStringToVTTCues(srtStr: string, timeOffset: number): Array<VTTCue | TextTrackCue> {<EOL>    <EOL>    <EOL>    const lines = srtStr.split(/\\r\\n|\\n|\\r/);<EOL>    const cueBlocks: string[][] = [];<EOL>    for (let i = <NUM_LIT>; i < lines.length; i++) {<EOL>        if (lines[i]) {<EOL>            const","gt":"startingI = i;"}
{"input":"<s> /**<EOL> * Parse whole srt file into an array of cues, to be inserted in a video's<EOL> * TrackElement.<EOL> * @param {string} srtStr<EOL> * @param {Number} timeOffset<EOL> * @returns {Array.<VTTCue|TextTrackCue>}<EOL> */<EOL>export default function parseSRTStringToVTTCues(srtStr: string, timeOffset: number): Array<VTTCue | TextTrackCue> {<EOL>    <EOL>    <EOL>    const lines = srtStr.split(/\\r\\n|\\n|\\r/);<EOL>    const cueBlocks: string[][] = [];<EOL>    for (let i = <NUM_LIT>; i < lines.length; i++) {<EOL>        if (lines[i]) {<EOL>            const startingI = i;<EOL>            i++;<EOL>            while (lines[i]) {<EOL>                i++;<EOL>            }<EOL>            cueBlocks.push(","gt":"lines.slice(startingI, i));"}
{"input":"<s> /**<EOL> * Parse whole srt file into an array of cues, to be inserted in a video's<EOL> * TrackElement.<EOL> * @param {string} srtStr<EOL> * @param {Number} timeOffset<EOL> * @returns {Array.<VTTCue|TextTrackCue>}<EOL> */<EOL>export default function parseSRTStringToVTTCues(srtStr: string, timeOffset: number): Array<VTTCue | TextTrackCue> {<EOL>    <EOL>    <EOL>    const lines = srtStr.split(/\\r\\n|\\n|\\r/);<EOL>    const cueBlocks: string[][] = [];<EOL>    for (let i = <NUM_LIT>; i < lines.length; i++) {<EOL>        if (lines[i]) {<EOL>            const startingI = i;<EOL>            i++;<EOL>            while (lines[i]) {<EOL>                i++;<EOL>            }<EOL>            cueBlocks.push(lines.slice(startingI, i));<EOL>        }<EOL>    }<EOL>    const cues: Array<VTTCue | TextTrackCue> = [];<EOL>    for (let i = <NUM_LIT>; i < cueBlocks.length; i++) {<EOL>        const","gt":"cue = parseCue(cueBlocks[i], timeOffset);"}
{"input":"<s> /**<EOL> * Compares the two strings in a case-insensitive manner and returns a value<EOL> * indicating whether one is greater than the other. When the return value is<EOL> * used in a sort operation the comparands will be sorted in ascending order.<EOL> */<EOL>export function caseInsensitiveCompare(x: string, y: string): number {<EOL>    return compare(x.toLowerCase(), y.","gt":"toLocaleLowerCase());"}
{"input":"<s> /** Add a new remote with the given URL. */<EOL>export async function addRemote(repository: Repository, name: string, url: string): Promise<IRemote> {<EOL>    await git(['<STR_LIT>', '<STR_LIT>', name, url],","gt":"repository.path, '<STR_LIT>');"}
{"input":"<s> /** Removes an existing remote, or silently errors if it doesn't exist */<EOL>export async function removeRemote(repository: Repository, name: string): Promise<void> {<EOL>    const options = {<EOL>        successExitCodes: new Set([<NUM_LIT>,","gt":"<NUM_LIT>]),"}
{"input":"<s> function videoSizeChange(): Observable<number> {<EOL>    return","gt":"onEvent(window, \"<STR_LIT>\");"}
{"input":"<s> function parseSortSpecifier(sortSpecifier: SortSpecifier | string): SortSpecifier {<EOL>    if (isObject(sortSpecifier)) {<EOL>        let s = sortSpecifier as SortSpecifier;<EOL>        s.kind = s.kind || '<STR_LIT>';<EOL>        s.order = s.","gt":"order || '<STR_LIT>';"}
{"input":"<s> function parseSortSpecifier(sortSpecifier: SortSpecifier | string): SortSpecifier {<EOL>    if (isObject(sortSpecifier)) {<EOL>        let s = sortSpecifier as SortSpecifier;<EOL>        s.kind = s.kind || '<STR_LIT>';<EOL>        s.order = s.order || '<STR_LIT>';<EOL>        return s;<EOL>    }<EOL>    else if (typeof sortSpecifier === '<STR_LIT>') {<EOL>","gt":"return parseSortSpecifierString(sortSpecifier);"}
{"input":"<s> /**<EOL> * Handle connection endpoint plugin config.<EOL> * The type is typically the protocol e.g. ws<EOL> * Plugins can be passed either as a __path__ property or as a __name__ property with<EOL> * a naming convetion: *{amqp: {name: 'my-plugin'}}* will be resolved to the<EOL> * npm module *deepstream.io-connection-my-plugin*<EOL> * Exception: the name *uws* will be resolved to deepstream.io's internal uWebSockets plugin<EOL> * Options to the constructor of the plugin can be passed as *options* object.<EOL> *<EOL> * CLI arguments will be considered.<EOL> */<EOL>function handleConnectionEndpoints(config: InternalDeepstreamConfig, services: any): Array<ConnectionEndpoint> {<EOL>    <EOL>    for (const type in config.connectionEndpoints) {<EOL>        if (!config.connectionEndpoints[type]) {<EOL>            delete config.connectionEndpoints[type];<EOL>        }<EOL>    }<EOL>    if (!config.connectionEndpoints || Object.keys(config.connectionEndpoints).length === <NUM_LIT>) {<EOL>        throw","gt":"new Error('<STR_LIT>');"}
{"input":"<s> /**<EOL> * Handle connection endpoint plugin config.<EOL> * The type is typically the protocol e.g. ws<EOL> * Plugins can be passed either as a __path__ property or as a __name__ property with<EOL> * a naming convetion: *{amqp: {name: 'my-plugin'}}* will be resolved to the<EOL> * npm module *deepstream.io-connection-my-plugin*<EOL> * Exception: the name *uws* will be resolved to deepstream.io's internal uWebSockets plugin<EOL> * Options to the constructor of the plugin can be passed as *options* object.<EOL> *<EOL> * CLI arguments will be considered.<EOL> */<EOL>function handleConnectionEndpoints(config: InternalDeepstreamConfig, services: any): Array<ConnectionEndpoint> {<EOL>    <EOL>    for (const type in config.connectionEndpoints) {<EOL>        if (!config.connectionEndpoints[type]) {<EOL>            delete config.connectionEndpoints[type];<EOL>        }<EOL>    }<EOL>    if (!config.connectionEndpoints || Object.keys(config.connectionEndpoints).length === <NUM_LIT>) {<EOL>        throw new Error('<STR_LIT>');<EOL>    }<EOL>    const connectionEndpoints: Array<ConnectionEndpoint> = [];<EOL>","gt":"for (const connectionType in config.connectionEndpoints) {"}
{"input":"<s> /**<EOL> * Handle connection endpoint plugin config.<EOL> * The type is typically the protocol e.g. ws<EOL> * Plugins can be passed either as a __path__ property or as a __name__ property with<EOL> * a naming convetion: *{amqp: {name: 'my-plugin'}}* will be resolved to the<EOL> * npm module *deepstream.io-connection-my-plugin*<EOL> * Exception: the name *uws* will be resolved to deepstream.io's internal uWebSockets plugin<EOL> * Options to the constructor of the plugin can be passed as *options* object.<EOL> *<EOL> * CLI arguments will be considered.<EOL> */<EOL>function handleConnectionEndpoints(config: InternalDeepstreamConfig, services: any): Array<ConnectionEndpoint> {<EOL>    <EOL>    for (const type in config.connectionEndpoints) {<EOL>        if (!config.connectionEndpoints[type]) {<EOL>            delete config.connectionEndpoints[type];<EOL>        }<EOL>    }<EOL>    if (!config.connectionEndpoints || Object.keys(config.connectionEndpoints).length === <NUM_LIT>) {<EOL>        throw new Error('<STR_LIT>');<EOL>    }<EOL>    const connectionEndpoints: Array<ConnectionEndpoint> = [];<EOL>    for (const connectionType in config.connectionEndpoints) {<EOL>        const plugin = config.connectionEndpoints[connectionType];<EOL>        plugin.options = plugin.options || {};<EOL>","gt":"let PluginConstructor;"}
{"input":"<s> /**<EOL> * Instantiate the given plugin, which either needs a path property or a name<EOL> * property which fits to the npm module name convention. Options will be passed<EOL> * to the constructor.<EOL> *<EOL> * CLI arguments will be considered.<EOL> */<EOL>function resolvePluginClass(plugin: PluginConfig, type: string): any {<EOL>    if (customPlugins.has(plugin.name)) {<EOL>        return customPlugins.get(plugin.name);<EOL>    }<EOL>    <EOL>    <EOL>    const req = global && global.require ? global.require : require;<EOL>","gt":"let requirePath;"}
{"input":"<s> /**<EOL> * Instantiate the given plugin, which either needs a path property or a name<EOL> * property which fits to the npm module name convention. Options will be passed<EOL> * to the constructor.<EOL> *<EOL> * CLI arguments will be considered.<EOL> */<EOL>function resolvePluginClass(plugin: PluginConfig, type: string): any {<EOL>    if (customPlugins.has(plugin.name)) {<EOL>        return customPlugins.get(plugin.name);<EOL>    }<EOL>    <EOL>    <EOL>    const req = global && global.require ? global.require : require;<EOL>    let requirePath;<EOL>    let pluginConstructor;<EOL>    let es6Adaptor;<EOL>    if (plugin.path != null) {<EOL>","gt":"requirePath = fileUtils.lookupLibRequirePath(plugin.path);"}
{"input":"<s> /**<EOL> * Instantiate the given plugin, which either needs a path property or a name<EOL> * property which fits to the npm module name convention. Options will be passed<EOL> * to the constructor.<EOL> *<EOL> * CLI arguments will be considered.<EOL> */<EOL>function resolvePluginClass(plugin: PluginConfig, type: string): any {<EOL>    if (customPlugins.has(plugin.name)) {<EOL>        return customPlugins.get(plugin.name);<EOL>    }<EOL>    <EOL>    <EOL>    const req = global && global.require ? global.require : require;<EOL>    let requirePath;<EOL>    let pluginConstructor;<EOL>    let es6Adaptor;<EOL>    if (plugin.path != null) {<EOL>        requirePath = fileUtils.lookupLibRequirePath(plugin.path);<EOL>        es6Adaptor = req(requirePath);<EOL>        pluginConstructor = es6Adaptor.default ? es6Adaptor.default : es6Adaptor;<EOL>    }<EOL>    else if (","gt":"plugin.name != null && type) {"}
{"input":"<s> /**<EOL> * Instantiate the given plugin, which either needs a path property or a name<EOL> * property which fits to the npm module name convention. Options will be passed<EOL> * to the constructor.<EOL> *<EOL> * CLI arguments will be considered.<EOL> */<EOL>function resolvePluginClass(plugin: PluginConfig, type: string): any {<EOL>    if (customPlugins.has(plugin.name)) {<EOL>        return customPlugins.get(plugin.name);<EOL>    }<EOL>    <EOL>    <EOL>    const req = global && global.require ? global.require : require;<EOL>    let requirePath;<EOL>    let pluginConstructor;<EOL>    let es6Adaptor;<EOL>    if (plugin.path != null) {<EOL>        requirePath = fileUtils.lookupLibRequirePath(plugin.path);<EOL>        es6Adaptor = req(requirePath);<EOL>        pluginConstructor = es6Adaptor.default ? es6Adaptor.default : es6Adaptor;<EOL>    }<EOL>    else if (plugin.name != null && type) {<EOL>        requirePath = `<STR_LIT>`;<EOL>        requirePath = fileUtils.lookupLibRequirePath(requirePath);<EOL>        es6Adaptor = req(requirePath);<EOL>        pluginConstructor = es6Adaptor.default ? es6Adaptor.","gt":"default : es6Adaptor;"}
{"input":"<s> /**<EOL> * Instantiate the given plugin, which either needs a path property or a name<EOL> * property which fits to the npm module name convention. Options will be passed<EOL> * to the constructor.<EOL> *<EOL> * CLI arguments will be considered.<EOL> */<EOL>function resolvePluginClass(plugin: PluginConfig, type: string): any {<EOL>    if (customPlugins.has(plugin.name)) {<EOL>        return customPlugins.get(plugin.name);<EOL>    }<EOL>    <EOL>    <EOL>    const req = global && global.require ? global.require : require;<EOL>    let requirePath;<EOL>    let pluginConstructor;<EOL>    let es6Adaptor;<EOL>    if (plugin.path != null) {<EOL>        requirePath = fileUtils.lookupLibRequirePath(plugin.path);<EOL>        es6Adaptor = req(requirePath);<EOL>        pluginConstructor = es6Adaptor.default ? es6Adaptor.default : es6Adaptor;<EOL>    }<EOL>    else if (plugin.name != null && type) {<EOL>        requirePath = `<STR_LIT>`;<EOL>        requirePath = fileUtils.lookupLibRequirePath(requirePath);<EOL>        es6Adaptor = req(requirePath);<EOL>        pluginConstructor = es6Adaptor.default ? es6Adaptor.default : es6Adaptor;<EOL>    }<EOL>    else if (plugin.name != null) {<EOL>        requirePath = fileUtils.lookupLibRequirePath(plugin.name);<EOL>        es6Adaptor = req(requirePath);<EOL>        pluginConstructor = es6Adaptor.default ? es6Adaptor.default : es6Adaptor;<EOL>    }<EOL>    else if (plugin.type === '<STR_LIT>' && type === '<STR_LIT>') {<EOL>","gt":"pluginConstructor = DefaultCache;"}
{"input":"<s> function getIndexStatus(status: string) {<EOL>    switch (status[<NUM_LIT>]) {<EOL>        case '<STR_LIT>':<EOL>            return IndexStatus.Added;<EOL>        case","gt":"'<STR_LIT>':"}
{"input":"<s> function getIndexStatus(status: string) {<EOL>    switch (status[<NUM_LIT>]) {<EOL>        case '<STR_LIT>':<EOL>            return IndexStatus.Added;<EOL>        case '<STR_LIT>':<EOL>            return IndexStatus.Copied;<EOL>        case '<STR_LIT>':<EOL>            return","gt":"IndexStatus.Deleted;"}
{"input":"<s> function getIndexStatus(status: string) {<EOL>    switch (status[<NUM_LIT>]) {<EOL>        case '<STR_LIT>':<EOL>            return IndexStatus.Added;<EOL>        case '<STR_LIT>':<EOL>            return IndexStatus.Copied;<EOL>        case '<STR_LIT>':<EOL>            return IndexStatus.Deleted;<EOL>        case '<STR_LIT>':<EOL>            return IndexStatus.Modified;<EOL>        case '<STR_LIT>':<EOL>","gt":"return IndexStatus.Renamed;"}
{"input":"<s> function getIndexStatus(status: string) {<EOL>    switch (status[<NUM_LIT>]) {<EOL>        case '<STR_LIT>':<EOL>            return IndexStatus.Added;<EOL>        case '<STR_LIT>':<EOL>            return IndexStatus.Copied;<EOL>        case '<STR_LIT>':<EOL>            return IndexStatus.Deleted;<EOL>        case '<STR_LIT>':<EOL>            return IndexStatus.Modified;<EOL>        case '<STR_LIT>':<EOL>            return IndexStatus.Renamed;<EOL>        case '<STR_LIT>':<EOL>            return IndexStatus.TypeChanged;<EOL>        case '<STR_LIT>':<EOL>            return IndexStatus.Unmerged;<EOL>","gt":"case '<STR_LIT>':"}
{"input":"<s> function storageCompatability(storage: StoragePlugin) {<EOL>    const oldGet = storage.get as Function;<EOL>    storage.get = (recordName: string, callback: StorageReadCallback) => {<EOL>        oldGet.call(storage, recordName, (error, record) => {<EOL>            callback(error,","gt":"record ? record._v : -<NUM_LIT>, record ? record._d : {});"}
{"input":"<s> function storageCompatability(storage: StoragePlugin) {<EOL>    const oldGet = storage.get as Function;<EOL>    storage.get = (recordName: string, callback: StorageReadCallback) => {<EOL>        oldGet.call(storage, recordName, (error, record) => {<EOL>            callback(error, record ? record._v : -<NUM_LIT>, record ? record._d : {});<EOL>        });<EOL>    };<EOL>    const oldSet = storage.set as Function;<EOL>","gt":"storage.set = (recordName: string, version: number, data: any, callback: StorageWriteCallback) => {"}
{"input":"<s> /**<EOL> * Returns the rules defined for the P element.<EOL> * Empty string if not found.<EOL> * @param {string} str - The entire styling part.<EOL> * @returns {string}<EOL> */<EOL>function getPCSSRules(str: string): string {<EOL>    const pRuleRegex = /p\\s*{([^}]*)}/gi;<EOL>","gt":"const rule = pRuleRegex.exec(str);"}
{"input":"<s> function toWallClockTime(position: number, manifest: Manifest): Date {<EOL>    return","gt":"new Date((position + (manifest.availabilityStartTime || <NUM_LIT>)) * <NUM_LIT>);"}
{"input":"<s> /**<EOL> * Specific exponential backoff algorithm used for segments/manifest<EOL> * downloading.<EOL> *<EOL> * The specificty here in comparaison to a \"regular\" backoff algorithm is<EOL> * the separation between type of errors:<EOL> *   - \"offline\" errors<EOL> *   - other xhr errors<EOL> * Both have their own counters which are resetted if the error type changes.<EOL> * @param {Observable}<EOL> * @param {Object} options<EOL> * @param {Number} options.baseDelay - First delay set when and if:<EOL> *   - the first observable throws<EOL> *   - any observable throws an error which has a type different than the last<EOL> *     one.<EOL> * @param {Number} options.maxDelay - Maximum delay considered for the backoff.<EOL> * Note that this delay is not exact as it will be \"fuzzed\".<EOL> * @param {Number} options.maxRetryRegular - Maximum number of retry for<EOL> * \"regular\" errors. That is, errors that are most likely due to the CDN.<EOL> * @param {Number} options.maxRetryOffline - Maximum number of retry for<EOL> * \"offline\" errors. That is, errors that are most likely due to the user being<EOL> * offline.<EOL> * @param {Function} [options.onRetry] - callback to call as an observable<EOL> * throws. Will be called with two arguments:<EOL> *   - The error thrown by the observable.<EOL> *   - The counter for the current error type.<EOL> * @returns {Observable}<EOL> */<EOL>function downloadingBackoff<T>(obs$: Observable<T>, options: IDownloadingBackoffOptions): Observable<T> {<EOL>    const { baseDelay, maxDelay, maxRetryRegular, maxRetryOffline, onRetry, } = options;<EOL>    let retryCount = <NUM_LIT>;<EOL>    const","gt":"ERROR_TYPES = {"}
{"input":"<s> /**<EOL> * Specific exponential backoff algorithm used for segments/manifest<EOL> * downloading.<EOL> *<EOL> * The specificty here in comparaison to a \"regular\" backoff algorithm is<EOL> * the separation between type of errors:<EOL> *   - \"offline\" errors<EOL> *   - other xhr errors<EOL> * Both have their own counters which are resetted if the error type changes.<EOL> * @param {Observable}<EOL> * @param {Object} options<EOL> * @param {Number} options.baseDelay - First delay set when and if:<EOL> *   - the first observable throws<EOL> *   - any observable throws an error which has a type different than the last<EOL> *     one.<EOL> * @param {Number} options.maxDelay - Maximum delay considered for the backoff.<EOL> * Note that this delay is not exact as it will be \"fuzzed\".<EOL> * @param {Number} options.maxRetryRegular - Maximum number of retry for<EOL> * \"regular\" errors. That is, errors that are most likely due to the CDN.<EOL> * @param {Number} options.maxRetryOffline - Maximum number of retry for<EOL> * \"offline\" errors. That is, errors that are most likely due to the user being<EOL> * offline.<EOL> * @param {Function} [options.onRetry] - callback to call as an observable<EOL> * throws. Will be called with two arguments:<EOL> *   - The error thrown by the observable.<EOL> *   - The counter for the current error type.<EOL> * @returns {Observable}<EOL> */<EOL>function downloadingBackoff<T>(obs$: Observable<T>, options: IDownloadingBackoffOptions): Observable<T> {<EOL>    const { baseDelay, maxDelay, maxRetryRegular, maxRetryOffline, onRetry, } = options;<EOL>    let retryCount = <NUM_LIT>;<EOL>    const ERROR_TYPES = {<EOL>        NONE: <NUM_LIT>,<EOL>        REGULAR: <NUM_LIT>,<EOL>","gt":"OFFLINE: <NUM_LIT>,"}
{"input":"<s> /**<EOL> * Specific exponential backoff algorithm used for segments/manifest<EOL> * downloading.<EOL> *<EOL> * The specificty here in comparaison to a \"regular\" backoff algorithm is<EOL> * the separation between type of errors:<EOL> *   - \"offline\" errors<EOL> *   - other xhr errors<EOL> * Both have their own counters which are resetted if the error type changes.<EOL> * @param {Observable}<EOL> * @param {Object} options<EOL> * @param {Number} options.baseDelay - First delay set when and if:<EOL> *   - the first observable throws<EOL> *   - any observable throws an error which has a type different than the last<EOL> *     one.<EOL> * @param {Number} options.maxDelay - Maximum delay considered for the backoff.<EOL> * Note that this delay is not exact as it will be \"fuzzed\".<EOL> * @param {Number} options.maxRetryRegular - Maximum number of retry for<EOL> * \"regular\" errors. That is, errors that are most likely due to the CDN.<EOL> * @param {Number} options.maxRetryOffline - Maximum number of retry for<EOL> * \"offline\" errors. That is, errors that are most likely due to the user being<EOL> * offline.<EOL> * @param {Function} [options.onRetry] - callback to call as an observable<EOL> * throws. Will be called with two arguments:<EOL> *   - The error thrown by the observable.<EOL> *   - The counter for the current error type.<EOL> * @returns {Observable}<EOL> */<EOL>function downloadingBackoff<T>(obs$: Observable<T>, options: IDownloadingBackoffOptions): Observable<T> {<EOL>    const { baseDelay, maxDelay, maxRetryRegular, maxRetryOffline, onRetry, } = options;<EOL>    let retryCount = <NUM_LIT>;<EOL>    const ERROR_TYPES = {<EOL>        NONE: <NUM_LIT>,<EOL>        REGULAR: <NUM_LIT>,<EOL>        OFFLINE: <NUM_LIT>,<EOL>    };<EOL>    let lastError = ERROR_TYPES.NONE;<EOL>    return obs$.catch((error: Error, source) => {<EOL>","gt":"if (!shouldRetry(error)) {"}
{"input":"<s> /**<EOL> * Specific exponential backoff algorithm used for segments/manifest<EOL> * downloading.<EOL> *<EOL> * The specificty here in comparaison to a \"regular\" backoff algorithm is<EOL> * the separation between type of errors:<EOL> *   - \"offline\" errors<EOL> *   - other xhr errors<EOL> * Both have their own counters which are resetted if the error type changes.<EOL> * @param {Observable}<EOL> * @param {Object} options<EOL> * @param {Number} options.baseDelay - First delay set when and if:<EOL> *   - the first observable throws<EOL> *   - any observable throws an error which has a type different than the last<EOL> *     one.<EOL> * @param {Number} options.maxDelay - Maximum delay considered for the backoff.<EOL> * Note that this delay is not exact as it will be \"fuzzed\".<EOL> * @param {Number} options.maxRetryRegular - Maximum number of retry for<EOL> * \"regular\" errors. That is, errors that are most likely due to the CDN.<EOL> * @param {Number} options.maxRetryOffline - Maximum number of retry for<EOL> * \"offline\" errors. That is, errors that are most likely due to the user being<EOL> * offline.<EOL> * @param {Function} [options.onRetry] - callback to call as an observable<EOL> * throws. Will be called with two arguments:<EOL> *   - The error thrown by the observable.<EOL> *   - The counter for the current error type.<EOL> * @returns {Observable}<EOL> */<EOL>function downloadingBackoff<T>(obs$: Observable<T>, options: IDownloadingBackoffOptions): Observable<T> {<EOL>    const { baseDelay, maxDelay, maxRetryRegular, maxRetryOffline, onRetry, } = options;<EOL>    let retryCount = <NUM_LIT>;<EOL>    const ERROR_TYPES = {<EOL>        NONE: <NUM_LIT>,<EOL>        REGULAR: <NUM_LIT>,<EOL>        OFFLINE: <NUM_LIT>,<EOL>    };<EOL>    let lastError = ERROR_TYPES.NONE;<EOL>    return obs$.catch((error: Error, source) => {<EOL>        if (!shouldRetry(error)) {<EOL>            throw error;<EOL>        }<EOL>        const currentError = error instanceof","gt":"RequestError &&"}
{"input":"<s> /**<EOL> * Specific exponential backoff algorithm used for segments/manifest<EOL> * downloading.<EOL> *<EOL> * The specificty here in comparaison to a \"regular\" backoff algorithm is<EOL> * the separation between type of errors:<EOL> *   - \"offline\" errors<EOL> *   - other xhr errors<EOL> * Both have their own counters which are resetted if the error type changes.<EOL> * @param {Observable}<EOL> * @param {Object} options<EOL> * @param {Number} options.baseDelay - First delay set when and if:<EOL> *   - the first observable throws<EOL> *   - any observable throws an error which has a type different than the last<EOL> *     one.<EOL> * @param {Number} options.maxDelay - Maximum delay considered for the backoff.<EOL> * Note that this delay is not exact as it will be \"fuzzed\".<EOL> * @param {Number} options.maxRetryRegular - Maximum number of retry for<EOL> * \"regular\" errors. That is, errors that are most likely due to the CDN.<EOL> * @param {Number} options.maxRetryOffline - Maximum number of retry for<EOL> * \"offline\" errors. That is, errors that are most likely due to the user being<EOL> * offline.<EOL> * @param {Function} [options.onRetry] - callback to call as an observable<EOL> * throws. Will be called with two arguments:<EOL> *   - The error thrown by the observable.<EOL> *   - The counter for the current error type.<EOL> * @returns {Observable}<EOL> */<EOL>function downloadingBackoff<T>(obs$: Observable<T>, options: IDownloadingBackoffOptions): Observable<T> {<EOL>    const { baseDelay, maxDelay, maxRetryRegular, maxRetryOffline, onRetry, } = options;<EOL>    let retryCount = <NUM_LIT>;<EOL>    const ERROR_TYPES = {<EOL>        NONE: <NUM_LIT>,<EOL>        REGULAR: <NUM_LIT>,<EOL>        OFFLINE: <NUM_LIT>,<EOL>    };<EOL>    let lastError = ERROR_TYPES.NONE;<EOL>    return obs$.catch((error: Error, source) => {<EOL>        if (!shouldRetry(error)) {<EOL>            throw error;<EOL>        }<EOL>        const currentError = error instanceof RequestError &&<EOL>            isOfflineRequestError(error) ? ERROR_TYPES.OFFLINE : ERROR_TYPES.REGULAR;<EOL>        const maxRetry = currentError === ERROR_TYPES.OFFLINE ?<EOL>            maxRetryOffline : maxRetryRegular;<EOL>        if (currentError !==","gt":"lastError) {"}
{"input":"<s> /**<EOL> * Specific exponential backoff algorithm used for segments/manifest<EOL> * downloading.<EOL> *<EOL> * The specificty here in comparaison to a \"regular\" backoff algorithm is<EOL> * the separation between type of errors:<EOL> *   - \"offline\" errors<EOL> *   - other xhr errors<EOL> * Both have their own counters which are resetted if the error type changes.<EOL> * @param {Observable}<EOL> * @param {Object} options<EOL> * @param {Number} options.baseDelay - First delay set when and if:<EOL> *   - the first observable throws<EOL> *   - any observable throws an error which has a type different than the last<EOL> *     one.<EOL> * @param {Number} options.maxDelay - Maximum delay considered for the backoff.<EOL> * Note that this delay is not exact as it will be \"fuzzed\".<EOL> * @param {Number} options.maxRetryRegular - Maximum number of retry for<EOL> * \"regular\" errors. That is, errors that are most likely due to the CDN.<EOL> * @param {Number} options.maxRetryOffline - Maximum number of retry for<EOL> * \"offline\" errors. That is, errors that are most likely due to the user being<EOL> * offline.<EOL> * @param {Function} [options.onRetry] - callback to call as an observable<EOL> * throws. Will be called with two arguments:<EOL> *   - The error thrown by the observable.<EOL> *   - The counter for the current error type.<EOL> * @returns {Observable}<EOL> */<EOL>function downloadingBackoff<T>(obs$: Observable<T>, options: IDownloadingBackoffOptions): Observable<T> {<EOL>    const { baseDelay, maxDelay, maxRetryRegular, maxRetryOffline, onRetry, } = options;<EOL>    let retryCount = <NUM_LIT>;<EOL>    const ERROR_TYPES = {<EOL>        NONE: <NUM_LIT>,<EOL>        REGULAR: <NUM_LIT>,<EOL>        OFFLINE: <NUM_LIT>,<EOL>    };<EOL>    let lastError = ERROR_TYPES.NONE;<EOL>    return obs$.catch((error: Error, source) => {<EOL>        if (!shouldRetry(error)) {<EOL>            throw error;<EOL>        }<EOL>        const currentError = error instanceof RequestError &&<EOL>            isOfflineRequestError(error) ? ERROR_TYPES.OFFLINE : ERROR_TYPES.REGULAR;<EOL>        const maxRetry = currentError === ERROR_TYPES.OFFLINE ?<EOL>            maxRetryOffline : maxRetryRegular;<EOL>        if (currentError !== lastError) {<EOL>            retryCount = <NUM_LIT>;<EOL>            lastError = currentError;<EOL>        }<EOL>        if (++retryCount > maxRetry) {<EOL>            throw error;<EOL>        }<EOL>","gt":"if (onRetry) {"}
{"input":"<s> /** Install LFS hooks in the repository. */<EOL>export async function installLFSHooks(repository: Repository, force: boolean): Promise<void> {<EOL>    const args = ['<STR_LIT>', '<STR_LIT>'];<EOL>    if (","gt":"force) {"}
{"input":"<s> /**<EOL> * Get the URL for the HTML site. For example:<EOL> *<EOL> * https://api.github.com -> https://github.com<EOL> * http://github.mycompany.com/api -> http://github.mycompany.com/<EOL> */<EOL>export function getHTMLURL(endpoint: string): string {<EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>","gt":"if (endpoint === getDotComAPIEndpoint()) {"}
{"input":"<s> /**<EOL> * Get the URL for the HTML site. For example:<EOL> *<EOL> * https://api.github.com -> https://github.com<EOL> * http://github.mycompany.com/api -> http://github.mycompany.com/<EOL> */<EOL>export function getHTMLURL(endpoint: string): string {<EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    if (endpoint === getDotComAPIEndpoint()) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>","gt":"else {"}
{"input":"<s> /**<EOL> * @param {Object} cuesInfos<EOL> * @param {Number} start<EOL> * @param {Number} end<EOL> * @returns {Array.<Object>}<EOL> */<EOL>function removeCuesInfosBetween(cuesInfos: ICuesGroup, start: number, end: number): [<EOL>    ICuesGroup,<EOL>    ICuesGroup<EOL>] {<EOL>    const cuesInfos1 = {<EOL>        start: cuesInfos.start,<EOL>        end: start,<EOL>        cues: getCuesBefore(cuesInfos.","gt":"cues, start),"}
{"input":"<s> /**<EOL> * @param {Object} cuesInfos<EOL> * @param {Number} start<EOL> * @param {Number} end<EOL> * @returns {Array.<Object>}<EOL> */<EOL>function removeCuesInfosBetween(cuesInfos: ICuesGroup, start: number, end: number): [<EOL>    ICuesGroup,<EOL>    ICuesGroup<EOL>] {<EOL>    const cuesInfos1 = {<EOL>        start: cuesInfos.start,<EOL>        end: start,<EOL>        cues: getCuesBefore(cuesInfos.cues, start),<EOL>    };<EOL>    const cuesInfos2 = {<EOL>        start: end,<EOL>        end: cuesInfos.end,<EOL>","gt":"cues: getCuesAfter(cuesInfos.cues, end),"}
{"input":"<s> export function getTextForError(newText: string, pos: number, length = <NUM_LIT>) {<EOL>    const startPos = Math.max(<NUM_LIT>, newText.lastIndexOf(\"<STR_LIT>\", pos) - <NUM_LIT>);<EOL>    let endPos = Math.min(newText.length, newText.indexOf(\"<STR_LIT>\", pos + length));<EOL>    endPos = endPos === -<NUM_LIT> ? newText.length : Math.min(newText.length, endPos + <NUM_LIT>);<EOL>    let text =","gt":"\"<STR_LIT>\";"}
{"input":"<s> export function getTextForError(newText: string, pos: number, length = <NUM_LIT>) {<EOL>    const startPos = Math.max(<NUM_LIT>, newText.lastIndexOf(\"<STR_LIT>\", pos) - <NUM_LIT>);<EOL>    let endPos = Math.min(newText.length, newText.indexOf(\"<STR_LIT>\", pos + length));<EOL>    endPos = endPos === -<NUM_LIT> ? newText.length : Math.min(newText.length, endPos + <NUM_LIT>);<EOL>    let text = \"<STR_LIT>\";<EOL>    text += newText.substring(startPos, endPos);<EOL>    if (startPos !== <NUM_LIT>)<EOL>        text = \"<STR_LIT>\" + text;<EOL>    if (endPos !==","gt":"newText.length)"}
{"input":"<s> /**<EOL> * Re-fetch the manifest and merge it with the previous version.<EOL> *<EOL> * /!\\ Mutates the given manifest<EOL> * @param {Object} manifest<EOL> * @returns {Observable}<EOL> */<EOL>function refreshManifest(manifestPipeline: (url: string) => Observable<Manifest>, currentManifest: Manifest): Observable<IManifestUpdateEvent> {<EOL>    const refreshURL = currentManifest.getUrl();<EOL>    if (!refreshURL) {<EOL>        log.warn(\"<STR_LIT>\");<EOL>        return","gt":"Observable.empty();"}
{"input":"<s> /**<EOL> * Render the diff for a file within the repository working directory. The file will be<EOL> * compared against HEAD if it's tracked, if not it'll be compared to an empty file meaning<EOL> * that all content in the file will be treated as additions.<EOL> */<EOL>export async function getWorkingDirectoryDiff(sketchPath: string, repository: Repository, kactusFiles: Array<IKactusFile>, file: WorkingDirectoryFileChange, previousCommitish?: string): Promise<IDiff> {<EOL>    let successExitCodes: Set<number> | undefined;<EOL>    let args: Array<string>;<EOL>    <EOL>    <EOL>    if (file.status === AppFileStatus.New) {<EOL>        <EOL>        <EOL>        <EOL>        <EOL>        <EOL>        <EOL>        <EOL>        <EOL>        <EOL>        <EOL>        successExitCodes = new Set([<NUM_LIT>, <NUM_LIT>]);<EOL>        args = [<EOL>            '<STR_LIT>',<EOL>            '<STR_LIT>',<EOL>            '<STR_LIT>',<EOL>            '<STR_LIT>',<EOL>","gt":"'<STR_LIT>',"}
{"input":"<s> /**<EOL> * Render the diff for a file within the repository working directory. The file will be<EOL> * compared against HEAD if it's tracked, if not it'll be compared to an empty file meaning<EOL> * that all content in the file will be treated as additions.<EOL> */<EOL>export async function getWorkingDirectoryDiff(sketchPath: string, repository: Repository, kactusFiles: Array<IKactusFile>, file: WorkingDirectoryFileChange, previousCommitish?: string): Promise<IDiff> {<EOL>    let successExitCodes: Set<number> | undefined;<EOL>    let args: Array<string>;<EOL>    <EOL>    <EOL>    if (file.status === AppFileStatus.New) {<EOL>        <EOL>        <EOL>        <EOL>        <EOL>        <EOL>        <EOL>        <EOL>        <EOL>        <EOL>        <EOL>        successExitCodes = new Set([<NUM_LIT>, <NUM_LIT>]);<EOL>        args = [<EOL>            '<STR_LIT>',<EOL>            '<STR_LIT>',<EOL>            '<STR_LIT>',<EOL>            '<STR_LIT>',<EOL>            '<STR_LIT>',<EOL>            '<STR_LIT>',<EOL>            '<STR_LIT>',<EOL>            '<STR_LIT>',<EOL>            file.path,<EOL>        ];<EOL>    }<EOL>    else if (file.status === AppFileStatus.Renamed) {<EOL>        <EOL>        <EOL>        <EOL>        <EOL>        <EOL>        <EOL>        <EOL>        args = [<EOL>            '<STR_LIT>',<EOL>","gt":"'<STR_LIT>',"}
{"input":"<s> /**<EOL> * Render the diff for a file within the repository working directory. The file will be<EOL> * compared against HEAD if it's tracked, if not it'll be compared to an empty file meaning<EOL> * that all content in the file will be treated as additions.<EOL> */<EOL>export async function getWorkingDirectoryDiff(sketchPath: string, repository: Repository, kactusFiles: Array<IKactusFile>, file: WorkingDirectoryFileChange, previousCommitish?: string): Promise<IDiff> {<EOL>    let successExitCodes: Set<number> | undefined;<EOL>    let args: Array<string>;<EOL>    <EOL>    <EOL>    if (file.status === AppFileStatus.New) {<EOL>        <EOL>        <EOL>        <EOL>        <EOL>        <EOL>        <EOL>        <EOL>        <EOL>        <EOL>        <EOL>        successExitCodes = new Set([<NUM_LIT>, <NUM_LIT>]);<EOL>        args = [<EOL>            '<STR_LIT>',<EOL>            '<STR_LIT>',<EOL>            '<STR_LIT>',<EOL>            '<STR_LIT>',<EOL>            '<STR_LIT>',<EOL>            '<STR_LIT>',<EOL>            '<STR_LIT>',<EOL>            '<STR_LIT>',<EOL>            file.path,<EOL>        ];<EOL>    }<EOL>    else if (file.status === AppFileStatus.Renamed) {<EOL>        <EOL>        <EOL>        <EOL>        <EOL>        <EOL>        <EOL>        <EOL>        args = [<EOL>            '<STR_LIT>',<EOL>            '<STR_LIT>',<EOL>            '<STR_LIT>',<EOL>            '<STR_LIT>',<EOL>","gt":"'<STR_LIT>',"}
{"input":"<s> /**<EOL> * Render the diff for a file within the repository working directory. The file will be<EOL> * compared against HEAD if it's tracked, if not it'll be compared to an empty file meaning<EOL> * that all content in the file will be treated as additions.<EOL> */<EOL>export async function getWorkingDirectoryDiff(sketchPath: string, repository: Repository, kactusFiles: Array<IKactusFile>, file: WorkingDirectoryFileChange, previousCommitish?: string): Promise<IDiff> {<EOL>    let successExitCodes: Set<number> | undefined;<EOL>    let args: Array<string>;<EOL>    <EOL>    <EOL>    if (file.status === AppFileStatus.New) {<EOL>        <EOL>        <EOL>        <EOL>        <EOL>        <EOL>        <EOL>        <EOL>        <EOL>        <EOL>        <EOL>        successExitCodes = new Set([<NUM_LIT>, <NUM_LIT>]);<EOL>        args = [<EOL>            '<STR_LIT>',<EOL>            '<STR_LIT>',<EOL>            '<STR_LIT>',<EOL>            '<STR_LIT>',<EOL>            '<STR_LIT>',<EOL>            '<STR_LIT>',<EOL>            '<STR_LIT>',<EOL>            '<STR_LIT>',<EOL>            file.path,<EOL>        ];<EOL>    }<EOL>    else if (file.status === AppFileStatus.Renamed) {<EOL>        <EOL>        <EOL>        <EOL>        <EOL>        <EOL>        <EOL>        <EOL>        args = [<EOL>            '<STR_LIT>',<EOL>            '<STR_LIT>',<EOL>            '<STR_LIT>',<EOL>            '<STR_LIT>',<EOL>            '<STR_LIT>',<EOL>            '<STR_LIT>',<EOL>            file.path,<EOL>        ];<EOL>    }<EOL>    else {<EOL>        args = [<EOL>            '<STR_LIT>',<EOL>            '<STR_LIT>',<EOL>            '<STR_LIT>',<EOL>            '<STR_LIT>',<EOL>            '<STR_LIT>',<EOL>            '<STR_LIT>',<EOL>            '<STR_LIT>',<EOL>            file.path,<EOL>        ];<EOL>    }<EOL>    const {","gt":"output, error } = await spawnAndComplete(args, repository.path, '<STR_LIT>', successExitCodes);"}
{"input":"<s> export function getClausedNodeChildFormatting(parent: Node, member: Node) {<EOL>    return FormattingKind.","gt":"Newline;"}
{"input":"<s> function getExpression(text: string) {<EOL>    return getInfoFromTextWithDescendant<TaggedTemplateExpression>(","gt":"text, SyntaxKind.TaggedTemplateExpression).descendant;"}
{"input":"<s> export async function createCommit(repository: Repository, kactusFiles: Array<IKactusFile>, message: string, files: ReadonlyArray<WorkingDirectoryFileChange>): Promise<boolean> {<EOL>    <EOL>    <EOL>    <EOL>    await unstageAll(repository);<EOL>    await stageFiles(repository, kactusFiles, files);<EOL>","gt":"try {"}
{"input":"<s> export async function createCommit(repository: Repository, kactusFiles: Array<IKactusFile>, message: string, files: ReadonlyArray<WorkingDirectoryFileChange>): Promise<boolean> {<EOL>    <EOL>    <EOL>    <EOL>    await unstageAll(repository);<EOL>    await stageFiles(repository, kactusFiles, files);<EOL>    try {<EOL>        await git(['<STR_LIT>', '<STR_LIT>', '<STR_LIT>'], repository.path, '<STR_LIT>', {<EOL>            stdin: message,<EOL>        });<EOL>        return true;<EOL>    }<EOL>","gt":"catch (e) {"}
{"input":"<s> export async function createCommit(repository: Repository, kactusFiles: Array<IKactusFile>, message: string, files: ReadonlyArray<WorkingDirectoryFileChange>): Promise<boolean> {<EOL>    <EOL>    <EOL>    <EOL>    await unstageAll(repository);<EOL>    await stageFiles(repository, kactusFiles, files);<EOL>    try {<EOL>        await git(['<STR_LIT>', '<STR_LIT>', '<STR_LIT>'], repository.path, '<STR_LIT>', {<EOL>            stdin: message,<EOL>        });<EOL>        return true;<EOL>    }<EOL>    catch (e) {<EOL>        <EOL>        <EOL>        if (e instanceof GitError) {<EOL>","gt":"const output = e.result.stderr.trim();"}
{"input":"<s> export async function createCommit(repository: Repository, kactusFiles: Array<IKactusFile>, message: string, files: ReadonlyArray<WorkingDirectoryFileChange>): Promise<boolean> {<EOL>    <EOL>    <EOL>    <EOL>    await unstageAll(repository);<EOL>    await stageFiles(repository, kactusFiles, files);<EOL>    try {<EOL>        await git(['<STR_LIT>', '<STR_LIT>', '<STR_LIT>'], repository.path, '<STR_LIT>', {<EOL>            stdin: message,<EOL>        });<EOL>        return true;<EOL>    }<EOL>    catch (e) {<EOL>        <EOL>        <EOL>        if (e instanceof GitError) {<EOL>            const output = e.result.stderr.trim();<EOL>            let standardError = '<STR_LIT>';<EOL>            if (output.length > <NUM_LIT>) {<EOL>                standardError = `<STR_LIT>`;<EOL>            }<EOL>            const exitCode = e.result.exitCode;<EOL>            const error =","gt":"new Error(`<STR_LIT>`);"}
{"input":"<s> export function fromAmbientableNode(node: compiler.AmbientableNode): MakeRequired<structures.AmbientableNodeStructure> {<EOL>","gt":"return {"}
{"input":"<s> export function match<T, _K extends keyof T>(query: string, items: ReadonlyArray<T>, getKey: _K | KeyFunction<T>): ReadonlyArray<IMatch<T>> {<EOL>    <EOL>    const maxScore = score(query, query, <NUM_LIT>);<EOL>    const result = items<EOL>        .map((item): IMatch<T> => {<EOL>        const key: string = typeof getKey ===","gt":"'<STR_LIT>'"}
{"input":"<s> export function match<T, _K extends keyof T>(query: string, items: ReadonlyArray<T>, getKey: _K | KeyFunction<T>): ReadonlyArray<IMatch<T>> {<EOL>    <EOL>    const maxScore = score(query, query, <NUM_LIT>);<EOL>    const result = items<EOL>        .map((item): IMatch<T> => {<EOL>        const key: string = typeof getKey === '<STR_LIT>'<EOL>            ? (getKey as KeyFunction<T>)(item)<EOL>            : String(item[getKey]);<EOL>        return {<EOL>            score: score(key,","gt":"query, maxScore),"}
{"input":"<s> export function generateGraph(nodeCount: number) {<EOL>    const nodes = [];<EOL>    const links = [];<EOL>    for (let i = <NUM_LIT>; i < nodeCount; i++) {<EOL>        const country = countries[Math.floor(Math.random() * countries.length)];<EOL>        nodes.push({<EOL>","gt":"id: id(),"}
{"input":"<s> export function generateGraph(nodeCount: number) {<EOL>    const nodes = [];<EOL>    const links = [];<EOL>    for (let i = <NUM_LIT>; i < nodeCount; i++) {<EOL>        const country = countries[Math.floor(Math.random() * countries.length)];<EOL>        nodes.push({<EOL>            id: id(),<EOL>            value: country,<EOL>        });<EOL>        for (let j = <NUM_LIT>; j < nodes.length - <NUM_LIT>; j++) {<EOL>            if (","gt":"Math.random() < <NUM_LIT>) {"}
{"input":"<s> /**<EOL> * Write a file using the standard fs.writeFile API, but wrapped in a promise.<EOL> *<EOL> * @param path the path to the file on disk<EOL> * @param data the contents of the file to write<EOL> * @param options the default Fs.writeFile options<EOL> */<EOL>export function writeFile(path: string, data: any, options: {<EOL>    encoding?: string;<EOL>    mode?: number;<EOL>    flag?: string;<EOL>} = {}): Promise<void> {<EOL>    return new Promise<void>((resolve, reject) => {<EOL>        Fs.writeFile(path, data, options, err => {<EOL>            if (err) {<EOL>                reject(","gt":"err);"}
{"input":"<s> /**<EOL> * Tail the file and call the callback on every line.<EOL> *<EOL> * Note that this will not stop tailing until the returned `Disposable` is<EOL> * disposed of.<EOL> */<EOL>export function tailByLine(path: string, cb: (line: string) => void): Disposable {<EOL>    const tailer = new Tailer(path);<EOL>    const disposable = tailer.onDataAvailable(stream => {<EOL>        byline(stream).on('<STR_LIT>', (buffer: Buffer) => {<EOL>            if (disposable.disposed) {<EOL>","gt":"return;"}
{"input":"<s> /**<EOL> * Tail the file and call the callback on every line.<EOL> *<EOL> * Note that this will not stop tailing until the returned `Disposable` is<EOL> * disposed of.<EOL> */<EOL>export function tailByLine(path: string, cb: (line: string) => void): Disposable {<EOL>    const tailer = new Tailer(path);<EOL>    const disposable = tailer.onDataAvailable(stream => {<EOL>        byline(stream).on('<STR_LIT>', (buffer: Buffer) => {<EOL>            if (disposable.disposed) {<EOL>                return;<EOL>            }<EOL>            const line = buffer.toString();<EOL>            cb(line);<EOL>        });<EOL>    });<EOL>    tailer.start();<EOL>    return new","gt":"Disposable(() => {"}
{"input":"<s> /**<EOL> * Add text track to the given media element.<EOL> * Returns an object with the following properties:<EOL> *   - track {TextTrack}: the added text track<EOL> *   - trackElement {HTMLElement|undefined}: the added <track> element.<EOL> *     undefined if no trackElement was added.<EOL> * @param {HTMLMediaElement} video<EOL> * @param {Boolean} hidden<EOL> * @returns {Object}<EOL> */<EOL>function addTextTrack(video: HTMLMediaElement, hidden: boolean): {<EOL>    track: TextTrack;<EOL>    trackElement?: HTMLTrackElement;<EOL>} {<EOL>    let track;<EOL>    let trackElement;<EOL>    const kind = \"<STR_LIT>\";<EOL>    if (isIE) {<EOL>        const tracksLength = video.textTracks.length;<EOL>","gt":"track = tracksLength > <NUM_LIT> ?"}
{"input":"<s> /**<EOL> * Add text track to the given media element.<EOL> * Returns an object with the following properties:<EOL> *   - track {TextTrack}: the added text track<EOL> *   - trackElement {HTMLElement|undefined}: the added <track> element.<EOL> *     undefined if no trackElement was added.<EOL> * @param {HTMLMediaElement} video<EOL> * @param {Boolean} hidden<EOL> * @returns {Object}<EOL> */<EOL>function addTextTrack(video: HTMLMediaElement, hidden: boolean): {<EOL>    track: TextTrack;<EOL>    trackElement?: HTMLTrackElement;<EOL>} {<EOL>    let track;<EOL>    let trackElement;<EOL>    const kind = \"<STR_LIT>\";<EOL>    if (isIE) {<EOL>        const tracksLength = video.textTracks.length;<EOL>        track = tracksLength > <NUM_LIT> ?<EOL>            video.textTracks[tracksLength - <NUM_LIT>] : video.addTextTrack(kind);<EOL>        track.mode = hidden ? track.HIDDEN : track.SHOWING;<EOL>    }<EOL>    else {<EOL>        <EOL>        <EOL>        trackElement = document.createElement(\"<STR_LIT>\");<EOL>        video.appendChild(trackElement);<EOL>        track =","gt":"trackElement.track;"}
{"input":"<s> function _decorate(decorators: any[], target: any): void {<EOL>    Reflect.","gt":"decorate(decorators, target);"}
{"input":"<s> function targetName(name: string) {<EOL>    return function (target: any, targetKey: string, index: number) {<EOL>        const metadata = new Metadata(METADATA_KEY.","gt":"NAME_TAG, name);"}
{"input":"<s> /**<EOL> * @param {Uint8Array} mvhd<EOL> * @param {Uint8Array} mvex<EOL> * @param {Uint8Array} trak<EOL> * @param {Object} pssList<EOL> * @returns {Array.<Uint8Array>}<EOL> */<EOL>function moovChildren(mvhd: Uint8Array, mvex: Uint8Array, trak: Uint8Array, pssList: PSSList): Uint8Array[] {<EOL>    const moov = [mvhd, mvex, trak];<EOL>    pssList.","gt":"forEach((pss) => {"}
{"input":"<s> /**<EOL> * @param {Node} root<EOL> * @returns {Object}<EOL> */<EOL>function parseMPDAttributes(root: Node): IMPDAttributes {<EOL>    const res: IMPDAttributes = {};<EOL>    for (let i = <NUM_LIT>; i < root.attributes.length; i++) {<EOL>        const attribute = root.attributes[i];<EOL>        switch (attribute.","gt":"name) {"}
{"input":"<s> /**<EOL> * @param {Node} root<EOL> * @returns {Object}<EOL> */<EOL>function parseMPDAttributes(root: Node): IMPDAttributes {<EOL>    const res: IMPDAttributes = {};<EOL>    for (let i = <NUM_LIT>; i < root.attributes.length; i++) {<EOL>        const attribute = root.attributes[i];<EOL>        switch (attribute.name) {<EOL>            case \"<STR_LIT>\":<EOL>                res.id = attribute.","gt":"value;"}
{"input":"<s> /**<EOL> * @param {Node} root<EOL> * @returns {Object}<EOL> */<EOL>function parseMPDAttributes(root: Node): IMPDAttributes {<EOL>    const res: IMPDAttributes = {};<EOL>    for (let i = <NUM_LIT>; i < root.attributes.length; i++) {<EOL>        const attribute = root.attributes[i];<EOL>        switch (attribute.name) {<EOL>            case \"<STR_LIT>\":<EOL>                res.id = attribute.value;<EOL>                break;<EOL>            case \"<STR_LIT>\":<EOL>                res.","gt":"profiles = attribute.value;"}
{"input":"<s> /**<EOL> * @param {Node} root<EOL> * @returns {Object}<EOL> */<EOL>function parseMPDAttributes(root: Node): IMPDAttributes {<EOL>    const res: IMPDAttributes = {};<EOL>    for (let i = <NUM_LIT>; i < root.attributes.length; i++) {<EOL>        const attribute = root.attributes[i];<EOL>        switch (attribute.name) {<EOL>            case \"<STR_LIT>\":<EOL>                res.id = attribute.value;<EOL>                break;<EOL>            case \"<STR_LIT>\":<EOL>                res.profiles = attribute.value;<EOL>                break;<EOL>            case \"<STR_LIT>\":<EOL>                res.type = attribute.value;<EOL>                break;<EOL>            case","gt":"\"<STR_LIT>\":"}
{"input":"<s> /**<EOL> * @param {Node} root<EOL> * @returns {Object}<EOL> */<EOL>function parseMPDAttributes(root: Node): IMPDAttributes {<EOL>    const res: IMPDAttributes = {};<EOL>    for (let i = <NUM_LIT>; i < root.attributes.length; i++) {<EOL>        const attribute = root.attributes[i];<EOL>        switch (attribute.name) {<EOL>            case \"<STR_LIT>\":<EOL>                res.id = attribute.value;<EOL>                break;<EOL>            case \"<STR_LIT>\":<EOL>                res.profiles = attribute.value;<EOL>                break;<EOL>            case \"<STR_LIT>\":<EOL>                res.type = attribute.value;<EOL>                break;<EOL>            case \"<STR_LIT>\":<EOL>","gt":"res.availabilityStartTime = +parseDateTime(attribute.value);"}
{"input":"<s> /**<EOL> * @param {Node} root<EOL> * @returns {Object}<EOL> */<EOL>function parseMPDAttributes(root: Node): IMPDAttributes {<EOL>    const res: IMPDAttributes = {};<EOL>    for (let i = <NUM_LIT>; i < root.attributes.length; i++) {<EOL>        const attribute = root.attributes[i];<EOL>        switch (attribute.name) {<EOL>            case \"<STR_LIT>\":<EOL>                res.id = attribute.value;<EOL>                break;<EOL>            case \"<STR_LIT>\":<EOL>                res.profiles = attribute.value;<EOL>                break;<EOL>            case \"<STR_LIT>\":<EOL>                res.type = attribute.value;<EOL>                break;<EOL>            case \"<STR_LIT>\":<EOL>                res.availabilityStartTime = +parseDateTime(attribute.value);<EOL>                break;<EOL>            case \"<STR_LIT>\":<EOL>                res.availabilityEndTime = +parseDateTime(attribute.value);<EOL>                break;<EOL>            case \"<STR_LIT>\":<EOL>                res.publishTime = +parseDateTime(attribute.value);<EOL>                break;<EOL>            case \"<STR_LIT>\":<EOL>                res.duration = parseDuration(attribute.","gt":"value);"}
{"input":"<s> /**<EOL> * @param {Node} root<EOL> * @returns {Object}<EOL> */<EOL>function parseMPDAttributes(root: Node): IMPDAttributes {<EOL>    const res: IMPDAttributes = {};<EOL>    for (let i = <NUM_LIT>; i < root.attributes.length; i++) {<EOL>        const attribute = root.attributes[i];<EOL>        switch (attribute.name) {<EOL>            case \"<STR_LIT>\":<EOL>                res.id = attribute.value;<EOL>                break;<EOL>            case \"<STR_LIT>\":<EOL>                res.profiles = attribute.value;<EOL>                break;<EOL>            case \"<STR_LIT>\":<EOL>                res.type = attribute.value;<EOL>                break;<EOL>            case \"<STR_LIT>\":<EOL>                res.availabilityStartTime = +parseDateTime(attribute.value);<EOL>                break;<EOL>            case \"<STR_LIT>\":<EOL>                res.availabilityEndTime = +parseDateTime(attribute.value);<EOL>                break;<EOL>            case \"<STR_LIT>\":<EOL>                res.publishTime = +parseDateTime(attribute.value);<EOL>                break;<EOL>            case \"<STR_LIT>\":<EOL>                res.duration = parseDuration(attribute.value);<EOL>                break;<EOL>            case \"<STR_LIT>\":<EOL>                res.minimumUpdatePeriod = parseDuration(attribute.value);<EOL>                break;<EOL>            case \"<STR_LIT>\":<EOL>                res.minBufferTime = parseDuration(attribute.value);<EOL>                break;<EOL>            case \"<STR_LIT>\":<EOL>                res.timeShiftBufferDepth = parseDuration(attribute.value);<EOL>","gt":"break;"}
{"input":"<s> /**<EOL> * @param {Node} root<EOL> * @returns {Object}<EOL> */<EOL>function parseMPDAttributes(root: Node): IMPDAttributes {<EOL>    const res: IMPDAttributes = {};<EOL>    for (let i = <NUM_LIT>; i < root.attributes.length; i++) {<EOL>        const attribute = root.attributes[i];<EOL>        switch (attribute.name) {<EOL>            case \"<STR_LIT>\":<EOL>                res.id = attribute.value;<EOL>                break;<EOL>            case \"<STR_LIT>\":<EOL>                res.profiles = attribute.value;<EOL>                break;<EOL>            case \"<STR_LIT>\":<EOL>                res.type = attribute.value;<EOL>                break;<EOL>            case \"<STR_LIT>\":<EOL>                res.availabilityStartTime = +parseDateTime(attribute.value);<EOL>                break;<EOL>            case \"<STR_LIT>\":<EOL>                res.availabilityEndTime = +parseDateTime(attribute.value);<EOL>                break;<EOL>            case \"<STR_LIT>\":<EOL>                res.publishTime = +parseDateTime(attribute.value);<EOL>                break;<EOL>            case \"<STR_LIT>\":<EOL>                res.duration = parseDuration(attribute.value);<EOL>                break;<EOL>            case \"<STR_LIT>\":<EOL>                res.minimumUpdatePeriod = parseDuration(attribute.value);<EOL>                break;<EOL>            case \"<STR_LIT>\":<EOL>                res.minBufferTime = parseDuration(attribute.value);<EOL>                break;<EOL>            case \"<STR_LIT>\":<EOL>                res.timeShiftBufferDepth = parseDuration(attribute.value);<EOL>                break;<EOL>            case \"<STR_LIT>\":<EOL>                res.suggestedPresentationDelay = parseDuration(attribute.value);<EOL>                break;<EOL>            case \"<STR_LIT>\":<EOL>                res.maxSegmentDuration =","gt":"parseDuration(attribute.value);"}
{"input":"<s> function compareChangeType(c1: ChangeType, c2: ChangeType): number {<EOL>    const order = (change: ChangeType) => {<EOL>        switch (change) {<EOL>            case ChangeType.Added:<EOL>                return <NUM_LIT>;<EOL>            case ChangeType.Modified:<EOL>","gt":"return <NUM_LIT>;"}
{"input":"<s> function compareChangeType(c1: ChangeType, c2: ChangeType): number {<EOL>    const order = (change: ChangeType) => {<EOL>        switch (change) {<EOL>            case ChangeType.Added:<EOL>                return <NUM_LIT>;<EOL>            case ChangeType.Modified:<EOL>                return <NUM_LIT>;<EOL>            case ChangeType.Metadata:<EOL>                <EOL>                <EOL>                <EOL>                return <NUM_LIT>;<EOL>            case ChangeType.Removed:<EOL>                return <NUM_LIT>;<EOL>","gt":"default:"}
{"input":"<s> /** Get the commit for the given ref. */<EOL>export async function getCommit(repository: Repository, ref: string): Promise<Commit | null> {<EOL>    const commits = await getCommits(repository, ref, <NUM_LIT>);<EOL>    if (","gt":"commits.length < <NUM_LIT>) {"}
{"input":"<s> export function isFunction(p: any): boolean {<EOL>    return typeof p ===","gt":"'<STR_LIT>';"}
{"input":"<s> function getInWelcomeFlowBuilder(inWelcomeFlow: boolean): MenuStateBuilder {<EOL>    const welcomeScopedIds: ReadonlyArray<MenuIDs> = [<EOL>        '<STR_LIT>',<EOL>        '<STR_LIT>',<EOL>        '<STR_LIT>',<EOL>        '<STR_LIT>',<EOL>","gt":"'<STR_LIT>',"}
{"input":"<s> function getInWelcomeFlowBuilder(inWelcomeFlow: boolean): MenuStateBuilder {<EOL>    const welcomeScopedIds: ReadonlyArray<MenuIDs> = [<EOL>        '<STR_LIT>',<EOL>        '<STR_LIT>',<EOL>        '<STR_LIT>',<EOL>        '<STR_LIT>',<EOL>        '<STR_LIT>',<EOL>    ];<EOL>    const menuStateBuilder = new MenuStateBuilder();<EOL>    if (inWelcomeFlow) {<EOL>        for (const id of welcomeScopedIds) {<EOL>","gt":"menuStateBuilder.disable(id);"}
{"input":"<s> function getInWelcomeFlowBuilder(inWelcomeFlow: boolean): MenuStateBuilder {<EOL>    const welcomeScopedIds: ReadonlyArray<MenuIDs> = [<EOL>        '<STR_LIT>',<EOL>        '<STR_LIT>',<EOL>        '<STR_LIT>',<EOL>        '<STR_LIT>',<EOL>        '<STR_LIT>',<EOL>    ];<EOL>    const menuStateBuilder = new MenuStateBuilder();<EOL>    if (inWelcomeFlow) {<EOL>        for (const id of welcomeScopedIds) {<EOL>            menuStateBuilder.disable(id);<EOL>        }<EOL>    }<EOL>    else {<EOL>        for (const id of","gt":"welcomeScopedIds) {"}
{"input":"<s> export function generateGraph(nodeCount: number) {<EOL>    const nodes = [];<EOL>    const links = [];<EOL>    for (let i = <NUM_LIT>; i < nodeCount; i++) {<EOL>        const country = countries[Math.floor(Math.random() * countries.length)];<EOL>        nodes.push({<EOL>            value:","gt":"country.name,"}
{"input":"<s> export function generateGraph(nodeCount: number) {<EOL>    const nodes = [];<EOL>    const links = [];<EOL>    for (let i = <NUM_LIT>; i < nodeCount; i++) {<EOL>        const country = countries[Math.floor(Math.random() * countries.length)];<EOL>        nodes.push({<EOL>            value: country.name,<EOL>        });<EOL>        for (let j = <NUM_LIT>; j < nodes.length - <NUM_LIT>; j++) {<EOL>            if (Math.random() < <NUM_LIT>) {<EOL>","gt":"links.push({"}
{"input":"<s> /**<EOL> * Returns global parameters from a TTML Document<EOL> * TODO Missing parameters.<EOL> * @param {Element} tt - <tt> node<EOL> * @throws Error - Throws if the spacing style is invalid.<EOL> * @returns {Object} params<EOL> * @returns {Number} params.frameRate<EOL> * @returns {Number} params.subFrameRate<EOL> * @returns {Number} params.tickRate<EOL> * @returns {string} params.spaceStyle<EOL> */<EOL>export default function getParameters(tt: Element): ITTParameters {<EOL>    const parsedFrameRate = tt.getAttribute(\"<STR_LIT>\");<EOL>    const parsedSubFrameRate = tt.getAttribute(\"<STR_LIT>\");<EOL>    const","gt":"parsedTickRate = tt.getAttribute(\"<STR_LIT>\");"}
{"input":"<s> /**<EOL> * Returns global parameters from a TTML Document<EOL> * TODO Missing parameters.<EOL> * @param {Element} tt - <tt> node<EOL> * @throws Error - Throws if the spacing style is invalid.<EOL> * @returns {Object} params<EOL> * @returns {Number} params.frameRate<EOL> * @returns {Number} params.subFrameRate<EOL> * @returns {Number} params.tickRate<EOL> * @returns {string} params.spaceStyle<EOL> */<EOL>export default function getParameters(tt: Element): ITTParameters {<EOL>    const parsedFrameRate = tt.getAttribute(\"<STR_LIT>\");<EOL>    const parsedSubFrameRate = tt.getAttribute(\"<STR_LIT>\");<EOL>    const parsedTickRate = tt.getAttribute(\"<STR_LIT>\");<EOL>    const parsedFrameRateMultiplier = tt.getAttribute(\"<STR_LIT>\");<EOL>    const parsedSpaceStyle =","gt":"tt.getAttribute(\"<STR_LIT>\");"}
{"input":"<s> /**<EOL> * Returns global parameters from a TTML Document<EOL> * TODO Missing parameters.<EOL> * @param {Element} tt - <tt> node<EOL> * @throws Error - Throws if the spacing style is invalid.<EOL> * @returns {Object} params<EOL> * @returns {Number} params.frameRate<EOL> * @returns {Number} params.subFrameRate<EOL> * @returns {Number} params.tickRate<EOL> * @returns {string} params.spaceStyle<EOL> */<EOL>export default function getParameters(tt: Element): ITTParameters {<EOL>    const parsedFrameRate = tt.getAttribute(\"<STR_LIT>\");<EOL>    const parsedSubFrameRate = tt.getAttribute(\"<STR_LIT>\");<EOL>    const parsedTickRate = tt.getAttribute(\"<STR_LIT>\");<EOL>    const parsedFrameRateMultiplier = tt.getAttribute(\"<STR_LIT>\");<EOL>    const parsedSpaceStyle = tt.getAttribute(\"<STR_LIT>\");<EOL>    if (parsedSpaceStyle && parsedSpaceStyle !== \"<STR_LIT>\" &&<EOL>        parsedSpaceStyle !==","gt":"\"<STR_LIT>\") {"}
{"input":"<s> /**<EOL> * Returns global parameters from a TTML Document<EOL> * TODO Missing parameters.<EOL> * @param {Element} tt - <tt> node<EOL> * @throws Error - Throws if the spacing style is invalid.<EOL> * @returns {Object} params<EOL> * @returns {Number} params.frameRate<EOL> * @returns {Number} params.subFrameRate<EOL> * @returns {Number} params.tickRate<EOL> * @returns {string} params.spaceStyle<EOL> */<EOL>export default function getParameters(tt: Element): ITTParameters {<EOL>    const parsedFrameRate = tt.getAttribute(\"<STR_LIT>\");<EOL>    const parsedSubFrameRate = tt.getAttribute(\"<STR_LIT>\");<EOL>    const parsedTickRate = tt.getAttribute(\"<STR_LIT>\");<EOL>    const parsedFrameRateMultiplier = tt.getAttribute(\"<STR_LIT>\");<EOL>    const parsedSpaceStyle = tt.getAttribute(\"<STR_LIT>\");<EOL>    if (parsedSpaceStyle && parsedSpaceStyle !== \"<STR_LIT>\" &&<EOL>        parsedSpaceStyle !== \"<STR_LIT>\") {<EOL>        throw new Error(\"<STR_LIT>\");<EOL>    }<EOL>    const nbFrameRate = Number(parsedFrameRate) || <NUM_LIT>;<EOL>    const","gt":"nbSubFrameRate = Number(parsedSubFrameRate) || <NUM_LIT>;"}
{"input":"<s> /**<EOL> * Returns global parameters from a TTML Document<EOL> * TODO Missing parameters.<EOL> * @param {Element} tt - <tt> node<EOL> * @throws Error - Throws if the spacing style is invalid.<EOL> * @returns {Object} params<EOL> * @returns {Number} params.frameRate<EOL> * @returns {Number} params.subFrameRate<EOL> * @returns {Number} params.tickRate<EOL> * @returns {string} params.spaceStyle<EOL> */<EOL>export default function getParameters(tt: Element): ITTParameters {<EOL>    const parsedFrameRate = tt.getAttribute(\"<STR_LIT>\");<EOL>    const parsedSubFrameRate = tt.getAttribute(\"<STR_LIT>\");<EOL>    const parsedTickRate = tt.getAttribute(\"<STR_LIT>\");<EOL>    const parsedFrameRateMultiplier = tt.getAttribute(\"<STR_LIT>\");<EOL>    const parsedSpaceStyle = tt.getAttribute(\"<STR_LIT>\");<EOL>    if (parsedSpaceStyle && parsedSpaceStyle !== \"<STR_LIT>\" &&<EOL>        parsedSpaceStyle !== \"<STR_LIT>\") {<EOL>        throw new Error(\"<STR_LIT>\");<EOL>    }<EOL>    const nbFrameRate = Number(parsedFrameRate) || <NUM_LIT>;<EOL>    const nbSubFrameRate = Number(parsedSubFrameRate) || <NUM_LIT>;<EOL>    const nbTickRate = Number(parsedTickRate) || <NUM_LIT>;<EOL>    let tickRate = nbTickRate;<EOL>    let frameRate = nbFrameRate;<EOL>    const subFrameRate = nbSubFrameRate !=","gt":"null ? nbSubFrameRate : <NUM_LIT>;"}
{"input":"<s> /**<EOL> * Returns global parameters from a TTML Document<EOL> * TODO Missing parameters.<EOL> * @param {Element} tt - <tt> node<EOL> * @throws Error - Throws if the spacing style is invalid.<EOL> * @returns {Object} params<EOL> * @returns {Number} params.frameRate<EOL> * @returns {Number} params.subFrameRate<EOL> * @returns {Number} params.tickRate<EOL> * @returns {string} params.spaceStyle<EOL> */<EOL>export default function getParameters(tt: Element): ITTParameters {<EOL>    const parsedFrameRate = tt.getAttribute(\"<STR_LIT>\");<EOL>    const parsedSubFrameRate = tt.getAttribute(\"<STR_LIT>\");<EOL>    const parsedTickRate = tt.getAttribute(\"<STR_LIT>\");<EOL>    const parsedFrameRateMultiplier = tt.getAttribute(\"<STR_LIT>\");<EOL>    const parsedSpaceStyle = tt.getAttribute(\"<STR_LIT>\");<EOL>    if (parsedSpaceStyle && parsedSpaceStyle !== \"<STR_LIT>\" &&<EOL>        parsedSpaceStyle !== \"<STR_LIT>\") {<EOL>        throw new Error(\"<STR_LIT>\");<EOL>    }<EOL>    const nbFrameRate = Number(parsedFrameRate) || <NUM_LIT>;<EOL>    const nbSubFrameRate = Number(parsedSubFrameRate) || <NUM_LIT>;<EOL>    const nbTickRate = Number(parsedTickRate) || <NUM_LIT>;<EOL>    let tickRate = nbTickRate;<EOL>    let frameRate = nbFrameRate;<EOL>    const subFrameRate = nbSubFrameRate != null ? nbSubFrameRate : <NUM_LIT>;<EOL>    <EOL>    const spaceStyle = (parsedSpaceStyle || \"<STR_LIT>\") as \"<STR_LIT>\" | \"<STR_LIT>\";<EOL>    if (nbTickRate === <NUM_LIT>) {<EOL>        tickRate =","gt":"parsedFrameRate ? nbFrameRate * nbSubFrameRate : <NUM_LIT>;"}
{"input":"<s> /**<EOL> * Returns global parameters from a TTML Document<EOL> * TODO Missing parameters.<EOL> * @param {Element} tt - <tt> node<EOL> * @throws Error - Throws if the spacing style is invalid.<EOL> * @returns {Object} params<EOL> * @returns {Number} params.frameRate<EOL> * @returns {Number} params.subFrameRate<EOL> * @returns {Number} params.tickRate<EOL> * @returns {string} params.spaceStyle<EOL> */<EOL>export default function getParameters(tt: Element): ITTParameters {<EOL>    const parsedFrameRate = tt.getAttribute(\"<STR_LIT>\");<EOL>    const parsedSubFrameRate = tt.getAttribute(\"<STR_LIT>\");<EOL>    const parsedTickRate = tt.getAttribute(\"<STR_LIT>\");<EOL>    const parsedFrameRateMultiplier = tt.getAttribute(\"<STR_LIT>\");<EOL>    const parsedSpaceStyle = tt.getAttribute(\"<STR_LIT>\");<EOL>    if (parsedSpaceStyle && parsedSpaceStyle !== \"<STR_LIT>\" &&<EOL>        parsedSpaceStyle !== \"<STR_LIT>\") {<EOL>        throw new Error(\"<STR_LIT>\");<EOL>    }<EOL>    const nbFrameRate = Number(parsedFrameRate) || <NUM_LIT>;<EOL>    const nbSubFrameRate = Number(parsedSubFrameRate) || <NUM_LIT>;<EOL>    const nbTickRate = Number(parsedTickRate) || <NUM_LIT>;<EOL>    let tickRate = nbTickRate;<EOL>    let frameRate = nbFrameRate;<EOL>    const subFrameRate = nbSubFrameRate != null ? nbSubFrameRate : <NUM_LIT>;<EOL>    <EOL>    const spaceStyle = (parsedSpaceStyle || \"<STR_LIT>\") as \"<STR_LIT>\" | \"<STR_LIT>\";<EOL>    if (nbTickRate === <NUM_LIT>) {<EOL>        tickRate = parsedFrameRate ? nbFrameRate * nbSubFrameRate : <NUM_LIT>;<EOL>    }<EOL>    if (parsedFrameRateMultiplier) {<EOL>        const multiplierResults = /^(\\d+) (\\d+)$/g.exec(parsedFrameRateMultiplier);<EOL>        if (multiplierResults) {<EOL>            const numerator = Number(multiplierResults[<NUM_LIT>]);<EOL>            const denominator = Number(multiplierResults[<NUM_LIT>]);<EOL>            const multiplierNum = numerator / denominator;<EOL>","gt":"frameRate = nbFrameRate * multiplierNum;"}
{"input":"<s> /**<EOL> * Get end of the given index range, timescaled.<EOL> * @param {Object} range<EOL> * @param {Number} range.ts - the range's start time<EOL> * @param {Number} range.d - the range's duration<EOL> * @param {Number} range.r - the range's count. 0 for a single element, 1 for<EOL> * 2 elements etc.<EOL> * @returns {Number} - absolute end time of the range<EOL> */<EOL>function getTimelineRangeEnd({ ts, d, r }: {<EOL>    ts: number;<EOL>    d?: number;<EOL>    r: number;<EOL>}): number {<EOL>    return (d == null || d === -<NUM_LIT>) ? ts : ts + (","gt":"r + <NUM_LIT>) * d;"}
{"input":"<s> function verify(payload, done) {<EOL>    const","gt":"id = payload.sub;"}
{"input":"<s> export function mockCreateToken(token: AccessToken = { access_token: '<STR_LIT>', expires_in: <NUM_LIT> }): nock.Scope {<EOL>    let","gt":"mock: nock.Scope = nock('<STR_LIT>').post('<STR_LIT>');"}
{"input":"<s> function parseAdaptationSetChildren(adaptationSetChildren: NodeList): IAdaptationSetChildren {<EOL>    const children: IAdaptationSetChildren = {<EOL>        baseURL: \"<STR_LIT>\",<EOL>        representations: [],<EOL>    };<EOL>    for (let i = <NUM_LIT>; i < adaptationSetChildren.length; i++) {<EOL>        const","gt":"currentNode = adaptationSetChildren[i];"}
{"input":"<s> function parseAdaptationSetChildren(adaptationSetChildren: NodeList): IAdaptationSetChildren {<EOL>    const children: IAdaptationSetChildren = {<EOL>        baseURL: \"<STR_LIT>\",<EOL>        representations: [],<EOL>    };<EOL>    for (let i = <NUM_LIT>; i < adaptationSetChildren.length; i++) {<EOL>        const currentNode = adaptationSetChildren[i];<EOL>        switch (currentNode.nodeName) {<EOL>            case \"<STR_LIT>\":<EOL>                children.","gt":"accessibility = parseScheme(currentNode);"}
{"input":"<s> function parseAdaptationSetChildren(adaptationSetChildren: NodeList): IAdaptationSetChildren {<EOL>    const children: IAdaptationSetChildren = {<EOL>        baseURL: \"<STR_LIT>\",<EOL>        representations: [],<EOL>    };<EOL>    for (let i = <NUM_LIT>; i < adaptationSetChildren.length; i++) {<EOL>        const currentNode = adaptationSetChildren[i];<EOL>        switch (currentNode.nodeName) {<EOL>            case \"<STR_LIT>\":<EOL>                children.accessibility = parseScheme(currentNode);<EOL>                break;<EOL>            case \"<STR_LIT>\":<EOL>                children.baseURL = currentNode.textContent || \"<STR_LIT>\";<EOL>                break;<EOL>","gt":"case \"<STR_LIT>\":"}
{"input":"<s> function parseAdaptationSetChildren(adaptationSetChildren: NodeList): IAdaptationSetChildren {<EOL>    const children: IAdaptationSetChildren = {<EOL>        baseURL: \"<STR_LIT>\",<EOL>        representations: [],<EOL>    };<EOL>    for (let i = <NUM_LIT>; i < adaptationSetChildren.length; i++) {<EOL>        const currentNode = adaptationSetChildren[i];<EOL>        switch (currentNode.nodeName) {<EOL>            case \"<STR_LIT>\":<EOL>                children.accessibility = parseScheme(currentNode);<EOL>                break;<EOL>            case \"<STR_LIT>\":<EOL>                children.baseURL = currentNode.textContent || \"<STR_LIT>\";<EOL>                break;<EOL>            case \"<STR_LIT>\":<EOL>                children.contentComponent = parseContentComponent(currentNode);<EOL>                break;<EOL>            case \"<STR_LIT>\":<EOL>                const representation = createRepresentationIntermediateRepresentation(currentNode);<EOL>","gt":"children.representations.push(representation);"}
{"input":"<s> function parseAdaptationSetChildren(adaptationSetChildren: NodeList): IAdaptationSetChildren {<EOL>    const children: IAdaptationSetChildren = {<EOL>        baseURL: \"<STR_LIT>\",<EOL>        representations: [],<EOL>    };<EOL>    for (let i = <NUM_LIT>; i < adaptationSetChildren.length; i++) {<EOL>        const currentNode = adaptationSetChildren[i];<EOL>        switch (currentNode.nodeName) {<EOL>            case \"<STR_LIT>\":<EOL>                children.accessibility = parseScheme(currentNode);<EOL>                break;<EOL>            case \"<STR_LIT>\":<EOL>                children.baseURL = currentNode.textContent || \"<STR_LIT>\";<EOL>                break;<EOL>            case \"<STR_LIT>\":<EOL>                children.contentComponent = parseContentComponent(currentNode);<EOL>                break;<EOL>            case \"<STR_LIT>\":<EOL>                const representation = createRepresentationIntermediateRepresentation(currentNode);<EOL>                children.representations.push(representation);<EOL>                break;<EOL>            case \"<STR_LIT>\":<EOL>                children.role = parseScheme(currentNode);<EOL>                break;<EOL>","gt":"case \"<STR_LIT>\":"}
{"input":"<s> function parseAdaptationSetChildren(adaptationSetChildren: NodeList): IAdaptationSetChildren {<EOL>    const children: IAdaptationSetChildren = {<EOL>        baseURL: \"<STR_LIT>\",<EOL>        representations: [],<EOL>    };<EOL>    for (let i = <NUM_LIT>; i < adaptationSetChildren.length; i++) {<EOL>        const currentNode = adaptationSetChildren[i];<EOL>        switch (currentNode.nodeName) {<EOL>            case \"<STR_LIT>\":<EOL>                children.accessibility = parseScheme(currentNode);<EOL>                break;<EOL>            case \"<STR_LIT>\":<EOL>                children.baseURL = currentNode.textContent || \"<STR_LIT>\";<EOL>                break;<EOL>            case \"<STR_LIT>\":<EOL>                children.contentComponent = parseContentComponent(currentNode);<EOL>                break;<EOL>            case \"<STR_LIT>\":<EOL>                const representation = createRepresentationIntermediateRepresentation(currentNode);<EOL>                children.representations.push(representation);<EOL>                break;<EOL>            case \"<STR_LIT>\":<EOL>                children.role = parseScheme(currentNode);<EOL>                break;<EOL>            case \"<STR_LIT>\":<EOL>                children.segmentBase = parseSegmentBase(currentNode);<EOL>                break;<EOL>            case \"<STR_LIT>\":<EOL>                children.segmentList = parseSegmentList(currentNode);<EOL>                break;<EOL>            case \"<STR_LIT>\":<EOL>                children.segmentTemplate = parseSegmentTemplate(currentNode);<EOL>                break;<EOL>            case \"<STR_LIT>\":<EOL>","gt":"children.contentProtection = parseContentProtection(currentNode);"}
{"input":"<s> /**<EOL> * Try to replicate the textOutline TTML style property into CSS.<EOL> *<EOL> * We mock it throught the text-shadow property, translating the TTML thickness<EOL> * into blur radius and the blur-radius into... nothing.<EOL> *<EOL> * @param {string} color<EOL> * @param {string|number} thickness<EOL> * @returns {string}<EOL> */<EOL>function generateCSSTextOutline(color: string, thickness: string | number): string {<EOL>    return `<STR_LIT>` +<EOL>","gt":"} ${color},`<STR_LIT>+"}
{"input":"<s> function activePeriodChanged(period: Period): IActivePeriodChangedEvent {<EOL>    return {<EOL>        type:","gt":"\"<STR_LIT>\","}
{"input":"<s> export function selectRows(selected: any[], row: any, comparefn: any) {<EOL>    const selectedIndex = comparefn(row, selected);<EOL>    if (selectedIndex > -<NUM_LIT>) {<EOL>        selected.splice(","gt":"selectedIndex, <NUM_LIT>);"}
{"input":"<s> function warning(value: Error | CustomError): IStreamWarningEvent {<EOL>    return {<EOL>","gt":"type: \"<STR_LIT>\","}
{"input":"<s> function getOverloadsAndImplementation(node: OverloadableNodeExtensionType & OverloadableNode) {<EOL>    const parentSyntaxList = node.getParentSyntaxListOrThrow();<EOL>    const name = getNameIfNamedNode(node);<EOL>","gt":"const kind = node.getKind();"}
{"input":"<s> function setItem(key: string, login: string, value: string) {<EOL>","gt":"return keytar.setPassword(key, login, value);"}
{"input":"<s> /**<EOL> * Returns the columns by pin.<EOL> */<EOL>export function columnsByPin(cols: any[]) {<EOL>    const ret: {<EOL>        left: any;<EOL>        center: any;<EOL>        right: any;<EOL>    } = {<EOL>        left: [],<EOL>        center: [],<EOL>","gt":"right: []"}
{"input":"<s> /**<EOL> * Returns the columns by pin.<EOL> */<EOL>export function columnsByPin(cols: any[]) {<EOL>    const ret: {<EOL>        left: any;<EOL>        center: any;<EOL>        right: any;<EOL>    } = {<EOL>        left: [],<EOL>        center: [],<EOL>        right: []<EOL>    };<EOL>    if (cols) {<EOL>        for (const col of cols) {<EOL>            if (col.frozenLeft) {<EOL>                ret.left.","gt":"push(col);"}
{"input":"<s> /**<EOL> * Returns the columns by pin.<EOL> */<EOL>export function columnsByPin(cols: any[]) {<EOL>    const ret: {<EOL>        left: any;<EOL>        center: any;<EOL>        right: any;<EOL>    } = {<EOL>        left: [],<EOL>        center: [],<EOL>        right: []<EOL>    };<EOL>    if (cols) {<EOL>        for (const col of cols) {<EOL>            if (col.frozenLeft) {<EOL>                ret.left.push(col);<EOL>            }<EOL>            else if (col.frozenRight) {<EOL>                ret.right.push(col);<EOL>            }<EOL>","gt":"else {"}
{"input":"<s> /**<EOL>  Mark `map` as immutable.<EOL> */<EOL>function endMutation(map) {<EOL>    map._editable = map._editable &&","gt":"map._editable - <NUM_LIT>;"}
{"input":"<s> /**<EOL> * Marks a source as \"pullable\" and adds an implementation of the `Pullable`<EOL> * interface.<EOL> *<EOL> * The `pull` method is part of the \"request flow\" in Orbit. Requests trigger<EOL> * events before and after processing of each request. Observers can delay the<EOL> * resolution of a request by returning a promise in an event listener.<EOL> *<EOL> * A pullable source emits the following events:<EOL> *<EOL> * - `beforePull` - emitted prior to the processing of `pull`, this event<EOL> * includes the requested `Query` as an argument.<EOL> *<EOL> * - `pull` - emitted after a `pull` has successfully been requested, this<EOL> * event's arguments include both the requested `Query` and an array of the<EOL> * resulting `Transform` instances.<EOL> *<EOL> * - `pullFail` - emitted when an error has occurred processing a `pull`, this<EOL> * event's arguments include both the requested `Query` and the error.<EOL> *<EOL> * A pullable source must implement a private method `_pull`, which performs<EOL> * the processing required for `pull` and returns a promise that resolves to an<EOL> * array of `Transform` instances.<EOL> *<EOL> * @export<EOL> * @decorator<EOL> * @param {SourceClass} Klass<EOL> * @returns {void}<EOL> */<EOL>export default function pullable(Klass: SourceClass): void {<EOL>    let proto = Klass.prototype;<EOL>    if (isPullable(proto)) {<EOL>        return;<EOL>    }<EOL>    assert('<STR_LIT>', proto instanceof","gt":"Source);"}
{"input":"<s> /**<EOL> * Marks a source as \"pullable\" and adds an implementation of the `Pullable`<EOL> * interface.<EOL> *<EOL> * The `pull` method is part of the \"request flow\" in Orbit. Requests trigger<EOL> * events before and after processing of each request. Observers can delay the<EOL> * resolution of a request by returning a promise in an event listener.<EOL> *<EOL> * A pullable source emits the following events:<EOL> *<EOL> * - `beforePull` - emitted prior to the processing of `pull`, this event<EOL> * includes the requested `Query` as an argument.<EOL> *<EOL> * - `pull` - emitted after a `pull` has successfully been requested, this<EOL> * event's arguments include both the requested `Query` and an array of the<EOL> * resulting `Transform` instances.<EOL> *<EOL> * - `pullFail` - emitted when an error has occurred processing a `pull`, this<EOL> * event's arguments include both the requested `Query` and the error.<EOL> *<EOL> * A pullable source must implement a private method `_pull`, which performs<EOL> * the processing required for `pull` and returns a promise that resolves to an<EOL> * array of `Transform` instances.<EOL> *<EOL> * @export<EOL> * @decorator<EOL> * @param {SourceClass} Klass<EOL> * @returns {void}<EOL> */<EOL>export default function pullable(Klass: SourceClass): void {<EOL>    let proto = Klass.prototype;<EOL>    if (isPullable(proto)) {<EOL>        return;<EOL>    }<EOL>    assert('<STR_LIT>', proto instanceof Source);<EOL>    proto[PULLABLE] = true;<EOL>    proto.pull = function (queryOrExpression: QueryOrExpression, options?: object, id?: string): Promise<Transform[]> {<EOL>","gt":"const query = buildQuery(queryOrExpression, options, id, this.queryBuilder);"}
{"input":"<s> /**<EOL> * Marks a source as \"pullable\" and adds an implementation of the `Pullable`<EOL> * interface.<EOL> *<EOL> * The `pull` method is part of the \"request flow\" in Orbit. Requests trigger<EOL> * events before and after processing of each request. Observers can delay the<EOL> * resolution of a request by returning a promise in an event listener.<EOL> *<EOL> * A pullable source emits the following events:<EOL> *<EOL> * - `beforePull` - emitted prior to the processing of `pull`, this event<EOL> * includes the requested `Query` as an argument.<EOL> *<EOL> * - `pull` - emitted after a `pull` has successfully been requested, this<EOL> * event's arguments include both the requested `Query` and an array of the<EOL> * resulting `Transform` instances.<EOL> *<EOL> * - `pullFail` - emitted when an error has occurred processing a `pull`, this<EOL> * event's arguments include both the requested `Query` and the error.<EOL> *<EOL> * A pullable source must implement a private method `_pull`, which performs<EOL> * the processing required for `pull` and returns a promise that resolves to an<EOL> * array of `Transform` instances.<EOL> *<EOL> * @export<EOL> * @decorator<EOL> * @param {SourceClass} Klass<EOL> * @returns {void}<EOL> */<EOL>export default function pullable(Klass: SourceClass): void {<EOL>    let proto = Klass.prototype;<EOL>    if (isPullable(proto)) {<EOL>        return;<EOL>    }<EOL>    assert('<STR_LIT>', proto instanceof Source);<EOL>    proto[PULLABLE] = true;<EOL>    proto.pull = function (queryOrExpression: QueryOrExpression, options?: object, id?: string): Promise<Transform[]> {<EOL>        const query = buildQuery(queryOrExpression, options, id, this.queryBuilder);<EOL>        return this._enqueueRequest('<STR_LIT>', query);<EOL>    };<EOL>    proto.__pull__ = function (query: Query): Promise<Transform[]> {<EOL>        return fulfillInSeries(this, '<STR_LIT>', query)<EOL>            .then(() => this._pull(","gt":"query))"}
{"input":"<s> /**<EOL> * Marks a source as \"pushable\" and adds an implementation of the `Pushable`<EOL> * interface.<EOL> *<EOL> * The `push` method is part of the \"request flow\" in Orbit. Requests trigger<EOL> * events before and after processing of each request. Observers can delay the<EOL> * resolution of a request by returning a promise in an event listener.<EOL> *<EOL> * A pushable source emits the following events:<EOL> *<EOL> * - `beforePush` - emitted prior to the processing of `push`, this event<EOL> * includes the requested `Transform` as an argument.<EOL> *<EOL> * - `push` - emitted after a `push` has successfully been applied, this event's<EOL> * arguments include both the requested `Transform` and an array of the actual<EOL> * applied `Transform` instances.<EOL> *<EOL> * - `pushFail` - emitted when an error has occurred pushing a transform, this<EOL> * event's arguments include both the requested `Transform` and the error.<EOL> *<EOL> * A pushable source must implement a private method `_push`, which performs<EOL> * the processing required for `push` and returns a promise that resolves to an<EOL> * array of `Transform` instances.<EOL> *<EOL> * @export<EOL> * @decorator<EOL> * @param {SourceClass} Klass<EOL> * @returns {void}<EOL> */<EOL>export default function pushable(Klass: SourceClass): void {<EOL>    let proto = Klass.prototype;<EOL>    if (isPushable(proto)) {<EOL>","gt":"return;"}
{"input":"<s> /**<EOL> * Marks a source as \"pushable\" and adds an implementation of the `Pushable`<EOL> * interface.<EOL> *<EOL> * The `push` method is part of the \"request flow\" in Orbit. Requests trigger<EOL> * events before and after processing of each request. Observers can delay the<EOL> * resolution of a request by returning a promise in an event listener.<EOL> *<EOL> * A pushable source emits the following events:<EOL> *<EOL> * - `beforePush` - emitted prior to the processing of `push`, this event<EOL> * includes the requested `Transform` as an argument.<EOL> *<EOL> * - `push` - emitted after a `push` has successfully been applied, this event's<EOL> * arguments include both the requested `Transform` and an array of the actual<EOL> * applied `Transform` instances.<EOL> *<EOL> * - `pushFail` - emitted when an error has occurred pushing a transform, this<EOL> * event's arguments include both the requested `Transform` and the error.<EOL> *<EOL> * A pushable source must implement a private method `_push`, which performs<EOL> * the processing required for `push` and returns a promise that resolves to an<EOL> * array of `Transform` instances.<EOL> *<EOL> * @export<EOL> * @decorator<EOL> * @param {SourceClass} Klass<EOL> * @returns {void}<EOL> */<EOL>export default function pushable(Klass: SourceClass): void {<EOL>    let proto = Klass.prototype;<EOL>    if (isPushable(proto)) {<EOL>        return;<EOL>    }<EOL>    assert('<STR_LIT>', proto instanceof Source);<EOL>    proto[PUSHABLE] = true;<EOL>","gt":"proto.push = function (transformOrOperations: TransformOrOperations, options?: object, id?: string): Promise<Transform[]> {"}
{"input":"<s> /**<EOL> * Marks a source as \"pushable\" and adds an implementation of the `Pushable`<EOL> * interface.<EOL> *<EOL> * The `push` method is part of the \"request flow\" in Orbit. Requests trigger<EOL> * events before and after processing of each request. Observers can delay the<EOL> * resolution of a request by returning a promise in an event listener.<EOL> *<EOL> * A pushable source emits the following events:<EOL> *<EOL> * - `beforePush` - emitted prior to the processing of `push`, this event<EOL> * includes the requested `Transform` as an argument.<EOL> *<EOL> * - `push` - emitted after a `push` has successfully been applied, this event's<EOL> * arguments include both the requested `Transform` and an array of the actual<EOL> * applied `Transform` instances.<EOL> *<EOL> * - `pushFail` - emitted when an error has occurred pushing a transform, this<EOL> * event's arguments include both the requested `Transform` and the error.<EOL> *<EOL> * A pushable source must implement a private method `_push`, which performs<EOL> * the processing required for `push` and returns a promise that resolves to an<EOL> * array of `Transform` instances.<EOL> *<EOL> * @export<EOL> * @decorator<EOL> * @param {SourceClass} Klass<EOL> * @returns {void}<EOL> */<EOL>export default function pushable(Klass: SourceClass): void {<EOL>    let proto = Klass.prototype;<EOL>    if (isPushable(proto)) {<EOL>        return;<EOL>    }<EOL>    assert('<STR_LIT>', proto instanceof Source);<EOL>    proto[PUSHABLE] = true;<EOL>    proto.push = function (transformOrOperations: TransformOrOperations, options?: object, id?: string): Promise<Transform[]> {<EOL>        const transform = buildTransform(transformOrOperations, options, id, this.transformBuilder);<EOL>        if (this.transformLog.contains(transform.id)) {<EOL>            return Orbit.Promise.resolve([]);<EOL>        }<EOL>        return this._enqueueRequest('<STR_LIT>',","gt":"transform);"}
{"input":"<s> /**<EOL> * Marks a source as \"pushable\" and adds an implementation of the `Pushable`<EOL> * interface.<EOL> *<EOL> * The `push` method is part of the \"request flow\" in Orbit. Requests trigger<EOL> * events before and after processing of each request. Observers can delay the<EOL> * resolution of a request by returning a promise in an event listener.<EOL> *<EOL> * A pushable source emits the following events:<EOL> *<EOL> * - `beforePush` - emitted prior to the processing of `push`, this event<EOL> * includes the requested `Transform` as an argument.<EOL> *<EOL> * - `push` - emitted after a `push` has successfully been applied, this event's<EOL> * arguments include both the requested `Transform` and an array of the actual<EOL> * applied `Transform` instances.<EOL> *<EOL> * - `pushFail` - emitted when an error has occurred pushing a transform, this<EOL> * event's arguments include both the requested `Transform` and the error.<EOL> *<EOL> * A pushable source must implement a private method `_push`, which performs<EOL> * the processing required for `push` and returns a promise that resolves to an<EOL> * array of `Transform` instances.<EOL> *<EOL> * @export<EOL> * @decorator<EOL> * @param {SourceClass} Klass<EOL> * @returns {void}<EOL> */<EOL>export default function pushable(Klass: SourceClass): void {<EOL>    let proto = Klass.prototype;<EOL>    if (isPushable(proto)) {<EOL>        return;<EOL>    }<EOL>    assert('<STR_LIT>', proto instanceof Source);<EOL>    proto[PUSHABLE] = true;<EOL>    proto.push = function (transformOrOperations: TransformOrOperations, options?: object, id?: string): Promise<Transform[]> {<EOL>        const transform = buildTransform(transformOrOperations, options, id, this.transformBuilder);<EOL>        if (this.transformLog.contains(transform.id)) {<EOL>            return Orbit.Promise.resolve([]);<EOL>        }<EOL>        return this._enqueueRequest('<STR_LIT>', transform);<EOL>    };<EOL>    proto.__push__ = function (transform: Transform): Promise<Transform[]> {<EOL>        if (this.","gt":"transformLog.contains(transform.id)) {"}
{"input":"<s> /**<EOL> * Marks a source as \"pushable\" and adds an implementation of the `Pushable`<EOL> * interface.<EOL> *<EOL> * The `push` method is part of the \"request flow\" in Orbit. Requests trigger<EOL> * events before and after processing of each request. Observers can delay the<EOL> * resolution of a request by returning a promise in an event listener.<EOL> *<EOL> * A pushable source emits the following events:<EOL> *<EOL> * - `beforePush` - emitted prior to the processing of `push`, this event<EOL> * includes the requested `Transform` as an argument.<EOL> *<EOL> * - `push` - emitted after a `push` has successfully been applied, this event's<EOL> * arguments include both the requested `Transform` and an array of the actual<EOL> * applied `Transform` instances.<EOL> *<EOL> * - `pushFail` - emitted when an error has occurred pushing a transform, this<EOL> * event's arguments include both the requested `Transform` and the error.<EOL> *<EOL> * A pushable source must implement a private method `_push`, which performs<EOL> * the processing required for `push` and returns a promise that resolves to an<EOL> * array of `Transform` instances.<EOL> *<EOL> * @export<EOL> * @decorator<EOL> * @param {SourceClass} Klass<EOL> * @returns {void}<EOL> */<EOL>export default function pushable(Klass: SourceClass): void {<EOL>    let proto = Klass.prototype;<EOL>    if (isPushable(proto)) {<EOL>        return;<EOL>    }<EOL>    assert('<STR_LIT>', proto instanceof Source);<EOL>    proto[PUSHABLE] = true;<EOL>    proto.push = function (transformOrOperations: TransformOrOperations, options?: object, id?: string): Promise<Transform[]> {<EOL>        const transform = buildTransform(transformOrOperations, options, id, this.transformBuilder);<EOL>        if (this.transformLog.contains(transform.id)) {<EOL>            return Orbit.Promise.resolve([]);<EOL>        }<EOL>        return this._enqueueRequest('<STR_LIT>', transform);<EOL>    };<EOL>    proto.__push__ = function (transform: Transform): Promise<Transform[]> {<EOL>        if (this.transformLog.contains(transform.id)) {<EOL>            return Orbit.Promise.resolve([]);<EOL>        }<EOL>        return fulfillInSeries(this, '<STR_LIT>', transform)<EOL>            .then(() => {<EOL>            if (this.","gt":"transformLog.contains(transform.id)) {"}
{"input":"<s> /**<EOL> * Marks a source as \"pushable\" and adds an implementation of the `Pushable`<EOL> * interface.<EOL> *<EOL> * The `push` method is part of the \"request flow\" in Orbit. Requests trigger<EOL> * events before and after processing of each request. Observers can delay the<EOL> * resolution of a request by returning a promise in an event listener.<EOL> *<EOL> * A pushable source emits the following events:<EOL> *<EOL> * - `beforePush` - emitted prior to the processing of `push`, this event<EOL> * includes the requested `Transform` as an argument.<EOL> *<EOL> * - `push` - emitted after a `push` has successfully been applied, this event's<EOL> * arguments include both the requested `Transform` and an array of the actual<EOL> * applied `Transform` instances.<EOL> *<EOL> * - `pushFail` - emitted when an error has occurred pushing a transform, this<EOL> * event's arguments include both the requested `Transform` and the error.<EOL> *<EOL> * A pushable source must implement a private method `_push`, which performs<EOL> * the processing required for `push` and returns a promise that resolves to an<EOL> * array of `Transform` instances.<EOL> *<EOL> * @export<EOL> * @decorator<EOL> * @param {SourceClass} Klass<EOL> * @returns {void}<EOL> */<EOL>export default function pushable(Klass: SourceClass): void {<EOL>    let proto = Klass.prototype;<EOL>    if (isPushable(proto)) {<EOL>        return;<EOL>    }<EOL>    assert('<STR_LIT>', proto instanceof Source);<EOL>    proto[PUSHABLE] = true;<EOL>    proto.push = function (transformOrOperations: TransformOrOperations, options?: object, id?: string): Promise<Transform[]> {<EOL>        const transform = buildTransform(transformOrOperations, options, id, this.transformBuilder);<EOL>        if (this.transformLog.contains(transform.id)) {<EOL>            return Orbit.Promise.resolve([]);<EOL>        }<EOL>        return this._enqueueRequest('<STR_LIT>', transform);<EOL>    };<EOL>    proto.__push__ = function (transform: Transform): Promise<Transform[]> {<EOL>        if (this.transformLog.contains(transform.id)) {<EOL>            return Orbit.Promise.resolve([]);<EOL>        }<EOL>        return fulfillInSeries(this, '<STR_LIT>', transform)<EOL>            .then(() => {<EOL>            if (this.transformLog.contains(transform.id)) {<EOL>                return Orbit.Promise.resolve([]);<EOL>            }<EOL>            else {<EOL>                return this._push(transform)<EOL>                    .then(result => {<EOL>                    return this._transformed(result)<EOL>                        .then(() => settleInSeries(this, '<STR_LIT>', transform, result))<EOL>                        .","gt":"then(() => result);"}
{"input":"<s> /** Utility function to compare doubles (using Firestore semantics for NaN). */<EOL>function numericComparator(left: number, right: number): number {<EOL>    if (left < right) {<EOL>        return -<NUM_LIT>;<EOL>    }<EOL>    else if (left > right) {<EOL>        return <NUM_LIT>;<EOL>    }<EOL>    else if (left === right) {<EOL>        return <NUM_LIT>;<EOL>    }<EOL>","gt":"else {"}
{"input":"<s> /**<EOL> * Set the initial time given as soon as possible on the video element.<EOL> * Emit \"null\" when done.<EOL> * @param {HMTLMediaElement} videoElement<EOL> * @param {number} startTime<EOL> * @returns {Observable}<EOL> */<EOL>function doInitialSeek(videoElement: HTMLMediaElement, startTime: number): Observable<void> {<EOL>    return hasLoadedMetadata(videoElement)<EOL>        .do(() => {<EOL>        log.","gt":"info(\"<STR_LIT>\", startTime);"}
{"input":"<s> /**<EOL> * Translate groups of 4 little-endian bytes to Integer.<EOL> * @param {Uint8Array} bytes<EOL> * @param {Number} offset - The offset (from the start of the given array)<EOL> * @returns {Number}<EOL> */<EOL>function le4toi(bytes: Uint8Array, offset: number): number {<EOL>    return ((bytes[offset + <NUM_LIT>]) +<EOL>        (bytes[","gt":"offset + <NUM_LIT>] * <NUM_LIT>) +"}
{"input":"<s> export function trimLabel(s, max = <NUM_LIT>): string {<EOL>    if (typeof s !== '<STR_LIT>') {<EOL>        if (typeof s === '<STR_LIT>') {<EOL>            return s + '<STR_LIT>';<EOL>        }<EOL>","gt":"else {"}
{"input":"<s> export function trimLabel(s, max = <NUM_LIT>): string {<EOL>    if (typeof s !== '<STR_LIT>') {<EOL>        if (typeof s === '<STR_LIT>') {<EOL>            return s + '<STR_LIT>';<EOL>        }<EOL>        else {<EOL>            return '<STR_LIT>';<EOL>        }<EOL>    }<EOL>","gt":"s = s.trim();"}
{"input":"<s> /**<EOL> * @param {TimeRanges} timeRanges<EOL> * @param {Number} time<EOL> * @returns {Object} - Object with two properties:<EOL> *   - outerRanges {Array.<Object>}: every ranges which does not contain the<EOL> *     given time.<EOL> *   - innerRange {Object|null}: the range which contain the given time.<EOL> */<EOL>function getInnerAndOuterTimeRanges(timeRanges: TimeRanges, time: number): {<EOL>    innerRange: IRange | null;<EOL>    outerRanges: IRange[];<EOL>} {<EOL>    let innerRange: IRange | null = null;<EOL>    const outerRanges: IRange[] = [];<EOL>    for (let i = <NUM_LIT>; i < timeRanges.length; i++) {<EOL>        const start = timeRanges.start(","gt":"i);"}
{"input":"<s> /**<EOL> * @param {TimeRanges} timeRanges<EOL> * @param {Number} time<EOL> * @returns {Object} - Object with two properties:<EOL> *   - outerRanges {Array.<Object>}: every ranges which does not contain the<EOL> *     given time.<EOL> *   - innerRange {Object|null}: the range which contain the given time.<EOL> */<EOL>function getInnerAndOuterTimeRanges(timeRanges: TimeRanges, time: number): {<EOL>    innerRange: IRange | null;<EOL>    outerRanges: IRange[];<EOL>} {<EOL>    let innerRange: IRange | null = null;<EOL>    const outerRanges: IRange[] = [];<EOL>    for (let i = <NUM_LIT>; i < timeRanges.length; i++) {<EOL>        const start = timeRanges.start(i);<EOL>        const end = timeRanges.end(i);<EOL>        if (time < start || time >= end) {<EOL>            outerRanges.push({ start, end });<EOL>        }<EOL>        else {<EOL>            innerRange = {","gt":"start, end };"}
{"input":"<s> /**<EOL> * Insert a range object into an array of ranges objects, at the right place.<EOL> * /!\\ Mutate the array of ranges.<EOL> * @param {Array.<Object>} ranges<EOL> * @param {Object} rangeToAddArg<EOL> * @returns {Array.<Object>}<EOL> */<EOL>function insertInto(ranges: IRange[], rangeToAddArg: IRange): IRange[] {<EOL>    if (rangeToAddArg.start === rangeToAddArg.end) {<EOL>        return ranges;<EOL>    }<EOL>","gt":"let rangeToAdd: IRange = rangeToAddArg;"}
{"input":"<s> /**<EOL> * Insert a range object into an array of ranges objects, at the right place.<EOL> * /!\\ Mutate the array of ranges.<EOL> * @param {Array.<Object>} ranges<EOL> * @param {Object} rangeToAddArg<EOL> * @returns {Array.<Object>}<EOL> */<EOL>function insertInto(ranges: IRange[], rangeToAddArg: IRange): IRange[] {<EOL>    if (rangeToAddArg.start === rangeToAddArg.end) {<EOL>        return ranges;<EOL>    }<EOL>    let rangeToAdd: IRange = rangeToAddArg;<EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    let index = <NUM_LIT>;<EOL>    for (; index < ranges.length; index++) {<EOL>        const range =","gt":"ranges[index];"}
{"input":"<s> /**<EOL> * Insert a range object into an array of ranges objects, at the right place.<EOL> * /!\\ Mutate the array of ranges.<EOL> * @param {Array.<Object>} ranges<EOL> * @param {Object} rangeToAddArg<EOL> * @returns {Array.<Object>}<EOL> */<EOL>function insertInto(ranges: IRange[], rangeToAddArg: IRange): IRange[] {<EOL>    if (rangeToAddArg.start === rangeToAddArg.end) {<EOL>        return ranges;<EOL>    }<EOL>    let rangeToAdd: IRange = rangeToAddArg;<EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    let index = <NUM_LIT>;<EOL>    for (; index < ranges.length; index++) {<EOL>        const range = ranges[index];<EOL>        const overlapping = areRangesOverlapping(rangeToAdd, range);<EOL>        const contiguous = areRangesNearlyContiguous(rangeToAdd, range);<EOL>        <EOL>        <EOL>","gt":"if (overlapping || contiguous) {"}
{"input":"<s> /**<EOL> * Insert a range object into an array of ranges objects, at the right place.<EOL> * /!\\ Mutate the array of ranges.<EOL> * @param {Array.<Object>} ranges<EOL> * @param {Object} rangeToAddArg<EOL> * @returns {Array.<Object>}<EOL> */<EOL>function insertInto(ranges: IRange[], rangeToAddArg: IRange): IRange[] {<EOL>    if (rangeToAddArg.start === rangeToAddArg.end) {<EOL>        return ranges;<EOL>    }<EOL>    let rangeToAdd: IRange = rangeToAddArg;<EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    let index = <NUM_LIT>;<EOL>    for (; index < ranges.length; index++) {<EOL>        const range = ranges[index];<EOL>        const overlapping = areRangesOverlapping(rangeToAdd, range);<EOL>        const contiguous = areRangesNearlyContiguous(rangeToAdd, range);<EOL>        <EOL>        <EOL>        if (overlapping || contiguous) {<EOL>            rangeToAdd = createRangeUnion(rangeToAdd, range);<EOL>            ranges.splice(index--, <NUM_LIT>);<EOL>        }<EOL>        else {<EOL>            <EOL>            if (index ===","gt":"<NUM_LIT>) {"}
{"input":"<s> /**<EOL> * Insert a range object into an array of ranges objects, at the right place.<EOL> * /!\\ Mutate the array of ranges.<EOL> * @param {Array.<Object>} ranges<EOL> * @param {Object} rangeToAddArg<EOL> * @returns {Array.<Object>}<EOL> */<EOL>function insertInto(ranges: IRange[], rangeToAddArg: IRange): IRange[] {<EOL>    if (rangeToAddArg.start === rangeToAddArg.end) {<EOL>        return ranges;<EOL>    }<EOL>    let rangeToAdd: IRange = rangeToAddArg;<EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    let index = <NUM_LIT>;<EOL>    for (; index < ranges.length; index++) {<EOL>        const range = ranges[index];<EOL>        const overlapping = areRangesOverlapping(rangeToAdd, range);<EOL>        const contiguous = areRangesNearlyContiguous(rangeToAdd, range);<EOL>        <EOL>        <EOL>        if (overlapping || contiguous) {<EOL>            rangeToAdd = createRangeUnion(rangeToAdd, range);<EOL>            ranges.splice(index--, <NUM_LIT>);<EOL>        }<EOL>        else {<EOL>            <EOL>            if (index === <NUM_LIT>) {<EOL>                if (isBefore(rangeToAdd, ranges[<NUM_LIT>])) {<EOL>                    <EOL>                    <EOL>                    <EOL>                    break;<EOL>                }<EOL>            }<EOL>            else {<EOL>                if (isBefore(ranges[index - <NUM_LIT>], rangeToAdd)<EOL>                    &&","gt":"isBefore(rangeToAdd, range)) {"}
{"input":"<s> export function removeClausedNodeChildren(nodes: Node[]) {<EOL>    removeChildrenWithFormatting({<EOL>","gt":"getSiblingFormatting: getClausedNodeChildFormatting,"}
{"input":"<s> function mockSendToTopicRequest(): nock.Scope {<EOL>    return nock(`<STR_LIT>`)<EOL>        .post(","gt":"FCM_SEND_PATH)"}
{"input":"<s> /**<EOL> * Calculates the Total Flex Grow<EOL> */<EOL>export function getTotalFlexGrow(columns: any[]) {<EOL>    let totalFlexGrow = <NUM_LIT>;<EOL>    for (","gt":"const c of columns) {"}
{"input":"<s> /**<EOL> * Converts strings from something to camel case<EOL> * http://stackoverflow.com/questions/10425287/convert-dash-separated-string-to-camelcase<EOL> */<EOL>export function camelCase(str: string): string {<EOL>    <EOL>    str = str.replace(/[^a-zA-Z0-9 ]/g, '<STR_LIT>');<EOL>    <EOL>    str = str.replace(","gt":"/([a-z](?=[A-Z]))/g, '<STR_LIT>');"}
{"input":"<s> /**<EOL> * Converts strings from something to camel case<EOL> * http://stackoverflow.com/questions/10425287/convert-dash-separated-string-to-camelcase<EOL> */<EOL>export function camelCase(str: string): string {<EOL>    <EOL>    str = str.replace(/[^a-zA-Z0-9 ]/g, '<STR_LIT>');<EOL>    <EOL>    str = str.replace(/([a-z](?=[A-Z]))/g, '<STR_LIT>');<EOL>    <EOL>    str = str.replace(/([^a-zA-Z0-9 ])|^[0-9]+/g, '<STR_LIT>').trim().toLowerCase();<EOL>    <EOL>    str = str.replace(/([ 0-9]+)([a-zA-Z])/g, function (a, b, c) {<EOL>","gt":"return b.trim() + c.toUpperCase();"}
{"input":"<s> export function testAuthTokenProvider(app) {<EOL>    let token_ = null;<EOL>    let nextToken_ = null;<EOL>    let hasNextToken_ = false;<EOL>","gt":"const listeners_ = [];"}
{"input":"<s> export function testAuthTokenProvider(app) {<EOL>    let token_ = null;<EOL>    let nextToken_ = null;<EOL>    let hasNextToken_ = false;<EOL>    const listeners_ = [];<EOL>    app['<STR_LIT>'] = app['<STR_LIT>'] || {};<EOL>","gt":"app['<STR_LIT>']['<STR_LIT>'] = function (forceRefresh) {"}
{"input":"<s> export function testAuthTokenProvider(app) {<EOL>    let token_ = null;<EOL>    let nextToken_ = null;<EOL>    let hasNextToken_ = false;<EOL>    const listeners_ = [];<EOL>    app['<STR_LIT>'] = app['<STR_LIT>'] || {};<EOL>    app['<STR_LIT>']['<STR_LIT>'] = function (forceRefresh) {<EOL>        if (forceRefresh && hasNextToken_) {<EOL>","gt":"token_ = nextToken_;"}
{"input":"<s> export function testAuthTokenProvider(app) {<EOL>    let token_ = null;<EOL>    let nextToken_ = null;<EOL>    let hasNextToken_ = false;<EOL>    const listeners_ = [];<EOL>    app['<STR_LIT>'] = app['<STR_LIT>'] || {};<EOL>    app['<STR_LIT>']['<STR_LIT>'] = function (forceRefresh) {<EOL>        if (forceRefresh && hasNextToken_) {<EOL>            token_ = nextToken_;<EOL>            hasNextToken_ = false;<EOL>        }<EOL>        return Promise.resolve({ accessToken: token_ });<EOL>    };<EOL>    app['<STR_LIT>'][","gt":"'<STR_LIT>'] = function (listener) {"}
{"input":"<s> export function testAuthTokenProvider(app) {<EOL>    let token_ = null;<EOL>    let nextToken_ = null;<EOL>    let hasNextToken_ = false;<EOL>    const listeners_ = [];<EOL>    app['<STR_LIT>'] = app['<STR_LIT>'] || {};<EOL>    app['<STR_LIT>']['<STR_LIT>'] = function (forceRefresh) {<EOL>        if (forceRefresh && hasNextToken_) {<EOL>            token_ = nextToken_;<EOL>            hasNextToken_ = false;<EOL>        }<EOL>        return Promise.resolve({ accessToken: token_ });<EOL>    };<EOL>    app['<STR_LIT>']['<STR_LIT>'] = function (listener) {<EOL>        const token = token_;<EOL>        listeners_.push(listener);<EOL>        const async = Promise.resolve();<EOL>        async.then(function () {<EOL>","gt":"listener(token);"}
{"input":"<s> export function testAuthTokenProvider(app) {<EOL>    let token_ = null;<EOL>    let nextToken_ = null;<EOL>    let hasNextToken_ = false;<EOL>    const listeners_ = [];<EOL>    app['<STR_LIT>'] = app['<STR_LIT>'] || {};<EOL>    app['<STR_LIT>']['<STR_LIT>'] = function (forceRefresh) {<EOL>        if (forceRefresh && hasNextToken_) {<EOL>            token_ = nextToken_;<EOL>            hasNextToken_ = false;<EOL>        }<EOL>        return Promise.resolve({ accessToken: token_ });<EOL>    };<EOL>    app['<STR_LIT>']['<STR_LIT>'] = function (listener) {<EOL>        const token = token_;<EOL>        listeners_.push(listener);<EOL>        const async = Promise.resolve();<EOL>        async.then(function () {<EOL>            listener(token);<EOL>        });<EOL>    };<EOL>    app['<STR_LIT>']['<STR_LIT>'] = function (listener) {<EOL>        throw Error(","gt":"'<STR_LIT>');"}
{"input":"<s> export function testAuthTokenProvider(app) {<EOL>    let token_ = null;<EOL>    let nextToken_ = null;<EOL>    let hasNextToken_ = false;<EOL>    const listeners_ = [];<EOL>    app['<STR_LIT>'] = app['<STR_LIT>'] || {};<EOL>    app['<STR_LIT>']['<STR_LIT>'] = function (forceRefresh) {<EOL>        if (forceRefresh && hasNextToken_) {<EOL>            token_ = nextToken_;<EOL>            hasNextToken_ = false;<EOL>        }<EOL>        return Promise.resolve({ accessToken: token_ });<EOL>    };<EOL>    app['<STR_LIT>']['<STR_LIT>'] = function (listener) {<EOL>        const token = token_;<EOL>        listeners_.push(listener);<EOL>        const async = Promise.resolve();<EOL>        async.then(function () {<EOL>            listener(token);<EOL>        });<EOL>    };<EOL>    app['<STR_LIT>']['<STR_LIT>'] = function (listener) {<EOL>        throw Error('<STR_LIT>');<EOL>    };<EOL>    return {<EOL>        setToken: function (token) {<EOL>            token_ = token;<EOL>            const async = Promise.resolve();<EOL>            for (let i = <NUM_LIT>; i < listeners_.length; i++) {<EOL>                async.then((function (idx) {<EOL>                    return function () {<EOL>                        listeners_[idx](","gt":"token);"}
{"input":"<s> function pieceHash(piece: DrawShapePiece): Hash {<EOL>    return [piece.color, piece.role, piece.scale].filter(x => x).","gt":"join('<STR_LIT>');"}
{"input":"<s> export function setPieces(state: State, pieces: cg.PiecesDiff): void {<EOL>    for (let key in pieces) {<EOL>        const piece = pieces[key];<EOL>","gt":"if (piece)"}
{"input":"<s> function baseUserMove(state: State, orig: cg.Key, dest: cg.Key): cg.Piece | boolean {<EOL>    const result = baseMove(state, orig, dest);<EOL>    if (result) {<EOL>        state.","gt":"movable.dests = undefined;"}
{"input":"<s> export default function premove(pieces: cg.Pieces, key: cg.Key, canCastle: boolean): cg.Key[] {<EOL>    const piece = pieces[key], pos = util.key2pos(key);<EOL>    let mobility: Mobility;<EOL>    switch (piece.role) {<EOL>        case '<STR_LIT>':<EOL>","gt":"mobility = pawn(piece.color);"}
{"input":"<s> export default function premove(pieces: cg.Pieces, key: cg.Key, canCastle: boolean): cg.Key[] {<EOL>    const piece = pieces[key], pos = util.key2pos(key);<EOL>    let mobility: Mobility;<EOL>    switch (piece.role) {<EOL>        case '<STR_LIT>':<EOL>            mobility = pawn(piece.color);<EOL>            break;<EOL>        case '<STR_LIT>':<EOL>","gt":"mobility = knight;"}
{"input":"<s> export default function premove(pieces: cg.Pieces, key: cg.Key, canCastle: boolean): cg.Key[] {<EOL>    const piece = pieces[key], pos = util.key2pos(key);<EOL>    let mobility: Mobility;<EOL>    switch (piece.role) {<EOL>        case '<STR_LIT>':<EOL>            mobility = pawn(piece.color);<EOL>            break;<EOL>        case '<STR_LIT>':<EOL>            mobility = knight;<EOL>            break;<EOL>        case '<STR_LIT>':<EOL>            mobility =","gt":"bishop;"}
{"input":"<s> export default function premove(pieces: cg.Pieces, key: cg.Key, canCastle: boolean): cg.Key[] {<EOL>    const piece = pieces[key], pos = util.key2pos(key);<EOL>    let mobility: Mobility;<EOL>    switch (piece.role) {<EOL>        case '<STR_LIT>':<EOL>            mobility = pawn(piece.color);<EOL>            break;<EOL>        case '<STR_LIT>':<EOL>            mobility = knight;<EOL>            break;<EOL>        case '<STR_LIT>':<EOL>            mobility = bishop;<EOL>            break;<EOL>        case '<STR_LIT>':<EOL>","gt":"mobility = rook;"}
{"input":"<s> export default function premove(pieces: cg.Pieces, key: cg.Key, canCastle: boolean): cg.Key[] {<EOL>    const piece = pieces[key], pos = util.key2pos(key);<EOL>    let mobility: Mobility;<EOL>    switch (piece.role) {<EOL>        case '<STR_LIT>':<EOL>            mobility = pawn(piece.color);<EOL>            break;<EOL>        case '<STR_LIT>':<EOL>            mobility = knight;<EOL>            break;<EOL>        case '<STR_LIT>':<EOL>            mobility = bishop;<EOL>            break;<EOL>        case '<STR_LIT>':<EOL>            mobility = rook;<EOL>            break;<EOL>        case '<STR_LIT>':<EOL>            mobility = queen;<EOL>            break;<EOL>","gt":"case '<STR_LIT>':"}
{"input":"<s> export function exec(s: string, opts: {<EOL>    silent: boolean;<EOL>} = { silent: !DEBUG }, cb?: any): {<EOL>    stdout: string;<EOL>    code: number;<EOL>} {<EOL>    debug(s);<EOL>    let result = shell.exec(s, opts, cb);<EOL>    if (result.code !== <NUM_LIT>) {<EOL>        console.error(","gt":"result.stdout);"}
{"input":"<s> function posZIndex(pos: cg.Pos, asWhite: boolean): string {<EOL>    let z = <NUM_LIT> + (pos[<NUM_LIT>] - <NUM_LIT>) * <NUM_LIT> + (<NUM_LIT> - pos[<NUM_LIT>]);<EOL>    if (","gt":"asWhite)"}
{"input":"<s> export function end(s: State, e: cg.MouchEvent): void {<EOL>    const cur = s.draggable.current;<EOL>    if (!cur)<EOL>        return;<EOL>    <EOL>    <EOL>    if (e.type === '<STR_LIT>' && cur && cur.originTarget !== e.target && !cur.newPiece) {<EOL>","gt":"s.draggable.current = undefined;"}
{"input":"<s> export function end(s: State, e: cg.MouchEvent): void {<EOL>    const cur = s.draggable.current;<EOL>    if (!cur)<EOL>        return;<EOL>    <EOL>    <EOL>    if (e.type === '<STR_LIT>' && cur && cur.originTarget !== e.target && !cur.newPiece) {<EOL>        s.draggable.current = undefined;<EOL>        return;<EOL>    }<EOL>    board.unsetPremove(s);<EOL>    board.unsetPredrop(s);<EOL>    <EOL>    const eventPos: cg.NumberPair = util.eventPosition(e) || cur.epos;<EOL>    const dest = board.getKeyAtDomPos(eventPos, s.orientation === '<STR_LIT>', s.dom.bounds());<EOL>    if (dest && cur.started) {<EOL>        if (","gt":"cur.newPiece)"}
{"input":"<s> export function end(s: State, e: cg.MouchEvent): void {<EOL>    const cur = s.draggable.current;<EOL>    if (!cur)<EOL>        return;<EOL>    <EOL>    <EOL>    if (e.type === '<STR_LIT>' && cur && cur.originTarget !== e.target && !cur.newPiece) {<EOL>        s.draggable.current = undefined;<EOL>        return;<EOL>    }<EOL>    board.unsetPremove(s);<EOL>    board.unsetPredrop(s);<EOL>    <EOL>    const eventPos: cg.NumberPair = util.eventPosition(e) || cur.epos;<EOL>    const dest = board.getKeyAtDomPos(eventPos, s.orientation === '<STR_LIT>', s.dom.bounds());<EOL>    if (dest && cur.started) {<EOL>        if (cur.newPiece)<EOL>            board.dropNewPiece(s, cur.orig, dest, cur.force);<EOL>        else {<EOL>            s.stats.ctrlKey = e.ctrlKey;<EOL>            if (board.userMove(","gt":"s, cur.orig, dest))"}
{"input":"<s> export function end(s: State, e: cg.MouchEvent): void {<EOL>    const cur = s.draggable.current;<EOL>    if (!cur)<EOL>        return;<EOL>    <EOL>    <EOL>    if (e.type === '<STR_LIT>' && cur && cur.originTarget !== e.target && !cur.newPiece) {<EOL>        s.draggable.current = undefined;<EOL>        return;<EOL>    }<EOL>    board.unsetPremove(s);<EOL>    board.unsetPredrop(s);<EOL>    <EOL>    const eventPos: cg.NumberPair = util.eventPosition(e) || cur.epos;<EOL>    const dest = board.getKeyAtDomPos(eventPos, s.orientation === '<STR_LIT>', s.dom.bounds());<EOL>    if (dest && cur.started) {<EOL>        if (cur.newPiece)<EOL>            board.dropNewPiece(s, cur.orig, dest, cur.force);<EOL>        else {<EOL>            s.stats.ctrlKey = e.ctrlKey;<EOL>            if (board.userMove(s, cur.orig, dest))<EOL>                s.stats.dragged = true;<EOL>        }<EOL>    }<EOL>    else if (cur.newPiece) {<EOL>        delete s.pieces[cur.orig];<EOL>    }<EOL>    else if (s.draggable.deleteOnDropOff) {<EOL>        delete s.pieces[","gt":"cur.orig];"}
{"input":"<s> export function annotated(annotation: AnnotationData, sl: Sourcelike): Source {<EOL>    return {<EOL>","gt":"kind: \"<STR_LIT>\","}
{"input":"<s> function replaceUnion(u: UnionType, builder: GraphRewriteBuilder<StringType | UnionType>, forwardingRef: TypeRef): TypeRef {<EOL>    const stringMembers = defined(unionNeedsReplacing(u));<EOL>    const types: TypeRef[] = [];<EOL>    u.members.forEach(t => {<EOL>","gt":"if (stringMembers.has(t))"}
{"input":"<s> function replaceUnion(u: UnionType, builder: GraphRewriteBuilder<StringType | UnionType>, forwardingRef: TypeRef): TypeRef {<EOL>    const stringMembers = defined(unionNeedsReplacing(u));<EOL>    const types: TypeRef[] = [];<EOL>    u.members.forEach(t => {<EOL>        if (stringMembers.has(t))<EOL>            return;<EOL>        types.push(builder.reconstituteType(t));<EOL>    });<EOL>    <EOL>    if (types.length === <NUM_LIT>) {<EOL>        return builder.getStringType(","gt":"undefined, undefined, forwardingRef);"}
{"input":"<s> export function isLetter(codePoint: number): boolean {<EOL>","gt":"const category = unicode.getCategory(codePoint);"}
{"input":"<s> function randomInt(lower: number, upper: number) {<EOL>    const range = upper -","gt":"lower;"}
{"input":"<s> function unionMembersRecursively(...unions: UnionType[]): OrderedSet<Type> {<EOL>    let processedUnions = Set<UnionType>();<EOL>    let members = OrderedSet<Type>();<EOL>    function addMembers(u: UnionType): void {<EOL>        if (processedUnions.has(u))<EOL>            return;<EOL>        processedUnions = processedUnions.add(","gt":"u);"}
{"input":"<s> function unionMembersRecursively(...unions: UnionType[]): OrderedSet<Type> {<EOL>    let processedUnions = Set<UnionType>();<EOL>    let members = OrderedSet<Type>();<EOL>    function addMembers(u: UnionType): void {<EOL>        if (processedUnions.has(u))<EOL>            return;<EOL>        processedUnions = processedUnions.add(u);<EOL>        u.members.forEach(t => {<EOL>            if (t instanceof UnionType) {<EOL>                addMembers(t);<EOL>            }<EOL>","gt":"else {"}
{"input":"<s> function rustStyle(original: string, isSnakeCase: boolean): string {<EOL>    const words = splitIntoWords(original);<EOL>    const wordStyle =","gt":"isSnakeCase ? allLowerWordStyle : firstUpperWordStyle;"}
{"input":"<s> export default function (): void {<EOL>    describe(\"<STR_LIT>\", () => {<EOL>        let buttonInGroupService: ButtonInGroupService;<EOL>        beforeEach(() => {<EOL>            buttonInGroupService = new ButtonInGroupService();<EOL>        });<EOL>        it(","gt":"\"<STR_LIT>\", () => {"}
{"input":"<s> export default function (): void {<EOL>    describe(\"<STR_LIT>\", () => {<EOL>        let buttonInGroupService: ButtonInGroupService;<EOL>        beforeEach(() => {<EOL>            buttonInGroupService = new ButtonInGroupService();<EOL>        });<EOL>        it(\"<STR_LIT>\", () => {<EOL>            let testButton: any;<EOL>            buttonInGroupService.changes.subscribe((button) => {<EOL>                testButton = button;<EOL>            });<EOL>            const mockButton: ClrButton = new ClrButton(null);<EOL>            mockButton.inMenu = true;<EOL>","gt":"buttonInGroupService.updateButtonGroup(mockButton);"}
{"input":"<s> /**<EOL> * Verifies a token is signed with the private key corresponding to the provided public key.<EOL> *<EOL> * @param {string} token The token to verify.<EOL> * @param {string} publicKey The public key to use to verify the token.<EOL> * @return {Promise<object>} A promise fulfilled with the decoded token if it is valid; otherwise, a rejected promise.<EOL> */<EOL>function verifyToken(token: string, publicKey: string): Promise<object> {<EOL>    return new Promise((resolve, reject) => {<EOL>        jwt.verify(token, publicKey, {<EOL>            algorithms: [ALGORITHM],<EOL>        }, (err,","gt":"res) => {"}
{"input":"<s> function isPartCharacter(utf16Unit: number): boolean {<EOL>","gt":"const category: string = unicode.getCategory(utf16Unit);"}
{"input":"<s> /**<EOL> * Recursively detach all nodes.<EOL> */<EOL>export function vNodeDetach(vnode: VNode): void {<EOL>    if (\"<STR_LIT>\" as string !== \"<STR_LIT>\") {<EOL>        if ((vnode._debugFlags & VNodeDebugFlags.Detached) !== <NUM_LIT>) {<EOL>            throw new Error(\"<STR_LIT>\");<EOL>        }<EOL>        vnode._debugFlags |= VNodeDebugFlags.Detached;<EOL>        vnode.","gt":"_debugFlags &= ~VNodeDebugFlags.Attached;"}
{"input":"<s> /**<EOL> * Recursively detach all nodes.<EOL> */<EOL>export function vNodeDetach(vnode: VNode): void {<EOL>    if (\"<STR_LIT>\" as string !== \"<STR_LIT>\") {<EOL>        if ((vnode._debugFlags & VNodeDebugFlags.Detached) !== <NUM_LIT>) {<EOL>            throw new Error(\"<STR_LIT>\");<EOL>        }<EOL>        vnode._debugFlags |= VNodeDebugFlags.Detached;<EOL>        vnode._debugFlags &= ~VNodeDebugFlags.Attached;<EOL>    }<EOL>    if ((vnode._flags & VNodeFlags.Component) === <NUM_LIT>) {<EOL>        const children = vnode._children;<EOL>        if (children !==","gt":"null && typeof children !== \"<STR_LIT>\") {"}
{"input":"<s> /**<EOL> * Safely checks if the number is NaN.<EOL> */<EOL>export function safeIsNaN(value: AnyJs): boolean {<EOL>    if (NumberAsAny.IsNaN) {<EOL>        return NumberAsAny.","gt":"IsNaN(value);"}
{"input":"<s> function mutateMsgWithLiveExtras(api: any) {<EOL>    return (msg: Msg) => {<EOL>        if (isMsg(msg)) {<EOL>            const likes = api.message.obs.likes[<NUM_LIT>](msg.key);<EOL>            const name =","gt":"api.about.obs.name[<NUM_LIT>](msg.value.author);"}
{"input":"<s> /** Compares the input details and the saved ones  */<EOL>export function compareDetails(input: InputDetails, saved: Object, now: number): void {<EOL>    const subscriptionKeys = ['<STR_LIT>', '<STR_LIT>', '<STR_LIT>'];<EOL>    const subscriptionValues = {<EOL>        endpoint: input.subscription.endpoint,<EOL>        auth: arrayBufferToBase64(input.subscription.getKey('<STR_LIT>')),<EOL>        p256dh:","gt":"arrayBufferToBase64(input.subscription.getKey('<STR_LIT>'))"}
{"input":"<s> /** Compares the input details and the saved ones  */<EOL>export function compareDetails(input: InputDetails, saved: Object, now: number): void {<EOL>    const subscriptionKeys = ['<STR_LIT>', '<STR_LIT>', '<STR_LIT>'];<EOL>    const subscriptionValues = {<EOL>        endpoint: input.subscription.endpoint,<EOL>        auth: arrayBufferToBase64(input.subscription.getKey('<STR_LIT>')),<EOL>        p256dh: arrayBufferToBase64(input.subscription.getKey('<STR_LIT>'))<EOL>    };<EOL>    subscriptionKeys.forEach(keyName => {<EOL>        assert.equal(saved[keyName],","gt":"subscriptionValues[keyName]);"}
{"input":"<s> export default function App(sources: Sources): Sinks {<EOL>    const calculatorSinks = Calculator(sources);<EOL>    const vdom$ = view(calculatorSinks.DOM);<EOL>    const reducer$ = calculatorSinks.","gt":"onion;"}
{"input":"<s> export function isMsg(msg: any): msg is Msg<any> {<EOL>    return msg && msg.key &&","gt":"msg.value && typeof msg.value === '<STR_LIT>';"}
{"input":"<s> function makeGetter<T, R>(scope: Scope<T, R>): Getter<T, R> {<EOL>    if (typeof scope === '<STR_LIT>' || typeof scope === '<STR_LIT>') {<EOL>        return function lensGet(state) {<EOL>            if (typeof state === '<STR_LIT>') {<EOL>                return void","gt":"<NUM_LIT>;"}
{"input":"<s> /**<EOL> * Run the given scanner on the given package relative url.<EOL> *<EOL> * The url must be loadable with the given analyzer.<EOL> */<EOL>export async function runScanner(analyzer: Analyzer, scanner: Scanner<ParsedDocument, any, any>, url: string): Promise<{<EOL>    features: ScannedFeature[];<EOL>    warnings: Warning[];<EOL>}> {<EOL>    const context = await analyzer['<STR_LIT>'];<EOL>","gt":"const resolvedUrl = analyzer.resolveUrl(url)!;"}
{"input":"<s> /**<EOL> * Removes entries from from the given a batches and returns them.<EOL> *<EOL> * @param holes An array of indexes in the batches array; in increasing order.<EOL> * Indexes are relative to the original state of the batches array, not any<EOL> * intermediate state that might occur.<EOL> * @param batches The array to mutate, removing entries from it.<EOL> * @return A new array containing all the entries that were removed from<EOL> * batches.<EOL> */<EOL>async function makeHolesInBatches(holes: number[], batches: MutationBatch[]): Promise<MutationBatch[]> {<EOL>    const removed = [];<EOL>    for (let i = <NUM_LIT>; i < holes.length; i++) {<EOL>        const index = holes[","gt":"i] - i;"}
{"input":"<s> <EOL>/** @internal */<EOL>export function resourceToInstanceAndPath(resource) {<EOL>    let resourceRegex = `<STR_LIT>`;<EOL>    let match = resource.match(new RegExp(resourceRegex));<EOL>    if (!match) {<EOL>        throw","gt":"new Error(`<STR_LIT>` +"}
{"input":"<s> export function IpValidator(control: FormControl): ValidationErrors {<EOL>    return /(\\d{1,3}\\.){3}\\d{1,3}/.test(control.value) ? null : {","gt":"'<STR_LIT>': true };"}
{"input":"<s> function requestInvite$(invitationUrl: string): Rx.Observable<superagent.Response> {<EOL>","gt":"const request = superagent(invitationUrl);"}
{"input":"<s> export function startListening(el: HTMLElement, eventName: string, listener: (event: Event) => boolean | void) {<EOL>    el.addEventListener(eventName,","gt":"listener);"}
{"input":"<s> export function minValidationMessage(err, field) {<EOL>    return","gt":"field.templateOptions.min}`<STR_LIT>;"}
{"input":"<s> function serializeElementLike(elementOrMixin: ElementOrMixin, urlResolver: UrlResolver): ElementLike {<EOL>    const class_ = serializeClass(elementOrMixin, urlResolver) as ElementLike;<EOL>    let path: undefined | ResolvedUrl;<EOL>    if (elementOrMixin.sourceRange) {<EOL>        path = elementOrMixin.sourceRange.file;<EOL>    }<EOL>    class_.attributes =<EOL>        Array.from(elementOrMixin.attributes.values())<EOL>            .map((a) =>","gt":"serializeAttribute(elementOrMixin, path, urlResolver, a));"}
{"input":"<s> function serializeElementLike(elementOrMixin: ElementOrMixin, urlResolver: UrlResolver): ElementLike {<EOL>    const class_ = serializeClass(elementOrMixin, urlResolver) as ElementLike;<EOL>    let path: undefined | ResolvedUrl;<EOL>    if (elementOrMixin.sourceRange) {<EOL>        path = elementOrMixin.sourceRange.file;<EOL>    }<EOL>    class_.attributes =<EOL>        Array.from(elementOrMixin.attributes.values())<EOL>            .map((a) => serializeAttribute(elementOrMixin, path, urlResolver, a));<EOL>    class_.events = Array.from(elementOrMixin.events.values())<EOL>        .map((e) => serializeEvent(elementOrMixin, path, e));<EOL>    Object.assign(class_, {<EOL>        styling: {<EOL>","gt":"cssVariables: [],"}
{"input":"<s> function serializeElementLike(elementOrMixin: ElementOrMixin, urlResolver: UrlResolver): ElementLike {<EOL>    const class_ = serializeClass(elementOrMixin, urlResolver) as ElementLike;<EOL>    let path: undefined | ResolvedUrl;<EOL>    if (elementOrMixin.sourceRange) {<EOL>        path = elementOrMixin.sourceRange.file;<EOL>    }<EOL>    class_.attributes =<EOL>        Array.from(elementOrMixin.attributes.values())<EOL>            .map((a) => serializeAttribute(elementOrMixin, path, urlResolver, a));<EOL>    class_.events = Array.from(elementOrMixin.events.values())<EOL>        .map((e) => serializeEvent(elementOrMixin, path, e));<EOL>    Object.assign(class_, {<EOL>        styling: {<EOL>            cssVariables: [],<EOL>            selectors: [],<EOL>        },<EOL>        slots: elementOrMixin.slots.map((s) => {<EOL>            return {<EOL>                description: '<STR_LIT>',<EOL>                name:","gt":"s.name,"}
{"input":"<s> function defaultItemScope(key: string) {<EOL>    return {","gt":"'<STR_LIT>': null };"}
{"input":"<s> function Function(dec: string, expr: string): expressions.Function {<EOL>    return new expressions.Function(dec,","gt":"new Json.JString(expr, <NUM_LIT>, <NUM_LIT>));"}
{"input":"<s> export function testFunctionParsing1(test) {<EOL>","gt":"var predicate = Function(\"<STR_LIT>\", \"<STR_LIT>\");"}
{"input":"<s> export function authorName(name: string | null, msg: Msg): string {<EOL>    return","gt":"name || msg.value.author.slice(<NUM_LIT>, <NUM_LIT>);"}
{"input":"<s> function createOwnerStore(db: IDBDatabase): void {<EOL>","gt":"db.createObjectStore(DbOwner.store);"}
{"input":"<s> export function testSanitizeQuotes1(test: nodeunit.Test): void {<EOL>    translationTestCase(\"<STR_LIT>\", \"<STR_LIT>\", new expressions.","gt":"Functions(), test);"}
{"input":"<s> /**<EOL> * Validates that the provided named option equals one of the expected values.<EOL> */<EOL>export function validateNamedPropertyEquals<T>(functionName: string, inputName: string, optionName: string, input: T, expected: T[]): void {<EOL>    const expectedDescription: string[] = [];<EOL>    for (const val of expected) {<EOL>        if (val ===","gt":"input) {"}
{"input":"<s> export function assertSetValidationRules(rules_str, test, cb) {<EOL>    setValidationRules(rules_str, function (err) {<EOL>        if (err) {<EOL>","gt":"test.ok(false);"}
{"input":"<s> export function scanDatabindingTemplateForExpressions(document: ParsedHtmlDocument, template: Template) {<EOL>    return","gt":"extractDataBindingsFromTemplates(document, [template].concat([...getAllDataBindingTemplates(template.content)]));"}
{"input":"<s> function _expandOptionPaths(options: {<EOL>    [key: string]: any;<EOL>}): any {<EOL>    const result = {};<EOL>    _.each(options, function (value, key) {<EOL>        let target = result;<EOL>        const","gt":"parts = key.split('<STR_LIT>');"}
{"input":"<s> function _expandOptionPaths(options: {<EOL>    [key: string]: any;<EOL>}): any {<EOL>    const result = {};<EOL>    _.each(options, function (value, key) {<EOL>        let target = result;<EOL>        const parts = key.split('<STR_LIT>');<EOL>        for (const part of parts.slice(<NUM_LIT>, -<NUM_LIT>)) {<EOL>            target = target[part] = target[part] || {};<EOL>        }<EOL>        target[_.","gt":"last(parts)] = value;"}
{"input":"<s> function createRenderTarget(id: string | null = null) {<EOL>    const element = document.createElement('<STR_LIT>');<EOL>    element.className = '<STR_LIT>';<EOL>    if (","gt":"id) {"}
{"input":"<s> export default function model(actions: Actions): Stream<Reducer<State>> {<EOL>    const initReducer$ = xs.of(function initReducer(prev: State): State {<EOL>        return prev || { apps: {}, backendReady: false };<EOL>    });<EOL>    const updateReducer$ = actions.updateFromBackend$.map(backendState => function updateAppsReducer(prev: State): State {<EOL>        let next: State | undefined = undefined;<EOL>        const","gt":"apps = backendState.apps;"}
{"input":"<s> export default function model(actions: Actions): Stream<Reducer<State>> {<EOL>    const initReducer$ = xs.of(function initReducer(prev: State): State {<EOL>        return prev || { apps: {}, backendReady: false };<EOL>    });<EOL>    const updateReducer$ = actions.updateFromBackend$.map(backendState => function updateAppsReducer(prev: State): State {<EOL>        let next: State | undefined = undefined;<EOL>        const apps = backendState.apps;<EOL>        if (prev.backendReady !== backendState.backendReady) {<EOL>            next = next || { ...prev };<EOL>            next.backendReady = backendState.backendReady;<EOL>        }<EOL>        Object.keys(apps).forEach(key => {<EOL>            if (!prev.apps[key]) {<EOL>                next = next || { ...","gt":"prev };"}
{"input":"<s> export default function model(actions: Actions): Stream<Reducer<State>> {<EOL>    const initReducer$ = xs.of(function initReducer(prev: State): State {<EOL>        return prev || { apps: {}, backendReady: false };<EOL>    });<EOL>    const updateReducer$ = actions.updateFromBackend$.map(backendState => function updateAppsReducer(prev: State): State {<EOL>        let next: State | undefined = undefined;<EOL>        const apps = backendState.apps;<EOL>        if (prev.backendReady !== backendState.backendReady) {<EOL>            next = next || { ...prev };<EOL>            next.backendReady = backendState.backendReady;<EOL>        }<EOL>        Object.keys(apps).forEach(key => {<EOL>            if (!prev.apps[key]) {<EOL>                next = next || { ...prev };<EOL>                next.apps[key] = apps[key];<EOL>            }<EOL>            else if (prev.apps[key].apkFullPath !== apps[key].apkFullPath) {<EOL>                next =","gt":"next || { ...prev };"}
{"input":"<s> export default function model(actions: Actions): Stream<Reducer<State>> {<EOL>    const initReducer$ = xs.of(function initReducer(prev: State): State {<EOL>        return prev || { apps: {}, backendReady: false };<EOL>    });<EOL>    const updateReducer$ = actions.updateFromBackend$.map(backendState => function updateAppsReducer(prev: State): State {<EOL>        let next: State | undefined = undefined;<EOL>        const apps = backendState.apps;<EOL>        if (prev.backendReady !== backendState.backendReady) {<EOL>            next = next || { ...prev };<EOL>            next.backendReady = backendState.backendReady;<EOL>        }<EOL>        Object.keys(apps).forEach(key => {<EOL>            if (!prev.apps[key]) {<EOL>                next = next || { ...prev };<EOL>                next.apps[key] = apps[key];<EOL>            }<EOL>            else if (prev.apps[key].apkFullPath !== apps[key].apkFullPath) {<EOL>                next = next || { ...prev };<EOL>                next.apps[key].apkFullPath = apps[key].apkFullPath;<EOL>            }<EOL>            else if (prev.apps[key].readme !== apps[key].readme) {<EOL>                next = next || { ...prev };<EOL>                next.apps[key].readme = apps[key].readme;<EOL>            }<EOL>            else if (prev.","gt":"apps[key].peers !== apps[key].peers) {"}
{"input":"<s> export function renderMatrixA(matrixA: VNode, state: State): VNode {<EOL>    const showResizers = state.step === <NUM_LIT>;<EOL>    return table(`<STR_LIT>`, [<EOL>        tr([<EOL>            td(showResizers ? [","gt":"renderRowsResizer('<STR_LIT>')] : []),"}
{"input":"<s> export function renderMatrixA(matrixA: VNode, state: State): VNode {<EOL>    const showResizers = state.step === <NUM_LIT>;<EOL>    return table(`<STR_LIT>`, [<EOL>        tr([<EOL>            td(showResizers ? [renderRowsResizer('<STR_LIT>')] : []),<EOL>            td(`<STR_LIT>`, {<EOL>                hook: { update: mutateCellStyles(state) }<EOL>            }, [matrixA, renderOperatorGrid(state)]),<EOL>        ]),<EOL>        tr([<EOL>","gt":"td(),"}
{"input":"<s> export function makeNormalUrl(urlPart: string): string {<EOL>    return","gt":"constants.domainBase + constants.apiBaseUrl + urlPart;"}
{"input":"<s> function findDatabindingInString(str: string) {<EOL>    const expressions: RawDatabinding[] = [];<EOL>    const openers = /{{|\\[\\[/g;<EOL>    let match;<EOL>    while (match = openers.exec(str)) {<EOL>        const matchedOpeners = match[<NUM_LIT>];<EOL>        const","gt":"startIndex = match.index + <NUM_LIT>;"}
{"input":"<s> function findDatabindingInString(str: string) {<EOL>    const expressions: RawDatabinding[] = [];<EOL>    const openers = /{{|\\[\\[/g;<EOL>    let match;<EOL>    while (match = openers.exec(str)) {<EOL>        const matchedOpeners = match[<NUM_LIT>];<EOL>        const startIndex = match.index + <NUM_LIT>;<EOL>        const direction = matchedOpeners === '<STR_LIT>' ? '<STR_LIT>' : '<STR_LIT>';<EOL>        const closers = matchedOpeners === '<STR_LIT>' ? '<STR_LIT>' : '<STR_LIT>';<EOL>        const endIndex = str.indexOf(closers, startIndex);<EOL>        if (endIndex === -<NUM_LIT>) {<EOL>            <EOL>            break;<EOL>        }<EOL>        const expressionText = str.slice(startIndex, endIndex);<EOL>        expressions.push({ startIndex, endIndex, expressionText,","gt":"direction });"}
{"input":"<s> /**<EOL> * Asserts that all records in the graph have had all of their dependencies<EOL> * resolved or rejected.<EOL> */<EOL>function assertGraphIsSettled(graph: DependencyGraph) {<EOL>    for (const record of graph['<STR_LIT>'].values()) {<EOL>        if (!(record.dependenciesDeferred.","gt":"resolved ||"}
{"input":"<s> function resetMockPages(): MockPage[] {<EOL>    return [new","gt":"MockPage(<NUM_LIT>), new MockPage(<NUM_LIT>), new MockPage(<NUM_LIT>)];"}
{"input":"<s> function getTypeFromAnnotation(jsdocAnn: jsdoc.Annotation): string | undefined {<EOL>    const typeTag = jsdoc.getTag(jsdocAnn, '<STR_LIT>');<EOL>","gt":"let type = undefined;"}
{"input":"<s> export function getBehaviorReference(argNode: babel.Node, document: JavaScriptDocument, scope: Scope): Result<ScannedReference, Warning> {<EOL>    const behaviorName = astValue.getIdentifierName(argNode);<EOL>    if (!behaviorName) {<EOL>        return {<EOL>            successful: false,<EOL>            error: new Warning({<EOL>                code:","gt":"'<STR_LIT>',"}
{"input":"<s> export function getBehaviorReference(argNode: babel.Node, document: JavaScriptDocument, scope: Scope): Result<ScannedReference, Warning> {<EOL>    const behaviorName = astValue.getIdentifierName(argNode);<EOL>    if (!behaviorName) {<EOL>        return {<EOL>            successful: false,<EOL>            error: new Warning({<EOL>                code: '<STR_LIT>',<EOL>                message: `<STR_LIT>` +<EOL>                    `<STR_LIT>`,<EOL>                severity: Severity.WARNING,<EOL>                sourceRange: document.","gt":"sourceRangeForNode(argNode)!,"}
{"input":"<s> export function cancelTests(context: Context): void {<EOL>    if (!context._testRunners) {<EOL>","gt":"return;"}
{"input":"<s> export function adapt(stream: Stream<any>): any {<EOL>    return getGlobal().adaptStream(","gt":"stream);"}
{"input":"<s> /**<EOL> * Return a new bundle array where all bundles within it matching the predicate<EOL> * are merged.<EOL> */<EOL>export function mergeMatchingBundles(bundles: Bundle[], predicate: (bundle: Bundle) => boolean): Bundle[] {<EOL>    const newBundles = Array.from(bundles);<EOL>    const bundlesToMerge = newBundles.filter(predicate);<EOL>    if (","gt":"bundlesToMerge.length > <NUM_LIT>) {"}
{"input":"<s> export default function (): void {<EOL>    describe((\"<STR_LIT>\"), function () {<EOL>        let vertNavService: VerticalNavIconService;<EOL>        beforeEach(() => {<EOL>","gt":"vertNavService = new VerticalNavIconService();"}
{"input":"<s> export default function (): void {<EOL>    describe((\"<STR_LIT>\"), function () {<EOL>        let vertNavService: VerticalNavIconService;<EOL>        beforeEach(() => {<EOL>            vertNavService = new VerticalNavIconService();<EOL>        });<EOL>        afterEach(() => {<EOL>","gt":"vertNavService = null;"}
{"input":"<s> export default function (): void {<EOL>    describe((\"<STR_LIT>\"), function () {<EOL>        let vertNavService: VerticalNavIconService;<EOL>        beforeEach(() => {<EOL>            vertNavService = new VerticalNavIconService();<EOL>        });<EOL>        afterEach(() => {<EOL>            vertNavService = null;<EOL>        });<EOL>        it(\"<STR_LIT>\", () => {<EOL>            expect(vertNavService.hasIcons).toBe(false);<EOL>            vertNavService.registerIcon();<EOL>            expect(vertNavService.hasIcons).toBe(","gt":"true);"}
{"input":"<s> export default function (): void {<EOL>    describe((\"<STR_LIT>\"), function () {<EOL>        let vertNavService: VerticalNavIconService;<EOL>        beforeEach(() => {<EOL>            vertNavService = new VerticalNavIconService();<EOL>        });<EOL>        afterEach(() => {<EOL>            vertNavService = null;<EOL>        });<EOL>        it(\"<STR_LIT>\", () => {<EOL>            expect(vertNavService.hasIcons).toBe(false);<EOL>            vertNavService.registerIcon();<EOL>            expect(vertNavService.hasIcons).toBe(true);<EOL>        });<EOL>        it(\"<STR_LIT>\", () => {<EOL>            expect(vertNavService.hasIcons).toBe(false);<EOL>","gt":"vertNavService.registerIcon();"}
{"input":"<s> function raiseError(err: any) {<EOL>","gt":"if (err) {"}
{"input":"<s> function mockTimeSource({ interval = <NUM_LIT> } = {}): any {<EOL>    let time = <NUM_LIT>;<EOL>    let maxTime = <NUM_LIT>;<EOL>    const asserts: Array<any> = [];<EOL>    let","gt":"done: any;"}
{"input":"<s> function mockTimeSource({ interval = <NUM_LIT> } = {}): any {<EOL>    let time = <NUM_LIT>;<EOL>    let maxTime = <NUM_LIT>;<EOL>    const asserts: Array<any> = [];<EOL>    let done: any;<EOL>    const scheduler = makeScheduler();<EOL>    function addAssert(","gt":"assert: any) {"}
{"input":"<s> function mockTimeSource({ interval = <NUM_LIT> } = {}): any {<EOL>    let time = <NUM_LIT>;<EOL>    let maxTime = <NUM_LIT>;<EOL>    const asserts: Array<any> = [];<EOL>    let done: any;<EOL>    const scheduler = makeScheduler();<EOL>    function addAssert(assert: any) {<EOL>        asserts.push(assert);<EOL>    }<EOL>    function currentTime() {<EOL>        return time;<EOL>    }<EOL>    function setTime(newTime: number) {<EOL>","gt":"time = newTime;"}
{"input":"<s> function mockTimeSource({ interval = <NUM_LIT> } = {}): any {<EOL>    let time = <NUM_LIT>;<EOL>    let maxTime = <NUM_LIT>;<EOL>    const asserts: Array<any> = [];<EOL>    let done: any;<EOL>    const scheduler = makeScheduler();<EOL>    function addAssert(assert: any) {<EOL>        asserts.push(assert);<EOL>    }<EOL>    function currentTime() {<EOL>        return time;<EOL>    }<EOL>    function setTime(newTime: number) {<EOL>        time = newTime;<EOL>    }<EOL>    function setMaxTime(newTime: number) {<EOL>        maxTime = Math.max(newTime, maxTime);<EOL>    }<EOL>","gt":"function createOperator() {"}
{"input":"<s> function mockTimeSource({ interval = <NUM_LIT> } = {}): any {<EOL>    let time = <NUM_LIT>;<EOL>    let maxTime = <NUM_LIT>;<EOL>    const asserts: Array<any> = [];<EOL>    let done: any;<EOL>    const scheduler = makeScheduler();<EOL>    function addAssert(assert: any) {<EOL>        asserts.push(assert);<EOL>    }<EOL>    function currentTime() {<EOL>        return time;<EOL>    }<EOL>    function setTime(newTime: number) {<EOL>        time = newTime;<EOL>    }<EOL>    function setMaxTime(newTime: number) {<EOL>        maxTime = Math.max(newTime, maxTime);<EOL>    }<EOL>    function createOperator() {<EOL>        return { schedule: scheduler.add, currentTime };<EOL>    }<EOL>    const timeSource = {<EOL>        diagram: makeDiagram(scheduler.add, currentTime, interval, setMaxTime),<EOL>        record: makeRecord(scheduler.add,","gt":"currentTime, interval),"}
{"input":"<s> function mockTimeSource({ interval = <NUM_LIT> } = {}): any {<EOL>    let time = <NUM_LIT>;<EOL>    let maxTime = <NUM_LIT>;<EOL>    const asserts: Array<any> = [];<EOL>    let done: any;<EOL>    const scheduler = makeScheduler();<EOL>    function addAssert(assert: any) {<EOL>        asserts.push(assert);<EOL>    }<EOL>    function currentTime() {<EOL>        return time;<EOL>    }<EOL>    function setTime(newTime: number) {<EOL>        time = newTime;<EOL>    }<EOL>    function setMaxTime(newTime: number) {<EOL>        maxTime = Math.max(newTime, maxTime);<EOL>    }<EOL>    function createOperator() {<EOL>        return { schedule: scheduler.add, currentTime };<EOL>    }<EOL>    const timeSource = {<EOL>        diagram: makeDiagram(scheduler.add, currentTime, interval, setMaxTime),<EOL>        record: makeRecord(scheduler.add, currentTime, interval),<EOL>        assertEqual: makeAssertEqual(() => timeSource, scheduler.add, currentTime, interval, addAssert),<EOL>        delay: makeDelay(createOperator),<EOL>        debounce: makeDebounce(createOperator),<EOL>        periodic: makePeriodic(createOperator),<EOL>        throttle: makeThrottle(createOperator),<EOL>        animationFrames: () => timeSource.periodic(<NUM_LIT>).map(frame),<EOL>        throttleAnimation: makeThrottleAnimation(() => timeSource, scheduler.add, currentTime),<EOL>        run(doneCallback = raiseError, timeToRunTo = <NUM_LIT>) {<EOL>","gt":"done = doneCallback;"}
{"input":"<s> function displayUnexpectedErrors(errors: Array<any>) {<EOL>    if (errors.length === <NUM_LIT>) {<EOL>","gt":"return `<STR_LIT>`;"}
{"input":"<s> export async function startControlServer(options: ServerOptions, mainlineInfo: MainlineServer, variantInfos: VariantServer[]) {<EOL>    options = applyDefaultServerOptions(options);<EOL>    const app = express();<EOL>    app.get('<STR_LIT>', (_req, res) => {<EOL>        res.contentType('<STR_LIT>');<EOL>        res.send(JSON.stringify({<EOL>","gt":"packageName: options.packageName,"}
{"input":"<s> export async function startControlServer(options: ServerOptions, mainlineInfo: MainlineServer, variantInfos: VariantServer[]) {<EOL>    options = applyDefaultServerOptions(options);<EOL>    const app = express();<EOL>    app.get('<STR_LIT>', (_req, res) => {<EOL>        res.contentType('<STR_LIT>');<EOL>        res.send(JSON.stringify({<EOL>            packageName: options.packageName,<EOL>            mainlineServer: {<EOL>                port: mainlineInfo.server.address().port,<EOL>            },<EOL>            variants: variantInfos.map(info => {<EOL>                return { name: info.variantName, port: info.server.address().port };<EOL>            })<EOL>        }));<EOL>        res.end();<EOL>    });<EOL>    const indexPath = path.join(__dirname, '<STR_LIT>',","gt":"'<STR_LIT>', '<STR_LIT>');"}
{"input":"<s> export default function (): void {<EOL>    describe(\"<STR_LIT>\", function () {<EOL>        let context: TestContext<ClrWizard, HeaderActionsTestComponent>;<EOL>        let headerActionService: HeaderActionService;<EOL>        let wizardNavigationService: WizardNavigationService;<EOL>","gt":"beforeEach(function () {"}
{"input":"<s> export default function (): void {<EOL>    describe(\"<STR_LIT>\", function () {<EOL>        let context: TestContext<ClrWizard, HeaderActionsTestComponent>;<EOL>        let headerActionService: HeaderActionService;<EOL>        let wizardNavigationService: WizardNavigationService;<EOL>        beforeEach(function () {<EOL>            context = this.create(ClrWizard, HeaderActionsTestComponent);<EOL>            headerActionService = context.getClarityProvider(HeaderActionService);<EOL>            wizardNavigationService =","gt":"context.getClarityProvider(WizardNavigationService);"}
{"input":"<s> export default function (): void {<EOL>    describe(\"<STR_LIT>\", function () {<EOL>        let context: TestContext<ClrWizard, HeaderActionsTestComponent>;<EOL>        let headerActionService: HeaderActionService;<EOL>        let wizardNavigationService: WizardNavigationService;<EOL>        beforeEach(function () {<EOL>            context = this.create(ClrWizard, HeaderActionsTestComponent);<EOL>            headerActionService = context.getClarityProvider(HeaderActionService);<EOL>            wizardNavigationService = context.getClarityProvider(WizardNavigationService);<EOL>            context.detectChanges();<EOL>        });<EOL>","gt":"it(\"<STR_LIT>\", function () {"}
{"input":"<s> export default function (): void {<EOL>    describe(\"<STR_LIT>\", function () {<EOL>        let context: TestContext<ClrWizard, HeaderActionsTestComponent>;<EOL>        let headerActionService: HeaderActionService;<EOL>        let wizardNavigationService: WizardNavigationService;<EOL>        beforeEach(function () {<EOL>            context = this.create(ClrWizard, HeaderActionsTestComponent);<EOL>            headerActionService = context.getClarityProvider(HeaderActionService);<EOL>            wizardNavigationService = context.getClarityProvider(WizardNavigationService);<EOL>            context.detectChanges();<EOL>        });<EOL>        it(\"<STR_LIT>\", function () {<EOL>            expect(headerActionService.wizardHasHeaderActions).toBe(true);<EOL>        });<EOL>","gt":"it(\"<STR_LIT>\", function () {"}
{"input":"<s> export default function (): void {<EOL>    describe(\"<STR_LIT>\", function () {<EOL>        let context: TestContext<ClrWizard, HeaderActionsTestComponent>;<EOL>        let headerActionService: HeaderActionService;<EOL>        let wizardNavigationService: WizardNavigationService;<EOL>        beforeEach(function () {<EOL>            context = this.create(ClrWizard, HeaderActionsTestComponent);<EOL>            headerActionService = context.getClarityProvider(HeaderActionService);<EOL>            wizardNavigationService = context.getClarityProvider(WizardNavigationService);<EOL>            context.detectChanges();<EOL>        });<EOL>        it(\"<STR_LIT>\", function () {<EOL>            expect(headerActionService.wizardHasHeaderActions).toBe(true);<EOL>        });<EOL>        it(\"<STR_LIT>\", function () {<EOL>            const lastPage = wizardNavigationService.pageCollection.lastPage;<EOL>            expect(headerActionService.currentPageHasHeaderActions).toBe(true);<EOL>            wizardNavigationService.currentPage = lastPage;<EOL>            expect(headerActionService.currentPageHasHeaderActions).toBe(false);<EOL>        });<EOL>        it(","gt":"\"<STR_LIT>\", function () {"}
{"input":"<s> /**<EOL> * Return true if node is a text node that is empty or consists only of white<EOL> * space.<EOL> */<EOL>export function isBlankTextNode(node: ASTNode): boolean {<EOL>    return node &&","gt":"dom5.isTextNode(node) &&"}
{"input":"<s> function formatRequest(req: express.Request) {<EOL>    const headers = {};<EOL>    for (const key in req.headers) {<EOL>        headers[capWords(key)] = req.headers[key];<EOL>    }<EOL>    const","gt":"formatted = {"}
{"input":"<s> function formatRequest(req: express.Request) {<EOL>    const headers = {};<EOL>    for (const key in req.headers) {<EOL>        headers[capWords(key)] = req.headers[key];<EOL>    }<EOL>    const formatted = {<EOL>        headers: headers,<EOL>        url: req.","gt":"originalUrl,"}
{"input":"<s> function formatRequest(req: express.Request) {<EOL>    const headers = {};<EOL>    for (const key in req.headers) {<EOL>        headers[capWords(key)] = req.headers[key];<EOL>    }<EOL>    const formatted = {<EOL>        headers: headers,<EOL>        url: req.originalUrl,<EOL>        data: req.body,<EOL>        files: (<any>req).files,<EOL>        form: {},<EOL>        json: {},<EOL>    };<EOL>    const contentType = (headers['<STR_LIT>'] || '<STR_LIT>').toLowerCase().split('<STR_LIT>')[<NUM_LIT>];<EOL>    const field = {<EOL>        '<STR_LIT>': '<STR_LIT>',<EOL>        '<STR_LIT>': '<STR_LIT>',<EOL>","gt":"'<STR_LIT>': '<STR_LIT>'"}
{"input":"<s> /**<EOL> * Loads suites of tests, supporting both `.js` and `.html` files.<EOL> *<EOL> * @param files The files to load.<EOL> */<EOL>export function loadSuites(files: string[]) {<EOL>    files.forEach(function (file) {<EOL>        if (/\\.js(\\?.*)?$/.test(file)) {<EOL>            jsSuites.push(file);<EOL>        }<EOL>        else if (/\\.html(\\?.*)?$/.test(file)) {<EOL>            htmlSuites.push(file);<EOL>        }<EOL>        else {<EOL>            throw","gt":"new Error('<STR_LIT>' + file);"}
{"input":"<s> export default function (): void {<EOL>    describe(\"<STR_LIT>\", function () {<EOL>        beforeEach(function (this: UserContext) {<EOL>            this.","gt":"organizer = new DatagridRenderOrganizer();"}
{"input":"<s> export default function (): void {<EOL>    describe(\"<STR_LIT>\", function () {<EOL>        beforeEach(function (this: UserContext) {<EOL>            this.organizer = new DatagridRenderOrganizer();<EOL>        });<EOL>        it(\"<STR_LIT>\", function (this: UserContext) {<EOL>","gt":"let clearedWidths = false;"}
{"input":"<s> export default function (): void {<EOL>    describe(\"<STR_LIT>\", function () {<EOL>        beforeEach(function (this: UserContext) {<EOL>            this.organizer = new DatagridRenderOrganizer();<EOL>        });<EOL>        it(\"<STR_LIT>\", function (this: UserContext) {<EOL>            let clearedWidths = false;<EOL>            this.organizer.clearWidths.subscribe(() => clearedWidths = true);<EOL>            this.organizer.resize();<EOL>            expect(clearedWidths).toBe(false);<EOL>            this.","gt":"organizer.resize();"}
{"input":"<s> export default function (): void {<EOL>    describe(\"<STR_LIT>\", function () {<EOL>        beforeEach(function (this: UserContext) {<EOL>            this.organizer = new DatagridRenderOrganizer();<EOL>        });<EOL>        it(\"<STR_LIT>\", function (this: UserContext) {<EOL>            let clearedWidths = false;<EOL>            this.organizer.clearWidths.subscribe(() => clearedWidths = true);<EOL>            this.organizer.resize();<EOL>            expect(clearedWidths).toBe(false);<EOL>            this.organizer.resize();<EOL>            expect(clearedWidths).toBe(true);<EOL>        });<EOL>        it(\"<STR_LIT>\", function (this:","gt":"UserContext) {"}
{"input":"<s> export default function (): void {<EOL>    describe(\"<STR_LIT>\", function () {<EOL>        beforeEach(function (this: UserContext) {<EOL>            this.organizer = new DatagridRenderOrganizer();<EOL>        });<EOL>        it(\"<STR_LIT>\", function (this: UserContext) {<EOL>            let clearedWidths = false;<EOL>            this.organizer.clearWidths.subscribe(() => clearedWidths = true);<EOL>            this.organizer.resize();<EOL>            expect(clearedWidths).toBe(false);<EOL>            this.organizer.resize();<EOL>            expect(clearedWidths).toBe(true);<EOL>        });<EOL>        it(\"<STR_LIT>\", function (this: UserContext) {<EOL>            <EOL>            this.organizer.resize();<EOL>            let step = <NUM_LIT>;<EOL>            this.organizer.noLayout.subscribe(","gt":"on => expect(step++).toBe(on ? <NUM_LIT> : <NUM_LIT>));"}
{"input":"<s> export default function (): void {<EOL>    describe(\"<STR_LIT>\", function () {<EOL>        beforeEach(function (this: UserContext) {<EOL>            this.organizer = new DatagridRenderOrganizer();<EOL>        });<EOL>        it(\"<STR_LIT>\", function (this: UserContext) {<EOL>            let clearedWidths = false;<EOL>            this.organizer.clearWidths.subscribe(() => clearedWidths = true);<EOL>            this.organizer.resize();<EOL>            expect(clearedWidths).toBe(false);<EOL>            this.organizer.resize();<EOL>            expect(clearedWidths).toBe(true);<EOL>        });<EOL>        it(\"<STR_LIT>\", function (this: UserContext) {<EOL>            <EOL>            this.organizer.resize();<EOL>            let step = <NUM_LIT>;<EOL>            this.organizer.noLayout.subscribe(on => expect(step++).toBe(on ? <NUM_LIT> : <NUM_LIT>));<EOL>            this.organizer.clearWidths.subscribe(() => expect(step++).toBe(<NUM_LIT>));<EOL>            this.organizer.detectStrictWidths.subscribe(() => expect(step++).toBe(<NUM_LIT>));<EOL>            this.organizer.tableMode.subscribe(on => expect(step++).toBe(on ? <NUM_LIT> : <NUM_LIT>));<EOL>            this.organizer.computeWidths.subscribe(() => expect(step++).toBe(<NUM_LIT>));<EOL>            this.organizer.alignColumns.subscribe(() => expect(step++).toBe(<NUM_LIT>));<EOL>            this.organizer.scrollbar.subscribe(() => expect(step++).toBe(<NUM_LIT>));<EOL>            this.","gt":"organizer.resize();"}
{"input":"<s> /**<EOL> * @license<EOL> * Copyright (c) 2018 The Polymer Project Authors. All rights reserved.<EOL> * This code may only be used under the BSD style license found at<EOL> * http://polymer.github.io/LICENSE.txt<EOL> * The complete set of authors may be found at<EOL> * http://polymer.github.io/AUTHORS.txt<EOL> * The complete set of contributors may be found at<EOL> * http://polymer.github.io/CONTRIBUTORS.txt<EOL> * Code distributed by Google as part of the polymer project is also<EOL> * subject to an additional IP rights grant found at<EOL> * http://polymer.github.io/PATENTS.txt<EOL> */<EOL>/**<EOL> * Simple utility function used to find an item in a set with a predicate<EOL> * function.  Analagous to Array.find(), without requiring converting the set<EOL> * an Array.<EOL> */<EOL>export function find<T>(items: Iterable<T>, predicate: (item: T) => boolean): T | undefined {<EOL>    for (const item of items) {<EOL>        if (","gt":"predicate(item)) {"}
{"input":"<s> export default function (): void {<EOL>    describe(\"<STR_LIT>\", function () {<EOL>        beforeEach(function () {<EOL>            this.pageInstance = new Page(new StateDebouncer());<EOL>        });<EOL>        it(\"<STR_LIT>\", function () {<EOL>            expect(this.pageInstance.size).toBe(<NUM_LIT>);<EOL>        });<EOL>        it(\"<STR_LIT>\",","gt":"function () {"}
{"input":"<s> export default function (): void {<EOL>    describe(\"<STR_LIT>\", function () {<EOL>        beforeEach(function () {<EOL>            this.pageInstance = new Page(new StateDebouncer());<EOL>        });<EOL>        it(\"<STR_LIT>\", function () {<EOL>            expect(this.pageInstance.size).toBe(<NUM_LIT>);<EOL>        });<EOL>        it(\"<STR_LIT>\", function () {<EOL>            expect(this.pageInstance.current).toBe(<NUM_LIT>);<EOL>        });<EOL>        it(","gt":"\"<STR_LIT>\", function () {"}
{"input":"<s> export default function (): void {<EOL>    describe(\"<STR_LIT>\", function () {<EOL>        beforeEach(function () {<EOL>            this.pageInstance = new Page(new StateDebouncer());<EOL>        });<EOL>        it(\"<STR_LIT>\", function () {<EOL>            expect(this.pageInstance.size).toBe(<NUM_LIT>);<EOL>        });<EOL>        it(\"<STR_LIT>\", function () {<EOL>            expect(this.pageInstance.current).toBe(<NUM_LIT>);<EOL>        });<EOL>        it(\"<STR_LIT>\", function () {<EOL>            this.pageInstance.size = <NUM_LIT>;<EOL>            this.pageInstance.totalItems = <NUM_LIT>;<EOL>            expect(this.pageInstance.last).toBe(<NUM_LIT>);<EOL>        });<EOL>        it(\"<STR_LIT>\",","gt":"function () {"}
{"input":"<s> export default function (): void {<EOL>    describe(\"<STR_LIT>\", function () {<EOL>        beforeEach(function () {<EOL>            this.pageInstance = new Page(new StateDebouncer());<EOL>        });<EOL>        it(\"<STR_LIT>\", function () {<EOL>            expect(this.pageInstance.size).toBe(<NUM_LIT>);<EOL>        });<EOL>        it(\"<STR_LIT>\", function () {<EOL>            expect(this.pageInstance.current).toBe(<NUM_LIT>);<EOL>        });<EOL>        it(\"<STR_LIT>\", function () {<EOL>            this.pageInstance.size = <NUM_LIT>;<EOL>            this.pageInstance.totalItems = <NUM_LIT>;<EOL>            expect(this.pageInstance.last).toBe(<NUM_LIT>);<EOL>        });<EOL>        it(\"<STR_LIT>\", function () {<EOL>","gt":"this.pageInstance.size = <NUM_LIT>;"}
{"input":"<s> export default function (): void {<EOL>    describe(\"<STR_LIT>\", function () {<EOL>        beforeEach(function () {<EOL>            this.pageInstance = new Page(new StateDebouncer());<EOL>        });<EOL>        it(\"<STR_LIT>\", function () {<EOL>            expect(this.pageInstance.size).toBe(<NUM_LIT>);<EOL>        });<EOL>        it(\"<STR_LIT>\", function () {<EOL>            expect(this.pageInstance.current).toBe(<NUM_LIT>);<EOL>        });<EOL>        it(\"<STR_LIT>\", function () {<EOL>            this.pageInstance.size = <NUM_LIT>;<EOL>            this.pageInstance.totalItems = <NUM_LIT>;<EOL>            expect(this.pageInstance.last).toBe(<NUM_LIT>);<EOL>        });<EOL>        it(\"<STR_LIT>\", function () {<EOL>            this.pageInstance.size = <NUM_LIT>;<EOL>            this.pageInstance.totalItems = <NUM_LIT>;<EOL>            this.pageInstance.current = <NUM_LIT>;<EOL>            expect(this.pageInstance.firstItem).toBe(<NUM_LIT>);<EOL>            expect(this.pageInstance.lastItem).toBe(<NUM_LIT>);<EOL>        });<EOL>        it(\"<STR_LIT>\", function () {<EOL>            this.pageInstance.next();<EOL>","gt":"expect(this.pageInstance.current).toBe(<NUM_LIT>);"}
{"input":"<s> export default function (): void {<EOL>    describe(\"<STR_LIT>\", function () {<EOL>        beforeEach(function () {<EOL>            this.pageInstance = new Page(new StateDebouncer());<EOL>        });<EOL>        it(\"<STR_LIT>\", function () {<EOL>            expect(this.pageInstance.size).toBe(<NUM_LIT>);<EOL>        });<EOL>        it(\"<STR_LIT>\", function () {<EOL>            expect(this.pageInstance.current).toBe(<NUM_LIT>);<EOL>        });<EOL>        it(\"<STR_LIT>\", function () {<EOL>            this.pageInstance.size = <NUM_LIT>;<EOL>            this.pageInstance.totalItems = <NUM_LIT>;<EOL>            expect(this.pageInstance.last).toBe(<NUM_LIT>);<EOL>        });<EOL>        it(\"<STR_LIT>\", function () {<EOL>            this.pageInstance.size = <NUM_LIT>;<EOL>            this.pageInstance.totalItems = <NUM_LIT>;<EOL>            this.pageInstance.current = <NUM_LIT>;<EOL>            expect(this.pageInstance.firstItem).toBe(<NUM_LIT>);<EOL>            expect(this.pageInstance.lastItem).toBe(<NUM_LIT>);<EOL>        });<EOL>        it(\"<STR_LIT>\", function () {<EOL>            this.pageInstance.next();<EOL>            expect(this.pageInstance.current).toBe(<NUM_LIT>);<EOL>        });<EOL>","gt":"it(\"<STR_LIT>\", function () {"}
{"input":"<s> export default function (): void {<EOL>    describe(\"<STR_LIT>\", function () {<EOL>        beforeEach(function () {<EOL>            this.pageInstance = new Page(new StateDebouncer());<EOL>        });<EOL>        it(\"<STR_LIT>\", function () {<EOL>            expect(this.pageInstance.size).toBe(<NUM_LIT>);<EOL>        });<EOL>        it(\"<STR_LIT>\", function () {<EOL>            expect(this.pageInstance.current).toBe(<NUM_LIT>);<EOL>        });<EOL>        it(\"<STR_LIT>\", function () {<EOL>            this.pageInstance.size = <NUM_LIT>;<EOL>            this.pageInstance.totalItems = <NUM_LIT>;<EOL>            expect(this.pageInstance.last).toBe(<NUM_LIT>);<EOL>        });<EOL>        it(\"<STR_LIT>\", function () {<EOL>            this.pageInstance.size = <NUM_LIT>;<EOL>            this.pageInstance.totalItems = <NUM_LIT>;<EOL>            this.pageInstance.current = <NUM_LIT>;<EOL>            expect(this.pageInstance.firstItem).toBe(<NUM_LIT>);<EOL>            expect(this.pageInstance.lastItem).toBe(<NUM_LIT>);<EOL>        });<EOL>        it(\"<STR_LIT>\", function () {<EOL>            this.pageInstance.next();<EOL>            expect(this.pageInstance.current).toBe(<NUM_LIT>);<EOL>        });<EOL>        it(\"<STR_LIT>\", function () {<EOL>            this.pageInstance.size = <NUM_LIT>;<EOL>            this.pageInstance.totalItems = <NUM_LIT>;<EOL>            this.pageInstance.current = <NUM_LIT>;<EOL>            expect(this.pageInstance.current).toBe(<NUM_LIT>);<EOL>            this.pageInstance.totalItems = <NUM_LIT>;<EOL>            expect(this.pageInstance.current).toBe(<NUM_LIT>);<EOL>        });<EOL>        it(\"<STR_LIT>\", function () {<EOL>","gt":"this.pageInstance.size = <NUM_LIT>;"}
{"input":"<s> export default function (): void {<EOL>    describe(\"<STR_LIT>\", function () {<EOL>        beforeEach(function () {<EOL>            this.pageInstance = new Page(new StateDebouncer());<EOL>        });<EOL>        it(\"<STR_LIT>\", function () {<EOL>            expect(this.pageInstance.size).toBe(<NUM_LIT>);<EOL>        });<EOL>        it(\"<STR_LIT>\", function () {<EOL>            expect(this.pageInstance.current).toBe(<NUM_LIT>);<EOL>        });<EOL>        it(\"<STR_LIT>\", function () {<EOL>            this.pageInstance.size = <NUM_LIT>;<EOL>            this.pageInstance.totalItems = <NUM_LIT>;<EOL>            expect(this.pageInstance.last).toBe(<NUM_LIT>);<EOL>        });<EOL>        it(\"<STR_LIT>\", function () {<EOL>            this.pageInstance.size = <NUM_LIT>;<EOL>            this.pageInstance.totalItems = <NUM_LIT>;<EOL>            this.pageInstance.current = <NUM_LIT>;<EOL>            expect(this.pageInstance.firstItem).toBe(<NUM_LIT>);<EOL>            expect(this.pageInstance.lastItem).toBe(<NUM_LIT>);<EOL>        });<EOL>        it(\"<STR_LIT>\", function () {<EOL>            this.pageInstance.next();<EOL>            expect(this.pageInstance.current).toBe(<NUM_LIT>);<EOL>        });<EOL>        it(\"<STR_LIT>\", function () {<EOL>            this.pageInstance.size = <NUM_LIT>;<EOL>            this.pageInstance.totalItems = <NUM_LIT>;<EOL>            this.pageInstance.current = <NUM_LIT>;<EOL>            expect(this.pageInstance.current).toBe(<NUM_LIT>);<EOL>            this.pageInstance.totalItems = <NUM_LIT>;<EOL>            expect(this.pageInstance.current).toBe(<NUM_LIT>);<EOL>        });<EOL>        it(\"<STR_LIT>\", function () {<EOL>            this.pageInstance.size = <NUM_LIT>;<EOL>            this.pageInstance.totalItems = <NUM_LIT>;<EOL>            this.pageInstance.current = <NUM_LIT>;<EOL>            expect(this.pageInstance.current).toBe(<NUM_LIT>);<EOL>            this.pageInstance.size = <NUM_LIT>;<EOL>            expect(this.pageInstance.current).toBe(<NUM_LIT>);<EOL>            this.pageInstance.size = <NUM_LIT>;<EOL>            expect(this.pageInstance.current).toBe(<NUM_LIT>);<EOL>        });<EOL>        it(\"<STR_LIT>\", function () {<EOL>            this.pageInstance.size = <NUM_LIT>;<EOL>","gt":"this.pageInstance.totalItems = <NUM_LIT>;"}
{"input":"<s> export default function (): void {<EOL>    describe(\"<STR_LIT>\", function () {<EOL>        beforeEach(function () {<EOL>            this.pageInstance = new Page(new StateDebouncer());<EOL>        });<EOL>        it(\"<STR_LIT>\", function () {<EOL>            expect(this.pageInstance.size).toBe(<NUM_LIT>);<EOL>        });<EOL>        it(\"<STR_LIT>\", function () {<EOL>            expect(this.pageInstance.current).toBe(<NUM_LIT>);<EOL>        });<EOL>        it(\"<STR_LIT>\", function () {<EOL>            this.pageInstance.size = <NUM_LIT>;<EOL>            this.pageInstance.totalItems = <NUM_LIT>;<EOL>            expect(this.pageInstance.last).toBe(<NUM_LIT>);<EOL>        });<EOL>        it(\"<STR_LIT>\", function () {<EOL>            this.pageInstance.size = <NUM_LIT>;<EOL>            this.pageInstance.totalItems = <NUM_LIT>;<EOL>            this.pageInstance.current = <NUM_LIT>;<EOL>            expect(this.pageInstance.firstItem).toBe(<NUM_LIT>);<EOL>            expect(this.pageInstance.lastItem).toBe(<NUM_LIT>);<EOL>        });<EOL>        it(\"<STR_LIT>\", function () {<EOL>            this.pageInstance.next();<EOL>            expect(this.pageInstance.current).toBe(<NUM_LIT>);<EOL>        });<EOL>        it(\"<STR_LIT>\", function () {<EOL>            this.pageInstance.size = <NUM_LIT>;<EOL>            this.pageInstance.totalItems = <NUM_LIT>;<EOL>            this.pageInstance.current = <NUM_LIT>;<EOL>            expect(this.pageInstance.current).toBe(<NUM_LIT>);<EOL>            this.pageInstance.totalItems = <NUM_LIT>;<EOL>            expect(this.pageInstance.current).toBe(<NUM_LIT>);<EOL>        });<EOL>        it(\"<STR_LIT>\", function () {<EOL>            this.pageInstance.size = <NUM_LIT>;<EOL>            this.pageInstance.totalItems = <NUM_LIT>;<EOL>            this.pageInstance.current = <NUM_LIT>;<EOL>            expect(this.pageInstance.current).toBe(<NUM_LIT>);<EOL>            this.pageInstance.size = <NUM_LIT>;<EOL>            expect(this.pageInstance.current).toBe(<NUM_LIT>);<EOL>            this.pageInstance.size = <NUM_LIT>;<EOL>            expect(this.pageInstance.current).toBe(<NUM_LIT>);<EOL>        });<EOL>        it(\"<STR_LIT>\", function () {<EOL>            this.pageInstance.size = <NUM_LIT>;<EOL>            this.pageInstance.totalItems = <NUM_LIT>;<EOL>            this.pageInstance.current = <NUM_LIT>;<EOL>            expect(this.pageInstance.lastItem).toBe(<NUM_LIT>);<EOL>        });<EOL>        it(\"<STR_LIT>\",","gt":"function () {"}
{"input":"<s> export default function (): void {<EOL>    describe(\"<STR_LIT>\", function () {<EOL>        beforeEach(function () {<EOL>            this.pageInstance = new Page(new StateDebouncer());<EOL>        });<EOL>        it(\"<STR_LIT>\", function () {<EOL>            expect(this.pageInstance.size).toBe(<NUM_LIT>);<EOL>        });<EOL>        it(\"<STR_LIT>\", function () {<EOL>            expect(this.pageInstance.current).toBe(<NUM_LIT>);<EOL>        });<EOL>        it(\"<STR_LIT>\", function () {<EOL>            this.pageInstance.size = <NUM_LIT>;<EOL>            this.pageInstance.totalItems = <NUM_LIT>;<EOL>            expect(this.pageInstance.last).toBe(<NUM_LIT>);<EOL>        });<EOL>        it(\"<STR_LIT>\", function () {<EOL>            this.pageInstance.size = <NUM_LIT>;<EOL>            this.pageInstance.totalItems = <NUM_LIT>;<EOL>            this.pageInstance.current = <NUM_LIT>;<EOL>            expect(this.pageInstance.firstItem).toBe(<NUM_LIT>);<EOL>            expect(this.pageInstance.lastItem).toBe(<NUM_LIT>);<EOL>        });<EOL>        it(\"<STR_LIT>\", function () {<EOL>            this.pageInstance.next();<EOL>            expect(this.pageInstance.current).toBe(<NUM_LIT>);<EOL>        });<EOL>        it(\"<STR_LIT>\", function () {<EOL>            this.pageInstance.size = <NUM_LIT>;<EOL>            this.pageInstance.totalItems = <NUM_LIT>;<EOL>            this.pageInstance.current = <NUM_LIT>;<EOL>            expect(this.pageInstance.current).toBe(<NUM_LIT>);<EOL>            this.pageInstance.totalItems = <NUM_LIT>;<EOL>            expect(this.pageInstance.current).toBe(<NUM_LIT>);<EOL>        });<EOL>        it(\"<STR_LIT>\", function () {<EOL>            this.pageInstance.size = <NUM_LIT>;<EOL>            this.pageInstance.totalItems = <NUM_LIT>;<EOL>            this.pageInstance.current = <NUM_LIT>;<EOL>            expect(this.pageInstance.current).toBe(<NUM_LIT>);<EOL>            this.pageInstance.size = <NUM_LIT>;<EOL>            expect(this.pageInstance.current).toBe(<NUM_LIT>);<EOL>            this.pageInstance.size = <NUM_LIT>;<EOL>            expect(this.pageInstance.current).toBe(<NUM_LIT>);<EOL>        });<EOL>        it(\"<STR_LIT>\", function () {<EOL>            this.pageInstance.size = <NUM_LIT>;<EOL>            this.pageInstance.totalItems = <NUM_LIT>;<EOL>            this.pageInstance.current = <NUM_LIT>;<EOL>            expect(this.pageInstance.lastItem).toBe(<NUM_LIT>);<EOL>        });<EOL>        it(\"<STR_LIT>\", function () {<EOL>            this.pageInstance.size = <NUM_LIT>;<EOL>            this.pageInstance.totalItems = <NUM_LIT>;<EOL>            expect(this.pageInstance.","gt":"current).toBe(<NUM_LIT>);"}
{"input":"<s> export default function (): void {<EOL>    describe(\"<STR_LIT>\", function () {<EOL>        beforeEach(function () {<EOL>            this.pageInstance = new Page(new StateDebouncer());<EOL>        });<EOL>        it(\"<STR_LIT>\", function () {<EOL>            expect(this.pageInstance.size).toBe(<NUM_LIT>);<EOL>        });<EOL>        it(\"<STR_LIT>\", function () {<EOL>            expect(this.pageInstance.current).toBe(<NUM_LIT>);<EOL>        });<EOL>        it(\"<STR_LIT>\", function () {<EOL>            this.pageInstance.size = <NUM_LIT>;<EOL>            this.pageInstance.totalItems = <NUM_LIT>;<EOL>            expect(this.pageInstance.last).toBe(<NUM_LIT>);<EOL>        });<EOL>        it(\"<STR_LIT>\", function () {<EOL>            this.pageInstance.size = <NUM_LIT>;<EOL>            this.pageInstance.totalItems = <NUM_LIT>;<EOL>            this.pageInstance.current = <NUM_LIT>;<EOL>            expect(this.pageInstance.firstItem).toBe(<NUM_LIT>);<EOL>            expect(this.pageInstance.lastItem).toBe(<NUM_LIT>);<EOL>        });<EOL>        it(\"<STR_LIT>\", function () {<EOL>            this.pageInstance.next();<EOL>            expect(this.pageInstance.current).toBe(<NUM_LIT>);<EOL>        });<EOL>        it(\"<STR_LIT>\", function () {<EOL>            this.pageInstance.size = <NUM_LIT>;<EOL>            this.pageInstance.totalItems = <NUM_LIT>;<EOL>            this.pageInstance.current = <NUM_LIT>;<EOL>            expect(this.pageInstance.current).toBe(<NUM_LIT>);<EOL>            this.pageInstance.totalItems = <NUM_LIT>;<EOL>            expect(this.pageInstance.current).toBe(<NUM_LIT>);<EOL>        });<EOL>        it(\"<STR_LIT>\", function () {<EOL>            this.pageInstance.size = <NUM_LIT>;<EOL>            this.pageInstance.totalItems = <NUM_LIT>;<EOL>            this.pageInstance.current = <NUM_LIT>;<EOL>            expect(this.pageInstance.current).toBe(<NUM_LIT>);<EOL>            this.pageInstance.size = <NUM_LIT>;<EOL>            expect(this.pageInstance.current).toBe(<NUM_LIT>);<EOL>            this.pageInstance.size = <NUM_LIT>;<EOL>            expect(this.pageInstance.current).toBe(<NUM_LIT>);<EOL>        });<EOL>        it(\"<STR_LIT>\", function () {<EOL>            this.pageInstance.size = <NUM_LIT>;<EOL>            this.pageInstance.totalItems = <NUM_LIT>;<EOL>            this.pageInstance.current = <NUM_LIT>;<EOL>            expect(this.pageInstance.lastItem).toBe(<NUM_LIT>);<EOL>        });<EOL>        it(\"<STR_LIT>\", function () {<EOL>            this.pageInstance.size = <NUM_LIT>;<EOL>            this.pageInstance.totalItems = <NUM_LIT>;<EOL>            expect(this.pageInstance.current).toBe(<NUM_LIT>);<EOL>            this.pageInstance.next();<EOL>            expect(this.pageInstance.current).toBe(<NUM_LIT>);<EOL>            this.pageInstance.next();<EOL>            expect(this.pageInstance.current).toBe(<NUM_LIT>);<EOL>        });<EOL>        it(\"<STR_LIT>\", function () {<EOL>            this.pageInstance.size = <NUM_LIT>;<EOL>            this.pageInstance.totalItems = <NUM_LIT>;<EOL>            this.pageInstance.current = <NUM_LIT>;<EOL>            expect(this.pageInstance.current).","gt":"toBe(<NUM_LIT>);"}
{"input":"<s> export default function (): void {<EOL>    describe(\"<STR_LIT>\", function () {<EOL>        beforeEach(function () {<EOL>            this.pageInstance = new Page(new StateDebouncer());<EOL>        });<EOL>        it(\"<STR_LIT>\", function () {<EOL>            expect(this.pageInstance.size).toBe(<NUM_LIT>);<EOL>        });<EOL>        it(\"<STR_LIT>\", function () {<EOL>            expect(this.pageInstance.current).toBe(<NUM_LIT>);<EOL>        });<EOL>        it(\"<STR_LIT>\", function () {<EOL>            this.pageInstance.size = <NUM_LIT>;<EOL>            this.pageInstance.totalItems = <NUM_LIT>;<EOL>            expect(this.pageInstance.last).toBe(<NUM_LIT>);<EOL>        });<EOL>        it(\"<STR_LIT>\", function () {<EOL>            this.pageInstance.size = <NUM_LIT>;<EOL>            this.pageInstance.totalItems = <NUM_LIT>;<EOL>            this.pageInstance.current = <NUM_LIT>;<EOL>            expect(this.pageInstance.firstItem).toBe(<NUM_LIT>);<EOL>            expect(this.pageInstance.lastItem).toBe(<NUM_LIT>);<EOL>        });<EOL>        it(\"<STR_LIT>\", function () {<EOL>            this.pageInstance.next();<EOL>            expect(this.pageInstance.current).toBe(<NUM_LIT>);<EOL>        });<EOL>        it(\"<STR_LIT>\", function () {<EOL>            this.pageInstance.size = <NUM_LIT>;<EOL>            this.pageInstance.totalItems = <NUM_LIT>;<EOL>            this.pageInstance.current = <NUM_LIT>;<EOL>            expect(this.pageInstance.current).toBe(<NUM_LIT>);<EOL>            this.pageInstance.totalItems = <NUM_LIT>;<EOL>            expect(this.pageInstance.current).toBe(<NUM_LIT>);<EOL>        });<EOL>        it(\"<STR_LIT>\", function () {<EOL>            this.pageInstance.size = <NUM_LIT>;<EOL>            this.pageInstance.totalItems = <NUM_LIT>;<EOL>            this.pageInstance.current = <NUM_LIT>;<EOL>            expect(this.pageInstance.current).toBe(<NUM_LIT>);<EOL>            this.pageInstance.size = <NUM_LIT>;<EOL>            expect(this.pageInstance.current).toBe(<NUM_LIT>);<EOL>            this.pageInstance.size = <NUM_LIT>;<EOL>            expect(this.pageInstance.current).toBe(<NUM_LIT>);<EOL>        });<EOL>        it(\"<STR_LIT>\", function () {<EOL>            this.pageInstance.size = <NUM_LIT>;<EOL>            this.pageInstance.totalItems = <NUM_LIT>;<EOL>            this.pageInstance.current = <NUM_LIT>;<EOL>            expect(this.pageInstance.lastItem).toBe(<NUM_LIT>);<EOL>        });<EOL>        it(\"<STR_LIT>\", function () {<EOL>            this.pageInstance.size = <NUM_LIT>;<EOL>            this.pageInstance.totalItems = <NUM_LIT>;<EOL>            expect(this.pageInstance.current).toBe(<NUM_LIT>);<EOL>            this.pageInstance.next();<EOL>            expect(this.pageInstance.current).toBe(<NUM_LIT>);<EOL>            this.pageInstance.next();<EOL>            expect(this.pageInstance.current).toBe(<NUM_LIT>);<EOL>        });<EOL>        it(\"<STR_LIT>\", function () {<EOL>            this.pageInstance.size = <NUM_LIT>;<EOL>            this.pageInstance.totalItems = <NUM_LIT>;<EOL>            this.pageInstance.current = <NUM_LIT>;<EOL>            expect(this.pageInstance.current).toBe(<NUM_LIT>);<EOL>            this.pageInstance.previous();<EOL>            expect(this.pageInstance.current).toBe(<NUM_LIT>);<EOL>            this.pageInstance.previous();<EOL>            expect(this.pageInstance.current).toBe(<NUM_LIT>);<EOL>        });<EOL>        it(","gt":"\"<STR_LIT>\", function () {"}
{"input":"<s> export default function (): void {<EOL>    describe(\"<STR_LIT>\", function () {<EOL>        beforeEach(function () {<EOL>            this.pageInstance = new Page(new StateDebouncer());<EOL>        });<EOL>        it(\"<STR_LIT>\", function () {<EOL>            expect(this.pageInstance.size).toBe(<NUM_LIT>);<EOL>        });<EOL>        it(\"<STR_LIT>\", function () {<EOL>            expect(this.pageInstance.current).toBe(<NUM_LIT>);<EOL>        });<EOL>        it(\"<STR_LIT>\", function () {<EOL>            this.pageInstance.size = <NUM_LIT>;<EOL>            this.pageInstance.totalItems = <NUM_LIT>;<EOL>            expect(this.pageInstance.last).toBe(<NUM_LIT>);<EOL>        });<EOL>        it(\"<STR_LIT>\", function () {<EOL>            this.pageInstance.size = <NUM_LIT>;<EOL>            this.pageInstance.totalItems = <NUM_LIT>;<EOL>            this.pageInstance.current = <NUM_LIT>;<EOL>            expect(this.pageInstance.firstItem).toBe(<NUM_LIT>);<EOL>            expect(this.pageInstance.lastItem).toBe(<NUM_LIT>);<EOL>        });<EOL>        it(\"<STR_LIT>\", function () {<EOL>            this.pageInstance.next();<EOL>            expect(this.pageInstance.current).toBe(<NUM_LIT>);<EOL>        });<EOL>        it(\"<STR_LIT>\", function () {<EOL>            this.pageInstance.size = <NUM_LIT>;<EOL>            this.pageInstance.totalItems = <NUM_LIT>;<EOL>            this.pageInstance.current = <NUM_LIT>;<EOL>            expect(this.pageInstance.current).toBe(<NUM_LIT>);<EOL>            this.pageInstance.totalItems = <NUM_LIT>;<EOL>            expect(this.pageInstance.current).toBe(<NUM_LIT>);<EOL>        });<EOL>        it(\"<STR_LIT>\", function () {<EOL>            this.pageInstance.size = <NUM_LIT>;<EOL>            this.pageInstance.totalItems = <NUM_LIT>;<EOL>            this.pageInstance.current = <NUM_LIT>;<EOL>            expect(this.pageInstance.current).toBe(<NUM_LIT>);<EOL>            this.pageInstance.size = <NUM_LIT>;<EOL>            expect(this.pageInstance.current).toBe(<NUM_LIT>);<EOL>            this.pageInstance.size = <NUM_LIT>;<EOL>            expect(this.pageInstance.current).toBe(<NUM_LIT>);<EOL>        });<EOL>        it(\"<STR_LIT>\", function () {<EOL>            this.pageInstance.size = <NUM_LIT>;<EOL>            this.pageInstance.totalItems = <NUM_LIT>;<EOL>            this.pageInstance.current = <NUM_LIT>;<EOL>            expect(this.pageInstance.lastItem).toBe(<NUM_LIT>);<EOL>        });<EOL>        it(\"<STR_LIT>\", function () {<EOL>            this.pageInstance.size = <NUM_LIT>;<EOL>            this.pageInstance.totalItems = <NUM_LIT>;<EOL>            expect(this.pageInstance.current).toBe(<NUM_LIT>);<EOL>            this.pageInstance.next();<EOL>            expect(this.pageInstance.current).toBe(<NUM_LIT>);<EOL>            this.pageInstance.next();<EOL>            expect(this.pageInstance.current).toBe(<NUM_LIT>);<EOL>        });<EOL>        it(\"<STR_LIT>\", function () {<EOL>            this.pageInstance.size = <NUM_LIT>;<EOL>            this.pageInstance.totalItems = <NUM_LIT>;<EOL>            this.pageInstance.current = <NUM_LIT>;<EOL>            expect(this.pageInstance.current).toBe(<NUM_LIT>);<EOL>            this.pageInstance.previous();<EOL>            expect(this.pageInstance.current).toBe(<NUM_LIT>);<EOL>            this.pageInstance.previous();<EOL>            expect(this.pageInstance.current).toBe(<NUM_LIT>);<EOL>        });<EOL>        it(\"<STR_LIT>\", function () {<EOL>            let nbChanges =","gt":"<NUM_LIT>;"}
{"input":"<s> export default function (): void {<EOL>    describe(\"<STR_LIT>\", function () {<EOL>        beforeEach(function () {<EOL>            this.pageInstance = new Page(new StateDebouncer());<EOL>        });<EOL>        it(\"<STR_LIT>\", function () {<EOL>            expect(this.pageInstance.size).toBe(<NUM_LIT>);<EOL>        });<EOL>        it(\"<STR_LIT>\", function () {<EOL>            expect(this.pageInstance.current).toBe(<NUM_LIT>);<EOL>        });<EOL>        it(\"<STR_LIT>\", function () {<EOL>            this.pageInstance.size = <NUM_LIT>;<EOL>            this.pageInstance.totalItems = <NUM_LIT>;<EOL>            expect(this.pageInstance.last).toBe(<NUM_LIT>);<EOL>        });<EOL>        it(\"<STR_LIT>\", function () {<EOL>            this.pageInstance.size = <NUM_LIT>;<EOL>            this.pageInstance.totalItems = <NUM_LIT>;<EOL>            this.pageInstance.current = <NUM_LIT>;<EOL>            expect(this.pageInstance.firstItem).toBe(<NUM_LIT>);<EOL>            expect(this.pageInstance.lastItem).toBe(<NUM_LIT>);<EOL>        });<EOL>        it(\"<STR_LIT>\", function () {<EOL>            this.pageInstance.next();<EOL>            expect(this.pageInstance.current).toBe(<NUM_LIT>);<EOL>        });<EOL>        it(\"<STR_LIT>\", function () {<EOL>            this.pageInstance.size = <NUM_LIT>;<EOL>            this.pageInstance.totalItems = <NUM_LIT>;<EOL>            this.pageInstance.current = <NUM_LIT>;<EOL>            expect(this.pageInstance.current).toBe(<NUM_LIT>);<EOL>            this.pageInstance.totalItems = <NUM_LIT>;<EOL>            expect(this.pageInstance.current).toBe(<NUM_LIT>);<EOL>        });<EOL>        it(\"<STR_LIT>\", function () {<EOL>            this.pageInstance.size = <NUM_LIT>;<EOL>            this.pageInstance.totalItems = <NUM_LIT>;<EOL>            this.pageInstance.current = <NUM_LIT>;<EOL>            expect(this.pageInstance.current).toBe(<NUM_LIT>);<EOL>            this.pageInstance.size = <NUM_LIT>;<EOL>            expect(this.pageInstance.current).toBe(<NUM_LIT>);<EOL>            this.pageInstance.size = <NUM_LIT>;<EOL>            expect(this.pageInstance.current).toBe(<NUM_LIT>);<EOL>        });<EOL>        it(\"<STR_LIT>\", function () {<EOL>            this.pageInstance.size = <NUM_LIT>;<EOL>            this.pageInstance.totalItems = <NUM_LIT>;<EOL>            this.pageInstance.current = <NUM_LIT>;<EOL>            expect(this.pageInstance.lastItem).toBe(<NUM_LIT>);<EOL>        });<EOL>        it(\"<STR_LIT>\", function () {<EOL>            this.pageInstance.size = <NUM_LIT>;<EOL>            this.pageInstance.totalItems = <NUM_LIT>;<EOL>            expect(this.pageInstance.current).toBe(<NUM_LIT>);<EOL>            this.pageInstance.next();<EOL>            expect(this.pageInstance.current).toBe(<NUM_LIT>);<EOL>            this.pageInstance.next();<EOL>            expect(this.pageInstance.current).toBe(<NUM_LIT>);<EOL>        });<EOL>        it(\"<STR_LIT>\", function () {<EOL>            this.pageInstance.size = <NUM_LIT>;<EOL>            this.pageInstance.totalItems = <NUM_LIT>;<EOL>            this.pageInstance.current = <NUM_LIT>;<EOL>            expect(this.pageInstance.current).toBe(<NUM_LIT>);<EOL>            this.pageInstance.previous();<EOL>            expect(this.pageInstance.current).toBe(<NUM_LIT>);<EOL>            this.pageInstance.previous();<EOL>            expect(this.pageInstance.current).toBe(<NUM_LIT>);<EOL>        });<EOL>        it(\"<STR_LIT>\", function () {<EOL>            let nbChanges = <NUM_LIT>;<EOL>            let currentPage: number;<EOL>            this.pageInstance.change.subscribe((page: number) => {<EOL>                nbChanges++;<EOL>","gt":"currentPage ="}
{"input":"<s> export default function (): void {<EOL>    describe(\"<STR_LIT>\", function () {<EOL>        beforeEach(function () {<EOL>            this.pageInstance = new Page(new StateDebouncer());<EOL>        });<EOL>        it(\"<STR_LIT>\", function () {<EOL>            expect(this.pageInstance.size).toBe(<NUM_LIT>);<EOL>        });<EOL>        it(\"<STR_LIT>\", function () {<EOL>            expect(this.pageInstance.current).toBe(<NUM_LIT>);<EOL>        });<EOL>        it(\"<STR_LIT>\", function () {<EOL>            this.pageInstance.size = <NUM_LIT>;<EOL>            this.pageInstance.totalItems = <NUM_LIT>;<EOL>            expect(this.pageInstance.last).toBe(<NUM_LIT>);<EOL>        });<EOL>        it(\"<STR_LIT>\", function () {<EOL>            this.pageInstance.size = <NUM_LIT>;<EOL>            this.pageInstance.totalItems = <NUM_LIT>;<EOL>            this.pageInstance.current = <NUM_LIT>;<EOL>            expect(this.pageInstance.firstItem).toBe(<NUM_LIT>);<EOL>            expect(this.pageInstance.lastItem).toBe(<NUM_LIT>);<EOL>        });<EOL>        it(\"<STR_LIT>\", function () {<EOL>            this.pageInstance.next();<EOL>            expect(this.pageInstance.current).toBe(<NUM_LIT>);<EOL>        });<EOL>        it(\"<STR_LIT>\", function () {<EOL>            this.pageInstance.size = <NUM_LIT>;<EOL>            this.pageInstance.totalItems = <NUM_LIT>;<EOL>            this.pageInstance.current = <NUM_LIT>;<EOL>            expect(this.pageInstance.current).toBe(<NUM_LIT>);<EOL>            this.pageInstance.totalItems = <NUM_LIT>;<EOL>            expect(this.pageInstance.current).toBe(<NUM_LIT>);<EOL>        });<EOL>        it(\"<STR_LIT>\", function () {<EOL>            this.pageInstance.size = <NUM_LIT>;<EOL>            this.pageInstance.totalItems = <NUM_LIT>;<EOL>            this.pageInstance.current = <NUM_LIT>;<EOL>            expect(this.pageInstance.current).toBe(<NUM_LIT>);<EOL>            this.pageInstance.size = <NUM_LIT>;<EOL>            expect(this.pageInstance.current).toBe(<NUM_LIT>);<EOL>            this.pageInstance.size = <NUM_LIT>;<EOL>            expect(this.pageInstance.current).toBe(<NUM_LIT>);<EOL>        });<EOL>        it(\"<STR_LIT>\", function () {<EOL>            this.pageInstance.size = <NUM_LIT>;<EOL>            this.pageInstance.totalItems = <NUM_LIT>;<EOL>            this.pageInstance.current = <NUM_LIT>;<EOL>            expect(this.pageInstance.lastItem).toBe(<NUM_LIT>);<EOL>        });<EOL>        it(\"<STR_LIT>\", function () {<EOL>            this.pageInstance.size = <NUM_LIT>;<EOL>            this.pageInstance.totalItems = <NUM_LIT>;<EOL>            expect(this.pageInstance.current).toBe(<NUM_LIT>);<EOL>            this.pageInstance.next();<EOL>            expect(this.pageInstance.current).toBe(<NUM_LIT>);<EOL>            this.pageInstance.next();<EOL>            expect(this.pageInstance.current).toBe(<NUM_LIT>);<EOL>        });<EOL>        it(\"<STR_LIT>\", function () {<EOL>            this.pageInstance.size = <NUM_LIT>;<EOL>            this.pageInstance.totalItems = <NUM_LIT>;<EOL>            this.pageInstance.current = <NUM_LIT>;<EOL>            expect(this.pageInstance.current).toBe(<NUM_LIT>);<EOL>            this.pageInstance.previous();<EOL>            expect(this.pageInstance.current).toBe(<NUM_LIT>);<EOL>            this.pageInstance.previous();<EOL>            expect(this.pageInstance.current).toBe(<NUM_LIT>);<EOL>        });<EOL>        it(\"<STR_LIT>\", function () {<EOL>            let nbChanges = <NUM_LIT>;<EOL>            let currentPage: number;<EOL>            this.pageInstance.change.subscribe((page: number) => {<EOL>                nbChanges++;<EOL>                currentPage =","gt":"page;"}
{"input":"<s> export default function (): void {<EOL>    describe(\"<STR_LIT>\", function () {<EOL>        beforeEach(function () {<EOL>            this.pageInstance = new Page(new StateDebouncer());<EOL>        });<EOL>        it(\"<STR_LIT>\", function () {<EOL>            expect(this.pageInstance.size).toBe(<NUM_LIT>);<EOL>        });<EOL>        it(\"<STR_LIT>\", function () {<EOL>            expect(this.pageInstance.current).toBe(<NUM_LIT>);<EOL>        });<EOL>        it(\"<STR_LIT>\", function () {<EOL>            this.pageInstance.size = <NUM_LIT>;<EOL>            this.pageInstance.totalItems = <NUM_LIT>;<EOL>            expect(this.pageInstance.last).toBe(<NUM_LIT>);<EOL>        });<EOL>        it(\"<STR_LIT>\", function () {<EOL>            this.pageInstance.size = <NUM_LIT>;<EOL>            this.pageInstance.totalItems = <NUM_LIT>;<EOL>            this.pageInstance.current = <NUM_LIT>;<EOL>            expect(this.pageInstance.firstItem).toBe(<NUM_LIT>);<EOL>            expect(this.pageInstance.lastItem).toBe(<NUM_LIT>);<EOL>        });<EOL>        it(\"<STR_LIT>\", function () {<EOL>            this.pageInstance.next();<EOL>            expect(this.pageInstance.current).toBe(<NUM_LIT>);<EOL>        });<EOL>        it(\"<STR_LIT>\", function () {<EOL>            this.pageInstance.size = <NUM_LIT>;<EOL>            this.pageInstance.totalItems = <NUM_LIT>;<EOL>            this.pageInstance.current = <NUM_LIT>;<EOL>            expect(this.pageInstance.current).toBe(<NUM_LIT>);<EOL>            this.pageInstance.totalItems = <NUM_LIT>;<EOL>            expect(this.pageInstance.current).toBe(<NUM_LIT>);<EOL>        });<EOL>        it(\"<STR_LIT>\", function () {<EOL>            this.pageInstance.size = <NUM_LIT>;<EOL>            this.pageInstance.totalItems = <NUM_LIT>;<EOL>            this.pageInstance.current = <NUM_LIT>;<EOL>            expect(this.pageInstance.current).toBe(<NUM_LIT>);<EOL>            this.pageInstance.size = <NUM_LIT>;<EOL>            expect(this.pageInstance.current).toBe(<NUM_LIT>);<EOL>            this.pageInstance.size = <NUM_LIT>;<EOL>            expect(this.pageInstance.current).toBe(<NUM_LIT>);<EOL>        });<EOL>        it(\"<STR_LIT>\", function () {<EOL>            this.pageInstance.size = <NUM_LIT>;<EOL>            this.pageInstance.totalItems = <NUM_LIT>;<EOL>            this.pageInstance.current = <NUM_LIT>;<EOL>            expect(this.pageInstance.lastItem).toBe(<NUM_LIT>);<EOL>        });<EOL>        it(\"<STR_LIT>\", function () {<EOL>            this.pageInstance.size = <NUM_LIT>;<EOL>            this.pageInstance.totalItems = <NUM_LIT>;<EOL>            expect(this.pageInstance.current).toBe(<NUM_LIT>);<EOL>            this.pageInstance.next();<EOL>            expect(this.pageInstance.current).toBe(<NUM_LIT>);<EOL>            this.pageInstance.next();<EOL>            expect(this.pageInstance.current).toBe(<NUM_LIT>);<EOL>        });<EOL>        it(\"<STR_LIT>\", function () {<EOL>            this.pageInstance.size = <NUM_LIT>;<EOL>            this.pageInstance.totalItems = <NUM_LIT>;<EOL>            this.pageInstance.current = <NUM_LIT>;<EOL>            expect(this.pageInstance.current).toBe(<NUM_LIT>);<EOL>            this.pageInstance.previous();<EOL>            expect(this.pageInstance.current).toBe(<NUM_LIT>);<EOL>            this.pageInstance.previous();<EOL>            expect(this.pageInstance.current).toBe(<NUM_LIT>);<EOL>        });<EOL>        it(\"<STR_LIT>\", function () {<EOL>            let nbChanges = <NUM_LIT>;<EOL>            let currentPage: number;<EOL>            this.pageInstance.change.subscribe((page: number) => {<EOL>                nbChanges++;<EOL>                currentPage = page;<EOL>            });<EOL>","gt":"expect(currentPage).toBeUndefined();"}
{"input":"<s> function exists(path: string): boolean {<EOL>    try {<EOL>        fs.statSync(path);<EOL>        return","gt":"true;"}
{"input":"<s> /**<EOL> * Assume that if the same symbol is documented in multiple places, the longer<EOL> * description is probably the intended one.<EOL> *<EOL> * TODO(rictic): unify logic with join(...)'s above.<EOL> */<EOL>export function pickBestDescription(...descriptions: Array<string | undefined>): string {<EOL>    let description = '<STR_LIT>';<EOL>    for (const desc of descriptions) {<EOL>        if (desc && desc.length > description.","gt":"length) {"}
{"input":"<s> /**<EOL> * Detects a function<EOL> * @param {Function} fn The possible function<EOL> */<EOL>function isFunction(fn) {<EOL>","gt":"const functionType = typeof function () { };"}
{"input":"<s> function runClean(editor: vscode.TextEditor) {<EOL>    try {<EOL>        const cwd: string = editor.document<EOL>            ? utils.detectProjectRoot(editor.document.fileName)<EOL>            : vscode.workspace.rootPath;<EOL>        const elmStuffDir = path.join(cwd, '<STR_LIT>', '<STR_LIT>');<EOL>","gt":"rimraf(elmStuffDir, error => {"}
{"input":"<s> function runClean(editor: vscode.TextEditor) {<EOL>    try {<EOL>        const cwd: string = editor.document<EOL>            ? utils.detectProjectRoot(editor.document.fileName)<EOL>            : vscode.workspace.rootPath;<EOL>        const elmStuffDir = path.join(cwd, '<STR_LIT>', '<STR_LIT>');<EOL>        rimraf(elmStuffDir, error => {<EOL>            if (error) {<EOL>                vscode.window.showErrorMessage('<STR_LIT>');<EOL>            }<EOL>","gt":"else {"}
{"input":"<s> function mockTracerimplementationTests(): void {<EOL>    describe('<STR_LIT>', () => {<EOL>        describe('<STR_LIT>', () => {<EOL>            it('<STR_LIT>', () => {<EOL>                const tracer = new MockTracer();<EOL>                const","gt":"span = tracer.startSpan('<STR_LIT>');"}
{"input":"<s> function mockTracerimplementationTests(): void {<EOL>    describe('<STR_LIT>', () => {<EOL>        describe('<STR_LIT>', () => {<EOL>            it('<STR_LIT>', () => {<EOL>                const tracer = new MockTracer();<EOL>                const span = tracer.startSpan('<STR_LIT>');<EOL>                span.addTags({ key: '<STR_LIT>' });<EOL>                span.finish();<EOL>                expect(() => {<EOL>                    const","gt":"report = tracer.report();"}
{"input":"<s> function mockTracerimplementationTests(): void {<EOL>    describe('<STR_LIT>', () => {<EOL>        describe('<STR_LIT>', () => {<EOL>            it('<STR_LIT>', () => {<EOL>                const tracer = new MockTracer();<EOL>                const span = tracer.startSpan('<STR_LIT>');<EOL>                span.addTags({ key: '<STR_LIT>' });<EOL>                span.finish();<EOL>                expect(() => {<EOL>                    const report = tracer.report();<EOL>                    for (const span of report.spans) {<EOL>                        span.tags();<EOL>                    }<EOL>                }).to.not.","gt":"throw(Error);"}
{"input":"<s> export function mixins(...Ctors: VueClass<Vue>[]): VueClass<Vue> {<EOL>    return Vue.extend({","gt":"mixins: Ctors });"}
{"input":"<s> function triggerValidation(textDocument: TextDocument): void {<EOL>    cleanPendingValidation(textDocument);<EOL>","gt":"pendingValidationRequests[textDocument.uri] = setTimeout(() => {"}
{"input":"<s> function toLowerOrHover(action: OracleAction, text: string): string {<EOL>    return action === OracleAction.","gt":"IsAutocomplete ? text.toLowerCase() : text;"}
{"input":"<s> export function componentFactory(Component: VueClass<Vue>, options: ComponentOptions<Vue> = {}): VueClass<Vue> {<EOL>    options.name = options.name || (Component as any)._componentTag || (Component as any).name;<EOL>    <EOL>    const proto = Component.prototype;<EOL>    Object.","gt":"getOwnPropertyNames(proto).forEach(function (key) {"}
{"input":"<s> export function componentFactory(Component: VueClass<Vue>, options: ComponentOptions<Vue> = {}): VueClass<Vue> {<EOL>    options.name = options.name || (Component as any)._componentTag || (Component as any).name;<EOL>    <EOL>    const proto = Component.prototype;<EOL>    Object.getOwnPropertyNames(proto).forEach(function (key) {<EOL>        if (key === '<STR_LIT>') {<EOL>","gt":"return;"}
{"input":"<s> export function componentFactory(Component: VueClass<Vue>, options: ComponentOptions<Vue> = {}): VueClass<Vue> {<EOL>    options.name = options.name || (Component as any)._componentTag || (Component as any).name;<EOL>    <EOL>    const proto = Component.prototype;<EOL>    Object.getOwnPropertyNames(proto).forEach(function (key) {<EOL>        if (key === '<STR_LIT>') {<EOL>            return;<EOL>        }<EOL>        <EOL>        if ($internalHooks.","gt":"indexOf(key) > -<NUM_LIT>) {"}
{"input":"<s> export function componentFactory(Component: VueClass<Vue>, options: ComponentOptions<Vue> = {}): VueClass<Vue> {<EOL>    options.name = options.name || (Component as any)._componentTag || (Component as any).name;<EOL>    <EOL>    const proto = Component.prototype;<EOL>    Object.getOwnPropertyNames(proto).forEach(function (key) {<EOL>        if (key === '<STR_LIT>') {<EOL>            return;<EOL>        }<EOL>        <EOL>        if ($internalHooks.indexOf(key) > -<NUM_LIT>) {<EOL>            options[key] = proto[key];<EOL>            return;<EOL>        }<EOL>        const descriptor = Object.getOwnPropertyDescriptor(proto, key)!;<EOL>        if (typeof descriptor.value ===","gt":"'<STR_LIT>') {"}
{"input":"<s> export function componentFactory(Component: VueClass<Vue>, options: ComponentOptions<Vue> = {}): VueClass<Vue> {<EOL>    options.name = options.name || (Component as any)._componentTag || (Component as any).name;<EOL>    <EOL>    const proto = Component.prototype;<EOL>    Object.getOwnPropertyNames(proto).forEach(function (key) {<EOL>        if (key === '<STR_LIT>') {<EOL>            return;<EOL>        }<EOL>        <EOL>        if ($internalHooks.indexOf(key) > -<NUM_LIT>) {<EOL>            options[key] = proto[key];<EOL>            return;<EOL>        }<EOL>        const descriptor = Object.getOwnPropertyDescriptor(proto, key)!;<EOL>        if (typeof descriptor.value === '<STR_LIT>') {<EOL>            <EOL>            (options.methods || (options.methods = {}))[key] = descriptor.value;<EOL>        }<EOL>        else if (descriptor.get || descriptor.set) {<EOL>            <EOL>            (options.computed || (options.computed = {}))[key] = {<EOL>                get: descriptor.get,<EOL>                set: descriptor.set<EOL>            };<EOL>        }<EOL>    });<EOL>    (options.mixins || (options.mixins = [])).push({<EOL>        data(this: Vue) {<EOL>            return collectDataFromConstructor(this, Component);<EOL>        }<EOL>    });<EOL>    <EOL>    const decorators = (Component as DecoratedClass).__decorators__;<EOL>    if (decorators) {<EOL>        decorators.forEach(fn => fn(","gt":"options));"}
{"input":"<s> function browsePackage(): Promise<void> {<EOL>    const quickPickPackageOptions: vscode.QuickPickOptions = {<EOL>        matchOnDescription: true,<EOL>        placeHolder:","gt":"'<STR_LIT>',"}
{"input":"<s> function browsePackage(): Promise<void> {<EOL>    const quickPickPackageOptions: vscode.QuickPickOptions = {<EOL>        matchOnDescription: true,<EOL>        placeHolder: '<STR_LIT>',<EOL>    };<EOL>    const quickPickVersionOptions: vscode.QuickPickOptions = {<EOL>        matchOnDescription:","gt":"false,"}
{"input":"<s> function browsePackage(): Promise<void> {<EOL>    const quickPickPackageOptions: vscode.QuickPickOptions = {<EOL>        matchOnDescription: true,<EOL>        placeHolder: '<STR_LIT>',<EOL>    };<EOL>    const quickPickVersionOptions: vscode.QuickPickOptions = {<EOL>        matchOnDescription: false,<EOL>        placeHolder: '<STR_LIT>',<EOL>    };<EOL>    return getJSON()<EOL>        .","gt":"then(transformToPackageQuickPickItems)"}
{"input":"<s> function browsePackage(): Promise<void> {<EOL>    const quickPickPackageOptions: vscode.QuickPickOptions = {<EOL>        matchOnDescription: true,<EOL>        placeHolder: '<STR_LIT>',<EOL>    };<EOL>    const quickPickVersionOptions: vscode.QuickPickOptions = {<EOL>        matchOnDescription: false,<EOL>        placeHolder: '<STR_LIT>',<EOL>    };<EOL>    return getJSON()<EOL>        .then(transformToPackageQuickPickItems)<EOL>        .then(packages => vscode.window.showQuickPick(packages, quickPickPackageOptions))<EOL>        .then(selectedPackage => {<EOL>        if (selectedPackage ===","gt":"undefined) {"}
{"input":"<s> function browsePackage(): Promise<void> {<EOL>    const quickPickPackageOptions: vscode.QuickPickOptions = {<EOL>        matchOnDescription: true,<EOL>        placeHolder: '<STR_LIT>',<EOL>    };<EOL>    const quickPickVersionOptions: vscode.QuickPickOptions = {<EOL>        matchOnDescription: false,<EOL>        placeHolder: '<STR_LIT>',<EOL>    };<EOL>    return getJSON()<EOL>        .then(transformToPackageQuickPickItems)<EOL>        .then(packages => vscode.window.showQuickPick(packages, quickPickPackageOptions))<EOL>        .then(selectedPackage => {<EOL>        if (selectedPackage === undefined) {<EOL>            return; <EOL>        }<EOL>        return vscode.window<EOL>            .showQuickPick(transformToPackageVersionQuickPickItems(","gt":"selectedPackage), quickPickVersionOptions)"}
{"input":"<s> function browsePackage(): Promise<void> {<EOL>    const quickPickPackageOptions: vscode.QuickPickOptions = {<EOL>        matchOnDescription: true,<EOL>        placeHolder: '<STR_LIT>',<EOL>    };<EOL>    const quickPickVersionOptions: vscode.QuickPickOptions = {<EOL>        matchOnDescription: false,<EOL>        placeHolder: '<STR_LIT>',<EOL>    };<EOL>    return getJSON()<EOL>        .then(transformToPackageQuickPickItems)<EOL>        .then(packages => vscode.window.showQuickPick(packages, quickPickPackageOptions))<EOL>        .then(selectedPackage => {<EOL>        if (selectedPackage === undefined) {<EOL>            return; <EOL>        }<EOL>        return vscode.window<EOL>            .showQuickPick(transformToPackageVersionQuickPickItems(selectedPackage), quickPickVersionOptions)<EOL>            .then(selectedVersion => {<EOL>            oc.show(vscode.ViewColumn.Three);<EOL>            let uri = selectedVersion<EOL>                ? vscode.Uri.parse('<STR_LIT>' +<EOL>                    selectedPackage.","gt":"label +"}
{"input":"<s> export function getComments(comments: Array<LuaComment>): string {<EOL>    if (comments == null)<EOL>        return \"<STR_LIT>\";<EOL>    var commentStr: string = \"<STR_LIT>\";<EOL>    if (comments.length == <NUM_LIT>) {<EOL>","gt":"return comments[<NUM_LIT>].content;"}
{"input":"<s> export function getComments(comments: Array<LuaComment>): string {<EOL>    if (comments == null)<EOL>        return \"<STR_LIT>\";<EOL>    var commentStr: string = \"<STR_LIT>\";<EOL>    if (comments.length == <NUM_LIT>) {<EOL>        return comments[<NUM_LIT>].content;<EOL>    }<EOL>    for (var i: number = <NUM_LIT>; i < comments.length; i++) {<EOL>        var comment = comments[i].content;<EOL>        var index = comment.trim().","gt":"indexOf(\"<STR_LIT>\");"}
{"input":"<s> /**<EOL> * Creates an Iterator with advanced chainable operator methods for any Iterable or Iterator<EOL> */<EOL>export function iterate<T>(collection: Iterator<T> | Iterable<T>): IteratorWithOperators<T> {<EOL>    return","gt":"new IteratorWithOperators(toIterator(collection));"}
{"input":"<s> function getLanguagesInDocument(document: TextDocument, regions: EmbeddedRegion[]): string[] {<EOL>    const result = ['<STR_LIT>'];<EOL>    for (const region of regions) {<EOL>","gt":"if (region.languageId && result.indexOf(region.languageId) === -<NUM_LIT>) {"}
{"input":"<s> function getParameterIndex(args: Array<string>, maxCount: number, index: number, callBack: Function) {<EOL>    vscode.window.showInputBox({ prompt: \"<STR_LIT>\" + (index + <NUM_LIT>), value: \"<STR_LIT>\" + (index + <NUM_LIT>) }).then(parameter => {<EOL>        args.push(parameter);<EOL>        if (index >= maxCount - <NUM_LIT>) {<EOL>","gt":"callBack(args);"}
{"input":"<s> function getParameterIndex(args: Array<string>, maxCount: number, index: number, callBack: Function) {<EOL>    vscode.window.showInputBox({ prompt: \"<STR_LIT>\" + (index + <NUM_LIT>), value: \"<STR_LIT>\" + (index + <NUM_LIT>) }).then(parameter => {<EOL>        args.push(parameter);<EOL>        if (index >= maxCount - <NUM_LIT>) {<EOL>            callBack(args);<EOL>        }<EOL>        else {<EOL>            index++;<EOL>            getParameterIndex(args, maxCount,","gt":"index, callBack);"}
{"input":"<s> export function getLogFiles(): ReadonlyArray<string> {<EOL>    const directory = path.join(getUserDataPath(), '<STR_LIT>');<EOL>    if (!fs.existsSync(directory)) {<EOL>","gt":"return [];"}
{"input":"<s> /**<EOL> * Convert an email address to a Gravatar URL format<EOL> *<EOL> * @param email The email address associated with a user<EOL> * @param size The size (in pixels) of the avatar to render<EOL> */<EOL>export function generateGravatarUrl(email: string, size: number = <NUM_LIT>): string {<EOL>    const input = email.trim().toLowerCase();<EOL>","gt":"const hash = crypto"}
{"input":"<s> <EOL><EOL><EOL><EOL><EOL>async function runTest(browser, port, { path, doneMsg, timeout }: Test) {<EOL>    let pass, fail;<EOL>    const promise = new Promise((res, rej) => { pass = res; fail = rej; });<EOL>    let timer =","gt":"null;"}
{"input":"<s> <EOL><EOL><EOL><EOL><EOL>async function runTest(browser, port, { path, doneMsg, timeout }: Test) {<EOL>    let pass, fail;<EOL>    const promise = new Promise((res, rej) => { pass = res; fail = rej; });<EOL>    let timer = null;<EOL>    const url = `<STR_LIT>`;<EOL>    console.log(\"<STR_LIT>\", url);<EOL>","gt":"const page = await browser.newPage();"}
{"input":"<s> <EOL><EOL><EOL><EOL><EOL>async function runTest(browser, port, { path, doneMsg, timeout }: Test) {<EOL>    let pass, fail;<EOL>    const promise = new Promise((res, rej) => { pass = res; fail = rej; });<EOL>    let timer = null;<EOL>    const url = `<STR_LIT>`;<EOL>    console.log(\"<STR_LIT>\", url);<EOL>    const page = await browser.newPage();<EOL>    page.on(\"<STR_LIT>\", onLoad);<EOL>    page.on(","gt":"\"<STR_LIT>\", onMessage);"}
{"input":"<s> <EOL><EOL><EOL><EOL><EOL>async function runTest(browser, port, { path, doneMsg, timeout }: Test) {<EOL>    let pass, fail;<EOL>    const promise = new Promise((res, rej) => { pass = res; fail = rej; });<EOL>    let timer = null;<EOL>    const url = `<STR_LIT>`;<EOL>    console.log(\"<STR_LIT>\", url);<EOL>    const page = await browser.newPage();<EOL>    page.on(\"<STR_LIT>\", onLoad);<EOL>    page.on(\"<STR_LIT>\", onMessage);<EOL>    page.on(\"<STR_LIT>\", onResponse);<EOL>    page.on(\"<STR_LIT>\", onError);<EOL>    page.goto(url, { timeout: <NUM_LIT> });<EOL>    try {<EOL>","gt":"await promise;"}
{"input":"<s> <EOL><EOL><EOL><EOL><EOL>async function runTest(browser, port, { path, doneMsg, timeout }: Test) {<EOL>    let pass, fail;<EOL>    const promise = new Promise((res, rej) => { pass = res; fail = rej; });<EOL>    let timer = null;<EOL>    const url = `<STR_LIT>`;<EOL>    console.log(\"<STR_LIT>\", url);<EOL>    const page = await browser.newPage();<EOL>    page.on(\"<STR_LIT>\", onLoad);<EOL>    page.on(\"<STR_LIT>\", onMessage);<EOL>    page.on(\"<STR_LIT>\", onResponse);<EOL>    page.on(\"<STR_LIT>\", onError);<EOL>    page.goto(url, { timeout: <NUM_LIT> });<EOL>    try {<EOL>        await promise;<EOL>        console.log(`<STR_LIT>`);<EOL>        return true;<EOL>    }<EOL>    catch (err) {<EOL>        console.log(err.message); <EOL>        console.log(`<STR_LIT>`);<EOL>        return","gt":"false;"}
{"input":"<s> <EOL><EOL><EOL><EOL><EOL>async function runTest(browser, port, { path, doneMsg, timeout }: Test) {<EOL>    let pass, fail;<EOL>    const promise = new Promise((res, rej) => { pass = res; fail = rej; });<EOL>    let timer = null;<EOL>    const url = `<STR_LIT>`;<EOL>    console.log(\"<STR_LIT>\", url);<EOL>    const page = await browser.newPage();<EOL>    page.on(\"<STR_LIT>\", onLoad);<EOL>    page.on(\"<STR_LIT>\", onMessage);<EOL>    page.on(\"<STR_LIT>\", onResponse);<EOL>    page.on(\"<STR_LIT>\", onError);<EOL>    page.goto(url, { timeout: <NUM_LIT> });<EOL>    try {<EOL>        await promise;<EOL>        console.log(`<STR_LIT>`);<EOL>        return true;<EOL>    }<EOL>    catch (err) {<EOL>        console.log(err.message); <EOL>        console.log(`<STR_LIT>`);<EOL>        return false;<EOL>    }<EOL>    finally {<EOL>        if (!debug)<EOL>            await page.close();<EOL>        cancelTimer();<EOL>    }<EOL>    function onLoad() {<EOL>","gt":"restartTimer();"}
{"input":"<s> <EOL><EOL><EOL><EOL><EOL>async function runTest(browser, port, { path, doneMsg, timeout }: Test) {<EOL>    let pass, fail;<EOL>    const promise = new Promise((res, rej) => { pass = res; fail = rej; });<EOL>    let timer = null;<EOL>    const url = `<STR_LIT>`;<EOL>    console.log(\"<STR_LIT>\", url);<EOL>    const page = await browser.newPage();<EOL>    page.on(\"<STR_LIT>\", onLoad);<EOL>    page.on(\"<STR_LIT>\", onMessage);<EOL>    page.on(\"<STR_LIT>\", onResponse);<EOL>    page.on(\"<STR_LIT>\", onError);<EOL>    page.goto(url, { timeout: <NUM_LIT> });<EOL>    try {<EOL>        await promise;<EOL>        console.log(`<STR_LIT>`);<EOL>        return true;<EOL>    }<EOL>    catch (err) {<EOL>        console.log(err.message); <EOL>        console.log(`<STR_LIT>`);<EOL>        return false;<EOL>    }<EOL>    finally {<EOL>        if (!debug)<EOL>            await page.close();<EOL>        cancelTimer();<EOL>    }<EOL>    function onLoad() {<EOL>        restartTimer();<EOL>    }<EOL>    function onError(browserError) {<EOL>        const err = new Error(prefix(browserError.message, \"<STR_LIT>\"));<EOL>        fail(err);<EOL>    }<EOL>    function onResponse(res) {<EOL>        <EOL>        <EOL>        if (!(res.ok || res.status === <NUM_LIT>)) {<EOL>            fail(new Error(`<STR_LIT>`));<EOL>        }<EOL>    }<EOL>    function onTimeOut() {<EOL>        fail(new Error(","gt":"timeout}ms)`<STR_LIT>;"}
{"input":"<s> <EOL><EOL><EOL><EOL><EOL>async function runTest(browser, port, { path, doneMsg, timeout }: Test) {<EOL>    let pass, fail;<EOL>    const promise = new Promise((res, rej) => { pass = res; fail = rej; });<EOL>    let timer = null;<EOL>    const url = `<STR_LIT>`;<EOL>    console.log(\"<STR_LIT>\", url);<EOL>    const page = await browser.newPage();<EOL>    page.on(\"<STR_LIT>\", onLoad);<EOL>    page.on(\"<STR_LIT>\", onMessage);<EOL>    page.on(\"<STR_LIT>\", onResponse);<EOL>    page.on(\"<STR_LIT>\", onError);<EOL>    page.goto(url, { timeout: <NUM_LIT> });<EOL>    try {<EOL>        await promise;<EOL>        console.log(`<STR_LIT>`);<EOL>        return true;<EOL>    }<EOL>    catch (err) {<EOL>        console.log(err.message); <EOL>        console.log(`<STR_LIT>`);<EOL>        return false;<EOL>    }<EOL>    finally {<EOL>        if (!debug)<EOL>            await page.close();<EOL>        cancelTimer();<EOL>    }<EOL>    function onLoad() {<EOL>        restartTimer();<EOL>    }<EOL>    function onError(browserError) {<EOL>        const err = new Error(prefix(browserError.message, \"<STR_LIT>\"));<EOL>        fail(err);<EOL>    }<EOL>    function onResponse(res) {<EOL>        <EOL>        <EOL>        if (!(res.ok || res.status === <NUM_LIT>)) {<EOL>            fail(new Error(`<STR_LIT>`));<EOL>        }<EOL>    }<EOL>    function onTimeOut() {<EOL>        fail(new Error(`<STR_LIT>`));<EOL>    }<EOL>    function onMessage(msg) {<EOL>        const values = msg.args.map(v => v._remoteObject.value !== undefined<EOL>            ? v._remoteObject.value<EOL>            : `<STR_LIT>`);<EOL>        const text = format.apply(null, values);<EOL>        console.log(prefix(text, \"<STR_LIT>\"));<EOL>","gt":"if (text.match(doneMsg)) {"}
{"input":"<s> <EOL><EOL><EOL><EOL><EOL>async function runTest(browser, port, { path, doneMsg, timeout }: Test) {<EOL>    let pass, fail;<EOL>    const promise = new Promise((res, rej) => { pass = res; fail = rej; });<EOL>    let timer = null;<EOL>    const url = `<STR_LIT>`;<EOL>    console.log(\"<STR_LIT>\", url);<EOL>    const page = await browser.newPage();<EOL>    page.on(\"<STR_LIT>\", onLoad);<EOL>    page.on(\"<STR_LIT>\", onMessage);<EOL>    page.on(\"<STR_LIT>\", onResponse);<EOL>    page.on(\"<STR_LIT>\", onError);<EOL>    page.goto(url, { timeout: <NUM_LIT> });<EOL>    try {<EOL>        await promise;<EOL>        console.log(`<STR_LIT>`);<EOL>        return true;<EOL>    }<EOL>    catch (err) {<EOL>        console.log(err.message); <EOL>        console.log(`<STR_LIT>`);<EOL>        return false;<EOL>    }<EOL>    finally {<EOL>        if (!debug)<EOL>            await page.close();<EOL>        cancelTimer();<EOL>    }<EOL>    function onLoad() {<EOL>        restartTimer();<EOL>    }<EOL>    function onError(browserError) {<EOL>        const err = new Error(prefix(browserError.message, \"<STR_LIT>\"));<EOL>        fail(err);<EOL>    }<EOL>    function onResponse(res) {<EOL>        <EOL>        <EOL>        if (!(res.ok || res.status === <NUM_LIT>)) {<EOL>            fail(new Error(`<STR_LIT>`));<EOL>        }<EOL>    }<EOL>    function onTimeOut() {<EOL>        fail(new Error(`<STR_LIT>`));<EOL>    }<EOL>    function onMessage(msg) {<EOL>        const values = msg.args.map(v => v._remoteObject.value !== undefined<EOL>            ? v._remoteObject.value<EOL>            : `<STR_LIT>`);<EOL>        const text = format.apply(null, values);<EOL>        console.log(prefix(text, \"<STR_LIT>\"));<EOL>        if (text.match(doneMsg)) {<EOL>            pass();<EOL>        }<EOL>        else {<EOL>            restartTimer();<EOL>        }<EOL>    }<EOL>","gt":"function restartTimer() {"}
{"input":"<s> <EOL><EOL><EOL><EOL><EOL>async function runTest(browser, port, { path, doneMsg, timeout }: Test) {<EOL>    let pass, fail;<EOL>    const promise = new Promise((res, rej) => { pass = res; fail = rej; });<EOL>    let timer = null;<EOL>    const url = `<STR_LIT>`;<EOL>    console.log(\"<STR_LIT>\", url);<EOL>    const page = await browser.newPage();<EOL>    page.on(\"<STR_LIT>\", onLoad);<EOL>    page.on(\"<STR_LIT>\", onMessage);<EOL>    page.on(\"<STR_LIT>\", onResponse);<EOL>    page.on(\"<STR_LIT>\", onError);<EOL>    page.goto(url, { timeout: <NUM_LIT> });<EOL>    try {<EOL>        await promise;<EOL>        console.log(`<STR_LIT>`);<EOL>        return true;<EOL>    }<EOL>    catch (err) {<EOL>        console.log(err.message); <EOL>        console.log(`<STR_LIT>`);<EOL>        return false;<EOL>    }<EOL>    finally {<EOL>        if (!debug)<EOL>            await page.close();<EOL>        cancelTimer();<EOL>    }<EOL>    function onLoad() {<EOL>        restartTimer();<EOL>    }<EOL>    function onError(browserError) {<EOL>        const err = new Error(prefix(browserError.message, \"<STR_LIT>\"));<EOL>        fail(err);<EOL>    }<EOL>    function onResponse(res) {<EOL>        <EOL>        <EOL>        if (!(res.ok || res.status === <NUM_LIT>)) {<EOL>            fail(new Error(`<STR_LIT>`));<EOL>        }<EOL>    }<EOL>    function onTimeOut() {<EOL>        fail(new Error(`<STR_LIT>`));<EOL>    }<EOL>    function onMessage(msg) {<EOL>        const values = msg.args.map(v => v._remoteObject.value !== undefined<EOL>            ? v._remoteObject.value<EOL>            : `<STR_LIT>`);<EOL>        const text = format.apply(null, values);<EOL>        console.log(prefix(text, \"<STR_LIT>\"));<EOL>        if (text.match(doneMsg)) {<EOL>            pass();<EOL>        }<EOL>        else {<EOL>            restartTimer();<EOL>        }<EOL>    }<EOL>    function restartTimer() {<EOL>","gt":"cancelTimer();"}
{"input":"<s> function getIpcFriendlyError(error: Error) {<EOL>    return {<EOL>        message:","gt":"error.message || `<STR_LIT>`,"}
{"input":"<s> function filter(name: string): boolean {<EOL>    if (filterRegExp) {<EOL>","gt":"return filterRegExp.test(name);"}
{"input":"<s> /** Find the menu item with the given ID. */<EOL>export function findMenuItemByID(menu: Electron.Menu, id: string): Electron.MenuItem | null {<EOL>    const items = menu.items;<EOL>    for (const item of items) {<EOL>        <EOL>        if ((item as any).id === id) {<EOL>            return","gt":"item;"}
{"input":"<s> /** Find the menu item with the given ID. */<EOL>export function findMenuItemByID(menu: Electron.Menu, id: string): Electron.MenuItem | null {<EOL>    const items = menu.items;<EOL>    for (const item of items) {<EOL>        <EOL>        if ((item as any).id === id) {<EOL>            return item;<EOL>        }<EOL>        <EOL>        const submenu = item.submenu as Electron.Menu;<EOL>","gt":"if (submenu) {"}
{"input":"<s> export function formatTrackTitle(title: string): string {<EOL>","gt":"if (!title)"}
{"input":"<s> export function streamUrl(url: string): string {<EOL>    return","gt":"url}?${CLIENT_ID_PARAM}`<STR_LIT>;"}
{"input":"<s> /**<EOL> * flatten() and inferShape were forked from deps/deeplearnjs/src/util.ts<EOL> *<EOL> * Copyright 2017 Google Inc. All Rights Reserved.<EOL> * Licensed under the Apache License, Version 2.0 (the \"License\");<EOL> * you may not use this file except in compliance with the License.<EOL> * You may obtain a copy of the License at<EOL> *<EOL> * http://www.apache.org/licenses/LICENSE-2.0<EOL> *<EOL> * Unless required by applicable law or agreed to in writing, software<EOL> * distributed under the License is distributed on an \"AS IS\" BASIS,<EOL> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.<EOL> * See the License for the specific language governing permissions and<EOL> * limitations under the License.<EOL> * =============================================================================<EOL> */<EOL>export function flatten(arr: number | boolean | RegularArray<number> | RegularArray<boolean>, ret: Array<number | boolean> = []): Array<number | boolean> {<EOL>    if (Array.isArray(arr)) {<EOL>        for (let i = <NUM_LIT>; i < arr.length; ++i) {<EOL>            flatten(arr[","gt":"i], ret);"}
{"input":"<s> function disallowedCharacter(value: string): boolean {<EOL>    if (value.length !== <NUM_LIT>) {<EOL>        return fatalError('<STR_LIT>');<EOL>    }<EOL>    const disallowedCharacters = [<EOL>        '<STR_LIT>',<EOL>","gt":"'<STR_LIT>',"}
{"input":"<s> function disallowedCharacter(value: string): boolean {<EOL>    if (value.length !== <NUM_LIT>) {<EOL>        return fatalError('<STR_LIT>');<EOL>    }<EOL>    const disallowedCharacters = [<EOL>        '<STR_LIT>',<EOL>        '<STR_LIT>',<EOL>        '<STR_LIT>',<EOL>        '<STR_LIT>',<EOL>        '<STR_LIT>',<EOL>","gt":"'<STR_LIT>',"}
{"input":"<s> function disallowedCharacter(value: string): boolean {<EOL>    if (value.length !== <NUM_LIT>) {<EOL>        return fatalError('<STR_LIT>');<EOL>    }<EOL>    const disallowedCharacters = [<EOL>        '<STR_LIT>',<EOL>        '<STR_LIT>',<EOL>        '<STR_LIT>',<EOL>        '<STR_LIT>',<EOL>        '<STR_LIT>',<EOL>        '<STR_LIT>',<EOL>        '<STR_LIT>',<EOL>        '<STR_LIT>',<EOL>        \"<STR_LIT>\",<EOL>","gt":"'<STR_LIT>',"}
{"input":"<s> function dtypeDL(propelDtype: types.DType): DTypeDL {<EOL>    switch (propelDtype) {<EOL>        case \"<STR_LIT>\":<EOL>        case","gt":"\"<STR_LIT>\":"}
{"input":"<s> /**<EOL> * Reject the current OAuth request with the given error.<EOL> *<EOL> * Note that this can only be called after `askUserToOAuth` has been called and<EOL> * must only be called once.<EOL> */<EOL>export function rejectOAuthRequest(error: Error) {<EOL>    if (!oauthState) {<EOL>","gt":"fatalError('<STR_LIT>');"}
{"input":"<s> async function getResolvedInstallPath(): Promise<string | null> {<EOL>    return new Promise<string | null>((resolve, reject) => {<EOL>        Fs.readlink(InstalledCLIPath, (err, realpath) => {<EOL>            if (err) {<EOL>                resolve(","gt":"null);"}
{"input":"<s> function readLatestMigration(): string {<EOL>    const angularCli = JSON.parse(","gt":"fs.readFileSync('<STR_LIT>').toString());"}
{"input":"<s> function runRule(ruleArguments: any, content: string, libNames: string[] = ['<STR_LIT>'], appNames: string[] = []): RuleFailure[] {<EOL>    const options: any = {<EOL>        ruleArguments: [ruleArguments],<EOL>","gt":"ruleSeverity: '<STR_LIT>',"}
{"input":"<s> export default function (options: Schema): Rule {<EOL>    const fullPath = path.join(options.directory, toFileName(options.name), options.sourceDir);<EOL>    return chain([<EOL>        mergeWith(apply(url('<STR_LIT>'), [template({ ...options, ...names(options.name), dot: '<STR_LIT>', tmpl: '<STR_LIT>' })])),<EOL>        externalSchematic('<STR_LIT>', '<STR_LIT>', {<EOL>","gt":"name: '<STR_LIT>',"}
{"input":"<s> export default function (options: Schema): Rule {<EOL>    const fullPath = path.join(options.directory, toFileName(options.name), options.sourceDir);<EOL>    return chain([<EOL>        mergeWith(apply(url('<STR_LIT>'), [template({ ...options, ...names(options.name), dot: '<STR_LIT>', tmpl: '<STR_LIT>' })])),<EOL>        externalSchematic('<STR_LIT>', '<STR_LIT>', {<EOL>            name: '<STR_LIT>',<EOL>            commonModule: false,<EOL>            flat: true,<EOL>            routing:","gt":"options.routing,"}
{"input":"<s> export default function (options: Schema): Rule {<EOL>    const fullPath = path.join(options.directory, toFileName(options.name), options.sourceDir);<EOL>    return chain([<EOL>        mergeWith(apply(url('<STR_LIT>'), [template({ ...options, ...names(options.name), dot: '<STR_LIT>', tmpl: '<STR_LIT>' })])),<EOL>        externalSchematic('<STR_LIT>', '<STR_LIT>', {<EOL>            name: '<STR_LIT>',<EOL>            commonModule: false,<EOL>            flat: true,<EOL>            routing: options.routing,<EOL>            sourceDir: fullPath,<EOL>            spec: false<EOL>        }),<EOL>        externalSchematic('<STR_LIT>', '<STR_LIT>', {<EOL>            name: '<STR_LIT>',<EOL>            selector:","gt":"options.prefix}-root`<STR_LIT>,"}
{"input":"<s> export default function (options: Schema): Rule {<EOL>    const fullPath = path.join(options.directory, toFileName(options.name), options.sourceDir);<EOL>    return chain([<EOL>        mergeWith(apply(url('<STR_LIT>'), [template({ ...options, ...names(options.name), dot: '<STR_LIT>', tmpl: '<STR_LIT>' })])),<EOL>        externalSchematic('<STR_LIT>', '<STR_LIT>', {<EOL>            name: '<STR_LIT>',<EOL>            commonModule: false,<EOL>            flat: true,<EOL>            routing: options.routing,<EOL>            sourceDir: fullPath,<EOL>            spec: false<EOL>        }),<EOL>        externalSchematic('<STR_LIT>', '<STR_LIT>', {<EOL>            name: '<STR_LIT>',<EOL>            selector: `<STR_LIT>`,<EOL>            sourceDir: fullPath,<EOL>            flat: true,<EOL>            inlineStyle: options.inlineStyle,<EOL>            inlineTemplate: options.inlineTemplate,<EOL>            spec: !options.skipTests,<EOL>","gt":"styleext: options.style,"}
{"input":"<s> function addLazyLoadedRouterConfiguration(modulePath: string): Rule {<EOL>    return (host: Tree) => {<EOL>        const moduleSource = host.read(modulePath)!.toString('<STR_LIT>');<EOL>        const","gt":"sourceFile = ts.createSourceFile(modulePath, moduleSource, ts.ScriptTarget.Latest, true);"}
{"input":"<s> function addNgRxToPackageJson() {<EOL>    return (host: Tree) => {<EOL>        if (!host.exists('<STR_LIT>'))<EOL>            return host;<EOL>        const sourceText = host.read('<STR_LIT>')!.toString('<STR_LIT>');<EOL>        const json = JSON.","gt":"parse(sourceText);"}
{"input":"<s> function addNgRxToPackageJson() {<EOL>    return (host: Tree) => {<EOL>        if (!host.exists('<STR_LIT>'))<EOL>            return host;<EOL>        const sourceText = host.read('<STR_LIT>')!.toString('<STR_LIT>');<EOL>        const json = JSON.parse(sourceText);<EOL>        if (!json['<STR_LIT>']) {<EOL>            json['<STR_LIT>'] = {};<EOL>        }<EOL>        if (!json['<STR_LIT>']['<STR_LIT>']) {<EOL>            json['<STR_LIT>']['<STR_LIT>'] = ngrxVersion;<EOL>        }<EOL>        if (!json['<STR_LIT>']['<STR_LIT>']) {<EOL>","gt":"json['<STR_LIT>']['<STR_LIT>'] = routerStoreVersion;"}
{"input":"<s> function addNgRxToPackageJson() {<EOL>    return (host: Tree) => {<EOL>        if (!host.exists('<STR_LIT>'))<EOL>            return host;<EOL>        const sourceText = host.read('<STR_LIT>')!.toString('<STR_LIT>');<EOL>        const json = JSON.parse(sourceText);<EOL>        if (!json['<STR_LIT>']) {<EOL>            json['<STR_LIT>'] = {};<EOL>        }<EOL>        if (!json['<STR_LIT>']['<STR_LIT>']) {<EOL>            json['<STR_LIT>']['<STR_LIT>'] = ngrxVersion;<EOL>        }<EOL>        if (!json['<STR_LIT>']['<STR_LIT>']) {<EOL>            json['<STR_LIT>']['<STR_LIT>'] = routerStoreVersion;<EOL>        }<EOL>        if (!json['<STR_LIT>']['<STR_LIT>']) {<EOL>            json['<STR_LIT>']['<STR_LIT>'] = ngrxVersion;<EOL>        }<EOL>        if (!json['<STR_LIT>'][","gt":"'<STR_LIT>']) {"}
{"input":"<s> function packageOSX() {<EOL>    const dest = getOSXZipPath();<EOL>    fs.removeSync(","gt":"dest);"}
{"input":"<s> function addTasks(options: Schema, context: SchematicContext) {<EOL>    let packageTask;<EOL>    if (!options.skipInstall) {<EOL>        packageTask = context.addTask(new NodePackageInstallTask(","gt":"options.directory));"}
{"input":"<s> export function assertShapesMatch(shapeA: number[], shapeB: number[], errorMessagePrefix = \"<STR_LIT>\"): void {<EOL>    assert(arraysEqual(shapeA, shapeB), errorMessagePrefix +","gt":"} and ${shapeB} must match`<STR_LIT>;"}
{"input":"<s> /** Get the hostname to use for the given remote. */<EOL>export function getGenericHostname(remoteURL: string): string {<EOL>    const parsed = parseRemote(remoteURL);<EOL>    if (parsed) {<EOL>        return","gt":"parsed.hostname;"}
{"input":"<s> /** Get the username for the host. */<EOL>export function getGenericUsername(hostname: string): string | null {<EOL>","gt":"const key = getKeyForUsername(hostname);"}
{"input":"<s> /**<EOL> * Get the version of the app.<EOL> *<EOL> * This is preferrable to using `remote` directly because we cache the result.<EOL> */<EOL>export function getVersion(): string {<EOL>    if (!version) {<EOL>        version = getApp().","gt":"getVersion();"}
{"input":"<s> function loseContext(gl: WebGLRenderingContext) {<EOL>    if (gl != null) {<EOL>        const loseContextExtension = gl.getExtension(\"<STR_LIT>\");<EOL>","gt":"if (loseContextExtension == null) {"}
{"input":"<s> export function fileExists(filePath: string): boolean {<EOL>    try {<EOL>        return statSync(","gt":"filePath).isFile();"}
{"input":"<s> export function addDeclarationToModule(source: ts.SourceFile, modulePath: string, symbolName: string): Change[] {<EOL>","gt":"return _addSymbolToNgModuleMetadata(source, modulePath, '<STR_LIT>', symbolName);"}
{"input":"<s> export function getTouchedProjects(touchedFiles: string[]): string[] {<EOL>    const config = JSON.parse(fs.readFileSync('<STR_LIT>', '<STR_LIT>'));<EOL>    const projects = getProjectNodes(","gt":"config);"}
{"input":"<s> function readLatestMigration(): string {<EOL>    const angularCli = JSON.parse(","gt":"fs.readFileSync('<STR_LIT>').toString());"}
{"input":"<s> function isWebGLDisjointQueryTimerEnabled(webGLVersion: number) {<EOL>    const gl = getWebGLRenderingContext(webGLVersion);<EOL>    const extensionName = webGLVersion === <NUM_LIT> ? \"<STR_LIT>\" :<EOL>","gt":"\"<STR_LIT>\";"}
{"input":"<s> function parseChannel(arg: string): Channel {<EOL>    if (arg === '<STR_LIT>' || arg === '<STR_LIT>' || arg === '<STR_LIT>') {<EOL>        return","gt":"arg;"}
{"input":"<s> /**<EOL> * Lookup a suitable email address to display in the application, based on the<EOL> * following rules:<EOL> *<EOL> *  - the primary email if it's publicly visible<EOL> *  - the first public email<EOL> *  - an '@users.noreply.github.com' email address<EOL> *  - the first email address<EOL> *<EOL> * Otherwise just return null<EOL> *<EOL> * @param emails array of email addresses associated with an account<EOL> */<EOL>export function lookupPreferredEmail(emails: ReadonlyArray<IAPIEmail>): IAPIEmail | null {<EOL>    if (emails.length === <NUM_LIT>) {<EOL>        return null;<EOL>    }<EOL>    const","gt":"primary = emails.find(e => e.primary);"}
{"input":"<s> /**<EOL> * Lookup a suitable email address to display in the application, based on the<EOL> * following rules:<EOL> *<EOL> *  - the primary email if it's publicly visible<EOL> *  - the first public email<EOL> *  - an '@users.noreply.github.com' email address<EOL> *  - the first email address<EOL> *<EOL> * Otherwise just return null<EOL> *<EOL> * @param emails array of email addresses associated with an account<EOL> */<EOL>export function lookupPreferredEmail(emails: ReadonlyArray<IAPIEmail>): IAPIEmail | null {<EOL>    if (emails.length === <NUM_LIT>) {<EOL>        return null;<EOL>    }<EOL>    const primary = emails.find(e => e.primary);<EOL>    if (primary && isEmailPublic(primary)) {<EOL>        return primary;<EOL>    }<EOL>    const noReply = emails.find(e => e.email.toLowerCase().endsWith('<STR_LIT>'));<EOL>    if (noReply) {<EOL>","gt":"return noReply;"}
{"input":"<s> export async function externalEditorErrorHandler(error: Error, dispatcher: Dispatcher): Promise<Error | null> {<EOL>    const e = asEditorError(error);<EOL>    if (!e) {<EOL>        return error;<EOL>    }<EOL>    const { suggestAtom, openPreferences } = e.metadata;<EOL>    await dispatcher.showPopup({<EOL>        type: PopupType.ExternalEditorFailed,<EOL>        message: e.message,<EOL>        suggestAtom,<EOL>","gt":"openPreferences,"}
{"input":"<s> /** Like range() but outputs a javascript array of numbers. */<EOL>function rangeJS(limit: number): number[] {<EOL>    const r = new Array(limit);<EOL>    for (let i = <NUM_LIT>; i < limit;","gt":"i++) {"}
{"input":"<s> /** Open the merge tool for the given file. */<EOL>export async function openMergeTool(repository: Repository, path: string): Promise<void> {<EOL>    await git(['<STR_LIT>',","gt":"path], repository.path, '<STR_LIT>');"}
{"input":"<s> function getSampler1D(inputInfo: InputInfo): string {<EOL>    const texName =","gt":"inputInfo.name;"}
{"input":"<s> <EOL>export function execute0(opName: string, inputs: TensorTF[], attrs): TensorTF {<EOL>    const handles = inputs.map((t) => t.handle);<EOL>    const r = binding.execute(","gt":"ctx, opName, attrs, handles);"}
{"input":"<s> export function getCoordsDataType(rank: number): string {<EOL>    if (rank === <NUM_LIT>) {<EOL>        return \"<STR_LIT>\";<EOL>    }<EOL>    else if (rank === <NUM_LIT>) {<EOL>","gt":"return \"<STR_LIT>\";"}
{"input":"<s> /**<EOL> * Get a list of files which have recorded changes in the index as compared to<EOL> * HEAD along with the type of change.<EOL> *<EOL> * @param repository The repository for which to retrieve the index changes.<EOL> */<EOL>export async function getIndexChanges(repository: Repository): Promise<Map<string, NoRenameIndexStatus>> {<EOL>    const args = ['<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>'];<EOL>    let result = await git([...args, '<STR_LIT>', '<STR_LIT>'], repository.path, '<STR_LIT>', {<EOL>        successExitCodes: new Set([<NUM_LIT>, <NUM_LIT>]),<EOL>    });<EOL>    <EOL>    <EOL>    <EOL>    if (result.exitCode === <NUM_LIT>) {<EOL>        result = await git([...args, NullTreeSHA], repository.path, '<STR_LIT>');<EOL>    }<EOL>    const map = new Map<string, NoRenameIndexStatus>();<EOL>    const pieces = result.stdout.split('<STR_LIT>');<EOL>    for (let i = <NUM_LIT>; i < pieces.length - <NUM_LIT>; i += <NUM_LIT>) {<EOL>","gt":"const status = getNoRenameIndexStatus(pieces[i]);"}
{"input":"<s> /**<EOL> * Returns a callback which can be passed along to the processCallback option<EOL> * in IGitExecution. The callback then takes care of reading stderr of the<EOL> * process and parsing its contents using the provided parser.<EOL> */<EOL>function createProgressProcessCallback(parser: GitProgressParser, lfsProgressPath: string | null, progressCallback: (progress: IGitProgress | IGitOutput) => void): (process: ChildProcess) => void {<EOL>    return process => {<EOL>        if (lfsProgressPath) {<EOL>            const lfsParser = new GitLFSProgressParser();<EOL>            const disposable = tailByLine(lfsProgressPath, line => {<EOL>                const progress = lfsParser.parse(line);<EOL>                progressCallback(","gt":"progress);"}
{"input":"<s> export function STEP(alpha = <NUM_LIT>) {<EOL>","gt":"return CHECK_NAN_SNIPPET + `<STR_LIT>`"}
{"input":"<s> /**<EOL> * Render the diff for a file within the repository working directory. The file will be<EOL> * compared against HEAD if it's tracked, if not it'll be compared to an empty file meaning<EOL> * that all content in the file will be treated as additions.<EOL> */<EOL>export async function getWorkingDirectoryDiff(repository: Repository, file: WorkingDirectoryFileChange): Promise<IDiff> {<EOL>    let successExitCodes: Set<number> | undefined;<EOL>    let args: Array<string>;<EOL>    <EOL>    <EOL>    if (file.status === AppFileStatus.New) {<EOL>        <EOL>        <EOL>        <EOL>        <EOL>        <EOL>        <EOL>        <EOL>        <EOL>        <EOL>        <EOL>        successExitCodes = new Set([<NUM_LIT>, <NUM_LIT>]);<EOL>        args = [<EOL>            '<STR_LIT>',<EOL>            '<STR_LIT>',<EOL>            '<STR_LIT>',<EOL>            '<STR_LIT>',<EOL>","gt":"'<STR_LIT>',"}
{"input":"<s> /**<EOL> * Render the diff for a file within the repository working directory. The file will be<EOL> * compared against HEAD if it's tracked, if not it'll be compared to an empty file meaning<EOL> * that all content in the file will be treated as additions.<EOL> */<EOL>export async function getWorkingDirectoryDiff(repository: Repository, file: WorkingDirectoryFileChange): Promise<IDiff> {<EOL>    let successExitCodes: Set<number> | undefined;<EOL>    let args: Array<string>;<EOL>    <EOL>    <EOL>    if (file.status === AppFileStatus.New) {<EOL>        <EOL>        <EOL>        <EOL>        <EOL>        <EOL>        <EOL>        <EOL>        <EOL>        <EOL>        <EOL>        successExitCodes = new Set([<NUM_LIT>, <NUM_LIT>]);<EOL>        args = [<EOL>            '<STR_LIT>',<EOL>            '<STR_LIT>',<EOL>            '<STR_LIT>',<EOL>            '<STR_LIT>',<EOL>            '<STR_LIT>',<EOL>            '<STR_LIT>',<EOL>            '<STR_LIT>',<EOL>            '<STR_LIT>',<EOL>            file.path,<EOL>        ];<EOL>    }<EOL>    else if (file.status === AppFileStatus.Renamed) {<EOL>        <EOL>        <EOL>        <EOL>        <EOL>        <EOL>        <EOL>        <EOL>        args = [<EOL>            '<STR_LIT>',<EOL>","gt":"'<STR_LIT>',"}
{"input":"<s> /**<EOL> * Render the diff for a file within the repository working directory. The file will be<EOL> * compared against HEAD if it's tracked, if not it'll be compared to an empty file meaning<EOL> * that all content in the file will be treated as additions.<EOL> */<EOL>export async function getWorkingDirectoryDiff(repository: Repository, file: WorkingDirectoryFileChange): Promise<IDiff> {<EOL>    let successExitCodes: Set<number> | undefined;<EOL>    let args: Array<string>;<EOL>    <EOL>    <EOL>    if (file.status === AppFileStatus.New) {<EOL>        <EOL>        <EOL>        <EOL>        <EOL>        <EOL>        <EOL>        <EOL>        <EOL>        <EOL>        <EOL>        successExitCodes = new Set([<NUM_LIT>, <NUM_LIT>]);<EOL>        args = [<EOL>            '<STR_LIT>',<EOL>            '<STR_LIT>',<EOL>            '<STR_LIT>',<EOL>            '<STR_LIT>',<EOL>            '<STR_LIT>',<EOL>            '<STR_LIT>',<EOL>            '<STR_LIT>',<EOL>            '<STR_LIT>',<EOL>            file.path,<EOL>        ];<EOL>    }<EOL>    else if (file.status === AppFileStatus.Renamed) {<EOL>        <EOL>        <EOL>        <EOL>        <EOL>        <EOL>        <EOL>        <EOL>        args = [<EOL>            '<STR_LIT>',<EOL>            '<STR_LIT>',<EOL>            '<STR_LIT>',<EOL>            '<STR_LIT>',<EOL>","gt":"'<STR_LIT>',"}
{"input":"<s> /**<EOL> * Render the diff for a file within the repository working directory. The file will be<EOL> * compared against HEAD if it's tracked, if not it'll be compared to an empty file meaning<EOL> * that all content in the file will be treated as additions.<EOL> */<EOL>export async function getWorkingDirectoryDiff(repository: Repository, file: WorkingDirectoryFileChange): Promise<IDiff> {<EOL>    let successExitCodes: Set<number> | undefined;<EOL>    let args: Array<string>;<EOL>    <EOL>    <EOL>    if (file.status === AppFileStatus.New) {<EOL>        <EOL>        <EOL>        <EOL>        <EOL>        <EOL>        <EOL>        <EOL>        <EOL>        <EOL>        <EOL>        successExitCodes = new Set([<NUM_LIT>, <NUM_LIT>]);<EOL>        args = [<EOL>            '<STR_LIT>',<EOL>            '<STR_LIT>',<EOL>            '<STR_LIT>',<EOL>            '<STR_LIT>',<EOL>            '<STR_LIT>',<EOL>            '<STR_LIT>',<EOL>            '<STR_LIT>',<EOL>            '<STR_LIT>',<EOL>            file.path,<EOL>        ];<EOL>    }<EOL>    else if (file.status === AppFileStatus.Renamed) {<EOL>        <EOL>        <EOL>        <EOL>        <EOL>        <EOL>        <EOL>        <EOL>        args = [<EOL>            '<STR_LIT>',<EOL>            '<STR_LIT>',<EOL>            '<STR_LIT>',<EOL>            '<STR_LIT>',<EOL>            '<STR_LIT>',<EOL>            '<STR_LIT>',<EOL>            file.path,<EOL>        ];<EOL>    }<EOL>    else {<EOL>        args = [<EOL>            '<STR_LIT>',<EOL>            '<STR_LIT>',<EOL>            '<STR_LIT>',<EOL>            '<STR_LIT>',<EOL>            '<STR_LIT>',<EOL>            '<STR_LIT>',<EOL>            '<STR_LIT>',<EOL>            file.path,<EOL>        ];<EOL>    }<EOL>    const { output, error } =","gt":"await spawnAndComplete(args, repository.path, '<STR_LIT>', successExitCodes);"}
{"input":"<s> /**<EOL> * Merge one or more commit message trailers into a commit message.<EOL> *<EOL> * If no trailers are given this method will simply try to ensure that<EOL> * any trailers that happen to be part of the raw message are formatted<EOL> * in accordance with the configuration options set for trailers in<EOL> * the given repository.<EOL> *<EOL> * Note that configuration may be set so that duplicate trailers are<EOL> * kept or discarded.<EOL> *<EOL> * @param repository    The repository in which to run the interpret-<EOL> *                      trailers command. Although not intuitive this<EOL> *                      does matter as there are configuration options<EOL> *                      available for the format, position, etc of commit<EOL> *                      message trailers. See the manpage for<EOL> *                      git-interpret-trailers for more information.<EOL> *<EOL> * @param commitMessage A commit message with or withot existing commit<EOL> *                      message trailers into which to merge the trailers<EOL> *                      given in the trailers parameter<EOL> *<EOL> * @param trailers      Zero or more trailers to merge into the commit message<EOL> *<EOL> * @returns             A commit message string where the provided trailers (if)<EOL> *                      any have been merged into the commit message using the<EOL> *                      configuration settings for trailers in the provided<EOL> *                      repository.<EOL> */<EOL>export async function mergeTrailers(repository: Repository, commitMessage: string, trailers: ReadonlyArray<ITrailer>, unfold: boolean = false) {<EOL>    const args = ['<STR_LIT>'];<EOL>    if (unfold) {<EOL>        args.push('<STR_LIT>');<EOL>    }<EOL>    for (const trailer of trailers) {<EOL>        args.push('<STR_LIT>', `<STR_LIT>`);<EOL>    }<EOL>    const result = await git(args, repository.path, '<STR_LIT>', {<EOL>","gt":"stdin: commitMessage,"}
{"input":"<s> /** Get the user agent to use for all requests. */<EOL>function getUserAgent() {<EOL>    const platform =","gt":"__DARWIN__ ? '<STR_LIT>' : '<STR_LIT>';"}
{"input":"<s> /**<EOL> * Map the raw status text from Git to an app-friendly value<EOL> * shamelessly borrowed from GitHub Desktop (Windows)<EOL> */<EOL>function mapStatus(rawStatus: string): AppFileStatus {<EOL>    const status = rawStatus.trim();<EOL>    if (status === '<STR_LIT>') {<EOL>        return AppFileStatus.Modified;<EOL>    } <EOL>    if (","gt":"status === '<STR_LIT>') {"}
{"input":"<s> /**<EOL> * Map the raw status text from Git to an app-friendly value<EOL> * shamelessly borrowed from GitHub Desktop (Windows)<EOL> */<EOL>function mapStatus(rawStatus: string): AppFileStatus {<EOL>    const status = rawStatus.trim();<EOL>    if (status === '<STR_LIT>') {<EOL>        return AppFileStatus.Modified;<EOL>    } <EOL>    if (status === '<STR_LIT>') {<EOL>        return AppFileStatus.New;<EOL>    } <EOL>    if (","gt":"status === '<STR_LIT>') {"}
{"input":"<s> /**<EOL> * Map the raw status text from Git to an app-friendly value<EOL> * shamelessly borrowed from GitHub Desktop (Windows)<EOL> */<EOL>function mapStatus(rawStatus: string): AppFileStatus {<EOL>    const status = rawStatus.trim();<EOL>    if (status === '<STR_LIT>') {<EOL>        return AppFileStatus.Modified;<EOL>    } <EOL>    if (status === '<STR_LIT>') {<EOL>        return AppFileStatus.New;<EOL>    } <EOL>    if (status === '<STR_LIT>') {<EOL>        return AppFileStatus.Deleted;<EOL>    } <EOL>    if (","gt":"status === '<STR_LIT>') {"}
{"input":"<s> /**<EOL> * Map the raw status text from Git to an app-friendly value<EOL> * shamelessly borrowed from GitHub Desktop (Windows)<EOL> */<EOL>function mapStatus(rawStatus: string): AppFileStatus {<EOL>    const status = rawStatus.trim();<EOL>    if (status === '<STR_LIT>') {<EOL>        return AppFileStatus.Modified;<EOL>    } <EOL>    if (status === '<STR_LIT>') {<EOL>        return AppFileStatus.New;<EOL>    } <EOL>    if (status === '<STR_LIT>') {<EOL>        return AppFileStatus.Deleted;<EOL>    } <EOL>    if (status === '<STR_LIT>') {<EOL>        return AppFileStatus.Renamed;<EOL>    } <EOL>","gt":"if (status === '<STR_LIT>') {"}
{"input":"<s> /**<EOL> * Map the raw status text from Git to an app-friendly value<EOL> * shamelessly borrowed from GitHub Desktop (Windows)<EOL> */<EOL>function mapStatus(rawStatus: string): AppFileStatus {<EOL>    const status = rawStatus.trim();<EOL>    if (status === '<STR_LIT>') {<EOL>        return AppFileStatus.Modified;<EOL>    } <EOL>    if (status === '<STR_LIT>') {<EOL>        return AppFileStatus.New;<EOL>    } <EOL>    if (status === '<STR_LIT>') {<EOL>        return AppFileStatus.Deleted;<EOL>    } <EOL>    if (status === '<STR_LIT>') {<EOL>        return AppFileStatus.Renamed;<EOL>    } <EOL>    if (status === '<STR_LIT>') {<EOL>        return AppFileStatus.Copied;<EOL>    } <EOL>    <EOL>    if (status.match(/R[0-9]+/)) {<EOL>","gt":"return AppFileStatus.Renamed;"}
{"input":"<s> function getAskPassScriptPath(): string {<EOL>    return","gt":"Path.resolve(__dirname, '<STR_LIT>');"}
{"input":"<s> /** Parse the label into the specified shell type. */<EOL>export function parse(label: string): Shell {<EOL>    if (__DARWIN__) {<EOL>        return Darwin.parse(label);<EOL>    }<EOL>    else","gt":"if (__WIN32__) {"}
{"input":"<s> /** Parse the label into the specified shell type. */<EOL>export function parse(label: string): Shell {<EOL>    if (__DARWIN__) {<EOL>        return Darwin.parse(label);<EOL>    }<EOL>    else if (__WIN32__) {<EOL>        return Win32.parse(label);<EOL>    }<EOL>    else if (__LINUX__) {<EOL>        return Linux.parse(","gt":"label);"}
{"input":"<s> function getTextureType(gl: WebGLRenderingContext) {<EOL>    if (!ENV.get(\"<STR_LIT>\")) {<EOL>","gt":"return gl.UNSIGNED_BYTE;"}
{"input":"<s> export async function downloadMatrixFromOutputTextureAsync(<EOL><EOL>gl: WebGLRenderingContext, getBufferSubDataAsyncExtension: any, rows: number, columns: number): Promise<Float32Array> {<EOL>    <EOL>    const gl2 = gl as any;<EOL>    const channelsPerPixel = <NUM_LIT>;<EOL>    const downloadTarget = getDownloadTargetArrayBuffer(rows, columns, channelsPerPixel);<EOL>    <EOL>    const bufferSizeBytes = downloadTarget instanceof Float32Array ?<EOL>        downloadTarget.length * <NUM_LIT> :<EOL>        downloadTarget;<EOL>    const buffer = gl.createBuffer();<EOL>    webgl_util.callAndCheck(gl, () => gl.bindBuffer(gl2.PIXEL_PACK_BUFFER, buffer));<EOL>    webgl_util.callAndCheck(gl, () => gl.bufferData(gl2.PIXEL_PACK_BUFFER, bufferSizeBytes,","gt":"gl.STATIC_DRAW));"}
{"input":"<s> function deriveResponse({ to, from, page }: ListRange & ListPage, { type, uuid, items, max, $entities }: List): List & ListPage {<EOL>    const stored = MemoryRetrieve(`<STR_LIT>`);<EOL>    storeList({<EOL>        uuid,<EOL>        items: Object.assign((stored && stored.items) || {}, items),<EOL>        max,<EOL>","gt":"type,"}
{"input":"<s> function deriveResponse({ to, from, page }: ListRange & ListPage, { type, uuid, items, max, $entities }: List): List & ListPage {<EOL>    const stored = MemoryRetrieve(`<STR_LIT>`);<EOL>    storeList({<EOL>        uuid,<EOL>        items: Object.assign((stored && stored.items) || {}, items),<EOL>        max,<EOL>        type,<EOL>        $entities,<EOL>    });<EOL>    return {<EOL>","gt":"uuid,"}
{"input":"<s> function deriveResponse({ to, from, page }: ListRange & ListPage, { type, uuid, items, max, $entities }: List): List & ListPage {<EOL>    const stored = MemoryRetrieve(`<STR_LIT>`);<EOL>    storeList({<EOL>        uuid,<EOL>        items: Object.assign((stored && stored.items) || {}, items),<EOL>        max,<EOL>        type,<EOL>        $entities,<EOL>    });<EOL>    return {<EOL>        uuid,<EOL>        items: Object.assign({}, ...Object.keys(items)<EOL>            .filter(key => Number(key) >= from && Number(key) <= to)<EOL>            .map(key => ({ [key]: items[key] }))),<EOL>","gt":"type,"}
{"input":"<s> export function rank(url: string): number {<EOL>    return (strip(","gt":"url).match(/\\/+/g) || '<STR_LIT>').length;"}
{"input":"<s> /**<EOL> * Generate colors for line|bar charts<EOL> * @param index<EOL> * @returns {number[]|Color}<EOL> */<EOL>function generateColor(index: number): number[] {<EOL>    return BaseChartDirective.","gt":"defaultColors[index] || getRandomColor();"}
{"input":"<s> <EOL>function setProperty(renderer: Renderer, elementRef: ElementRef, propName: string, propValue: any): void {<EOL>    renderer.","gt":"setElementProperty(elementRef, propName, propValue);"}
{"input":"<s> export function getDate(date: Date, isUTC = false): number {<EOL>    return","gt":"isUTC ? date.getUTCDate() : date.getDate();"}
{"input":"<s> export function calendar(date: Date, time: Date, formats: CalendarSpec, locale: Locale = getLocale(), config: DateParsingConfig = {}): string {<EOL>    <EOL>    <EOL>    const now = time;<EOL>    const sod = startOf(cloneWithOffset(now, date, config), '<STR_LIT>', config._isUTC);<EOL>    const format = getCalendarFormat(date, sod, { _isUTC: true, _offset: <NUM_LIT> }) || '<STR_LIT>';<EOL>    let","gt":"output;"}
{"input":"<s> export function daysInMonth(date: Date): number {<EOL>","gt":"return _daysInMonth(date.getFullYear(), date.getMonth());"}
{"input":"<s> function getElements(fixture: any, selector: string) {<EOL>    return","gt":"fixture.nativeElement.querySelectorAll(selector) as HTMLElement;"}
{"input":"<s> function formatReducer(state: BsDatepickerState, action: Action): BsDatepickerState {<EOL>    if (state.view.mode === '<STR_LIT>') {<EOL>        const formattedMonths = state.monthsModel.map((month, monthIndex) => formatDaysCalendar(month, getFormatOptions(state), monthIndex));<EOL>        return Object.assign({}, state, { formattedMonths });<EOL>    }<EOL>    <EOL>    const displayMonths =","gt":"state.displayMonths;"}
{"input":"<s> function formatReducer(state: BsDatepickerState, action: Action): BsDatepickerState {<EOL>    if (state.view.mode === '<STR_LIT>') {<EOL>        const formattedMonths = state.monthsModel.map((month, monthIndex) => formatDaysCalendar(month, getFormatOptions(state), monthIndex));<EOL>        return Object.assign({}, state, { formattedMonths });<EOL>    }<EOL>    <EOL>    const displayMonths = state.displayMonths;<EOL>    <EOL>    <EOL>","gt":"let viewDate = state.view.date;"}
{"input":"<s> function formatReducer(state: BsDatepickerState, action: Action): BsDatepickerState {<EOL>    if (state.view.mode === '<STR_LIT>') {<EOL>        const formattedMonths = state.monthsModel.map((month, monthIndex) => formatDaysCalendar(month, getFormatOptions(state), monthIndex));<EOL>        return Object.assign({}, state, { formattedMonths });<EOL>    }<EOL>    <EOL>    const displayMonths = state.displayMonths;<EOL>    <EOL>    <EOL>    let viewDate = state.view.date;<EOL>    if (state.view.mode === '<STR_LIT>') {<EOL>        const monthsCalendar = new Array(displayMonths);<EOL>        for (","gt":"let calendarIndex = <NUM_LIT>; calendarIndex < displayMonths; calendarIndex++) {"}
{"input":"<s> function formatReducer(state: BsDatepickerState, action: Action): BsDatepickerState {<EOL>    if (state.view.mode === '<STR_LIT>') {<EOL>        const formattedMonths = state.monthsModel.map((month, monthIndex) => formatDaysCalendar(month, getFormatOptions(state), monthIndex));<EOL>        return Object.assign({}, state, { formattedMonths });<EOL>    }<EOL>    <EOL>    const displayMonths = state.displayMonths;<EOL>    <EOL>    <EOL>    let viewDate = state.view.date;<EOL>    if (state.view.mode === '<STR_LIT>') {<EOL>        const monthsCalendar = new Array(displayMonths);<EOL>        for (let calendarIndex = <NUM_LIT>; calendarIndex < displayMonths; calendarIndex++) {<EOL>            <EOL>            monthsCalendar[calendarIndex] = formatMonthsCalendar(viewDate, getFormatOptions(state));<EOL>            viewDate =","gt":"shiftDate(viewDate, { year: <NUM_LIT> });"}
{"input":"<s> function getSetWeekYearHelper(date: Date, input: number, week: number, weekday: number, dow: number, doy: number): number | Date {<EOL>    if (!input) {<EOL>","gt":"return getWeekYear(date);"}
{"input":"<s> export function addTimeToArrayFromToken(token: string, input: string, config: DateParsingConfig): DateParsingConfig {<EOL>    if (input != null && hasOwnProp(tokens, token)) {<EOL>        tokens[token](input, config._a, config,","gt":"token);"}
{"input":"<s> export function size(value: any[]): number {<EOL>    return","gt":"isEmpty(value) ? <NUM_LIT> : value.length;"}
{"input":"<s> export function formatDaysCalendar(daysCalendar: DaysCalendarModel, formatOptions: DatepickerFormatOptions, monthIndex: number): DaysCalendarViewModel {<EOL>    return {<EOL>        month: daysCalendar.month,<EOL>        monthTitle: formatDate(daysCalendar.month, formatOptions.monthTitle, formatOptions.locale),<EOL>        yearTitle: formatDate(daysCalendar.month, formatOptions.yearTitle, formatOptions.locale),<EOL>        weekNumbers: getWeekNumbers(","gt":"daysCalendar.daysMatrix, formatOptions.weekNumbers, formatOptions.locale),"}
{"input":"<s> export function formatDaysCalendar(daysCalendar: DaysCalendarModel, formatOptions: DatepickerFormatOptions, monthIndex: number): DaysCalendarViewModel {<EOL>    return {<EOL>        month: daysCalendar.month,<EOL>        monthTitle: formatDate(daysCalendar.month, formatOptions.monthTitle, formatOptions.locale),<EOL>        yearTitle: formatDate(daysCalendar.month, formatOptions.yearTitle, formatOptions.locale),<EOL>        weekNumbers: getWeekNumbers(daysCalendar.daysMatrix, formatOptions.weekNumbers, formatOptions.locale),<EOL>        weekdays: getShiftedWeekdays(formatOptions.locale),<EOL>        weeks: daysCalendar.daysMatrix.map((week: Date[], weekIndex: number) => ({<EOL>            days: week.map((date: Date, dayIndex: number) => ({<EOL>","gt":"date,"}
{"input":"<s> function getPrevNavButton(fixture: TestFixture): HTMLElement {<EOL>","gt":"return fixture.nativeElement.querySelector(prevNavSelector) as HTMLElement;"}
{"input":"<s> <EOL><EOL><EOL><EOL><EOL>function plural(word: string, num: number): string {<EOL>","gt":"let forms = word.split('<STR_LIT>');"}
{"input":"<s> export function markInvalid(config: DateParsingConfig): DateParsingConfig {<EOL>    config._isValid =","gt":"false;"}
{"input":"<s> function translate(num: number, withoutSuffix: boolean, key: string, isFuture: boolean): string {<EOL>    const result = num + '<STR_LIT>';<EOL>    switch (key) {<EOL>","gt":"case '<STR_LIT>':"}
{"input":"<s> function translate(num: number, withoutSuffix: boolean, key: string, isFuture: boolean): string {<EOL>    const result = num + '<STR_LIT>';<EOL>    switch (key) {<EOL>        case '<STR_LIT>': <EOL>            return (withoutSuffix || isFuture) ? '<STR_LIT>' : '<STR_LIT>';<EOL>        case '<STR_LIT>': <EOL>","gt":"if (withoutSuffix || isFuture) {"}
{"input":"<s> function translate(num: number, withoutSuffix: boolean, key: string, isFuture: boolean): string {<EOL>    const result = num + '<STR_LIT>';<EOL>    switch (key) {<EOL>        case '<STR_LIT>': <EOL>            return (withoutSuffix || isFuture) ? '<STR_LIT>' : '<STR_LIT>';<EOL>        case '<STR_LIT>': <EOL>            if (withoutSuffix || isFuture) {<EOL>                return result + (plural(num) ? '<STR_LIT>' : '<STR_LIT>');<EOL>            }<EOL>            else {<EOL>                return result + '<STR_LIT>';<EOL>            }<EOL>        <EOL>        case","gt":"'<STR_LIT>':"}
{"input":"<s> function translate(num: number, withoutSuffix: boolean, key: string, isFuture: boolean): string {<EOL>    const result = num + '<STR_LIT>';<EOL>    switch (key) {<EOL>        case '<STR_LIT>': <EOL>            return (withoutSuffix || isFuture) ? '<STR_LIT>' : '<STR_LIT>';<EOL>        case '<STR_LIT>': <EOL>            if (withoutSuffix || isFuture) {<EOL>                return result + (plural(num) ? '<STR_LIT>' : '<STR_LIT>');<EOL>            }<EOL>            else {<EOL>                return result + '<STR_LIT>';<EOL>            }<EOL>        <EOL>        case '<STR_LIT>': <EOL>            return withoutSuffix ? '<STR_LIT>' : (isFuture ? '<STR_LIT>' : '<STR_LIT>');<EOL>        case '<STR_LIT>': <EOL>            if (withoutSuffix || isFuture) {<EOL>                return result + (plural(num) ? '<STR_LIT>' : '<STR_LIT>');<EOL>            }<EOL>            else {<EOL>","gt":"return result + '<STR_LIT>';"}
{"input":"<s> function translate(num: number, withoutSuffix: boolean, key: string, isFuture: boolean): string {<EOL>    const result = num + '<STR_LIT>';<EOL>    switch (key) {<EOL>        case '<STR_LIT>': <EOL>            return (withoutSuffix || isFuture) ? '<STR_LIT>' : '<STR_LIT>';<EOL>        case '<STR_LIT>': <EOL>            if (withoutSuffix || isFuture) {<EOL>                return result + (plural(num) ? '<STR_LIT>' : '<STR_LIT>');<EOL>            }<EOL>            else {<EOL>                return result + '<STR_LIT>';<EOL>            }<EOL>        <EOL>        case '<STR_LIT>': <EOL>            return withoutSuffix ? '<STR_LIT>' : (isFuture ? '<STR_LIT>' : '<STR_LIT>');<EOL>        case '<STR_LIT>': <EOL>            if (withoutSuffix || isFuture) {<EOL>                return result + (plural(num) ? '<STR_LIT>' : '<STR_LIT>');<EOL>            }<EOL>            else {<EOL>                return result + '<STR_LIT>';<EOL>            }<EOL>        <EOL>        case '<STR_LIT>': <EOL>            return withoutSuffix ? '<STR_LIT>' : (isFuture ? '<STR_LIT>' : '<STR_LIT>');<EOL>        case '<STR_LIT>': <EOL>            if (withoutSuffix ||","gt":"isFuture) {"}
{"input":"<s> function translate(num: number, withoutSuffix: boolean, key: string, isFuture: boolean): string {<EOL>    const result = num + '<STR_LIT>';<EOL>    switch (key) {<EOL>        case '<STR_LIT>': <EOL>            return (withoutSuffix || isFuture) ? '<STR_LIT>' : '<STR_LIT>';<EOL>        case '<STR_LIT>': <EOL>            if (withoutSuffix || isFuture) {<EOL>                return result + (plural(num) ? '<STR_LIT>' : '<STR_LIT>');<EOL>            }<EOL>            else {<EOL>                return result + '<STR_LIT>';<EOL>            }<EOL>        <EOL>        case '<STR_LIT>': <EOL>            return withoutSuffix ? '<STR_LIT>' : (isFuture ? '<STR_LIT>' : '<STR_LIT>');<EOL>        case '<STR_LIT>': <EOL>            if (withoutSuffix || isFuture) {<EOL>                return result + (plural(num) ? '<STR_LIT>' : '<STR_LIT>');<EOL>            }<EOL>            else {<EOL>                return result + '<STR_LIT>';<EOL>            }<EOL>        <EOL>        case '<STR_LIT>': <EOL>            return withoutSuffix ? '<STR_LIT>' : (isFuture ? '<STR_LIT>' : '<STR_LIT>');<EOL>        case '<STR_LIT>': <EOL>            if (withoutSuffix || isFuture) {<EOL>                return result + (plural(num) ? '<STR_LIT>' : '<STR_LIT>');<EOL>            }<EOL>            else {<EOL>                return result + '<STR_LIT>';<EOL>            }<EOL>        <EOL>        case '<STR_LIT>': <EOL>","gt":"return (withoutSuffix || isFuture) ? '<STR_LIT>' : '<STR_LIT>';"}
{"input":"<s> function translate(num: number, withoutSuffix: boolean, key: string, isFuture: boolean): string {<EOL>    const result = num + '<STR_LIT>';<EOL>    switch (key) {<EOL>        case '<STR_LIT>': <EOL>            return (withoutSuffix || isFuture) ? '<STR_LIT>' : '<STR_LIT>';<EOL>        case '<STR_LIT>': <EOL>            if (withoutSuffix || isFuture) {<EOL>                return result + (plural(num) ? '<STR_LIT>' : '<STR_LIT>');<EOL>            }<EOL>            else {<EOL>                return result + '<STR_LIT>';<EOL>            }<EOL>        <EOL>        case '<STR_LIT>': <EOL>            return withoutSuffix ? '<STR_LIT>' : (isFuture ? '<STR_LIT>' : '<STR_LIT>');<EOL>        case '<STR_LIT>': <EOL>            if (withoutSuffix || isFuture) {<EOL>                return result + (plural(num) ? '<STR_LIT>' : '<STR_LIT>');<EOL>            }<EOL>            else {<EOL>                return result + '<STR_LIT>';<EOL>            }<EOL>        <EOL>        case '<STR_LIT>': <EOL>            return withoutSuffix ? '<STR_LIT>' : (isFuture ? '<STR_LIT>' : '<STR_LIT>');<EOL>        case '<STR_LIT>': <EOL>            if (withoutSuffix || isFuture) {<EOL>                return result + (plural(num) ? '<STR_LIT>' : '<STR_LIT>');<EOL>            }<EOL>            else {<EOL>                return result + '<STR_LIT>';<EOL>            }<EOL>        <EOL>        case '<STR_LIT>': <EOL>            return (withoutSuffix || isFuture) ? '<STR_LIT>' : '<STR_LIT>';<EOL>        case '<STR_LIT>': <EOL>            if (withoutSuffix || isFuture) {<EOL>                return result + (plural(num) ? '<STR_LIT>' : '<STR_LIT>');<EOL>            }<EOL>            else {<EOL>                return result + '<STR_LIT>';<EOL>            }<EOL>        <EOL>        case '<STR_LIT>': <EOL>            return (withoutSuffix || isFuture) ? '<STR_LIT>' : '<STR_LIT>';<EOL>        case '<STR_LIT>': <EOL>            if (withoutSuffix || isFuture) {<EOL>                return result + (plural(num) ? '<STR_LIT>' :","gt":"'<STR_LIT>');"}
{"input":"<s> function translate(num: number, withoutSuffix: boolean, key: string, isFuture: boolean): string {<EOL>    const result = num + '<STR_LIT>';<EOL>    switch (key) {<EOL>        case '<STR_LIT>': <EOL>            return (withoutSuffix || isFuture) ? '<STR_LIT>' : '<STR_LIT>';<EOL>        case '<STR_LIT>': <EOL>            if (withoutSuffix || isFuture) {<EOL>                return result + (plural(num) ? '<STR_LIT>' : '<STR_LIT>');<EOL>            }<EOL>            else {<EOL>                return result + '<STR_LIT>';<EOL>            }<EOL>        <EOL>        case '<STR_LIT>': <EOL>            return withoutSuffix ? '<STR_LIT>' : (isFuture ? '<STR_LIT>' : '<STR_LIT>');<EOL>        case '<STR_LIT>': <EOL>            if (withoutSuffix || isFuture) {<EOL>                return result + (plural(num) ? '<STR_LIT>' : '<STR_LIT>');<EOL>            }<EOL>            else {<EOL>                return result + '<STR_LIT>';<EOL>            }<EOL>        <EOL>        case '<STR_LIT>': <EOL>            return withoutSuffix ? '<STR_LIT>' : (isFuture ? '<STR_LIT>' : '<STR_LIT>');<EOL>        case '<STR_LIT>': <EOL>            if (withoutSuffix || isFuture) {<EOL>                return result + (plural(num) ? '<STR_LIT>' : '<STR_LIT>');<EOL>            }<EOL>            else {<EOL>                return result + '<STR_LIT>';<EOL>            }<EOL>        <EOL>        case '<STR_LIT>': <EOL>            return (withoutSuffix || isFuture) ? '<STR_LIT>' : '<STR_LIT>';<EOL>        case '<STR_LIT>': <EOL>            if (withoutSuffix || isFuture) {<EOL>                return result + (plural(num) ? '<STR_LIT>' : '<STR_LIT>');<EOL>            }<EOL>            else {<EOL>                return result + '<STR_LIT>';<EOL>            }<EOL>        <EOL>        case '<STR_LIT>': <EOL>            return (withoutSuffix || isFuture) ? '<STR_LIT>' : '<STR_LIT>';<EOL>        case '<STR_LIT>': <EOL>            if (withoutSuffix || isFuture) {<EOL>                return result + (plural(num) ? '<STR_LIT>' : '<STR_LIT>');<EOL>            }<EOL>            else {<EOL>                return result + '<STR_LIT>';<EOL>            }<EOL>        <EOL>        case","gt":"'<STR_LIT>':"}
{"input":"<s> function translate(num: number, withoutSuffix: boolean, key: string, isFuture: boolean): string {<EOL>    const result = num + '<STR_LIT>';<EOL>    switch (key) {<EOL>        case '<STR_LIT>': <EOL>            return (withoutSuffix || isFuture) ? '<STR_LIT>' : '<STR_LIT>';<EOL>        case '<STR_LIT>': <EOL>            if (withoutSuffix || isFuture) {<EOL>                return result + (plural(num) ? '<STR_LIT>' : '<STR_LIT>');<EOL>            }<EOL>            else {<EOL>                return result + '<STR_LIT>';<EOL>            }<EOL>        <EOL>        case '<STR_LIT>': <EOL>            return withoutSuffix ? '<STR_LIT>' : (isFuture ? '<STR_LIT>' : '<STR_LIT>');<EOL>        case '<STR_LIT>': <EOL>            if (withoutSuffix || isFuture) {<EOL>                return result + (plural(num) ? '<STR_LIT>' : '<STR_LIT>');<EOL>            }<EOL>            else {<EOL>                return result + '<STR_LIT>';<EOL>            }<EOL>        <EOL>        case '<STR_LIT>': <EOL>            return withoutSuffix ? '<STR_LIT>' : (isFuture ? '<STR_LIT>' : '<STR_LIT>');<EOL>        case '<STR_LIT>': <EOL>            if (withoutSuffix || isFuture) {<EOL>                return result + (plural(num) ? '<STR_LIT>' : '<STR_LIT>');<EOL>            }<EOL>            else {<EOL>                return result + '<STR_LIT>';<EOL>            }<EOL>        <EOL>        case '<STR_LIT>': <EOL>            return (withoutSuffix || isFuture) ? '<STR_LIT>' : '<STR_LIT>';<EOL>        case '<STR_LIT>': <EOL>            if (withoutSuffix || isFuture) {<EOL>                return result + (plural(num) ? '<STR_LIT>' : '<STR_LIT>');<EOL>            }<EOL>            else {<EOL>                return result + '<STR_LIT>';<EOL>            }<EOL>        <EOL>        case '<STR_LIT>': <EOL>            return (withoutSuffix || isFuture) ? '<STR_LIT>' : '<STR_LIT>';<EOL>        case '<STR_LIT>': <EOL>            if (withoutSuffix || isFuture) {<EOL>                return result + (plural(num) ? '<STR_LIT>' : '<STR_LIT>');<EOL>            }<EOL>            else {<EOL>                return result + '<STR_LIT>';<EOL>            }<EOL>        <EOL>        case '<STR_LIT>': <EOL>            return (withoutSuffix || isFuture) ? '<STR_LIT>' : '<STR_LIT>';<EOL>        case '<STR_LIT>': <EOL>            if (withoutSuffix ||","gt":"isFuture) {"}
{"input":"<s> export function createLocalOrUTC(input: DateInput, format?: string | string[], localeKey?: string, strict?: boolean, isUTC?: boolean): DateParsingConfig {<EOL>    const config: DateParsingConfig = {};<EOL>    let _input = input;<EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    if ((isObject(_input) && isObjectEmpty(_input)) || (isArray(_input) && _input.length === <NUM_LIT>)) {<EOL>        _input = undefined;<EOL>    }<EOL>    <EOL>    <EOL>    <EOL>    config._useUTC = config._isUTC = isUTC;<EOL>    config.","gt":"_l = localeKey;"}
{"input":"<s> <EOL>function getYear(date: Date, opts: DateFormatterOptions): string {<EOL>","gt":"return getFullYear(date, opts.isUTC).toString();"}
