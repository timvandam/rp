{"input":"<s> <EOL>export function GoDown(num) {<EOL>    let m = new DownMotion();<EOL>    let a =","gt":"new GoDownAction();"}
{"input":"<s> <EOL>export function GotoWordFoword(num) {<EOL>    let a = new GoAction();<EOL>    let m =","gt":"new MoveWordMotion();"}
{"input":"<s> <EOL>export function GotoRight(num) {<EOL>    let m = new RightMotion();<EOL>    m.Count = num > <NUM_LIT> ? num :","gt":"<NUM_LIT>;"}
{"input":"<s> <EOL>export function AddOuterGraveAccentSelection(num, action) {<EOL>    let m = new QuotationSelection();<EOL>    m.","gt":"Quote = \"<STR_LIT>\";"}
{"input":"<s> function tranceVimStyleRange(org) {<EOL>    let r = new Range();<EOL>    r.","gt":"start = tranceVimStylePosition(org.start);"}
{"input":"<s> function getOrCreateProps(target) {<EOL>    if (!target.hasOwnProperty('<STR_LIT>')) {<EOL>        target.","gt":"__agBeanMetaData = {};"}
{"input":"<s> function writeCanvasTo(context, color) {<EOL>    return function (log) {<EOL>        const { prev, curt } = log;<EOL>        const prevX = prev.clientX;<EOL>        const prevY = prev.clientY;<EOL>        const","gt":"curtX = curt.clientX;"}
{"input":"<s> function writeCanvasTo(context, color) {<EOL>    return function (log) {<EOL>        const { prev, curt } = log;<EOL>        const prevX = prev.clientX;<EOL>        const prevY = prev.clientY;<EOL>        const  curtX = curt.clientX;<EOL>        const curtY = curt.clientY;<EOL>        context.strokeStyle = color;<EOL>        context.beginPath();<EOL>        context.moveTo(prevX, prevY);<EOL>        context.lineTo(curtX, curtY);<EOL>        context.","gt":"lineWidth = <NUM_LIT>;"}
{"input":"<s> export function mouseleave(el = document.body) {<EOL>    return Observable.","gt":"fromEvent(el, '<STR_LIT>');"}
{"input":"<s> function horizontalRatioOf(width) {<EOL>    return","gt":"function () {"}
{"input":"<s> function linkOpenAsTargetBlank(tokens, idx, options, env, self) {<EOL>    const linkOpenToken = tokens[idx];<EOL>    const targetAttrIndex = linkOpenToken.attrIndex('<STR_LIT>');<EOL>","gt":"if (targetAttrIndex < <NUM_LIT>) {"}
{"input":"<s> export function defaults(orig, defaults) {<EOL>    const ret = clone(orig);<EOL>    Object.keys(","gt":"defaults).forEach((k) => {"}
{"input":"<s> export function defaults(orig, defaults) {<EOL>    const ret = clone(orig);<EOL>    Object.keys( defaults).forEach((k) => {<EOL>        if (k in ret) {<EOL>            return;<EOL>        }<EOL>        ret[k] = defaults[","gt":"k];"}
{"input":"<s> export function buildDateString(datetime) {<EOL>    const { year, month, day, weekday } = datetime;<EOL>    let dateString = `<STR_LIT>`;<EOL>    if (","gt":"Utils.getLeftZero()) {"}
{"input":"<s> function padDate(str) {<EOL>    let regex = /-(\\d)(-|$)/;<EOL>","gt":"while (regex.exec(str) !== null) {"}
{"input":"<s> <EOL>export function findEndOfContent(document, pos, levelSym = \"<STR_LIT>\") {<EOL>    if (pos.line === document.lineCount - <NUM_LIT>) {<EOL>        return new vscode.Position(pos.line, getLine(document, pos).length);<EOL>        '<STR_LIT>';<EOL>    }<EOL>    let","gt":"sectionRegex = getSectionRegex(levelSym);"}
{"input":"<s> <EOL>export function findEndOfContent(document, pos, levelSym = \"<STR_LIT>\") {<EOL>    if (pos.line === document.lineCount - <NUM_LIT>) {<EOL>        return new vscode.Position(pos.line, getLine(document, pos).length);<EOL>        '<STR_LIT>';<EOL>    }<EOL>    let  sectionRegex = getSectionRegex(levelSym);<EOL>    if (levelSym.startsWith(\"<STR_LIT>\")) { <EOL>        let numStars = getStarPrefixCount(levelSym) + <NUM_LIT>;<EOL>        sectionRegex =","gt":"new RegExp(`<STR_LIT>`);"}
{"input":"<s> <EOL>export function findEndOfContent(document, pos, levelSym = \"<STR_LIT>\") {<EOL>    if (pos.line === document.lineCount - <NUM_LIT>) {<EOL>        return new vscode.Position(pos.line, getLine(document, pos).length);<EOL>        '<STR_LIT>';<EOL>    }<EOL>    let  sectionRegex = getSectionRegex(levelSym);<EOL>    if (levelSym.startsWith(\"<STR_LIT>\")) { <EOL>        let numStars = getStarPrefixCount(levelSym) + <NUM_LIT>;<EOL>        sectionRegex =  new RegExp(`<STR_LIT>`);<EOL>    }<EOL>    let curLine = pos.line;<EOL>    let curPos;<EOL>    let curLinePrefix;<EOL>","gt":"do {"}
{"input":"<s> <EOL>export function findEndOfContent(document, pos, levelSym = \"<STR_LIT>\") {<EOL>    if (pos.line === document.lineCount - <NUM_LIT>) {<EOL>        return new vscode.Position(pos.line, getLine(document, pos).length);<EOL>        '<STR_LIT>';<EOL>    }<EOL>    let  sectionRegex = getSectionRegex(levelSym);<EOL>    if (levelSym.startsWith(\"<STR_LIT>\")) { <EOL>        let numStars = getStarPrefixCount(levelSym) + <NUM_LIT>;<EOL>        sectionRegex =  new RegExp(`<STR_LIT>`);<EOL>    }<EOL>    let curLine = pos.line;<EOL>    let curPos;<EOL>    let curLinePrefix;<EOL>     do {<EOL>        curLine++;<EOL>        curPos = new vscode.Position(curLine, <NUM_LIT>);<EOL>        curLinePrefix = getPrefix(getLine(document, curPos));<EOL>    } while (curLine < document.lineCount - <NUM_LIT> && inSubsection(curLinePrefix, sectionRegex));<EOL>    if (curLine !== document.lineCount - <NUM_LIT>) {<EOL>        curPos =","gt":"new vscode.Position(curPos.line - <NUM_LIT>, getLine(document, new vscode.Position(curPos.line - <NUM_LIT>, <NUM_LIT>)).length + <NUM_LIT>);"}
{"input":"<s> export function hexDiff(hex1, hex2) {<EOL>    let","gt":"rgb1 = hexToRgb(hex1);"}
{"input":"<s> <EOL>export function isNumber(obj) {<EOL>    return","gt":"typeof obj === \"<STR_LIT>\";"}
{"input":"<s> <EOL>export function b64DecodeUnicode(str) {<EOL>    return decodeURIComponent(Array.prototype.","gt":"map.call(b64decode(str), (c) => {"}
{"input":"<s> <EOL>function makeLonghand(item, data) {<EOL>    switch (item.instruction) {<EOL>        case '<STR_LIT>':<EOL>            item.instruction = '<STR_LIT>';<EOL>","gt":"break;"}
{"input":"<s> function cross(o, a, b) {<EOL>    return (a[<NUM_LIT>] -","gt":"o[<NUM_LIT>]) * (b[<NUM_LIT>] - o[<NUM_LIT>]) - (a[<NUM_LIT>] - o[<NUM_LIT>]) * (b[<NUM_LIT>] - o[<NUM_LIT>]);"}
{"input":"<s> function A(aA1, aA2) {<EOL>    return <NUM_LIT> - <NUM_LIT> *","gt":"aA2 + <NUM_LIT> * aA1;"}
{"input":"<s> <EOL>export function commandsToString(commands) {<EOL>    const tokens = [];<EOL>    commands.forEach((cmd) => {<EOL>        tokens.push(","gt":"cmd.type);"}
{"input":"<s> function newBezierCurve(start, cp1, cp2, end) {<EOL>    return new Command('<STR_LIT>', [start, cp1, cp2,","gt":"end]);"}
{"input":"<s> <EOL>export function floorMod(num, maxNum) {<EOL>","gt":"return (num % maxNum + maxNum) % maxNum;"}
{"input":"<s> <EOL>export function toSvgString(vectorLayer, width, height, x, y, withIdsAndNS = true, frameNumber = '<STR_LIT>') {<EOL>    const xmlDoc = document.implementation.createDocument(undefined, '<STR_LIT>', undefined);<EOL>    const rootNode = xmlDoc.documentElement;<EOL>    vectorLayerToSvgNode(vectorLayer, rootNode, xmlDoc, withIdsAndNS, frameNumber);<EOL>    if (width !== undefined) {<EOL>        rootNode.setAttributeNS(undefined, '<STR_LIT>', width.","gt":"toString() + '<STR_LIT>');"}
{"input":"<s> <EOL>export function toSvgString(vectorLayer, width, height, x, y, withIdsAndNS = true, frameNumber = '<STR_LIT>') {<EOL>    const xmlDoc = document.implementation.createDocument(undefined, '<STR_LIT>', undefined);<EOL>    const rootNode = xmlDoc.documentElement;<EOL>    vectorLayerToSvgNode(vectorLayer, rootNode, xmlDoc, withIdsAndNS, frameNumber);<EOL>    if (width !== undefined) {<EOL>        rootNode.setAttributeNS(undefined, '<STR_LIT>', width. toString() + '<STR_LIT>');<EOL>    }<EOL>    if (height !== undefined) {<EOL>        rootNode.setAttributeNS(undefined, '<STR_LIT>', height.toString() + '<STR_LIT>');<EOL>    }<EOL>    if (x !== undefined) {<EOL>        rootNode.setAttributeNS(undefined, '<STR_LIT>', x.toString() + '<STR_LIT>');<EOL>    }<EOL>","gt":"if (y !== undefined) {"}
{"input":"<s> function isSvgNode(node) {<EOL>","gt":"return node.nodeName === '<STR_LIT>';"}
{"input":"<s> function JS2SVG(config) {<EOL>    if (config) {<EOL>        this.config = Object.assign({}, defaults, config);<EOL>    }<EOL>    else {<EOL>","gt":"this.config = defaults;"}
{"input":"<s> function JS2SVG(config) {<EOL>    if (config) {<EOL>        this.config = Object.assign({}, defaults, config);<EOL>    }<EOL>    else {<EOL>         this.config = defaults;<EOL>    }<EOL>    var indent = this.config.indent;<EOL>    if (typeof indent == '<STR_LIT>' && !isNaN(indent)) {<EOL>","gt":"this.config.indent = '<STR_LIT>';"}
{"input":"<s> function JS2SVG(config) {<EOL>    if (config) {<EOL>        this.config = Object.assign({}, defaults, config);<EOL>    }<EOL>    else {<EOL>         this.config = defaults;<EOL>    }<EOL>    var indent = this.config.indent;<EOL>    if (typeof indent == '<STR_LIT>' && !isNaN(indent)) {<EOL>         this.config.indent = '<STR_LIT>';<EOL>        for (var i = indent; i-- > <NUM_LIT>;)<EOL>            this.config.indent += '<STR_LIT>';<EOL>    }<EOL>    else if (typeof indent != '<STR_LIT>') {<EOL>        this.config.indent = '<STR_LIT>';<EOL>    }<EOL>    if (this.config.pretty) {<EOL>        this.config.doctypeEnd += EOL;<EOL>        this.config.procInstEnd += EOL;<EOL>        this.config.commentEnd += EOL;<EOL>        this.config.cdataEnd += EOL;<EOL>        this.config.","gt":"tagShortEnd += EOL;"}
{"input":"<s> <EOL>function getMatrixData(a, b) {<EOL>    return b.name ==","gt":"'<STR_LIT>' ? a.concat(b.data.slice(<NUM_LIT>, <NUM_LIT>)) : a;"}
{"input":"<s> <EOL>function mergePathsFn(item, params) {<EOL>    if (!item.isElem() || item.isEmpty())<EOL>        return;<EOL>    var prevContentItem = null, prevContentItemKeys = null;<EOL>    item.content = item.content.filter(function (contentItem) {<EOL>        if (prevContentItem &&<EOL>            prevContentItem.isElem(","gt":"'<STR_LIT>') &&"}
{"input":"<s> <EOL>function mergePathsFn(item, params) {<EOL>    if (!item.isElem() || item.isEmpty())<EOL>        return;<EOL>    var prevContentItem = null, prevContentItemKeys = null;<EOL>    item.content = item.content.filter(function (contentItem) {<EOL>        if (prevContentItem &&<EOL>            prevContentItem.isElem( '<STR_LIT>') &&<EOL>            prevContentItem.isEmpty() &&<EOL>            prevContentItem.hasAttr('<STR_LIT>') &&<EOL>            contentItem.","gt":"isElem('<STR_LIT>') &&"}
{"input":"<s> <EOL>function mergePathsFn(item, params) {<EOL>    if (!item.isElem() || item.isEmpty())<EOL>        return;<EOL>    var prevContentItem = null, prevContentItemKeys = null;<EOL>    item.content = item.content.filter(function (contentItem) {<EOL>        if (prevContentItem &&<EOL>            prevContentItem.isElem( '<STR_LIT>') &&<EOL>            prevContentItem.isEmpty() &&<EOL>            prevContentItem.hasAttr('<STR_LIT>') &&<EOL>            contentItem. isElem('<STR_LIT>') &&<EOL>            contentItem.isEmpty() &&<EOL>            contentItem.hasAttr('<STR_LIT>')) {<EOL>","gt":"if (!prevContentItemKeys) {"}
{"input":"<s> <EOL>function mergePathsFn(item, params) {<EOL>    if (!item.isElem() || item.isEmpty())<EOL>        return;<EOL>    var prevContentItem = null, prevContentItemKeys = null;<EOL>    item.content = item.content.filter(function (contentItem) {<EOL>        if (prevContentItem &&<EOL>            prevContentItem.isElem( '<STR_LIT>') &&<EOL>            prevContentItem.isEmpty() &&<EOL>            prevContentItem.hasAttr('<STR_LIT>') &&<EOL>            contentItem. isElem('<STR_LIT>') &&<EOL>            contentItem.isEmpty() &&<EOL>            contentItem.hasAttr('<STR_LIT>')) {<EOL>             if (!prevContentItemKeys) {<EOL>                prevContentItemKeys = Object.keys(prevContentItem.attrs);<EOL>            }<EOL>            var contentItemAttrs = Object.keys(contentItem.attrs), equalData = prevContentItemKeys.length == contentItemAttrs.length &&<EOL>                contentItemAttrs.every(","gt":"function (key) {"}
{"input":"<s> <EOL>function mergePathsFn(item, params) {<EOL>    if (!item.isElem() || item.isEmpty())<EOL>        return;<EOL>    var prevContentItem = null, prevContentItemKeys = null;<EOL>    item.content = item.content.filter(function (contentItem) {<EOL>        if (prevContentItem &&<EOL>            prevContentItem.isElem( '<STR_LIT>') &&<EOL>            prevContentItem.isEmpty() &&<EOL>            prevContentItem.hasAttr('<STR_LIT>') &&<EOL>            contentItem. isElem('<STR_LIT>') &&<EOL>            contentItem.isEmpty() &&<EOL>            contentItem.hasAttr('<STR_LIT>')) {<EOL>             if (!prevContentItemKeys) {<EOL>                prevContentItemKeys = Object.keys(prevContentItem.attrs);<EOL>            }<EOL>            var contentItemAttrs = Object.keys(contentItem.attrs), equalData = prevContentItemKeys.length == contentItemAttrs.length &&<EOL>                contentItemAttrs.every( function (key) {<EOL>                    return key == '<STR_LIT>' ||<EOL>                        prevContentItem.hasAttr(key) &&<EOL>                            prevContentItem.attr(key).value == contentItem.attr(key).value;<EOL>                }), prevPathJS = path2js(prevContentItem), curPathJS = path2js(contentItem);<EOL>            if (equalData && !intersects(prevPathJS, curPathJS)) {<EOL>                js2path(prevContentItem,","gt":"prevPathJS.concat(curPathJS), params);"}
{"input":"<s> <EOL><EOL>function a2c(x1, y1, rx, ry, angle, large_arc_flag, sweep_flag, x2, y2, recursive) {<EOL>    <EOL>    <EOL>    var _120 = Math.PI * <NUM_LIT> / <NUM_LIT>, rad = Math.PI / <NUM_LIT> * (+angle || <NUM_LIT>), res = [], rotateX = function (x, y, rad) {<EOL>        return x * Math.cos(rad) - y * Math.sin(rad);<EOL>    }, rotateY = function (x, y,","gt":"rad) {"}
{"input":"<s> <EOL><EOL>function a2c(x1, y1, rx, ry, angle, large_arc_flag, sweep_flag, x2, y2, recursive) {<EOL>    <EOL>    <EOL>    var _120 = Math.PI * <NUM_LIT> / <NUM_LIT>, rad = Math.PI / <NUM_LIT> * (+angle || <NUM_LIT>), res = [], rotateX = function (x, y, rad) {<EOL>        return x * Math.cos(rad) - y * Math.sin(rad);<EOL>    }, rotateY = function (x, y,  rad) {<EOL>        return x * Math.sin(rad) + y * Math.cos(rad);<EOL>    };<EOL>","gt":"if (!recursive) {"}
{"input":"<s> <EOL><EOL>function a2c(x1, y1, rx, ry, angle, large_arc_flag, sweep_flag, x2, y2, recursive) {<EOL>    <EOL>    <EOL>    var _120 = Math.PI * <NUM_LIT> / <NUM_LIT>, rad = Math.PI / <NUM_LIT> * (+angle || <NUM_LIT>), res = [], rotateX = function (x, y, rad) {<EOL>        return x * Math.cos(rad) - y * Math.sin(rad);<EOL>    }, rotateY = function (x, y,  rad) {<EOL>        return x * Math.sin(rad) + y * Math.cos(rad);<EOL>    };<EOL>     if (!recursive) {<EOL>        x1 = rotateX(x1, y1, -rad);<EOL>        y1 = rotateY(x1, y1, -rad);<EOL>        x2 = rotateX(x2,","gt":"y2, -rad);"}
{"input":"<s> <EOL><EOL>function a2c(x1, y1, rx, ry, angle, large_arc_flag, sweep_flag, x2, y2, recursive) {<EOL>    <EOL>    <EOL>    var _120 = Math.PI * <NUM_LIT> / <NUM_LIT>, rad = Math.PI / <NUM_LIT> * (+angle || <NUM_LIT>), res = [], rotateX = function (x, y, rad) {<EOL>        return x * Math.cos(rad) - y * Math.sin(rad);<EOL>    }, rotateY = function (x, y,  rad) {<EOL>        return x * Math.sin(rad) + y * Math.cos(rad);<EOL>    };<EOL>     if (!recursive) {<EOL>        x1 = rotateX(x1, y1, -rad);<EOL>        y1 = rotateY(x1, y1, -rad);<EOL>        x2 = rotateX(x2,  y2, -rad);<EOL>        y2 =","gt":"rotateY(x2, y2, -rad);"}
{"input":"<s> <EOL><EOL>function a2c(x1, y1, rx, ry, angle, large_arc_flag, sweep_flag, x2, y2, recursive) {<EOL>    <EOL>    <EOL>    var _120 = Math.PI * <NUM_LIT> / <NUM_LIT>, rad = Math.PI / <NUM_LIT> * (+angle || <NUM_LIT>), res = [], rotateX = function (x, y, rad) {<EOL>        return x * Math.cos(rad) - y * Math.sin(rad);<EOL>    }, rotateY = function (x, y,  rad) {<EOL>        return x * Math.sin(rad) + y * Math.cos(rad);<EOL>    };<EOL>     if (!recursive) {<EOL>        x1 = rotateX(x1, y1, -rad);<EOL>        y1 = rotateY(x1, y1, -rad);<EOL>        x2 = rotateX(x2,  y2, -rad);<EOL>        y2 =  rotateY(x2, y2, -rad);<EOL>        var x = (x1 - x2) / <NUM_LIT>, y = (y1 - y2) / <NUM_LIT>;<EOL>        var h = x * x / (rx * rx) + y * y / (ry * ry);<EOL>        if (h > <NUM_LIT>) {<EOL>            h = Math.sqrt(h);<EOL>            rx = h * rx;<EOL>","gt":"ry = h * ry;"}
{"input":"<s> <EOL><EOL>function a2c(x1, y1, rx, ry, angle, large_arc_flag, sweep_flag, x2, y2, recursive) {<EOL>    <EOL>    <EOL>    var _120 = Math.PI * <NUM_LIT> / <NUM_LIT>, rad = Math.PI / <NUM_LIT> * (+angle || <NUM_LIT>), res = [], rotateX = function (x, y, rad) {<EOL>        return x * Math.cos(rad) - y * Math.sin(rad);<EOL>    }, rotateY = function (x, y,  rad) {<EOL>        return x * Math.sin(rad) + y * Math.cos(rad);<EOL>    };<EOL>     if (!recursive) {<EOL>        x1 = rotateX(x1, y1, -rad);<EOL>        y1 = rotateY(x1, y1, -rad);<EOL>        x2 = rotateX(x2,  y2, -rad);<EOL>        y2 =  rotateY(x2, y2, -rad);<EOL>        var x = (x1 - x2) / <NUM_LIT>, y = (y1 - y2) / <NUM_LIT>;<EOL>        var h = x * x / (rx * rx) + y * y / (ry * ry);<EOL>        if (h > <NUM_LIT>) {<EOL>            h = Math.sqrt(h);<EOL>            rx = h * rx;<EOL>             ry = h * ry;<EOL>        }<EOL>        var rx2 = rx * rx, ry2 = ry * ry, k = (large_arc_flag == sweep_flag ? -<NUM_LIT> : <NUM_LIT>) *<EOL>            Math.sqrt(Math.abs((rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x))), cx = k * rx * y / ry + (x1 + x2) / <NUM_LIT>, cy = k * -ry * x / rx + (y1 + y2) / <NUM_LIT>, f1 = Math.asin(Number(((y1 - cy) / ry).toFixed(<NUM_LIT>))), f2 = Math.asin(Number(((y2 - cy) / ry).toFixed(<NUM_LIT>)));<EOL>        f1 = x1 < cx ? Math.PI - f1 : f1;<EOL>        f2 = x2 < cx ? Math.PI - f2 : f2;<EOL>        f1 < <NUM_LIT> && (f1 = Math.PI * <NUM_LIT> + f1);<EOL>        f2 < <NUM_LIT> && (f2 =","gt":"Math.PI * <NUM_LIT> + f2);"}
{"input":"<s> <EOL><EOL>function a2c(x1, y1, rx, ry, angle, large_arc_flag, sweep_flag, x2, y2, recursive) {<EOL>    <EOL>    <EOL>    var _120 = Math.PI * <NUM_LIT> / <NUM_LIT>, rad = Math.PI / <NUM_LIT> * (+angle || <NUM_LIT>), res = [], rotateX = function (x, y, rad) {<EOL>        return x * Math.cos(rad) - y * Math.sin(rad);<EOL>    }, rotateY = function (x, y,  rad) {<EOL>        return x * Math.sin(rad) + y * Math.cos(rad);<EOL>    };<EOL>     if (!recursive) {<EOL>        x1 = rotateX(x1, y1, -rad);<EOL>        y1 = rotateY(x1, y1, -rad);<EOL>        x2 = rotateX(x2,  y2, -rad);<EOL>        y2 =  rotateY(x2, y2, -rad);<EOL>        var x = (x1 - x2) / <NUM_LIT>, y = (y1 - y2) / <NUM_LIT>;<EOL>        var h = x * x / (rx * rx) + y * y / (ry * ry);<EOL>        if (h > <NUM_LIT>) {<EOL>            h = Math.sqrt(h);<EOL>            rx = h * rx;<EOL>             ry = h * ry;<EOL>        }<EOL>        var rx2 = rx * rx, ry2 = ry * ry, k = (large_arc_flag == sweep_flag ? -<NUM_LIT> : <NUM_LIT>) *<EOL>            Math.sqrt(Math.abs((rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x))), cx = k * rx * y / ry + (x1 + x2) / <NUM_LIT>, cy = k * -ry * x / rx + (y1 + y2) / <NUM_LIT>, f1 = Math.asin(Number(((y1 - cy) / ry).toFixed(<NUM_LIT>))), f2 = Math.asin(Number(((y2 - cy) / ry).toFixed(<NUM_LIT>)));<EOL>        f1 = x1 < cx ? Math.PI - f1 : f1;<EOL>        f2 = x2 < cx ? Math.PI - f2 : f2;<EOL>        f1 < <NUM_LIT> && (f1 = Math.PI * <NUM_LIT> + f1);<EOL>        f2 < <NUM_LIT> && (f2 =  Math.PI * <NUM_LIT> + f2);<EOL>        if (sweep_flag && f1 > f2) {<EOL>            f1 = f1 - Math.PI * <NUM_LIT>;<EOL>        }<EOL>        if (!sweep_flag && f2 > f1) {<EOL>            f2 = f2 - Math.PI *","gt":"<NUM_LIT>;"}
{"input":"<s> <EOL><EOL>function a2c(x1, y1, rx, ry, angle, large_arc_flag, sweep_flag, x2, y2, recursive) {<EOL>    <EOL>    <EOL>    var _120 = Math.PI * <NUM_LIT> / <NUM_LIT>, rad = Math.PI / <NUM_LIT> * (+angle || <NUM_LIT>), res = [], rotateX = function (x, y, rad) {<EOL>        return x * Math.cos(rad) - y * Math.sin(rad);<EOL>    }, rotateY = function (x, y,  rad) {<EOL>        return x * Math.sin(rad) + y * Math.cos(rad);<EOL>    };<EOL>     if (!recursive) {<EOL>        x1 = rotateX(x1, y1, -rad);<EOL>        y1 = rotateY(x1, y1, -rad);<EOL>        x2 = rotateX(x2,  y2, -rad);<EOL>        y2 =  rotateY(x2, y2, -rad);<EOL>        var x = (x1 - x2) / <NUM_LIT>, y = (y1 - y2) / <NUM_LIT>;<EOL>        var h = x * x / (rx * rx) + y * y / (ry * ry);<EOL>        if (h > <NUM_LIT>) {<EOL>            h = Math.sqrt(h);<EOL>            rx = h * rx;<EOL>             ry = h * ry;<EOL>        }<EOL>        var rx2 = rx * rx, ry2 = ry * ry, k = (large_arc_flag == sweep_flag ? -<NUM_LIT> : <NUM_LIT>) *<EOL>            Math.sqrt(Math.abs((rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x))), cx = k * rx * y / ry + (x1 + x2) / <NUM_LIT>, cy = k * -ry * x / rx + (y1 + y2) / <NUM_LIT>, f1 = Math.asin(Number(((y1 - cy) / ry).toFixed(<NUM_LIT>))), f2 = Math.asin(Number(((y2 - cy) / ry).toFixed(<NUM_LIT>)));<EOL>        f1 = x1 < cx ? Math.PI - f1 : f1;<EOL>        f2 = x2 < cx ? Math.PI - f2 : f2;<EOL>        f1 < <NUM_LIT> && (f1 = Math.PI * <NUM_LIT> + f1);<EOL>        f2 < <NUM_LIT> && (f2 =  Math.PI * <NUM_LIT> + f2);<EOL>        if (sweep_flag && f1 > f2) {<EOL>            f1 = f1 - Math.PI * <NUM_LIT>;<EOL>        }<EOL>        if (!sweep_flag && f2 > f1) {<EOL>            f2 = f2 - Math.PI *  <NUM_LIT>;<EOL>        }<EOL>    }<EOL>    else {<EOL>        f1 = recursive[<NUM_LIT>];<EOL>        f2 = recursive[<NUM_LIT>];<EOL>        cx = recursive[<NUM_LIT>];<EOL>        cy = recursive[<NUM_LIT>];<EOL>    }<EOL>    var df = f2 - f1;<EOL>    if (Math.abs(df) > _120) {<EOL>        var f2old = f2, x2old = x2, y2old = y2;<EOL>        f2 = f1 + _120 * (sweep_flag && f2 > f1 ? <NUM_LIT> : -<NUM_LIT>);<EOL>        x2 = cx + rx * Math.cos(f2);<EOL>        y2 = cy + ry * Math.sin(f2);<EOL>        res = a2c(x2, y2, rx, ry,","gt":"angle, <NUM_LIT>, sweep_flag, x2old, y2old, [f2, f2old, cx, cy]);"}
{"input":"<s> <EOL><EOL>function a2c(x1, y1, rx, ry, angle, large_arc_flag, sweep_flag, x2, y2, recursive) {<EOL>    <EOL>    <EOL>    var _120 = Math.PI * <NUM_LIT> / <NUM_LIT>, rad = Math.PI / <NUM_LIT> * (+angle || <NUM_LIT>), res = [], rotateX = function (x, y, rad) {<EOL>        return x * Math.cos(rad) - y * Math.sin(rad);<EOL>    }, rotateY = function (x, y,  rad) {<EOL>        return x * Math.sin(rad) + y * Math.cos(rad);<EOL>    };<EOL>     if (!recursive) {<EOL>        x1 = rotateX(x1, y1, -rad);<EOL>        y1 = rotateY(x1, y1, -rad);<EOL>        x2 = rotateX(x2,  y2, -rad);<EOL>        y2 =  rotateY(x2, y2, -rad);<EOL>        var x = (x1 - x2) / <NUM_LIT>, y = (y1 - y2) / <NUM_LIT>;<EOL>        var h = x * x / (rx * rx) + y * y / (ry * ry);<EOL>        if (h > <NUM_LIT>) {<EOL>            h = Math.sqrt(h);<EOL>            rx = h * rx;<EOL>             ry = h * ry;<EOL>        }<EOL>        var rx2 = rx * rx, ry2 = ry * ry, k = (large_arc_flag == sweep_flag ? -<NUM_LIT> : <NUM_LIT>) *<EOL>            Math.sqrt(Math.abs((rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x))), cx = k * rx * y / ry + (x1 + x2) / <NUM_LIT>, cy = k * -ry * x / rx + (y1 + y2) / <NUM_LIT>, f1 = Math.asin(Number(((y1 - cy) / ry).toFixed(<NUM_LIT>))), f2 = Math.asin(Number(((y2 - cy) / ry).toFixed(<NUM_LIT>)));<EOL>        f1 = x1 < cx ? Math.PI - f1 : f1;<EOL>        f2 = x2 < cx ? Math.PI - f2 : f2;<EOL>        f1 < <NUM_LIT> && (f1 = Math.PI * <NUM_LIT> + f1);<EOL>        f2 < <NUM_LIT> && (f2 =  Math.PI * <NUM_LIT> + f2);<EOL>        if (sweep_flag && f1 > f2) {<EOL>            f1 = f1 - Math.PI * <NUM_LIT>;<EOL>        }<EOL>        if (!sweep_flag && f2 > f1) {<EOL>            f2 = f2 - Math.PI *  <NUM_LIT>;<EOL>        }<EOL>    }<EOL>    else {<EOL>        f1 = recursive[<NUM_LIT>];<EOL>        f2 = recursive[<NUM_LIT>];<EOL>        cx = recursive[<NUM_LIT>];<EOL>        cy = recursive[<NUM_LIT>];<EOL>    }<EOL>    var df = f2 - f1;<EOL>    if (Math.abs(df) > _120) {<EOL>        var f2old = f2, x2old = x2, y2old = y2;<EOL>        f2 = f1 + _120 * (sweep_flag && f2 > f1 ? <NUM_LIT> : -<NUM_LIT>);<EOL>        x2 = cx + rx * Math.cos(f2);<EOL>        y2 = cy + ry * Math.sin(f2);<EOL>        res = a2c(x2, y2, rx, ry,  angle, <NUM_LIT>, sweep_flag, x2old, y2old, [f2, f2old, cx, cy]);<EOL>    }<EOL>    df = f2 - f1;<EOL>    var c1 = Math.cos(f1), s1 = Math.sin(f1), c2 = Math.cos(f2), s2 = Math.sin(f2), t = Math.tan(df / <NUM_LIT>), hx = <NUM_LIT> / <NUM_LIT> * rx * t, hy = <NUM_LIT> / <NUM_LIT> * ry * t, m = [-hx * s1, hy * c1, x2 + hx * s2 - x1, y2 - hy * c2 - y1, x2 - x1, y2 - y1];<EOL>","gt":"if (recursive) {"}
{"input":"<s> <EOL><EOL>function a2c(x1, y1, rx, ry, angle, large_arc_flag, sweep_flag, x2, y2, recursive) {<EOL>    <EOL>    <EOL>    var _120 = Math.PI * <NUM_LIT> / <NUM_LIT>, rad = Math.PI / <NUM_LIT> * (+angle || <NUM_LIT>), res = [], rotateX = function (x, y, rad) {<EOL>        return x * Math.cos(rad) - y * Math.sin(rad);<EOL>    }, rotateY = function (x, y,  rad) {<EOL>        return x * Math.sin(rad) + y * Math.cos(rad);<EOL>    };<EOL>     if (!recursive) {<EOL>        x1 = rotateX(x1, y1, -rad);<EOL>        y1 = rotateY(x1, y1, -rad);<EOL>        x2 = rotateX(x2,  y2, -rad);<EOL>        y2 =  rotateY(x2, y2, -rad);<EOL>        var x = (x1 - x2) / <NUM_LIT>, y = (y1 - y2) / <NUM_LIT>;<EOL>        var h = x * x / (rx * rx) + y * y / (ry * ry);<EOL>        if (h > <NUM_LIT>) {<EOL>            h = Math.sqrt(h);<EOL>            rx = h * rx;<EOL>             ry = h * ry;<EOL>        }<EOL>        var rx2 = rx * rx, ry2 = ry * ry, k = (large_arc_flag == sweep_flag ? -<NUM_LIT> : <NUM_LIT>) *<EOL>            Math.sqrt(Math.abs((rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x))), cx = k * rx * y / ry + (x1 + x2) / <NUM_LIT>, cy = k * -ry * x / rx + (y1 + y2) / <NUM_LIT>, f1 = Math.asin(Number(((y1 - cy) / ry).toFixed(<NUM_LIT>))), f2 = Math.asin(Number(((y2 - cy) / ry).toFixed(<NUM_LIT>)));<EOL>        f1 = x1 < cx ? Math.PI - f1 : f1;<EOL>        f2 = x2 < cx ? Math.PI - f2 : f2;<EOL>        f1 < <NUM_LIT> && (f1 = Math.PI * <NUM_LIT> + f1);<EOL>        f2 < <NUM_LIT> && (f2 =  Math.PI * <NUM_LIT> + f2);<EOL>        if (sweep_flag && f1 > f2) {<EOL>            f1 = f1 - Math.PI * <NUM_LIT>;<EOL>        }<EOL>        if (!sweep_flag && f2 > f1) {<EOL>            f2 = f2 - Math.PI *  <NUM_LIT>;<EOL>        }<EOL>    }<EOL>    else {<EOL>        f1 = recursive[<NUM_LIT>];<EOL>        f2 = recursive[<NUM_LIT>];<EOL>        cx = recursive[<NUM_LIT>];<EOL>        cy = recursive[<NUM_LIT>];<EOL>    }<EOL>    var df = f2 - f1;<EOL>    if (Math.abs(df) > _120) {<EOL>        var f2old = f2, x2old = x2, y2old = y2;<EOL>        f2 = f1 + _120 * (sweep_flag && f2 > f1 ? <NUM_LIT> : -<NUM_LIT>);<EOL>        x2 = cx + rx * Math.cos(f2);<EOL>        y2 = cy + ry * Math.sin(f2);<EOL>        res = a2c(x2, y2, rx, ry,  angle, <NUM_LIT>, sweep_flag, x2old, y2old, [f2, f2old, cx, cy]);<EOL>    }<EOL>    df = f2 - f1;<EOL>    var c1 = Math.cos(f1), s1 = Math.sin(f1), c2 = Math.cos(f2), s2 = Math.sin(f2), t = Math.tan(df / <NUM_LIT>), hx = <NUM_LIT> / <NUM_LIT> * rx * t, hy = <NUM_LIT> / <NUM_LIT> * ry * t, m = [-hx * s1, hy * c1, x2 + hx * s2 - x1, y2 - hy * c2 - y1, x2 - x1, y2 - y1];<EOL>     if (recursive) {<EOL>        return m.concat(res);<EOL>    }<EOL>","gt":"else {"}
{"input":"<s> function cross(o, a, b) {<EOL>    return (a[<NUM_LIT>] - o[<NUM_LIT>]) * (b[<NUM_LIT>] - o[","gt":"<NUM_LIT>]) - (a[<NUM_LIT>] - o[<NUM_LIT>]) * (b[<NUM_LIT>] - o[<NUM_LIT>]);"}
{"input":"<s> <EOL>function removeEditorsNSDataFn(item, params) {<EOL>    if (Array.isArray(params.additionalNamespaces)) {<EOL>        editorNamespaces = editorNamespaces.concat(params.additionalNamespaces);<EOL>    }<EOL>    if (item.elem) {<EOL>","gt":"if (item.isElem('<STR_LIT>')) {"}
{"input":"<s> <EOL>function removeEditorsNSDataFn(item, params) {<EOL>    if (Array.isArray(params.additionalNamespaces)) {<EOL>        editorNamespaces = editorNamespaces.concat(params.additionalNamespaces);<EOL>    }<EOL>    if (item.elem) {<EOL>         if (item.isElem('<STR_LIT>')) {<EOL>            item.eachAttr(function (attr) {<EOL>                if (attr.prefix === '<STR_LIT>' && editorNamespaces.indexOf(attr.value) > -<NUM_LIT>) {<EOL>                    prefixes.","gt":"push(attr.local);"}
{"input":"<s> <EOL><EOL><EOL><EOL><EOL><EOL>export function cleanupOutData(data, params) {<EOL>    var str = '<STR_LIT>', delimiter, prev;<EOL>    data.forEach(function (item, i) {<EOL>        <EOL>        delimiter = '<STR_LIT>';<EOL>        <EOL>        if (i === <NUM_LIT>) {<EOL>            delimiter = '<STR_LIT>';<EOL>        }<EOL>        <EOL>        <EOL>        <EOL>        if (params.leadingZero) {<EOL>            item = removeLeadingZero(item);<EOL>        }<EOL>        <EOL>        <EOL>        if (params.negativeExtraSpace &&<EOL>            (item < <NUM_LIT> || (String(item).charCodeAt(<NUM_LIT>) == <NUM_LIT> && prev % <NUM_LIT> !== <NUM_LIT>))) {<EOL>","gt":"delimiter = '<STR_LIT>';"}
{"input":"<s> <EOL>export function removeLeadingZero(num) {<EOL>    var strNum = num.toString();<EOL>    if (<NUM_LIT> < num && num < <NUM_LIT> && strNum.charCodeAt(<NUM_LIT>) == <NUM_LIT>) {<EOL>        strNum = strNum.slice(","gt":"<NUM_LIT>);"}
{"input":"<s> <EOL>export function transform2js(transformString) {<EOL>    <EOL>    var transforms = [], <EOL>    <EOL>    current;<EOL>    <EOL>    transformString.split(regTransformSplit).","gt":"forEach(function (item) {"}
{"input":"<s> <EOL>export function transform2js(transformString) {<EOL>    <EOL>    var transforms = [], <EOL>    <EOL>    current;<EOL>    <EOL>    transformString.split(regTransformSplit). forEach(function (item) {<EOL>        <EOL>        var num;<EOL>","gt":"if (item) {"}
{"input":"<s> export function optimize(svgText, callback) {<EOL>    svg2js(svgText, (svgJs) => {<EOL>        if (svgJs.error) {<EOL>            console.warn('<STR_LIT>', svgJs.error);<EOL>            callback(","gt":"undefined);"}
{"input":"<s> export function optimize(svgText, callback) {<EOL>    svg2js(svgText, (svgJs) => {<EOL>        if (svgJs.error) {<EOL>            console.warn('<STR_LIT>', svgJs.error);<EOL>            callback( undefined);<EOL>            return;<EOL>        }<EOL>        callback(js2svg(executePlugins(svgJs, batchedSvgoPlugins), {<EOL>            indent: '<STR_LIT>',<EOL>","gt":"pretty: true,"}
{"input":"<s> export function _storeFactory(dispatcher, reducer, state$) {<EOL>    return new Store(dispatcher,","gt":"reducer, state$);"}
{"input":"<s> export function isFunction(functionToCheck) {<EOL>    let","gt":"getType = {};"}
{"input":"<s> function gotoItemInActiveList(index) {<EOL>    let","gt":"member = activeList.members[index];"}
{"input":"<s> export function getCompletionsAtPosition(model, position) {<EOL>    const doc = Parser.","gt":"parse(model.getValue());"}
{"input":"<s> export function getClassificationsForLine(filePath, lineStart, string) {<EOL>    const offsetForBom = hasBom[filePath] ? -<NUM_LIT> : <NUM_LIT>;<EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    let lineLength = string.length;<EOL>    let","gt":"encodedClassifications = languageService.getEncodedSyntacticClassifications(filePath, { start: lineStart, length: lineLength });"}
{"input":"<s> export function getClassificationsForLine(filePath, lineStart, string) {<EOL>    const offsetForBom = hasBom[filePath] ? -<NUM_LIT> : <NUM_LIT>;<EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    let lineLength = string.length;<EOL>    let  encodedClassifications = languageService.getEncodedSyntacticClassifications(filePath, { start: lineStart, length: lineLength });<EOL>    let classifications = unencodeClassifications(encodedClassifications);<EOL>    <EOL>    let lastStartSet = false;<EOL>    let lastStart = <NUM_LIT>;<EOL>    <EOL>    classifications = classifications<EOL>        .","gt":"map((c, i) => {"}
{"input":"<s> export function getClassificationsForLine(filePath, lineStart, string) {<EOL>    const offsetForBom = hasBom[filePath] ? -<NUM_LIT> : <NUM_LIT>;<EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    let lineLength = string.length;<EOL>    let  encodedClassifications = languageService.getEncodedSyntacticClassifications(filePath, { start: lineStart, length: lineLength });<EOL>    let classifications = unencodeClassifications(encodedClassifications);<EOL>    <EOL>    let lastStartSet = false;<EOL>    let lastStart = <NUM_LIT>;<EOL>    <EOL>    classifications = classifications<EOL>        . map((c, i) => {<EOL>        <EOL>        c.textSpan.start += offsetForBom;<EOL>        <EOL>        if ((c.textSpan.start + c.textSpan.length) <= lineStart) {<EOL>            return null;<EOL>        }<EOL>        <EOL>        if (c.textSpan.start > (lineStart +","gt":"lineLength)) {"}
{"input":"<s> export function getClassificationsForLine(filePath, lineStart, string) {<EOL>    const offsetForBom = hasBom[filePath] ? -<NUM_LIT> : <NUM_LIT>;<EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    let lineLength = string.length;<EOL>    let  encodedClassifications = languageService.getEncodedSyntacticClassifications(filePath, { start: lineStart, length: lineLength });<EOL>    let classifications = unencodeClassifications(encodedClassifications);<EOL>    <EOL>    let lastStartSet = false;<EOL>    let lastStart = <NUM_LIT>;<EOL>    <EOL>    classifications = classifications<EOL>        . map((c, i) => {<EOL>        <EOL>        c.textSpan.start += offsetForBom;<EOL>        <EOL>        if ((c.textSpan.start + c.textSpan.length) <= lineStart) {<EOL>            return null;<EOL>        }<EOL>        <EOL>        if (c.textSpan.start > (lineStart +  lineLength)) {<EOL>            return null;<EOL>        }<EOL>        <EOL>        if (c.","gt":"textSpan.start < lineStart) {"}
{"input":"<s> export function getClassificationsForLine(filePath, lineStart, string) {<EOL>    const offsetForBom = hasBom[filePath] ? -<NUM_LIT> : <NUM_LIT>;<EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    let lineLength = string.length;<EOL>    let  encodedClassifications = languageService.getEncodedSyntacticClassifications(filePath, { start: lineStart, length: lineLength });<EOL>    let classifications = unencodeClassifications(encodedClassifications);<EOL>    <EOL>    let lastStartSet = false;<EOL>    let lastStart = <NUM_LIT>;<EOL>    <EOL>    classifications = classifications<EOL>        . map((c, i) => {<EOL>        <EOL>        c.textSpan.start += offsetForBom;<EOL>        <EOL>        if ((c.textSpan.start + c.textSpan.length) <= lineStart) {<EOL>            return null;<EOL>        }<EOL>        <EOL>        if (c.textSpan.start > (lineStart +  lineLength)) {<EOL>            return null;<EOL>        }<EOL>        <EOL>        if (c. textSpan.start < lineStart) {<EOL>            c.textSpan.length = c.textSpan.start + c.textSpan.length - lineStart;<EOL>            c.textSpan.","gt":"start = lineStart;"}
{"input":"<s> export function getClassificationsForLine(filePath, lineStart, string) {<EOL>    const offsetForBom = hasBom[filePath] ? -<NUM_LIT> : <NUM_LIT>;<EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    let lineLength = string.length;<EOL>    let  encodedClassifications = languageService.getEncodedSyntacticClassifications(filePath, { start: lineStart, length: lineLength });<EOL>    let classifications = unencodeClassifications(encodedClassifications);<EOL>    <EOL>    let lastStartSet = false;<EOL>    let lastStart = <NUM_LIT>;<EOL>    <EOL>    classifications = classifications<EOL>        . map((c, i) => {<EOL>        <EOL>        c.textSpan.start += offsetForBom;<EOL>        <EOL>        if ((c.textSpan.start + c.textSpan.length) <= lineStart) {<EOL>            return null;<EOL>        }<EOL>        <EOL>        if (c.textSpan.start > (lineStart +  lineLength)) {<EOL>            return null;<EOL>        }<EOL>        <EOL>        if (c. textSpan.start < lineStart) {<EOL>            c.textSpan.length = c.textSpan.start + c.textSpan.length - lineStart;<EOL>            c.textSpan. start = lineStart;<EOL>        }<EOL>        <EOL>        if ((c.textSpan.start + c.textSpan.length) > (lineStart + lineLength)) {<EOL>            c.textSpan.length = (lineStart + lineLength) - (c.textSpan.start);<EOL>        }<EOL>        <EOL>        if (!lastStartSet) {<EOL>","gt":"lastStartSet = true;"}
{"input":"<s> export function getClassificationsForLine(filePath, lineStart, string) {<EOL>    const offsetForBom = hasBom[filePath] ? -<NUM_LIT> : <NUM_LIT>;<EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    let lineLength = string.length;<EOL>    let  encodedClassifications = languageService.getEncodedSyntacticClassifications(filePath, { start: lineStart, length: lineLength });<EOL>    let classifications = unencodeClassifications(encodedClassifications);<EOL>    <EOL>    let lastStartSet = false;<EOL>    let lastStart = <NUM_LIT>;<EOL>    <EOL>    classifications = classifications<EOL>        . map((c, i) => {<EOL>        <EOL>        c.textSpan.start += offsetForBom;<EOL>        <EOL>        if ((c.textSpan.start + c.textSpan.length) <= lineStart) {<EOL>            return null;<EOL>        }<EOL>        <EOL>        if (c.textSpan.start > (lineStart +  lineLength)) {<EOL>            return null;<EOL>        }<EOL>        <EOL>        if (c. textSpan.start < lineStart) {<EOL>            c.textSpan.length = c.textSpan.start + c.textSpan.length - lineStart;<EOL>            c.textSpan. start = lineStart;<EOL>        }<EOL>        <EOL>        if ((c.textSpan.start + c.textSpan.length) > (lineStart + lineLength)) {<EOL>            c.textSpan.length = (lineStart + lineLength) - (c.textSpan.start);<EOL>        }<EOL>        <EOL>        if (!lastStartSet) {<EOL>             lastStartSet = true;<EOL>            lastStart = c.textSpan.start;<EOL>        }<EOL>        else {<EOL>            if (c.textSpan.start == lastStart) {<EOL>","gt":"return null;"}
{"input":"<s> export function getClassificationsForLine(filePath, lineStart, string) {<EOL>    const offsetForBom = hasBom[filePath] ? -<NUM_LIT> : <NUM_LIT>;<EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    let lineLength = string.length;<EOL>    let  encodedClassifications = languageService.getEncodedSyntacticClassifications(filePath, { start: lineStart, length: lineLength });<EOL>    let classifications = unencodeClassifications(encodedClassifications);<EOL>    <EOL>    let lastStartSet = false;<EOL>    let lastStart = <NUM_LIT>;<EOL>    <EOL>    classifications = classifications<EOL>        . map((c, i) => {<EOL>        <EOL>        c.textSpan.start += offsetForBom;<EOL>        <EOL>        if ((c.textSpan.start + c.textSpan.length) <= lineStart) {<EOL>            return null;<EOL>        }<EOL>        <EOL>        if (c.textSpan.start > (lineStart +  lineLength)) {<EOL>            return null;<EOL>        }<EOL>        <EOL>        if (c. textSpan.start < lineStart) {<EOL>            c.textSpan.length = c.textSpan.start + c.textSpan.length - lineStart;<EOL>            c.textSpan. start = lineStart;<EOL>        }<EOL>        <EOL>        if ((c.textSpan.start + c.textSpan.length) > (lineStart + lineLength)) {<EOL>            c.textSpan.length = (lineStart + lineLength) - (c.textSpan.start);<EOL>        }<EOL>        <EOL>        if (!lastStartSet) {<EOL>             lastStartSet = true;<EOL>            lastStart = c.textSpan.start;<EOL>        }<EOL>        else {<EOL>            if (c.textSpan.start == lastStart) {<EOL>                 return null;<EOL>            }<EOL>        }<EOL>","gt":"return c;"}
{"input":"<s> export function getPositionOfLineAndCharacter(filePath, line, ch) {<EOL>    return languageServiceHost.getPositionOfLineAndCharacter(filePath, line,","gt":"ch);"}
{"input":"<s> <EOL>export function onlyLastCallWithDelay(call, token) {<EOL>    let delay = <NUM_LIT>;<EOL>    let timeout;<EOL>    const p = new Promise((resolve, reject) => {<EOL>        const later = () => {<EOL>","gt":"if (token.isCancellationRequested)"}
{"input":"<s> <EOL>export function onlyLastCallWithDelay(call, token) {<EOL>    let delay = <NUM_LIT>;<EOL>    let timeout;<EOL>    const p = new Promise((resolve, reject) => {<EOL>        const later = () => {<EOL>             if (token.isCancellationRequested)<EOL>                reject('<STR_LIT>');<EOL>","gt":"else {"}
{"input":"<s> <EOL>export function onlyLastCallWithDelay(call, token) {<EOL>    let delay = <NUM_LIT>;<EOL>    let timeout;<EOL>    const p = new Promise((resolve, reject) => {<EOL>        const later = () => {<EOL>             if (token.isCancellationRequested)<EOL>                reject('<STR_LIT>');<EOL>             else {<EOL>                call().then((res) => {<EOL>                    if (token.isCancellationRequested)<EOL>                        reject('<STR_LIT>');<EOL>                    else<EOL>","gt":"resolve(res);"}
{"input":"<s> <EOL>export function onlyLastCallWithDelay(call, token) {<EOL>    let delay = <NUM_LIT>;<EOL>    let timeout;<EOL>    const p = new Promise((resolve, reject) => {<EOL>        const later = () => {<EOL>             if (token.isCancellationRequested)<EOL>                reject('<STR_LIT>');<EOL>             else {<EOL>                call().then((res) => {<EOL>                    if (token.isCancellationRequested)<EOL>                        reject('<STR_LIT>');<EOL>                    else<EOL>                         resolve(res);<EOL>                });<EOL>            }<EOL>        };<EOL>        timeout = setTimeout(later, delay);<EOL>        token.","gt":"onCancellationRequested(() => {"}
{"input":"<s> export function getUrlFromFilePathAndProtocol(config) {<EOL>    return config.","gt":"protocol + '<STR_LIT>' + config.filePath;"}
{"input":"<s> <EOL>export function selectMany(arr) {<EOL>    var result = [];<EOL>    for (var i = <NUM_LIT>; i < arr.length; i++) {<EOL>        for (var j = <NUM_LIT>; j < arr[i].","gt":"length; j++) {"}
{"input":"<s> <EOL>export function values(dict) {<EOL>    return Object.keys(dict).map((key) =>","gt":"dict[key]);"}
{"input":"<s> function setErrorsInTsconfig(filePath, errors) {<EOL>    console.log(","gt":"'<STR_LIT>', errors[<NUM_LIT>].message);"}
{"input":"<s> export function getOpenFile(filePath) {<EOL>    if (openFiles.some((f) => f.config.filePath ==","gt":"filePath)) {"}
{"input":"<s> <EOL>export function getSetting(config) {<EOL>    let session = getDefaultOrNewSession(","gt":"config.sessionId);"}
{"input":"<s> function writeDiskSessionFile(sessionFileContents) {<EOL>    fsu.writeFile(sessionFile, json.stringify(","gt":"sessionFileContents));"}
{"input":"<s> export function createEditorconfig(data) {<EOL>    const defaultContents = `<STR_LIT>`.trim();<EOL>    const filePath = workingDir.makeAbsolute('<STR_LIT>');<EOL>    if (fsu.","gt":"existsSync(filePath)) {"}
{"input":"<s> <EOL>function transformClass(node, sourceFile) {<EOL>    const name = node.name.text;<EOL>    const comment = getParsedComment(node, sourceFile);<EOL>    const subItems = [];<EOL>    let icon = types.IconType.Class;<EOL>    if (node.typeParameters) {<EOL>        icon = types.","gt":"IconType.ClassGeneric;"}
{"input":"<s> <EOL>function transformClass(node, sourceFile) {<EOL>    const name = node.name.text;<EOL>    const comment = getParsedComment(node, sourceFile);<EOL>    const subItems = [];<EOL>    let icon = types.IconType.Class;<EOL>    if (node.typeParameters) {<EOL>        icon = types. IconType.ClassGeneric;<EOL>    }<EOL>    ts.forEachChild(node, (node) => {<EOL>        if (node.","gt":"kind == ts.SyntaxKind.Constructor) {"}
{"input":"<s> <EOL>function transformClass(node, sourceFile) {<EOL>    const name = node.name.text;<EOL>    const comment = getParsedComment(node, sourceFile);<EOL>    const subItems = [];<EOL>    let icon = types.IconType.Class;<EOL>    if (node.typeParameters) {<EOL>        icon = types. IconType.ClassGeneric;<EOL>    }<EOL>    ts.forEachChild(node, (node) => {<EOL>        if (node. kind == ts.SyntaxKind.Constructor) {<EOL>            subItems.push(transformClassConstructor(node, sourceFile));<EOL>        }<EOL>        if (node.kind ==","gt":"ts.SyntaxKind.PropertyDeclaration) {"}
{"input":"<s> <EOL>function transformClass(node, sourceFile) {<EOL>    const name = node.name.text;<EOL>    const comment = getParsedComment(node, sourceFile);<EOL>    const subItems = [];<EOL>    let icon = types.IconType.Class;<EOL>    if (node.typeParameters) {<EOL>        icon = types. IconType.ClassGeneric;<EOL>    }<EOL>    ts.forEachChild(node, (node) => {<EOL>        if (node. kind == ts.SyntaxKind.Constructor) {<EOL>            subItems.push(transformClassConstructor(node, sourceFile));<EOL>        }<EOL>        if (node.kind ==  ts.SyntaxKind.PropertyDeclaration) {<EOL>            subItems.push(transformClassProperty(node, sourceFile));<EOL>        }<EOL>","gt":"if (node.kind == ts.SyntaxKind.MethodDeclaration) {"}
{"input":"<s> <EOL>function transformModule(node, sourceFile) {<EOL>    <EOL>    let icon = types.IconType.Namespace;<EOL>    let name = ts.unescapeLeadingUnderscores(ts.getPropertyNameForPropertyNameNode(node.name));<EOL>    if (node.body.","gt":"kind === ts.SyntaxKind.ModuleDeclaration) {"}
{"input":"<s> <EOL>function transformModule(node, sourceFile) {<EOL>    <EOL>    let icon = types.IconType.Namespace;<EOL>    let name = ts.unescapeLeadingUnderscores(ts.getPropertyNameForPropertyNameNode(node.name));<EOL>    if (node.body. kind === ts.SyntaxKind.ModuleDeclaration) {<EOL>        name = name + '<STR_LIT>';<EOL>        const recurse = transformModule(node.body, sourceFile);<EOL>","gt":"return {"}
{"input":"<s> <EOL>function transformModule(node, sourceFile) {<EOL>    <EOL>    let icon = types.IconType.Namespace;<EOL>    let name = ts.unescapeLeadingUnderscores(ts.getPropertyNameForPropertyNameNode(node.name));<EOL>    if (node.body. kind === ts.SyntaxKind.ModuleDeclaration) {<EOL>        name = name + '<STR_LIT>';<EOL>        const recurse = transformModule(node.body, sourceFile);<EOL>         return {<EOL>            name: name + recurse.name,<EOL>            icon,<EOL>            comment: recurse.comment,<EOL>            subItems: recurse.subItems,<EOL>            location: getDocumentedTypeLocation(sourceFile, node.","gt":"name.pos),"}
{"input":"<s> <EOL>function transformModule(node, sourceFile) {<EOL>    <EOL>    let icon = types.IconType.Namespace;<EOL>    let name = ts.unescapeLeadingUnderscores(ts.getPropertyNameForPropertyNameNode(node.name));<EOL>    if (node.body. kind === ts.SyntaxKind.ModuleDeclaration) {<EOL>        name = name + '<STR_LIT>';<EOL>        const recurse = transformModule(node.body, sourceFile);<EOL>         return {<EOL>            name: name + recurse.name,<EOL>            icon,<EOL>            comment: recurse.comment,<EOL>            subItems: recurse.subItems,<EOL>            location: getDocumentedTypeLocation(sourceFile, node. name.pos),<EOL>        };<EOL>    }<EOL>    else {<EOL>","gt":"const comment = getParsedComment(node, sourceFile);"}
{"input":"<s> <EOL>export function getDocumentedTypeLocation(sourceFile, position) {<EOL>    <EOL>    const pos = ts.getLineAndCharacterOfPosition(sourceFile, position + <NUM_LIT>);<EOL>","gt":"return {"}
{"input":"<s> export function applyQuickFix(query) {<EOL>    const info = getInfoForQuickFixAnalysis(query);<EOL>    <EOL>    if (query.key.startsWith(tsCodefixPrefix)) {<EOL>        <EOL>        let project = getProject(","gt":"query.filePath);"}
{"input":"<s> export function applyQuickFix(query) {<EOL>    const info = getInfoForQuickFixAnalysis(query);<EOL>    <EOL>    if (query.key.startsWith(tsCodefixPrefix)) {<EOL>        <EOL>        let project = getProject( query.filePath);<EOL>        const tsCodeFixes = project.languageService.getCodeFixesAtPosition(query.filePath, query.position, query.position, info.positionErrors.map((e) => e.code), info.formatOptions);<EOL>        const index = +query.key.substr(tsCodefixPrefix.length);<EOL>        const tsCodeFix =","gt":"tsCodeFixes[index];"}
{"input":"<s> export function applyQuickFix(query) {<EOL>    const info = getInfoForQuickFixAnalysis(query);<EOL>    <EOL>    if (query.key.startsWith(tsCodefixPrefix)) {<EOL>        <EOL>        let project = getProject( query.filePath);<EOL>        const tsCodeFixes = project.languageService.getCodeFixesAtPosition(query.filePath, query.position, query.position, info.positionErrors.map((e) => e.code), info.formatOptions);<EOL>        const index = +query.key.substr(tsCodefixPrefix.length);<EOL>        const tsCodeFix =  tsCodeFixes[index];<EOL>        <EOL>        const refactorings = [];<EOL>        tsCodeFix.changes.","gt":"forEach((change) => {"}
{"input":"<s> export function applyQuickFix(query) {<EOL>    const info = getInfoForQuickFixAnalysis(query);<EOL>    <EOL>    if (query.key.startsWith(tsCodefixPrefix)) {<EOL>        <EOL>        let project = getProject( query.filePath);<EOL>        const tsCodeFixes = project.languageService.getCodeFixesAtPosition(query.filePath, query.position, query.position, info.positionErrors.map((e) => e.code), info.formatOptions);<EOL>        const index = +query.key.substr(tsCodefixPrefix.length);<EOL>        const tsCodeFix =  tsCodeFixes[index];<EOL>        <EOL>        const refactorings = [];<EOL>        tsCodeFix.changes. forEach((change) => {<EOL>            change.textChanges.forEach((tc) => {<EOL>                const res = {<EOL>","gt":"filePath: change.fileName,"}
{"input":"<s> export function getFlowRoots(query) {<EOL>    let project = activeProject.GetProject.getCurrentIfAny();<EOL>    var languageService = project.languageService;<EOL>    const filePath = query.filePath;<EOL>    const sourceFile = project.getSourceFile(query.","gt":"filePath);"}
{"input":"<s> export function getFlowRoots(query) {<EOL>    let project = activeProject.GetProject.getCurrentIfAny();<EOL>    var languageService = project.languageService;<EOL>    const filePath = query.filePath;<EOL>    const sourceFile = project.getSourceFile(query. filePath);<EOL>    const flowPoints = [];<EOL>    let declarations = sourceFile.getNamedDeclarations();<EOL>    for (let","gt":"index in declarations) {"}
{"input":"<s> export function getFlowRoots(query) {<EOL>    let project = activeProject.GetProject.getCurrentIfAny();<EOL>    var languageService = project.languageService;<EOL>    const filePath = query.filePath;<EOL>    const sourceFile = project.getSourceFile(query. filePath);<EOL>    const flowPoints = [];<EOL>    let declarations = sourceFile.getNamedDeclarations();<EOL>    for (let  index in declarations) {<EOL>        for (let declaration of declarations[index]) {<EOL>            const flowPoint = {<EOL>                filePath,<EOL>","gt":"from: project.languageServiceHost.getLineAndCharacterOfPosition(filePath, declaration.getStart()),"}
{"input":"<s> export function bearishspinningtop(data) {<EOL>    return new BearishSpinningTop().hasPattern(","gt":"data);"}
{"input":"<s> export function bullish(data) {<EOL>    return new","gt":"BullishPatterns().hasPattern(data);"}
{"input":"<s> export function darkcloudcover(data) {<EOL>","gt":"return new DarkCloudCover().hasPattern(data);"}
{"input":"<s> export function dragonflydoji(data) {<EOL>    return new DragonFlyDoji().hasPattern(","gt":"data);"}
{"input":"<s> export function morningstar(data) {<EOL>    return new MorningStar().hasPattern(","gt":"data);"}
{"input":"<s> export function kst(input) {<EOL>    Indicator.reverseInputs(input);<EOL>    var result = new KST(input).result;<EOL>    if (","gt":"input.reversedInput) {"}
{"input":"<s> export function format(v) {<EOL>    let precision = getConfig('<STR_LIT>');<EOL>    if (","gt":"precision) {"}
{"input":"<s> export function adl(input) {<EOL>    Indicator.reverseInputs(input);<EOL>    var result = new ADL(input).result;<EOL>    if (","gt":"input.reversedInput) {"}
{"input":"<s> export function obv(input) {<EOL>    Indicator.reverseInputs(input);<EOL>    var result = new OBV(input).result;<EOL>    if (input.","gt":"reversedInput) {"}
{"input":"<s> <EOL>function processTemplate(template, args) {<EOL>    let statements = \"<STR_LIT>\";<EOL>    if (template.indexOf(\"<STR_LIT>\") > -<NUM_LIT>) {<EOL>        let statementsStartPos = template.indexOf(\"<STR_LIT>\");<EOL>        let statementsBodyStartPos =","gt":"statementsStartPos + \"<STR_LIT>\".length;"}
{"input":"<s> <EOL>function processTemplate(template, args) {<EOL>    let statements = \"<STR_LIT>\";<EOL>    if (template.indexOf(\"<STR_LIT>\") > -<NUM_LIT>) {<EOL>        let statementsStartPos = template.indexOf(\"<STR_LIT>\");<EOL>        let statementsBodyStartPos =  statementsStartPos + \"<STR_LIT>\".length;<EOL>        let statementsBodyEndPos = template.indexOf(\"<STR_LIT>\");<EOL>        let statementsEndPos = statementsBodyEndPos + \"<STR_LIT>\".length;<EOL>        while (statementsStartPos > <NUM_LIT> && (template[statementsStartPos - <NUM_LIT>] == '<STR_LIT>' || template[statementsStartPos - <NUM_LIT>] == '<STR_LIT>'))<EOL>","gt":"statementsStartPos--;"}
{"input":"<s> <EOL>function processTemplate(template, args) {<EOL>    let statements = \"<STR_LIT>\";<EOL>    if (template.indexOf(\"<STR_LIT>\") > -<NUM_LIT>) {<EOL>        let statementsStartPos = template.indexOf(\"<STR_LIT>\");<EOL>        let statementsBodyStartPos =  statementsStartPos + \"<STR_LIT>\".length;<EOL>        let statementsBodyEndPos = template.indexOf(\"<STR_LIT>\");<EOL>        let statementsEndPos = statementsBodyEndPos + \"<STR_LIT>\".length;<EOL>        while (statementsStartPos > <NUM_LIT> && (template[statementsStartPos - <NUM_LIT>] == '<STR_LIT>' || template[statementsStartPos - <NUM_LIT>] == '<STR_LIT>'))<EOL>             statementsStartPos--;<EOL>        if (statementsBodyEndPos > <NUM_LIT> && template[statementsBodyEndPos - <NUM_LIT>] == '<STR_LIT>')<EOL>            statementsBodyEndPos--;<EOL>        let templateText = template.slice(statementsBodyStartPos,","gt":"statementsBodyEndPos).replace(/\\n    /g, '<STR_LIT>');"}
{"input":"<s> <EOL>function processTemplate(template, args) {<EOL>    let statements = \"<STR_LIT>\";<EOL>    if (template.indexOf(\"<STR_LIT>\") > -<NUM_LIT>) {<EOL>        let statementsStartPos = template.indexOf(\"<STR_LIT>\");<EOL>        let statementsBodyStartPos =  statementsStartPos + \"<STR_LIT>\".length;<EOL>        let statementsBodyEndPos = template.indexOf(\"<STR_LIT>\");<EOL>        let statementsEndPos = statementsBodyEndPos + \"<STR_LIT>\".length;<EOL>        while (statementsStartPos > <NUM_LIT> && (template[statementsStartPos - <NUM_LIT>] == '<STR_LIT>' || template[statementsStartPos - <NUM_LIT>] == '<STR_LIT>'))<EOL>             statementsStartPos--;<EOL>        if (statementsBodyEndPos > <NUM_LIT> && template[statementsBodyEndPos - <NUM_LIT>] == '<STR_LIT>')<EOL>            statementsBodyEndPos--;<EOL>        let templateText = template.slice(statementsBodyStartPos,  statementsBodyEndPos).replace(/\\n    /g, '<STR_LIT>');<EOL>        let [c, s] = processTemplate(templateText, args);<EOL>        statements += s + c;<EOL>        template = template.slice(<NUM_LIT>, statementsStartPos) + template.slice(statementsEndPos);<EOL>    }<EOL>    if (typeof","gt":"args === \"<STR_LIT>\")"}
{"input":"<s> <EOL>function processTemplate(template, args) {<EOL>    let statements = \"<STR_LIT>\";<EOL>    if (template.indexOf(\"<STR_LIT>\") > -<NUM_LIT>) {<EOL>        let statementsStartPos = template.indexOf(\"<STR_LIT>\");<EOL>        let statementsBodyStartPos =  statementsStartPos + \"<STR_LIT>\".length;<EOL>        let statementsBodyEndPos = template.indexOf(\"<STR_LIT>\");<EOL>        let statementsEndPos = statementsBodyEndPos + \"<STR_LIT>\".length;<EOL>        while (statementsStartPos > <NUM_LIT> && (template[statementsStartPos - <NUM_LIT>] == '<STR_LIT>' || template[statementsStartPos - <NUM_LIT>] == '<STR_LIT>'))<EOL>             statementsStartPos--;<EOL>        if (statementsBodyEndPos > <NUM_LIT> && template[statementsBodyEndPos - <NUM_LIT>] == '<STR_LIT>')<EOL>            statementsBodyEndPos--;<EOL>        let templateText = template.slice(statementsBodyStartPos,  statementsBodyEndPos).replace(/\\n    /g, '<STR_LIT>');<EOL>        let [c, s] = processTemplate(templateText, args);<EOL>        statements += s + c;<EOL>        template = template.slice(<NUM_LIT>, statementsStartPos) + template.slice(statementsEndPos);<EOL>    }<EOL>    if (typeof  args === \"<STR_LIT>\")<EOL>        return [template.replace(/{this}/g, () => args),","gt":"statements];"}
{"input":"<s> <EOL>function processTemplate(template, args) {<EOL>    let statements = \"<STR_LIT>\";<EOL>    if (template.indexOf(\"<STR_LIT>\") > -<NUM_LIT>) {<EOL>        let statementsStartPos = template.indexOf(\"<STR_LIT>\");<EOL>        let statementsBodyStartPos =  statementsStartPos + \"<STR_LIT>\".length;<EOL>        let statementsBodyEndPos = template.indexOf(\"<STR_LIT>\");<EOL>        let statementsEndPos = statementsBodyEndPos + \"<STR_LIT>\".length;<EOL>        while (statementsStartPos > <NUM_LIT> && (template[statementsStartPos - <NUM_LIT>] == '<STR_LIT>' || template[statementsStartPos - <NUM_LIT>] == '<STR_LIT>'))<EOL>             statementsStartPos--;<EOL>        if (statementsBodyEndPos > <NUM_LIT> && template[statementsBodyEndPos - <NUM_LIT>] == '<STR_LIT>')<EOL>            statementsBodyEndPos--;<EOL>        let templateText = template.slice(statementsBodyStartPos,  statementsBodyEndPos).replace(/\\n    /g, '<STR_LIT>');<EOL>        let [c, s] = processTemplate(templateText, args);<EOL>        statements += s + c;<EOL>        template = template.slice(<NUM_LIT>, statementsStartPos) + template.slice(statementsEndPos);<EOL>    }<EOL>    if (typeof  args === \"<STR_LIT>\")<EOL>        return [template.replace(/{this}/g, () => args),  statements];<EOL>    let ifPos;<EOL>    while ((ifPos = template.indexOf(\"<STR_LIT>\")) > -<NUM_LIT>) {<EOL>        let posBeforeIf = ifPos;<EOL>        while (posBeforeIf > <NUM_LIT> && (template[posBeforeIf - <NUM_LIT>] == '<STR_LIT>' || template[posBeforeIf - <NUM_LIT>] == '<STR_LIT>'))<EOL>            posBeforeIf--;<EOL>        ifPos += <NUM_LIT>;<EOL>        let conditionStartPos = ifPos;<EOL>        while (","gt":"template[ifPos] != \"<STR_LIT>\")"}
{"input":"<s> <EOL>function processTemplate(template, args) {<EOL>    let statements = \"<STR_LIT>\";<EOL>    if (template.indexOf(\"<STR_LIT>\") > -<NUM_LIT>) {<EOL>        let statementsStartPos = template.indexOf(\"<STR_LIT>\");<EOL>        let statementsBodyStartPos =  statementsStartPos + \"<STR_LIT>\".length;<EOL>        let statementsBodyEndPos = template.indexOf(\"<STR_LIT>\");<EOL>        let statementsEndPos = statementsBodyEndPos + \"<STR_LIT>\".length;<EOL>        while (statementsStartPos > <NUM_LIT> && (template[statementsStartPos - <NUM_LIT>] == '<STR_LIT>' || template[statementsStartPos - <NUM_LIT>] == '<STR_LIT>'))<EOL>             statementsStartPos--;<EOL>        if (statementsBodyEndPos > <NUM_LIT> && template[statementsBodyEndPos - <NUM_LIT>] == '<STR_LIT>')<EOL>            statementsBodyEndPos--;<EOL>        let templateText = template.slice(statementsBodyStartPos,  statementsBodyEndPos).replace(/\\n    /g, '<STR_LIT>');<EOL>        let [c, s] = processTemplate(templateText, args);<EOL>        statements += s + c;<EOL>        template = template.slice(<NUM_LIT>, statementsStartPos) + template.slice(statementsEndPos);<EOL>    }<EOL>    if (typeof  args === \"<STR_LIT>\")<EOL>        return [template.replace(/{this}/g, () => args),  statements];<EOL>    let ifPos;<EOL>    while ((ifPos = template.indexOf(\"<STR_LIT>\")) > -<NUM_LIT>) {<EOL>        let posBeforeIf = ifPos;<EOL>        while (posBeforeIf > <NUM_LIT> && (template[posBeforeIf - <NUM_LIT>] == '<STR_LIT>' || template[posBeforeIf - <NUM_LIT>] == '<STR_LIT>'))<EOL>            posBeforeIf--;<EOL>        ifPos += <NUM_LIT>;<EOL>        let conditionStartPos = ifPos;<EOL>        while ( template[ifPos] != \"<STR_LIT>\")<EOL>            ifPos++;<EOL>","gt":"let endIfPos = template.indexOf(\"<STR_LIT>\", ifPos);"}
{"input":"<s> <EOL>function processTemplate(template, args) {<EOL>    let statements = \"<STR_LIT>\";<EOL>    if (template.indexOf(\"<STR_LIT>\") > -<NUM_LIT>) {<EOL>        let statementsStartPos = template.indexOf(\"<STR_LIT>\");<EOL>        let statementsBodyStartPos =  statementsStartPos + \"<STR_LIT>\".length;<EOL>        let statementsBodyEndPos = template.indexOf(\"<STR_LIT>\");<EOL>        let statementsEndPos = statementsBodyEndPos + \"<STR_LIT>\".length;<EOL>        while (statementsStartPos > <NUM_LIT> && (template[statementsStartPos - <NUM_LIT>] == '<STR_LIT>' || template[statementsStartPos - <NUM_LIT>] == '<STR_LIT>'))<EOL>             statementsStartPos--;<EOL>        if (statementsBodyEndPos > <NUM_LIT> && template[statementsBodyEndPos - <NUM_LIT>] == '<STR_LIT>')<EOL>            statementsBodyEndPos--;<EOL>        let templateText = template.slice(statementsBodyStartPos,  statementsBodyEndPos).replace(/\\n    /g, '<STR_LIT>');<EOL>        let [c, s] = processTemplate(templateText, args);<EOL>        statements += s + c;<EOL>        template = template.slice(<NUM_LIT>, statementsStartPos) + template.slice(statementsEndPos);<EOL>    }<EOL>    if (typeof  args === \"<STR_LIT>\")<EOL>        return [template.replace(/{this}/g, () => args),  statements];<EOL>    let ifPos;<EOL>    while ((ifPos = template.indexOf(\"<STR_LIT>\")) > -<NUM_LIT>) {<EOL>        let posBeforeIf = ifPos;<EOL>        while (posBeforeIf > <NUM_LIT> && (template[posBeforeIf - <NUM_LIT>] == '<STR_LIT>' || template[posBeforeIf - <NUM_LIT>] == '<STR_LIT>'))<EOL>            posBeforeIf--;<EOL>        ifPos += <NUM_LIT>;<EOL>        let conditionStartPos = ifPos;<EOL>        while ( template[ifPos] != \"<STR_LIT>\")<EOL>            ifPos++;<EOL>         let endIfPos = template.indexOf(\"<STR_LIT>\", ifPos);<EOL>        let elseIfPos = template.indexOf(\"<STR_LIT>\", ifPos);<EOL>        let elsePos = template.indexOf(\"<STR_LIT>\", ifPos);<EOL>        let endIfBodyPos = endIfPos;<EOL>        if (elseIfPos != -<NUM_LIT> && elseIfPos < endIfBodyPos)<EOL>            endIfBodyPos = elseIfPos;<EOL>        if (elsePos != -<NUM_LIT> && elsePos < endIfBodyPos)<EOL>            endIfBodyPos = elsePos;<EOL>        if (endIfBodyPos > <NUM_LIT> && template[endIfBodyPos - <NUM_LIT>] ==","gt":"'<STR_LIT>')"}
{"input":"<s> <EOL>function processTemplate(template, args) {<EOL>    let statements = \"<STR_LIT>\";<EOL>    if (template.indexOf(\"<STR_LIT>\") > -<NUM_LIT>) {<EOL>        let statementsStartPos = template.indexOf(\"<STR_LIT>\");<EOL>        let statementsBodyStartPos =  statementsStartPos + \"<STR_LIT>\".length;<EOL>        let statementsBodyEndPos = template.indexOf(\"<STR_LIT>\");<EOL>        let statementsEndPos = statementsBodyEndPos + \"<STR_LIT>\".length;<EOL>        while (statementsStartPos > <NUM_LIT> && (template[statementsStartPos - <NUM_LIT>] == '<STR_LIT>' || template[statementsStartPos - <NUM_LIT>] == '<STR_LIT>'))<EOL>             statementsStartPos--;<EOL>        if (statementsBodyEndPos > <NUM_LIT> && template[statementsBodyEndPos - <NUM_LIT>] == '<STR_LIT>')<EOL>            statementsBodyEndPos--;<EOL>        let templateText = template.slice(statementsBodyStartPos,  statementsBodyEndPos).replace(/\\n    /g, '<STR_LIT>');<EOL>        let [c, s] = processTemplate(templateText, args);<EOL>        statements += s + c;<EOL>        template = template.slice(<NUM_LIT>, statementsStartPos) + template.slice(statementsEndPos);<EOL>    }<EOL>    if (typeof  args === \"<STR_LIT>\")<EOL>        return [template.replace(/{this}/g, () => args),  statements];<EOL>    let ifPos;<EOL>    while ((ifPos = template.indexOf(\"<STR_LIT>\")) > -<NUM_LIT>) {<EOL>        let posBeforeIf = ifPos;<EOL>        while (posBeforeIf > <NUM_LIT> && (template[posBeforeIf - <NUM_LIT>] == '<STR_LIT>' || template[posBeforeIf - <NUM_LIT>] == '<STR_LIT>'))<EOL>            posBeforeIf--;<EOL>        ifPos += <NUM_LIT>;<EOL>        let conditionStartPos = ifPos;<EOL>        while ( template[ifPos] != \"<STR_LIT>\")<EOL>            ifPos++;<EOL>         let endIfPos = template.indexOf(\"<STR_LIT>\", ifPos);<EOL>        let elseIfPos = template.indexOf(\"<STR_LIT>\", ifPos);<EOL>        let elsePos = template.indexOf(\"<STR_LIT>\", ifPos);<EOL>        let endIfBodyPos = endIfPos;<EOL>        if (elseIfPos != -<NUM_LIT> && elseIfPos < endIfBodyPos)<EOL>            endIfBodyPos = elseIfPos;<EOL>        if (elsePos != -<NUM_LIT> && elsePos < endIfBodyPos)<EOL>            endIfBodyPos = elsePos;<EOL>        if (endIfBodyPos > <NUM_LIT> && template[endIfBodyPos - <NUM_LIT>] ==  '<STR_LIT>')<EOL>            endIfBodyPos--;<EOL>        let posAfterIf = endIfPos + <NUM_LIT>;<EOL>        if (endIfPos > <NUM_LIT> && template[endIfPos - <NUM_LIT>] == '<STR_LIT>')<EOL>            endIfPos--;<EOL>        let evalText = template.slice(conditionStartPos, ifPos);<EOL>        for (let k in args)<EOL>            evalText = evalText.replace(new RegExp(\"<STR_LIT>\" + k + \"<STR_LIT>\", \"<STR_LIT>\"), function (m) { return \"<STR_LIT>\" + m; });<EOL>        let evalResult = eval(evalText);<EOL>        if (evalResult)<EOL>            template = template.slice(<NUM_LIT>, posBeforeIf) + template.slice(ifPos + <NUM_LIT>, endIfBodyPos).replace(/\\n    /g, '<STR_LIT>') + template.slice(posAfterIf);<EOL>        else if (elseIfPos > -<NUM_LIT>)<EOL>            template = template.slice(<NUM_LIT>, posBeforeIf) +","gt":"\"<STR_LIT>\" + template.slice(elseIfPos + <NUM_LIT>);"}
{"input":"<s> <EOL>function processTemplate(template, args) {<EOL>    let statements = \"<STR_LIT>\";<EOL>    if (template.indexOf(\"<STR_LIT>\") > -<NUM_LIT>) {<EOL>        let statementsStartPos = template.indexOf(\"<STR_LIT>\");<EOL>        let statementsBodyStartPos =  statementsStartPos + \"<STR_LIT>\".length;<EOL>        let statementsBodyEndPos = template.indexOf(\"<STR_LIT>\");<EOL>        let statementsEndPos = statementsBodyEndPos + \"<STR_LIT>\".length;<EOL>        while (statementsStartPos > <NUM_LIT> && (template[statementsStartPos - <NUM_LIT>] == '<STR_LIT>' || template[statementsStartPos - <NUM_LIT>] == '<STR_LIT>'))<EOL>             statementsStartPos--;<EOL>        if (statementsBodyEndPos > <NUM_LIT> && template[statementsBodyEndPos - <NUM_LIT>] == '<STR_LIT>')<EOL>            statementsBodyEndPos--;<EOL>        let templateText = template.slice(statementsBodyStartPos,  statementsBodyEndPos).replace(/\\n    /g, '<STR_LIT>');<EOL>        let [c, s] = processTemplate(templateText, args);<EOL>        statements += s + c;<EOL>        template = template.slice(<NUM_LIT>, statementsStartPos) + template.slice(statementsEndPos);<EOL>    }<EOL>    if (typeof  args === \"<STR_LIT>\")<EOL>        return [template.replace(/{this}/g, () => args),  statements];<EOL>    let ifPos;<EOL>    while ((ifPos = template.indexOf(\"<STR_LIT>\")) > -<NUM_LIT>) {<EOL>        let posBeforeIf = ifPos;<EOL>        while (posBeforeIf > <NUM_LIT> && (template[posBeforeIf - <NUM_LIT>] == '<STR_LIT>' || template[posBeforeIf - <NUM_LIT>] == '<STR_LIT>'))<EOL>            posBeforeIf--;<EOL>        ifPos += <NUM_LIT>;<EOL>        let conditionStartPos = ifPos;<EOL>        while ( template[ifPos] != \"<STR_LIT>\")<EOL>            ifPos++;<EOL>         let endIfPos = template.indexOf(\"<STR_LIT>\", ifPos);<EOL>        let elseIfPos = template.indexOf(\"<STR_LIT>\", ifPos);<EOL>        let elsePos = template.indexOf(\"<STR_LIT>\", ifPos);<EOL>        let endIfBodyPos = endIfPos;<EOL>        if (elseIfPos != -<NUM_LIT> && elseIfPos < endIfBodyPos)<EOL>            endIfBodyPos = elseIfPos;<EOL>        if (elsePos != -<NUM_LIT> && elsePos < endIfBodyPos)<EOL>            endIfBodyPos = elsePos;<EOL>        if (endIfBodyPos > <NUM_LIT> && template[endIfBodyPos - <NUM_LIT>] ==  '<STR_LIT>')<EOL>            endIfBodyPos--;<EOL>        let posAfterIf = endIfPos + <NUM_LIT>;<EOL>        if (endIfPos > <NUM_LIT> && template[endIfPos - <NUM_LIT>] == '<STR_LIT>')<EOL>            endIfPos--;<EOL>        let evalText = template.slice(conditionStartPos, ifPos);<EOL>        for (let k in args)<EOL>            evalText = evalText.replace(new RegExp(\"<STR_LIT>\" + k + \"<STR_LIT>\", \"<STR_LIT>\"), function (m) { return \"<STR_LIT>\" + m; });<EOL>        let evalResult = eval(evalText);<EOL>        if (evalResult)<EOL>            template = template.slice(<NUM_LIT>, posBeforeIf) + template.slice(ifPos + <NUM_LIT>, endIfBodyPos).replace(/\\n    /g, '<STR_LIT>') + template.slice(posAfterIf);<EOL>        else if (elseIfPos > -<NUM_LIT>)<EOL>            template = template.slice(<NUM_LIT>, posBeforeIf) +  \"<STR_LIT>\" + template.slice(elseIfPos + <NUM_LIT>);<EOL>        else if (elsePos > -<NUM_LIT>)<EOL>            template = template.slice(<NUM_LIT>, posBeforeIf) + template.slice(elsePos + <NUM_LIT>, endIfPos).replace(/\\n    /g, '<STR_LIT>') + template.slice(posAfterIf);<EOL>        else<EOL>            template = template.slice(<NUM_LIT>, posBeforeIf) + template.slice(posAfterIf);<EOL>    }<EOL>    let replaced = false;<EOL>    for (var k in args) {<EOL>","gt":"if (k == \"<STR_LIT>\")"}
{"input":"<s> <EOL>function processTemplate(template, args) {<EOL>    let statements = \"<STR_LIT>\";<EOL>    if (template.indexOf(\"<STR_LIT>\") > -<NUM_LIT>) {<EOL>        let statementsStartPos = template.indexOf(\"<STR_LIT>\");<EOL>        let statementsBodyStartPos =  statementsStartPos + \"<STR_LIT>\".length;<EOL>        let statementsBodyEndPos = template.indexOf(\"<STR_LIT>\");<EOL>        let statementsEndPos = statementsBodyEndPos + \"<STR_LIT>\".length;<EOL>        while (statementsStartPos > <NUM_LIT> && (template[statementsStartPos - <NUM_LIT>] == '<STR_LIT>' || template[statementsStartPos - <NUM_LIT>] == '<STR_LIT>'))<EOL>             statementsStartPos--;<EOL>        if (statementsBodyEndPos > <NUM_LIT> && template[statementsBodyEndPos - <NUM_LIT>] == '<STR_LIT>')<EOL>            statementsBodyEndPos--;<EOL>        let templateText = template.slice(statementsBodyStartPos,  statementsBodyEndPos).replace(/\\n    /g, '<STR_LIT>');<EOL>        let [c, s] = processTemplate(templateText, args);<EOL>        statements += s + c;<EOL>        template = template.slice(<NUM_LIT>, statementsStartPos) + template.slice(statementsEndPos);<EOL>    }<EOL>    if (typeof  args === \"<STR_LIT>\")<EOL>        return [template.replace(/{this}/g, () => args),  statements];<EOL>    let ifPos;<EOL>    while ((ifPos = template.indexOf(\"<STR_LIT>\")) > -<NUM_LIT>) {<EOL>        let posBeforeIf = ifPos;<EOL>        while (posBeforeIf > <NUM_LIT> && (template[posBeforeIf - <NUM_LIT>] == '<STR_LIT>' || template[posBeforeIf - <NUM_LIT>] == '<STR_LIT>'))<EOL>            posBeforeIf--;<EOL>        ifPos += <NUM_LIT>;<EOL>        let conditionStartPos = ifPos;<EOL>        while ( template[ifPos] != \"<STR_LIT>\")<EOL>            ifPos++;<EOL>         let endIfPos = template.indexOf(\"<STR_LIT>\", ifPos);<EOL>        let elseIfPos = template.indexOf(\"<STR_LIT>\", ifPos);<EOL>        let elsePos = template.indexOf(\"<STR_LIT>\", ifPos);<EOL>        let endIfBodyPos = endIfPos;<EOL>        if (elseIfPos != -<NUM_LIT> && elseIfPos < endIfBodyPos)<EOL>            endIfBodyPos = elseIfPos;<EOL>        if (elsePos != -<NUM_LIT> && elsePos < endIfBodyPos)<EOL>            endIfBodyPos = elsePos;<EOL>        if (endIfBodyPos > <NUM_LIT> && template[endIfBodyPos - <NUM_LIT>] ==  '<STR_LIT>')<EOL>            endIfBodyPos--;<EOL>        let posAfterIf = endIfPos + <NUM_LIT>;<EOL>        if (endIfPos > <NUM_LIT> && template[endIfPos - <NUM_LIT>] == '<STR_LIT>')<EOL>            endIfPos--;<EOL>        let evalText = template.slice(conditionStartPos, ifPos);<EOL>        for (let k in args)<EOL>            evalText = evalText.replace(new RegExp(\"<STR_LIT>\" + k + \"<STR_LIT>\", \"<STR_LIT>\"), function (m) { return \"<STR_LIT>\" + m; });<EOL>        let evalResult = eval(evalText);<EOL>        if (evalResult)<EOL>            template = template.slice(<NUM_LIT>, posBeforeIf) + template.slice(ifPos + <NUM_LIT>, endIfBodyPos).replace(/\\n    /g, '<STR_LIT>') + template.slice(posAfterIf);<EOL>        else if (elseIfPos > -<NUM_LIT>)<EOL>            template = template.slice(<NUM_LIT>, posBeforeIf) +  \"<STR_LIT>\" + template.slice(elseIfPos + <NUM_LIT>);<EOL>        else if (elsePos > -<NUM_LIT>)<EOL>            template = template.slice(<NUM_LIT>, posBeforeIf) + template.slice(elsePos + <NUM_LIT>, endIfPos).replace(/\\n    /g, '<STR_LIT>') + template.slice(posAfterIf);<EOL>        else<EOL>            template = template.slice(<NUM_LIT>, posBeforeIf) + template.slice(posAfterIf);<EOL>    }<EOL>    let replaced = false;<EOL>    for (var k in args) {<EOL>         if (k == \"<STR_LIT>\")<EOL>            continue;<EOL>        if (args[k] && args[k].push) {<EOL>            let data = { template };<EOL>            while (replaceArray(data, k, args[k], statements))<EOL>                replaced = true;<EOL>            template = data.template;<EOL>        }<EOL>","gt":"else {"}
{"input":"<s> <EOL>function processTemplate(template, args) {<EOL>    let statements = \"<STR_LIT>\";<EOL>    if (template.indexOf(\"<STR_LIT>\") > -<NUM_LIT>) {<EOL>        let statementsStartPos = template.indexOf(\"<STR_LIT>\");<EOL>        let statementsBodyStartPos =  statementsStartPos + \"<STR_LIT>\".length;<EOL>        let statementsBodyEndPos = template.indexOf(\"<STR_LIT>\");<EOL>        let statementsEndPos = statementsBodyEndPos + \"<STR_LIT>\".length;<EOL>        while (statementsStartPos > <NUM_LIT> && (template[statementsStartPos - <NUM_LIT>] == '<STR_LIT>' || template[statementsStartPos - <NUM_LIT>] == '<STR_LIT>'))<EOL>             statementsStartPos--;<EOL>        if (statementsBodyEndPos > <NUM_LIT> && template[statementsBodyEndPos - <NUM_LIT>] == '<STR_LIT>')<EOL>            statementsBodyEndPos--;<EOL>        let templateText = template.slice(statementsBodyStartPos,  statementsBodyEndPos).replace(/\\n    /g, '<STR_LIT>');<EOL>        let [c, s] = processTemplate(templateText, args);<EOL>        statements += s + c;<EOL>        template = template.slice(<NUM_LIT>, statementsStartPos) + template.slice(statementsEndPos);<EOL>    }<EOL>    if (typeof  args === \"<STR_LIT>\")<EOL>        return [template.replace(/{this}/g, () => args),  statements];<EOL>    let ifPos;<EOL>    while ((ifPos = template.indexOf(\"<STR_LIT>\")) > -<NUM_LIT>) {<EOL>        let posBeforeIf = ifPos;<EOL>        while (posBeforeIf > <NUM_LIT> && (template[posBeforeIf - <NUM_LIT>] == '<STR_LIT>' || template[posBeforeIf - <NUM_LIT>] == '<STR_LIT>'))<EOL>            posBeforeIf--;<EOL>        ifPos += <NUM_LIT>;<EOL>        let conditionStartPos = ifPos;<EOL>        while ( template[ifPos] != \"<STR_LIT>\")<EOL>            ifPos++;<EOL>         let endIfPos = template.indexOf(\"<STR_LIT>\", ifPos);<EOL>        let elseIfPos = template.indexOf(\"<STR_LIT>\", ifPos);<EOL>        let elsePos = template.indexOf(\"<STR_LIT>\", ifPos);<EOL>        let endIfBodyPos = endIfPos;<EOL>        if (elseIfPos != -<NUM_LIT> && elseIfPos < endIfBodyPos)<EOL>            endIfBodyPos = elseIfPos;<EOL>        if (elsePos != -<NUM_LIT> && elsePos < endIfBodyPos)<EOL>            endIfBodyPos = elsePos;<EOL>        if (endIfBodyPos > <NUM_LIT> && template[endIfBodyPos - <NUM_LIT>] ==  '<STR_LIT>')<EOL>            endIfBodyPos--;<EOL>        let posAfterIf = endIfPos + <NUM_LIT>;<EOL>        if (endIfPos > <NUM_LIT> && template[endIfPos - <NUM_LIT>] == '<STR_LIT>')<EOL>            endIfPos--;<EOL>        let evalText = template.slice(conditionStartPos, ifPos);<EOL>        for (let k in args)<EOL>            evalText = evalText.replace(new RegExp(\"<STR_LIT>\" + k + \"<STR_LIT>\", \"<STR_LIT>\"), function (m) { return \"<STR_LIT>\" + m; });<EOL>        let evalResult = eval(evalText);<EOL>        if (evalResult)<EOL>            template = template.slice(<NUM_LIT>, posBeforeIf) + template.slice(ifPos + <NUM_LIT>, endIfBodyPos).replace(/\\n    /g, '<STR_LIT>') + template.slice(posAfterIf);<EOL>        else if (elseIfPos > -<NUM_LIT>)<EOL>            template = template.slice(<NUM_LIT>, posBeforeIf) +  \"<STR_LIT>\" + template.slice(elseIfPos + <NUM_LIT>);<EOL>        else if (elsePos > -<NUM_LIT>)<EOL>            template = template.slice(<NUM_LIT>, posBeforeIf) + template.slice(elsePos + <NUM_LIT>, endIfPos).replace(/\\n    /g, '<STR_LIT>') + template.slice(posAfterIf);<EOL>        else<EOL>            template = template.slice(<NUM_LIT>, posBeforeIf) + template.slice(posAfterIf);<EOL>    }<EOL>    let replaced = false;<EOL>    for (var k in args) {<EOL>         if (k == \"<STR_LIT>\")<EOL>            continue;<EOL>        if (args[k] && args[k].push) {<EOL>            let data = { template };<EOL>            while (replaceArray(data, k, args[k], statements))<EOL>                replaced = true;<EOL>            template = data.template;<EOL>        }<EOL>         else {<EOL>            let index = -<NUM_LIT>;<EOL>            while ((index = template.indexOf(\"<STR_LIT>\" + k + \"<STR_LIT>\")) > -<NUM_LIT>) {<EOL>                let spaces = '<STR_LIT>';<EOL>                while (template.length > index && template[index - <NUM_LIT>] == '<STR_LIT>') {<EOL>                    index--;<EOL>","gt":"spaces += '<STR_LIT>';"}
{"input":"<s> <EOL>function processTemplate(template, args) {<EOL>    let statements = \"<STR_LIT>\";<EOL>    if (template.indexOf(\"<STR_LIT>\") > -<NUM_LIT>) {<EOL>        let statementsStartPos = template.indexOf(\"<STR_LIT>\");<EOL>        let statementsBodyStartPos =  statementsStartPos + \"<STR_LIT>\".length;<EOL>        let statementsBodyEndPos = template.indexOf(\"<STR_LIT>\");<EOL>        let statementsEndPos = statementsBodyEndPos + \"<STR_LIT>\".length;<EOL>        while (statementsStartPos > <NUM_LIT> && (template[statementsStartPos - <NUM_LIT>] == '<STR_LIT>' || template[statementsStartPos - <NUM_LIT>] == '<STR_LIT>'))<EOL>             statementsStartPos--;<EOL>        if (statementsBodyEndPos > <NUM_LIT> && template[statementsBodyEndPos - <NUM_LIT>] == '<STR_LIT>')<EOL>            statementsBodyEndPos--;<EOL>        let templateText = template.slice(statementsBodyStartPos,  statementsBodyEndPos).replace(/\\n    /g, '<STR_LIT>');<EOL>        let [c, s] = processTemplate(templateText, args);<EOL>        statements += s + c;<EOL>        template = template.slice(<NUM_LIT>, statementsStartPos) + template.slice(statementsEndPos);<EOL>    }<EOL>    if (typeof  args === \"<STR_LIT>\")<EOL>        return [template.replace(/{this}/g, () => args),  statements];<EOL>    let ifPos;<EOL>    while ((ifPos = template.indexOf(\"<STR_LIT>\")) > -<NUM_LIT>) {<EOL>        let posBeforeIf = ifPos;<EOL>        while (posBeforeIf > <NUM_LIT> && (template[posBeforeIf - <NUM_LIT>] == '<STR_LIT>' || template[posBeforeIf - <NUM_LIT>] == '<STR_LIT>'))<EOL>            posBeforeIf--;<EOL>        ifPos += <NUM_LIT>;<EOL>        let conditionStartPos = ifPos;<EOL>        while ( template[ifPos] != \"<STR_LIT>\")<EOL>            ifPos++;<EOL>         let endIfPos = template.indexOf(\"<STR_LIT>\", ifPos);<EOL>        let elseIfPos = template.indexOf(\"<STR_LIT>\", ifPos);<EOL>        let elsePos = template.indexOf(\"<STR_LIT>\", ifPos);<EOL>        let endIfBodyPos = endIfPos;<EOL>        if (elseIfPos != -<NUM_LIT> && elseIfPos < endIfBodyPos)<EOL>            endIfBodyPos = elseIfPos;<EOL>        if (elsePos != -<NUM_LIT> && elsePos < endIfBodyPos)<EOL>            endIfBodyPos = elsePos;<EOL>        if (endIfBodyPos > <NUM_LIT> && template[endIfBodyPos - <NUM_LIT>] ==  '<STR_LIT>')<EOL>            endIfBodyPos--;<EOL>        let posAfterIf = endIfPos + <NUM_LIT>;<EOL>        if (endIfPos > <NUM_LIT> && template[endIfPos - <NUM_LIT>] == '<STR_LIT>')<EOL>            endIfPos--;<EOL>        let evalText = template.slice(conditionStartPos, ifPos);<EOL>        for (let k in args)<EOL>            evalText = evalText.replace(new RegExp(\"<STR_LIT>\" + k + \"<STR_LIT>\", \"<STR_LIT>\"), function (m) { return \"<STR_LIT>\" + m; });<EOL>        let evalResult = eval(evalText);<EOL>        if (evalResult)<EOL>            template = template.slice(<NUM_LIT>, posBeforeIf) + template.slice(ifPos + <NUM_LIT>, endIfBodyPos).replace(/\\n    /g, '<STR_LIT>') + template.slice(posAfterIf);<EOL>        else if (elseIfPos > -<NUM_LIT>)<EOL>            template = template.slice(<NUM_LIT>, posBeforeIf) +  \"<STR_LIT>\" + template.slice(elseIfPos + <NUM_LIT>);<EOL>        else if (elsePos > -<NUM_LIT>)<EOL>            template = template.slice(<NUM_LIT>, posBeforeIf) + template.slice(elsePos + <NUM_LIT>, endIfPos).replace(/\\n    /g, '<STR_LIT>') + template.slice(posAfterIf);<EOL>        else<EOL>            template = template.slice(<NUM_LIT>, posBeforeIf) + template.slice(posAfterIf);<EOL>    }<EOL>    let replaced = false;<EOL>    for (var k in args) {<EOL>         if (k == \"<STR_LIT>\")<EOL>            continue;<EOL>        if (args[k] && args[k].push) {<EOL>            let data = { template };<EOL>            while (replaceArray(data, k, args[k], statements))<EOL>                replaced = true;<EOL>            template = data.template;<EOL>        }<EOL>         else {<EOL>            let index = -<NUM_LIT>;<EOL>            while ((index = template.indexOf(\"<STR_LIT>\" + k + \"<STR_LIT>\")) > -<NUM_LIT>) {<EOL>                let spaces = '<STR_LIT>';<EOL>                while (template.length > index && template[index - <NUM_LIT>] == '<STR_LIT>') {<EOL>                    index--;<EOL>                     spaces += '<STR_LIT>';<EOL>                }<EOL>                let value = args[k];<EOL>                if (value && value.resolve)<EOL>","gt":"value = value.resolve();"}
{"input":"<s> <EOL>function processTemplate(template, args) {<EOL>    let statements = \"<STR_LIT>\";<EOL>    if (template.indexOf(\"<STR_LIT>\") > -<NUM_LIT>) {<EOL>        let statementsStartPos = template.indexOf(\"<STR_LIT>\");<EOL>        let statementsBodyStartPos =  statementsStartPos + \"<STR_LIT>\".length;<EOL>        let statementsBodyEndPos = template.indexOf(\"<STR_LIT>\");<EOL>        let statementsEndPos = statementsBodyEndPos + \"<STR_LIT>\".length;<EOL>        while (statementsStartPos > <NUM_LIT> && (template[statementsStartPos - <NUM_LIT>] == '<STR_LIT>' || template[statementsStartPos - <NUM_LIT>] == '<STR_LIT>'))<EOL>             statementsStartPos--;<EOL>        if (statementsBodyEndPos > <NUM_LIT> && template[statementsBodyEndPos - <NUM_LIT>] == '<STR_LIT>')<EOL>            statementsBodyEndPos--;<EOL>        let templateText = template.slice(statementsBodyStartPos,  statementsBodyEndPos).replace(/\\n    /g, '<STR_LIT>');<EOL>        let [c, s] = processTemplate(templateText, args);<EOL>        statements += s + c;<EOL>        template = template.slice(<NUM_LIT>, statementsStartPos) + template.slice(statementsEndPos);<EOL>    }<EOL>    if (typeof  args === \"<STR_LIT>\")<EOL>        return [template.replace(/{this}/g, () => args),  statements];<EOL>    let ifPos;<EOL>    while ((ifPos = template.indexOf(\"<STR_LIT>\")) > -<NUM_LIT>) {<EOL>        let posBeforeIf = ifPos;<EOL>        while (posBeforeIf > <NUM_LIT> && (template[posBeforeIf - <NUM_LIT>] == '<STR_LIT>' || template[posBeforeIf - <NUM_LIT>] == '<STR_LIT>'))<EOL>            posBeforeIf--;<EOL>        ifPos += <NUM_LIT>;<EOL>        let conditionStartPos = ifPos;<EOL>        while ( template[ifPos] != \"<STR_LIT>\")<EOL>            ifPos++;<EOL>         let endIfPos = template.indexOf(\"<STR_LIT>\", ifPos);<EOL>        let elseIfPos = template.indexOf(\"<STR_LIT>\", ifPos);<EOL>        let elsePos = template.indexOf(\"<STR_LIT>\", ifPos);<EOL>        let endIfBodyPos = endIfPos;<EOL>        if (elseIfPos != -<NUM_LIT> && elseIfPos < endIfBodyPos)<EOL>            endIfBodyPos = elseIfPos;<EOL>        if (elsePos != -<NUM_LIT> && elsePos < endIfBodyPos)<EOL>            endIfBodyPos = elsePos;<EOL>        if (endIfBodyPos > <NUM_LIT> && template[endIfBodyPos - <NUM_LIT>] ==  '<STR_LIT>')<EOL>            endIfBodyPos--;<EOL>        let posAfterIf = endIfPos + <NUM_LIT>;<EOL>        if (endIfPos > <NUM_LIT> && template[endIfPos - <NUM_LIT>] == '<STR_LIT>')<EOL>            endIfPos--;<EOL>        let evalText = template.slice(conditionStartPos, ifPos);<EOL>        for (let k in args)<EOL>            evalText = evalText.replace(new RegExp(\"<STR_LIT>\" + k + \"<STR_LIT>\", \"<STR_LIT>\"), function (m) { return \"<STR_LIT>\" + m; });<EOL>        let evalResult = eval(evalText);<EOL>        if (evalResult)<EOL>            template = template.slice(<NUM_LIT>, posBeforeIf) + template.slice(ifPos + <NUM_LIT>, endIfBodyPos).replace(/\\n    /g, '<STR_LIT>') + template.slice(posAfterIf);<EOL>        else if (elseIfPos > -<NUM_LIT>)<EOL>            template = template.slice(<NUM_LIT>, posBeforeIf) +  \"<STR_LIT>\" + template.slice(elseIfPos + <NUM_LIT>);<EOL>        else if (elsePos > -<NUM_LIT>)<EOL>            template = template.slice(<NUM_LIT>, posBeforeIf) + template.slice(elsePos + <NUM_LIT>, endIfPos).replace(/\\n    /g, '<STR_LIT>') + template.slice(posAfterIf);<EOL>        else<EOL>            template = template.slice(<NUM_LIT>, posBeforeIf) + template.slice(posAfterIf);<EOL>    }<EOL>    let replaced = false;<EOL>    for (var k in args) {<EOL>         if (k == \"<STR_LIT>\")<EOL>            continue;<EOL>        if (args[k] && args[k].push) {<EOL>            let data = { template };<EOL>            while (replaceArray(data, k, args[k], statements))<EOL>                replaced = true;<EOL>            template = data.template;<EOL>        }<EOL>         else {<EOL>            let index = -<NUM_LIT>;<EOL>            while ((index = template.indexOf(\"<STR_LIT>\" + k + \"<STR_LIT>\")) > -<NUM_LIT>) {<EOL>                let spaces = '<STR_LIT>';<EOL>                while (template.length > index && template[index - <NUM_LIT>] == '<STR_LIT>') {<EOL>                    index--;<EOL>                     spaces += '<STR_LIT>';<EOL>                }<EOL>                let value = args[k];<EOL>                if (value && value.resolve)<EOL>                     value = value.resolve();<EOL>                if (value && typeof value === '<STR_LIT>')<EOL>                    value = value.replace(","gt":"/\\n/g, '<STR_LIT>' + spaces);"}
{"input":"<s> <EOL>function processTemplate(template, args) {<EOL>    let statements = \"<STR_LIT>\";<EOL>    if (template.indexOf(\"<STR_LIT>\") > -<NUM_LIT>) {<EOL>        let statementsStartPos = template.indexOf(\"<STR_LIT>\");<EOL>        let statementsBodyStartPos =  statementsStartPos + \"<STR_LIT>\".length;<EOL>        let statementsBodyEndPos = template.indexOf(\"<STR_LIT>\");<EOL>        let statementsEndPos = statementsBodyEndPos + \"<STR_LIT>\".length;<EOL>        while (statementsStartPos > <NUM_LIT> && (template[statementsStartPos - <NUM_LIT>] == '<STR_LIT>' || template[statementsStartPos - <NUM_LIT>] == '<STR_LIT>'))<EOL>             statementsStartPos--;<EOL>        if (statementsBodyEndPos > <NUM_LIT> && template[statementsBodyEndPos - <NUM_LIT>] == '<STR_LIT>')<EOL>            statementsBodyEndPos--;<EOL>        let templateText = template.slice(statementsBodyStartPos,  statementsBodyEndPos).replace(/\\n    /g, '<STR_LIT>');<EOL>        let [c, s] = processTemplate(templateText, args);<EOL>        statements += s + c;<EOL>        template = template.slice(<NUM_LIT>, statementsStartPos) + template.slice(statementsEndPos);<EOL>    }<EOL>    if (typeof  args === \"<STR_LIT>\")<EOL>        return [template.replace(/{this}/g, () => args),  statements];<EOL>    let ifPos;<EOL>    while ((ifPos = template.indexOf(\"<STR_LIT>\")) > -<NUM_LIT>) {<EOL>        let posBeforeIf = ifPos;<EOL>        while (posBeforeIf > <NUM_LIT> && (template[posBeforeIf - <NUM_LIT>] == '<STR_LIT>' || template[posBeforeIf - <NUM_LIT>] == '<STR_LIT>'))<EOL>            posBeforeIf--;<EOL>        ifPos += <NUM_LIT>;<EOL>        let conditionStartPos = ifPos;<EOL>        while ( template[ifPos] != \"<STR_LIT>\")<EOL>            ifPos++;<EOL>         let endIfPos = template.indexOf(\"<STR_LIT>\", ifPos);<EOL>        let elseIfPos = template.indexOf(\"<STR_LIT>\", ifPos);<EOL>        let elsePos = template.indexOf(\"<STR_LIT>\", ifPos);<EOL>        let endIfBodyPos = endIfPos;<EOL>        if (elseIfPos != -<NUM_LIT> && elseIfPos < endIfBodyPos)<EOL>            endIfBodyPos = elseIfPos;<EOL>        if (elsePos != -<NUM_LIT> && elsePos < endIfBodyPos)<EOL>            endIfBodyPos = elsePos;<EOL>        if (endIfBodyPos > <NUM_LIT> && template[endIfBodyPos - <NUM_LIT>] ==  '<STR_LIT>')<EOL>            endIfBodyPos--;<EOL>        let posAfterIf = endIfPos + <NUM_LIT>;<EOL>        if (endIfPos > <NUM_LIT> && template[endIfPos - <NUM_LIT>] == '<STR_LIT>')<EOL>            endIfPos--;<EOL>        let evalText = template.slice(conditionStartPos, ifPos);<EOL>        for (let k in args)<EOL>            evalText = evalText.replace(new RegExp(\"<STR_LIT>\" + k + \"<STR_LIT>\", \"<STR_LIT>\"), function (m) { return \"<STR_LIT>\" + m; });<EOL>        let evalResult = eval(evalText);<EOL>        if (evalResult)<EOL>            template = template.slice(<NUM_LIT>, posBeforeIf) + template.slice(ifPos + <NUM_LIT>, endIfBodyPos).replace(/\\n    /g, '<STR_LIT>') + template.slice(posAfterIf);<EOL>        else if (elseIfPos > -<NUM_LIT>)<EOL>            template = template.slice(<NUM_LIT>, posBeforeIf) +  \"<STR_LIT>\" + template.slice(elseIfPos + <NUM_LIT>);<EOL>        else if (elsePos > -<NUM_LIT>)<EOL>            template = template.slice(<NUM_LIT>, posBeforeIf) + template.slice(elsePos + <NUM_LIT>, endIfPos).replace(/\\n    /g, '<STR_LIT>') + template.slice(posAfterIf);<EOL>        else<EOL>            template = template.slice(<NUM_LIT>, posBeforeIf) + template.slice(posAfterIf);<EOL>    }<EOL>    let replaced = false;<EOL>    for (var k in args) {<EOL>         if (k == \"<STR_LIT>\")<EOL>            continue;<EOL>        if (args[k] && args[k].push) {<EOL>            let data = { template };<EOL>            while (replaceArray(data, k, args[k], statements))<EOL>                replaced = true;<EOL>            template = data.template;<EOL>        }<EOL>         else {<EOL>            let index = -<NUM_LIT>;<EOL>            while ((index = template.indexOf(\"<STR_LIT>\" + k + \"<STR_LIT>\")) > -<NUM_LIT>) {<EOL>                let spaces = '<STR_LIT>';<EOL>                while (template.length > index && template[index - <NUM_LIT>] == '<STR_LIT>') {<EOL>                    index--;<EOL>                     spaces += '<STR_LIT>';<EOL>                }<EOL>                let value = args[k];<EOL>                if (value && value.resolve)<EOL>                     value = value.resolve();<EOL>                if (value && typeof value === '<STR_LIT>')<EOL>                    value = value.replace( /\\n/g, '<STR_LIT>' + spaces);<EOL>                template = template.replace(\"<STR_LIT>\" +","gt":"k + \"<STR_LIT>\", () => value);"}
{"input":"<s> <EOL>export function getSelection(element) {<EOL>    if (!element)<EOL>        throw Error(","gt":"\"<STR_LIT>\");"}
{"input":"<s> function compareGroups(l, r) {<EOL>","gt":"return l.order === r.order ?"}
{"input":"<s> export function getRedirector() {<EOL>    return new","gt":"FirebaseRedirector(loadRedirects());"}
{"input":"<s> export default function () {<EOL>    if (!ngVersionMatches('<STR_LIT>')) {<EOL>        return Promise.resolve();<EOL>    }<EOL>    return ng('<STR_LIT>', '<STR_LIT>', '<STR_LIT>',","gt":"'<STR_LIT>', '<STR_LIT>')"}
{"input":"<s> export default function () {<EOL>    return Promise.resolve()<EOL>        .then(() => createDir('<STR_LIT>'))<EOL>        .","gt":"then(() => writeFile('<STR_LIT>', `<STR_LIT>`"}
{"input":"<s> export default function () {<EOL>    return Promise.resolve()<EOL>        .then(() => createDir('<STR_LIT>'))<EOL>        . then(() => writeFile('<STR_LIT>', `<STR_LIT>`))<EOL>        .then(() => appendToFile('<STR_LIT>', '<STR_LIT>'))<EOL>        .then(() => ng('<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>'))<EOL>        .then(() => expectFileToMatch('<STR_LIT>',","gt":"/Bonjour i18n!/))"}
{"input":"<s> export default function () {<EOL>    return Promise.resolve()<EOL>        .then(() => createDir('<STR_LIT>'))<EOL>        . then(() => writeFile('<STR_LIT>', `<STR_LIT>`))<EOL>        .then(() => appendToFile('<STR_LIT>', '<STR_LIT>'))<EOL>        .then(() => ng('<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>'))<EOL>        .then(() => expectFileToMatch('<STR_LIT>',  /Bonjour i18n!/))<EOL>        .then(() => ng('<STR_LIT>', '<STR_LIT>'))<EOL>        .then(() => expectToFail(() => expectFileToMatch('<STR_LIT>', /Bonjour i18n!/)))<EOL>        .then(() => expectFileToMatch('<STR_LIT>', /Hello i18n!/))<EOL>        .then(() => appendToFile(","gt":"'<STR_LIT>', '<STR_LIT>'))"}
{"input":"<s> export default function () {<EOL>    return Promise.resolve()<EOL>        .then(() => createDir('<STR_LIT>'))<EOL>        . then(() => writeFile('<STR_LIT>', `<STR_LIT>`))<EOL>        .then(() => appendToFile('<STR_LIT>', '<STR_LIT>'))<EOL>        .then(() => ng('<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>'))<EOL>        .then(() => expectFileToMatch('<STR_LIT>',  /Bonjour i18n!/))<EOL>        .then(() => ng('<STR_LIT>', '<STR_LIT>'))<EOL>        .then(() => expectToFail(() => expectFileToMatch('<STR_LIT>', /Bonjour i18n!/)))<EOL>        .then(() => expectFileToMatch('<STR_LIT>', /Hello i18n!/))<EOL>        .then(() => appendToFile( '<STR_LIT>', '<STR_LIT>'))<EOL>        .then(() => readFile('<STR_LIT>')<EOL>        .then((compilerCliPackage) => {<EOL>        const version = new Version(JSON.","gt":"parse(compilerCliPackage).version);"}
{"input":"<s> export default function () {<EOL>    return Promise.resolve()<EOL>        .then(() => createDir('<STR_LIT>'))<EOL>        . then(() => writeFile('<STR_LIT>', `<STR_LIT>`))<EOL>        .then(() => appendToFile('<STR_LIT>', '<STR_LIT>'))<EOL>        .then(() => ng('<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>'))<EOL>        .then(() => expectFileToMatch('<STR_LIT>',  /Bonjour i18n!/))<EOL>        .then(() => ng('<STR_LIT>', '<STR_LIT>'))<EOL>        .then(() => expectToFail(() => expectFileToMatch('<STR_LIT>', /Bonjour i18n!/)))<EOL>        .then(() => expectFileToMatch('<STR_LIT>', /Hello i18n!/))<EOL>        .then(() => appendToFile( '<STR_LIT>', '<STR_LIT>'))<EOL>        .then(() => readFile('<STR_LIT>')<EOL>        .then((compilerCliPackage) => {<EOL>        const version = new Version(JSON. parse(compilerCliPackage).version);<EOL>        if (version.major === <NUM_LIT>) {<EOL>            return expectToFail(() => ng('<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>'));<EOL>        }<EOL>        else {<EOL>            return ng('<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>')<EOL>                .then(() => expectFileToMatch('<STR_LIT>', /Other content/));<EOL>        }<EOL>    }))<EOL>        .then(() => readFile('<STR_LIT>')<EOL>        .then((compilerCliPackage) => {<EOL>        const version =","gt":"new Version(JSON.parse(compilerCliPackage).version);"}
{"input":"<s> function generateFileHashMap() {<EOL>    const hashes = new Map();<EOL>    fs.readdirSync('<STR_LIT>')<EOL>        .forEach((name) => {<EOL>        if (!name.","gt":"match(OUTPUT_RE)) {"}
{"input":"<s> function generateFileHashMap() {<EOL>    const hashes = new Map();<EOL>    fs.readdirSync('<STR_LIT>')<EOL>        .forEach((name) => {<EOL>        if (!name. match(OUTPUT_RE)) {<EOL>            return;<EOL>        }<EOL>        const [module, hash] = name.split('<STR_LIT>');<EOL>","gt":"hashes.set(module, hash);"}
{"input":"<s> export default function () {<EOL>    return Promise.resolve()<EOL>        .then(() => writeMultipleFiles({<EOL>        '<STR_LIT>': '<STR_LIT>',<EOL>","gt":"'<STR_LIT>': '<STR_LIT>',"}
{"input":"<s> export default function () {<EOL>    return Promise.resolve()<EOL>        .then(() => writeMultipleFiles({<EOL>        '<STR_LIT>': '<STR_LIT>',<EOL>         '<STR_LIT>': '<STR_LIT>',<EOL>        '<STR_LIT>': '<STR_LIT>',<EOL>","gt":"'<STR_LIT>': '<STR_LIT>',"}
{"input":"<s> export default function () {<EOL>    return Promise.resolve()<EOL>        .then(() => writeMultipleFiles({<EOL>        '<STR_LIT>': '<STR_LIT>',<EOL>         '<STR_LIT>': '<STR_LIT>',<EOL>        '<STR_LIT>': '<STR_LIT>',<EOL>         '<STR_LIT>': '<STR_LIT>',<EOL>        '<STR_LIT>':","gt":"'<STR_LIT>'"}
{"input":"<s> export default function () {<EOL>    return Promise.resolve()<EOL>        .then(() => writeMultipleFiles({<EOL>        '<STR_LIT>': '<STR_LIT>',<EOL>         '<STR_LIT>': '<STR_LIT>',<EOL>        '<STR_LIT>': '<STR_LIT>',<EOL>         '<STR_LIT>': '<STR_LIT>',<EOL>        '<STR_LIT>':  '<STR_LIT>'<EOL>    }))<EOL>        .then(() => updateJsonFile('<STR_LIT>', (configJson) => {<EOL>        const app = configJson['<STR_LIT>'][<NUM_LIT>];<EOL>        app['<STR_LIT>'] = [<EOL>            '<STR_LIT>',<EOL>            { input: '<STR_LIT>' },<EOL>            {","gt":"input: '<STR_LIT>', lazy: true },"}
{"input":"<s> export default function () {<EOL>    return Promise.resolve()<EOL>        .then(() => writeMultipleFiles({<EOL>        '<STR_LIT>': '<STR_LIT>',<EOL>         '<STR_LIT>': '<STR_LIT>',<EOL>        '<STR_LIT>': '<STR_LIT>',<EOL>         '<STR_LIT>': '<STR_LIT>',<EOL>        '<STR_LIT>':  '<STR_LIT>'<EOL>    }))<EOL>        .then(() => updateJsonFile('<STR_LIT>', (configJson) => {<EOL>        const app = configJson['<STR_LIT>'][<NUM_LIT>];<EOL>        app['<STR_LIT>'] = [<EOL>            '<STR_LIT>',<EOL>            { input: '<STR_LIT>' },<EOL>            {  input: '<STR_LIT>', lazy: true },<EOL>            { input: '<STR_LIT>', output: '<STR_LIT>' },<EOL>            { input: '<STR_LIT>', output: '<STR_LIT>', lazy: true }<EOL>        ];<EOL>    }))<EOL>        .then(() => ng('<STR_LIT>', '<STR_LIT>'))<EOL>        <EOL>        .then(() => expectFileToMatch('<STR_LIT>', '<STR_LIT>'))<EOL>        .then(() => expectFileToMatch('<STR_LIT>', '<STR_LIT>'))<EOL>        .then(() => expectFileToMatch('<STR_LIT>', '<STR_LIT>'))<EOL>        .then(() => expectFileToMatch(","gt":"'<STR_LIT>', '<STR_LIT>'))"}
{"input":"<s> export default function () {<EOL>    return Promise.resolve()<EOL>        .then(() => writeMultipleFiles({<EOL>        '<STR_LIT>': '<STR_LIT>',<EOL>         '<STR_LIT>': '<STR_LIT>',<EOL>        '<STR_LIT>': '<STR_LIT>',<EOL>         '<STR_LIT>': '<STR_LIT>',<EOL>        '<STR_LIT>':  '<STR_LIT>'<EOL>    }))<EOL>        .then(() => updateJsonFile('<STR_LIT>', (configJson) => {<EOL>        const app = configJson['<STR_LIT>'][<NUM_LIT>];<EOL>        app['<STR_LIT>'] = [<EOL>            '<STR_LIT>',<EOL>            { input: '<STR_LIT>' },<EOL>            {  input: '<STR_LIT>', lazy: true },<EOL>            { input: '<STR_LIT>', output: '<STR_LIT>' },<EOL>            { input: '<STR_LIT>', output: '<STR_LIT>', lazy: true }<EOL>        ];<EOL>    }))<EOL>        .then(() => ng('<STR_LIT>', '<STR_LIT>'))<EOL>        <EOL>        .then(() => expectFileToMatch('<STR_LIT>', '<STR_LIT>'))<EOL>        .then(() => expectFileToMatch('<STR_LIT>', '<STR_LIT>'))<EOL>        .then(() => expectFileToMatch('<STR_LIT>', '<STR_LIT>'))<EOL>        .then(() => expectFileToMatch( '<STR_LIT>', '<STR_LIT>'))<EOL>        .then(() => expectFileToMatch('<STR_LIT>', '<STR_LIT>'))<EOL>        <EOL>        .then(() => expectToFail(() => expectFileToExist('<STR_LIT>')))<EOL>        .then(() => expectToFail(() => expectFileToExist('<STR_LIT>')))<EOL>        .then(() => expectToFail(() => expectFileToExist('<STR_LIT>')))<EOL>        .then(() => expectToFail(() => expectFileToExist('<STR_LIT>')))<EOL>        <EOL>        .then(() => expectFileToMatch('<STR_LIT>', new RegExp(oneLineTrim `<STR_LIT>`)))<EOL>        .then(() =>","gt":"expectFileToMatch('<STR_LIT>', oneLineTrim `<STR_LIT>`"}
{"input":"<s> export default function () {<EOL>    return Promise.resolve()<EOL>        .then(() => silentNg(","gt":"'<STR_LIT>'))"}
{"input":"<s> export default function () {<EOL>    return Promise.resolve()<EOL>        .then(() => createProject(","gt":"'<STR_LIT>', '<STR_LIT>'))"}
{"input":"<s> export default function () {<EOL>    const directiveDir = join('<STR_LIT>', '<STR_LIT>');<EOL>    return Promise.resolve()<EOL>        .then(() => updateJsonFile('<STR_LIT>', (configJson) => {<EOL>        const app = configJson['<STR_LIT>'][","gt":"<NUM_LIT>];"}
{"input":"<s> export default function () {<EOL>    const directiveDir = join('<STR_LIT>', '<STR_LIT>');<EOL>    return Promise.resolve()<EOL>        .then(() => updateJsonFile('<STR_LIT>', (configJson) => {<EOL>        const app = configJson['<STR_LIT>'][ <NUM_LIT>];<EOL>        app['<STR_LIT>'] = '<STR_LIT>';<EOL>    }))<EOL>        .then(() => ng('<STR_LIT>', '<STR_LIT>', '<STR_LIT>'))<EOL>        .then(() => expectFileToMatch(join(","gt":"directiveDir, '<STR_LIT>'), /selector: '\\[pre/))"}
{"input":"<s> export default function () {<EOL>    const root = process.cwd();<EOL>    const testPath = join(root, '<STR_LIT>', '<STR_LIT>');<EOL>    process.chdir(testPath);<EOL>    fs.","gt":"mkdirSync('<STR_LIT>');"}
{"input":"<s> export default function () {<EOL>    const root = process.cwd();<EOL>    const testPath = join(root, '<STR_LIT>', '<STR_LIT>');<EOL>    process.chdir(testPath);<EOL>    fs. mkdirSync('<STR_LIT>');<EOL>    return Promise.resolve()<EOL>        .then(() => ng('<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>')<EOL>        .then(() => expectFileToExist(join(testPath, '<STR_LIT>')))<EOL>        .then(() => expectFileToExist(join(testPath, '<STR_LIT>', '<STR_LIT>')))<EOL>        .then(() => expectFileToExist(join(testPath, '<STR_LIT>', '<STR_LIT>')))<EOL>        .then(() => expectToFail(() => expectFileToExist(join(testPath,","gt":"'<STR_LIT>', '<STR_LIT>'))))"}
{"input":"<s> export function appendToFile(filePath, text, options) {<EOL>    return","gt":"readFile(filePath)"}
{"input":"<s> export function symlinkFile(from, to, type) {<EOL>    return new Promise((resolve, reject) => {<EOL>        fs.symlink(from, to, type, (err) => {<EOL>            if (err) {<EOL>                reject(","gt":"err);"}
{"input":"<s> export function teardown(path) {<EOL>    process.chdir(root);<EOL>    if (fs.pathExistsSync(path)) {<EOL>","gt":"return fs.remove(path);"}
{"input":"<s> export function initWebWorkerRenderPlatform() {<EOL>","gt":"BrowserDomAdapter.makeCurrent();"}
{"input":"<s> export function getStartAtObservable(query) {<EOL>    if (query.startAt instanceof Observable) {<EOL>        return query.startAt;<EOL>    }<EOL>    else if (hasKey(","gt":"query, '<STR_LIT>')) {"}
{"input":"<s> export function getStartAtObservable(query) {<EOL>    if (query.startAt instanceof Observable) {<EOL>        return query.startAt;<EOL>    }<EOL>    else if (hasKey( query, '<STR_LIT>')) {<EOL>        return new Observable((subscriber) => {<EOL>            subscriber.next(query.startAt);<EOL>        });<EOL>    }<EOL>    else {<EOL>        return new","gt":"Observable((subscriber) => {"}
{"input":"<s> export function stripLeadingSlash(value) {<EOL>    <EOL>    if (value.substring(<NUM_LIT>, <NUM_LIT>) === '<STR_LIT>') {<EOL>        return","gt":"value.substring(<NUM_LIT>, value.length);"}
{"input":"<s> export function stripTrailingSlash(value) {<EOL>    <EOL>    if (value.substring(value.length - <NUM_LIT>, value.length) === '<STR_LIT>') {<EOL>        return value.substring(<NUM_LIT>, value.","gt":"length - <NUM_LIT>);"}
{"input":"<s> function positionAfter(changes, prevKey) {<EOL>    if (isNil(prevKey)) {<EOL>        return <NUM_LIT>;<EOL>    }<EOL>","gt":"else {"}
{"input":"<s> function positionAfter(changes, prevKey) {<EOL>    if (isNil(prevKey)) {<EOL>        return <NUM_LIT>;<EOL>    }<EOL>     else {<EOL>        const i = positionFor(changes, prevKey);<EOL>        if (i === -<NUM_LIT>) {<EOL>            return changes.length;<EOL>        }<EOL>        else {<EOL>            return i +","gt":"<NUM_LIT>;"}
{"input":"<s> <EOL>export function associateQuery(collectionRef, queryFn = (ref) => ref) {<EOL>","gt":"const query = queryFn(collectionRef);"}
{"input":"<s> export function _getAngularFireStorage(app) {<EOL>    return new AngularFireStorage(","gt":"app);"}
{"input":"<s> function init() {<EOL>    const rootEl = document.querySelector('<STR_LIT>');<EOL>    rootEl.textContent = '<STR_LIT>';<EOL>    table =","gt":"new TableComponent(rootEl);"}
{"input":"<s> function _buildTree(currDepth, valueFn) {<EOL>","gt":"const children = currDepth < maxDepth ? _buildTree(currDepth + <NUM_LIT>, valueFn) : null;"}
{"input":"<s> function getComponentText(selector, innerSelector) {<EOL>    return","gt":"browser.executeScript(`<STR_LIT>`);"}
{"input":"<s> export function main() {<EOL>    bootstrapWorkerUi(","gt":"'<STR_LIT>').then(afterBootstrap);"}
{"input":"<s> export function main() {<EOL>    platformBrowserDynamic().","gt":"bootstrapModule(ExampleModule);"}
{"input":"<s> function normalizeParams(obj) {<EOL>    return obj ? copyObj(","gt":"obj) : null;"}
{"input":"<s> function countChars(value, char) {<EOL>    let count = <NUM_LIT>;<EOL>    for (let i = <NUM_LIT>; i < value.length; i++) {<EOL>        const c = value.charAt(","gt":"i);"}
{"input":"<s> export function listenOnPlayer(player, eventName, event, callback) {<EOL>    switch (eventName) {<EOL>        case '<STR_LIT>':<EOL>            player.onStart(() => callback(event && copyAnimationEvent(event, '<STR_LIT>', player)));<EOL>","gt":"break;"}
{"input":"<s> export function listenOnPlayer(player, eventName, event, callback) {<EOL>    switch (eventName) {<EOL>        case '<STR_LIT>':<EOL>            player.onStart(() => callback(event && copyAnimationEvent(event, '<STR_LIT>', player)));<EOL>             break;<EOL>        case '<STR_LIT>':<EOL>            player.onDone(() => callback(event && copyAnimationEvent(event, '<STR_LIT>', player)));<EOL>            break;<EOL>        case '<STR_LIT>':<EOL>            player.onDestroy(() => callback(event && copyAnimationEvent(event,","gt":"'<STR_LIT>', player)));"}
{"input":"<s> function _flattenGroupPlayersRecur(players, finalPlayers) {<EOL>    for (let i = <NUM_LIT>; i < players.length; i++) {<EOL>        const player = players[i];<EOL>","gt":"if (player instanceof AnimationGroupPlayer) {"}
{"input":"<s> function listen(element, engine, eventName, phaseName, callback, id = DEFAULT_NAMESPACE_ID) {<EOL>    return engine.","gt":"listen(id, element, eventName, phaseName, callback);"}
{"input":"<s> function mv(runIndex, time, values) {<EOL>    return new MeasureValues(runIndex, new Date(time),","gt":"values);"}
{"input":"<s> function padNumber(num, digits, minusSign = '<STR_LIT>', trim, negWrap) {<EOL>    let neg = '<STR_LIT>';<EOL>    if (num < <NUM_LIT> || (negWrap && num <= <NUM_LIT>)) {<EOL>        if (negWrap) {<EOL>            num = -num + <NUM_LIT>;<EOL>        }<EOL>","gt":"else {"}
{"input":"<s> function datePartGetterFactory(ret) {<EOL>    return (date, locale) => intlDateFormat(date, locale,","gt":"ret);"}
{"input":"<s> function formatNumber(pipe, locale, value, style, digits, currency = null, currencyAsSymbol = false) {<EOL>    if (value == null)<EOL>        return null;<EOL>    <EOL>    value = typeof value === '<STR_LIT>' && !isNaN(+value -","gt":"parseFloat(value)) ? +value : value;"}
{"input":"<s> function formatNumber(pipe, locale, value, style, digits, currency = null, currencyAsSymbol = false) {<EOL>    if (value == null)<EOL>        return null;<EOL>    <EOL>    value = typeof value === '<STR_LIT>' && !isNaN(+value -  parseFloat(value)) ? +value : value;<EOL>    if (","gt":"typeof value !== '<STR_LIT>') {"}
{"input":"<s> function formatNumber(pipe, locale, value, style, digits, currency = null, currencyAsSymbol = false) {<EOL>    if (value == null)<EOL>        return null;<EOL>    <EOL>    value = typeof value === '<STR_LIT>' && !isNaN(+value -  parseFloat(value)) ? +value : value;<EOL>    if ( typeof value !== '<STR_LIT>') {<EOL>        throw invalidPipeArgumentError(pipe, value);<EOL>    }<EOL>    let minInt;<EOL>    let minFraction;<EOL>    let maxFraction;<EOL>    if (style !== NumberFormatStyle.Currency) {<EOL>        <EOL>        minInt = <NUM_LIT>;<EOL>        minFraction = <NUM_LIT>;<EOL>        maxFraction = <NUM_LIT>;<EOL>    }<EOL>    if (digits) {<EOL>        const parts = digits.match(NUMBER_FORMAT_REGEXP);<EOL>        if (parts === null) {<EOL>            throw new Error(`<STR_LIT>`);<EOL>        }<EOL>        if (parts[<NUM_LIT>] != null) { <EOL>            minInt = parseIntAutoRadix(parts[<NUM_LIT>]);<EOL>        }<EOL>        if (parts[<NUM_LIT>] != null) { <EOL>            minFraction = parseIntAutoRadix(parts[<NUM_LIT>]);<EOL>        }<EOL>        if (parts[<NUM_LIT>] != null) { <EOL>","gt":"maxFraction = parseIntAutoRadix(parts[<NUM_LIT>]);"}
{"input":"<s> function createTestComponent(template) {<EOL>    return TestBed.","gt":"overrideComponent(TestComponent, { set: { template: template } })"}
{"input":"<s> export function getExpressionDiagnostics(scope, ast, query, context = {}) {<EOL>    const analyzer = new","gt":"AstType(scope, query, context);"}
{"input":"<s> function expandedMessage(error) {<EOL>    switch (error.message) {<EOL>        case '<STR_LIT>':<EOL>            if (error.context && error.context.className) {<EOL>                return `<STR_LIT>`;<EOL>            }<EOL>            break;<EOL>        case '<STR_LIT>':<EOL>","gt":"return '<STR_LIT>';"}
{"input":"<s> function expandedMessage(error) {<EOL>    switch (error.message) {<EOL>        case '<STR_LIT>':<EOL>            if (error.context && error.context.className) {<EOL>                return `<STR_LIT>`;<EOL>            }<EOL>            break;<EOL>        case '<STR_LIT>':<EOL>             return '<STR_LIT>';<EOL>        case '<STR_LIT>':<EOL>            return '<STR_LIT>';<EOL>        case","gt":"'<STR_LIT>':"}
{"input":"<s> function expandedMessage(error) {<EOL>    switch (error.message) {<EOL>        case '<STR_LIT>':<EOL>            if (error.context && error.context.className) {<EOL>                return `<STR_LIT>`;<EOL>            }<EOL>            break;<EOL>        case '<STR_LIT>':<EOL>             return '<STR_LIT>';<EOL>        case '<STR_LIT>':<EOL>            return '<STR_LIT>';<EOL>        case  '<STR_LIT>':<EOL>            if (error.context && error.context.typeName) {<EOL>                return `<STR_LIT>`;<EOL>            }<EOL>            break;<EOL>        case '<STR_LIT>':<EOL>            let prefix = error.context && error.context.name ? `<STR_LIT>` : '<STR_LIT>';<EOL>            return prefix +<EOL>","gt":"'<STR_LIT>';"}
{"input":"<s> function populateBuiltins(symbols) {<EOL>    <EOL>    ['<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>',<EOL>        '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>',","gt":"'<STR_LIT>',"}
{"input":"<s> function dotRelative(from, to) {<EOL>    const rPath =","gt":"path.relative(from, to).replace(/\\\\/g, '<STR_LIT>');"}
{"input":"<s> function calcRootPath() {<EOL>    const moduleFilename =","gt":"module.filename.replace(/\\\\/g, '<STR_LIT>');"}
{"input":"<s> export function isFormattedError(error) {<EOL>    return !!error[","gt":"FORMATTED_MESSAGE];"}
{"input":"<s> export function deserializeSummaries(symbolCache, summaryResolver, libraryFileName, json) {<EOL>    const deserializer =","gt":"new FromJsonDeserializer(symbolCache, summaryResolver);"}
{"input":"<s> export function ngfactoryFilePath(filePath, forceSourceFile = false) {<EOL>","gt":"const urlWithSuffix = splitTypescriptSuffix(filePath, forceSourceFile);"}
{"input":"<s> function invalid(arg) {<EOL>    throw new Error(","gt":"constructor.name} doesn'<STR_LIT>;"}
{"input":"<s> function byteStringToHexString(str) {<EOL>    let hex = '<STR_LIT>';<EOL>    for (let","gt":"i = <NUM_LIT>; i < str.length; i++) {"}
{"input":"<s> <EOL>export function fingerprint(str) {<EOL>    const utf8 = utf8Encode(str);<EOL>    let [hi, lo] = [hash32(utf8, <NUM_LIT>), hash32(utf8, <NUM_LIT>)];<EOL>    if (hi == <NUM_LIT> && (lo ==","gt":"<NUM_LIT> || lo == <NUM_LIT>)) {"}
{"input":"<s> function _isOpeningComment(n) {<EOL>    return !!(n instanceof html.Comment && n.value && n.","gt":"value.startsWith('<STR_LIT>'));"}
{"input":"<s> function spanOf(ast) {<EOL>    const start = ast.sourceSpan.start.offset;<EOL>    let end = ast.sourceSpan.end.offset;<EOL>    if (ast instanceof Element) {<EOL>        if (","gt":"ast.endSourceSpan) {"}
{"input":"<s> function toUpperCaseCharCode(code) {<EOL>    return code >= chars.$a && code <= chars.","gt":"$z ? code - chars.$a + chars.$A : code;"}
{"input":"<s> function _resolveProvidersFromDirectives(directives, sourceSpan, targetErrors) {<EOL>    const providersByToken = new Map();<EOL>    directives.forEach((directive) => {<EOL>        const dirProvider = { token: { identifier: directive.type }, useClass: directive.type };<EOL>        _resolveProviders([dirProvider], directive.isComponent ?","gt":"ProviderAstType.Component : ProviderAstType.Directive, true, sourceSpan, targetErrors, providersByToken,  false);"}
{"input":"<s> function _resolveProvidersFromDirectives(directives, sourceSpan, targetErrors) {<EOL>    const providersByToken = new Map();<EOL>    directives.forEach((directive) => {<EOL>        const dirProvider = { token: { identifier: directive.type }, useClass: directive.type };<EOL>        _resolveProviders([dirProvider], directive.isComponent ?  ProviderAstType.Component : ProviderAstType.Directive, true, sourceSpan, targetErrors, providersByToken, false);<EOL>    });<EOL>    <EOL>    const directivesWithComponentFirst = directives.filter((dir) => dir.isComponent).concat(directives.filter((dir) => !dir.isComponent));<EOL>    directivesWithComponentFirst.forEach((directive) => {<EOL>        _resolveProviders(directive.providers, ProviderAstType.PublicService, false, sourceSpan, targetErrors, providersByToken, false);<EOL>        _resolveProviders(directive.viewProviders, ProviderAstType.PrivateService, false, sourceSpan, targetErrors, providersByToken,","gt":"false);"}
{"input":"<s> export function processRules(input, ruleCallback) {<EOL>    const inputWithEscapedBlocks = escapeBlocks(input);<EOL>    let nextBlockIndex = <NUM_LIT>;<EOL>    return inputWithEscapedBlocks.escapedString.replace(_ruleRe, function (...m) {<EOL>        const selector = m[<NUM_LIT>];<EOL>        let content =","gt":"'<STR_LIT>';"}
{"input":"<s> export function processRules(input, ruleCallback) {<EOL>    const inputWithEscapedBlocks = escapeBlocks(input);<EOL>    let nextBlockIndex = <NUM_LIT>;<EOL>    return inputWithEscapedBlocks.escapedString.replace(_ruleRe, function (...m) {<EOL>        const selector = m[<NUM_LIT>];<EOL>        let content =  '<STR_LIT>';<EOL>        let suffix = m[<NUM_LIT>];<EOL>        let contentPrefix = '<STR_LIT>';<EOL>        if (suffix && suffix.startsWith('<STR_LIT>' + BLOCK_PLACEHOLDER)) {<EOL>            content = inputWithEscapedBlocks.","gt":"blocks[nextBlockIndex++];"}
{"input":"<s> function _isAnimationLabel(name) {<EOL>","gt":"return name[<NUM_LIT>] == '<STR_LIT>';"}
{"input":"<s> <EOL>function splitExportAs(exportAs) {<EOL>    return exportAs ? exportAs.split(","gt":"'<STR_LIT>').map((e) => e.trim()) : [];"}
{"input":"<s> <EOL>function _joinAndCanonicalizePath(parts) {<EOL>    let path = parts[_ComponentIndex.Path];<EOL>    path = path == null ? '<STR_LIT>' : _removeDotSegments(","gt":"path);"}
{"input":"<s> function extractProperties(type, instance, visited, descMap, name, superName) {<EOL>    if (!type)<EOL>        return;<EOL>    visited[name] = true;<EOL>    const fullName = name + (superName ? '<STR_LIT>' + superName : '<STR_LIT>');<EOL>    const props = descMap.has(fullName) ? descMap.get(","gt":"fullName) : [];"}
{"input":"<s> function extractProperties(type, instance, visited, descMap, name, superName) {<EOL>    if (!type)<EOL>        return;<EOL>    visited[name] = true;<EOL>    const fullName = name + (superName ? '<STR_LIT>' + superName : '<STR_LIT>');<EOL>    const props = descMap.has(fullName) ? descMap.get( fullName) : [];<EOL>    const prototype = type.prototype;<EOL>    const keys = Object.getOwnPropertyNames(prototype);<EOL>","gt":"keys.sort();"}
{"input":"<s> function extractProperties(type, instance, visited, descMap, name, superName) {<EOL>    if (!type)<EOL>        return;<EOL>    visited[name] = true;<EOL>    const fullName = name + (superName ? '<STR_LIT>' + superName : '<STR_LIT>');<EOL>    const props = descMap.has(fullName) ? descMap.get( fullName) : [];<EOL>    const prototype = type.prototype;<EOL>    const keys = Object.getOwnPropertyNames(prototype);<EOL>     keys.sort();<EOL>    keys.forEach((name) => {<EOL>        if (name.startsWith('<STR_LIT>')) {<EOL>            props.push('<STR_LIT>' + name.substr(<NUM_LIT>));<EOL>        }<EOL>","gt":"else {"}
{"input":"<s> function extractProperties(type, instance, visited, descMap, name, superName) {<EOL>    if (!type)<EOL>        return;<EOL>    visited[name] = true;<EOL>    const fullName = name + (superName ? '<STR_LIT>' + superName : '<STR_LIT>');<EOL>    const props = descMap.has(fullName) ? descMap.get( fullName) : [];<EOL>    const prototype = type.prototype;<EOL>    const keys = Object.getOwnPropertyNames(prototype);<EOL>     keys.sort();<EOL>    keys.forEach((name) => {<EOL>        if (name.startsWith('<STR_LIT>')) {<EOL>            props.push('<STR_LIT>' + name.substr(<NUM_LIT>));<EOL>        }<EOL>         else {<EOL>            const typeCh = _TYPE_MNEMONICS[typeof instance[name]];<EOL>            const descriptor = Object.getOwnPropertyDescriptor(prototype, name);<EOL>            const isSetter = descriptor && descriptor.set;<EOL>            if (typeCh !== void <NUM_LIT> && !name.startsWith('<STR_LIT>') && isSetter) {<EOL>                props.","gt":"push(typeCh + name);"}
{"input":"<s> function humanizeContentProjection(templateAsts) {<EOL>    const humanizer =","gt":"new TemplateContentProjectionHumanizer();"}
{"input":"<s> <EOL>export function keyframes(steps) {<EOL>    return","gt":"_keyframes(steps);"}
{"input":"<s> <EOL>export function sequence(steps) {<EOL>    return _sequence(","gt":"steps);"}
{"input":"<s> export function isDefaultChangeDetectionStrategy(changeDetectionStrategy) {<EOL>    return","gt":"changeDetectionStrategy == null ||"}
{"input":"<s> export function removeDebugNodeFromIndex(node) {<EOL>","gt":"_nativeNodeToDebugNode.delete(node.nativeNode);"}
{"input":"<s> <EOL>export function resolveForwardRef(type) {<EOL>    if (typeof type === '<STR_LIT>' && type.hasOwnProperty('<STR_LIT>') &&<EOL>        type.__forward_ref__ === forwardRef) {<EOL>","gt":"return type();"}
{"input":"<s> function resolveToken(token, record, records, parent, notFoundValue, flags) {<EOL>    let value;<EOL>    if (record && !(flags & InjectFlags.SkipSelf)) {<EOL>        <EOL>        <EOL>        value = record.","gt":"value;"}
{"input":"<s> function resolveToken(token, record, records, parent, notFoundValue, flags) {<EOL>    let value;<EOL>    if (record && !(flags & InjectFlags.SkipSelf)) {<EOL>        <EOL>        <EOL>        value = record. value;<EOL>        if (value == CIRCULAR) {<EOL>            throw Error(NO_NEW_LINE + '<STR_LIT>');<EOL>        }<EOL>        else if (value === EMPTY) {<EOL>            record.value = CIRCULAR;<EOL>            let obj = undefined;<EOL>            let useNew = record.useNew;<EOL>            let fn = record.","gt":"fn;"}
{"input":"<s> function resolveToken(token, record, records, parent, notFoundValue, flags) {<EOL>    let value;<EOL>    if (record && !(flags & InjectFlags.SkipSelf)) {<EOL>        <EOL>        <EOL>        value = record. value;<EOL>        if (value == CIRCULAR) {<EOL>            throw Error(NO_NEW_LINE + '<STR_LIT>');<EOL>        }<EOL>        else if (value === EMPTY) {<EOL>            record.value = CIRCULAR;<EOL>            let obj = undefined;<EOL>            let useNew = record.useNew;<EOL>            let fn = record. fn;<EOL>            let depRecords = record.deps;<EOL>            let deps = EMPTY;<EOL>            if (depRecords.length) {<EOL>","gt":"deps = [];"}
{"input":"<s> function resolveToken(token, record, records, parent, notFoundValue, flags) {<EOL>    let value;<EOL>    if (record && !(flags & InjectFlags.SkipSelf)) {<EOL>        <EOL>        <EOL>        value = record. value;<EOL>        if (value == CIRCULAR) {<EOL>            throw Error(NO_NEW_LINE + '<STR_LIT>');<EOL>        }<EOL>        else if (value === EMPTY) {<EOL>            record.value = CIRCULAR;<EOL>            let obj = undefined;<EOL>            let useNew = record.useNew;<EOL>            let fn = record. fn;<EOL>            let depRecords = record.deps;<EOL>            let deps = EMPTY;<EOL>            if (depRecords.length) {<EOL>                 deps = [];<EOL>                for (let i = <NUM_LIT>; i < depRecords.length; i++) {<EOL>                    const depRecord = depRecords[i];<EOL>                    const options = depRecord.options;<EOL>                    const childRecord = options & OptionFlags.CheckSelf ? records.get(depRecord.token) : undefined;<EOL>","gt":"deps.push(tryResolveToken("}
{"input":"<s> <EOL>export function outOfBoundsError(index) {<EOL>    return","gt":"Error(`<STR_LIT>`);"}
{"input":"<s> function _normalizeProviders(providers, res) {<EOL>    providers.forEach((b) => {<EOL>        if (b instanceof Type) {<EOL>            res.push({ provide: b, useClass: b });<EOL>        }<EOL>        else if (b && typeof b == '<STR_LIT>' &&","gt":"b.provide !== undefined) {"}
{"input":"<s> function _normalizeProviders(providers, res) {<EOL>    providers.forEach((b) => {<EOL>        if (b instanceof Type) {<EOL>            res.push({ provide: b, useClass: b });<EOL>        }<EOL>        else if (b && typeof b == '<STR_LIT>' &&  b.provide !== undefined) {<EOL>            res.push(b);<EOL>        }<EOL>        else if (b instanceof Array) {<EOL>","gt":"_normalizeProviders(b, res);"}
{"input":"<s> function _normalizeProviders(providers, res) {<EOL>    providers.forEach((b) => {<EOL>        if (b instanceof Type) {<EOL>            res.push({ provide: b, useClass: b });<EOL>        }<EOL>        else if (b && typeof b == '<STR_LIT>' &&  b.provide !== undefined) {<EOL>            res.push(b);<EOL>        }<EOL>        else if (b instanceof Array) {<EOL>             _normalizeProviders(b, res);<EOL>        }<EOL>        else {<EOL>            throw","gt":"invalidProviderError(b);"}
{"input":"<s> export function wrappedError(message, originalError) {<EOL>    const msg = `<STR_LIT>`;<EOL>    const","gt":"error = Error(msg);"}
{"input":"<s> <EOL>export function getHostElement(component) {<EOL>    return","gt":"_getComponentHostLElementNode(component).native;"}
{"input":"<s> function assertDataInRange(index, arr) {<EOL>","gt":"if (arr == null)"}
{"input":"<s> function setUpAttributes(native, attrs) {<EOL>    ngDevMode && assertEqual(attrs.length % <NUM_LIT>, <NUM_LIT>, '<STR_LIT>');<EOL>    const isProc =","gt":"isProceduralRenderer(renderer);"}
{"input":"<s> function setElementClass(view, renderNode, name, value) {<EOL>    const renderer = view.renderer;<EOL>    if (value) {<EOL>        renderer.","gt":"addClass(renderNode, name);"}
{"input":"<s> export function expressionChangedAfterItHasBeenCheckedError(context, oldValue, currValue, isFirstCheck) {<EOL>    let msg = `<STR_LIT>`;<EOL>    if (isFirstCheck) {<EOL>","gt":"msg +="}
{"input":"<s> function updateProp(view, providerData, def, bindingIdx, value, changes) {<EOL>    if (def.flags & NodeFlags.Component) {<EOL>        const compView = asElementData(view, def.parent.nodeIndex).componentView;<EOL>        if (compView.def.flags & ViewFlags.OnPush) {<EOL>","gt":"compView.state |= ViewState.ChecksEnabled;"}
{"input":"<s> function updateProp(view, providerData, def, bindingIdx, value, changes) {<EOL>    if (def.flags & NodeFlags.Component) {<EOL>        const compView = asElementData(view, def.parent.nodeIndex).componentView;<EOL>        if (compView.def.flags & ViewFlags.OnPush) {<EOL>             compView.state |= ViewState.ChecksEnabled;<EOL>        }<EOL>    }<EOL>    const binding = def.bindings[","gt":"bindingIdx];"}
{"input":"<s> function updateProp(view, providerData, def, bindingIdx, value, changes) {<EOL>    if (def.flags & NodeFlags.Component) {<EOL>        const compView = asElementData(view, def.parent.nodeIndex).componentView;<EOL>        if (compView.def.flags & ViewFlags.OnPush) {<EOL>             compView.state |= ViewState.ChecksEnabled;<EOL>        }<EOL>    }<EOL>    const binding = def.bindings[ bindingIdx];<EOL>    const propName = binding.name;<EOL>    <EOL>    <EOL>    <EOL>    providerData.instance[","gt":"propName] = value;"}
{"input":"<s> function updateProp(view, providerData, def, bindingIdx, value, changes) {<EOL>    if (def.flags & NodeFlags.Component) {<EOL>        const compView = asElementData(view, def.parent.nodeIndex).componentView;<EOL>        if (compView.def.flags & ViewFlags.OnPush) {<EOL>             compView.state |= ViewState.ChecksEnabled;<EOL>        }<EOL>    }<EOL>    const binding = def.bindings[ bindingIdx];<EOL>    const propName = binding.name;<EOL>    <EOL>    <EOL>    <EOL>    providerData.instance[ propName] = value;<EOL>    if (def.flags & NodeFlags.OnChanges) {<EOL>        changes = changes || {};<EOL>        const oldValue = WrappedValue.unwrap(view.oldValues[def.bindingIndex + bindingIdx]);<EOL>","gt":"const binding = def.bindings[bindingIdx];"}
{"input":"<s> export function dirtyParentQueries(view) {<EOL>    const queryIds = view.def.nodeMatchedQueries;<EOL>    while (view.parent && isEmbeddedView(view)) {<EOL>        let","gt":"tplDef = view.parentNodeDef;"}
{"input":"<s> export function dirtyParentQueries(view) {<EOL>    const queryIds = view.def.nodeMatchedQueries;<EOL>    while (view.parent && isEmbeddedView(view)) {<EOL>        let  tplDef = view.parentNodeDef;<EOL>        view = view.parent;<EOL>        <EOL>        const end =","gt":"tplDef.nodeIndex + tplDef.childCount;"}
{"input":"<s> export function dirtyParentQueries(view) {<EOL>    const queryIds = view.def.nodeMatchedQueries;<EOL>    while (view.parent && isEmbeddedView(view)) {<EOL>        let  tplDef = view.parentNodeDef;<EOL>        view = view.parent;<EOL>        <EOL>        const end =  tplDef.nodeIndex + tplDef.childCount;<EOL>        for (let i = <NUM_LIT>; i <= end; i++) {<EOL>            const nodeDef = view.def.nodes[i];<EOL>            if ((nodeDef.flags & NodeFlags.TypeContentQuery) &&<EOL>                (nodeDef.flags & NodeFlags.","gt":"DynamicQuery) &&"}
{"input":"<s> export function dirtyParentQueries(view) {<EOL>    const queryIds = view.def.nodeMatchedQueries;<EOL>    while (view.parent && isEmbeddedView(view)) {<EOL>        let  tplDef = view.parentNodeDef;<EOL>        view = view.parent;<EOL>        <EOL>        const end =  tplDef.nodeIndex + tplDef.childCount;<EOL>        for (let i = <NUM_LIT>; i <= end; i++) {<EOL>            const nodeDef = view.def.nodes[i];<EOL>            if ((nodeDef.flags & NodeFlags.TypeContentQuery) &&<EOL>                (nodeDef.flags & NodeFlags. DynamicQuery) &&<EOL>                (nodeDef.query.filterId & queryIds) === nodeDef.query.filterId) {<EOL>                asQueryList(view, i).setDirty();<EOL>            }<EOL>            if ((nodeDef.flags & NodeFlags.TypeElement && i + nodeDef.","gt":"childCount < tplDef.nodeIndex) ||"}
{"input":"<s> export function dirtyParentQueries(view) {<EOL>    const queryIds = view.def.nodeMatchedQueries;<EOL>    while (view.parent && isEmbeddedView(view)) {<EOL>        let  tplDef = view.parentNodeDef;<EOL>        view = view.parent;<EOL>        <EOL>        const end =  tplDef.nodeIndex + tplDef.childCount;<EOL>        for (let i = <NUM_LIT>; i <= end; i++) {<EOL>            const nodeDef = view.def.nodes[i];<EOL>            if ((nodeDef.flags & NodeFlags.TypeContentQuery) &&<EOL>                (nodeDef.flags & NodeFlags. DynamicQuery) &&<EOL>                (nodeDef.query.filterId & queryIds) === nodeDef.query.filterId) {<EOL>                asQueryList(view, i).setDirty();<EOL>            }<EOL>            if ((nodeDef.flags & NodeFlags.TypeElement && i + nodeDef. childCount < tplDef.nodeIndex) ||<EOL>                !(nodeDef.childFlags & NodeFlags.TypeContentQuery) ||<EOL>                !(nodeDef.childFlags & NodeFlags.DynamicQuery)) {<EOL>                <EOL>                i +=","gt":"nodeDef.childCount;"}
{"input":"<s> export function dirtyParentQueries(view) {<EOL>    const queryIds = view.def.nodeMatchedQueries;<EOL>    while (view.parent && isEmbeddedView(view)) {<EOL>        let  tplDef = view.parentNodeDef;<EOL>        view = view.parent;<EOL>        <EOL>        const end =  tplDef.nodeIndex + tplDef.childCount;<EOL>        for (let i = <NUM_LIT>; i <= end; i++) {<EOL>            const nodeDef = view.def.nodes[i];<EOL>            if ((nodeDef.flags & NodeFlags.TypeContentQuery) &&<EOL>                (nodeDef.flags & NodeFlags. DynamicQuery) &&<EOL>                (nodeDef.query.filterId & queryIds) === nodeDef.query.filterId) {<EOL>                asQueryList(view, i).setDirty();<EOL>            }<EOL>            if ((nodeDef.flags & NodeFlags.TypeElement && i + nodeDef. childCount < tplDef.nodeIndex) ||<EOL>                !(nodeDef.childFlags & NodeFlags.TypeContentQuery) ||<EOL>                !(nodeDef.childFlags & NodeFlags.DynamicQuery)) {<EOL>                <EOL>                i +=  nodeDef.childCount;<EOL>            }<EOL>        }<EOL>    }<EOL>    <EOL>    if (view.def.nodeFlags & NodeFlags.TypeViewQuery) {<EOL>        for (let i = <NUM_LIT>; i < view.def.nodes.length; i++) {<EOL>            const nodeDef =","gt":"view.def.nodes[i];"}
{"input":"<s> function debugDestroyView(view) {<EOL>    return callWithDebugContext(DebugAction.destroy, destroyView, null, [","gt":"view]);"}
{"input":"<s> function _addInterpolationPart(value, binding) {<EOL>    const","gt":"valueStr = value != null ? value.toString() : '<STR_LIT>';"}
{"input":"<s> function execRenderNodeAction(view, renderNode, action, parentNode, nextSibling, target) {<EOL>    const renderer = view.renderer;<EOL>    switch (action) {<EOL>        case RenderNodeAction.AppendChild:<EOL>            renderer.appendChild(parentNode, renderNode);<EOL>","gt":"break;"}
{"input":"<s> function execRenderNodeAction(view, renderNode, action, parentNode, nextSibling, target) {<EOL>    const renderer = view.renderer;<EOL>    switch (action) {<EOL>        case RenderNodeAction.AppendChild:<EOL>            renderer.appendChild(parentNode, renderNode);<EOL>             break;<EOL>        case RenderNodeAction.InsertBefore:<EOL>            renderer.insertBefore(parentNode, renderNode, nextSibling);<EOL>            break;<EOL>        case","gt":"RenderNodeAction.RemoveChild:"}
{"input":"<s> function execRenderNodeAction(view, renderNode, action, parentNode, nextSibling, target) {<EOL>    const renderer = view.renderer;<EOL>    switch (action) {<EOL>        case RenderNodeAction.AppendChild:<EOL>            renderer.appendChild(parentNode, renderNode);<EOL>             break;<EOL>        case RenderNodeAction.InsertBefore:<EOL>            renderer.insertBefore(parentNode, renderNode, nextSibling);<EOL>            break;<EOL>        case  RenderNodeAction.RemoveChild:<EOL>            renderer.removeChild(parentNode, renderNode);<EOL>            break;<EOL>","gt":"case RenderNodeAction.Collect:"}
{"input":"<s> function _toStringWithNull(v) {<EOL>    return v != null ? v.","gt":"toString() : '<STR_LIT>';"}
{"input":"<s> function approximate(value, target) {<EOL>","gt":"return Math.abs(target - value) / value;"}
{"input":"<s> function unimplemented() {<EOL>    throw Error(","gt":"'<STR_LIT>');"}
{"input":"<s> function _describe(jsmFn, ...args) {<EOL>    const parentRunner = runnerStack.length === <NUM_LIT> ? null : runnerStack[runnerStack.length - <NUM_LIT>];<EOL>    const","gt":"runner = new BeforeEachRunner(parentRunner);"}
{"input":"<s> function logOnStable() {<EOL>    _zone.","gt":"onStable.subscribe({ next: _log.fn('<STR_LIT>') });"}
{"input":"<s> function waitForElement(selector) {<EOL>    const EC =","gt":"ExpectedConditions;"}
{"input":"<s> function _buildValueString(id, value) {<EOL>    if (id == null)<EOL>        return `<STR_LIT>`;<EOL>    if (typeof","gt":"value === '<STR_LIT>')"}
{"input":"<s> function _getJsonpConnections() {<EOL>    const w = typeof window == '<STR_LIT>' ?","gt":"window : {};"}
{"input":"<s> export function removeSuffix(value, suffix) {<EOL>    if (","gt":"value.endsWith(suffix))"}
{"input":"<s> export function initDomAdapter() {<EOL>    BrowserDomAdapter.","gt":"makeCurrent();"}
{"input":"<s> function _ngProbeTokensToMap(tokens) {<EOL>    return tokens.reduce((prev, t) => (prev[t.name] =","gt":"t.token, prev), {});"}
{"input":"<s> export function httpFactory(xhrBackend, options) {<EOL>    const","gt":"macroBackend = new ZoneMacroTaskBackend(xhrBackend);"}
{"input":"<s> function notSupported(feature) {<EOL>","gt":"throw new Error(`<STR_LIT>`);"}
{"input":"<s> export function provideLocationStrategy(platformLocationStrategy, baseHref, options = {}) {<EOL>    return options.useHash ? new HashLocationStrategy(","gt":"platformLocationStrategy, baseHref) :"}
{"input":"<s> <EOL>export function last(a) {<EOL>    return a.length > <NUM_LIT> ? a[a.length - <NUM_LIT>] :","gt":"null;"}
{"input":"<s> function advance(fixture) {<EOL>","gt":"tick();"}
{"input":"<s> function createActivatedRoute(cmp) {<EOL>    return new ActivatedRoute(new BehaviorSubject([new UrlSegment('<STR_LIT>', {})]), new BehaviorSubject({}), null, null, new","gt":"BehaviorSubject({}), null, cmp, null);"}
{"input":"<s> export function directiveNormalize(name) {<EOL>    return name.replace(","gt":"DIRECTIVE_PREFIX_REGEXP, '<STR_LIT>')"}
{"input":"<s> <EOL>function supportsNgModel(component) {<EOL>    return","gt":"typeof component.writeValue === '<STR_LIT>' &&"}
{"input":"<s> export function setTempInjectorRef(injector) {<EOL>    tempInjectorRef =","gt":"injector;"}
{"input":"<s> <EOL>function identifierIsMetadata(id, metadata, checker) {<EOL>    const symbol = checker.getSymbolAtLocation(id);<EOL>    if (!symbol || !symbol.declarations || !symbol.declarations.length) {<EOL>","gt":"return false;"}
{"input":"<s> export function testWrapEnums(content) {<EOL>    const regexes = [<EOL>        <EOL>","gt":"/var (\\S+) = \\{\\};\\r?\\n(\\1\\.(\\S+) = \\d+;\\r?\\n)+\\1\\[\\1\\.(\\S+)\\] = \"\\4\";\\r?\\n(\\1\\[\\1\\.(\\S+)\\] = \"\\S+\";\\r?\\n*)+/,"}
{"input":"<s> <EOL>export function getTestConfig(wco) {<EOL>    const { projectRoot, buildOptions, appConfig } = wco;<EOL>    const nodeModules = path.resolve(projectRoot, '<STR_LIT>');<EOL>    const extraRules = [];<EOL>    const extraPlugins = [];<EOL>    <EOL>    if (buildOptions.codeCoverage) {<EOL>        <EOL>        const codeCoverageExclude = [];<EOL>        let exclude = [<EOL>","gt":"/\\.(e2e|spec)\\.ts$/,"}
{"input":"<s> <EOL>export function getTestConfig(wco) {<EOL>    const { projectRoot, buildOptions, appConfig } = wco;<EOL>    const nodeModules = path.resolve(projectRoot, '<STR_LIT>');<EOL>    const extraRules = [];<EOL>    const extraPlugins = [];<EOL>    <EOL>    if (buildOptions.codeCoverage) {<EOL>        <EOL>        const codeCoverageExclude = [];<EOL>        let exclude = [<EOL>             /\\.(e2e|spec)\\.ts$/,<EOL>","gt":"/node_modules/"}
{"input":"<s> <EOL>export function getTestConfig(wco) {<EOL>    const { projectRoot, buildOptions, appConfig } = wco;<EOL>    const nodeModules = path.resolve(projectRoot, '<STR_LIT>');<EOL>    const extraRules = [];<EOL>    const extraPlugins = [];<EOL>    <EOL>    if (buildOptions.codeCoverage) {<EOL>        <EOL>        const codeCoverageExclude = [];<EOL>        let exclude = [<EOL>             /\\.(e2e|spec)\\.ts$/,<EOL>             /node_modules/<EOL>        ];<EOL>        if (codeCoverageExclude) {<EOL>            codeCoverageExclude.forEach((excludeGlob) => {<EOL>                const excludeFiles = glob<EOL>                    .sync(path.join(projectRoot, excludeGlob), { nodir: true })<EOL>                    .map((file) => path.","gt":"normalize(file));"}
{"input":"<s> <EOL>export function getTestConfig(wco) {<EOL>    const { projectRoot, buildOptions, appConfig } = wco;<EOL>    const nodeModules = path.resolve(projectRoot, '<STR_LIT>');<EOL>    const extraRules = [];<EOL>    const extraPlugins = [];<EOL>    <EOL>    if (buildOptions.codeCoverage) {<EOL>        <EOL>        const codeCoverageExclude = [];<EOL>        let exclude = [<EOL>             /\\.(e2e|spec)\\.ts$/,<EOL>             /node_modules/<EOL>        ];<EOL>        if (codeCoverageExclude) {<EOL>            codeCoverageExclude.forEach((excludeGlob) => {<EOL>                const excludeFiles = glob<EOL>                    .sync(path.join(projectRoot, excludeGlob), { nodir: true })<EOL>                    .map((file) => path. normalize(file));<EOL>                exclude.push(...excludeFiles);<EOL>            });<EOL>        }<EOL>        extraRules.push({<EOL>            test: /\\.(js|ts)$/, loader:","gt":"'<STR_LIT>',"}
{"input":"<s> <EOL>export function getTestConfig(wco) {<EOL>    const { projectRoot, buildOptions, appConfig } = wco;<EOL>    const nodeModules = path.resolve(projectRoot, '<STR_LIT>');<EOL>    const extraRules = [];<EOL>    const extraPlugins = [];<EOL>    <EOL>    if (buildOptions.codeCoverage) {<EOL>        <EOL>        const codeCoverageExclude = [];<EOL>        let exclude = [<EOL>             /\\.(e2e|spec)\\.ts$/,<EOL>             /node_modules/<EOL>        ];<EOL>        if (codeCoverageExclude) {<EOL>            codeCoverageExclude.forEach((excludeGlob) => {<EOL>                const excludeFiles = glob<EOL>                    .sync(path.join(projectRoot, excludeGlob), { nodir: true })<EOL>                    .map((file) => path. normalize(file));<EOL>                exclude.push(...excludeFiles);<EOL>            });<EOL>        }<EOL>        extraRules.push({<EOL>            test: /\\.(js|ts)$/, loader:  '<STR_LIT>',<EOL>            options: { esModules: true },<EOL>            enforce: '<STR_LIT>',<EOL>            exclude<EOL>        });<EOL>    }<EOL>    return {<EOL>","gt":"resolve: {"}
{"input":"<s> <EOL>export function getTestConfig(wco) {<EOL>    const { projectRoot, buildOptions, appConfig } = wco;<EOL>    const nodeModules = path.resolve(projectRoot, '<STR_LIT>');<EOL>    const extraRules = [];<EOL>    const extraPlugins = [];<EOL>    <EOL>    if (buildOptions.codeCoverage) {<EOL>        <EOL>        const codeCoverageExclude = [];<EOL>        let exclude = [<EOL>             /\\.(e2e|spec)\\.ts$/,<EOL>             /node_modules/<EOL>        ];<EOL>        if (codeCoverageExclude) {<EOL>            codeCoverageExclude.forEach((excludeGlob) => {<EOL>                const excludeFiles = glob<EOL>                    .sync(path.join(projectRoot, excludeGlob), { nodir: true })<EOL>                    .map((file) => path. normalize(file));<EOL>                exclude.push(...excludeFiles);<EOL>            });<EOL>        }<EOL>        extraRules.push({<EOL>            test: /\\.(js|ts)$/, loader:  '<STR_LIT>',<EOL>            options: { esModules: true },<EOL>            enforce: '<STR_LIT>',<EOL>            exclude<EOL>        });<EOL>    }<EOL>    return {<EOL>         resolve: {<EOL>            mainFields: [<EOL>                ...(wco.supportES2015 ? ['<STR_LIT>'] : []),<EOL>                '<STR_LIT>', '<STR_LIT>', '<STR_LIT>'<EOL>            ]<EOL>        },<EOL>        devtool: buildOptions.sourcemaps ? '<STR_LIT>' : '<STR_LIT>',<EOL>        entry: {<EOL>            main: path.resolve(projectRoot, appConfig.root, appConfig.main)<EOL>        },<EOL>        module: {<EOL>","gt":"rules: [].concat(extraRules)"}
{"input":"<s> <EOL>export function getTestConfig(wco) {<EOL>    const { projectRoot, buildOptions, appConfig } = wco;<EOL>    const nodeModules = path.resolve(projectRoot, '<STR_LIT>');<EOL>    const extraRules = [];<EOL>    const extraPlugins = [];<EOL>    <EOL>    if (buildOptions.codeCoverage) {<EOL>        <EOL>        const codeCoverageExclude = [];<EOL>        let exclude = [<EOL>             /\\.(e2e|spec)\\.ts$/,<EOL>             /node_modules/<EOL>        ];<EOL>        if (codeCoverageExclude) {<EOL>            codeCoverageExclude.forEach((excludeGlob) => {<EOL>                const excludeFiles = glob<EOL>                    .sync(path.join(projectRoot, excludeGlob), { nodir: true })<EOL>                    .map((file) => path. normalize(file));<EOL>                exclude.push(...excludeFiles);<EOL>            });<EOL>        }<EOL>        extraRules.push({<EOL>            test: /\\.(js|ts)$/, loader:  '<STR_LIT>',<EOL>            options: { esModules: true },<EOL>            enforce: '<STR_LIT>',<EOL>            exclude<EOL>        });<EOL>    }<EOL>    return {<EOL>         resolve: {<EOL>            mainFields: [<EOL>                ...(wco.supportES2015 ? ['<STR_LIT>'] : []),<EOL>                '<STR_LIT>', '<STR_LIT>', '<STR_LIT>'<EOL>            ]<EOL>        },<EOL>        devtool: buildOptions.sourcemaps ? '<STR_LIT>' : '<STR_LIT>',<EOL>        entry: {<EOL>            main: path.resolve(projectRoot, appConfig.root, appConfig.main)<EOL>        },<EOL>        module: {<EOL>             rules: [].concat(extraRules)<EOL>        },<EOL>        plugins: [<EOL>            new webpack.optimize.CommonsChunkPlugin({<EOL>","gt":"minChunks: Infinity,"}
{"input":"<s> <EOL>export function getTestConfig(wco) {<EOL>    const { projectRoot, buildOptions, appConfig } = wco;<EOL>    const nodeModules = path.resolve(projectRoot, '<STR_LIT>');<EOL>    const extraRules = [];<EOL>    const extraPlugins = [];<EOL>    <EOL>    if (buildOptions.codeCoverage) {<EOL>        <EOL>        const codeCoverageExclude = [];<EOL>        let exclude = [<EOL>             /\\.(e2e|spec)\\.ts$/,<EOL>             /node_modules/<EOL>        ];<EOL>        if (codeCoverageExclude) {<EOL>            codeCoverageExclude.forEach((excludeGlob) => {<EOL>                const excludeFiles = glob<EOL>                    .sync(path.join(projectRoot, excludeGlob), { nodir: true })<EOL>                    .map((file) => path. normalize(file));<EOL>                exclude.push(...excludeFiles);<EOL>            });<EOL>        }<EOL>        extraRules.push({<EOL>            test: /\\.(js|ts)$/, loader:  '<STR_LIT>',<EOL>            options: { esModules: true },<EOL>            enforce: '<STR_LIT>',<EOL>            exclude<EOL>        });<EOL>    }<EOL>    return {<EOL>         resolve: {<EOL>            mainFields: [<EOL>                ...(wco.supportES2015 ? ['<STR_LIT>'] : []),<EOL>                '<STR_LIT>', '<STR_LIT>', '<STR_LIT>'<EOL>            ]<EOL>        },<EOL>        devtool: buildOptions.sourcemaps ? '<STR_LIT>' : '<STR_LIT>',<EOL>        entry: {<EOL>            main: path.resolve(projectRoot, appConfig.root, appConfig.main)<EOL>        },<EOL>        module: {<EOL>             rules: [].concat(extraRules)<EOL>        },<EOL>        plugins: [<EOL>            new webpack.optimize.CommonsChunkPlugin({<EOL>                 minChunks: Infinity,<EOL>                name: '<STR_LIT>'<EOL>            }),<EOL>            new","gt":"webpack.optimize.CommonsChunkPlugin({"}
{"input":"<s> export function getNonAotConfig(wco) {<EOL>    const { appConfig, projectRoot } = wco;<EOL>    const","gt":"tsConfigPath = path.resolve(projectRoot, appConfig.root, appConfig.tsConfig);"}
{"input":"<s> export function isFile(filePath) {<EOL>    let stat;<EOL>    try {<EOL>        stat = fs.statSync(filePath);<EOL>    }<EOL>    catch (e) {<EOL>        if (e && (e.code === '<STR_LIT>' || e.code === '<STR_LIT>')) {<EOL>            return false;<EOL>        }<EOL>        throw","gt":"e;"}
{"input":"<s> <EOL>function _readBlanks(context) {<EOL>    if ((context.mode & JsonParseMode.CommentsAllowed) != <NUM_LIT>) {<EOL>        const comments = [];<EOL>        while (","gt":"true) {"}
{"input":"<s> <EOL>function _readBlanks(context) {<EOL>    if ((context.mode & JsonParseMode.CommentsAllowed) != <NUM_LIT>) {<EOL>        const comments = [];<EOL>        while ( true) {<EOL>            let char = context.original[context.position.offset];<EOL>            if (char == '<STR_LIT>' && context.original[context.position.offset + <NUM_LIT>] == '<STR_LIT>') {<EOL>                const","gt":"start = context.position;"}
{"input":"<s> <EOL>function _readBlanks(context) {<EOL>    if ((context.mode & JsonParseMode.CommentsAllowed) != <NUM_LIT>) {<EOL>        const comments = [];<EOL>        while ( true) {<EOL>            let char = context.original[context.position.offset];<EOL>            if (char == '<STR_LIT>' && context.original[context.position.offset + <NUM_LIT>] == '<STR_LIT>') {<EOL>                const  start = context.position;<EOL>                <EOL>                _next(context);<EOL>","gt":"_next(context);"}
{"input":"<s> <EOL>function _readBlanks(context) {<EOL>    if ((context.mode & JsonParseMode.CommentsAllowed) != <NUM_LIT>) {<EOL>        const comments = [];<EOL>        while ( true) {<EOL>            let char = context.original[context.position.offset];<EOL>            if (char == '<STR_LIT>' && context.original[context.position.offset + <NUM_LIT>] == '<STR_LIT>') {<EOL>                const  start = context.position;<EOL>                <EOL>                _next(context);<EOL>                 _next(context);<EOL>                char = context.original[context.position.offset];<EOL>                while (context.original[context.position.offset] != '<STR_LIT>'<EOL>                    || context.original[context.position.offset + <NUM_LIT>] != '<STR_LIT>') {<EOL>","gt":"_next(context);"}
{"input":"<s> <EOL>function _readBlanks(context) {<EOL>    if ((context.mode & JsonParseMode.CommentsAllowed) != <NUM_LIT>) {<EOL>        const comments = [];<EOL>        while ( true) {<EOL>            let char = context.original[context.position.offset];<EOL>            if (char == '<STR_LIT>' && context.original[context.position.offset + <NUM_LIT>] == '<STR_LIT>') {<EOL>                const  start = context.position;<EOL>                <EOL>                _next(context);<EOL>                 _next(context);<EOL>                char = context.original[context.position.offset];<EOL>                while (context.original[context.position.offset] != '<STR_LIT>'<EOL>                    || context.original[context.position.offset + <NUM_LIT>] != '<STR_LIT>') {<EOL>                     _next(context);<EOL>                    if (context.position.offset >= context.original.","gt":"length) {"}
{"input":"<s> <EOL>function _readBlanks(context) {<EOL>    if ((context.mode & JsonParseMode.CommentsAllowed) != <NUM_LIT>) {<EOL>        const comments = [];<EOL>        while ( true) {<EOL>            let char = context.original[context.position.offset];<EOL>            if (char == '<STR_LIT>' && context.original[context.position.offset + <NUM_LIT>] == '<STR_LIT>') {<EOL>                const  start = context.position;<EOL>                <EOL>                _next(context);<EOL>                 _next(context);<EOL>                char = context.original[context.position.offset];<EOL>                while (context.original[context.position.offset] != '<STR_LIT>'<EOL>                    || context.original[context.position.offset + <NUM_LIT>] != '<STR_LIT>') {<EOL>                     _next(context);<EOL>                    if (context.position.offset >= context.original. length) {<EOL>                        throw new UnexpectedEndOfInputException(context);<EOL>                    }<EOL>                }<EOL>                <EOL>                _next(context);<EOL>                _next(context);<EOL>","gt":"comments."}
{"input":"<s> <EOL>function _readBlanks(context) {<EOL>    if ((context.mode & JsonParseMode.CommentsAllowed) != <NUM_LIT>) {<EOL>        const comments = [];<EOL>        while ( true) {<EOL>            let char = context.original[context.position.offset];<EOL>            if (char == '<STR_LIT>' && context.original[context.position.offset + <NUM_LIT>] == '<STR_LIT>') {<EOL>                const  start = context.position;<EOL>                <EOL>                _next(context);<EOL>                 _next(context);<EOL>                char = context.original[context.position.offset];<EOL>                while (context.original[context.position.offset] != '<STR_LIT>'<EOL>                    || context.original[context.position.offset + <NUM_LIT>] != '<STR_LIT>') {<EOL>                     _next(context);<EOL>                    if (context.position.offset >= context.original. length) {<EOL>                        throw new UnexpectedEndOfInputException(context);<EOL>                    }<EOL>                }<EOL>                <EOL>                _next(context);<EOL>                _next(context);<EOL>                 comments.","gt":"push({"}
{"input":"<s> <EOL>function _readBlanks(context) {<EOL>    if ((context.mode & JsonParseMode.CommentsAllowed) != <NUM_LIT>) {<EOL>        const comments = [];<EOL>        while ( true) {<EOL>            let char = context.original[context.position.offset];<EOL>            if (char == '<STR_LIT>' && context.original[context.position.offset + <NUM_LIT>] == '<STR_LIT>') {<EOL>                const  start = context.position;<EOL>                <EOL>                _next(context);<EOL>                 _next(context);<EOL>                char = context.original[context.position.offset];<EOL>                while (context.original[context.position.offset] != '<STR_LIT>'<EOL>                    || context.original[context.position.offset + <NUM_LIT>] != '<STR_LIT>') {<EOL>                     _next(context);<EOL>                    if (context.position.offset >= context.original. length) {<EOL>                        throw new UnexpectedEndOfInputException(context);<EOL>                    }<EOL>                }<EOL>                <EOL>                _next(context);<EOL>                _next(context);<EOL>                 comments. push({<EOL>                    kind: '<STR_LIT>',<EOL>                    start,<EOL>                    end: context.position,<EOL>                    text: context.original.substring(start.offset, context.position.offset),<EOL>                    content: context.original.substring(start.offset + <NUM_LIT>, context.position.offset - <NUM_LIT>),<EOL>                });<EOL>            }<EOL>            else if (char == '<STR_LIT>' && context.original[context.","gt":"position.offset + <NUM_LIT>] == '<STR_LIT>') {"}
{"input":"<s> <EOL>function _readBlanks(context) {<EOL>    if ((context.mode & JsonParseMode.CommentsAllowed) != <NUM_LIT>) {<EOL>        const comments = [];<EOL>        while ( true) {<EOL>            let char = context.original[context.position.offset];<EOL>            if (char == '<STR_LIT>' && context.original[context.position.offset + <NUM_LIT>] == '<STR_LIT>') {<EOL>                const  start = context.position;<EOL>                <EOL>                _next(context);<EOL>                 _next(context);<EOL>                char = context.original[context.position.offset];<EOL>                while (context.original[context.position.offset] != '<STR_LIT>'<EOL>                    || context.original[context.position.offset + <NUM_LIT>] != '<STR_LIT>') {<EOL>                     _next(context);<EOL>                    if (context.position.offset >= context.original. length) {<EOL>                        throw new UnexpectedEndOfInputException(context);<EOL>                    }<EOL>                }<EOL>                <EOL>                _next(context);<EOL>                _next(context);<EOL>                 comments. push({<EOL>                    kind: '<STR_LIT>',<EOL>                    start,<EOL>                    end: context.position,<EOL>                    text: context.original.substring(start.offset, context.position.offset),<EOL>                    content: context.original.substring(start.offset + <NUM_LIT>, context.position.offset - <NUM_LIT>),<EOL>                });<EOL>            }<EOL>            else if (char == '<STR_LIT>' && context.original[context. position.offset + <NUM_LIT>] == '<STR_LIT>') {<EOL>                const start = context.position;<EOL>                <EOL>                _next(context);<EOL>                _next(context);<EOL>                char = context.original[context.position.offset];<EOL>                while (context.original[context.position.offset] != '<STR_LIT>') {<EOL>                    _next(context);<EOL>                    if (","gt":"context.position.offset >= context.original.length) {"}
{"input":"<s> export function fileBufferToString(fileBuffer) {<EOL>    if (typeof TextDecoder !== '<STR_LIT>') {<EOL>        <EOL>        return new TextDecoder('<STR_LIT>').decode(new Uint8Array(","gt":"fileBuffer));"}
{"input":"<s> <EOL>export function isAbsolute(p) {<EOL>    return p.","gt":"startsWith(NormalizedSep);"}
{"input":"<s> export function filter(predicate) {<EOL>    return (tree) => new FilteredTree(tree,","gt":"predicate);"}
{"input":"<s> export function when(predicate, operator) {<EOL>    return (entry) => {<EOL>        if (predicate(entry.path, entry)) {<EOL>            return operator(","gt":"entry);"}
{"input":"<s> <EOL>export function schematic(schematicName, options) {<EOL>    return (input, context) => {<EOL>        const collection = context.","gt":"schematic.collection;"}
{"input":"<s> function files(tree) {<EOL>    const treeFiles =","gt":"[];"}
{"input":"<s> function addAppShellConfig(options) {<EOL>    return (host) => {<EOL>        const config = getConfig(host);<EOL>        const app = getAppFromConfig(config, options.clientApp || '<STR_LIT>');<EOL>        if (!app) {<EOL>            throw new SchematicsException(formatMissingAppMsg('<STR_LIT>',","gt":"options.clientApp));"}
{"input":"<s> <EOL>function validateProject(options) {<EOL>    return (host, context) => {<EOL>        const routerOutletCheckRegex = /<router\\-outlet.*?>([\\s\\S]*?)<\\/router\\-outlet>/;<EOL>        const config = getConfig(host);<EOL>        const app = getAppFromConfig(config, options.clientApp || '<STR_LIT>');<EOL>        if (app ===","gt":"null) {"}
{"input":"<s> <EOL>function validateProject(options) {<EOL>    return (host, context) => {<EOL>        const routerOutletCheckRegex = /<router\\-outlet.*?>([\\s\\S]*?)<\\/router\\-outlet>/;<EOL>        const config = getConfig(host);<EOL>        const app = getAppFromConfig(config, options.clientApp || '<STR_LIT>');<EOL>        if (app ===  null) {<EOL>            throw new SchematicsException(formatMissingAppMsg('<STR_LIT>', options.clientApp));<EOL>        }<EOL>        const componentPath = getBootstrapComponentPath(host, app);<EOL>        const tmpl =","gt":"getComponentTemplateInfo(host, componentPath);"}
{"input":"<s> <EOL>function validateProject(options) {<EOL>    return (host, context) => {<EOL>        const routerOutletCheckRegex = /<router\\-outlet.*?>([\\s\\S]*?)<\\/router\\-outlet>/;<EOL>        const config = getConfig(host);<EOL>        const app = getAppFromConfig(config, options.clientApp || '<STR_LIT>');<EOL>        if (app ===  null) {<EOL>            throw new SchematicsException(formatMissingAppMsg('<STR_LIT>', options.clientApp));<EOL>        }<EOL>        const componentPath = getBootstrapComponentPath(host, app);<EOL>        const tmpl =  getComponentTemplateInfo(host, componentPath);<EOL>        const template = getComponentTemplate(host, componentPath, tmpl);<EOL>        if (!routerOutletCheckRegex.test(template)) {<EOL>            const errorMsg = `<STR_LIT>`;<EOL>            context.logger.error(","gt":"errorMsg);"}
{"input":"<s> <EOL>export function findModule(host, generateDir) {<EOL>    let dir = host.getDir('<STR_LIT>' + generateDir);<EOL>    const moduleRe = /\\.module\\.ts$/;<EOL>    const routingModuleRe = /-routing\\.module\\.ts/;<EOL>    while (dir) {<EOL>        const matches = dir.subfiles.filter((p) =>","gt":"moduleRe.test(p) && !routingModuleRe.test(p));"}
{"input":"<s> <EOL>export function findModule(host, generateDir) {<EOL>    let dir = host.getDir('<STR_LIT>' + generateDir);<EOL>    const moduleRe = /\\.module\\.ts$/;<EOL>    const routingModuleRe = /-routing\\.module\\.ts/;<EOL>    while (dir) {<EOL>        const matches = dir.subfiles.filter((p) =>  moduleRe.test(p) && !routingModuleRe.test(p));<EOL>        if (matches.length == <NUM_LIT>) {<EOL>            return join(dir.path, matches[<NUM_LIT>]);<EOL>        }<EOL>        else if (","gt":"matches.length > <NUM_LIT>) {"}
{"input":"<s> <EOL>export function findModule(host, generateDir) {<EOL>    let dir = host.getDir('<STR_LIT>' + generateDir);<EOL>    const moduleRe = /\\.module\\.ts$/;<EOL>    const routingModuleRe = /-routing\\.module\\.ts/;<EOL>    while (dir) {<EOL>        const matches = dir.subfiles.filter((p) =>  moduleRe.test(p) && !routingModuleRe.test(p));<EOL>        if (matches.length == <NUM_LIT>) {<EOL>            return join(dir.path, matches[<NUM_LIT>]);<EOL>        }<EOL>        else if ( matches.length > <NUM_LIT>) {<EOL>            throw new Error('<STR_LIT>'<EOL>                + '<STR_LIT>');<EOL>        }<EOL>        dir =","gt":"dir.parent;"}
{"input":"<s> <EOL>function _getRecursiveVersions(packageJson, packages, allVersions, logger, loose) {<EOL>    return observableFrom(kPackageJsonDependencyFields).pipe(mergeMap((field) => {<EOL>        const deps = packageJson[field];<EOL>","gt":"if (deps) {"}
{"input":"<s> <EOL>function _getRecursiveVersions(packageJson, packages, allVersions, logger, loose) {<EOL>    return observableFrom(kPackageJsonDependencyFields).pipe(mergeMap((field) => {<EOL>        const deps = packageJson[field];<EOL>         if (deps) {<EOL>            return observableFrom(Object.keys(deps)<EOL>                .map((depName) => depName in deps ? [depName, deps[","gt":"depName]] : null)"}
{"input":"<s> <EOL>function _getRecursiveVersions(packageJson, packages, allVersions, logger, loose) {<EOL>    return observableFrom(kPackageJsonDependencyFields).pipe(mergeMap((field) => {<EOL>        const deps = packageJson[field];<EOL>         if (deps) {<EOL>            return observableFrom(Object.keys(deps)<EOL>                .map((depName) => depName in deps ? [depName, deps[ depName]] : null)<EOL>                .filter((x) => !!x));<EOL>        }<EOL>        else {<EOL>            return empty();<EOL>        }<EOL>    }), mergeMap(([","gt":"depName, depVersion]) => {"}
{"input":"<s> <EOL>function _getRecursiveVersions(packageJson, packages, allVersions, logger, loose) {<EOL>    return observableFrom(kPackageJsonDependencyFields).pipe(mergeMap((field) => {<EOL>        const deps = packageJson[field];<EOL>         if (deps) {<EOL>            return observableFrom(Object.keys(deps)<EOL>                .map((depName) => depName in deps ? [depName, deps[ depName]] : null)<EOL>                .filter((x) => !!x));<EOL>        }<EOL>        else {<EOL>            return empty();<EOL>        }<EOL>    }), mergeMap(([ depName, depVersion]) => {<EOL>        if (!packages[depName] || packages[depName] === depVersion) {<EOL>            return empty();<EOL>        }<EOL>        if (allVersions[depName] && semver.intersects(allVersions[depName],","gt":"depVersion)) {"}
{"input":"<s> <EOL>function _getRecursiveVersions(packageJson, packages, allVersions, logger, loose) {<EOL>    return observableFrom(kPackageJsonDependencyFields).pipe(mergeMap((field) => {<EOL>        const deps = packageJson[field];<EOL>         if (deps) {<EOL>            return observableFrom(Object.keys(deps)<EOL>                .map((depName) => depName in deps ? [depName, deps[ depName]] : null)<EOL>                .filter((x) => !!x));<EOL>        }<EOL>        else {<EOL>            return empty();<EOL>        }<EOL>    }), mergeMap(([ depName, depVersion]) => {<EOL>        if (!packages[depName] || packages[depName] === depVersion) {<EOL>            return empty();<EOL>        }<EOL>        if (allVersions[depName] && semver.intersects(allVersions[depName],  depVersion)) {<EOL>            allVersions[depName] = semverIntersect.intersect(allVersions[depName], depVersion);<EOL>            return empty();<EOL>        }<EOL>        return _getNpmPackageJson(depName, logger).pipe(map((json) => [packages[depName], depName, depVersion, json]));<EOL>    }),","gt":"mergeMap(([version, depName, depVersion, npmPackageJson]) => {"}
{"input":"<s> <EOL>function _getRecursiveVersions(packageJson, packages, allVersions, logger, loose) {<EOL>    return observableFrom(kPackageJsonDependencyFields).pipe(mergeMap((field) => {<EOL>        const deps = packageJson[field];<EOL>         if (deps) {<EOL>            return observableFrom(Object.keys(deps)<EOL>                .map((depName) => depName in deps ? [depName, deps[ depName]] : null)<EOL>                .filter((x) => !!x));<EOL>        }<EOL>        else {<EOL>            return empty();<EOL>        }<EOL>    }), mergeMap(([ depName, depVersion]) => {<EOL>        if (!packages[depName] || packages[depName] === depVersion) {<EOL>            return empty();<EOL>        }<EOL>        if (allVersions[depName] && semver.intersects(allVersions[depName],  depVersion)) {<EOL>            allVersions[depName] = semverIntersect.intersect(allVersions[depName], depVersion);<EOL>            return empty();<EOL>        }<EOL>        return _getNpmPackageJson(depName, logger).pipe(map((json) => [packages[depName], depName, depVersion, json]));<EOL>    }),  mergeMap(([version, depName, depVersion, npmPackageJson]) => {<EOL>        const updateVersion = _getVersionFromNpmPackage(npmPackageJson, version, loose);<EOL>        const npmPackageVersions = Object.keys(npmPackageJson['<STR_LIT>']);<EOL>        const match = semver.maxSatisfying(npmPackageVersions, updateVersion);<EOL>        if (!match) {<EOL>            return empty();<EOL>        }<EOL>        if (semver.lt(semverIntersect.parseRange(updateVersion).version,","gt":"semverIntersect.parseRange(depVersion).version)) {"}
{"input":"<s> <EOL>function _getRecursiveVersions(packageJson, packages, allVersions, logger, loose) {<EOL>    return observableFrom(kPackageJsonDependencyFields).pipe(mergeMap((field) => {<EOL>        const deps = packageJson[field];<EOL>         if (deps) {<EOL>            return observableFrom(Object.keys(deps)<EOL>                .map((depName) => depName in deps ? [depName, deps[ depName]] : null)<EOL>                .filter((x) => !!x));<EOL>        }<EOL>        else {<EOL>            return empty();<EOL>        }<EOL>    }), mergeMap(([ depName, depVersion]) => {<EOL>        if (!packages[depName] || packages[depName] === depVersion) {<EOL>            return empty();<EOL>        }<EOL>        if (allVersions[depName] && semver.intersects(allVersions[depName],  depVersion)) {<EOL>            allVersions[depName] = semverIntersect.intersect(allVersions[depName], depVersion);<EOL>            return empty();<EOL>        }<EOL>        return _getNpmPackageJson(depName, logger).pipe(map((json) => [packages[depName], depName, depVersion, json]));<EOL>    }),  mergeMap(([version, depName, depVersion, npmPackageJson]) => {<EOL>        const updateVersion = _getVersionFromNpmPackage(npmPackageJson, version, loose);<EOL>        const npmPackageVersions = Object.keys(npmPackageJson['<STR_LIT>']);<EOL>        const match = semver.maxSatisfying(npmPackageVersions, updateVersion);<EOL>        if (!match) {<EOL>            return empty();<EOL>        }<EOL>        if (semver.lt(semverIntersect.parseRange(updateVersion).version,  semverIntersect.parseRange(depVersion).version)) {<EOL>            throw new SchematicsException(`<STR_LIT>`);<EOL>        }<EOL>        const innerNpmPackageJson = npmPackageJson['<STR_LIT>'][match];<EOL>        const","gt":"dependencies = {};"}
{"input":"<s> <EOL>function _getRecursiveVersions(packageJson, packages, allVersions, logger, loose) {<EOL>    return observableFrom(kPackageJsonDependencyFields).pipe(mergeMap((field) => {<EOL>        const deps = packageJson[field];<EOL>         if (deps) {<EOL>            return observableFrom(Object.keys(deps)<EOL>                .map((depName) => depName in deps ? [depName, deps[ depName]] : null)<EOL>                .filter((x) => !!x));<EOL>        }<EOL>        else {<EOL>            return empty();<EOL>        }<EOL>    }), mergeMap(([ depName, depVersion]) => {<EOL>        if (!packages[depName] || packages[depName] === depVersion) {<EOL>            return empty();<EOL>        }<EOL>        if (allVersions[depName] && semver.intersects(allVersions[depName],  depVersion)) {<EOL>            allVersions[depName] = semverIntersect.intersect(allVersions[depName], depVersion);<EOL>            return empty();<EOL>        }<EOL>        return _getNpmPackageJson(depName, logger).pipe(map((json) => [packages[depName], depName, depVersion, json]));<EOL>    }),  mergeMap(([version, depName, depVersion, npmPackageJson]) => {<EOL>        const updateVersion = _getVersionFromNpmPackage(npmPackageJson, version, loose);<EOL>        const npmPackageVersions = Object.keys(npmPackageJson['<STR_LIT>']);<EOL>        const match = semver.maxSatisfying(npmPackageVersions, updateVersion);<EOL>        if (!match) {<EOL>            return empty();<EOL>        }<EOL>        if (semver.lt(semverIntersect.parseRange(updateVersion).version,  semverIntersect.parseRange(depVersion).version)) {<EOL>            throw new SchematicsException(`<STR_LIT>`);<EOL>        }<EOL>        const innerNpmPackageJson = npmPackageJson['<STR_LIT>'][match];<EOL>        const  dependencies = {};<EOL>        const deps = innerNpmPackageJson['<STR_LIT>'];<EOL>        if (deps) {<EOL>            for (const depName of Object.keys(deps)) {<EOL>                dependencies[depName] = deps[depName];<EOL>            }<EOL>        }<EOL>        logger.debug(","gt":"JSON.stringify(depName)} to version ${updateVersion}.`<STR_LIT>;"}
{"input":"<s> <EOL>function _getRecursiveVersions(packageJson, packages, allVersions, logger, loose) {<EOL>    return observableFrom(kPackageJsonDependencyFields).pipe(mergeMap((field) => {<EOL>        const deps = packageJson[field];<EOL>         if (deps) {<EOL>            return observableFrom(Object.keys(deps)<EOL>                .map((depName) => depName in deps ? [depName, deps[ depName]] : null)<EOL>                .filter((x) => !!x));<EOL>        }<EOL>        else {<EOL>            return empty();<EOL>        }<EOL>    }), mergeMap(([ depName, depVersion]) => {<EOL>        if (!packages[depName] || packages[depName] === depVersion) {<EOL>            return empty();<EOL>        }<EOL>        if (allVersions[depName] && semver.intersects(allVersions[depName],  depVersion)) {<EOL>            allVersions[depName] = semverIntersect.intersect(allVersions[depName], depVersion);<EOL>            return empty();<EOL>        }<EOL>        return _getNpmPackageJson(depName, logger).pipe(map((json) => [packages[depName], depName, depVersion, json]));<EOL>    }),  mergeMap(([version, depName, depVersion, npmPackageJson]) => {<EOL>        const updateVersion = _getVersionFromNpmPackage(npmPackageJson, version, loose);<EOL>        const npmPackageVersions = Object.keys(npmPackageJson['<STR_LIT>']);<EOL>        const match = semver.maxSatisfying(npmPackageVersions, updateVersion);<EOL>        if (!match) {<EOL>            return empty();<EOL>        }<EOL>        if (semver.lt(semverIntersect.parseRange(updateVersion).version,  semverIntersect.parseRange(depVersion).version)) {<EOL>            throw new SchematicsException(`<STR_LIT>`);<EOL>        }<EOL>        const innerNpmPackageJson = npmPackageJson['<STR_LIT>'][match];<EOL>        const  dependencies = {};<EOL>        const deps = innerNpmPackageJson['<STR_LIT>'];<EOL>        if (deps) {<EOL>            for (const depName of Object.keys(deps)) {<EOL>                dependencies[depName] = deps[depName];<EOL>            }<EOL>        }<EOL>        logger.debug(`<STR_LIT>`);<EOL>        if (allVersions[depName]) {<EOL>            if (!semver.intersects(allVersions[depName], updateVersion)) {<EOL>                throw new SchematicsException('<STR_LIT>'<EOL>                    +","gt":"} would need to match both versions \"<STR_LIT>\" and `<STR_LIT>`"}
{"input":"<s> export default function (_, logger) {<EOL>    logger.info(JSON.stringify(","gt":"packages, null, <NUM_LIT>));"}
{"input":"<s> export default function () {<EOL>","gt":"'<STR_LIT>';"}
{"input":"<s> export default function ($compile) {<EOL>    '<STR_LIT>';<EOL>    return {<EOL>        restrict: '<STR_LIT>',<EOL>        require: '<STR_LIT>',<EOL>        link: function (","gt":"scope, element, attrs, ganttCtrl) {"}
{"input":"<s> export default function ($compile) {<EOL>    '<STR_LIT>';<EOL>    return {<EOL>        restrict: '<STR_LIT>',<EOL>        require: '<STR_LIT>',<EOL>        link: function ( scope, element, attrs, ganttCtrl) {<EOL>            scope.scope = ganttCtrl.gantt.$scope.$parent;<EOL>            scope.$watch(function () {<EOL>                return scope.$eval(attrs.ganttBindCompileHtml);<EOL>            }, function (value) {<EOL>                element.html(value);<EOL>","gt":"$compile(element.contents())(scope);"}
{"input":"<s> function blurAndScreenshot(msg) {<EOL>","gt":"browser.executeScript(`<STR_LIT>`);"}
{"input":"<s> <EOL>function getBodyActiveStates(elements) {<EOL>","gt":"return getClassStates(elements, '<STR_LIT>');"}
{"input":"<s> <EOL>function addThemeToAppStyles(options) {<EOL>    return (host) => {<EOL>        const config = getConfig(host);<EOL>        const themeName = options && options.theme ? options.theme : '<STR_LIT>';<EOL>        const","gt":"app = getAppFromConfig(config, '<STR_LIT>');"}
{"input":"<s> function getTouches(event, type) {<EOL>    if (event.touches == undefined || event.touches.length == <NUM_LIT>) {<EOL>        return [[event], [event]];<EOL>    }<EOL>","gt":"else {"}
{"input":"<s> <EOL>export function _mockNgReduxFactory() {<EOL>    return","gt":"mockNgRedux;"}
{"input":"<s> export function convertCommonJsToGoogModuleIfNeeded(host, modulesManifest, fileName, content) {<EOL>    if (!host.googmodule || isDtsFileName(fileName)) {<EOL>        return content;<EOL>    }<EOL>    const {","gt":"output, referencedModules } = processES5(host, fileName, content);"}
{"input":"<s> export function convertCommonJsToGoogModuleIfNeeded(host, modulesManifest, fileName, content) {<EOL>    if (!host.googmodule || isDtsFileName(fileName)) {<EOL>        return content;<EOL>    }<EOL>    const {  output, referencedModules } = processES5(host, fileName, content);<EOL>    const moduleName = host.pathToModuleName('<STR_LIT>', fileName);<EOL>    modulesManifest.addModule(fileName, moduleName);<EOL>    for (const referenced of referencedModules) {<EOL>        modulesManifest.","gt":"addReferencedModule(fileName, referenced);"}
{"input":"<s> <EOL>function synthesizeTrailingComments(sourceFile, node) {<EOL>    const parent = node.parent;<EOL>    const sharesEndWithParent = parent && parent.kind !== ts.SyntaxKind.Block &&<EOL>        parent.kind !== ts.SyntaxKind.SourceFile && parent.getEnd() === node.getEnd();<EOL>    if (","gt":"sharesEndWithParent) {"}
{"input":"<s> <EOL>function synthesizeTrailingComments(sourceFile, node) {<EOL>    const parent = node.parent;<EOL>    const sharesEndWithParent = parent && parent.kind !== ts.SyntaxKind.Block &&<EOL>        parent.kind !== ts.SyntaxKind.SourceFile && parent.getEnd() === node.getEnd();<EOL>    if ( sharesEndWithParent) {<EOL>        return -<NUM_LIT>;<EOL>    }<EOL>    const trailingComments = ts.getTrailingCommentRanges(sourceFile.text, node.getEnd());<EOL>    if (trailingComments && trailingComments.length) {<EOL>        ts.setSyntheticTrailingComments(node, synthesizeCommentRanges(sourceFile, trailingComments));<EOL>        return trailingComments[trailingComments.","gt":"length - <NUM_LIT>].end;"}
{"input":"<s> export function annotate(typeChecker, file, host, tsHost, tsOpts, sourceMapper) {<EOL>    return new Annotator(typeChecker, file, host, tsHost,","gt":"tsOpts, sourceMapper).annotate();"}
{"input":"<s> <EOL>export function getGeneratedExterns(externs) {<EOL>    let allExterns = EXTERNS_HEADER;<EOL>    for (const fileName","gt":"of Object.keys(externs)) {"}
{"input":"<s> <EOL>function isAmbient(node) {<EOL>    let current = node;<EOL>    while (current) {<EOL>        if (hasModifierFlag(","gt":"current, ts.ModifierFlags.Ambient))"}
{"input":"<s> export function findFileContentsByName(filename, files) {<EOL>    for (const filepath of files.keys()) {<EOL>        if (path.parse(filepath).base === path.parse(filename).base) {<EOL>            return files.get(","gt":"filepath);"}
{"input":"<s> <EOL>export function ng1ViewsBuilder(state) {<EOL>    <EOL>    if (!state.parent)<EOL>        return {};<EOL>    const tplKeys =","gt":"['<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>'], ctrlKeys = ['<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>'], compKeys = ['<STR_LIT>', '<STR_LIT>', '<STR_LIT>'], nonCompKeys = tplKeys.concat(ctrlKeys), allViewKeys = compKeys.concat(nonCompKeys);"}
{"input":"<s> <EOL>export function ng1ViewsBuilder(state) {<EOL>    <EOL>    if (!state.parent)<EOL>        return {};<EOL>    const tplKeys =  ['<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>'], ctrlKeys = ['<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>'], compKeys = ['<STR_LIT>', '<STR_LIT>', '<STR_LIT>'], nonCompKeys = tplKeys.concat(ctrlKeys), allViewKeys = compKeys.concat(nonCompKeys);<EOL>    <EOL>    <EOL>    <EOL>    if (isDefined(state.views) && hasAnyKey(allViewKeys, state)) {<EOL>        throw new Error(`<STR_LIT>` +<EOL>            `<STR_LIT>` +<EOL>            `<STR_LIT>` +<EOL>","gt":"key])).join('<STR_LIT>')}`<STR_LIT>;"}
{"input":"<s> <EOL>export function ng1ViewsBuilder(state) {<EOL>    <EOL>    if (!state.parent)<EOL>        return {};<EOL>    const tplKeys =  ['<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>'], ctrlKeys = ['<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>'], compKeys = ['<STR_LIT>', '<STR_LIT>', '<STR_LIT>'], nonCompKeys = tplKeys.concat(ctrlKeys), allViewKeys = compKeys.concat(nonCompKeys);<EOL>    <EOL>    <EOL>    <EOL>    if (isDefined(state.views) && hasAnyKey(allViewKeys, state)) {<EOL>        throw new Error(`<STR_LIT>` +<EOL>            `<STR_LIT>` +<EOL>            `<STR_LIT>` +<EOL>            `<STR_LIT>`);<EOL>    }<EOL>    const views = {}, viewsObject = state.views || {","gt":"'<STR_LIT>': pick(state, allViewKeys) };"}
{"input":"<s> <EOL>export function ng1ViewsBuilder(state) {<EOL>    <EOL>    if (!state.parent)<EOL>        return {};<EOL>    const tplKeys =  ['<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>'], ctrlKeys = ['<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>'], compKeys = ['<STR_LIT>', '<STR_LIT>', '<STR_LIT>'], nonCompKeys = tplKeys.concat(ctrlKeys), allViewKeys = compKeys.concat(nonCompKeys);<EOL>    <EOL>    <EOL>    <EOL>    if (isDefined(state.views) && hasAnyKey(allViewKeys, state)) {<EOL>        throw new Error(`<STR_LIT>` +<EOL>            `<STR_LIT>` +<EOL>            `<STR_LIT>` +<EOL>            `<STR_LIT>`);<EOL>    }<EOL>    const views = {}, viewsObject = state.views || {  '<STR_LIT>': pick(state, allViewKeys) };<EOL>    forEach(viewsObject, function (config, name) {<EOL>        <EOL>        name = name || '<STR_LIT>';<EOL>        <EOL>","gt":"if (isString(config))"}
{"input":"<s> <EOL>export function ng1ViewsBuilder(state) {<EOL>    <EOL>    if (!state.parent)<EOL>        return {};<EOL>    const tplKeys =  ['<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>'], ctrlKeys = ['<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>'], compKeys = ['<STR_LIT>', '<STR_LIT>', '<STR_LIT>'], nonCompKeys = tplKeys.concat(ctrlKeys), allViewKeys = compKeys.concat(nonCompKeys);<EOL>    <EOL>    <EOL>    <EOL>    if (isDefined(state.views) && hasAnyKey(allViewKeys, state)) {<EOL>        throw new Error(`<STR_LIT>` +<EOL>            `<STR_LIT>` +<EOL>            `<STR_LIT>` +<EOL>            `<STR_LIT>`);<EOL>    }<EOL>    const views = {}, viewsObject = state.views || {  '<STR_LIT>': pick(state, allViewKeys) };<EOL>    forEach(viewsObject, function (config, name) {<EOL>        <EOL>        name = name || '<STR_LIT>';<EOL>        <EOL>         if (isString(config))<EOL>            config = { component: config };<EOL>        <EOL>        config = extend({}, config);<EOL>        <EOL>        if (hasAnyKey(compKeys, config) && hasAnyKey(nonCompKeys, config)) {<EOL>            throw new Error(`<STR_LIT>`);<EOL>        }<EOL>        config.resolveAs = config.","gt":"resolveAs || '<STR_LIT>';"}
{"input":"<s> function filter(array, f) {<EOL>    if (array) {<EOL>        const len = array.length;<EOL>        let i = <NUM_LIT>;<EOL>        while (i < len && f(array[i]))<EOL>            i++;<EOL>        if (","gt":"i < len) {"}
{"input":"<s> function filter(array, f) {<EOL>    if (array) {<EOL>        const len = array.length;<EOL>        let i = <NUM_LIT>;<EOL>        while (i < len && f(array[i]))<EOL>            i++;<EOL>        if ( i < len) {<EOL>            const result = array.slice(<NUM_LIT>, i);<EOL>            i++;<EOL>            while (i < len) {<EOL>                const item = array[i];<EOL>                if (","gt":"f(item)) {"}
{"input":"<s> function help() {<EOL>    console.log(","gt":"'<STR_LIT>');"}
{"input":"<s> function detachedRun(options) {<EOL>    var file = path.resolve(__dirname, '<STR_LIT>', '<STR_LIT>');<EOL>    var oldSignal = options[Opt.STARTED_SIGNIFIER].getString();<EOL>    var","gt":"oldViaIPC = options[Opt.SIGNAL_VIA_IPC].getBoolean();"}
{"input":"<s> function detachedRun(options) {<EOL>    var file = path.resolve(__dirname, '<STR_LIT>', '<STR_LIT>');<EOL>    var oldSignal = options[Opt.STARTED_SIGNIFIER].getString();<EOL>    var  oldViaIPC = options[Opt.SIGNAL_VIA_IPC].getBoolean();<EOL>    options[Opt.DETACH].value = false;<EOL>    options[Opt.STARTED_SIGNIFIER].value = '<STR_LIT>';<EOL>    options[","gt":"Opt.SIGNAL_VIA_IPC].value = true;"}
{"input":"<s> function detachedRun(options) {<EOL>    var file = path.resolve(__dirname, '<STR_LIT>', '<STR_LIT>');<EOL>    var oldSignal = options[Opt.STARTED_SIGNIFIER].getString();<EOL>    var  oldViaIPC = options[Opt.SIGNAL_VIA_IPC].getBoolean();<EOL>    options[Opt.DETACH].value = false;<EOL>    options[Opt.STARTED_SIGNIFIER].value = '<STR_LIT>';<EOL>    options[ Opt.SIGNAL_VIA_IPC].value = true;<EOL>    let args = [file, commandName].concat(unparseOptions(options));<EOL>    var unreffed = false;<EOL>    let child = spawn(process.execPath, args, ['<STR_LIT>', <NUM_LIT>, <NUM_LIT>, '<STR_LIT>']);<EOL>    child.on(","gt":"'<STR_LIT>', (message) => {"}
{"input":"<s> function detachedRun(options) {<EOL>    var file = path.resolve(__dirname, '<STR_LIT>', '<STR_LIT>');<EOL>    var oldSignal = options[Opt.STARTED_SIGNIFIER].getString();<EOL>    var  oldViaIPC = options[Opt.SIGNAL_VIA_IPC].getBoolean();<EOL>    options[Opt.DETACH].value = false;<EOL>    options[Opt.STARTED_SIGNIFIER].value = '<STR_LIT>';<EOL>    options[ Opt.SIGNAL_VIA_IPC].value = true;<EOL>    let args = [file, commandName].concat(unparseOptions(options));<EOL>    var unreffed = false;<EOL>    let child = spawn(process.execPath, args, ['<STR_LIT>', <NUM_LIT>, <NUM_LIT>, '<STR_LIT>']);<EOL>    child.on( '<STR_LIT>', (message) => {<EOL>        if (message == options[Opt.STARTED_SIGNIFIER].getString()) {<EOL>            if (oldSignal) {<EOL>","gt":"sendStartedSignal(oldSignal, oldViaIPC);"}
{"input":"<s> function detachedRun(options) {<EOL>    var file = path.resolve(__dirname, '<STR_LIT>', '<STR_LIT>');<EOL>    var oldSignal = options[Opt.STARTED_SIGNIFIER].getString();<EOL>    var  oldViaIPC = options[Opt.SIGNAL_VIA_IPC].getBoolean();<EOL>    options[Opt.DETACH].value = false;<EOL>    options[Opt.STARTED_SIGNIFIER].value = '<STR_LIT>';<EOL>    options[ Opt.SIGNAL_VIA_IPC].value = true;<EOL>    let args = [file, commandName].concat(unparseOptions(options));<EOL>    var unreffed = false;<EOL>    let child = spawn(process.execPath, args, ['<STR_LIT>', <NUM_LIT>, <NUM_LIT>, '<STR_LIT>']);<EOL>    child.on( '<STR_LIT>', (message) => {<EOL>        if (message == options[Opt.STARTED_SIGNIFIER].getString()) {<EOL>            if (oldSignal) {<EOL>                 sendStartedSignal(oldSignal, oldViaIPC);<EOL>            }<EOL>            logger.info('<STR_LIT>' + child.pid);<EOL>            child.disconnect();<EOL>","gt":"child.unref();"}
{"input":"<s> function detachedRun(options) {<EOL>    var file = path.resolve(__dirname, '<STR_LIT>', '<STR_LIT>');<EOL>    var oldSignal = options[Opt.STARTED_SIGNIFIER].getString();<EOL>    var  oldViaIPC = options[Opt.SIGNAL_VIA_IPC].getBoolean();<EOL>    options[Opt.DETACH].value = false;<EOL>    options[Opt.STARTED_SIGNIFIER].value = '<STR_LIT>';<EOL>    options[ Opt.SIGNAL_VIA_IPC].value = true;<EOL>    let args = [file, commandName].concat(unparseOptions(options));<EOL>    var unreffed = false;<EOL>    let child = spawn(process.execPath, args, ['<STR_LIT>', <NUM_LIT>, <NUM_LIT>, '<STR_LIT>']);<EOL>    child.on( '<STR_LIT>', (message) => {<EOL>        if (message == options[Opt.STARTED_SIGNIFIER].getString()) {<EOL>            if (oldSignal) {<EOL>                 sendStartedSignal(oldSignal, oldViaIPC);<EOL>            }<EOL>            logger.info('<STR_LIT>' + child.pid);<EOL>            child.disconnect();<EOL>             child.unref();<EOL>            unreffed = true;<EOL>        }<EOL>    });<EOL>    child.on('<STR_LIT>', (code) => {<EOL>        if (!unreffed) {<EOL>            if (code == <NUM_LIT>) {<EOL>                logger.","gt":"warn('<STR_LIT>');"}
{"input":"<s> function canPatchViaPropertyDescriptor() {<EOL>    if ((isBrowser || isMix) && !ObjectGetOwnPropertyDescriptor(HTMLElement.prototype, '<STR_LIT>') &&<EOL>","gt":"typeof Element !== '<STR_LIT>') {"}
{"input":"<s> function canPatchViaPropertyDescriptor() {<EOL>    if ((isBrowser || isMix) && !ObjectGetOwnPropertyDescriptor(HTMLElement.prototype, '<STR_LIT>') &&<EOL>         typeof Element !== '<STR_LIT>') {<EOL>        <EOL>        <EOL>        const desc = ObjectGetOwnPropertyDescriptor(Element.prototype,","gt":"'<STR_LIT>');"}
{"input":"<s> function canPatchViaPropertyDescriptor() {<EOL>    if ((isBrowser || isMix) && !ObjectGetOwnPropertyDescriptor(HTMLElement.prototype, '<STR_LIT>') &&<EOL>         typeof Element !== '<STR_LIT>') {<EOL>        <EOL>        <EOL>        const desc = ObjectGetOwnPropertyDescriptor(Element.prototype,  '<STR_LIT>');<EOL>        if (desc && !desc.configurable)<EOL>            return","gt":"false;"}
{"input":"<s> function canPatchViaPropertyDescriptor() {<EOL>    if ((isBrowser || isMix) && !ObjectGetOwnPropertyDescriptor(HTMLElement.prototype, '<STR_LIT>') &&<EOL>         typeof Element !== '<STR_LIT>') {<EOL>        <EOL>        <EOL>        const desc = ObjectGetOwnPropertyDescriptor(Element.prototype,  '<STR_LIT>');<EOL>        if (desc && !desc.configurable)<EOL>            return  false;<EOL>    }<EOL>    const ON_READY_STATE_CHANGE = '<STR_LIT>';<EOL>","gt":"const XMLHttpRequestPrototype = XMLHttpRequest.prototype;"}
{"input":"<s> function canPatchViaPropertyDescriptor() {<EOL>    if ((isBrowser || isMix) && !ObjectGetOwnPropertyDescriptor(HTMLElement.prototype, '<STR_LIT>') &&<EOL>         typeof Element !== '<STR_LIT>') {<EOL>        <EOL>        <EOL>        const desc = ObjectGetOwnPropertyDescriptor(Element.prototype,  '<STR_LIT>');<EOL>        if (desc && !desc.configurable)<EOL>            return  false;<EOL>    }<EOL>    const ON_READY_STATE_CHANGE = '<STR_LIT>';<EOL>     const XMLHttpRequestPrototype = XMLHttpRequest.prototype;<EOL>    const xhrDesc = ObjectGetOwnPropertyDescriptor(XMLHttpRequestPrototype, ON_READY_STATE_CHANGE);<EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    if (xhrDesc) {<EOL>        ObjectDefineProperty(XMLHttpRequestPrototype, ON_READY_STATE_CHANGE, {<EOL>            enumerable:","gt":"true,"}
{"input":"<s> function canPatchViaPropertyDescriptor() {<EOL>    if ((isBrowser || isMix) && !ObjectGetOwnPropertyDescriptor(HTMLElement.prototype, '<STR_LIT>') &&<EOL>         typeof Element !== '<STR_LIT>') {<EOL>        <EOL>        <EOL>        const desc = ObjectGetOwnPropertyDescriptor(Element.prototype,  '<STR_LIT>');<EOL>        if (desc && !desc.configurable)<EOL>            return  false;<EOL>    }<EOL>    const ON_READY_STATE_CHANGE = '<STR_LIT>';<EOL>     const XMLHttpRequestPrototype = XMLHttpRequest.prototype;<EOL>    const xhrDesc = ObjectGetOwnPropertyDescriptor(XMLHttpRequestPrototype, ON_READY_STATE_CHANGE);<EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    if (xhrDesc) {<EOL>        ObjectDefineProperty(XMLHttpRequestPrototype, ON_READY_STATE_CHANGE, {<EOL>            enumerable:  true,<EOL>            configurable: true,<EOL>            get: function () {<EOL>                return true;<EOL>            }<EOL>        });<EOL>        const req = new","gt":"XMLHttpRequest();"}
{"input":"<s> function canPatchViaPropertyDescriptor() {<EOL>    if ((isBrowser || isMix) && !ObjectGetOwnPropertyDescriptor(HTMLElement.prototype, '<STR_LIT>') &&<EOL>         typeof Element !== '<STR_LIT>') {<EOL>        <EOL>        <EOL>        const desc = ObjectGetOwnPropertyDescriptor(Element.prototype,  '<STR_LIT>');<EOL>        if (desc && !desc.configurable)<EOL>            return  false;<EOL>    }<EOL>    const ON_READY_STATE_CHANGE = '<STR_LIT>';<EOL>     const XMLHttpRequestPrototype = XMLHttpRequest.prototype;<EOL>    const xhrDesc = ObjectGetOwnPropertyDescriptor(XMLHttpRequestPrototype, ON_READY_STATE_CHANGE);<EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    if (xhrDesc) {<EOL>        ObjectDefineProperty(XMLHttpRequestPrototype, ON_READY_STATE_CHANGE, {<EOL>            enumerable:  true,<EOL>            configurable: true,<EOL>            get: function () {<EOL>                return true;<EOL>            }<EOL>        });<EOL>        const req = new  XMLHttpRequest();<EOL>        const result = !!req.onreadystatechange;<EOL>        <EOL>        ObjectDefineProperty(XMLHttpRequestPrototype, ON_READY_STATE_CHANGE, xhrDesc || {});<EOL>        return result;<EOL>    }<EOL>    else {<EOL>        const SYMBOL_FAKE_ONREADYSTATECHANGE = zoneSymbol('<STR_LIT>');<EOL>        ObjectDefineProperty(XMLHttpRequestPrototype, ON_READY_STATE_CHANGE, {<EOL>            enumerable: true,<EOL>            configurable: true,<EOL>            get: function () {<EOL>","gt":"return this[SYMBOL_FAKE_ONREADYSTATECHANGE];"}
{"input":"<s> function canPatchViaPropertyDescriptor() {<EOL>    if ((isBrowser || isMix) && !ObjectGetOwnPropertyDescriptor(HTMLElement.prototype, '<STR_LIT>') &&<EOL>         typeof Element !== '<STR_LIT>') {<EOL>        <EOL>        <EOL>        const desc = ObjectGetOwnPropertyDescriptor(Element.prototype,  '<STR_LIT>');<EOL>        if (desc && !desc.configurable)<EOL>            return  false;<EOL>    }<EOL>    const ON_READY_STATE_CHANGE = '<STR_LIT>';<EOL>     const XMLHttpRequestPrototype = XMLHttpRequest.prototype;<EOL>    const xhrDesc = ObjectGetOwnPropertyDescriptor(XMLHttpRequestPrototype, ON_READY_STATE_CHANGE);<EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    if (xhrDesc) {<EOL>        ObjectDefineProperty(XMLHttpRequestPrototype, ON_READY_STATE_CHANGE, {<EOL>            enumerable:  true,<EOL>            configurable: true,<EOL>            get: function () {<EOL>                return true;<EOL>            }<EOL>        });<EOL>        const req = new  XMLHttpRequest();<EOL>        const result = !!req.onreadystatechange;<EOL>        <EOL>        ObjectDefineProperty(XMLHttpRequestPrototype, ON_READY_STATE_CHANGE, xhrDesc || {});<EOL>        return result;<EOL>    }<EOL>    else {<EOL>        const SYMBOL_FAKE_ONREADYSTATECHANGE = zoneSymbol('<STR_LIT>');<EOL>        ObjectDefineProperty(XMLHttpRequestPrototype, ON_READY_STATE_CHANGE, {<EOL>            enumerable: true,<EOL>            configurable: true,<EOL>            get: function () {<EOL>                 return this[SYMBOL_FAKE_ONREADYSTATECHANGE];<EOL>            },<EOL>            set: function (value) {<EOL>                this[SYMBOL_FAKE_ONREADYSTATECHANGE] = value;<EOL>            }<EOL>        });<EOL>","gt":"const req = new XMLHttpRequest();"}
{"input":"<s> export function bindArguments(args, source) {<EOL>    for (let i = args.length - <NUM_LIT>; i >= <NUM_LIT>; i--) {<EOL>        if (typeof args[","gt":"i] === '<STR_LIT>') {"}
{"input":"<s> export function wrapWithCurrentZone(callback, source) {<EOL>    return Zone.current.wrap(callback,","gt":"source);"}
{"input":"<s> function ieOrEdge() {<EOL>","gt":"return isIEOrEdge();"}
{"input":"<s> function supportsImports() {<EOL>    return '<STR_LIT>'","gt":"in document.createElement('<STR_LIT>');"}
{"input":"<s> function _ifEnvSupports(test, block, withDone = false) {<EOL>    if (withDone) {<EOL>        return function (done) {<EOL>            _runTest(test, block, done);<EOL>        };<EOL>    }<EOL>    else {<EOL>        return function () {<EOL>            _runTest(","gt":"test, block, undefined);"}
{"input":"<s> function supportNode() {<EOL>","gt":"return isNode;"}
{"input":"<s> function requestFactory(url, headersObj) {<EOL>    return (query, variables, operationName, forwardHeaders) => {<EOL>        return fetch(url, {<EOL>            method: '<STR_LIT>',<EOL>            headers: new","gt":"Headers({"}
{"input":"<s> function requestFactory(url, headersObj) {<EOL>    return (query, variables, operationName, forwardHeaders) => {<EOL>        return fetch(url, {<EOL>            method: '<STR_LIT>',<EOL>            headers: new  Headers({<EOL>                \"<STR_LIT>\": '<STR_LIT>',<EOL>                ...headersObj,<EOL>                ...","gt":"forwardHeaders,"}
{"input":"<s> function requestFactory(url, headersObj) {<EOL>    return (query, variables, operationName, forwardHeaders) => {<EOL>        return fetch(url, {<EOL>            method: '<STR_LIT>',<EOL>            headers: new  Headers({<EOL>                \"<STR_LIT>\": '<STR_LIT>',<EOL>                ...headersObj,<EOL>                ... forwardHeaders,<EOL>            }),<EOL>            body: JSON.stringify({<EOL>                operationName,<EOL>                query,<EOL>","gt":"variables,"}
{"input":"<s> function requestFactory(url, headersObj) {<EOL>    return (query, variables, operationName, forwardHeaders) => {<EOL>        return fetch(url, {<EOL>            method: '<STR_LIT>',<EOL>            headers: new  Headers({<EOL>                \"<STR_LIT>\": '<STR_LIT>',<EOL>                ...headersObj,<EOL>                ... forwardHeaders,<EOL>            }),<EOL>            body: JSON.stringify({<EOL>                operationName,<EOL>                query,<EOL>                 variables,<EOL>            })<EOL>        }).then((responce) => {<EOL>            if (responce.ok)<EOL>                return responce.","gt":"json();"}
{"input":"<s> function isLink(elem) {<EOL>    return elem.classList.contains(","gt":"'<STR_LIT>');"}
{"input":"<s> export function configureStore(preloadedState) {<EOL>    let composeEnhancers;<EOL>    if (DEBUG) {<EOL>        composeEnhancers = window[","gt":"'<STR_LIT>'] || compose;"}
{"input":"<s> <EOL>export function variablesInOperation(operation) {<EOL>    const names = new Set();<EOL>    if (operation.variableDefinitions) {<EOL>        for (const definition","gt":"of operation.variableDefinitions) {"}
{"input":"<s> function buildWareStack(funcs, modifiedObject, resolve) {<EOL>    const next = () => {<EOL>        if (funcs.length > <NUM_LIT>) {<EOL>            const f = funcs.shift();<EOL>            if (","gt":"f) {"}
{"input":"<s> function addErrorLoggingToSchema(schema, logger) {<EOL>    if (!logger) {<EOL>        throw new Error('<STR_LIT>');<EOL>    }<EOL>","gt":"if (typeof logger.log !== '<STR_LIT>') {"}
{"input":"<s> function addErrorLoggingToSchema(schema, logger) {<EOL>    if (!logger) {<EOL>        throw new Error('<STR_LIT>');<EOL>    }<EOL>     if (typeof logger.log !== '<STR_LIT>') {<EOL>        throw new Error('<STR_LIT>');<EOL>    }<EOL>    forEachField(schema, (field, typeName, fieldName) => {<EOL>        const errorHint =","gt":"typeName}.${fieldName}`<STR_LIT>;"}
{"input":"<s> function assertResolveFunctionsPresent(schema, resolverValidationOptions = {}) {<EOL>    const { requireResolversForArgs = false, requireResolversForNonScalar = false, requireResolversForAllFields = false, } = resolverValidationOptions;<EOL>    if (requireResolversForAllFields &&<EOL>        (requireResolversForArgs || requireResolversForNonScalar)) {<EOL>        throw new TypeError('<STR_LIT>' +<EOL>","gt":"'<STR_LIT>' +"}
{"input":"<s> export function extractExtensionDefinitions(ast) {<EOL>    const extensionDefs = ast.definitions.filter((def) => def.kind === oldTypeExtensionDefinitionKind ||<EOL>        def.kind","gt":"=== newExtensionDefinitionKind);"}
{"input":"<s> <EOL><EOL>function makePromise(observable) {<EOL>    let completed = false;<EOL>    return new Promise((resolve, reject) => {<EOL>        observable.subscribe({<EOL>            next: (data) => {<EOL>                if (","gt":"completed) {"}
{"input":"<s> <EOL><EOL>function makePromise(observable) {<EOL>    let completed = false;<EOL>    return new Promise((resolve, reject) => {<EOL>        observable.subscribe({<EOL>            next: (data) => {<EOL>                if ( completed) {<EOL>                    console.warn(`<STR_LIT>`);<EOL>                }<EOL>                else {<EOL>","gt":"completed = true;"}
{"input":"<s> <EOL>export function isIOS() {<EOL>    if (typeof window !== '<STR_LIT>' && typeof navigator !== '<STR_LIT>') {<EOL>        return /iPad|iPhone|iPod/.test(navigator.userAgent) && !","gt":"window.MSStream;"}
{"input":"<s> <EOL><EOL><EOL><EOL><EOL><EOL>export function decodeTag(token) {<EOL>    if (token.tag === '<STR_LIT>') {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>","gt":"if (token.tag === '<STR_LIT>') {"}
{"input":"<s> <EOL><EOL><EOL><EOL><EOL><EOL>export function decodeTag(token) {<EOL>    if (token.tag === '<STR_LIT>') {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>     if (token.tag === '<STR_LIT>') {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    if (token.tag === '<STR_LIT>') {<EOL>","gt":"return null;"}
{"input":"<s> export function mkHtml(title, html, renderLaTeX, useGithubStyle) {<EOL>    const githubStyle = useGithubStyle ? '<STR_LIT>' : '<STR_LIT>';<EOL>    let maybeMathJaxScript;<EOL>    if (","gt":"renderLaTeX) {"}
{"input":"<s> <EOL>function getUserMacrosPath() {<EOL>    const userMacrosPath = CSON.resolve(path.join(atom.getConfigDirPath(), '<STR_LIT>'));<EOL>    return","gt":"userMacrosPath != null"}
{"input":"<s> <EOL>export async function renderPandoc(text, filePath, renderMath) {<EOL>    const { args, opts } = setPandocOptions(filePath, renderMath);<EOL>    return new Promise((resolve, reject) => {<EOL>        const cp = CP.execFile(atomConfig().pandocPath, getArguments(args), opts, function (error, stdout, stderr) {<EOL>","gt":"if (error) {"}
{"input":"<s> <EOL>export async function renderPandoc(text, filePath, renderMath) {<EOL>    const { args, opts } = setPandocOptions(filePath, renderMath);<EOL>    return new Promise((resolve, reject) => {<EOL>        const cp = CP.execFile(atomConfig().pandocPath, getArguments(args), opts, function (error, stdout, stderr) {<EOL>             if (error) {<EOL>                atom.notifications.addError(error.toString(), {<EOL>                    stack: error.stack,<EOL>","gt":"dismissable: true,"}
{"input":"<s> <EOL>export async function renderPandoc(text, filePath, renderMath) {<EOL>    const { args, opts } = setPandocOptions(filePath, renderMath);<EOL>    return new Promise((resolve, reject) => {<EOL>        const cp = CP.execFile(atomConfig().pandocPath, getArguments(args), opts, function (error, stdout, stderr) {<EOL>             if (error) {<EOL>                atom.notifications.addError(error.toString(), {<EOL>                    stack: error.stack,<EOL>                     dismissable: true,<EOL>                });<EOL>                reject(error);<EOL>            }<EOL>            try {<EOL>                const result = handleResponse(","gt":"stderr || '<STR_LIT>', stdout || '<STR_LIT>', renderMath);"}
{"input":"<s> <EOL>export async function renderPandoc(text, filePath, renderMath) {<EOL>    const { args, opts } = setPandocOptions(filePath, renderMath);<EOL>    return new Promise((resolve, reject) => {<EOL>        const cp = CP.execFile(atomConfig().pandocPath, getArguments(args), opts, function (error, stdout, stderr) {<EOL>             if (error) {<EOL>                atom.notifications.addError(error.toString(), {<EOL>                    stack: error.stack,<EOL>                     dismissable: true,<EOL>                });<EOL>                reject(error);<EOL>            }<EOL>            try {<EOL>                const result = handleResponse( stderr || '<STR_LIT>', stdout || '<STR_LIT>', renderMath);<EOL>                resolve(result);<EOL>            }<EOL>            catch (e) {<EOL>                reject(","gt":"e);"}
{"input":"<s> export function stringTo32ByteHex(stringToEncode) {<EOL>    return","gt":"<NUM_LIT>, '<STR_LIT>')}`<STR_LIT>;"}
{"input":"<s> <EOL>export function fetchLineItems(state) {<EOL>    const ids =","gt":"state.lineItemIds.toJS();"}
{"input":"<s> function fetchSelectedTaxonIds(state) {<EOL>    return","gt":"state.selectedTaxonIds.toJS();"}
{"input":"<s> export function reducer(state = initialState, { type, payload }) {<EOL>    switch (type) {<EOL>        case UserActions.","gt":"GET_USER_ORDERS_SUCCESS:"}
{"input":"<s> function shallowMerge(existing, more) {<EOL>    if (existing && more) {<EOL>        for (const key of Object.getOwnPropertyNames(more)) {<EOL>            const value = more[key];<EOL>            if (value !== undefined) {<EOL>                <EOL>                existing[key] = value;<EOL>            }<EOL>        }<EOL>        return existing;<EOL>    }<EOL>    if (","gt":"existing) {"}
{"input":"<s> export function isLegacy(args) {<EOL>    return args.some((arg) => regexLegacyArg.test(","gt":"arg));"}
{"input":"<s> export function matches(jsonQuery, jsonPath) {<EOL>    <EOL>    const leafNode = new Object();<EOL>    const obj = CreateObject(","gt":"jsonPath, leafNode);"}
{"input":"<s> <EOL>function isAbsolute(path) {<EOL>","gt":"return !!path.match(/^([a-zA-Z]:)?(\\/|\\\\)/);"}
{"input":"<s> <EOL>export function IsUri(uri) {<EOL>    return /^([a-z0-9+.-]+):(?:\\/\\/(?:((?:[a-z0-9-._~!$&'()*+,;=:]|%[0-9A-F]{2})*)@)?((?:[a-z0-9-._~!$&'()*+,;=]|%[0-9A-F]{2})*)(?::(\\d*))?(\\/(?:[a-z0-9-._~!$&'()*+,;=:@/]|%[0-9A-F]{2})*)?|(\\/?(?:[a-z0-9-._~!$&'()*+,;=:@]|%[0-9A-F]{2})+(?:[a-z0-9-._~!$&'()*+,;=:@/]|%[0-9A-F]{2})*)?)(?:\\?((?:[a-z0-9-._~!$&'()*+,;=:/?@]|%[0-9A-F]{2})*))?(?:#((?:[a-z0-9-._~!$&'()*+,;=:/?@]|%[0-9A-F]{2})*))?$/i.test(","gt":"uri);"}
{"input":"<s> export function CreateAssignmentMapping(assignedObject, sourceKey, sourcePath, targetPath, subject) {<EOL>    const result = [];<EOL>    for (const descendant of Descendants(ToAst(assignedObject))) {<EOL>        const path = descendant.path;<EOL>        result.","gt":"push({"}
{"input":"<s> <EOL>export async function toJSON(content) {<EOL>    await","gt":"ensureCoreLoaded();"}
{"input":"<s> function checkDellTag(tag) {<EOL>    tag = tag.toUpperCase();<EOL>    for (let tagItem in DellTag) {<EOL>        if (tag === DellTag[","gt":"tagItem]) {"}
{"input":"<s> <EOL>function checkSuffix(serial, tag, type) {<EOL>    serial = serial.","gt":"concat(tag);"}
{"input":"<s> function makeMonotonicTime() {<EOL>    if (typeof performance !== \"<STR_LIT>\" && performance) {<EOL>        let nowFun = performance.now ||<EOL>            performance.webkitNow ||<EOL>            performance.mozNow ||<EOL>            performance.","gt":"oNow ||"}
{"input":"<s> function printAllChildren(node, depth = <NUM_LIT>) {<EOL>    console.log(new Array(depth + <NUM_LIT>).join('<STR_LIT>'),","gt":"ts.syntaxKindToName(node.kind), node.pos, node.end);"}
{"input":"<s> function myApp() {<EOL>    import( \"<STR_LIT>\")<EOL>        .then((moment) => {<EOL>        <EOL>        <EOL>        const time = moment().format();<EOL>        console.log(\"<STR_LIT>\");<EOL>        console.log(time);<EOL>    })<EOL>        .","gt":"catch((err) => {"}
{"input":"<s> function doNotRun(test, done) {<EOL>    if (awsAccessKeyId === undefined || awsSecretAccessKey === undefined) {<EOL>        console.warn(","gt":"\"<STR_LIT>\");"}
{"input":"<s> export function getConfigPath() {<EOL>    return process.env.","gt":"NODE_ENV !== '<STR_LIT>' ? `<STR_LIT>` : `<STR_LIT>`;"}
{"input":"<s> export function create(config) {<EOL>    return new","gt":"BrokerAdapterImpl(config);"}
{"input":"<s> export default function form(obj) {<EOL>    const form = new FormData();<EOL>    if (obj) {<EOL>        Object.keys(obj).forEach(","gt":"function (name) {"}
{"input":"<s> <EOL>export function createTransport(options) {<EOL>    return {<EOL>        use,<EOL>","gt":"abort,"}
{"input":"<s> function auth(username, password) {<EOL>    return (req, res, next) => {<EOL>        const user = basicAuth(req);<EOL>        if (!user ||","gt":"user.name !== username || user.pass !== password) {"}
{"input":"<s> export function changeDefaultReducer(newReducer) {<EOL>    DEFAULT_REDUCER =","gt":"newReducer;"}
{"input":"<s> function cloneNodeArray(a) {<EOL>    a = a.slice(<NUM_LIT>);<EOL>    for (var i = <NUM_LIT>; i < a.length; i++) {<EOL>        var n = a[i];<EOL>        if (isArray(","gt":"n)) {"}
{"input":"<s> export function nodeOnPoint(x, y) {<EOL>    var target = document.elementFromPoint(x, y);<EOL>    var node = deref(target);<EOL>    if (hasPointerEventsNoneB(node)) {<EOL>","gt":"var fixed = pointerEventsNoneFix(x, y, target, node);"}
{"input":"<s> export function nodeOnPoint(x, y) {<EOL>    var target = document.elementFromPoint(x, y);<EOL>    var node = deref(target);<EOL>    if (hasPointerEventsNoneB(node)) {<EOL>         var fixed = pointerEventsNoneFix(x, y, target, node);<EOL>        node = fixed[","gt":"<NUM_LIT>];"}
{"input":"<s> function closeDropdown() {<EOL>    if ($dropdown) {<EOL>","gt":"PopUpManager.removePopUp($dropdown);"}
{"input":"<s> function closeNotExistingFiles(oldBranchName, newBranchName) {<EOL>    return Git.getDeletedFiles(oldBranchName, newBranchName).then((deletedFiles) => {<EOL>        const gitRoot = Preferences.get(\"<STR_LIT>\");<EOL>        const openedFiles = MainViewManager.getWorkingSet(MainViewManager.ALL_PANES);<EOL>        <EOL>        deletedFiles.forEach((","gt":"dFile) => {"}
{"input":"<s> function closeNotExistingFiles(oldBranchName, newBranchName) {<EOL>    return Git.getDeletedFiles(oldBranchName, newBranchName).then((deletedFiles) => {<EOL>        const gitRoot = Preferences.get(\"<STR_LIT>\");<EOL>        const openedFiles = MainViewManager.getWorkingSet(MainViewManager.ALL_PANES);<EOL>        <EOL>        deletedFiles.forEach(( dFile) => {<EOL>            const oFile = _.find(openedFiles, (f) => f.fullPath === gitRoot + dFile);<EOL>            if (oFile) {<EOL>                DocumentManager.closeFullEditor(oFile);<EOL>            }<EOL>        });<EOL>        EventEmitter.emit(","gt":"Events.REFRESH_ALL);"}
{"input":"<s> export function show(promise, title = null, options = {}) {<EOL>    if (!promise || !promise.finally || !promise.progressed) {<EOL>        throw new Error(\"<STR_LIT>\");<EOL>    }<EOL>    if (typeof title === \"<STR_LIT>\") {<EOL>","gt":"options = title;"}
{"input":"<s> export function show(promise, title = null, options = {}) {<EOL>    if (!promise || !promise.finally || !promise.progressed) {<EOL>        throw new Error(\"<STR_LIT>\");<EOL>    }<EOL>    if (typeof title === \"<STR_LIT>\") {<EOL>         options = title; <EOL>        title = false; <EOL>    }<EOL>    options = options || {}; <EOL>    return new Promise((resolve, reject) => {<EOL>","gt":"lines = [];"}
{"input":"<s> export function show(promise, title = null, options = {}) {<EOL>    if (!promise || !promise.finally || !promise.progressed) {<EOL>        throw new Error(\"<STR_LIT>\");<EOL>    }<EOL>    if (typeof title === \"<STR_LIT>\") {<EOL>         options = title; <EOL>        title = false; <EOL>    }<EOL>    options = options || {}; <EOL>    return new Promise((resolve, reject) => {<EOL>         lines = [];<EOL>        $textarea =","gt":"null;"}
{"input":"<s> export function show(promise, title = null, options = {}) {<EOL>    if (!promise || !promise.finally || !promise.progressed) {<EOL>        throw new Error(\"<STR_LIT>\");<EOL>    }<EOL>    if (typeof title === \"<STR_LIT>\") {<EOL>         options = title; <EOL>        title = false; <EOL>    }<EOL>    options = options || {}; <EOL>    return new Promise((resolve, reject) => {<EOL>         lines = [];<EOL>        $textarea =  null;<EOL>        let dialog;<EOL>        let finished = false;<EOL>        function showDialog() {<EOL>            if (finished) {<EOL>","gt":"return;"}
{"input":"<s> export function show(promise, title = null, options = {}) {<EOL>    if (!promise || !promise.finally || !promise.progressed) {<EOL>        throw new Error(\"<STR_LIT>\");<EOL>    }<EOL>    if (typeof title === \"<STR_LIT>\") {<EOL>         options = title; <EOL>        title = false; <EOL>    }<EOL>    options = options || {}; <EOL>    return new Promise((resolve, reject) => {<EOL>         lines = [];<EOL>        $textarea =  null;<EOL>        let dialog;<EOL>        let finished = false;<EOL>        function showDialog() {<EOL>            if (finished) {<EOL>                 return;<EOL>            }<EOL>            const templateArgs = { title: title || Strings.OPERATION_IN_PROGRESS_TITLE, Strings };<EOL>            const compiledTemplate = Mustache.render(","gt":"template, templateArgs);"}
{"input":"<s> export function show(promise, title = null, options = {}) {<EOL>    if (!promise || !promise.finally || !promise.progressed) {<EOL>        throw new Error(\"<STR_LIT>\");<EOL>    }<EOL>    if (typeof title === \"<STR_LIT>\") {<EOL>         options = title; <EOL>        title = false; <EOL>    }<EOL>    options = options || {}; <EOL>    return new Promise((resolve, reject) => {<EOL>         lines = [];<EOL>        $textarea =  null;<EOL>        let dialog;<EOL>        let finished = false;<EOL>        function showDialog() {<EOL>            if (finished) {<EOL>                 return;<EOL>            }<EOL>            const templateArgs = { title: title || Strings.OPERATION_IN_PROGRESS_TITLE, Strings };<EOL>            const compiledTemplate = Mustache.render( template, templateArgs);<EOL>            dialog = Dialogs.showModalDialogUsingTemplate(compiledTemplate);<EOL>            $textarea = dialog.getElement().find(\"<STR_LIT>\");<EOL>            onProgress();<EOL>        }<EOL>        function finish() {<EOL>            finished = true;<EOL>","gt":"if (dialog) {"}
{"input":"<s> export function show(promise, title = null, options = {}) {<EOL>    if (!promise || !promise.finally || !promise.progressed) {<EOL>        throw new Error(\"<STR_LIT>\");<EOL>    }<EOL>    if (typeof title === \"<STR_LIT>\") {<EOL>         options = title; <EOL>        title = false; <EOL>    }<EOL>    options = options || {}; <EOL>    return new Promise((resolve, reject) => {<EOL>         lines = [];<EOL>        $textarea =  null;<EOL>        let dialog;<EOL>        let finished = false;<EOL>        function showDialog() {<EOL>            if (finished) {<EOL>                 return;<EOL>            }<EOL>            const templateArgs = { title: title || Strings.OPERATION_IN_PROGRESS_TITLE, Strings };<EOL>            const compiledTemplate = Mustache.render( template, templateArgs);<EOL>            dialog = Dialogs.showModalDialogUsingTemplate(compiledTemplate);<EOL>            $textarea = dialog.getElement().find(\"<STR_LIT>\");<EOL>            onProgress();<EOL>        }<EOL>        function finish() {<EOL>            finished = true;<EOL>             if (dialog) {<EOL>                dialog.close();<EOL>            }<EOL>            promise<EOL>                .then((val) => resolve(val))<EOL>                .catch((err) => reject(err));<EOL>        }<EOL>        if (!options.preDelay) {<EOL>            showDialog();<EOL>        }<EOL>        else {<EOL>            setTimeout(() => showDialog(), options.","gt":"preDelay * <NUM_LIT>);"}
{"input":"<s> export function show(promise, title = null, options = {}) {<EOL>    if (!promise || !promise.finally || !promise.progressed) {<EOL>        throw new Error(\"<STR_LIT>\");<EOL>    }<EOL>    if (typeof title === \"<STR_LIT>\") {<EOL>         options = title; <EOL>        title = false; <EOL>    }<EOL>    options = options || {}; <EOL>    return new Promise((resolve, reject) => {<EOL>         lines = [];<EOL>        $textarea =  null;<EOL>        let dialog;<EOL>        let finished = false;<EOL>        function showDialog() {<EOL>            if (finished) {<EOL>                 return;<EOL>            }<EOL>            const templateArgs = { title: title || Strings.OPERATION_IN_PROGRESS_TITLE, Strings };<EOL>            const compiledTemplate = Mustache.render( template, templateArgs);<EOL>            dialog = Dialogs.showModalDialogUsingTemplate(compiledTemplate);<EOL>            $textarea = dialog.getElement().find(\"<STR_LIT>\");<EOL>            onProgress();<EOL>        }<EOL>        function finish() {<EOL>            finished = true;<EOL>             if (dialog) {<EOL>                dialog.close();<EOL>            }<EOL>            promise<EOL>                .then((val) => resolve(val))<EOL>                .catch((err) => reject(err));<EOL>        }<EOL>        if (!options.preDelay) {<EOL>            showDialog();<EOL>        }<EOL>        else {<EOL>            setTimeout(() => showDialog(), options. preDelay * <NUM_LIT>);<EOL>        }<EOL>        promise<EOL>            .progressed((string) => onProgress(string))<EOL>            .","gt":"finally(() => {"}
{"input":"<s> export function show(promise, title = null, options = {}) {<EOL>    if (!promise || !promise.finally || !promise.progressed) {<EOL>        throw new Error(\"<STR_LIT>\");<EOL>    }<EOL>    if (typeof title === \"<STR_LIT>\") {<EOL>         options = title; <EOL>        title = false; <EOL>    }<EOL>    options = options || {}; <EOL>    return new Promise((resolve, reject) => {<EOL>         lines = [];<EOL>        $textarea =  null;<EOL>        let dialog;<EOL>        let finished = false;<EOL>        function showDialog() {<EOL>            if (finished) {<EOL>                 return;<EOL>            }<EOL>            const templateArgs = { title: title || Strings.OPERATION_IN_PROGRESS_TITLE, Strings };<EOL>            const compiledTemplate = Mustache.render( template, templateArgs);<EOL>            dialog = Dialogs.showModalDialogUsingTemplate(compiledTemplate);<EOL>            $textarea = dialog.getElement().find(\"<STR_LIT>\");<EOL>            onProgress();<EOL>        }<EOL>        function finish() {<EOL>            finished = true;<EOL>             if (dialog) {<EOL>                dialog.close();<EOL>            }<EOL>            promise<EOL>                .then((val) => resolve(val))<EOL>                .catch((err) => reject(err));<EOL>        }<EOL>        if (!options.preDelay) {<EOL>            showDialog();<EOL>        }<EOL>        else {<EOL>            setTimeout(() => showDialog(), options. preDelay * <NUM_LIT>);<EOL>        }<EOL>        promise<EOL>            .progressed((string) => onProgress(string))<EOL>            . finally(() => {<EOL>            onProgress(\"<STR_LIT>\");<EOL>            if (!options.postDelay || !dialog) {<EOL>","gt":"finish();"}
{"input":"<s> export function isTimeout(err) {<EOL>    return err instanceof Error && (err.","gt":"message.indexOf(\"<STR_LIT>\") === <NUM_LIT> ||"}
{"input":"<s> <EOL>function loadRegistryInfo() {<EOL>    const registryInfo = ExtensionManager.extensions[packageJson.name].registryInfo;<EOL>","gt":"if (!registryInfo) {"}
{"input":"<s> export function difftool(file) {<EOL>    return _isFileStaged(file).then((staged) => {<EOL>        const args = [\"<STR_LIT>\"];<EOL>        if (staged) {<EOL>","gt":"args.push(\"<STR_LIT>\");"}
{"input":"<s> export function difftool(file) {<EOL>    return _isFileStaged(file).then((staged) => {<EOL>        const args = [\"<STR_LIT>\"];<EOL>        if (staged) {<EOL>             args.push(\"<STR_LIT>\");<EOL>        }<EOL>        args.push(\"<STR_LIT>\", file);<EOL>        return git(args, {<EOL>            timeout: false,<EOL>            nonblocking:","gt":"true"}
{"input":"<s> export function mergeBranch(branchName, mergeMessage, useNoff) {<EOL>    const args = [\"<STR_LIT>\"];<EOL>    if (useNoff) {<EOL>","gt":"args.push(\"<STR_LIT>\");"}
{"input":"<s> <EOL><EOL>export function push(remoteName, remoteBranch, additionalArgs) {<EOL>    if (!remoteName) {<EOL>        throw new TypeError(\"<STR_LIT>\");<EOL>    }<EOL>    let args = [\"<STR_LIT>\", \"<STR_LIT>\", \"<STR_LIT>\"];<EOL>    if (Array.","gt":"isArray(additionalArgs)) {"}
{"input":"<s> <EOL><EOL>export function push(remoteName, remoteBranch, additionalArgs) {<EOL>    if (!remoteName) {<EOL>        throw new TypeError(\"<STR_LIT>\");<EOL>    }<EOL>    let args = [\"<STR_LIT>\", \"<STR_LIT>\", \"<STR_LIT>\"];<EOL>    if (Array. isArray(additionalArgs)) {<EOL>        args = args.concat(additionalArgs);<EOL>    }<EOL>","gt":"args.push(remoteName);"}
{"input":"<s> export function getAllBranches() {<EOL>    return GitCli.getAllBranches().then((branches) =>","gt":"sortBranches(branches));"}
{"input":"<s> export function isVisible() {<EOL>    return","gt":"isShown;"}
{"input":"<s> <EOL>function initUi() {<EOL>    <EOL>    Panel.","gt":"init();"}
{"input":"<s> function spawnIfExists(directory, command, args, opts, callback) {<EOL>    return doIfExists(spawn, directory, command, args,","gt":"opts, callback);"}
{"input":"<s> function _getCurrentFilePath(editor) {<EOL>    const gitRoot = Preferences.get(\"<STR_LIT>\");<EOL>    const document = editor ? editor.document : DocumentManager.getCurrentDocument();<EOL>","gt":"let filePath = document.file.fullPath;"}
{"input":"<s> export function consoleDebug(msg) {<EOL>","gt":"if (debugOn) {"}
{"input":"<s> function chmodTerminalScript(allowExec) {<EOL>    const files = platform === \"<STR_LIT>\" ? [<EOL>        <EOL>        \"<STR_LIT>\",<EOL>","gt":"\"<STR_LIT>\""}
{"input":"<s> function chmodTerminalScript(allowExec) {<EOL>    const files = platform === \"<STR_LIT>\" ? [<EOL>        <EOL>        \"<STR_LIT>\",<EOL>         \"<STR_LIT>\"<EOL>    ] : [<EOL>        <EOL>        \"<STR_LIT>\"<EOL>    ];<EOL>    const args = [allowExec ? \"<STR_LIT>\" : \"<STR_LIT>\"].concat(files.map((file) => {<EOL>        return Cli.escapeShellArg(Utils.getExtensionDirectory() +","gt":"\"<STR_LIT>\" + file);"}
{"input":"<s> function getFailedResultStatistics() {<EOL>    const statistics = { m500: {}, noRes: {}, testFailed: {} };<EOL>    const build = (type) => _.keys(stressFailedResult[type]).","gt":"forEach((k) => statistics[type][k] = stressFailedResult[type][k].length);"}
{"input":"<s> function workerStarted(addr) {<EOL>","gt":"workers[addr].status = WorkerStatus.working;"}
{"input":"<s> function formatUsage(usage) {<EOL>    return","gt":"usage.replace(/~~~/g, '<STR_LIT>').replace(/(^[ \\t]*\\n)/gm, '<STR_LIT>').replace(/^    /mg, '<STR_LIT>');"}
{"input":"<s> function updateRuleFiles(cb) {<EOL>    const ruleDir = '<STR_LIT>';<EOL>    const allFiles = fs.readdirSync(ruleDir).filter((file) => fs.lstatSync(path.join(ruleDir, file)).isFile());<EOL>    const ruleNames = allFiles<EOL>        .filter((name) => /\\.ts$/.test(name))<EOL>        .map((name) => name.substr(<NUM_LIT>, name.","gt":"length - <NUM_LIT>));"}
{"input":"<s> function updateRuleFiles(cb) {<EOL>    const ruleDir = '<STR_LIT>';<EOL>    const allFiles = fs.readdirSync(ruleDir).filter((file) => fs.lstatSync(path.join(ruleDir, file)).isFile());<EOL>    const ruleNames = allFiles<EOL>        .filter((name) => /\\.ts$/.test(name))<EOL>        .map((name) => name.substr(<NUM_LIT>, name. length - <NUM_LIT>));<EOL>    const allPromises = [];<EOL>    ruleNames.forEach((name) => {<EOL>        allPromises.push(updateRuleFile(name, ruleTSMap[name]));<EOL>    });<EOL>    <EOL>    Promise.all(allPromises).","gt":"then(() => {"}
{"input":"<s> function walk(ctx) {<EOL>    const TAB_REGEX = /\\t/;<EOL>    const lines = ctx.sourceFile.text.split(/\\n/g);<EOL>","gt":"lines.forEach((line, i) => {"}
{"input":"<s> <EOL>function compatibleListener(eventNames, prefixes) {<EOL>    let mem;<EOL>    const prefixedEvents = eventPrefixed(eventNames, prefixes);<EOL>    return (element) => {<EOL>        <EOL>        <EOL>        if (element instanceof HTMLElement_) {<EOL>            if (typeof mem === \"<STR_LIT>\") {<EOL>                mem =","gt":"findSupportedEvent(element, prefixedEvents);"}
{"input":"<s> <EOL>function compatibleListener(eventNames, prefixes) {<EOL>    let mem;<EOL>    const prefixedEvents = eventPrefixed(eventNames, prefixes);<EOL>    return (element) => {<EOL>        <EOL>        <EOL>        if (element instanceof HTMLElement_) {<EOL>            if (typeof mem === \"<STR_LIT>\") {<EOL>                mem =  findSupportedEvent(element, prefixedEvents);<EOL>            }<EOL>            if (mem) {<EOL>                return","gt":"Observable.fromEvent(element, mem);"}
{"input":"<s> <EOL>function compatibleListener(eventNames, prefixes) {<EOL>    let mem;<EOL>    const prefixedEvents = eventPrefixed(eventNames, prefixes);<EOL>    return (element) => {<EOL>        <EOL>        <EOL>        if (element instanceof HTMLElement_) {<EOL>            if (typeof mem === \"<STR_LIT>\") {<EOL>                mem =  findSupportedEvent(element, prefixedEvents);<EOL>            }<EOL>            if (mem) {<EOL>                return  Observable.fromEvent(element, mem);<EOL>            }<EOL>            else {<EOL>                if (","gt":"__DEV__) {"}
{"input":"<s> <EOL>function compatibleListener(eventNames, prefixes) {<EOL>    let mem;<EOL>    const prefixedEvents = eventPrefixed(eventNames, prefixes);<EOL>    return (element) => {<EOL>        <EOL>        <EOL>        if (element instanceof HTMLElement_) {<EOL>            if (typeof mem === \"<STR_LIT>\") {<EOL>                mem =  findSupportedEvent(element, prefixedEvents);<EOL>            }<EOL>            if (mem) {<EOL>                return  Observable.fromEvent(element, mem);<EOL>            }<EOL>            else {<EOL>                if ( __DEV__) {<EOL>                    <EOL>                    log.warn(`<STR_LIT>`<EOL>                    <EOL>                    );<EOL>                }<EOL>","gt":"return Observable.never();"}
{"input":"<s> <EOL>function findFirstOptimalAudioAdaptation(audioAdaptations, preferredAudioTracks) {<EOL>    if (!audioAdaptations.length) {<EOL>        return null;<EOL>    }<EOL>    for (let i = <NUM_LIT>; i < preferredAudioTracks.length; i++) {<EOL>        const preferredAudioTrack =","gt":"preferredAudioTracks[i];"}
{"input":"<s> <EOL>function findFirstOptimalAudioAdaptation(audioAdaptations, preferredAudioTracks) {<EOL>    if (!audioAdaptations.length) {<EOL>        return null;<EOL>    }<EOL>    for (let i = <NUM_LIT>; i < preferredAudioTracks.length; i++) {<EOL>        const preferredAudioTrack =  preferredAudioTracks[i];<EOL>        if (preferredAudioTrack === null) {<EOL>            return null;<EOL>        }<EOL>        const foundAdaptation = arrayFind(audioAdaptations, (audioAdaptation) => (audioAdaptation.normalizedLanguage || \"<STR_LIT>\") === preferredAudioTrack.","gt":"normalized &&"}
{"input":"<s> <EOL>function clearEME() {<EOL>    return Observable.defer(() => {<EOL>        const observablesArray = [];<EOL>        if (instanceInfos.$videoElement && shouldUnsetMediaKeys()) {<EOL>            const obs$ = disposeMediaKeys(instanceInfos.$videoElement)<EOL>                .ignoreElements()<EOL>                .","gt":"finally(() => {"}
{"input":"<s> <EOL>function clearEME() {<EOL>    return Observable.defer(() => {<EOL>        const observablesArray = [];<EOL>        if (instanceInfos.$videoElement && shouldUnsetMediaKeys()) {<EOL>            const obs$ = disposeMediaKeys(instanceInfos.$videoElement)<EOL>                .ignoreElements()<EOL>                . finally(() => {<EOL>                instanceInfos.$videoElement = null;<EOL>            });<EOL>            observablesArray.push(obs$);<EOL>        }<EOL>        if (instanceInfos.$keySystem && instanceInfos.$keySystem.closeSessionsOnStop) {<EOL>            observablesArray.push($loadedSessions.dispose()<EOL>                .","gt":"ignoreElements());"}
{"input":"<s> <EOL>function handleEncryptedEvents(encryptedEvent, keySystemInfo, video, errorStream) {<EOL>    const { keySystem, keySystemAccess } = keySystemInfo;<EOL>    if (keySystem.persistentLicense) {<EOL>        if (keySystem.","gt":"licenseStorage) {"}
{"input":"<s> <EOL>function handleEncryptedEvents(encryptedEvent, keySystemInfo, video, errorStream) {<EOL>    const { keySystem, keySystemAccess } = keySystemInfo;<EOL>    if (keySystem.persistentLicense) {<EOL>        if (keySystem. licenseStorage) {<EOL>            $storedSessions.setStorage(keySystem.licenseStorage);<EOL>        }<EOL>","gt":"else {"}
{"input":"<s> <EOL>function handleEncryptedEvents(encryptedEvent, keySystemInfo, video, errorStream) {<EOL>    const { keySystem, keySystemAccess } = keySystemInfo;<EOL>    if (keySystem.persistentLicense) {<EOL>        if (keySystem. licenseStorage) {<EOL>            $storedSessions.setStorage(keySystem.licenseStorage);<EOL>        }<EOL>         else {<EOL>            const error = new Error(\"<STR_LIT>\");<EOL>            throw new EncryptedMediaError(\"<STR_LIT>\", error, true);<EOL>        }<EOL>    }<EOL>    log.info(\"<STR_LIT>\", encryptedEvent);<EOL>    return createMediaKeysObs(keySystemAccess).mergeMap((mediaKeys) => {<EOL>        <EOL>        const { serverCertificate } = keySystem;<EOL>        const setCertificate$ = (serverCertificate &&<EOL>            typeof mediaKeys.setServerCertificate === \"<STR_LIT>\" ?<EOL>            trySettingServerCertificate(","gt":"mediaKeys, serverCertificate, errorStream) :"}
{"input":"<s> <EOL>function setServerCertificate(mediaKeys, serverCertificate) {<EOL>    return Observable.defer(() => {<EOL>        return castToObservable(mediaKeys.setServerCertificate(serverCertificate))<EOL>            .","gt":"ignoreElements()"}
{"input":"<s> <EOL>function generateClock(videoElement) {<EOL>    const seeking$ = onSeeking$(videoElement);<EOL>    const seeked$ = onSeeked$(videoElement);<EOL>    const ended$ = onEnded$(videoElement);<EOL>    const manualRefresh$ = Observable.","gt":"merge(seeked$, ended$);"}
{"input":"<s> <EOL>function generateClock(videoElement) {<EOL>    const seeking$ = onSeeking$(videoElement);<EOL>    const seeked$ = onSeeked$(videoElement);<EOL>    const ended$ = onEnded$(videoElement);<EOL>    const manualRefresh$ = Observable. merge(seeked$, ended$);<EOL>    const autoRefresh$ = Observable<EOL>        .interval(MAXIMUM_HTML_TEXT_TRACK_UPDATE_INTERVAL)<EOL>        .startWith(null);<EOL>    <EOL>    return manualRefresh$<EOL>        .","gt":"startWith(null)"}
{"input":"<s> function speedChanged(speed) {<EOL>    return {<EOL>","gt":"type: \"<STR_LIT>\","}
{"input":"<s> <EOL>export default function handleVideoEvents(videoElement, startTime, autoPlay) {<EOL>    const initialSeek$ = doInitialSeek(videoElement, startTime);<EOL>    const hasHandledCanPlay$ = handleCanPlay(videoElement, autoPlay);<EOL>    const loadAndPlay$ = Observable<EOL>        .","gt":"combineLatest(initialSeek$, hasHandledCanPlay$)"}
{"input":"<s> <EOL>export default function handleVideoEvents(videoElement, startTime, autoPlay) {<EOL>    const initialSeek$ = doInitialSeek(videoElement, startTime);<EOL>    const hasHandledCanPlay$ = handleCanPlay(videoElement, autoPlay);<EOL>    const loadAndPlay$ = Observable<EOL>        . combineLatest(initialSeek$, hasHandledCanPlay$)<EOL>        .take(<NUM_LIT>)<EOL>        .mapTo(undefined);<EOL>    return {<EOL>","gt":"initialSeek$,"}
{"input":"<s> <EOL>export default function createManifest(manifestObject, externalTextTracks, externalImageTracks, warning$) {<EOL>    manifestObject.periods = (manifestObject.periods).map((period) => {<EOL>        period.adaptations = checkAdaptations(period.adaptations, warning$);<EOL>        return","gt":"period;"}
{"input":"<s> <EOL>function itole2(num) {<EOL>    return new Uint8Array([<EOL>        (num) &","gt":"<NUM_LIT>,"}
{"input":"<s> <EOL>function keepRangeIntersection(ranges1, ranges2) {<EOL>    for (let i = <NUM_LIT>; i < ranges1.length; i++) {<EOL>        const range = ranges1[i];<EOL>        const overlappingRange = findOverlappingRange(range, ranges2);<EOL>        if (!overlappingRange) {<EOL>            ranges1.splice(","gt":"i--, <NUM_LIT>);"}
{"input":"<s> <EOL>function keepRangeIntersection(ranges1, ranges2) {<EOL>    for (let i = <NUM_LIT>; i < ranges1.length; i++) {<EOL>        const range = ranges1[i];<EOL>        const overlappingRange = findOverlappingRange(range, ranges2);<EOL>        if (!overlappingRange) {<EOL>            ranges1.splice( i--, <NUM_LIT>);<EOL>        }<EOL>        else if (overlappingRange.start > range.start) {<EOL>            range.start = overlappingRange.start;<EOL>        }<EOL>        else if (overlappingRange.end < range.end) {<EOL>            range.end = overlappingRange.","gt":"end;"}
{"input":"<s> export function hide() {<EOL>","gt":"return higherOrderHide()(this);"}
{"input":"<s> export function getSnapshotRef(ref) {<EOL>","gt":"return ref[snapshotRefSymbol];"}
{"input":"<s> function stubPlugin() {<EOL>    return {<EOL>        afterComplete: sinon.stub(),<EOL>        afterError: sinon.stub(),<EOL>        afterNext: sinon.stub(),<EOL>","gt":"afterSubscribe: sinon.stub(),"}
{"input":"<s> function stubPlugin() {<EOL>    return {<EOL>        afterComplete: sinon.stub(),<EOL>        afterError: sinon.stub(),<EOL>        afterNext: sinon.stub(),<EOL>         afterSubscribe: sinon.stub(),<EOL>        afterUnsubscribe: sinon.stub(),<EOL>        beforeComplete: sinon.stub(),<EOL>        beforeError: sinon.stub(),<EOL>        beforeNext: sinon.","gt":"stub(),"}
{"input":"<s> function stubPlugin() {<EOL>    return {<EOL>        afterComplete: sinon.stub(),<EOL>        afterError: sinon.stub(),<EOL>        afterNext: sinon.stub(),<EOL>         afterSubscribe: sinon.stub(),<EOL>        afterUnsubscribe: sinon.stub(),<EOL>        beforeComplete: sinon.stub(),<EOL>        beforeError: sinon.stub(),<EOL>        beforeNext: sinon. stub(),<EOL>        beforeSubscribe: sinon.stub(),<EOL>        beforeUnsubscribe: sinon.stub(),<EOL>        flush: sinon.","gt":"stub(),"}
{"input":"<s> function test1() {<EOL>    <EOL>    var queue = new TaskQueue(Promise, <NUM_LIT>);<EOL>    var running = <NUM_LIT>;<EOL>    var maxRunning = <NUM_LIT>;<EOL>    <EOL>    function run(","gt":"item) {"}
{"input":"<s> function test1() {<EOL>    <EOL>    var queue = new TaskQueue(Promise, <NUM_LIT>);<EOL>    var running = <NUM_LIT>;<EOL>    var maxRunning = <NUM_LIT>;<EOL>    <EOL>    function run( item) {<EOL>        if (++running > maxRunning)<EOL>            maxRunning = running;<EOL>","gt":"return (Promise.delay(<NUM_LIT>, true).then(() => {"}
{"input":"<s> function test1() {<EOL>    <EOL>    var queue = new TaskQueue(Promise, <NUM_LIT>);<EOL>    var running = <NUM_LIT>;<EOL>    var maxRunning = <NUM_LIT>;<EOL>    <EOL>    function run( item) {<EOL>        if (++running > maxRunning)<EOL>            maxRunning = running;<EOL>         return (Promise.delay(<NUM_LIT>, true).then(() => {<EOL>            --running;<EOL>            return (item);<EOL>        }));<EOL>    }<EOL>    <EOL>    var list =","gt":"'<STR_LIT>'.split('<STR_LIT>');"}
{"input":"<s> function onError(e) {<EOL>    log.error(","gt":"'<STR_LIT>', '<STR_LIT>', e);"}
{"input":"<s> async function getOutRoom(contact, room) {<EOL>    log.info('<STR_LIT>', '<STR_LIT>', contact, room);<EOL>    try {<EOL>        await room.say(","gt":"'<STR_LIT>');"}
{"input":"<s> function error(str) {<EOL>    throw","gt":"new Error(str);"}
{"input":"<s> function isInSmallView() {<EOL>    return windowInnerWidth <","gt":"<NUM_LIT>;"}
{"input":"<s> async function resetUserPassword(req, res, next) {<EOL>    const user = res.locals.user;<EOL>    user.password = req.body.","gt":"password;"}
{"input":"<s> async function getVideoDescription(req, res) {<EOL>    const videoInstance = res.locals.video;<EOL>    let description = '<STR_LIT>';<EOL>    if (","gt":"videoInstance.isOwned()) {"}
{"input":"<s> async function isAccountExist(p, res) {<EOL>    const account = await p;<EOL>    if (!account) {<EOL>        res.status(","gt":"<NUM_LIT>)"}
{"input":"<s> function isUUIDValid(value) {<EOL>    return exists(","gt":"value) && validator.isUUID('<STR_LIT>' + value, <NUM_LIT>);"}
{"input":"<s> function isUserRoleValid(value) {<EOL>    return exists(value) && validator.isInt('<STR_LIT>' +","gt":"value) && UserRole[value] !== undefined;"}
{"input":"<s> function isUserVideoQuotaValid(value) {<EOL>    return","gt":"exists(value) && validator.isInt(value + '<STR_LIT>', USERS_CONSTRAINTS_FIELDS.VIDEO_QUOTA);"}
{"input":"<s> function isVideoTruncatedDescriptionValid(value) {<EOL>    return exists(","gt":"value) && validator.isLength(value, VIDEOS_CONSTRAINTS_FIELDS.TRUNCATED_DESCRIPTION);"}
{"input":"<s> function down(options) {<EOL>    throw new Error(","gt":"'<STR_LIT>');"}
{"input":"<s> function down(options) {<EOL>    throw","gt":"new Error('<STR_LIT>');"}
{"input":"<s> async function getOrCreateActorAndServerAndModel(actorUrl, recurseIfNeeded = true) {<EOL>    let actor = await ActorModel.loadByUrl(actorUrl);<EOL>    <EOL>    if (!actor) {<EOL>        const result = await fetchRemoteActor(","gt":"actorUrl);"}
{"input":"<s> async function getOrCreateActorAndServerAndModel(actorUrl, recurseIfNeeded = true) {<EOL>    let actor = await ActorModel.loadByUrl(actorUrl);<EOL>    <EOL>    if (!actor) {<EOL>        const result = await fetchRemoteActor( actorUrl);<EOL>        if (result ===","gt":"undefined)"}
{"input":"<s> async function getOrCreateActorAndServerAndModel(actorUrl, recurseIfNeeded = true) {<EOL>    let actor = await ActorModel.loadByUrl(actorUrl);<EOL>    <EOL>    if (!actor) {<EOL>        const result = await fetchRemoteActor( actorUrl);<EOL>        if (result ===  undefined)<EOL>            throw new Error('<STR_LIT>');<EOL>        <EOL>        <EOL>        let ownerActor = undefined;<EOL>        if (recurseIfNeeded === true && result.actor.type === '<STR_LIT>') {<EOL>            const accountAttributedTo = result.attributedTo.find((a) => a.type === '<STR_LIT>');<EOL>","gt":"if (!accountAttributedTo)"}
{"input":"<s> async function getOrCreateActorAndServerAndModel(actorUrl, recurseIfNeeded = true) {<EOL>    let actor = await ActorModel.loadByUrl(actorUrl);<EOL>    <EOL>    if (!actor) {<EOL>        const result = await fetchRemoteActor( actorUrl);<EOL>        if (result ===  undefined)<EOL>            throw new Error('<STR_LIT>');<EOL>        <EOL>        <EOL>        let ownerActor = undefined;<EOL>        if (recurseIfNeeded === true && result.actor.type === '<STR_LIT>') {<EOL>            const accountAttributedTo = result.attributedTo.find((a) => a.type === '<STR_LIT>');<EOL>             if (!accountAttributedTo)<EOL>                throw new Error('<STR_LIT>' + actor.url);<EOL>            try {<EOL>                <EOL>                ownerActor = await getOrCreateActorAndServerAndModel(accountAttributedTo.id, false);<EOL>            }<EOL>            catch (err) {<EOL>                logger.error('<STR_LIT>' + actor.url);<EOL>                throw new Error(err);<EOL>            }<EOL>        }<EOL>        const options = {<EOL>            arguments: [result, ownerActor],<EOL>            errorMessage: '<STR_LIT>'<EOL>        };<EOL>        actor = await retryTransactionWrapper(saveActorAndServerAndModelIfNotExist,","gt":"options);"}
{"input":"<s> function getRefreshToken(refreshToken) {<EOL>    logger.debug('<STR_LIT>' + refreshToken +","gt":"'<STR_LIT>');"}
{"input":"<s> async function exitServers(servers, flushAtExit) {<EOL>    killallServers(","gt":"servers);"}
{"input":"<s> function getUsersListPaginationAndSort(url, accessToken, start, count, sort) {<EOL>    const path = '<STR_LIT>';<EOL>    return request(url)<EOL>        .get(path)<EOL>        .query({","gt":"start })"}
{"input":"<s> function getUsersListPaginationAndSort(url, accessToken, start, count, sort) {<EOL>    const path = '<STR_LIT>';<EOL>    return request(url)<EOL>        .get(path)<EOL>        .query({  start })<EOL>        .query({ count })<EOL>        .query({ sort })<EOL>        .set('<STR_LIT>', '<STR_LIT>')<EOL>        .set(","gt":"'<STR_LIT>', '<STR_LIT>' + accessToken)"}
{"input":"<s> function normalizeObject(obj) {<EOL>    const newObj = {};<EOL>    for (const key of Object.keys(obj)) {<EOL>        <EOL>        if (key === '<STR_LIT>')<EOL>","gt":"continue;"}
{"input":"<s> function normalizeObject(obj) {<EOL>    const newObj = {};<EOL>    for (const key of Object.keys(obj)) {<EOL>        <EOL>        if (key === '<STR_LIT>')<EOL>             continue;<EOL>        const value = obj[key];<EOL>        if (typeof value === '<STR_LIT>') {<EOL>            newObj[key] = value.normalize();<EOL>        }<EOL>        else {<EOL>            newObj[","gt":"key] = value;"}
{"input":"<s> function processVideo(info, languageCode) {<EOL>    return new Promise(async (res) => {<EOL>        if (program['<STR_LIT>'])<EOL>            console.log('<STR_LIT>', info);<EOL>        const videoInfo = await fetchObject(info);<EOL>        if (program[","gt":"'<STR_LIT>'])"}
{"input":"<s> function processVideo(info, languageCode) {<EOL>    return new Promise(async (res) => {<EOL>        if (program['<STR_LIT>'])<EOL>            console.log('<STR_LIT>', info);<EOL>        const videoInfo = await fetchObject(info);<EOL>        if (program[ '<STR_LIT>'])<EOL>            console.log('<STR_LIT>', videoInfo);<EOL>        const result = await searchVideo(program['<STR_LIT>'], videoInfo.title);<EOL>        console.","gt":"log('<STR_LIT>');"}
{"input":"<s> function processVideo(info, languageCode) {<EOL>    return new Promise(async (res) => {<EOL>        if (program['<STR_LIT>'])<EOL>            console.log('<STR_LIT>', info);<EOL>        const videoInfo = await fetchObject(info);<EOL>        if (program[ '<STR_LIT>'])<EOL>            console.log('<STR_LIT>', videoInfo);<EOL>        const result = await searchVideo(program['<STR_LIT>'], videoInfo.title);<EOL>        console. log('<STR_LIT>');<EOL>        if (result.body.data.find((v) => v.name === videoInfo.title)) {<EOL>            console.log('<STR_LIT>', videoInfo.title);<EOL>            return res();<EOL>        }<EOL>        const path = join(__dirname, new Date().","gt":"getTime() + '<STR_LIT>');"}
{"input":"<s> function processVideo(info, languageCode) {<EOL>    return new Promise(async (res) => {<EOL>        if (program['<STR_LIT>'])<EOL>            console.log('<STR_LIT>', info);<EOL>        const videoInfo = await fetchObject(info);<EOL>        if (program[ '<STR_LIT>'])<EOL>            console.log('<STR_LIT>', videoInfo);<EOL>        const result = await searchVideo(program['<STR_LIT>'], videoInfo.title);<EOL>        console. log('<STR_LIT>');<EOL>        if (result.body.data.find((v) => v.name === videoInfo.title)) {<EOL>            console.log('<STR_LIT>', videoInfo.title);<EOL>            return res();<EOL>        }<EOL>        const path = join(__dirname, new Date(). getTime() + '<STR_LIT>');<EOL>        console.log('<STR_LIT>', videoInfo.title);<EOL>        const options = ['<STR_LIT>', '<STR_LIT>', '<STR_LIT>', path];<EOL>        youtubeDL.exec(videoInfo.url, options, processOptions, async (err, output) => {<EOL>            if (err)<EOL>                return console.error(","gt":"err);"}
{"input":"<s> <EOL>export function genImageUrl(file) {<EOL>    if (!isSSR && isImage(file)) {<EOL>        return window.","gt":"URL.createObjectURL(file);"}
{"input":"<s> <EOL>export function get(...target) {<EOL>    const user = getDeepProperty(USERCONFIG, target);<EOL>    const defult = getDeepProperty(DEFAULTS, target);<EOL>    <EOL>    if (defult && (!Array.isArray(defult) && typeof defult === \"<STR_LIT>\")) {<EOL>        return Object.assign(","gt":"o({}), defult, user);"}
{"input":"<s> <EOL>export function get(...target) {<EOL>    const user = getDeepProperty(USERCONFIG, target);<EOL>    const defult = getDeepProperty(DEFAULTS, target);<EOL>    <EOL>    if (defult && (!Array.isArray(defult) && typeof defult === \"<STR_LIT>\")) {<EOL>        return Object.assign( o({}), defult, user);<EOL>    }<EOL>    else {<EOL>        if (user !== undefined) {<EOL>            return user;<EOL>        }<EOL>","gt":"else {"}
{"input":"<s> <EOL><EOL>export async function tabclose(...indexes) {<EOL>    if (indexes.length > <NUM_LIT>) {<EOL>        const idsPromise = indexes.map((index) => idFromIndex(Number(index)));<EOL>        browser.tabs.remove(await","gt":"Promise.all(idsPromise));"}
{"input":"<s> <EOL><EOL>export async function ttscontrol(action) {<EOL>    let ttsAction = null;<EOL>    <EOL>    <EOL>    <EOL>    switch (","gt":"action) {"}
{"input":"<s> <EOL>function hintImage(inBackground) {<EOL>    hintPage(hintableImages(), (hint) => {<EOL>        let img_src = hint.target.getAttribute(\"<STR_LIT>\");<EOL>","gt":"if (inBackground) {"}
{"input":"<s> <EOL>function hintPageAnchorYank() {<EOL>    hintPage(anchors(), (hint) => {<EOL>        let anchorUrl = new","gt":"URL(window.location.href);"}
{"input":"<s> <EOL>export function hintPage(hintableElements, onSelect, buildHints = defaultHintBuilder(), filterHints = defaultHintFilter()) {<EOL>    state.mode = '<STR_LIT>';<EOL>    modeState = new HintState(filterHints);<EOL>    buildHints(hintableElements, onSelect);<EOL>    if (modeState.","gt":"hints.length) {"}
{"input":"<s> <EOL>export function hintPage(hintableElements, onSelect, buildHints = defaultHintBuilder(), filterHints = defaultHintFilter()) {<EOL>    state.mode = '<STR_LIT>';<EOL>    modeState = new HintState(filterHints);<EOL>    buildHints(hintableElements, onSelect);<EOL>    if (modeState. hints.length) {<EOL>        logger.debug(\"<STR_LIT>\", modeState.hints);<EOL>        modeState.focusedHint = modeState.hints[<NUM_LIT>];<EOL>        modeState.focusedHint.focused = true;<EOL>        document.documentElement.appendChild(modeState.hintHost);<EOL>    }<EOL>","gt":"else {"}
{"input":"<s> <EOL>export function iterEq(...arrays) {<EOL>    for (let a of zip(...arrays)) {<EOL>","gt":"if (!a.reduce((x, y) => (x === y)))"}
{"input":"<s> export function isSimpleKey(keyEvent) {<EOL>    return !(keyEvent.key.length >","gt":"<NUM_LIT> || hasNonShiftModifiers(keyEvent));"}
{"input":"<s> <EOL>export function generic(obj) {<EOL>    let ret = {};<EOL>    for (let key of Object.keys(obj)) {<EOL>        if (messageSafeTypes.has(typeof obj[","gt":"key])) {"}
{"input":"<s> export function Node(node) {<EOL>    return pick(node, <EOL>    <EOL>    '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', <EOL>    <EOL>    '<STR_LIT>', <EOL>    <EOL>    '<STR_LIT>', <EOL>    <EOL>","gt":"'<STR_LIT>',"}
{"input":"<s> function rejectWithError(msg, error) {<EOL>    const err = new GTTError(","gt":"}: ${msg}`<STR_LIT>;"}
{"input":"<s> export function getSignature(auth, payload, algorithm = '<STR_LIT>') {<EOL>    return crypto<EOL>        .createHmac(","gt":"algorithm, auth.secret)"}
{"input":"<s> export function PriceTreeFactory() {<EOL>    return","gt":"new RBTree((a, b) => a.price.cmp(b.price));"}
{"input":"<s> function logError(err) {<EOL>    console.log(err.message, err.response ?","gt":"message}`<STR_LIT>;"}
{"input":"<s> export function printSeparator() {<EOL>","gt":"return '<STR_LIT>';"}
{"input":"<s> export function createMockLivebook(product, messages) {<EOL>    const bookConfig = {<EOL>        logger: null,<EOL>        strictMode: false,<EOL>","gt":"product: product"}
{"input":"<s> export function createMockLivebook(product, messages) {<EOL>    const bookConfig = {<EOL>        logger: null,<EOL>        strictMode: false,<EOL>         product: product<EOL>    };<EOL>    const liveBook = new LiveOrderbook(bookConfig);<EOL>    const messageStream = new StaticCommandSet(messages);<EOL>    messageStream.pipe(liveBook);<EOL>    return {<EOL>        liveBook:","gt":"liveBook,"}
{"input":"<s> function level3Messages() {<EOL>    return [<EOL>        Object.assign({<EOL>            type: '<STR_LIT>',<EOL>            time: new Date('<STR_LIT>'),<EOL>            productId:","gt":"'<STR_LIT>'"}
{"input":"<s> function level3Messages() {<EOL>    return [<EOL>        Object.assign({<EOL>            type: '<STR_LIT>',<EOL>            time: new Date('<STR_LIT>'),<EOL>            productId:  '<STR_LIT>'<EOL>        }, shallowState()),<EOL>        { type: '<STR_LIT>',<EOL>            sequence: <NUM_LIT>,<EOL>            time: new Date(","gt":"'<STR_LIT>'),"}
{"input":"<s> function level3Messages() {<EOL>    return [<EOL>        Object.assign({<EOL>            type: '<STR_LIT>',<EOL>            time: new Date('<STR_LIT>'),<EOL>            productId:  '<STR_LIT>'<EOL>        }, shallowState()),<EOL>        { type: '<STR_LIT>',<EOL>            sequence: <NUM_LIT>,<EOL>            time: new Date( '<STR_LIT>'),<EOL>            productId: '<STR_LIT>',<EOL>            price: '<STR_LIT>',<EOL>            remainingSize:","gt":"'<STR_LIT>',"}
{"input":"<s> export function promiseSequential(promises) {<EOL>    if (!Array.isArray(promises)) {<EOL>        throw new Error('<STR_LIT>');<EOL>    }<EOL>    return new Promise((resolve, reject) => {<EOL>","gt":"let count = <NUM_LIT>;"}
{"input":"<s> export function promiseSequential(promises) {<EOL>    if (!Array.isArray(promises)) {<EOL>        throw new Error('<STR_LIT>');<EOL>    }<EOL>    return new Promise((resolve, reject) => {<EOL>         let count = <NUM_LIT>;<EOL>        let results = [];<EOL>        const iterateeFunc = (previousPromise, currentPromise) => {<EOL>","gt":"return previousPromise"}
{"input":"<s> export function promiseSequential(promises) {<EOL>    if (!Array.isArray(promises)) {<EOL>        throw new Error('<STR_LIT>');<EOL>    }<EOL>    return new Promise((resolve, reject) => {<EOL>         let count = <NUM_LIT>;<EOL>        let results = [];<EOL>        const iterateeFunc = (previousPromise, currentPromise) => {<EOL>             return previousPromise<EOL>                .then(function (result) {<EOL>                if (count++ !== <NUM_LIT>) {<EOL>","gt":"results = results.concat(result);"}
{"input":"<s> export function promiseSequential(promises) {<EOL>    if (!Array.isArray(promises)) {<EOL>        throw new Error('<STR_LIT>');<EOL>    }<EOL>    return new Promise((resolve, reject) => {<EOL>         let count = <NUM_LIT>;<EOL>        let results = [];<EOL>        const iterateeFunc = (previousPromise, currentPromise) => {<EOL>             return previousPromise<EOL>                .then(function (result) {<EOL>                if (count++ !== <NUM_LIT>) {<EOL>                     results = results.concat(result);<EOL>                }<EOL>                return currentPromise(result, results, count);<EOL>            })<EOL>                .catch((err) => {<EOL>                return reject(err);<EOL>            });<EOL>        };<EOL>        promises = promises.","gt":"concat(() => Promise.resolve());"}
{"input":"<s> export function handlePath(files, cwd) {<EOL>    let _files = files;<EOL>    let i = <NUM_LIT>;<EOL>    let len = files.","gt":"length;"}
{"input":"<s> export function hasBom(source) {<EOL>","gt":"return (source.charCodeAt(<NUM_LIT>) === <NUM_LIT>);"}
{"input":"<s> export function LogPropertyWithArgs(alias) {<EOL>","gt":"console.log('<STR_LIT>', alias);"}
{"input":"<s> export default function get(object, path, defaultValue = undefined) {<EOL>    if (path) {<EOL>        const pathSplitted = path.split(\"<STR_LIT>\");<EOL>        const property = pathSplitted[<NUM_LIT>];<EOL>        const","gt":"findProperty = object[property];"}
{"input":"<s> export default function get(object, path, defaultValue = undefined) {<EOL>    if (path) {<EOL>        const pathSplitted = path.split(\"<STR_LIT>\");<EOL>        const property = pathSplitted[<NUM_LIT>];<EOL>        const  findProperty = object[property];<EOL>        if (findProperty && path.indexOf(\"<STR_LIT>\") === -<NUM_LIT>) {<EOL>            return findProperty;<EOL>        }<EOL>        const newPath = pathSplitted.slice(<NUM_LIT>, pathSplitted.length).join(\"<STR_LIT>\");<EOL>        return","gt":"get(findProperty, newPath, defaultValue);"}
{"input":"<s> <EOL>export function write(context, snapshot, raw, payload) {<EOL>    let tracerContext;<EOL>    if (context.tracer.writeStart) {<EOL>        tracerContext = context.tracer.writeStart(raw, payload);<EOL>    }<EOL>    <EOL>    <EOL>    <EOL>    const editor = new SnapshotEditor(context, snapshot);<EOL>    const { warnings } = editor.mergePayload(raw, payload);<EOL>    const newSnapshot = editor.commit();<EOL>    if (","gt":"context.tracer.writeEnd) {"}
{"input":"<s> function* handleFetchRequests() {<EOL>    let _pending = {};<EOL>    while (<NUM_LIT>) {<EOL>        const req = yield take(FETCH_REQUEST);<EOL>        const {","gt":"info } = req;"}
{"input":"<s> function* handleFetchRequests() {<EOL>    let _pending = {};<EOL>    while (<NUM_LIT>) {<EOL>        const req = yield take(FETCH_REQUEST);<EOL>        const {  info } = req;<EOL>        const uri = String(info);<EOL>","gt":"yield spawn(function* () {"}
{"input":"<s> function* handleFetchRequests() {<EOL>    let _pending = {};<EOL>    while (<NUM_LIT>) {<EOL>        const req = yield take(FETCH_REQUEST);<EOL>        const {  info } = req;<EOL>        const uri = String(info);<EOL>         yield spawn(function* () {<EOL>            const state = yield select();<EOL>            let p;<EOL>","gt":"let emitChange;"}
{"input":"<s> function* handleFetchRequests() {<EOL>    let _pending = {};<EOL>    while (<NUM_LIT>) {<EOL>        const req = yield take(FETCH_REQUEST);<EOL>        const {  info } = req;<EOL>        const uri = String(info);<EOL>         yield spawn(function* () {<EOL>            const state = yield select();<EOL>            let p;<EOL>             let emitChange;<EOL>            if (_pending[uri]) {<EOL>                p = _pending[uri];<EOL>            }<EOL>            else {<EOL>                if (","gt":"state.fileCache && state.fileCache[uri]) {"}
{"input":"<s> function* handleFetchRequests() {<EOL>    let _pending = {};<EOL>    while (<NUM_LIT>) {<EOL>        const req = yield take(FETCH_REQUEST);<EOL>        const {  info } = req;<EOL>        const uri = String(info);<EOL>         yield spawn(function* () {<EOL>            const state = yield select();<EOL>            let p;<EOL>             let emitChange;<EOL>            if (_pending[uri]) {<EOL>                p = _pending[uri];<EOL>            }<EOL>            else {<EOL>                if ( state.fileCache && state.fileCache[uri]) {<EOL>                    p = Promise.resolve(state.fileCache[uri].content);<EOL>                }<EOL>                else {<EOL>                    emitChange = true;<EOL>                    let curl =","gt":"uri;"}
{"input":"<s> function* handleFetchRequests() {<EOL>    let _pending = {};<EOL>    while (<NUM_LIT>) {<EOL>        const req = yield take(FETCH_REQUEST);<EOL>        const {  info } = req;<EOL>        const uri = String(info);<EOL>         yield spawn(function* () {<EOL>            const state = yield select();<EOL>            let p;<EOL>             let emitChange;<EOL>            if (_pending[uri]) {<EOL>                p = _pending[uri];<EOL>            }<EOL>            else {<EOL>                if ( state.fileCache && state.fileCache[uri]) {<EOL>                    p = Promise.resolve(state.fileCache[uri].content);<EOL>                }<EOL>                else {<EOL>                    emitChange = true;<EOL>                    let curl =  uri;<EOL>                    if (curl.charAt(<NUM_LIT>) === \"<STR_LIT>\") {<EOL>                        curl = window.location.protocol + \"<STR_LIT>\" + window.location.host + curl;<EOL>                    }<EOL>                    if (curl.indexOf(window.location.host) === -<NUM_LIT>) {<EOL>                        curl =","gt":"apiHost}/proxy/${encodeURIComponent(String(info))}`<STR_LIT>;"}
{"input":"<s> function* handleFetchRequests() {<EOL>    let _pending = {};<EOL>    while (<NUM_LIT>) {<EOL>        const req = yield take(FETCH_REQUEST);<EOL>        const {  info } = req;<EOL>        const uri = String(info);<EOL>         yield spawn(function* () {<EOL>            const state = yield select();<EOL>            let p;<EOL>             let emitChange;<EOL>            if (_pending[uri]) {<EOL>                p = _pending[uri];<EOL>            }<EOL>            else {<EOL>                if ( state.fileCache && state.fileCache[uri]) {<EOL>                    p = Promise.resolve(state.fileCache[uri].content);<EOL>                }<EOL>                else {<EOL>                    emitChange = true;<EOL>                    let curl =  uri;<EOL>                    if (curl.charAt(<NUM_LIT>) === \"<STR_LIT>\") {<EOL>                        curl = window.location.protocol + \"<STR_LIT>\" + window.location.host + curl;<EOL>                    }<EOL>                    if (curl.indexOf(window.location.host) === -<NUM_LIT>) {<EOL>                        curl = `<STR_LIT>`;<EOL>                    }<EOL>                    p = _pending[uri] = new Promise(async (resolve) => {<EOL>                        const response = await fetch(curl);<EOL>                        const blob = await response.blob();<EOL>                        const fr = new FileReader();<EOL>                        fr.onload = () => {<EOL>                            resolve(fr.result);<EOL>                        };<EOL>                        fr.readAsArrayBuffer(","gt":"blob);"}
{"input":"<s> function* handleFetchRequests() {<EOL>    let _pending = {};<EOL>    while (<NUM_LIT>) {<EOL>        const req = yield take(FETCH_REQUEST);<EOL>        const {  info } = req;<EOL>        const uri = String(info);<EOL>         yield spawn(function* () {<EOL>            const state = yield select();<EOL>            let p;<EOL>             let emitChange;<EOL>            if (_pending[uri]) {<EOL>                p = _pending[uri];<EOL>            }<EOL>            else {<EOL>                if ( state.fileCache && state.fileCache[uri]) {<EOL>                    p = Promise.resolve(state.fileCache[uri].content);<EOL>                }<EOL>                else {<EOL>                    emitChange = true;<EOL>                    let curl =  uri;<EOL>                    if (curl.charAt(<NUM_LIT>) === \"<STR_LIT>\") {<EOL>                        curl = window.location.protocol + \"<STR_LIT>\" + window.location.host + curl;<EOL>                    }<EOL>                    if (curl.indexOf(window.location.host) === -<NUM_LIT>) {<EOL>                        curl = `<STR_LIT>`;<EOL>                    }<EOL>                    p = _pending[uri] = new Promise(async (resolve) => {<EOL>                        const response = await fetch(curl);<EOL>                        const blob = await response.blob();<EOL>                        const fr = new FileReader();<EOL>                        fr.onload = () => {<EOL>                            resolve(fr.result);<EOL>                        };<EOL>                        fr.readAsArrayBuffer( blob);<EOL>                    });<EOL>                }<EOL>            }<EOL>            const buffer = yield call(p.then.","gt":"bind(p));"}
{"input":"<s> export function* syntheticBrowserSaga() {<EOL>    yield fork(htmlContentEditorSaga);<EOL>    yield fork(fileEditorSaga);<EOL>","gt":"yield fork(handleToggleCSSProperty);"}
{"input":"<s> function* init() {<EOL>    yield","gt":"call(openMainWindow);"}
{"input":"<s> export function* mainSaga() {<EOL>    yield","gt":"fork(init);"}
{"input":"<s> export function* mainSaga() {<EOL>    yield fork(","gt":"httpService);"}
{"input":"<s> <EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL>function* handleTextEditorEscaped() {<EOL>    while (true) {<EOL>        const { sourceEvent, nodeId } = (yield take(STAGE_TOOL_EDIT_TEXT_KEY_DOWN));<EOL>        if (sourceEvent.key !==","gt":"\"<STR_LIT>\") {"}
{"input":"<s> function* handleComponentsPaneAddClicked() {<EOL>    while (true) {<EOL>        yield take(COMPONENTS_PANE_ADD_COMPONENT_CLICKED);<EOL>        const name = prompt(\"<STR_LIT>\");<EOL>","gt":"if (!name) {"}
{"input":"<s> function* handleComponentsPaneAddClicked() {<EOL>    while (true) {<EOL>        yield take(COMPONENTS_PANE_ADD_COMPONENT_CLICKED);<EOL>        const name = prompt(\"<STR_LIT>\");<EOL>         if (!name) {<EOL>            continue;<EOL>        }<EOL>        const state = yield select();<EOL>        const workspace = getWorkspaceById(state, state.selectedWorkspaceId);<EOL>        const { componentId } = yield call(apiCreateComponent, name, state);<EOL>","gt":"console.error(\"<STR_LIT>\");"}
{"input":"<s> function* handleDeleteKeyPressed() {<EOL>    while (true) {<EOL>        const action = (yield take(DELETE_SHORCUT_PRESSED));<EOL>        const state = yield select();<EOL>","gt":"const { sourceEvent } = event;"}
{"input":"<s> function* handleDeleteKeyPressed() {<EOL>    while (true) {<EOL>        const action = (yield take(DELETE_SHORCUT_PRESSED));<EOL>        const state = yield select();<EOL>         const { sourceEvent } = event;<EOL>        const workspace = getSelectedWorkspace(state);<EOL>        for (const [type, id] of workspace.selectionRefs) {<EOL>            yield put(workspaceSelectionDeleted(workspace.$id));<EOL>            yield put(removed(id, type));<EOL>            if (workspace.stage.fullScreen && workspace.stage.fullScreen.artboardId === id) {<EOL>                yield put(","gt":"fullScreenTargetDeleted());"}
{"input":"<s> <EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL>function* handleDNDEnded() {<EOL>    while (true) {<EOL>        const event = yield take(DND_ENDED);<EOL>        const state = yield select();<EOL>        const workspace = getSelectedWorkspace(state);<EOL>","gt":"const dropRef = getStageToolMouseNodeTargetReference(state, event);"}
{"input":"<s> <EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL>function* handleDNDEnded() {<EOL>    while (true) {<EOL>        const event = yield take(DND_ENDED);<EOL>        const state = yield select();<EOL>        const workspace = getSelectedWorkspace(state);<EOL>         const dropRef = getStageToolMouseNodeTargetReference(state, event);<EOL>        if (","gt":"dropRef) {"}
{"input":"<s> <EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL>function* handleDNDEnded() {<EOL>    while (true) {<EOL>        const event = yield take(DND_ENDED);<EOL>        const state = yield select();<EOL>        const workspace = getSelectedWorkspace(state);<EOL>         const dropRef = getStageToolMouseNodeTargetReference(state, event);<EOL>        if ( dropRef) {<EOL>            yield call(handleDroppedOnElement, dropRef, event);<EOL>        }<EOL>        else {<EOL>            yield call(","gt":"handleDroppedOnEmptySpace, event);"}
{"input":"<s> function* handleSelectionStoppedMoving() {<EOL>    while (true) {<EOL>        const { point, workspaceId } = (yield take(RESIZER_STOPPED_MOVING));<EOL>        const state = (yield select());<EOL>        const workspace = getWorkspaceById(","gt":"state, workspaceId);"}
{"input":"<s> function* handleSelectionStoppedMoving() {<EOL>    while (true) {<EOL>        const { point, workspaceId } = (yield take(RESIZER_STOPPED_MOVING));<EOL>        const state = (yield select());<EOL>        const workspace = getWorkspaceById( state, workspaceId);<EOL>        for (const item of getBoundedWorkspaceSelection(workspace)) {<EOL>            <EOL>            if (workspace.stage.fullScreen && workspace.stage.fullScreen.artboardId === item.$id) {<EOL>                continue;<EOL>            }<EOL>            const bounds =","gt":"getWorkspaceItemBounds(item, workspace);"}
{"input":"<s> function* addRoutes(server) {<EOL>    const state = yield select();<EOL>    server.use(PUBLIC_SRC_DIR_PATH, yield wrapRoute(getFile));<EOL>    server.use(express.static(path.join(path.dirname(require.","gt":"resolve(\"<STR_LIT>\")), \"<STR_LIT>\")));"}
{"input":"<s> function* addRoutes(server) {<EOL>    const state = yield select();<EOL>    server.use(PUBLIC_SRC_DIR_PATH, yield wrapRoute(getFile));<EOL>    server.use(express.static(path.join(path.dirname(require. resolve(\"<STR_LIT>\")), \"<STR_LIT>\")));<EOL>    console.log(\"<STR_LIT>\");<EOL>    server.all(/^\\/proxy\\/.*/, yield wrapRoute(proxy));<EOL>    <EOL>    server.get(","gt":"\"<STR_LIT>\", yield wrapRoute(getComponents));"}
{"input":"<s> function* addRoutes(server) {<EOL>    const state = yield select();<EOL>    server.use(PUBLIC_SRC_DIR_PATH, yield wrapRoute(getFile));<EOL>    server.use(express.static(path.join(path.dirname(require. resolve(\"<STR_LIT>\")), \"<STR_LIT>\")));<EOL>    console.log(\"<STR_LIT>\");<EOL>    server.all(/^\\/proxy\\/.*/, yield wrapRoute(proxy));<EOL>    <EOL>    server.get( \"<STR_LIT>\", yield wrapRoute(getComponents));<EOL>    <EOL>    server.get(\"<STR_LIT>\", yield wrapRoute(getComponentsScreenshot));<EOL>    <EOL>    <EOL>","gt":"server.get(\"<STR_LIT>\", yield wrapRoute(getAllComponentsPreview));"}
{"input":"<s> function* addRoutes(server) {<EOL>    const state = yield select();<EOL>    server.use(PUBLIC_SRC_DIR_PATH, yield wrapRoute(getFile));<EOL>    server.use(express.static(path.join(path.dirname(require. resolve(\"<STR_LIT>\")), \"<STR_LIT>\")));<EOL>    console.log(\"<STR_LIT>\");<EOL>    server.all(/^\\/proxy\\/.*/, yield wrapRoute(proxy));<EOL>    <EOL>    server.get( \"<STR_LIT>\", yield wrapRoute(getComponents));<EOL>    <EOL>    server.get(\"<STR_LIT>\", yield wrapRoute(getComponentsScreenshot));<EOL>    <EOL>    <EOL>     server.get(\"<STR_LIT>\", yield wrapRoute(getAllComponentsPreview));<EOL>    <EOL>    server.get(\"<STR_LIT>\", yield wrapRoute(getComponentHTMLPreview));<EOL>    server.get(\"<STR_LIT>\", yield wrapRoute(","gt":"getComponentJSONPreview));"}
{"input":"<s> function* addRoutes(server) {<EOL>    const state = yield select();<EOL>    server.use(PUBLIC_SRC_DIR_PATH, yield wrapRoute(getFile));<EOL>    server.use(express.static(path.join(path.dirname(require. resolve(\"<STR_LIT>\")), \"<STR_LIT>\")));<EOL>    console.log(\"<STR_LIT>\");<EOL>    server.all(/^\\/proxy\\/.*/, yield wrapRoute(proxy));<EOL>    <EOL>    server.get( \"<STR_LIT>\", yield wrapRoute(getComponents));<EOL>    <EOL>    server.get(\"<STR_LIT>\", yield wrapRoute(getComponentsScreenshot));<EOL>    <EOL>    <EOL>     server.get(\"<STR_LIT>\", yield wrapRoute(getAllComponentsPreview));<EOL>    <EOL>    server.get(\"<STR_LIT>\", yield wrapRoute(getComponentHTMLPreview));<EOL>    server.get(\"<STR_LIT>\", yield wrapRoute( getComponentJSONPreview));<EOL>    server.get(\"<STR_LIT>\", yield wrapRoute(getComponentJSONPreview));<EOL>    server.get(\"<STR_LIT>\", yield wrapRoute(getComponentHTMLPreview));<EOL>    server.get(\"<STR_LIT>\", yield wrapRoute(getComponentJSONPreviewDiff));<EOL>    server.get(\"<STR_LIT>\", yield wrapRoute(getComponentJSONPreviewDiff));<EOL>    server.get(\"<STR_LIT>\", yield","gt":"wrapRoute(getVMObjectSoureInfo));"}
{"input":"<s> function* addRoutes(server) {<EOL>    const state = yield select();<EOL>    server.use(PUBLIC_SRC_DIR_PATH, yield wrapRoute(getFile));<EOL>    server.use(express.static(path.join(path.dirname(require. resolve(\"<STR_LIT>\")), \"<STR_LIT>\")));<EOL>    console.log(\"<STR_LIT>\");<EOL>    server.all(/^\\/proxy\\/.*/, yield wrapRoute(proxy));<EOL>    <EOL>    server.get( \"<STR_LIT>\", yield wrapRoute(getComponents));<EOL>    <EOL>    server.get(\"<STR_LIT>\", yield wrapRoute(getComponentsScreenshot));<EOL>    <EOL>    <EOL>     server.get(\"<STR_LIT>\", yield wrapRoute(getAllComponentsPreview));<EOL>    <EOL>    server.get(\"<STR_LIT>\", yield wrapRoute(getComponentHTMLPreview));<EOL>    server.get(\"<STR_LIT>\", yield wrapRoute( getComponentJSONPreview));<EOL>    server.get(\"<STR_LIT>\", yield wrapRoute(getComponentJSONPreview));<EOL>    server.get(\"<STR_LIT>\", yield wrapRoute(getComponentHTMLPreview));<EOL>    server.get(\"<STR_LIT>\", yield wrapRoute(getComponentJSONPreviewDiff));<EOL>    server.get(\"<STR_LIT>\", yield wrapRoute(getComponentJSONPreviewDiff));<EOL>    server.get(\"<STR_LIT>\", yield  wrapRoute(getVMObjectSoureInfo));<EOL>    server.get(\"<STR_LIT>\", yield wrapRoute(getVMObjectSoureInfo));<EOL>    <EOL>    server.get(\"<STR_LIT>\", yield wrapRoute(getClippedComponentScreenshot));<EOL>    server.get(\"<STR_LIT>\", yield wrapRoute(getClippedComponentScreenshot));<EOL>    <EOL>    server.post(\"<STR_LIT>\", yield wrapRoute(createComponent));<EOL>    <EOL>","gt":"server.delete(\"<STR_LIT>\", yield wrapRoute(deleteComponent));"}
{"input":"<s> function* getPostData(req) {<EOL>    const chan = eventChannel((emit) => {<EOL>        let buffer = [];<EOL>        req.on(\"<STR_LIT>\", (","gt":"chunk) => buffer.push(chunk));"}
{"input":"<s> export function* mainSaga() {<EOL>    yield fork(frontEndSaga);<EOL>    yield","gt":"fork(vscodeSaga);"}
{"input":"<s> function* handleTextDocumentChange() {<EOL>    const chan = eventChannel((emit) => {<EOL>        vscode.workspace.onDidChangeTextDocument((e) => {<EOL>            const document = e.document;<EOL>            emit(textContentChanged(document.uri.fsPath, document.getText()));<EOL>        });<EOL>","gt":"return () => { };"}
{"input":"<s> function* handleTextDocumentChange() {<EOL>    const chan = eventChannel((emit) => {<EOL>        vscode.workspace.onDidChangeTextDocument((e) => {<EOL>            const document = e.document;<EOL>            emit(textContentChanged(document.uri.fsPath, document.getText()));<EOL>        });<EOL>         return () => { };<EOL>    });<EOL>    while (true) {<EOL>        const action = yield take(chan);<EOL>","gt":"const state = yield select();"}
{"input":"<s> function* handleTextDocumentChange() {<EOL>    const chan = eventChannel((emit) => {<EOL>        vscode.workspace.onDidChangeTextDocument((e) => {<EOL>            const document = e.document;<EOL>            emit(textContentChanged(document.uri.fsPath, document.getText()));<EOL>        });<EOL>         return () => { };<EOL>    });<EOL>    while (true) {<EOL>        const action = yield take(chan);<EOL>         const state = yield select();<EOL>        <EOL>        <EOL>        if (getFileCacheContent(action.filePath, state) && getFileCacheContent(action.filePath, state) === action.","gt":"content) {"}
{"input":"<s> function visitEdge(graph, idTable, inStream, operator, outStream) {<EOL>    makeSureNodeIsRegistered(graph, idTable, inStream);<EOL>    makeSureNodeIsRegistered(graph, idTable, outStream);<EOL>    graph.setEdge(idTable.","gt":"getId(inStream), idTable.getId(operator), {});"}
{"input":"<s> function totalIsolateSource(source, scope) {<EOL>    return source.select(","gt":"SCOPE_PREFIX + scope);"}
{"input":"<s> function makeDOMReady$() {<EOL>    return xs.create({<EOL>        start(lis) {<EOL>            if (document.readyState === '<STR_LIT>') {<EOL>                document.addEventListener('<STR_LIT>', () => {<EOL>                    const state = document.readyState;<EOL>                    if (","gt":"state === '<STR_LIT>' || state === '<STR_LIT>') {"}
{"input":"<s> function makeDOMReady$() {<EOL>    return xs.create({<EOL>        start(lis) {<EOL>            if (document.readyState === '<STR_LIT>') {<EOL>                document.addEventListener('<STR_LIT>', () => {<EOL>                    const state = document.readyState;<EOL>                    if ( state === '<STR_LIT>' || state === '<STR_LIT>') {<EOL>                        lis.next(null);<EOL>                        lis.complete();<EOL>                    }<EOL>                });<EOL>            }<EOL>            else {<EOL>                lis.next(null);<EOL>                lis.","gt":"complete();"}
{"input":"<s> export function thunk(sel, key, fn, args) {<EOL>    if (args === undefined) {<EOL>        args = fn;<EOL>        fn = key;<EOL>","gt":"key = undefined;"}
{"input":"<s> export function thunk(sel, key, fn, args) {<EOL>    if (args === undefined) {<EOL>        args = fn;<EOL>        fn = key;<EOL>         key = undefined;<EOL>    }<EOL>    return h(sel, {<EOL>        key: key,<EOL>        hook: { init: init, prepatch: prepatch },<EOL>","gt":"fn: fn,"}
{"input":"<s> function createRenderTarget(id = null) {<EOL>    const element = document.createElement('<STR_LIT>');<EOL>    element.className = '<STR_LIT>';<EOL>    if (","gt":"id) {"}
{"input":"<s> function processEvent(args) {<EOL>    const { scheduler, done, currentTime, setTime, timeToRunTo } = args;<EOL>    const nextEvent = scheduler.peek();<EOL>    const outOfTime = nextEvent && timeToRunTo && nextEvent.time >= timeToRunTo;<EOL>    if (!nextEvent || outOfTime) {<EOL>","gt":"done();"}
{"input":"<s> function processEvent(args) {<EOL>    const { scheduler, done, currentTime, setTime, timeToRunTo } = args;<EOL>    const nextEvent = scheduler.peek();<EOL>    const outOfTime = nextEvent && timeToRunTo && nextEvent.time >= timeToRunTo;<EOL>    if (!nextEvent || outOfTime) {<EOL>         done();<EOL>        return;<EOL>    }<EOL>    const eventToProcess = scheduler.shiftNextEntry();<EOL>    if (","gt":"eventToProcess.cancelled) {"}
{"input":"<s> function processEvent(args) {<EOL>    const { scheduler, done, currentTime, setTime, timeToRunTo } = args;<EOL>    const nextEvent = scheduler.peek();<EOL>    const outOfTime = nextEvent && timeToRunTo && nextEvent.time >= timeToRunTo;<EOL>    if (!nextEvent || outOfTime) {<EOL>         done();<EOL>        return;<EOL>    }<EOL>    const eventToProcess = scheduler.shiftNextEntry();<EOL>    if ( eventToProcess.cancelled) {<EOL>        setImmediate(processEvent, args);<EOL>        return;<EOL>    }<EOL>    const time = eventToProcess.time;<EOL>    setTime(time);<EOL>    if (eventToProcess.","gt":"f) {"}
{"input":"<s> function processEvent(args) {<EOL>    const { scheduler, done, currentTime, setTime, timeToRunTo } = args;<EOL>    const nextEvent = scheduler.peek();<EOL>    const outOfTime = nextEvent && timeToRunTo && nextEvent.time >= timeToRunTo;<EOL>    if (!nextEvent || outOfTime) {<EOL>         done();<EOL>        return;<EOL>    }<EOL>    const eventToProcess = scheduler.shiftNextEntry();<EOL>    if ( eventToProcess.cancelled) {<EOL>        setImmediate(processEvent, args);<EOL>        return;<EOL>    }<EOL>    const time = eventToProcess.time;<EOL>    setTime(time);<EOL>    if (eventToProcess. f) {<EOL>        eventToProcess.f(eventToProcess, time, scheduler.add, currentTime);<EOL>    }<EOL>    if (eventToProcess.type === '<STR_LIT>') {<EOL>        eventToProcess.stream.shamefullySendNext(eventToProcess.value);<EOL>    }<EOL>    if (","gt":"eventToProcess.type === '<STR_LIT>') {"}
{"input":"<s> export function reducer(state = initialEntities(slices.CLAIM_REBUTTAL, initialClaimRebuttal), action) {<EOL>    const entities = {};<EOL>    switch (action.type) {<EOL>        case typeFor(slices.CLAIM_REBUTTAL, actions.ADD_SUCCESS):<EOL>        case typeFor(slices.CLAIM_REBUTTAL, actions.ADD_TEMP):<EOL>            return entityFunctions.addEntityToStore(state, action);<EOL>        case typeFor(slices.","gt":"CLAIM_REBUTTAL, actions.ASYNC_SUCCESS):"}
{"input":"<s> export function reducer(state = initialEntities(slices.CLAIM_REBUTTAL, initialClaimRebuttal), action) {<EOL>    const entities = {};<EOL>    switch (action.type) {<EOL>        case typeFor(slices.CLAIM_REBUTTAL, actions.ADD_SUCCESS):<EOL>        case typeFor(slices.CLAIM_REBUTTAL, actions.ADD_TEMP):<EOL>            return entityFunctions.addEntityToStore(state, action);<EOL>        case typeFor(slices. CLAIM_REBUTTAL, actions.ASYNC_SUCCESS):<EOL>            return entityFunctions.addEntitiesToStore(state, action);<EOL>        case typeFor(slices.CLAIM_REBUTTAL, actions.DELETE):<EOL>            return entityFunctions.deleteEntity(state, action);<EOL>        case typeFor(slices.CLAIM_REBUTTAL,","gt":"actions.DELETE_TEMP):"}
{"input":"<s> export function reducer(state = initialEntities(slices.CLAIM_REBUTTAL, initialClaimRebuttal), action) {<EOL>    const entities = {};<EOL>    switch (action.type) {<EOL>        case typeFor(slices.CLAIM_REBUTTAL, actions.ADD_SUCCESS):<EOL>        case typeFor(slices.CLAIM_REBUTTAL, actions.ADD_TEMP):<EOL>            return entityFunctions.addEntityToStore(state, action);<EOL>        case typeFor(slices. CLAIM_REBUTTAL, actions.ASYNC_SUCCESS):<EOL>            return entityFunctions.addEntitiesToStore(state, action);<EOL>        case typeFor(slices.CLAIM_REBUTTAL, actions.DELETE):<EOL>            return entityFunctions.deleteEntity(state, action);<EOL>        case typeFor(slices.CLAIM_REBUTTAL,  actions.DELETE_TEMP):<EOL>            return entityFunctions.deleteTemp(state, action);<EOL>        case typeFor(slices.CLAIM_REBUTTAL, actions.UPDATE):<EOL>","gt":"return sliceFunctions.patch(state, action);"}
{"input":"<s> export function selectNext(state, action) {<EOL>    let ix = <NUM_LIT> + state.ids.indexOf(state.selectedEntityId);<EOL>    if (ix >= state.","gt":"ids.length) {"}
{"input":"<s> export function initialIDs(slice, vals = {}) {<EOL>    return Object.assign({},","gt":"initialSlice(slice), {"}
{"input":"<s> export function reducer(state = initialIDs(slices.SEARCH), action) {<EOL>    switch (action.type) {<EOL>        case typeFor(slices.SEARCH, actions.ASYNC_SUCCESS):<EOL>            return idFunctions.updateIDs(","gt":"state, action);"}
{"input":"<s> export function loadFail(state, action) {<EOL>    const newState = merge({}, state, {<EOL>        hasError:","gt":"true,"}
{"input":"<s> export function patch(state, action) {<EOL>    return patchOrUpdate(state, action,","gt":"false);"}
{"input":"<s> <EOL>function patchOrUpdate(state, action, update) {<EOL>    let obj = [state];<EOL>    let patch = !update;<EOL>    const path = action.payload.path;<EOL>    const hasPath =","gt":"path && path.length;"}
{"input":"<s> <EOL>function patchOrUpdate(state, action, update) {<EOL>    let obj = [state];<EOL>    let patch = !update;<EOL>    const path = action.payload.path;<EOL>    const hasPath =  path && path.length;<EOL>    const pathLength =","gt":"hasPath ? path.length : <NUM_LIT>;"}
{"input":"<s> <EOL>function patchOrUpdate(state, action, update) {<EOL>    let obj = [state];<EOL>    let patch = !update;<EOL>    const path = action.payload.path;<EOL>    const hasPath =  path && path.length;<EOL>    const pathLength =  hasPath ? path.length : <NUM_LIT>;<EOL>    const key = path[path.length - <NUM_LIT>];<EOL>    let val = {};<EOL>    let","gt":"pos = pathLength;"}
{"input":"<s> <EOL>function patchOrUpdate(state, action, update) {<EOL>    let obj = [state];<EOL>    let patch = !update;<EOL>    const path = action.payload.path;<EOL>    const hasPath =  path && path.length;<EOL>    const pathLength =  hasPath ? path.length : <NUM_LIT>;<EOL>    const key = path[path.length - <NUM_LIT>];<EOL>    let val = {};<EOL>    let  pos = pathLength;<EOL>    <EOL>    if (typeof action.payload.val === '<STR_LIT>') {<EOL>        <EOL>        val =","gt":"action.payload.val;"}
{"input":"<s> <EOL>function patchOrUpdate(state, action, update) {<EOL>    let obj = [state];<EOL>    let patch = !update;<EOL>    const path = action.payload.path;<EOL>    const hasPath =  path && path.length;<EOL>    const pathLength =  hasPath ? path.length : <NUM_LIT>;<EOL>    const key = path[path.length - <NUM_LIT>];<EOL>    let val = {};<EOL>    let  pos = pathLength;<EOL>    <EOL>    if (typeof action.payload.val === '<STR_LIT>') {<EOL>        <EOL>        val =  action.payload.val;<EOL>    }<EOL>    else if (typeof action.payload.val === '<STR_LIT>') {<EOL>        <EOL>        val[key] = action.payload.val(state);<EOL>","gt":"pos--;"}
{"input":"<s> <EOL>function patchOrUpdate(state, action, update) {<EOL>    let obj = [state];<EOL>    let patch = !update;<EOL>    const path = action.payload.path;<EOL>    const hasPath =  path && path.length;<EOL>    const pathLength =  hasPath ? path.length : <NUM_LIT>;<EOL>    const key = path[path.length - <NUM_LIT>];<EOL>    let val = {};<EOL>    let  pos = pathLength;<EOL>    <EOL>    if (typeof action.payload.val === '<STR_LIT>') {<EOL>        <EOL>        val =  action.payload.val;<EOL>    }<EOL>    else if (typeof action.payload.val === '<STR_LIT>') {<EOL>        <EOL>        val[key] = action.payload.val(state);<EOL>         pos--;<EOL>        patch = true;<EOL>    }<EOL>","gt":"else {"}
{"input":"<s> <EOL>function patchOrUpdate(state, action, update) {<EOL>    let obj = [state];<EOL>    let patch = !update;<EOL>    const path = action.payload.path;<EOL>    const hasPath =  path && path.length;<EOL>    const pathLength =  hasPath ? path.length : <NUM_LIT>;<EOL>    const key = path[path.length - <NUM_LIT>];<EOL>    let val = {};<EOL>    let  pos = pathLength;<EOL>    <EOL>    if (typeof action.payload.val === '<STR_LIT>') {<EOL>        <EOL>        val =  action.payload.val;<EOL>    }<EOL>    else if (typeof action.payload.val === '<STR_LIT>') {<EOL>        <EOL>        val[key] = action.payload.val(state);<EOL>         pos--;<EOL>        patch = true;<EOL>    }<EOL>     else {<EOL>        <EOL>        val[key] = action.payload.val;<EOL>        pos--;<EOL>        patch = true;<EOL>    }<EOL>    let i = <NUM_LIT>;<EOL>    for (i = <NUM_LIT>; i < pos; i++) {<EOL>        obj[i + <NUM_LIT>] = obj[i][path[i]];<EOL>    }<EOL>","gt":"if (patch) {"}
{"input":"<s> <EOL>function githubCommitToGitCommit(ghCommit) {<EOL>    return {<EOL>        sha: ghCommit.sha,<EOL>        parents: ghCommit.parents.map((p) =>","gt":"p.sha),"}
{"input":"<s> <EOL><EOL><EOL><EOL><EOL>export async function createDangerfileRuntimeEnvironment(dangerfileContext) {<EOL>    <EOL>    <EOL>    <EOL>    Object.keys(dangerfileContext).forEach((key) => {<EOL>        global[key] =","gt":"dangerfileContext[key];"}
{"input":"<s> <EOL><EOL><EOL><EOL><EOL>export async function createDangerfileRuntimeEnvironment(dangerfileContext) {<EOL>    <EOL>    <EOL>    <EOL>    Object.keys(dangerfileContext).forEach((key) => {<EOL>        global[key] =  dangerfileContext[key];<EOL>    });<EOL>    return {<EOL>        require: {<EOL>            external:","gt":"true,"}
{"input":"<s> export function deactivate() {<EOL>    setCommandVisiblity(false,","gt":"null);"}
{"input":"<s> export function getDartWorkspaceFolders() {<EOL>    if (!workspace.","gt":"workspaceFolders)"}
{"input":"<s> export function isAnalyzableAndInWorkspace(document) {<EOL>    if (document.","gt":"isUntitled || !document.fileName)"}
{"input":"<s> export function log(message) {<EOL>    console.","gt":"log(message);"}
{"input":"<s> export function Machine(config) {<EOL>    return new StateNode(config)","gt":";"}
{"input":"<s> export default function getCompareOperator(operator, negated) {<EOL>    switch (operator) {<EOL>        case '<STR_LIT>':<EOL>        case '<STR_LIT>':<EOL>            return negated ? '<STR_LIT>' : '<STR_LIT>';<EOL>        case '<STR_LIT>':<EOL>        case","gt":"'<STR_LIT>':"}
{"input":"<s> export default function getCompareOperator(operator, negated) {<EOL>    switch (operator) {<EOL>        case '<STR_LIT>':<EOL>        case '<STR_LIT>':<EOL>            return negated ? '<STR_LIT>' : '<STR_LIT>';<EOL>        case '<STR_LIT>':<EOL>        case  '<STR_LIT>':<EOL>            return negated ? '<STR_LIT>' : '<STR_LIT>';<EOL>        case '<STR_LIT>':<EOL>            return negated ? '<STR_LIT>' : '<STR_LIT>';<EOL>","gt":"case '<STR_LIT>':"}
{"input":"<s> export default function getCompareOperator(operator, negated) {<EOL>    switch (operator) {<EOL>        case '<STR_LIT>':<EOL>        case '<STR_LIT>':<EOL>            return negated ? '<STR_LIT>' : '<STR_LIT>';<EOL>        case '<STR_LIT>':<EOL>        case  '<STR_LIT>':<EOL>            return negated ? '<STR_LIT>' : '<STR_LIT>';<EOL>        case '<STR_LIT>':<EOL>            return negated ? '<STR_LIT>' : '<STR_LIT>';<EOL>         case '<STR_LIT>':<EOL>            return negated ? '<STR_LIT>' : '<STR_LIT>';<EOL>        case '<STR_LIT>':<EOL>            return negated ? '<STR_LIT>' : '<STR_LIT>';<EOL>","gt":"case '<STR_LIT>':"}
{"input":"<s> function trimRight(string) {<EOL>","gt":"return string.replace(/\\s+$/, '<STR_LIT>');"}
{"input":"<s> function checkSoak(input, expectedOutput, expectedOptionalChainingOutput) {<EOL>    check(","gt":"input, expectedOutput);"}
{"input":"<s> <EOL>export function get(data, path, deepCopy) {<EOL>    const tokens = tokenize(path);<EOL>    let value = data;<EOL>    for (let i = <NUM_LIT>; i < tokens.length; i++) {<EOL>","gt":"if (value === undefined) {"}
{"input":"<s> <EOL>export function get(data, path, deepCopy) {<EOL>    const tokens = tokenize(path);<EOL>    let value = data;<EOL>    for (let i = <NUM_LIT>; i < tokens.length; i++) {<EOL>         if (value === undefined) {<EOL>            return undefined;<EOL>        }<EOL>        if (typeof value !== '<STR_LIT>') {<EOL>            throw new Error('<STR_LIT>');<EOL>        }<EOL>        value =","gt":"value[tokens[i]];"}
{"input":"<s> <EOL>function handleUUIDProperty(config) {<EOL>","gt":"if (config.serverName === '<STR_LIT>') {"}
{"input":"<s> <EOL>function tokenize(path) {<EOL>    const tokens = [];<EOL>    const parts = path.split('<STR_LIT>');<EOL>    for (let i = <NUM_LIT>; i < parts.length; i++) {<EOL>","gt":"const part = parts[i].trim();"}
{"input":"<s> <EOL>function tokenize(path) {<EOL>    const tokens = [];<EOL>    const parts = path.split('<STR_LIT>');<EOL>    for (let i = <NUM_LIT>; i < parts.length; i++) {<EOL>         const part = parts[i].trim();<EOL>        if (part.length === <NUM_LIT>) {<EOL>            continue;<EOL>        }<EOL>        const arrayIndexes = part.split(SPLIT_REG_EXP);<EOL>        if (arrayIndexes.length === <NUM_LIT>) {<EOL>            <EOL>            continue;<EOL>        }<EOL>        tokens.push(arrayIndexes[<NUM_LIT>]);<EOL>        for (let j = <NUM_LIT>; j < arrayIndexes.length; j++) {<EOL>            if (arrayIndexes[j].length === <NUM_LIT>) {<EOL>","gt":"continue;"}
{"input":"<s> <EOL>export function recordRequest(recordName, config, services, socketWrapper, onComplete, onError, context, metaData, message) {<EOL>    let cacheTimedOut = false;<EOL>    const cacheTimeout = setTimeout(() => {<EOL>        cacheTimedOut = true;<EOL>        sendError(RECORD_ACTIONS.CACHE_RETRIEVAL_TIMEOUT,","gt":"recordName, recordName, socketWrapper, onError, services, context, metaData, message);"}
{"input":"<s> <EOL>export function recordRequest(recordName, config, services, socketWrapper, onComplete, onError, context, metaData, message) {<EOL>    let cacheTimedOut = false;<EOL>    const cacheTimeout = setTimeout(() => {<EOL>        cacheTimedOut = true;<EOL>        sendError(RECORD_ACTIONS.CACHE_RETRIEVAL_TIMEOUT,  recordName, recordName, socketWrapper, onError, services, context, metaData, message);<EOL>    }, config.cacheRetrievalTimeout);<EOL>    services.cache.get(recordName, (error, version, data) => {<EOL>        if (!cacheTimedOut) {<EOL>            clearTimeout(cacheTimeout);<EOL>            onCacheResponse(error, recordName,","gt":"version, data, socketWrapper, onComplete, onError, config, services, context, metaData, message);"}
{"input":"<s> function printInstructions(nextVersion, entries) {<EOL>    const object = {};<EOL>    object[`<STR_LIT>`] = entries.sort();<EOL>    const steps = [<EOL>","gt":"nextVersion}'<STR_LIT>,"}
{"input":"<s> function printInstructions(nextVersion, entries) {<EOL>    const object = {};<EOL>    object[`<STR_LIT>`] = entries.sort();<EOL>    const steps = [<EOL>        `<STR_LIT>`,<EOL>        `<STR_LIT>`,<EOL>        '<STR_LIT>',<EOL>        '<STR_LIT>',<EOL>","gt":"'<STR_LIT>',"}
{"input":"<s> function packageOSX() {<EOL>    const dest = getOSXZipPath();<EOL>    fs.removeSync(","gt":"dest);"}
{"input":"<s> function parseProjectPath(parsed) {<EOL>    return","gt":"parsed || DEFAULT_PROJECT_PATH;"}
{"input":"<s> <EOL>export async function remapSourceMap(sourceFile) {<EOL>    log.debug(`<STR_LIT>`);<EOL>    const opts = {<EOL>        inline: false,<EOL>        includeContent:","gt":"true"}
{"input":"<s> <EOL>export async function remapSourceMap(sourceFile) {<EOL>    log.debug(`<STR_LIT>`);<EOL>    const opts = {<EOL>        inline: false,<EOL>        includeContent:  true<EOL>    };<EOL>    <EOL>    const chain = await sorcery.load(sourceFile);<EOL>    if (!chain) {<EOL>","gt":"throw new Error('<STR_LIT>' + sourceFile);"}
{"input":"<s> <EOL>export function writeSourceFile(sourceFile) {<EOL>    if (isSynthesizedSourceFile(sourceFile)) {<EOL>        const sourceText = writeSourceText(sourceFile);<EOL>        return ts.createSourceFile(sourceFile.fileName, sourceText, sourceFile.languageVersion, true,","gt":"ts.ScriptKind.TS);"}
{"input":"<s> <EOL>export function writeSourceText(sourceFile) {<EOL>    const originalSource = sourceFile.getFullText();<EOL>    if (isSynthesizedSourceFile(sourceFile)) {<EOL>        let newSource = '<STR_LIT>';<EOL>        let position = <NUM_LIT>;<EOL>        for (let replacement of sourceFile.","gt":"__replacements) {"}
{"input":"<s> export function createSourceFile(sourceText, fileName = '<STR_LIT>') {<EOL>    if (typeof sourceText !== '<STR_LIT>') {<EOL>        sourceText = tags.stripIndent(","gt":"sourceText);"}
{"input":"<s> <EOL>function toObservable(obj) {<EOL>    if (Object.getOwnPropertySymbols(obj).indexOf(globalState.ignoreDynamicSymbol) > -<NUM_LIT>) {<EOL>        <EOL>","gt":"return obj;"}
{"input":"<s> <EOL>function toObservable(obj) {<EOL>    if (Object.getOwnPropertySymbols(obj).indexOf(globalState.ignoreDynamicSymbol) > -<NUM_LIT>) {<EOL>        <EOL>         return obj;<EOL>    }<EOL>","gt":"let dynamicObject;"}
{"input":"<s> <EOL>function toObservable(obj) {<EOL>    if (Object.getOwnPropertySymbols(obj).indexOf(globalState.ignoreDynamicSymbol) > -<NUM_LIT>) {<EOL>        <EOL>         return obj;<EOL>    }<EOL>     let dynamicObject;<EOL>    const builtIn = builtIns.get(obj.constructor);<EOL>    if (typeof builtIn === \"<STR_LIT>\" || typeof builtIn ===","gt":"\"<STR_LIT>\") {"}
{"input":"<s> <EOL>function toObservable(obj) {<EOL>    if (Object.getOwnPropertySymbols(obj).indexOf(globalState.ignoreDynamicSymbol) > -<NUM_LIT>) {<EOL>        <EOL>         return obj;<EOL>    }<EOL>     let dynamicObject;<EOL>    const builtIn = builtIns.get(obj.constructor);<EOL>    if (typeof builtIn === \"<STR_LIT>\" || typeof builtIn ===  \"<STR_LIT>\") {<EOL>        <EOL>        dynamicObject = builtIn(obj, bindCurrentReaction, queueRunReactions, getProxyValue);<EOL>    }<EOL>","gt":"else if (!builtIn) {"}
{"input":"<s> <EOL>function toObservable(obj) {<EOL>    if (Object.getOwnPropertySymbols(obj).indexOf(globalState.ignoreDynamicSymbol) > -<NUM_LIT>) {<EOL>        <EOL>         return obj;<EOL>    }<EOL>     let dynamicObject;<EOL>    const builtIn = builtIns.get(obj.constructor);<EOL>    if (typeof builtIn === \"<STR_LIT>\" || typeof builtIn ===  \"<STR_LIT>\") {<EOL>        <EOL>        dynamicObject = builtIn(obj, bindCurrentReaction, queueRunReactions, getProxyValue);<EOL>    }<EOL>     else if (!builtIn) {<EOL>        dynamicObject = new Proxy(","gt":"obj, {"}
{"input":"<s> <EOL>function toObservable(obj) {<EOL>    if (Object.getOwnPropertySymbols(obj).indexOf(globalState.ignoreDynamicSymbol) > -<NUM_LIT>) {<EOL>        <EOL>         return obj;<EOL>    }<EOL>     let dynamicObject;<EOL>    const builtIn = builtIns.get(obj.constructor);<EOL>    if (typeof builtIn === \"<STR_LIT>\" || typeof builtIn ===  \"<STR_LIT>\") {<EOL>        <EOL>        dynamicObject = builtIn(obj, bindCurrentReaction, queueRunReactions, getProxyValue);<EOL>    }<EOL>     else if (!builtIn) {<EOL>        dynamicObject = new Proxy( obj, {<EOL>            get(target, key, receiver) {<EOL>                let value = Reflect.get(target, key, receiver);<EOL>                <EOL>                if (key === \"<STR_LIT>\") {<EOL>","gt":"return target;"}
{"input":"<s> <EOL>function toObservable(obj) {<EOL>    if (Object.getOwnPropertySymbols(obj).indexOf(globalState.ignoreDynamicSymbol) > -<NUM_LIT>) {<EOL>        <EOL>         return obj;<EOL>    }<EOL>     let dynamicObject;<EOL>    const builtIn = builtIns.get(obj.constructor);<EOL>    if (typeof builtIn === \"<STR_LIT>\" || typeof builtIn ===  \"<STR_LIT>\") {<EOL>        <EOL>        dynamicObject = builtIn(obj, bindCurrentReaction, queueRunReactions, getProxyValue);<EOL>    }<EOL>     else if (!builtIn) {<EOL>        dynamicObject = new Proxy( obj, {<EOL>            get(target, key, receiver) {<EOL>                let value = Reflect.get(target, key, receiver);<EOL>                <EOL>                if (key === \"<STR_LIT>\") {<EOL>                     return target;<EOL>                }<EOL>                <EOL>                globalState.event.emit(\"<STR_LIT>\", { target, key, value });<EOL>                bindCurrentReaction(target, key);<EOL>                value = getProxyValue(target, key, value);<EOL>                return","gt":"value;"}
{"input":"<s> <EOL>function toObservable(obj) {<EOL>    if (Object.getOwnPropertySymbols(obj).indexOf(globalState.ignoreDynamicSymbol) > -<NUM_LIT>) {<EOL>        <EOL>         return obj;<EOL>    }<EOL>     let dynamicObject;<EOL>    const builtIn = builtIns.get(obj.constructor);<EOL>    if (typeof builtIn === \"<STR_LIT>\" || typeof builtIn ===  \"<STR_LIT>\") {<EOL>        <EOL>        dynamicObject = builtIn(obj, bindCurrentReaction, queueRunReactions, getProxyValue);<EOL>    }<EOL>     else if (!builtIn) {<EOL>        dynamicObject = new Proxy( obj, {<EOL>            get(target, key, receiver) {<EOL>                let value = Reflect.get(target, key, receiver);<EOL>                <EOL>                if (key === \"<STR_LIT>\") {<EOL>                     return target;<EOL>                }<EOL>                <EOL>                globalState.event.emit(\"<STR_LIT>\", { target, key, value });<EOL>                bindCurrentReaction(target, key);<EOL>                value = getProxyValue(target, key, value);<EOL>                return  value;<EOL>            },<EOL>            set(target, key, value, receiver) {<EOL>                const oldValue = Reflect.get(target, key, receiver);<EOL>                <EOL>                if (typeof value === \"<STR_LIT>\" && value) {<EOL>                    value = value.$raw || value;<EOL>                }<EOL>                globalState.event.emit(\"<STR_LIT>\", { target, key, value,","gt":"oldValue });"}
{"input":"<s> <EOL>function toObservable(obj) {<EOL>    if (Object.getOwnPropertySymbols(obj).indexOf(globalState.ignoreDynamicSymbol) > -<NUM_LIT>) {<EOL>        <EOL>         return obj;<EOL>    }<EOL>     let dynamicObject;<EOL>    const builtIn = builtIns.get(obj.constructor);<EOL>    if (typeof builtIn === \"<STR_LIT>\" || typeof builtIn ===  \"<STR_LIT>\") {<EOL>        <EOL>        dynamicObject = builtIn(obj, bindCurrentReaction, queueRunReactions, getProxyValue);<EOL>    }<EOL>     else if (!builtIn) {<EOL>        dynamicObject = new Proxy( obj, {<EOL>            get(target, key, receiver) {<EOL>                let value = Reflect.get(target, key, receiver);<EOL>                <EOL>                if (key === \"<STR_LIT>\") {<EOL>                     return target;<EOL>                }<EOL>                <EOL>                globalState.event.emit(\"<STR_LIT>\", { target, key, value });<EOL>                bindCurrentReaction(target, key);<EOL>                value = getProxyValue(target, key, value);<EOL>                return  value;<EOL>            },<EOL>            set(target, key, value, receiver) {<EOL>                const oldValue = Reflect.get(target, key, receiver);<EOL>                <EOL>                if (typeof value === \"<STR_LIT>\" && value) {<EOL>                    value = value.$raw || value;<EOL>                }<EOL>                globalState.event.emit(\"<STR_LIT>\", { target, key, value,  oldValue });<EOL>                const result = Reflect.set(target, key, value, receiver);<EOL>                <EOL>                <EOL>                if (key === \"<STR_LIT>\" || value !== oldValue) {<EOL>                    queueRunReactions(target, key);<EOL>                }<EOL>                return result;<EOL>            },<EOL>            deleteProperty(target, key) {<EOL>                const hasKey = Reflect.has(target, key);<EOL>                globalState.event.emit(\"<STR_LIT>\", { target, key });<EOL>                const result = Reflect.deleteProperty(","gt":"target, key);"}
{"input":"<s> <EOL>function toObservable(obj) {<EOL>    if (Object.getOwnPropertySymbols(obj).indexOf(globalState.ignoreDynamicSymbol) > -<NUM_LIT>) {<EOL>        <EOL>         return obj;<EOL>    }<EOL>     let dynamicObject;<EOL>    const builtIn = builtIns.get(obj.constructor);<EOL>    if (typeof builtIn === \"<STR_LIT>\" || typeof builtIn ===  \"<STR_LIT>\") {<EOL>        <EOL>        dynamicObject = builtIn(obj, bindCurrentReaction, queueRunReactions, getProxyValue);<EOL>    }<EOL>     else if (!builtIn) {<EOL>        dynamicObject = new Proxy( obj, {<EOL>            get(target, key, receiver) {<EOL>                let value = Reflect.get(target, key, receiver);<EOL>                <EOL>                if (key === \"<STR_LIT>\") {<EOL>                     return target;<EOL>                }<EOL>                <EOL>                globalState.event.emit(\"<STR_LIT>\", { target, key, value });<EOL>                bindCurrentReaction(target, key);<EOL>                value = getProxyValue(target, key, value);<EOL>                return  value;<EOL>            },<EOL>            set(target, key, value, receiver) {<EOL>                const oldValue = Reflect.get(target, key, receiver);<EOL>                <EOL>                if (typeof value === \"<STR_LIT>\" && value) {<EOL>                    value = value.$raw || value;<EOL>                }<EOL>                globalState.event.emit(\"<STR_LIT>\", { target, key, value,  oldValue });<EOL>                const result = Reflect.set(target, key, value, receiver);<EOL>                <EOL>                <EOL>                if (key === \"<STR_LIT>\" || value !== oldValue) {<EOL>                    queueRunReactions(target, key);<EOL>                }<EOL>                return result;<EOL>            },<EOL>            deleteProperty(target, key) {<EOL>                const hasKey = Reflect.has(target, key);<EOL>                globalState.event.emit(\"<STR_LIT>\", { target, key });<EOL>                const result = Reflect.deleteProperty( target, key);<EOL>                if (hasKey) {<EOL>                    queueRunReactions(target, key);<EOL>                }<EOL>                return result;<EOL>            }<EOL>        });<EOL>    }<EOL>","gt":"else {"}
{"input":"<s> <EOL>export function createUniqueId() {<EOL>","gt":"return globalState.uniqueIdCounter++;"}
{"input":"<s> <EOL>export function delay(milliseconds) {<EOL>    return function (value) {<EOL>        return new Promise(function (resolve) {<EOL>            setTimeout(","gt":"function () {"}
{"input":"<s> <EOL>export function diff(a, b, options = {}) {<EOL>    if (typeof a !== '<STR_LIT>' || typeof b !== '<STR_LIT>') {<EOL>        throw new TypeError('<STR_LIT>');<EOL>    }<EOL>    if (isArray(","gt":"a)) {"}
{"input":"<s> <EOL>export function diff(a, b, options = {}) {<EOL>    if (typeof a !== '<STR_LIT>' || typeof b !== '<STR_LIT>') {<EOL>        throw new TypeError('<STR_LIT>');<EOL>    }<EOL>    if (isArray( a)) {<EOL>        return diffArray(a, b, options);<EOL>    }<EOL>    if (isArray(b)) {<EOL>        b = objectCreate(null);<EOL>    }<EOL>    if (!isPlainObject(","gt":"a) || !isPlainObject(b)) {"}
{"input":"<s> <EOL>export function isIdentical(a, b) {<EOL>","gt":"return (a === b ||"}
{"input":"<s> export function isAmdRequire(object) {<EOL>","gt":"return typeof object.toUrl === '<STR_LIT>';"}
{"input":"<s> export function emit(target, event) {<EOL>    if (target.dispatchEvent &&<EOL>        ((target.ownerDocument && target.ownerDocument.createEvent) ||<EOL>            (target.document && target.document.createEvent) ||<EOL>            target.createEvent) ) {<EOL>        const nativeEvent = (target.ownerDocument || target.","gt":"document || target).createEvent('<STR_LIT>');"}
{"input":"<s> export function emit(target, event) {<EOL>    if (target.dispatchEvent &&<EOL>        ((target.ownerDocument && target.ownerDocument.createEvent) ||<EOL>            (target.document && target.document.createEvent) ||<EOL>            target.createEvent) ) {<EOL>        const nativeEvent = (target.ownerDocument || target. document || target).createEvent('<STR_LIT>');<EOL>        nativeEvent.initEvent(event.type, Boolean(event.bubbles), Boolean(event.cancelable));<EOL>        for (let key in event) {<EOL>            if (!(key in","gt":"nativeEvent)) {"}
{"input":"<s> export function emit(target, event) {<EOL>    if (target.dispatchEvent &&<EOL>        ((target.ownerDocument && target.ownerDocument.createEvent) ||<EOL>            (target.document && target.document.createEvent) ||<EOL>            target.createEvent) ) {<EOL>        const nativeEvent = (target.ownerDocument || target. document || target).createEvent('<STR_LIT>');<EOL>        nativeEvent.initEvent(event.type, Boolean(event.bubbles), Boolean(event.cancelable));<EOL>        for (let key in event) {<EOL>            if (!(key in  nativeEvent)) {<EOL>                nativeEvent[key] = event[key];<EOL>            }<EOL>        }<EOL>        return target.dispatchEvent(nativeEvent);<EOL>    }<EOL>    if (","gt":"target.emit) {"}
{"input":"<s> export function emit(target, event) {<EOL>    if (target.dispatchEvent &&<EOL>        ((target.ownerDocument && target.ownerDocument.createEvent) ||<EOL>            (target.document && target.document.createEvent) ||<EOL>            target.createEvent) ) {<EOL>        const nativeEvent = (target.ownerDocument || target. document || target).createEvent('<STR_LIT>');<EOL>        nativeEvent.initEvent(event.type, Boolean(event.bubbles), Boolean(event.cancelable));<EOL>        for (let key in event) {<EOL>            if (!(key in  nativeEvent)) {<EOL>                nativeEvent[key] = event[key];<EOL>            }<EOL>        }<EOL>        return target.dispatchEvent(nativeEvent);<EOL>    }<EOL>    if ( target.emit) {<EOL>        if (target.removeListener) {<EOL>            <EOL>            target.emit(event.type, event);<EOL>            return false;<EOL>        }<EOL>        else","gt":"if (target.on) {"}
{"input":"<s> function setOnError(request, reject) {<EOL>    request.","gt":"addEventListener('<STR_LIT>', function (event) {"}
{"input":"<s> <EOL>export function throttleAfter(callback, delay) {<EOL>    let ran;<EOL>    return function () {<EOL>        if (ran) {<EOL>","gt":"return;"}
{"input":"<s> <EOL>export function throttleAfter(callback, delay) {<EOL>    let ran;<EOL>    return function () {<EOL>        if (ran) {<EOL>             return;<EOL>        }<EOL>        ran = true;<EOL>        let context = this;<EOL>        let args = arguments;<EOL>        guaranteeMinimumTimeout(function () {<EOL>            callback.apply(context,","gt":"args);"}
{"input":"<s> function helloWorldTest(value) {<EOL>    return","gt":"value === '<STR_LIT>' || value === '<STR_LIT>';"}
{"input":"<s> export function isRemoteHead(ref) {<EOL>    return typeof ref === '<STR_LIT>' &&","gt":"REMOTE_REF_PREFIXES.filter((item) => ref.startsWith(item)).length > <NUM_LIT>;"}
{"input":"<s> export function registerTypes(serviceManager) {<EOL>    serviceManager.addSingleton(IPlatformService, PlatformService);<EOL>    serviceManager.addSingleton(","gt":"IFileSystem, FileSystem);"}
{"input":"<s> <EOL>export function isString(str) {<EOL>    if (typeof (str) === _typeof.string || str instanceof String) {<EOL>","gt":"return true;"}
{"input":"<s> export function getFirstNonEmptyLineFromMultilineString(stdout) {<EOL>    if (!stdout) {<EOL>","gt":"return '<STR_LIT>';"}
{"input":"<s> export function isBinary(ch) {<EOL>","gt":"return ch === Char._0 || ch === Char._1;"}
{"input":"<s> export function isDecimal(ch) {<EOL>    return ch >= Char.","gt":"_0 && ch <= Char._9;"}
{"input":"<s> function getExecutablePath(testProvider, settings) {<EOL>    let testRunnerExecutablePath;<EOL>    switch (testProvider) {<EOL>        case NOSETEST_PROVIDER: {<EOL>            testRunnerExecutablePath = settings.unitTest.nosetestPath;<EOL>","gt":"break;"}
{"input":"<s> function getExecutablePath(testProvider, settings) {<EOL>    let testRunnerExecutablePath;<EOL>    switch (testProvider) {<EOL>        case NOSETEST_PROVIDER: {<EOL>            testRunnerExecutablePath = settings.unitTest.nosetestPath;<EOL>             break;<EOL>        }<EOL>        case PYTEST_PROVIDER: {<EOL>            testRunnerExecutablePath = settings.unitTest.pyTestPath;<EOL>","gt":"break;"}
{"input":"<s> function getExecutablePath(testProvider, settings) {<EOL>    let testRunnerExecutablePath;<EOL>    switch (testProvider) {<EOL>        case NOSETEST_PROVIDER: {<EOL>            testRunnerExecutablePath = settings.unitTest.nosetestPath;<EOL>             break;<EOL>        }<EOL>        case PYTEST_PROVIDER: {<EOL>            testRunnerExecutablePath = settings.unitTest.pyTestPath;<EOL>             break;<EOL>        }<EOL>        default: {<EOL>            return","gt":"undefined;"}
{"input":"<s> function dispose() {<EOL>","gt":"workspaceTestManagerService.dispose();"}
{"input":"<s> async function getTestManager(displayTestNotConfiguredMessage, resource) {<EOL>    let wkspace;<EOL>    if (resource) {<EOL>        const wkspaceFolder = workspace.getWorkspaceFolder(resource);<EOL>        wkspace = wkspaceFolder ? wkspaceFolder.uri : undefined;<EOL>    }<EOL>","gt":"else {"}
{"input":"<s> async function getTestManager(displayTestNotConfiguredMessage, resource) {<EOL>    let wkspace;<EOL>    if (resource) {<EOL>        const wkspaceFolder = workspace.getWorkspaceFolder(resource);<EOL>        wkspace = wkspaceFolder ? wkspaceFolder.uri : undefined;<EOL>    }<EOL>     else {<EOL>        wkspace = await selectTestWorkspace();<EOL>    }<EOL>    if (!wkspace) {<EOL>","gt":"return;"}
{"input":"<s> async function getTestManager(displayTestNotConfiguredMessage, resource) {<EOL>    let wkspace;<EOL>    if (resource) {<EOL>        const wkspaceFolder = workspace.getWorkspaceFolder(resource);<EOL>        wkspace = wkspaceFolder ? wkspaceFolder.uri : undefined;<EOL>    }<EOL>     else {<EOL>        wkspace = await selectTestWorkspace();<EOL>    }<EOL>    if (!wkspace) {<EOL>         return;<EOL>    }<EOL>    const testManager = workspaceTestManagerService.getTestManager(wkspace);<EOL>    if (testManager) {<EOL>        return","gt":"testManager;"}
{"input":"<s> function getPythonPath() {<EOL>    <EOL>","gt":"if (process.env.TRAVIS_PYTHON_PATH && fs.existsSync(process.env.TRAVIS_PYTHON_PATH)) {"}
{"input":"<s> export async function enableDisableWorkspaceSymbols(resource, enabled, configTarget) {<EOL>    const settings =","gt":"workspace.getConfiguration('<STR_LIT>', resource);"}
{"input":"<s> function handleResponse(file, includeErrorAsResponse, error, stdout, stderr, token) {<EOL>    return new Promise((resolve, reject) => {<EOL>        if (token && token.isCancellationRequested) {<EOL>            return;<EOL>        }<EOL>","gt":"if (isNotInstalledError(error)) {"}
{"input":"<s> function handleResponse(file, includeErrorAsResponse, error, stdout, stderr, token) {<EOL>    return new Promise((resolve, reject) => {<EOL>        if (token && token.isCancellationRequested) {<EOL>            return;<EOL>        }<EOL>         if (isNotInstalledError(error)) {<EOL>            return reject(error);<EOL>        }<EOL>        <EOL>        <EOL>        <EOL>        if (includeErrorAsResponse && (stdout.length > <NUM_LIT> || stderr.length > <NUM_LIT>)) {<EOL>            return resolve(stdout +","gt":"'<STR_LIT>' + stderr);"}
{"input":"<s> function handleResponse(file, includeErrorAsResponse, error, stdout, stderr, token) {<EOL>    return new Promise((resolve, reject) => {<EOL>        if (token && token.isCancellationRequested) {<EOL>            return;<EOL>        }<EOL>         if (isNotInstalledError(error)) {<EOL>            return reject(error);<EOL>        }<EOL>        <EOL>        <EOL>        <EOL>        if (includeErrorAsResponse && (stdout.length > <NUM_LIT> || stderr.length > <NUM_LIT>)) {<EOL>            return resolve(stdout +  '<STR_LIT>' + stderr);<EOL>        }<EOL>        let hasErrors = (error && error.message.length > <NUM_LIT>) || (stderr && stderr.length > <NUM_LIT>);<EOL>        if (hasErrors && (typeof stdout !== '<STR_LIT>' || stdout.length ===","gt":"<NUM_LIT>)) {"}
{"input":"<s> function handleResponse(file, includeErrorAsResponse, error, stdout, stderr, token) {<EOL>    return new Promise((resolve, reject) => {<EOL>        if (token && token.isCancellationRequested) {<EOL>            return;<EOL>        }<EOL>         if (isNotInstalledError(error)) {<EOL>            return reject(error);<EOL>        }<EOL>        <EOL>        <EOL>        <EOL>        if (includeErrorAsResponse && (stdout.length > <NUM_LIT> || stderr.length > <NUM_LIT>)) {<EOL>            return resolve(stdout +  '<STR_LIT>' + stderr);<EOL>        }<EOL>        let hasErrors = (error && error.message.length > <NUM_LIT>) || (stderr && stderr.length > <NUM_LIT>);<EOL>        if (hasErrors && (typeof stdout !== '<STR_LIT>' || stdout.length ===  <NUM_LIT>)) {<EOL>            let errorMsg = (error && error.message) ? error.message : (stderr && stderr.length > <NUM_LIT> ? stderr + '<STR_LIT>' : '<STR_LIT>');<EOL>            console.error('<STR_LIT>');<EOL>            console.error(stdout);<EOL>            console.error('<STR_LIT>');<EOL>            console.error(stderr);<EOL>","gt":"console.error('<STR_LIT>');"}
{"input":"<s> function normalize(message) {<EOL>    return message<EOL>        .replace(/\\./g, \"<STR_LIT>\")<EOL>        .replace(/,/g,","gt":"\"<STR_LIT>\")"}
{"input":"<s> export function compileTemplate(config, templateContext, documents = [], settings = DEFAULT_SETTINGS) {<EOL>    if (!config) {<EOL>        throw new Error(`<STR_LIT>`);<EOL>    }<EOL>    debugLog(","gt":"inputType}`<STR_LIT>;"}
{"input":"<s> export function compileTemplate(config, templateContext, documents = [], settings = DEFAULT_SETTINGS) {<EOL>    if (!config) {<EOL>        throw new Error(`<STR_LIT>`);<EOL>    }<EOL>    debugLog(`<STR_LIT>`);<EOL>    debugLog(`<STR_LIT>`, settings);<EOL>    initHelpers(config, templateContext);<EOL>    const executionSettings = Object.assign(","gt":"DEFAULT_SETTINGS, settings);"}
{"input":"<s> export function compileTemplate(config, templateContext, documents = [], settings = DEFAULT_SETTINGS) {<EOL>    if (!config) {<EOL>        throw new Error(`<STR_LIT>`);<EOL>    }<EOL>    debugLog(`<STR_LIT>`);<EOL>    debugLog(`<STR_LIT>`, settings);<EOL>    initHelpers(config, templateContext);<EOL>    const executionSettings = Object.assign( DEFAULT_SETTINGS, settings);<EOL>    const templates = config.templates;<EOL>    Object.keys(templates).forEach((templateName) => {<EOL>        debugLog(`<STR_LIT>`);<EOL>        registerPartial(templateName,","gt":"templates[templateName]);"}
{"input":"<s> export function compileTemplate(config, templateContext, documents = [], settings = DEFAULT_SETTINGS) {<EOL>    if (!config) {<EOL>        throw new Error(`<STR_LIT>`);<EOL>    }<EOL>    debugLog(`<STR_LIT>`);<EOL>    debugLog(`<STR_LIT>`, settings);<EOL>    initHelpers(config, templateContext);<EOL>    const executionSettings = Object.assign( DEFAULT_SETTINGS, settings);<EOL>    const templates = config.templates;<EOL>    Object.keys(templates).forEach((templateName) => {<EOL>        debugLog(`<STR_LIT>`);<EOL>        registerPartial(templateName,  templates[templateName]);<EOL>    });<EOL>    let mergedDocuments;<EOL>    if (!executionSettings.generateDocuments) {<EOL>        debugLog(`<STR_LIT>`);<EOL>","gt":"mergedDocuments = {"}
{"input":"<s> export function compileTemplate(config, templateContext, documents = [], settings = DEFAULT_SETTINGS) {<EOL>    if (!config) {<EOL>        throw new Error(`<STR_LIT>`);<EOL>    }<EOL>    debugLog(`<STR_LIT>`);<EOL>    debugLog(`<STR_LIT>`, settings);<EOL>    initHelpers(config, templateContext);<EOL>    const executionSettings = Object.assign( DEFAULT_SETTINGS, settings);<EOL>    const templates = config.templates;<EOL>    Object.keys(templates).forEach((templateName) => {<EOL>        debugLog(`<STR_LIT>`);<EOL>        registerPartial(templateName,  templates[templateName]);<EOL>    });<EOL>    let mergedDocuments;<EOL>    if (!executionSettings.generateDocuments) {<EOL>        debugLog(`<STR_LIT>`);<EOL>         mergedDocuments = {<EOL>","gt":"fragments: [],"}
{"input":"<s> export function compileTemplate(config, templateContext, documents = [], settings = DEFAULT_SETTINGS) {<EOL>    if (!config) {<EOL>        throw new Error(`<STR_LIT>`);<EOL>    }<EOL>    debugLog(`<STR_LIT>`);<EOL>    debugLog(`<STR_LIT>`, settings);<EOL>    initHelpers(config, templateContext);<EOL>    const executionSettings = Object.assign( DEFAULT_SETTINGS, settings);<EOL>    const templates = config.templates;<EOL>    Object.keys(templates).forEach((templateName) => {<EOL>        debugLog(`<STR_LIT>`);<EOL>        registerPartial(templateName,  templates[templateName]);<EOL>    });<EOL>    let mergedDocuments;<EOL>    if (!executionSettings.generateDocuments) {<EOL>        debugLog(`<STR_LIT>`);<EOL>         mergedDocuments = {<EOL>             fragments: [],<EOL>            operations: [],<EOL>            hasFragments: false,<EOL>            hasOperations: false,<EOL>        };<EOL>    }<EOL>    else {<EOL>        mergedDocuments = documents.reduce((previousValue, item) => {<EOL>            const opArr = [...previousValue.operations, ...item.operations];<EOL>            const frArr = [...previousValue.","gt":"fragments, ...item.fragments];"}
{"input":"<s> export function compileTemplate(config, templateContext, documents = [], settings = DEFAULT_SETTINGS) {<EOL>    if (!config) {<EOL>        throw new Error(`<STR_LIT>`);<EOL>    }<EOL>    debugLog(`<STR_LIT>`);<EOL>    debugLog(`<STR_LIT>`, settings);<EOL>    initHelpers(config, templateContext);<EOL>    const executionSettings = Object.assign( DEFAULT_SETTINGS, settings);<EOL>    const templates = config.templates;<EOL>    Object.keys(templates).forEach((templateName) => {<EOL>        debugLog(`<STR_LIT>`);<EOL>        registerPartial(templateName,  templates[templateName]);<EOL>    });<EOL>    let mergedDocuments;<EOL>    if (!executionSettings.generateDocuments) {<EOL>        debugLog(`<STR_LIT>`);<EOL>         mergedDocuments = {<EOL>             fragments: [],<EOL>            operations: [],<EOL>            hasFragments: false,<EOL>            hasOperations: false,<EOL>        };<EOL>    }<EOL>    else {<EOL>        mergedDocuments = documents.reduce((previousValue, item) => {<EOL>            const opArr = [...previousValue.operations, ...item.operations];<EOL>            const frArr = [...previousValue. fragments, ...item.fragments];<EOL>            return {<EOL>                operations: opArr,<EOL>                fragments: frArr,<EOL>                hasFragments: frArr.length > <NUM_LIT>,<EOL>                hasOperations: opArr.length > <NUM_LIT>,<EOL>            };<EOL>        }, { hasFragments: false, hasOperations: false, operations: [], fragments: [] });<EOL>        debugLog(`<STR_LIT>`);<EOL>        if (","gt":"config.flattenTypes) {"}
{"input":"<s> export function compileTemplate(config, templateContext, documents = [], settings = DEFAULT_SETTINGS) {<EOL>    if (!config) {<EOL>        throw new Error(`<STR_LIT>`);<EOL>    }<EOL>    debugLog(`<STR_LIT>`);<EOL>    debugLog(`<STR_LIT>`, settings);<EOL>    initHelpers(config, templateContext);<EOL>    const executionSettings = Object.assign( DEFAULT_SETTINGS, settings);<EOL>    const templates = config.templates;<EOL>    Object.keys(templates).forEach((templateName) => {<EOL>        debugLog(`<STR_LIT>`);<EOL>        registerPartial(templateName,  templates[templateName]);<EOL>    });<EOL>    let mergedDocuments;<EOL>    if (!executionSettings.generateDocuments) {<EOL>        debugLog(`<STR_LIT>`);<EOL>         mergedDocuments = {<EOL>             fragments: [],<EOL>            operations: [],<EOL>            hasFragments: false,<EOL>            hasOperations: false,<EOL>        };<EOL>    }<EOL>    else {<EOL>        mergedDocuments = documents.reduce((previousValue, item) => {<EOL>            const opArr = [...previousValue.operations, ...item.operations];<EOL>            const frArr = [...previousValue. fragments, ...item.fragments];<EOL>            return {<EOL>                operations: opArr,<EOL>                fragments: frArr,<EOL>                hasFragments: frArr.length > <NUM_LIT>,<EOL>                hasOperations: opArr.length > <NUM_LIT>,<EOL>            };<EOL>        }, { hasFragments: false, hasOperations: false, operations: [], fragments: [] });<EOL>        debugLog(`<STR_LIT>`);<EOL>        if ( config.flattenTypes) {<EOL>            debugLog(`<STR_LIT>`);<EOL>            mergedDocuments = flattenTypes(mergedDocuments);<EOL>        }<EOL>    }<EOL>    if (config.inputType === EInputType.SINGLE_FILE) {<EOL>        if (!templates['<STR_LIT>']) {<EOL>            throw new Error(`<STR_LIT>`);<EOL>        }<EOL>        if (!config.outFile) {<EOL>            throw","gt":"new Error('<STR_LIT>');"}
{"input":"<s> export function compileTemplate(config, templateContext, documents = [], settings = DEFAULT_SETTINGS) {<EOL>    if (!config) {<EOL>        throw new Error(`<STR_LIT>`);<EOL>    }<EOL>    debugLog(`<STR_LIT>`);<EOL>    debugLog(`<STR_LIT>`, settings);<EOL>    initHelpers(config, templateContext);<EOL>    const executionSettings = Object.assign( DEFAULT_SETTINGS, settings);<EOL>    const templates = config.templates;<EOL>    Object.keys(templates).forEach((templateName) => {<EOL>        debugLog(`<STR_LIT>`);<EOL>        registerPartial(templateName,  templates[templateName]);<EOL>    });<EOL>    let mergedDocuments;<EOL>    if (!executionSettings.generateDocuments) {<EOL>        debugLog(`<STR_LIT>`);<EOL>         mergedDocuments = {<EOL>             fragments: [],<EOL>            operations: [],<EOL>            hasFragments: false,<EOL>            hasOperations: false,<EOL>        };<EOL>    }<EOL>    else {<EOL>        mergedDocuments = documents.reduce((previousValue, item) => {<EOL>            const opArr = [...previousValue.operations, ...item.operations];<EOL>            const frArr = [...previousValue. fragments, ...item.fragments];<EOL>            return {<EOL>                operations: opArr,<EOL>                fragments: frArr,<EOL>                hasFragments: frArr.length > <NUM_LIT>,<EOL>                hasOperations: opArr.length > <NUM_LIT>,<EOL>            };<EOL>        }, { hasFragments: false, hasOperations: false, operations: [], fragments: [] });<EOL>        debugLog(`<STR_LIT>`);<EOL>        if ( config.flattenTypes) {<EOL>            debugLog(`<STR_LIT>`);<EOL>            mergedDocuments = flattenTypes(mergedDocuments);<EOL>        }<EOL>    }<EOL>    if (config.inputType === EInputType.SINGLE_FILE) {<EOL>        if (!templates['<STR_LIT>']) {<EOL>            throw new Error(`<STR_LIT>`);<EOL>        }<EOL>        if (!config.outFile) {<EOL>            throw  new Error('<STR_LIT>');<EOL>        }<EOL>        debugLog(`<STR_LIT>`);<EOL>        return generateSingleFile(compile(cleanTemplateComments(templates['<STR_LIT>'])), executionSettings, config, templateContext, mergedDocuments);<EOL>    }<EOL>    else if (config.inputType === EInputType.MULTIPLE_FILES ||","gt":"config.inputType === EInputType.PROJECT) {"}
{"input":"<s> export function compileTemplate(config, templateContext, documents = [], settings = DEFAULT_SETTINGS) {<EOL>    if (!config) {<EOL>        throw new Error(`<STR_LIT>`);<EOL>    }<EOL>    debugLog(`<STR_LIT>`);<EOL>    debugLog(`<STR_LIT>`, settings);<EOL>    initHelpers(config, templateContext);<EOL>    const executionSettings = Object.assign( DEFAULT_SETTINGS, settings);<EOL>    const templates = config.templates;<EOL>    Object.keys(templates).forEach((templateName) => {<EOL>        debugLog(`<STR_LIT>`);<EOL>        registerPartial(templateName,  templates[templateName]);<EOL>    });<EOL>    let mergedDocuments;<EOL>    if (!executionSettings.generateDocuments) {<EOL>        debugLog(`<STR_LIT>`);<EOL>         mergedDocuments = {<EOL>             fragments: [],<EOL>            operations: [],<EOL>            hasFragments: false,<EOL>            hasOperations: false,<EOL>        };<EOL>    }<EOL>    else {<EOL>        mergedDocuments = documents.reduce((previousValue, item) => {<EOL>            const opArr = [...previousValue.operations, ...item.operations];<EOL>            const frArr = [...previousValue. fragments, ...item.fragments];<EOL>            return {<EOL>                operations: opArr,<EOL>                fragments: frArr,<EOL>                hasFragments: frArr.length > <NUM_LIT>,<EOL>                hasOperations: opArr.length > <NUM_LIT>,<EOL>            };<EOL>        }, { hasFragments: false, hasOperations: false, operations: [], fragments: [] });<EOL>        debugLog(`<STR_LIT>`);<EOL>        if ( config.flattenTypes) {<EOL>            debugLog(`<STR_LIT>`);<EOL>            mergedDocuments = flattenTypes(mergedDocuments);<EOL>        }<EOL>    }<EOL>    if (config.inputType === EInputType.SINGLE_FILE) {<EOL>        if (!templates['<STR_LIT>']) {<EOL>            throw new Error(`<STR_LIT>`);<EOL>        }<EOL>        if (!config.outFile) {<EOL>            throw  new Error('<STR_LIT>');<EOL>        }<EOL>        debugLog(`<STR_LIT>`);<EOL>        return generateSingleFile(compile(cleanTemplateComments(templates['<STR_LIT>'])), executionSettings, config, templateContext, mergedDocuments);<EOL>    }<EOL>    else if (config.inputType === EInputType.MULTIPLE_FILES ||  config.inputType === EInputType.PROJECT) {<EOL>        if (config.inputType === EInputType.MULTIPLE_FILES) {<EOL>            if (!config.","gt":"filesExtension) {"}
{"input":"<s> export function compileTemplate(config, templateContext, documents = [], settings = DEFAULT_SETTINGS) {<EOL>    if (!config) {<EOL>        throw new Error(`<STR_LIT>`);<EOL>    }<EOL>    debugLog(`<STR_LIT>`);<EOL>    debugLog(`<STR_LIT>`, settings);<EOL>    initHelpers(config, templateContext);<EOL>    const executionSettings = Object.assign( DEFAULT_SETTINGS, settings);<EOL>    const templates = config.templates;<EOL>    Object.keys(templates).forEach((templateName) => {<EOL>        debugLog(`<STR_LIT>`);<EOL>        registerPartial(templateName,  templates[templateName]);<EOL>    });<EOL>    let mergedDocuments;<EOL>    if (!executionSettings.generateDocuments) {<EOL>        debugLog(`<STR_LIT>`);<EOL>         mergedDocuments = {<EOL>             fragments: [],<EOL>            operations: [],<EOL>            hasFragments: false,<EOL>            hasOperations: false,<EOL>        };<EOL>    }<EOL>    else {<EOL>        mergedDocuments = documents.reduce((previousValue, item) => {<EOL>            const opArr = [...previousValue.operations, ...item.operations];<EOL>            const frArr = [...previousValue. fragments, ...item.fragments];<EOL>            return {<EOL>                operations: opArr,<EOL>                fragments: frArr,<EOL>                hasFragments: frArr.length > <NUM_LIT>,<EOL>                hasOperations: opArr.length > <NUM_LIT>,<EOL>            };<EOL>        }, { hasFragments: false, hasOperations: false, operations: [], fragments: [] });<EOL>        debugLog(`<STR_LIT>`);<EOL>        if ( config.flattenTypes) {<EOL>            debugLog(`<STR_LIT>`);<EOL>            mergedDocuments = flattenTypes(mergedDocuments);<EOL>        }<EOL>    }<EOL>    if (config.inputType === EInputType.SINGLE_FILE) {<EOL>        if (!templates['<STR_LIT>']) {<EOL>            throw new Error(`<STR_LIT>`);<EOL>        }<EOL>        if (!config.outFile) {<EOL>            throw  new Error('<STR_LIT>');<EOL>        }<EOL>        debugLog(`<STR_LIT>`);<EOL>        return generateSingleFile(compile(cleanTemplateComments(templates['<STR_LIT>'])), executionSettings, config, templateContext, mergedDocuments);<EOL>    }<EOL>    else if (config.inputType === EInputType.MULTIPLE_FILES ||  config.inputType === EInputType.PROJECT) {<EOL>        if (config.inputType === EInputType.MULTIPLE_FILES) {<EOL>            if (!config. filesExtension) {<EOL>                throw new Error('<STR_LIT>');<EOL>            }<EOL>        }<EOL>        debugLog(`<STR_LIT>`);<EOL>        const compiledTemplates = Object.keys(templates).map((templateName) => {<EOL>            debugLog(`<STR_LIT>`);<EOL>            const compiledTemplate = compile(cleanTemplateComments(templates[templateName], templateName));<EOL>            return {<EOL>                key: templateName,<EOL>                value: compiledTemplate,<EOL>            };<EOL>        }).reduce((","gt":"prev, item) => {"}
{"input":"<s> export function compileTemplate(config, templateContext, documents = [], settings = DEFAULT_SETTINGS) {<EOL>    if (!config) {<EOL>        throw new Error(`<STR_LIT>`);<EOL>    }<EOL>    debugLog(`<STR_LIT>`);<EOL>    debugLog(`<STR_LIT>`, settings);<EOL>    initHelpers(config, templateContext);<EOL>    const executionSettings = Object.assign( DEFAULT_SETTINGS, settings);<EOL>    const templates = config.templates;<EOL>    Object.keys(templates).forEach((templateName) => {<EOL>        debugLog(`<STR_LIT>`);<EOL>        registerPartial(templateName,  templates[templateName]);<EOL>    });<EOL>    let mergedDocuments;<EOL>    if (!executionSettings.generateDocuments) {<EOL>        debugLog(`<STR_LIT>`);<EOL>         mergedDocuments = {<EOL>             fragments: [],<EOL>            operations: [],<EOL>            hasFragments: false,<EOL>            hasOperations: false,<EOL>        };<EOL>    }<EOL>    else {<EOL>        mergedDocuments = documents.reduce((previousValue, item) => {<EOL>            const opArr = [...previousValue.operations, ...item.operations];<EOL>            const frArr = [...previousValue. fragments, ...item.fragments];<EOL>            return {<EOL>                operations: opArr,<EOL>                fragments: frArr,<EOL>                hasFragments: frArr.length > <NUM_LIT>,<EOL>                hasOperations: opArr.length > <NUM_LIT>,<EOL>            };<EOL>        }, { hasFragments: false, hasOperations: false, operations: [], fragments: [] });<EOL>        debugLog(`<STR_LIT>`);<EOL>        if ( config.flattenTypes) {<EOL>            debugLog(`<STR_LIT>`);<EOL>            mergedDocuments = flattenTypes(mergedDocuments);<EOL>        }<EOL>    }<EOL>    if (config.inputType === EInputType.SINGLE_FILE) {<EOL>        if (!templates['<STR_LIT>']) {<EOL>            throw new Error(`<STR_LIT>`);<EOL>        }<EOL>        if (!config.outFile) {<EOL>            throw  new Error('<STR_LIT>');<EOL>        }<EOL>        debugLog(`<STR_LIT>`);<EOL>        return generateSingleFile(compile(cleanTemplateComments(templates['<STR_LIT>'])), executionSettings, config, templateContext, mergedDocuments);<EOL>    }<EOL>    else if (config.inputType === EInputType.MULTIPLE_FILES ||  config.inputType === EInputType.PROJECT) {<EOL>        if (config.inputType === EInputType.MULTIPLE_FILES) {<EOL>            if (!config. filesExtension) {<EOL>                throw new Error('<STR_LIT>');<EOL>            }<EOL>        }<EOL>        debugLog(`<STR_LIT>`);<EOL>        const compiledTemplates = Object.keys(templates).map((templateName) => {<EOL>            debugLog(`<STR_LIT>`);<EOL>            const compiledTemplate = compile(cleanTemplateComments(templates[templateName], templateName));<EOL>            return {<EOL>                key: templateName,<EOL>                value: compiledTemplate,<EOL>            };<EOL>        }).reduce(( prev, item) => {<EOL>            prev[","gt":"item.key] = item.value;"}
{"input":"<s> export function compileTemplate(config, templateContext, documents = [], settings = DEFAULT_SETTINGS) {<EOL>    if (!config) {<EOL>        throw new Error(`<STR_LIT>`);<EOL>    }<EOL>    debugLog(`<STR_LIT>`);<EOL>    debugLog(`<STR_LIT>`, settings);<EOL>    initHelpers(config, templateContext);<EOL>    const executionSettings = Object.assign( DEFAULT_SETTINGS, settings);<EOL>    const templates = config.templates;<EOL>    Object.keys(templates).forEach((templateName) => {<EOL>        debugLog(`<STR_LIT>`);<EOL>        registerPartial(templateName,  templates[templateName]);<EOL>    });<EOL>    let mergedDocuments;<EOL>    if (!executionSettings.generateDocuments) {<EOL>        debugLog(`<STR_LIT>`);<EOL>         mergedDocuments = {<EOL>             fragments: [],<EOL>            operations: [],<EOL>            hasFragments: false,<EOL>            hasOperations: false,<EOL>        };<EOL>    }<EOL>    else {<EOL>        mergedDocuments = documents.reduce((previousValue, item) => {<EOL>            const opArr = [...previousValue.operations, ...item.operations];<EOL>            const frArr = [...previousValue. fragments, ...item.fragments];<EOL>            return {<EOL>                operations: opArr,<EOL>                fragments: frArr,<EOL>                hasFragments: frArr.length > <NUM_LIT>,<EOL>                hasOperations: opArr.length > <NUM_LIT>,<EOL>            };<EOL>        }, { hasFragments: false, hasOperations: false, operations: [], fragments: [] });<EOL>        debugLog(`<STR_LIT>`);<EOL>        if ( config.flattenTypes) {<EOL>            debugLog(`<STR_LIT>`);<EOL>            mergedDocuments = flattenTypes(mergedDocuments);<EOL>        }<EOL>    }<EOL>    if (config.inputType === EInputType.SINGLE_FILE) {<EOL>        if (!templates['<STR_LIT>']) {<EOL>            throw new Error(`<STR_LIT>`);<EOL>        }<EOL>        if (!config.outFile) {<EOL>            throw  new Error('<STR_LIT>');<EOL>        }<EOL>        debugLog(`<STR_LIT>`);<EOL>        return generateSingleFile(compile(cleanTemplateComments(templates['<STR_LIT>'])), executionSettings, config, templateContext, mergedDocuments);<EOL>    }<EOL>    else if (config.inputType === EInputType.MULTIPLE_FILES ||  config.inputType === EInputType.PROJECT) {<EOL>        if (config.inputType === EInputType.MULTIPLE_FILES) {<EOL>            if (!config. filesExtension) {<EOL>                throw new Error('<STR_LIT>');<EOL>            }<EOL>        }<EOL>        debugLog(`<STR_LIT>`);<EOL>        const compiledTemplates = Object.keys(templates).map((templateName) => {<EOL>            debugLog(`<STR_LIT>`);<EOL>            const compiledTemplate = compile(cleanTemplateComments(templates[templateName], templateName));<EOL>            return {<EOL>                key: templateName,<EOL>                value: compiledTemplate,<EOL>            };<EOL>        }).reduce(( prev, item) => {<EOL>            prev[ item.key] = item.value;<EOL>            return prev;<EOL>        }, {})","gt":";"}
{"input":"<s> export function separateSelectionSet(selectionSet) {<EOL>    const fields = selectionSet.filter((n) => isFieldNode(n));<EOL>    const fragmentsSpread = selectionSet.filter((n) => isFragmentSpreadNode(n));<EOL>    const inlineFragments = selectionSet.filter((n) => isInlineFragmentNode(n));<EOL>","gt":"return {"}
{"input":"<s> export function separateSelectionSet(selectionSet) {<EOL>    const fields = selectionSet.filter((n) => isFieldNode(n));<EOL>    const fragmentsSpread = selectionSet.filter((n) => isFragmentSpreadNode(n));<EOL>    const inlineFragments = selectionSet.filter((n) => isInlineFragmentNode(n));<EOL>     return {<EOL>        fragmentsSpread,<EOL>        fields,<EOL>        inlineFragments,<EOL>        hasFragmentsSpread: fragmentsSpread.length > <NUM_LIT>,<EOL>        hasFields: fields.","gt":"length > <NUM_LIT>,"}
{"input":"<s> export function isFragmentSpreadNode(node) {<EOL>    return","gt":"node['<STR_LIT>'] !== undefined;"}
{"input":"<s> export default function getAppRootPath() {<EOL>    let cwd = process.cwd();<EOL>","gt":"while (!fs.existsSync(path.join(cwd, \"<STR_LIT>\"))) {"}
{"input":"<s> export function getAst() {<EOL>    const ast = new TsSimpleAst({<EOL>        tsConfigFilePath: path.join(rootFolder, \"<STR_LIT>\"),<EOL>        addFilesFromTsConfig: false,<EOL>","gt":"manipulationSettings: {"}
{"input":"<s> export function getAst() {<EOL>    const ast = new TsSimpleAst({<EOL>        tsConfigFilePath: path.join(rootFolder, \"<STR_LIT>\"),<EOL>        addFilesFromTsConfig: false,<EOL>         manipulationSettings: {<EOL>            newLineKind: NewLineKind.CarriageReturnLineFeed<EOL>        }<EOL>    });<EOL>    ast.addExistingSourceFiles(path.","gt":"join(rootFolder, \"<STR_LIT>\"));"}
{"input":"<s> <EOL>function isPropertyToIgnore(prop) {<EOL>","gt":"return prop.getName() === \"<STR_LIT>\" ||"}
{"input":"<s> export function LiteralLikeNode(Base) {<EOL>    return class extends Base {<EOL>        getLiteralText() {<EOL>            return this.compilerNode.text;<EOL>        }<EOL>        isTerminated() {<EOL>            <EOL>            return !(this.compilerNode.isUnterminated || false);<EOL>        }<EOL>        hasExtendedUnicodeEscape() {<EOL>            return this.","gt":"compilerNode.hasExtendedUnicodeEscape || false;"}
{"input":"<s> export function NamedNode(Base) {<EOL>    return class extends Base {<EOL>        getNameNode() {<EOL>            return this.getNodeFromCompilerNode(this.compilerNode.name);<EOL>        }<EOL>        getName() {<EOL>            return this.getNameNode().getText();<EOL>        }<EOL>        rename(newName) {<EOL>            if (newName === this.getName())<EOL>                return this;<EOL>            errors.throwIfNotStringOrWhitespace(newName, nameof(newName));<EOL>            this.","gt":"getNameNode().rename(newName);"}
{"input":"<s> export function NamedNode(Base) {<EOL>    return class extends Base {<EOL>        getNameNode() {<EOL>            return this.getNodeFromCompilerNode(this.compilerNode.name);<EOL>        }<EOL>        getName() {<EOL>            return this.getNameNode().getText();<EOL>        }<EOL>        rename(newName) {<EOL>            if (newName === this.getName())<EOL>                return this;<EOL>            errors.throwIfNotStringOrWhitespace(newName, nameof(newName));<EOL>            this. getNameNode().rename(newName);<EOL>            return this;<EOL>        }<EOL>        fill(structure) {<EOL>","gt":"callBaseFill(Base.prototype, this, structure);"}
{"input":"<s> function getOverloadsAndImplementation(node) {<EOL>    const parentSyntaxList = node.getParentSyntaxListOrThrow();<EOL>    const name = getNameIfNamedNode(node);<EOL>    const kind =","gt":"node.getKind();"}
{"input":"<s> <EOL>export function throwIfRangeOutOfRange(actualRange, range, argName) {<EOL>    if (actualRange[<NUM_LIT>] > actualRange[<NUM_LIT>])<EOL>        throw new","gt":"ArgumentError(argName, `<STR_LIT>`);"}
{"input":"<s> export function fillAndGetChildren(opts) {<EOL>    const children = getRangeFromArray(opts.allChildren, opts.index, opts.structures.length, opts.expectedKind);<EOL>    if (opts.fillFunction != null) {<EOL>        for (let i = <NUM_LIT>;","gt":"i < children.length; i++) {"}
{"input":"<s> export function fromExportableNode(node) {<EOL>    return {<EOL>","gt":"isDefaultExport: node.hasDefaultKeyword(),"}
{"input":"<s> export function insertIntoCreatableSyntaxList(opts) {<EOL>    const { insertPos, newText, parent, syntaxList, childIndex, insertItemsCount } = opts;<EOL>    if (syntaxList == null)<EOL>        insertSyntaxList({<EOL>            parent,<EOL>","gt":"insertPos,"}
{"input":"<s> export function insertIntoCreatableSyntaxList(opts) {<EOL>    const { insertPos, newText, parent, syntaxList, childIndex, insertItemsCount } = opts;<EOL>    if (syntaxList == null)<EOL>        insertSyntaxList({<EOL>            parent,<EOL>             insertPos,<EOL>            newText<EOL>        });<EOL>    else<EOL>","gt":"insertIntoParent({"}
{"input":"<s> export function insertIntoCreatableSyntaxList(opts) {<EOL>    const { insertPos, newText, parent, syntaxList, childIndex, insertItemsCount } = opts;<EOL>    if (syntaxList == null)<EOL>        insertSyntaxList({<EOL>            parent,<EOL>             insertPos,<EOL>            newText<EOL>        });<EOL>    else<EOL>         insertIntoParent({<EOL>            insertPos,<EOL>            newText,<EOL>","gt":"parent: syntaxList,"}
{"input":"<s> <EOL>export function replaceSourceFileTextForRename(opts) {<EOL>    const { sourceFile, renameLocations,","gt":"newName } = opts;"}
{"input":"<s> function getInfo(text) {<EOL>    return getInfoFromTextWithDescendant(","gt":"text, SyntaxKind.JsxClosingElement, { isJsx: true });"}
{"input":"<s> function getInfo(text) {<EOL>    return getInfoFromTextWithDescendant(text,","gt":"SyntaxKind.JsxExpression, { isJsx: true });"}
{"input":"<s> function getStringLiteral(text) {<EOL>    return getInfoFromTextWithDescendant(text,","gt":"SyntaxKind.StringLiteral).descendant;"}
{"input":"<s> function getStatement(text) {<EOL>    return","gt":"getInfoFromTextWithDescendant(text, SyntaxKind.DoStatement).descendant;"}
{"input":"<s> function getStatement(text) {<EOL>    return getInfoFromTextWithDescendant(text,","gt":"SyntaxKind.WithStatement).descendant;"}
{"input":"<s> <EOL>export function isStringKind(kind) {<EOL>    switch (kind) {<EOL>        case SyntaxKind.StringLiteral:<EOL>        case SyntaxKind.FirstTemplateToken:<EOL>        case","gt":"SyntaxKind.TemplateHead:"}
{"input":"<s> <EOL>export function isStringKind(kind) {<EOL>    switch (kind) {<EOL>        case SyntaxKind.StringLiteral:<EOL>        case SyntaxKind.FirstTemplateToken:<EOL>        case  SyntaxKind.TemplateHead:<EOL>        case SyntaxKind.TemplateMiddle:<EOL>        case SyntaxKind.LastTemplateToken:<EOL>            return true;<EOL>","gt":"default:"}
{"input":"<s> function getFileSystemEntries(path, fileSystemWrapper) {<EOL>    const files = [];<EOL>    const directories = [];<EOL>    try {<EOL>        const entries = fileSystemWrapper.readDirSync(path);<EOL>        for (const entry","gt":"of entries) {"}
{"input":"<s> function getFileSystemEntries(path, fileSystemWrapper) {<EOL>    const files = [];<EOL>    const directories = [];<EOL>    try {<EOL>        const entries = fileSystemWrapper.readDirSync(path);<EOL>        for (const entry  of entries) {<EOL>            if (fileSystemWrapper.fileExistsSync(entry))<EOL>                files.push(entry);<EOL>            else<EOL>                directories.","gt":"push(entry);"}
{"input":"<s> function getFileSystemEntries(path, fileSystemWrapper) {<EOL>    const files = [];<EOL>    const directories = [];<EOL>    try {<EOL>        const entries = fileSystemWrapper.readDirSync(path);<EOL>        for (const entry  of entries) {<EOL>            if (fileSystemWrapper.fileExistsSync(entry))<EOL>                files.push(entry);<EOL>            else<EOL>                directories. push(entry);<EOL>        }<EOL>    }<EOL>    catch (err) {<EOL>","gt":"if (!FileUtils.isNotExistsError(err))"}
{"input":"<s> export async function makeHot(id, componentLoader, acceptFunc) {<EOL>    if (module.hot) {<EOL>        api.install(Vue);<EOL>","gt":"if (!api.compatible) {"}
{"input":"<s> async function submitCertification(cert, to, logger = null) {<EOL>    try {<EOL>        await to.postCert(cert);<EOL>","gt":"logger && logger.trace('<STR_LIT>', cert.from.substr(<NUM_LIT>, <NUM_LIT>), cert.idty_uid);"}
{"input":"<s> export function isCommandViewContextWithRemote(context) {<EOL>","gt":"return context.type === '<STR_LIT>' && context.node.remote && context.node.remote instanceof GitRemote;"}
{"input":"<s> export function runCommand(command, args, options = {}) {<EOL>    const { stdin, stdinEncoding, ...opts } = { maxBuffer: <NUM_LIT> * <NUM_LIT> * <NUM_LIT>, ...options };<EOL>    return new Promise((resolve, reject) => {<EOL>        const proc = execFile(command, args, opts, (err, stdout,","gt":"stderr) => {"}
{"input":"<s> export function runCommand(command, args, options = {}) {<EOL>    const { stdin, stdinEncoding, ...opts } = { maxBuffer: <NUM_LIT> * <NUM_LIT> * <NUM_LIT>, ...options };<EOL>    return new Promise((resolve, reject) => {<EOL>        const proc = execFile(command, args, opts, (err, stdout,  stderr) => {<EOL>            if (!err) {<EOL>                if (","gt":"stderr) {"}
{"input":"<s> export function runCommand(command, args, options = {}) {<EOL>    const { stdin, stdinEncoding, ...opts } = { maxBuffer: <NUM_LIT> * <NUM_LIT> * <NUM_LIT>, ...options };<EOL>    return new Promise((resolve, reject) => {<EOL>        const proc = execFile(command, args, opts, (err, stdout,  stderr) => {<EOL>            if (!err) {<EOL>                if ( stderr) {<EOL>                    Logger.warn(`<STR_LIT>`);<EOL>                }<EOL>                resolve(stdout);<EOL>                return;<EOL>            }<EOL>            if (err.message === '<STR_LIT>') {<EOL>                reject(new Error(`<STR_LIT>`));<EOL>            }<EOL>            Logger.warn(`<STR_LIT>`);<EOL>","gt":"reject(err);"}
{"input":"<s> function _getInfiniteCancellablePromise(cancellation) {<EOL>    return new Promise((resolve, reject) => {<EOL>        const disposable = cancellation.token.","gt":"onCancellationRequested(() => {"}
{"input":"<s> function buildParseFn(patterns, defaultType) {<EOL>    return ([, result], { type } = { type: defaultType }) => (patterns[","gt":"type] || patterns[defaultType])"}
{"input":"<s> function getStorageRef(reject, arg) {<EOL>    if (typeof (FIRStorage) === \"<STR_LIT>\") {<EOL>        reject(\"<STR_LIT>\");<EOL>","gt":"return;"}
{"input":"<s> export function max(source, ignoreNaN = false) {<EOL>    return ifSet(source, -Infinity,","gt":"ignoreNaN, (n, result) => n > result);"}
{"input":"<s> export function min(source, ignoreNaN = false) {<EOL>    return ifSet(source, +Infinity, ignoreNaN, (n, result) => n <","gt":"result);"}
{"input":"<s> <EOL>export function mergeSort(target) {<EOL>    if (!target)<EOL>        throw new","gt":"ArgumentNullException(\"<STR_LIT>\");"}
{"input":"<s> function sort(target, start, end, temp) {<EOL>    if (end - start > <NUM_LIT>) {<EOL>        <EOL>        const middle = Math.floor((start + end) / <NUM_LIT>);<EOL>        sort(target, start, middle, temp);<EOL>        sort(target,","gt":"middle, end, temp);"}
{"input":"<s> function sort(target, start, end, temp) {<EOL>    if (end - start > <NUM_LIT>) {<EOL>        <EOL>        const middle = Math.floor((start + end) / <NUM_LIT>);<EOL>        sort(target, start, middle, temp);<EOL>        sort(target,  middle, end, temp);<EOL>        <EOL>        for (let i = <NUM_LIT>, len = target.length; i < len; i++) {<EOL>","gt":"temp[i] = target[i];"}
{"input":"<s> function sort(target, start, end, temp) {<EOL>    if (end - start > <NUM_LIT>) {<EOL>        <EOL>        const middle = Math.floor((start + end) / <NUM_LIT>);<EOL>        sort(target, start, middle, temp);<EOL>        sort(target,  middle, end, temp);<EOL>        <EOL>        for (let i = <NUM_LIT>, len = target.length; i < len; i++) {<EOL>             temp[i] = target[i];<EOL>        }<EOL>        <EOL>        let k = start, i = start, j = middle;<EOL>        <EOL>        while (i < middle && j <","gt":"end) {"}
{"input":"<s> function ensureExternal(node, list) {<EOL>    if (!node)<EOL>        return null;<EOL>","gt":"if (!list)"}
{"input":"<s> export function Integer(n) {<EOL>    return Math.floor(","gt":"n);"}
{"input":"<s> export function assertKey(key, name = ITEM) {<EOL>    assertNotUndefined(key, name + DOT + KEY);<EOL>    if (","gt":"key === null)"}
{"input":"<s> function canMatch(source, match) {<EOL>    if (!Type.isString(source) || !match)<EOL>        return","gt":"false;"}
{"input":"<s> function areInvalid(v, d) {<EOL>    if (!areEqual(v, d)) {<EOL>","gt":"let memberType = new TypeInfoHelper(v);"}
{"input":"<s> function comparer() {<EOL>","gt":"test(comparerResults, comparerSort);"}
{"input":"<s> function report(name, fn) {<EOL>    if (","gt":"count > <NUM_LIT>)"}
{"input":"<s> function s3Url(options) {<EOL>    let url;<EOL>    if (options.endpoint != null) {<EOL>        url = `<STR_LIT>`;<EOL>    }<EOL>","gt":"else {"}
{"input":"<s> function s3Url(options) {<EOL>    let url;<EOL>    if (options.endpoint != null) {<EOL>        url = `<STR_LIT>`;<EOL>    }<EOL>     else {<EOL>        if (!options.bucket.includes(\"<STR_LIT>\")) {<EOL>            if (options.region === \"<STR_LIT>\") {<EOL>                url = `<STR_LIT>`;<EOL>            }<EOL>            else {<EOL>                url = `<STR_LIT>`;<EOL>            }<EOL>        }<EOL>        else {<EOL>            if (options.region ==","gt":"null) {"}
{"input":"<s> function s3Url(options) {<EOL>    let url;<EOL>    if (options.endpoint != null) {<EOL>        url = `<STR_LIT>`;<EOL>    }<EOL>     else {<EOL>        if (!options.bucket.includes(\"<STR_LIT>\")) {<EOL>            if (options.region === \"<STR_LIT>\") {<EOL>                url = `<STR_LIT>`;<EOL>            }<EOL>            else {<EOL>                url = `<STR_LIT>`;<EOL>            }<EOL>        }<EOL>        else {<EOL>            if (options.region ==  null) {<EOL>                throw new Error(`<STR_LIT>`);<EOL>            }<EOL>            <EOL>            url = options.region === \"<STR_LIT>\"<EOL>                ? `<STR_LIT>`<EOL>                :","gt":"region}.amazonaws.com/${options.bucket}`<STR_LIT>;"}
{"input":"<s> function stringify(buffer) {<EOL>    return byte2hex[buffer[<NUM_LIT>]] + byte2hex[buffer[<NUM_LIT>]] +<EOL>        byte2hex[buffer[<NUM_LIT>]] + byte2hex[buffer[<NUM_LIT>]] + \"<STR_LIT>\" +<EOL>        byte2hex[buffer[<NUM_LIT>]] + byte2hex[buffer[","gt":"<NUM_LIT>]] + \"<STR_LIT>\" +"}
{"input":"<s> export function orIfFileNotExist(promise, fallbackValue) {<EOL>    return promise<EOL>        .catch((e) => {<EOL>        if (","gt":"e.code === \"<STR_LIT>\" || e.code === \"<STR_LIT>\") {"}
{"input":"<s> <EOL>export function execWine(file, args, options = EXEC_TIMEOUT) {<EOL>    if (process.platform === \"<STR_LIT>\") {<EOL>        return exec(file, args, options);<EOL>    }<EOL>    else {<EOL>        return wineExecutable.","gt":"value"}
{"input":"<s> <EOL>export function execWine(file, args, options = EXEC_TIMEOUT) {<EOL>    if (process.platform === \"<STR_LIT>\") {<EOL>        return exec(file, args, options);<EOL>    }<EOL>    else {<EOL>        return wineExecutable. value<EOL>            .then((wine) => {<EOL>            const effectiveOptions = wine.env == null ? options : { ...options };<EOL>            if (wine.env != null) {<EOL>                effectiveOptions.env = options.env ==","gt":"null ? wine.env : {"}
{"input":"<s> export async function readAsar(archive) {<EOL>    const fd = await open(archive, \"<STR_LIT>\");<EOL>    let size;<EOL>    let headerBuf;<EOL>","gt":"try {"}
{"input":"<s> export async function readAsar(archive) {<EOL>    const fd = await open(archive, \"<STR_LIT>\");<EOL>    let size;<EOL>    let headerBuf;<EOL>     try {<EOL>        const sizeBuf = Buffer.allocUnsafe(<NUM_LIT>);<EOL>        if (await read(fd, sizeBuf, <NUM_LIT>, <NUM_LIT>, null) !== <NUM_LIT>) {<EOL>            throw","gt":"new Error(\"<STR_LIT>\");"}
{"input":"<s> export async function readAsar(archive) {<EOL>    const fd = await open(archive, \"<STR_LIT>\");<EOL>    let size;<EOL>    let headerBuf;<EOL>     try {<EOL>        const sizeBuf = Buffer.allocUnsafe(<NUM_LIT>);<EOL>        if (await read(fd, sizeBuf, <NUM_LIT>, <NUM_LIT>, null) !== <NUM_LIT>) {<EOL>            throw  new Error(\"<STR_LIT>\");<EOL>        }<EOL>        const sizePickle = createFromBuffer(sizeBuf);<EOL>        size = sizePickle.createIterator().readUInt32();<EOL>        headerBuf = Buffer.allocUnsafe(size);<EOL>        if (await read(fd, headerBuf, <NUM_LIT>, size, null) !==","gt":"size) {"}
{"input":"<s> export async function readAsar(archive) {<EOL>    const fd = await open(archive, \"<STR_LIT>\");<EOL>    let size;<EOL>    let headerBuf;<EOL>     try {<EOL>        const sizeBuf = Buffer.allocUnsafe(<NUM_LIT>);<EOL>        if (await read(fd, sizeBuf, <NUM_LIT>, <NUM_LIT>, null) !== <NUM_LIT>) {<EOL>            throw  new Error(\"<STR_LIT>\");<EOL>        }<EOL>        const sizePickle = createFromBuffer(sizeBuf);<EOL>        size = sizePickle.createIterator().readUInt32();<EOL>        headerBuf = Buffer.allocUnsafe(size);<EOL>        if (await read(fd, headerBuf, <NUM_LIT>, size, null) !==  size) {<EOL>            throw new Error(\"<STR_LIT>\");<EOL>        }<EOL>    }<EOL>","gt":"finally {"}
{"input":"<s> export function chooseNotNull(v1, v2) {<EOL>    return v1 == null ?","gt":"v2 : v1;"}
{"input":"<s> export async function writeUpdateInfoFiles(updateInfoFileTasks, packager) {<EOL>    <EOL>    updateInfoFileTasks.sort((a, b) => (a.info.files[<NUM_LIT>].url.endsWith(\"<STR_LIT>\") ? <NUM_LIT> : <NUM_LIT>) - (b.info.files[<NUM_LIT>].url.endsWith(\"<STR_LIT>\") ? <NUM_LIT> : <NUM_LIT>));<EOL>    const updateChannelFileToInfo = new Map();<EOL>    for (const task of updateInfoFileTasks) {<EOL>        const key =","gt":"safeStringifyJson(task.publishConfiguration)}`<STR_LIT>;"}
{"input":"<s> export async function writeUpdateInfoFiles(updateInfoFileTasks, packager) {<EOL>    <EOL>    updateInfoFileTasks.sort((a, b) => (a.info.files[<NUM_LIT>].url.endsWith(\"<STR_LIT>\") ? <NUM_LIT> : <NUM_LIT>) - (b.info.files[<NUM_LIT>].url.endsWith(\"<STR_LIT>\") ? <NUM_LIT> : <NUM_LIT>));<EOL>    const updateChannelFileToInfo = new Map();<EOL>    for (const task of updateInfoFileTasks) {<EOL>        const key = `<STR_LIT>`;<EOL>        const existingTask = updateChannelFileToInfo.get(key);<EOL>        if (existingTask == null) {<EOL>            updateChannelFileToInfo.set(key,","gt":"task);"}
{"input":"<s> export async function writeUpdateInfoFiles(updateInfoFileTasks, packager) {<EOL>    <EOL>    updateInfoFileTasks.sort((a, b) => (a.info.files[<NUM_LIT>].url.endsWith(\"<STR_LIT>\") ? <NUM_LIT> : <NUM_LIT>) - (b.info.files[<NUM_LIT>].url.endsWith(\"<STR_LIT>\") ? <NUM_LIT> : <NUM_LIT>));<EOL>    const updateChannelFileToInfo = new Map();<EOL>    for (const task of updateInfoFileTasks) {<EOL>        const key = `<STR_LIT>`;<EOL>        const existingTask = updateChannelFileToInfo.get(key);<EOL>        if (existingTask == null) {<EOL>            updateChannelFileToInfo.set(key,  task);<EOL>            continue;<EOL>        }<EOL>","gt":"existingTask.info.files.push(...task.info.files);"}
{"input":"<s> export async function writeUpdateInfoFiles(updateInfoFileTasks, packager) {<EOL>    <EOL>    updateInfoFileTasks.sort((a, b) => (a.info.files[<NUM_LIT>].url.endsWith(\"<STR_LIT>\") ? <NUM_LIT> : <NUM_LIT>) - (b.info.files[<NUM_LIT>].url.endsWith(\"<STR_LIT>\") ? <NUM_LIT> : <NUM_LIT>));<EOL>    const updateChannelFileToInfo = new Map();<EOL>    for (const task of updateInfoFileTasks) {<EOL>        const key = `<STR_LIT>`;<EOL>        const existingTask = updateChannelFileToInfo.get(key);<EOL>        if (existingTask == null) {<EOL>            updateChannelFileToInfo.set(key,  task);<EOL>            continue;<EOL>        }<EOL>         existingTask.info.files.push(...task.info.files);<EOL>    }<EOL>    const releaseDate = new Date().toISOString();<EOL>","gt":"await BluebirdPromise.map(updateChannelFileToInfo.values(), async (task) => {"}
{"input":"<s> export async function writeUpdateInfoFiles(updateInfoFileTasks, packager) {<EOL>    <EOL>    updateInfoFileTasks.sort((a, b) => (a.info.files[<NUM_LIT>].url.endsWith(\"<STR_LIT>\") ? <NUM_LIT> : <NUM_LIT>) - (b.info.files[<NUM_LIT>].url.endsWith(\"<STR_LIT>\") ? <NUM_LIT> : <NUM_LIT>));<EOL>    const updateChannelFileToInfo = new Map();<EOL>    for (const task of updateInfoFileTasks) {<EOL>        const key = `<STR_LIT>`;<EOL>        const existingTask = updateChannelFileToInfo.get(key);<EOL>        if (existingTask == null) {<EOL>            updateChannelFileToInfo.set(key,  task);<EOL>            continue;<EOL>        }<EOL>         existingTask.info.files.push(...task.info.files);<EOL>    }<EOL>    const releaseDate = new Date().toISOString();<EOL>     await BluebirdPromise.map(updateChannelFileToInfo.values(), async (task) => {<EOL>        task.info.releaseDate = releaseDate;<EOL>        const fileContent = Buffer.from(serializeToYaml(task.info));<EOL>        await outputFile(task.file, fileContent);<EOL>        packager.dispatchArtifactCreated({<EOL>            file: task.","gt":"file,"}
{"input":"<s> function getZstdCompressionLevel(endpoint) {<EOL>    const result = process.env.ELECTRON_BUILD_SERVICE_ZSTD_COMPRESSION;<EOL>    if (result != null) {<EOL>        return","gt":"result;"}
{"input":"<s> export function getDestinationPath(file, fileSet) {<EOL>    if (file === fileSet.src) {<EOL>        return fileSet.destination;<EOL>    }<EOL>    else {<EOL>        const src = ensureEndSlash(fileSet.src);<EOL>","gt":"const dest = ensureEndSlash(fileSet.destination);"}
{"input":"<s> export function getDestinationPath(file, fileSet) {<EOL>    if (file === fileSet.src) {<EOL>        return fileSet.destination;<EOL>    }<EOL>    else {<EOL>        const src = ensureEndSlash(fileSet.src);<EOL>         const dest = ensureEndSlash(fileSet.destination);<EOL>        if (file.startsWith(src)) {<EOL>            return dest + file.substring(src.length);<EOL>        }<EOL>","gt":"else {"}
{"input":"<s> export function getDestinationPath(file, fileSet) {<EOL>    if (file === fileSet.src) {<EOL>        return fileSet.destination;<EOL>    }<EOL>    else {<EOL>        const src = ensureEndSlash(fileSet.src);<EOL>         const dest = ensureEndSlash(fileSet.destination);<EOL>        if (file.startsWith(src)) {<EOL>            return dest + file.substring(src.length);<EOL>        }<EOL>         else {<EOL>            <EOL>            const index = file.lastIndexOf(NODE_MODULES_PATTERN);<EOL>            if (index < <NUM_LIT>) {<EOL>                throw new Error(","gt":"file}\"<STR_LIT>\"${fileSet.src}\"<STR_LIT>;"}
{"input":"<s> function getPackageToolPath() {<EOL>    if (process.env.FORCE_YARN === \"<STR_LIT>\") {<EOL>        return process.","gt":"platform === \"<STR_LIT>\" ? \"<STR_LIT>\" : \"<STR_LIT>\";"}
{"input":"<s> export async function getWindowsVm(debugLogger) {<EOL>    const vmList = (await parseVmList(debugLogger)).filter((it) => it.os === \"<STR_LIT>\");<EOL>    if (","gt":"vmList.length === <NUM_LIT>) {"}
{"input":"<s> function quoteString(s) {<EOL>    if (!s.includes(\"<STR_LIT>\") && !s.includes('<STR_LIT>')) {<EOL>        return","gt":"s;"}
{"input":"<s> function buildEntryMap(list) {<EOL>    const result = new Map();<EOL>    for (","gt":"const item of list) {"}
{"input":"<s> export async function checkHelpers(resourceDir, packElevateHelper) {<EOL>    const elevateHelperExecutable = path.join(resourceDir, \"<STR_LIT>\");<EOL>    if (packElevateHelper) {<EOL>","gt":"await assertThat(elevateHelperExecutable).isFile();"}
{"input":"<s> export function logProcess(label, data, labelColor, lineFilter = null) {<EOL>    const log = filterText(data.toString(), lineFilter);<EOL>    if (log == null || log.length === <NUM_LIT>) {<EOL>","gt":"return;"}
{"input":"<s> function configureDevelopmentPlugins(configurator) {<EOL>    const plugins = configurator.plugins;<EOL>    plugins.push(new NamedModulesPlugin());<EOL>    plugins.push(new DefinePlugin({<EOL>        __static: `<STR_LIT>`<EOL>    }));<EOL>    plugins.push(new","gt":"HotModuleReplacementPlugin());"}
{"input":"<s> function configureDevelopmentPlugins(configurator) {<EOL>    const plugins = configurator.plugins;<EOL>    plugins.push(new NamedModulesPlugin());<EOL>    plugins.push(new DefinePlugin({<EOL>        __static: `<STR_LIT>`<EOL>    }));<EOL>    plugins.push(new  HotModuleReplacementPlugin());<EOL>    if (configurator.hasDevDependency(\"<STR_LIT>\")) {<EOL>        const WebpackNotifierPlugin = require(\"<STR_LIT>\");<EOL>        plugins.","gt":"push(new WebpackNotifierPlugin({"}
{"input":"<s> function configureDevelopmentPlugins(configurator) {<EOL>    const plugins = configurator.plugins;<EOL>    plugins.push(new NamedModulesPlugin());<EOL>    plugins.push(new DefinePlugin({<EOL>        __static: `<STR_LIT>`<EOL>    }));<EOL>    plugins.push(new  HotModuleReplacementPlugin());<EOL>    if (configurator.hasDevDependency(\"<STR_LIT>\")) {<EOL>        const WebpackNotifierPlugin = require(\"<STR_LIT>\");<EOL>        plugins. push(new WebpackNotifierPlugin({<EOL>            title: `<STR_LIT>`,<EOL>            suppressSuccess: \"<STR_LIT>\",<EOL>","gt":"sound: false,"}
{"input":"<s> function configureDevelopmentPlugins(configurator) {<EOL>    const plugins = configurator.plugins;<EOL>    plugins.push(new NamedModulesPlugin());<EOL>    plugins.push(new DefinePlugin({<EOL>        __static: `<STR_LIT>`<EOL>    }));<EOL>    plugins.push(new  HotModuleReplacementPlugin());<EOL>    if (configurator.hasDevDependency(\"<STR_LIT>\")) {<EOL>        const WebpackNotifierPlugin = require(\"<STR_LIT>\");<EOL>        plugins. push(new WebpackNotifierPlugin({<EOL>            title: `<STR_LIT>`,<EOL>            suppressSuccess: \"<STR_LIT>\",<EOL>             sound: false,<EOL>        }));<EOL>    }<EOL>    if (","gt":"configurator.hasDevDependency(\"<STR_LIT>\")) {"}
{"input":"<s> function addCustomResolver(configuration) {<EOL>    expect(configuration.resolveLoader).toBeUndefined();<EOL>","gt":"configuration.resolveLoader = {"}
{"input":"<s> export async function doTest(configurationFile, electronWebpackConfiguration) {<EOL>    const projectDir = await getMutableProjectDir();<EOL>","gt":"const finalConfiguration = { projectDir, ...electronWebpackConfiguration };"}
{"input":"<s> export function getBaseUrl() {<EOL>    return","gt":"document.getElementsByTagName('<STR_LIT>')[<NUM_LIT>].href;"}
{"input":"<s> <EOL><EOL>export function line(ctx, color = Color.Red.clone(), x1, y1, x2, y2, thickness = <NUM_LIT>, cap = '<STR_LIT>') {<EOL>    ctx.beginPath();<EOL>    ctx.lineWidth = thickness;<EOL>    ctx.lineCap =","gt":"cap;"}
{"input":"<s> export default function (data) {<EOL>","gt":"var store = createStore(reducer, data, composeEnhancers(applyMiddleware(promiseMiddleware)));"}
{"input":"<s> export function fileWriteRequest(request, plugins) {<EOL>    const pluginsToRun = pluginsToRunForAlgebraicType(plugins, request.typeInformation);<EOL>    const wrappedPlugins = List.map(objcPluginForAlgebraicTypePlugin, pluginsToRun);<EOL>    const typeInfoProvider =","gt":"{"}
{"input":"<s> function readFileForFoundObjectSpec(path) {<EOL>    return FileReader.read(path).map(function (either) {<EOL>        return Logging.munit(Either.map(function (","gt":"contents) {"}
{"input":"<s> function loggerForParsedArgs(parsedArgs) {<EOL>    return {<EOL>        interestedLoggingTypes: parsedArgs.interestedLoggingTypes,<EOL>","gt":"minimalLevel: parsedArgs.minimalLevel,"}
{"input":"<s> function propagateGenerationSuccessError(errors) {<EOL>    return Promise.munit(","gt":"Logging.munit(Either.Left(errors)));"}
{"input":"<s> export function mapLoggedSequence3(seq, f, g) {<EOL>    return seq.map(","gt":"toAsyncLoggingPipelineForm(f))"}
{"input":"<s> export function mapLoggedSequence(seq, f) {<EOL>","gt":"return seq.map(toAsyncLoggingPipelineForm(f));"}
{"input":"<s> export function generate(directoryRunFrom, extension, configFileName, optionalConfigPath, configurationContext, parsedArgs) {<EOL>    const requestedPath = PathUtils.getAbsolutePathFromDirectoryAndAbsoluteOrRelativePath(File.getAbsoluteFilePath(directoryRunFrom), parsedArgs.givenPath);<EOL>    const outputPath = outputDirectory(directoryRunFrom, parsedArgs.outputPath);<EOL>    const valueObjectCreationContextFuture =","gt":"getObjectSpecCreationContext(valueObjectConfigPathFuture(configFileName, requestedPath, optionalConfigPath), configurationContext, parsedArgs);"}
{"input":"<s> function verify(xhr) {<EOL>    return Right(xhr)<EOL>        .bind((xhr) => /2..|304/.test(`<STR_LIT>`)<EOL>        ? Right(","gt":"xhr)"}
{"input":"<s> export function blur(document) {<EOL>    if (document !== window.document || document.activeElement === document.body)<EOL>","gt":"return;"}
{"input":"<s> function remove(el) {<EOL>","gt":"return void el.remove();"}
{"input":"<s> <EOL>export function overwrite(tr, changeset, specialStatus = SpecialStatus.DIRTY) {<EOL>    return {<EOL>        type: Actions.","gt":"OVERWRITE_RESOURCE,"}
{"input":"<s> function update(uuid, statusBeforeError) {<EOL>    return function (dispatch, getState) {<EOL>","gt":"const { index } = getState().resources;"}
{"input":"<s> export function onMalformed() {<EOL>    bothUp();<EOL>    if (!HACKY_FLAGS.","gt":"alreadyToldUserAboutMalformedMsg) {"}
{"input":"<s> export function storeUUID(uuid) {<EOL>    outstandingRequests.last = cleanUUID(","gt":"uuid);"}
{"input":"<s> <EOL>export function maybeNegateStatus(x) {<EOL>    const { consistent, <EOL>    <EOL>    syncStatus, fbosVersion, autoSync } = x;<EOL>    <EOL>    if (","gt":"consistent) {"}
{"input":"<s> <EOL>export function maybeNegateStatus(x) {<EOL>    const { consistent, <EOL>    <EOL>    syncStatus, fbosVersion, autoSync } = x;<EOL>    <EOL>    if ( consistent) {<EOL>        return syncStatus;<EOL>    }<EOL>    switch (determineStrategy({ autoSync, fbosVersion })) {<EOL>        case SyncStrat.","gt":"AUTO:"}
{"input":"<s> <EOL>export function maybeNegateStatus(x) {<EOL>    const { consistent, <EOL>    <EOL>    syncStatus, fbosVersion, autoSync } = x;<EOL>    <EOL>    if ( consistent) {<EOL>        return syncStatus;<EOL>    }<EOL>    switch (determineStrategy({ autoSync, fbosVersion })) {<EOL>        case SyncStrat. AUTO:<EOL>            return \"<STR_LIT>\";<EOL>        case SyncStrat.LEGACY:<EOL>        case SyncStrat.MANUAL:<EOL>","gt":"return \"<STR_LIT>\";"}
{"input":"<s> export function execSequence(sequence) {<EOL>    const noun = \"<STR_LIT>\";<EOL>    if (sequence.id) {<EOL>","gt":"commandOK(noun)();"}
{"input":"<s> export function factoryReset() {<EOL>    if (!confirm(t(Content.FACTORY_RESET_ALERT))) {<EOL>","gt":"return;"}
{"input":"<s> export function homeAll(speed) {<EOL>    const noun = \"<STR_LIT>\";<EOL>","gt":"getDevice()"}
{"input":"<s> function initLocalStorage() {<EOL>    localStorage[STORAGE_KEY] =","gt":"\"<STR_LIT>\";"}
{"input":"<s> function dev() {<EOL>    store = createStore(rootReducer, maybeFetchOldState(), getMiddleware(","gt":"\"<STR_LIT>\"));"}
{"input":"<s> <EOL>function maybeRecalculateLocalSequenceVariables(next) {<EOL>    (next.","gt":"kind === \"<STR_LIT>\") && doRecalculateLocalSequenceVariables(next);"}
{"input":"<s> function whoops(origin, kind) {<EOL>    const","gt":"msg = `<STR_LIT>`;"}
{"input":"<s> export function hasId(ri, k, id) {<EOL>    return !!ri.byKindAndId[joinKindAndId(","gt":"k, id)];"}
{"input":"<s> export function safeBooleanSettting(name) {<EOL>    if (isBooleanSetting(name)) {<EOL>","gt":"return name;"}
{"input":"<s> function safelyFetchErrors(err) {<EOL>    <EOL>    if (err && err.response && err.response.data) {<EOL>        return err.response.data;<EOL>    }<EOL>    else {<EOL>        return {<EOL>            error: t(\"<STR_LIT>\" +<EOL>","gt":"\"<STR_LIT>\")"}
{"input":"<s> <EOL>export function stopIE() {<EOL>    function flunk() {<EOL>        <EOL>        <EOL>        const READ_THE_COMMENT_ABOVE = \"<STR_LIT>\";<EOL>        alert(READ_THE_COMMENT_ABOVE);<EOL>","gt":"window.location.href = \"<STR_LIT>\";"}
{"input":"<s> <EOL>export function stopIE() {<EOL>    function flunk() {<EOL>        <EOL>        <EOL>        const READ_THE_COMMENT_ABOVE = \"<STR_LIT>\";<EOL>        alert(READ_THE_COMMENT_ABOVE);<EOL>         window.location.href = \"<STR_LIT>\";<EOL>    }<EOL>    try {<EOL>        const REQUIRED_GLOBALS = [","gt":"\"<STR_LIT>\", \"<STR_LIT>\", \"<STR_LIT>\", \"<STR_LIT>\"];"}
{"input":"<s> <EOL>export function stopIE() {<EOL>    function flunk() {<EOL>        <EOL>        <EOL>        const READ_THE_COMMENT_ABOVE = \"<STR_LIT>\";<EOL>        alert(READ_THE_COMMENT_ABOVE);<EOL>         window.location.href = \"<STR_LIT>\";<EOL>    }<EOL>    try {<EOL>        const REQUIRED_GLOBALS = [ \"<STR_LIT>\", \"<STR_LIT>\", \"<STR_LIT>\", \"<STR_LIT>\"];<EOL>        <EOL>        <EOL>        for (let i = <NUM_LIT>; i < REQUIRED_GLOBALS.","gt":"length; i++) {"}
{"input":"<s> export function reference(base, prop) {<EOL>    return {<EOL>","gt":"type: '<STR_LIT>',"}
{"input":"<s> export function snapshotVariable(name) {<EOL>    return cast(variable(name),","gt":"'<STR_LIT>');"}
{"input":"<s> <EOL><EOL>export function generate(symbols) {<EOL>    if (typeof symbols === '<STR_LIT>') {<EOL>","gt":"symbols = parser.parse(symbols);"}
{"input":"<s> <EOL>export function isURL(urlStr) {<EOL>    if (typeof urlStr !== '<STR_LIT>') {<EOL>        return false;<EOL>    }<EOL>    <EOL>","gt":"const re = /[^a-z0-9\\:\\/\\?\\#\\[\\]\\@\\!\\$\\&\\'\\(\\)\\*\\+\\,\\;\\=\\.\\-\\_\\~\\%]/i;"}
{"input":"<s> <EOL>export function isURL(urlStr) {<EOL>    if (typeof urlStr !== '<STR_LIT>') {<EOL>        return false;<EOL>    }<EOL>    <EOL>     const re = /[^a-z0-9\\:\\/\\?\\#\\[\\]\\@\\!\\$\\&\\'\\(\\)\\*\\+\\,\\;\\=\\.\\-\\_\\~\\%]/i;<EOL>    if (re.test(urlStr)) {<EOL>        return","gt":"false;"}
{"input":"<s> <EOL>export function isURL(urlStr) {<EOL>    if (typeof urlStr !== '<STR_LIT>') {<EOL>        return false;<EOL>    }<EOL>    <EOL>     const re = /[^a-z0-9\\:\\/\\?\\#\\[\\]\\@\\!\\$\\&\\'\\(\\)\\*\\+\\,\\;\\=\\.\\-\\_\\~\\%]/i;<EOL>    if (re.test(urlStr)) {<EOL>        return  false;<EOL>    }<EOL>    try {<EOL>        const uri = url.parse(urlStr);<EOL>        const scheme = uri.protocol;<EOL>","gt":"const slashes = uri.slashes;"}
{"input":"<s> <EOL>export function isURL(urlStr) {<EOL>    if (typeof urlStr !== '<STR_LIT>') {<EOL>        return false;<EOL>    }<EOL>    <EOL>     const re = /[^a-z0-9\\:\\/\\?\\#\\[\\]\\@\\!\\$\\&\\'\\(\\)\\*\\+\\,\\;\\=\\.\\-\\_\\~\\%]/i;<EOL>    if (re.test(urlStr)) {<EOL>        return  false;<EOL>    }<EOL>    try {<EOL>        const uri = url.parse(urlStr);<EOL>        const scheme = uri.protocol;<EOL>         const slashes = uri.slashes;<EOL>        const hostname = uri.hostname;<EOL>        const pathname = uri.pathname;<EOL>        if ((scheme !== '<STR_LIT>' && scheme !== '<STR_LIT>') || !slashes) {<EOL>            return","gt":"false;"}
{"input":"<s> <EOL>export function isURL(urlStr) {<EOL>    if (typeof urlStr !== '<STR_LIT>') {<EOL>        return false;<EOL>    }<EOL>    <EOL>     const re = /[^a-z0-9\\:\\/\\?\\#\\[\\]\\@\\!\\$\\&\\'\\(\\)\\*\\+\\,\\;\\=\\.\\-\\_\\~\\%]/i;<EOL>    if (re.test(urlStr)) {<EOL>        return  false;<EOL>    }<EOL>    try {<EOL>        const uri = url.parse(urlStr);<EOL>        const scheme = uri.protocol;<EOL>         const slashes = uri.slashes;<EOL>        const hostname = uri.hostname;<EOL>        const pathname = uri.pathname;<EOL>        if ((scheme !== '<STR_LIT>' && scheme !== '<STR_LIT>') || !slashes) {<EOL>            return  false;<EOL>        }<EOL>        <EOL>        <EOL>        if (!/^[a-zA-Z0-9]+[\\w\\-]*([\\.]?[a-zA-Z0-9]+[\\w\\-]*)*$/.test(","gt":"hostname)) {"}
{"input":"<s> <EOL>export function isURL(urlStr) {<EOL>    if (typeof urlStr !== '<STR_LIT>') {<EOL>        return false;<EOL>    }<EOL>    <EOL>     const re = /[^a-z0-9\\:\\/\\?\\#\\[\\]\\@\\!\\$\\&\\'\\(\\)\\*\\+\\,\\;\\=\\.\\-\\_\\~\\%]/i;<EOL>    if (re.test(urlStr)) {<EOL>        return  false;<EOL>    }<EOL>    try {<EOL>        const uri = url.parse(urlStr);<EOL>        const scheme = uri.protocol;<EOL>         const slashes = uri.slashes;<EOL>        const hostname = uri.hostname;<EOL>        const pathname = uri.pathname;<EOL>        if ((scheme !== '<STR_LIT>' && scheme !== '<STR_LIT>') || !slashes) {<EOL>            return  false;<EOL>        }<EOL>        <EOL>        <EOL>        if (!/^[a-zA-Z0-9]+[\\w\\-]*([\\.]?[a-zA-Z0-9]+[\\w\\-]*)*$/.test( hostname)) {<EOL>            return false;<EOL>        }<EOL>        <EOL>        <EOL>        const pathnameRe = /^(\\/[\\w\\-\\.\\~\\!\\$\\'\\(\\)\\*\\+\\,\\;\\=\\:\\@\\%]+)*$/;<EOL>        <EOL>        if (pathname &&<EOL>","gt":"pathname !== '<STR_LIT>' &&"}
{"input":"<s> <EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL>export function dateToTimestampProto(timeString) {<EOL>    if (typeof timeString === '<STR_LIT>') {<EOL>        return;<EOL>    }<EOL>    let","gt":"date = new Date(timeString);"}
{"input":"<s> <EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL>export function dateToTimestampProto(timeString) {<EOL>    if (typeof timeString === '<STR_LIT>') {<EOL>        return;<EOL>    }<EOL>    let  date = new Date(timeString);<EOL>    let seconds = Math.floor(date.getTime() / <NUM_LIT>);<EOL>    let nanos = <NUM_LIT>;<EOL>    if (timeString.length > <NUM_LIT>) {<EOL>        const nanoString = timeString.substring(<NUM_LIT>, timeString.length - <NUM_LIT>);<EOL>        const trailingZeroes = <NUM_LIT> - nanoString.length;<EOL>        nanos = parseInt(","gt":"nanoString, <NUM_LIT>) * Math.pow(<NUM_LIT>, trailingZeroes);"}
{"input":"<s> function copyFields(from, to, fields) {<EOL>    for (","gt":"let field of fields) {"}
{"input":"<s> <EOL>export function instance(instance) {<EOL>    return","gt":"new InstanceBuilder(instance);"}
{"input":"<s> export function setMaxNode(val) {<EOL>","gt":"MAX_NODE = val;"}
{"input":"<s> <EOL>function mutationsStore(txn) {<EOL>    return getStore(txn, DbMutationBatch.","gt":"store);"}
{"input":"<s> <EOL>export function validateNamedArrayAtLeastNumberOfElements(functionName, value, name, minNumberOfElements) {<EOL>    if (!(value instanceof Array) || value.length < minNumberOfElements) {<EOL>","gt":"throw new FirestoreError(Code.INVALID_ARGUMENT, `<STR_LIT>` +"}
{"input":"<s> <EOL>export function valueDescription(input) {<EOL>    if (input === undefined) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    else if (input === null) {<EOL>","gt":"return '<STR_LIT>';"}
{"input":"<s> <EOL>export function valueDescription(input) {<EOL>    if (input === undefined) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    else if (input === null) {<EOL>         return '<STR_LIT>';<EOL>    }<EOL>    else if (","gt":"typeof input === '<STR_LIT>') {"}
{"input":"<s> <EOL>export function valueDescription(input) {<EOL>    if (input === undefined) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    else if (input === null) {<EOL>         return '<STR_LIT>';<EOL>    }<EOL>    else if ( typeof input === '<STR_LIT>') {<EOL>        if (input.length > <NUM_LIT>) {<EOL>            input = `<STR_LIT>`;<EOL>        }<EOL>        return","gt":"JSON.stringify(input);"}
{"input":"<s> export function debug(tag, msg, ...obj) {<EOL>    if (logClient.logLevel <= FirebaseLogLevel.DEBUG) {<EOL>        const","gt":"args = obj.map(argToString);"}
{"input":"<s> export function shallowCopy(obj) {<EOL>    assert(obj && typeof obj === '<STR_LIT>', '<STR_LIT>');<EOL>    const result = {};<EOL>    for (const key in","gt":"obj) {"}
{"input":"<s> <EOL><EOL><EOL><EOL>function validationIt(persistence, message, testFunction) {<EOL>    it(message, () => {<EOL>        return withTestDb(persistence, async (db) => {<EOL>            const maybePromise =","gt":"testFunction(db);"}
{"input":"<s> function isIeOrEdge() {<EOL>    const ua = window.navigator.userAgent;<EOL>    return (ua.indexOf(","gt":"'<STR_LIT>') > <NUM_LIT> ||"}
{"input":"<s> <EOL>export function toDataArray(docSet) {<EOL>    return docSet.docs.map((","gt":"d) => d.data());"}
{"input":"<s> <EOL>export function withAlternateTestDb(persistence, fn) {<EOL>    return","gt":"withTestDbsSettings(persistence, ALT_PROJECT_ID, DEFAULT_SETTINGS, <NUM_LIT>, ([db]) => {"}
{"input":"<s> function aggregator(version, targets, outstanding, ...changes) {<EOL>    const aggregator = new WatchChangeAggregator(SnapshotVersion.fromMicroseconds(","gt":"version), targets, outstanding);"}
{"input":"<s> export function documentSet(...args) {<EOL>    let docSet = null;<EOL>    if (args[<NUM_LIT>] instanceof Function) {<EOL>        docSet = new DocumentSet(args[<NUM_LIT>]);<EOL>        args =","gt":"args.slice(<NUM_LIT>);"}
{"input":"<s> export function documentSet(...args) {<EOL>    let docSet = null;<EOL>    if (args[<NUM_LIT>] instanceof Function) {<EOL>        docSet = new DocumentSet(args[<NUM_LIT>]);<EOL>        args =  args.slice(<NUM_LIT>);<EOL>    }<EOL>    else {<EOL>        docSet = new DocumentSet();<EOL>    }<EOL>    for (const doc of args) {<EOL>        assert(doc instanceof Document,","gt":"'<STR_LIT>' + doc);"}
{"input":"<s> export function patchMutation(keyStr, json, precondition) {<EOL>    if (precondition === undefined) {<EOL>","gt":"precondition = Precondition.exists(true);"}
{"input":"<s> <EOL>export function size(obj) {<EOL>    let c =","gt":"<NUM_LIT>;"}
{"input":"<s> export function fromResourceString(authWrapper, resourceString, mappings) {<EOL>    let obj = json.","gt":"jsonObjectOrNull(resourceString);"}
{"input":"<s> export function forEach(obj, f) {<EOL>    for (let key in obj) {<EOL>        if (","gt":"contains(obj, key)) {"}
{"input":"<s> export function reject(error) {<EOL>","gt":"return Promise.reject(error);"}
{"input":"<s> <EOL>export function handlerCheck(cndn) {<EOL>","gt":"if (!cndn) {"}
{"input":"<s> export function objectErrorHandler(location) {<EOL>    let shared = sharedErrorHandler(location);<EOL>    function errorHandler(xhr, err) {<EOL>        let newErr = shared(xhr, err);<EOL>        if (xhr.","gt":"getStatus() === <NUM_LIT>) {"}
{"input":"<s> export function objectErrorHandler(location) {<EOL>    let shared = sharedErrorHandler(location);<EOL>    function errorHandler(xhr, err) {<EOL>        let newErr = shared(xhr, err);<EOL>        if (xhr. getStatus() === <NUM_LIT>) {<EOL>            newErr = errorsExports.objectNotFound(location.path);<EOL>        }<EOL>        newErr.setServerResponseProp(err.serverResponseProp());<EOL>        return","gt":"newErr;"}
{"input":"<s> function authWrapperWithHandler(handler) {<EOL>    function newSend(xhrio, url, method, body, headers) {<EOL>        const response = handler(url, method, body, headers);<EOL>        xhrio.simulateResponse(response.","gt":"status, response.body, response.headers);"}
{"input":"<s> <EOL><EOL>export function deepCopy(value) {<EOL>    return deepExtend(undefined,","gt":"value);"}
{"input":"<s> export function pad(str, len = <NUM_LIT>, ch = '<STR_LIT>') {<EOL>    str = String(str);<EOL>    ch = toString(ch);<EOL>    let i = -<NUM_LIT>;<EOL>    const length = len - str.length;<EOL>    let","gt":"left = true;"}
{"input":"<s> export function pad(str, len = <NUM_LIT>, ch = '<STR_LIT>') {<EOL>    str = String(str);<EOL>    ch = toString(ch);<EOL>    let i = -<NUM_LIT>;<EOL>    const length = len - str.length;<EOL>    let  left = true;<EOL>    while (++i < length) {<EOL>        const l = (str.length + ch.length <= len) ? (str.length + ch.length) : (str.length + <NUM_LIT>);<EOL>        if (left) {<EOL>            str = leftPad(str,","gt":"l, ch);"}
{"input":"<s> export function IpValidatorMessage(err, field) {<EOL>    return","gt":"field.formControl.value}\"<STR_LIT>;"}
{"input":"<s> <EOL>export function reducer(state = initialState, action) {<EOL>    switch (action.type) {<EOL>        case wallAction.ActionTypes.WALL_SEARCH: {<EOL>            return Object.assign({}, state, {<EOL>                loading: true<EOL>            });<EOL>        }<EOL>        case apiAction.ActionTypes.WALL_SEARCH_COMPLETE_SUCCESS:<EOL>        case apiAction.ActionTypes.WALL_SEARCH_COMPLETE_FAIL: {<EOL>            return Object.assign({},","gt":"state, {"}
{"input":"<s> <EOL>export function reducer(state = initialState, action) {<EOL>    switch (action.type) {<EOL>        case wallAction.ActionTypes.WALL_SEARCH: {<EOL>            return Object.assign({}, state, {<EOL>                loading: true<EOL>            });<EOL>        }<EOL>        case apiAction.ActionTypes.WALL_SEARCH_COMPLETE_SUCCESS:<EOL>        case apiAction.ActionTypes.WALL_SEARCH_COMPLETE_FAIL: {<EOL>            return Object.assign({},  state, {<EOL>                loading: false<EOL>            });<EOL>        }<EOL>","gt":"default: {"}
{"input":"<s> <EOL>export function instantiate(load, origInstantiate) {<EOL>    logger.","gt":"debug(`<STR_LIT>`);"}
{"input":"<s> function incrementPos(pos, nodes) {<EOL>    if (pos.upperIndex === <NUM_LIT> && pos.lowerIndex === pos.upper.slots.length - <NUM_LIT>) {<EOL>        return;<EOL>    }<EOL>    if (pos.upperIndex === <NUM_LIT> && pos.lowerIndex >= pos.lastLowerIndex) {<EOL>        pos.lowerIndex = <NUM_LIT>;<EOL>","gt":"pos.upperIndex++;"}
{"input":"<s> function incrementPos(pos, nodes) {<EOL>    if (pos.upperIndex === <NUM_LIT> && pos.lowerIndex === pos.upper.slots.length - <NUM_LIT>) {<EOL>        return;<EOL>    }<EOL>    if (pos.upperIndex === <NUM_LIT> && pos.lowerIndex >= pos.lastLowerIndex) {<EOL>        pos.lowerIndex = <NUM_LIT>;<EOL>         pos.upperIndex++;<EOL>        pos.upper = nodes[pos.upperIndex];<EOL>    }<EOL>    else {<EOL>        pos.","gt":"lowerIndex++;"}
{"input":"<s> function incrementPos(pos, nodes) {<EOL>    if (pos.upperIndex === <NUM_LIT> && pos.lowerIndex === pos.upper.slots.length - <NUM_LIT>) {<EOL>        return;<EOL>    }<EOL>    if (pos.upperIndex === <NUM_LIT> && pos.lowerIndex >= pos.lastLowerIndex) {<EOL>        pos.lowerIndex = <NUM_LIT>;<EOL>         pos.upperIndex++;<EOL>        pos.upper = nodes[pos.upperIndex];<EOL>    }<EOL>    else {<EOL>        pos. lowerIndex++;<EOL>    }<EOL>    pos.absoluteIndex++;<EOL>    var lower = pos.upper.slots[","gt":"pos.lowerIndex];"}
{"input":"<s> <EOL>function isAncestor(upperView, lowerView, listSize) {<EOL>    if (upperView.isRoot())<EOL>","gt":"return true;"}
{"input":"<s> export function gatherLeafValues(arg, flatten = true) {<EOL>    var slot = arg instanceof Slot ? arg : rootSlot(arg);<EOL>","gt":"return flatten"}
{"input":"<s> export function fromIterable(iterable) {<EOL>    let map = empty(true);<EOL>    let current;<EOL>","gt":"let it = iterable[Symbol.iterator]();"}
{"input":"<s> export function fromIterable(iterable) {<EOL>    let map = empty(true);<EOL>    let current;<EOL>     let it = iterable[Symbol.iterator]();<EOL>    while (!(current = it.next()).done) {<EOL>","gt":"var entry = current.value;"}
{"input":"<s> export function fromIterable(iterable) {<EOL>    let map = empty(true);<EOL>    let current;<EOL>     let it = iterable[Symbol.iterator]();<EOL>    while (!(current = it.next()).done) {<EOL>         var entry = current.value;<EOL>        const change =","gt":"ChangeFlag.get();"}
{"input":"<s> export function bitmapToIndex(shift, bitmap) {<EOL>    return hammingWeight(shift & (","gt":"bitmap - <NUM_LIT>));"}
{"input":"<s> export function fromPairsWithStringKeys(pairs, mutability) {<EOL>","gt":"return fromPairs(stringCompare, pairs, mutability);"}
{"input":"<s> export function assignValue(value, node) {<EOL>    const v = node.value;<EOL>    <EOL>    if (v === value || (v !== null &&","gt":"typeof v === '<STR_LIT>' && v == value)) {"}
{"input":"<s> export function isNone(node) {<EOL>    return node ===","gt":"NONE;"}
{"input":"<s> export function fromIterable(values) {<EOL>","gt":"return createSet(values);"}
{"input":"<s> export function intersect(other, main) {<EOL>    var immutable = isImmutable(main);<EOL>    var outputSet = immutable ? emptySet(true) : modify(main);<EOL>    var outputMap = immutable ? outputSet._map : HashMap.empty(outputSet);<EOL>    if (isHashSet(other)) {<EOL>        intersectHashSet(main._map, other._map, outputMap);<EOL>    }<EOL>    else if (Array.isArray(other)) {<EOL>        intersectArray(main._map, other, outputMap);<EOL>    }<EOL>    else if (other && typeof other === '<STR_LIT>') {<EOL>        if (","gt":"isIterable(other)) {"}
{"input":"<s> export function intersect(other, main) {<EOL>    var immutable = isImmutable(main);<EOL>    var outputSet = immutable ? emptySet(true) : modify(main);<EOL>    var outputMap = immutable ? outputSet._map : HashMap.empty(outputSet);<EOL>    if (isHashSet(other)) {<EOL>        intersectHashSet(main._map, other._map, outputMap);<EOL>    }<EOL>    else if (Array.isArray(other)) {<EOL>        intersectArray(main._map, other, outputMap);<EOL>    }<EOL>    else if (other && typeof other === '<STR_LIT>') {<EOL>        if ( isIterable(other)) {<EOL>            intersectIterable(main._map, other[Symbol.iterator](), outputMap);<EOL>        }<EOL>    }<EOL>    if (HashMap.size(outputMap) ===","gt":"HashMap.size(main._map)) {"}
{"input":"<s> export function set(key, value, map) {<EOL>    var nextSet = modify(map);<EOL>    const modified = setItem(key,","gt":"value, nextSet._indexed, nextSet._sorted, nextSet._select);"}
{"input":"<s> function createComparatorFn(compare) {<EOL>    var fn = COMPARATOR_CACHE.get(compare);<EOL>    return isDefined(fn) ?","gt":"fn : (fn = function (a, b) {"}
{"input":"<s> export function isEmpty(set) {<EOL>    return _size(","gt":"set._tree) === <NUM_LIT>;"}
{"input":"<s> export function isEqual(set, other) {<EOL>    if (set === other)<EOL>        return true;<EOL>    if (size(set) !== size(other) ||<EOL>        set._select !== other._select ||<EOL>        set._compare !==","gt":"other._compare)"}
{"input":"<s> export function isEqual(set, other) {<EOL>    if (set === other)<EOL>        return true;<EOL>    if (size(set) !== size(other) ||<EOL>        set._select !== other._select ||<EOL>        set._compare !==  other._compare)<EOL>        return false;<EOL>    var a = set._tree, b = other._tree;<EOL>    var ita = iterateFromFirst(a), itb = iterateFromFirst(b);<EOL>","gt":"do {"}
{"input":"<s> export function isEqual(set, other) {<EOL>    if (set === other)<EOL>        return true;<EOL>    if (size(set) !== size(other) ||<EOL>        set._select !== other._select ||<EOL>        set._compare !==  other._compare)<EOL>        return false;<EOL>    var a = set._tree, b = other._tree;<EOL>    var ita = iterateFromFirst(a), itb = iterateFromFirst(b);<EOL>     do {<EOL>        var ca = ita.next();<EOL>        var cb = itb.next();<EOL>        if (!equals(ca.value.value, cb.value.","gt":"value))"}
{"input":"<s> <EOL>function $import(name, o = {}) {<EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    if (name.","gt":"charCodeAt(<NUM_LIT>) === <NUM_LIT> || name.charCodeAt(<NUM_LIT>) === <NUM_LIT>) {"}
{"input":"<s> <EOL>function $import(name, o = {}) {<EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    if (name. charCodeAt(<NUM_LIT>) === <NUM_LIT> || name.charCodeAt(<NUM_LIT>) === <NUM_LIT>) {<EOL>        return $loadURL(name);<EOL>    }<EOL>    let ref = $getRef(name, o);<EOL>    if (ref.server) {<EOL>        return ref.","gt":"server;"}
{"input":"<s> <EOL>function $import(name, o = {}) {<EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    if (name. charCodeAt(<NUM_LIT>) === <NUM_LIT> || name.charCodeAt(<NUM_LIT>) === <NUM_LIT>) {<EOL>        return $loadURL(name);<EOL>    }<EOL>    let ref = $getRef(name, o);<EOL>    if (ref.server) {<EOL>        return ref. server;<EOL>    }<EOL>    let file = ref.file;<EOL>    <EOL>    if (ref.wildcard) {<EOL>        <EOL>        let safeRegEx = new RegExp(ref.wildcard<EOL>            .replace(/\\*/g, \"<STR_LIT>\")<EOL>            .replace(/[.?*+^$[\\]\\\\(){}|-]/g, \"<STR_LIT>\")<EOL>            .replace(","gt":"/@@/g, \"<STR_LIT>\")"}
{"input":"<s> <EOL>function $import(name, o = {}) {<EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    if (name. charCodeAt(<NUM_LIT>) === <NUM_LIT> || name.charCodeAt(<NUM_LIT>) === <NUM_LIT>) {<EOL>        return $loadURL(name);<EOL>    }<EOL>    let ref = $getRef(name, o);<EOL>    if (ref.server) {<EOL>        return ref. server;<EOL>    }<EOL>    let file = ref.file;<EOL>    <EOL>    if (ref.wildcard) {<EOL>        <EOL>        let safeRegEx = new RegExp(ref.wildcard<EOL>            .replace(/\\*/g, \"<STR_LIT>\")<EOL>            .replace(/[.?*+^$[\\]\\\\(){}|-]/g, \"<STR_LIT>\")<EOL>            .replace( /@@/g, \"<STR_LIT>\")<EOL>            .replace(/@/g, \"<STR_LIT>\"), \"<STR_LIT>\");<EOL>        let pkg = $packages[ref.pkgName];<EOL>        if (pkg) {<EOL>            let batch = {};<EOL>            for (let n in pkg.f) {<EOL>                if (safeRegEx.test(n)) {<EOL>                    batch[n] = $import(`<STR_LIT>`);<EOL>                }<EOL>            }<EOL>            return batch;<EOL>        }<EOL>    }<EOL>    if (!file) {<EOL>        let asyncMode = typeof o === \"<STR_LIT>\";<EOL>        let processStopped = $trigger(\"<STR_LIT>\", [name, o]);<EOL>        if (processStopped === false) {<EOL>            return;<EOL>        }<EOL>        return $async(name, (result) => asyncMode ? o(result) : null, o);<EOL>        <EOL>    }<EOL>    <EOL>    let pkg = ref.pkgName;<EOL>    if (file.locals && file.locals.module)<EOL>        return file.","gt":"locals.module.exports;"}
{"input":"<s> <EOL>function $import(name, o = {}) {<EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    if (name. charCodeAt(<NUM_LIT>) === <NUM_LIT> || name.charCodeAt(<NUM_LIT>) === <NUM_LIT>) {<EOL>        return $loadURL(name);<EOL>    }<EOL>    let ref = $getRef(name, o);<EOL>    if (ref.server) {<EOL>        return ref. server;<EOL>    }<EOL>    let file = ref.file;<EOL>    <EOL>    if (ref.wildcard) {<EOL>        <EOL>        let safeRegEx = new RegExp(ref.wildcard<EOL>            .replace(/\\*/g, \"<STR_LIT>\")<EOL>            .replace(/[.?*+^$[\\]\\\\(){}|-]/g, \"<STR_LIT>\")<EOL>            .replace( /@@/g, \"<STR_LIT>\")<EOL>            .replace(/@/g, \"<STR_LIT>\"), \"<STR_LIT>\");<EOL>        let pkg = $packages[ref.pkgName];<EOL>        if (pkg) {<EOL>            let batch = {};<EOL>            for (let n in pkg.f) {<EOL>                if (safeRegEx.test(n)) {<EOL>                    batch[n] = $import(`<STR_LIT>`);<EOL>                }<EOL>            }<EOL>            return batch;<EOL>        }<EOL>    }<EOL>    if (!file) {<EOL>        let asyncMode = typeof o === \"<STR_LIT>\";<EOL>        let processStopped = $trigger(\"<STR_LIT>\", [name, o]);<EOL>        if (processStopped === false) {<EOL>            return;<EOL>        }<EOL>        return $async(name, (result) => asyncMode ? o(result) : null, o);<EOL>        <EOL>    }<EOL>    <EOL>    let pkg = ref.pkgName;<EOL>    if (file.locals && file.locals.module)<EOL>        return file. locals.module.exports;<EOL>    let locals = file.locals = {};<EOL>    <EOL>    const path = $getDir(ref.validPath);<EOL>    locals.exports = {};<EOL>    locals.module = { exports: locals.exports };<EOL>    locals.require = (name, optionalCallback) => {<EOL>        const result = $import(name, {<EOL>","gt":"pkg,"}
{"input":"<s> <EOL>function $import(name, o = {}) {<EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    if (name. charCodeAt(<NUM_LIT>) === <NUM_LIT> || name.charCodeAt(<NUM_LIT>) === <NUM_LIT>) {<EOL>        return $loadURL(name);<EOL>    }<EOL>    let ref = $getRef(name, o);<EOL>    if (ref.server) {<EOL>        return ref. server;<EOL>    }<EOL>    let file = ref.file;<EOL>    <EOL>    if (ref.wildcard) {<EOL>        <EOL>        let safeRegEx = new RegExp(ref.wildcard<EOL>            .replace(/\\*/g, \"<STR_LIT>\")<EOL>            .replace(/[.?*+^$[\\]\\\\(){}|-]/g, \"<STR_LIT>\")<EOL>            .replace( /@@/g, \"<STR_LIT>\")<EOL>            .replace(/@/g, \"<STR_LIT>\"), \"<STR_LIT>\");<EOL>        let pkg = $packages[ref.pkgName];<EOL>        if (pkg) {<EOL>            let batch = {};<EOL>            for (let n in pkg.f) {<EOL>                if (safeRegEx.test(n)) {<EOL>                    batch[n] = $import(`<STR_LIT>`);<EOL>                }<EOL>            }<EOL>            return batch;<EOL>        }<EOL>    }<EOL>    if (!file) {<EOL>        let asyncMode = typeof o === \"<STR_LIT>\";<EOL>        let processStopped = $trigger(\"<STR_LIT>\", [name, o]);<EOL>        if (processStopped === false) {<EOL>            return;<EOL>        }<EOL>        return $async(name, (result) => asyncMode ? o(result) : null, o);<EOL>        <EOL>    }<EOL>    <EOL>    let pkg = ref.pkgName;<EOL>    if (file.locals && file.locals.module)<EOL>        return file. locals.module.exports;<EOL>    let locals = file.locals = {};<EOL>    <EOL>    const path = $getDir(ref.validPath);<EOL>    locals.exports = {};<EOL>    locals.module = { exports: locals.exports };<EOL>    locals.require = (name, optionalCallback) => {<EOL>        const result = $import(name, {<EOL>             pkg,<EOL>            path,<EOL>            v: ref.versions,<EOL>        });<EOL>        if (FuseBox[\"<STR_LIT>\"]) {<EOL>            syntheticDefaultExportPolyfill(result);<EOL>        }<EOL>","gt":"return result;"}
{"input":"<s> <EOL>function $import(name, o = {}) {<EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    if (name. charCodeAt(<NUM_LIT>) === <NUM_LIT> || name.charCodeAt(<NUM_LIT>) === <NUM_LIT>) {<EOL>        return $loadURL(name);<EOL>    }<EOL>    let ref = $getRef(name, o);<EOL>    if (ref.server) {<EOL>        return ref. server;<EOL>    }<EOL>    let file = ref.file;<EOL>    <EOL>    if (ref.wildcard) {<EOL>        <EOL>        let safeRegEx = new RegExp(ref.wildcard<EOL>            .replace(/\\*/g, \"<STR_LIT>\")<EOL>            .replace(/[.?*+^$[\\]\\\\(){}|-]/g, \"<STR_LIT>\")<EOL>            .replace( /@@/g, \"<STR_LIT>\")<EOL>            .replace(/@/g, \"<STR_LIT>\"), \"<STR_LIT>\");<EOL>        let pkg = $packages[ref.pkgName];<EOL>        if (pkg) {<EOL>            let batch = {};<EOL>            for (let n in pkg.f) {<EOL>                if (safeRegEx.test(n)) {<EOL>                    batch[n] = $import(`<STR_LIT>`);<EOL>                }<EOL>            }<EOL>            return batch;<EOL>        }<EOL>    }<EOL>    if (!file) {<EOL>        let asyncMode = typeof o === \"<STR_LIT>\";<EOL>        let processStopped = $trigger(\"<STR_LIT>\", [name, o]);<EOL>        if (processStopped === false) {<EOL>            return;<EOL>        }<EOL>        return $async(name, (result) => asyncMode ? o(result) : null, o);<EOL>        <EOL>    }<EOL>    <EOL>    let pkg = ref.pkgName;<EOL>    if (file.locals && file.locals.module)<EOL>        return file. locals.module.exports;<EOL>    let locals = file.locals = {};<EOL>    <EOL>    const path = $getDir(ref.validPath);<EOL>    locals.exports = {};<EOL>    locals.module = { exports: locals.exports };<EOL>    locals.require = (name, optionalCallback) => {<EOL>        const result = $import(name, {<EOL>             pkg,<EOL>            path,<EOL>            v: ref.versions,<EOL>        });<EOL>        if (FuseBox[\"<STR_LIT>\"]) {<EOL>            syntheticDefaultExportPolyfill(result);<EOL>        }<EOL>         return result;<EOL>    };<EOL>    if ($isBrowser || !g[\"<STR_LIT>\"].main) {<EOL>        locals.require.main = { filename:","gt":"\"<STR_LIT>\", paths: [] };"}
{"input":"<s> <EOL>function $import(name, o = {}) {<EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    if (name. charCodeAt(<NUM_LIT>) === <NUM_LIT> || name.charCodeAt(<NUM_LIT>) === <NUM_LIT>) {<EOL>        return $loadURL(name);<EOL>    }<EOL>    let ref = $getRef(name, o);<EOL>    if (ref.server) {<EOL>        return ref. server;<EOL>    }<EOL>    let file = ref.file;<EOL>    <EOL>    if (ref.wildcard) {<EOL>        <EOL>        let safeRegEx = new RegExp(ref.wildcard<EOL>            .replace(/\\*/g, \"<STR_LIT>\")<EOL>            .replace(/[.?*+^$[\\]\\\\(){}|-]/g, \"<STR_LIT>\")<EOL>            .replace( /@@/g, \"<STR_LIT>\")<EOL>            .replace(/@/g, \"<STR_LIT>\"), \"<STR_LIT>\");<EOL>        let pkg = $packages[ref.pkgName];<EOL>        if (pkg) {<EOL>            let batch = {};<EOL>            for (let n in pkg.f) {<EOL>                if (safeRegEx.test(n)) {<EOL>                    batch[n] = $import(`<STR_LIT>`);<EOL>                }<EOL>            }<EOL>            return batch;<EOL>        }<EOL>    }<EOL>    if (!file) {<EOL>        let asyncMode = typeof o === \"<STR_LIT>\";<EOL>        let processStopped = $trigger(\"<STR_LIT>\", [name, o]);<EOL>        if (processStopped === false) {<EOL>            return;<EOL>        }<EOL>        return $async(name, (result) => asyncMode ? o(result) : null, o);<EOL>        <EOL>    }<EOL>    <EOL>    let pkg = ref.pkgName;<EOL>    if (file.locals && file.locals.module)<EOL>        return file. locals.module.exports;<EOL>    let locals = file.locals = {};<EOL>    <EOL>    const path = $getDir(ref.validPath);<EOL>    locals.exports = {};<EOL>    locals.module = { exports: locals.exports };<EOL>    locals.require = (name, optionalCallback) => {<EOL>        const result = $import(name, {<EOL>             pkg,<EOL>            path,<EOL>            v: ref.versions,<EOL>        });<EOL>        if (FuseBox[\"<STR_LIT>\"]) {<EOL>            syntheticDefaultExportPolyfill(result);<EOL>        }<EOL>         return result;<EOL>    };<EOL>    if ($isBrowser || !g[\"<STR_LIT>\"].main) {<EOL>        locals.require.main = { filename:  \"<STR_LIT>\", paths: [] };<EOL>    }<EOL>","gt":"else {"}
{"input":"<s> export function matchesDefinedIfExpression(node, expressions) {<EOL>    if (node.type && node.type === \"<STR_LIT>\") {<EOL>        <EOL>        if (node.$parent && node.$parent.type === \"<STR_LIT>\") {<EOL>            return;<EOL>        }<EOL>        if (node.test && node.test.type === \"<STR_LIT>\") {<EOL>            if (node.test.left) {<EOL>                for (const key in expressions) {<EOL>","gt":"if (matchesPath(node.test.left, key)) {"}
{"input":"<s> export async function tsc(root, opts) {<EOL>    let tscOptions = [];<EOL>    root = ensureAbsolutePath(root);<EOL>    opts.project = root;<EOL>    for (const key in opts) {<EOL>","gt":"if (opts[key] !== undefined) {"}
{"input":"<s> export async function tsc(root, opts) {<EOL>    let tscOptions = [];<EOL>    root = ensureAbsolutePath(root);<EOL>    opts.project = root;<EOL>    for (const key in opts) {<EOL>         if (opts[key] !== undefined) {<EOL>            if (key === '<STR_LIT>') {<EOL>                tscOptions.push(`<STR_LIT>`);<EOL>            }<EOL>            else {<EOL>                tscOptions.push(`<STR_LIT>`, String(opts[key]));<EOL>            }<EOL>        }<EOL>    }<EOL>    return new Promise((resolve, reject) => {<EOL>        const proc = spawn(\"<STR_LIT>\" + (/^win/.test(process.platform) ? \"<STR_LIT>\" : \"<STR_LIT>\"), tscOptions, {<EOL>            stdio: \"<STR_LIT>\"<EOL>        });<EOL>        proc.on(\"<STR_LIT>\", function (code) {<EOL>","gt":"if (code === <NUM_LIT>) {"}
{"input":"<s> function setup({ plugins, styleContent = style }) {<EOL>    return createEnv({<EOL>        project: {<EOL>            files: {<EOL>","gt":"\"<STR_LIT>\": `<STR_LIT>`,"}
{"input":"<s> function setup({ plugins, styleContent = style }) {<EOL>    return createEnv({<EOL>        project: {<EOL>            files: {<EOL>                 \"<STR_LIT>\": `<STR_LIT>`,<EOL>                \"<STR_LIT>\": styleContent<EOL>            },<EOL>            plugins: plugins,<EOL>            instructions:","gt":"\"<STR_LIT>\","}
{"input":"<s> <EOL>export function loadContentComponent() {<EOL>","gt":"console.log(\"<STR_LIT>\");"}
{"input":"<s> export function deepAssign(target, ...args) {<EOL>    target = toObject(target);<EOL>    for (var","gt":"s = <NUM_LIT>; s < args.length; s++) {"}
{"input":"<s> export function renderModule(name, renderTest) {<EOL>    QUnit.module(name);<EOL>    for (let prop in renderTest.prototype) {<EOL>        const test = renderTest.prototype[prop];<EOL>        if (isTestFunction(test) && shouldRun(","gt":"test)) {"}
{"input":"<s> function setTestingDescriptor(descriptor) {<EOL>","gt":"let testFunction = descriptor.value;"}
{"input":"<s> <EOL>export function getImportStatements(modules) {<EOL>    let identifiers = new Array(modules.length).fill('<STR_LIT>');<EOL>    let imports = modules.map((locator, handle) => {<EOL>        <EOL>        <EOL>        <EOL>        <EOL>        if (!locator) {<EOL>            identifiers[handle] = `<STR_LIT>`;<EOL>","gt":"return '<STR_LIT>';"}
{"input":"<s> <EOL>export function getImportStatements(modules) {<EOL>    let identifiers = new Array(modules.length).fill('<STR_LIT>');<EOL>    let imports = modules.map((locator, handle) => {<EOL>        <EOL>        <EOL>        <EOL>        <EOL>        if (!locator) {<EOL>            identifiers[handle] = `<STR_LIT>`;<EOL>             return '<STR_LIT>';<EOL>        }<EOL>        let id = getIdentifier(locator, handle);<EOL>","gt":"identifiers[handle] = id;"}
{"input":"<s> export function precompile(string, options = defaultOptions) {<EOL>    let ast = preprocess(string, options);<EOL>    let { meta } = options;<EOL>    let { block } = TemplateCompiler.compile(options, ast);<EOL>    let idFn = options.","gt":"id || defaultId;"}
{"input":"<s> function isHelperInvocation(mustache) {<EOL>    return (mustache.params && mustache.params.length >","gt":"<NUM_LIT>) ||"}
{"input":"<s> export function test(...args) {<EOL>    if (args.length === <NUM_LIT>) {<EOL>        let meta = args[<NUM_LIT>];<EOL>        return (_target, _name, descriptor) => {<EOL>            let","gt":"testFunction = descriptor.value;"}
{"input":"<s> export function test(...args) {<EOL>    if (args.length === <NUM_LIT>) {<EOL>        let meta = args[<NUM_LIT>];<EOL>        return (_target, _name, descriptor) => {<EOL>            let  testFunction = descriptor.value;<EOL>            Object.keys(meta).forEach((key) => (testFunction[key] = meta[key]));<EOL>            setTestingDescriptor(descriptor);<EOL>        };<EOL>    }<EOL>    let","gt":"descriptor = args[<NUM_LIT>];"}
{"input":"<s> function decodeSmi(smi) {<EOL>    switch (smi & <NUM_LIT>) {<EOL>        case PrimitiveType.NUMBER:<EOL>            return","gt":"smi >> <NUM_LIT>;"}
{"input":"<s> function allDirty(refs, newValue) {<EOL>    refs.","gt":"forEach(function (ref) { isDirty(ref, newValue); });"}
{"input":"<s> function root(obj) {<EOL>","gt":"return metaFor(obj).root();"}
{"input":"<s> export function logOpcode(type, params) {<EOL>    let out = type;<EOL>    if (","gt":"params) {"}
{"input":"<s> export function clear(bounds) {<EOL>    let parent = bounds.parentElement();<EOL>    let first = bounds.firstNode();<EOL>    let last = bounds.lastNode();<EOL>","gt":"let node = first;"}
{"input":"<s> export function clear(bounds) {<EOL>    let parent = bounds.parentElement();<EOL>    let first = bounds.firstNode();<EOL>    let last = bounds.lastNode();<EOL>     let node = first;<EOL>    while (node) {<EOL>        let next = node.nextSibling;<EOL>        parent.removeChild(node);<EOL>        if (node === last)<EOL>            return next;<EOL>        node =","gt":"next;"}
{"input":"<s> <EOL>export function setDebuggerCallback(cb) {<EOL>    callback =","gt":"cb;"}
{"input":"<s> function isTextNode(node) {<EOL>    return node.nodeType ===","gt":"<NUM_LIT>;"}
{"input":"<s> export function rehydrationBuilder(env, cursor) {<EOL>    return","gt":"RehydrateBuilder.forInitialRender(env, cursor);"}
{"input":"<s> export function assertAppended(content) {<EOL>    equalTokens(","gt":"document.querySelector('<STR_LIT>'), content);"}
{"input":"<s> function compile(template) {<EOL>","gt":"return env.compile(template);"}
{"input":"<s> export function module(name, second, third) {<EOL>    let nested, setup;<EOL>    if (arguments.length === <NUM_LIT>) {<EOL>        setup = second;<EOL>        nested = third;<EOL>    }<EOL>    else if (arguments.length === <NUM_LIT>) {<EOL>        if (typeof second === '<STR_LIT>') {<EOL>            setup = second;<EOL>        }<EOL>        else {<EOL>","gt":"nested = second;"}
{"input":"<s> export function todo(name, callback) {<EOL>    return","gt":"QUnit.todo(name, callback);"}
{"input":"<s> function buildMustacheComment(value, loc) {<EOL>    return {<EOL>        type:","gt":"\"<STR_LIT>\","}
{"input":"<s> function buildPosition(line, column) {<EOL>    return {<EOL>","gt":"line,"}
{"input":"<s> export function appendChild(parent, node) {<EOL>    childrenFor(parent).","gt":"push(node);"}
{"input":"<s> export function isLiteral(path) {<EOL>    return path.type === '<STR_LIT>'<EOL>        || path.","gt":"type === '<STR_LIT>'"}
{"input":"<s> <EOL>function isProblematicAttribute(attr) {<EOL>    var isLabel = p.hasTagName(\"<STR_LIT>\");<EOL>    switch (attr.name.toLowerCase()) {<EOL>        case \"<STR_LIT>\":<EOL>            return isLabel(attr.","gt":"node);"}
{"input":"<s> <EOL>function isProblematicAttribute(attr) {<EOL>    var isLabel = p.hasTagName(\"<STR_LIT>\");<EOL>    switch (attr.name.toLowerCase()) {<EOL>        case \"<STR_LIT>\":<EOL>            return isLabel(attr. node);<EOL>    }<EOL>    if (isNativeAttribute(attr.name.toLowerCase())) {<EOL>        return true;<EOL>    }<EOL>    if (attr.name.indexOf(\"<STR_LIT>\") === <NUM_LIT> &&<EOL>        attr.name[attr.","gt":"name.length - <NUM_LIT>] != \"<STR_LIT>\") {"}
{"input":"<s> function makeWin32TmpDir() {<EOL>    const winTmpPath = process.env.TEMP || process.env.TMP ||<EOL>        (process.env.SystemRoot ||","gt":"process.env.windir) + '<STR_LIT>';"}
{"input":"<s> function patchHttp2Session(session, authority, api) {<EOL>","gt":"api.wrapEmitter(session);"}
{"input":"<s> async function runTest(testConfig) {<EOL>    const appView = new MockView([]);<EOL>    const files = await generateFiles(appView, testConfig.config, BASE_IMAGE);<EOL>    assert.ok(files);<EOL>    <EOL>    <EOL>    assert.strictEqual(files.size, <NUM_LIT>);<EOL>    assert.strictEqual(appView.pathsWritten.length, <NUM_LIT>);<EOL>    assert.strictEqual(files.has(","gt":"DOCKERFILE_NAME), true);"}
{"input":"<s> async function runTest(testConfig) {<EOL>    const appView = new MockView([]);<EOL>    const files = await generateFiles(appView, testConfig.config, BASE_IMAGE);<EOL>    assert.ok(files);<EOL>    <EOL>    <EOL>    assert.strictEqual(files.size, <NUM_LIT>);<EOL>    assert.strictEqual(appView.pathsWritten.length, <NUM_LIT>);<EOL>    assert.strictEqual(files.has( DOCKERFILE_NAME), true);<EOL>    assert.strictEqual(files.has(DOCKERIGNORE_NAME), true);<EOL>    if (testConfig.expectedDockerfile) {<EOL>        testConfig.expectedDockerfile(files.get(","gt":"DOCKERFILE_NAME));"}
{"input":"<s> async function runTest(testConfig) {<EOL>    const appView = new MockView([]);<EOL>    const files = await generateFiles(appView, testConfig.config, BASE_IMAGE);<EOL>    assert.ok(files);<EOL>    <EOL>    <EOL>    assert.strictEqual(files.size, <NUM_LIT>);<EOL>    assert.strictEqual(appView.pathsWritten.length, <NUM_LIT>);<EOL>    assert.strictEqual(files.has( DOCKERFILE_NAME), true);<EOL>    assert.strictEqual(files.has(DOCKERIGNORE_NAME), true);<EOL>    if (testConfig.expectedDockerfile) {<EOL>        testConfig.expectedDockerfile(files.get( DOCKERFILE_NAME));<EOL>        assert(hasLocation(appView.pathsWritten, {<EOL>            path: '<STR_LIT>',<EOL>            exists:","gt":"true,"}
{"input":"<s> async function runTest(testConfig) {<EOL>    const appView = new MockView([]);<EOL>    const files = await generateFiles(appView, testConfig.config, BASE_IMAGE);<EOL>    assert.ok(files);<EOL>    <EOL>    <EOL>    assert.strictEqual(files.size, <NUM_LIT>);<EOL>    assert.strictEqual(appView.pathsWritten.length, <NUM_LIT>);<EOL>    assert.strictEqual(files.has( DOCKERFILE_NAME), true);<EOL>    assert.strictEqual(files.has(DOCKERIGNORE_NAME), true);<EOL>    if (testConfig.expectedDockerfile) {<EOL>        testConfig.expectedDockerfile(files.get( DOCKERFILE_NAME));<EOL>        assert(hasLocation(appView.pathsWritten, {<EOL>            path: '<STR_LIT>',<EOL>            exists:  true,<EOL>            contents: testConfig.expectedDockerfile<EOL>        }));<EOL>    }<EOL>    if (testConfig.expectedDockerignore) {<EOL>        testConfig.expectedDockerignore(files.","gt":"get(DOCKERIGNORE_NAME));"}
{"input":"<s> function buildGenDockerfile(cb) {<EOL>    const options = {","gt":"cwd: GEN_DOCKERFILE_DIR };"}
{"input":"<s> async function testMediaBody(drive) {<EOL>    const resource = { title: '<STR_LIT>' };<EOL>","gt":"const media = { body: '<STR_LIT>' };"}
{"input":"<s> async function testMediaBody(drive) {<EOL>    const resource = { title: '<STR_LIT>' };<EOL>     const media = { body: '<STR_LIT>' };<EOL>","gt":"let expectedResp = fs.readFileSync(path.join(__dirname, '<STR_LIT>'), { encoding: '<STR_LIT>' });"}
{"input":"<s> async function testMediaBody(drive) {<EOL>    const resource = { title: '<STR_LIT>' };<EOL>     const media = { body: '<STR_LIT>' };<EOL>     let expectedResp = fs.readFileSync(path.join(__dirname, '<STR_LIT>'), { encoding: '<STR_LIT>' });<EOL>    const res = await pify(drive.files.insert)({ resource, media });<EOL>    assert.equal(res.config.method.toLowerCase(), '<STR_LIT>');<EOL>    assert.equal(res.config.maxContentLength, Math.pow(<NUM_LIT>, <NUM_LIT>));<EOL>    assert.equal(res.request.","gt":"path, '<STR_LIT>');"}
{"input":"<s> async function testMediaBody(drive) {<EOL>    const resource = { title: '<STR_LIT>' };<EOL>     const media = { body: '<STR_LIT>' };<EOL>     let expectedResp = fs.readFileSync(path.join(__dirname, '<STR_LIT>'), { encoding: '<STR_LIT>' });<EOL>    const res = await pify(drive.files.insert)({ resource, media });<EOL>    assert.equal(res.config.method.toLowerCase(), '<STR_LIT>');<EOL>    assert.equal(res.config.maxContentLength, Math.pow(<NUM_LIT>, <NUM_LIT>));<EOL>    assert.equal(res.request. path, '<STR_LIT>');<EOL>    assert.equal(res.request.headers['<STR_LIT>'].indexOf('<STR_LIT>'), <NUM_LIT>);<EOL>    const boundary = res.request.headers['<STR_LIT>'].replace(boundaryPrefix, '<STR_LIT>');<EOL>    expectedResp = expectedResp.replace(/\\n/g, '<STR_LIT>')<EOL>        .replace(/\\$boundary/g, boundary)<EOL>        .replace('<STR_LIT>',","gt":"media.body)"}
{"input":"<s> function createNock(path) {<EOL>    const p =","gt":"path ? path : '<STR_LIT>';"}
{"input":"<s> function testResponseError(drive, cb) {<EOL>    drive.files.list({ q: '<STR_LIT>' }, (err) => {<EOL>        assert(err instanceof","gt":"Error);"}
{"input":"<s> async function isComputeEngine() {<EOL>    return","gt":"gcpMetadata.isAvailable();"}
{"input":"<s> <EOL>function insertWellKnownFilePathIntoAuth(auth, filePath, mockFilePath) {<EOL>    const originalMockWellKnownFilePathFunction = auth._mockWellKnownFilePath;<EOL>    auth._mockWellKnownFilePath = (kfpath) => {<EOL>","gt":"if (kfpath === filePath) {"}
{"input":"<s> <EOL>function mockEnvVar(name, value = '<STR_LIT>') {<EOL>    if (!sandbox) {<EOL>        sandbox = sinon.","gt":"createSandbox();"}
{"input":"<s> function nock404GCE() {<EOL>    return nock(host).get(instancePath).","gt":"reply(<NUM_LIT>);"}
{"input":"<s> <EOL>function pathJoin(item1, item2) {<EOL>    return item1 + '<STR_LIT>' +","gt":"item2;"}
{"input":"<s> export function validateLayoutName(obj) {<EOL>","gt":"getLayoutByName(obj);"}
{"input":"<s> export function decodeManifestChunk(chunk, response) {<EOL>    return decodeJsonManifestChunk(chunk, response,","gt":"'<STR_LIT>');"}
{"input":"<s> export function decodeFragmentChunk(chunk, response) {<EOL>    let dv = new","gt":"DataView(response);"}
{"input":"<s> function getPointMatches(chunk, sectionIds, parameters, cancellationToken) {<EOL>    let path;<EOL>    if (sectionIds.length === <NUM_LIT>) {<EOL>        path = `<STR_LIT>` +<EOL>            `<STR_LIT>`;<EOL>    }<EOL>    else if (sectionIds.length === <NUM_LIT>) {<EOL>        path = `<STR_LIT>` +<EOL>            `<STR_LIT>`;<EOL>    }<EOL>    else {<EOL>        throw new Error(`<STR_LIT>`);<EOL>    }<EOL>","gt":"return sendHttpRequest(openShardedHttpRequest(parameters.baseUrls, path), '<STR_LIT>', cancellationToken)"}
{"input":"<s> export function makeRenderedPanelVisibleLayerTracker(layerManager, renderLayerType, panel) {<EOL>    return panel.registerDisposer(new VisibleRenderLayerTracker(layerManager, renderLayerType, (layer) => {<EOL>        const disposer = layer.redrawNeeded.add(() => panel.scheduleRedraw());<EOL>","gt":"panel.scheduleRedraw();"}
{"input":"<s> <EOL>function parseSwc(swcStr) {<EOL>    <EOL>    let swcInputAr = swcStr.split('<STR_LIT>');<EOL>    let swcObjectsAr = new Array();<EOL>    let float = '<STR_LIT>';<EOL>    let pattern = new RegExp('<STR_LIT>' + [<EOL>","gt":"'<STR_LIT>',"}
{"input":"<s> <EOL>function parseSwc(swcStr) {<EOL>    <EOL>    let swcInputAr = swcStr.split('<STR_LIT>');<EOL>    let swcObjectsAr = new Array();<EOL>    let float = '<STR_LIT>';<EOL>    let pattern = new RegExp('<STR_LIT>' + [<EOL>         '<STR_LIT>',<EOL>        '<STR_LIT>',<EOL>        float,<EOL>","gt":"float,"}
{"input":"<s> <EOL>function parseSwc(swcStr) {<EOL>    <EOL>    let swcInputAr = swcStr.split('<STR_LIT>');<EOL>    let swcObjectsAr = new Array();<EOL>    let float = '<STR_LIT>';<EOL>    let pattern = new RegExp('<STR_LIT>' + [<EOL>         '<STR_LIT>',<EOL>        '<STR_LIT>',<EOL>        float,<EOL>         float,<EOL>        float,<EOL>        float,<EOL>","gt":"'<STR_LIT>'"}
{"input":"<s> <EOL>function parseSwc(swcStr) {<EOL>    <EOL>    let swcInputAr = swcStr.split('<STR_LIT>');<EOL>    let swcObjectsAr = new Array();<EOL>    let float = '<STR_LIT>';<EOL>    let pattern = new RegExp('<STR_LIT>' + [<EOL>         '<STR_LIT>',<EOL>        '<STR_LIT>',<EOL>        float,<EOL>         float,<EOL>        float,<EOL>        float,<EOL>         '<STR_LIT>' <EOL>    ].join('<STR_LIT>') + '<STR_LIT>');<EOL>    swcInputAr.forEach(function (e) {<EOL>        <EOL>        <EOL>        let match = e.match(pattern);<EOL>        if (match) {<EOL>            let point = swcObjectsAr[parseInt(match[<NUM_LIT>], <NUM_LIT>) - <NUM_LIT>] = new PointObj();<EOL>            point.type = parseInt(match[<NUM_LIT>], <NUM_LIT>);<EOL>            point.x = parseFloat(match[<NUM_LIT>]);<EOL>","gt":"point.y = parseFloat(match[<NUM_LIT>]);"}
{"input":"<s> export function updateLayerDropEffect(event, manager, newTarget = false) {<EOL>    return setDropEffect(event, getLayerDropEffect(event, manager,","gt":"newTarget));"}
{"input":"<s> <EOL>export function maybePadArray(array, newSize) {<EOL>    if (array.length === newSize) {<EOL>","gt":"return array;"}
{"input":"<s> export function verifyFloat01(obj) {<EOL>    if (typeof obj !== '<STR_LIT>' || !Number.isFinite(obj) || obj < <NUM_LIT> || obj > <NUM_LIT>) {<EOL>        throw new Error(","gt":"stringify(obj)}.`<STR_LIT>;"}
{"input":"<s> export function verifyObjectProperty(obj, propertyName, validator) {<EOL>    let value = obj.hasOwnProperty(propertyName) ? obj[propertyName] : undefined;<EOL>    try {<EOL>","gt":"return validator(value);"}
{"input":"<s> export function setVec4FromUint32(out, x) {<EOL>    for (let j = <NUM_LIT>; j < <NUM_LIT>; ++j) {<EOL>        out[j] = ((x >> (j *","gt":"<NUM_LIT>)) & <NUM_LIT>) / <NUM_LIT>;"}
{"input":"<s> export function manageDashboardsDirective() {<EOL>    return {<EOL>        restrict: '<STR_LIT>',<EOL>        templateUrl: '<STR_LIT>',<EOL>        controller:","gt":"ManageDashboardsCtrl,"}
{"input":"<s> export function manageDashboardsDirective() {<EOL>    return {<EOL>        restrict: '<STR_LIT>',<EOL>        templateUrl: '<STR_LIT>',<EOL>        controller:  ManageDashboardsCtrl,<EOL>        bindToController: true,<EOL>        controllerAs: '<STR_LIT>',<EOL>        scope: {<EOL>            folderId: '<STR_LIT>',<EOL>            folderUid:","gt":"'<STR_LIT>',"}
{"input":"<s> <EOL>function applied(fn, scope) {<EOL>    if (fn.wrappedInApply) {<EOL>        return fn;<EOL>    }<EOL>    var wrapped = function () {<EOL>        var args = arguments;<EOL>        var phase =","gt":"scope.$root.$$phase;"}
{"input":"<s> <EOL>function applied(fn, scope) {<EOL>    if (fn.wrappedInApply) {<EOL>        return fn;<EOL>    }<EOL>    var wrapped = function () {<EOL>        var args = arguments;<EOL>        var phase =  scope.$root.$$phase;<EOL>        if (phase === '<STR_LIT>' || phase === '<STR_LIT>') {<EOL>            return fn.apply(null, args);<EOL>        }<EOL>","gt":"else {"}
{"input":"<s> <EOL>function watchProps(watchDepth, scope, watchExpressions, listener) {<EOL>    var supportsWatchCollection = angular.isFunction(scope.$watchCollection);<EOL>    var supportsWatchGroup = angular.isFunction(scope.$watchGroup);<EOL>    var watchGroupExpressions = [];<EOL>    watchExpressions.forEach(function (expr) {<EOL>        var","gt":"actualExpr = getPropExpression(expr);"}
{"input":"<s> <EOL>function watchProps(watchDepth, scope, watchExpressions, listener) {<EOL>    var supportsWatchCollection = angular.isFunction(scope.$watchCollection);<EOL>    var supportsWatchGroup = angular.isFunction(scope.$watchGroup);<EOL>    var watchGroupExpressions = [];<EOL>    watchExpressions.forEach(function (expr) {<EOL>        var  actualExpr = getPropExpression(expr);<EOL>        var exprWatchDepth = getPropWatchDepth(watchDepth, expr);<EOL>        if (exprWatchDepth === '<STR_LIT>' && supportsWatchCollection) {<EOL>            scope.$watchCollection(actualExpr,","gt":"listener);"}
{"input":"<s> <EOL>function watchProps(watchDepth, scope, watchExpressions, listener) {<EOL>    var supportsWatchCollection = angular.isFunction(scope.$watchCollection);<EOL>    var supportsWatchGroup = angular.isFunction(scope.$watchGroup);<EOL>    var watchGroupExpressions = [];<EOL>    watchExpressions.forEach(function (expr) {<EOL>        var  actualExpr = getPropExpression(expr);<EOL>        var exprWatchDepth = getPropWatchDepth(watchDepth, expr);<EOL>        if (exprWatchDepth === '<STR_LIT>' && supportsWatchCollection) {<EOL>            scope.$watchCollection(actualExpr,  listener);<EOL>        }<EOL>        else if (exprWatchDepth === '<STR_LIT>' && supportsWatchGroup) {<EOL>            watchGroupExpressions.push(","gt":"actualExpr);"}
{"input":"<s> function describeValueFormat(desc, value, tickSize, tickDecimals, result) {<EOL>    describe('<STR_LIT>' + desc, function () {<EOL>        it('<STR_LIT>' + value + '<STR_LIT>' + result, function () {<EOL>            var scaledDecimals = tickDecimals - Math.floor(Math.","gt":"log(tickSize) / Math.LN10);"}
{"input":"<s> export function getScaledDecimals(decimals, tick_size) {<EOL>    return decimals - Math.","gt":"floor(Math.log(tick_size) / Math.LN10);"}
{"input":"<s> export function rowOptionsDirective() {<EOL>    return {<EOL>        restrict: '<STR_LIT>',<EOL>        templateUrl: '<STR_LIT>',<EOL>","gt":"controller: RowOptionsCtrl,"}
{"input":"<s> export function rowOptionsDirective() {<EOL>    return {<EOL>        restrict: '<STR_LIT>',<EOL>        templateUrl: '<STR_LIT>',<EOL>         controller: RowOptionsCtrl,<EOL>        bindToController: true,<EOL>        controllerAs: '<STR_LIT>',<EOL>        scope: {<EOL>            row: '<STR_LIT>',<EOL>            dismiss: '<STR_LIT>',<EOL>            onUpdated:","gt":"'<STR_LIT>',"}
{"input":"<s> function panelLinksEditor() {<EOL>    return {<EOL>        scope: {<EOL>            panel:","gt":"'<STR_LIT>',"}
{"input":"<s> function getNoneOption() {<EOL>    return { text: '<STR_LIT>', value: '<STR_LIT>',","gt":"isNone: true };"}
{"input":"<s> function supportsTags(version) {<EOL>    return","gt":"isVersionGtOrEq(version, '<STR_LIT>');"}
{"input":"<s> function addTransformationStrategy(selectParts, partModel) {<EOL>    var i;<EOL>    <EOL>    for (i =","gt":"<NUM_LIT>; i < selectParts.length; i++) {"}
{"input":"<s> function convertToLogScaleValueBuckets(xBucket, yBucketSplitFactor, logBase) {<EOL>    let values = xBucket.values;<EOL>    let points = xBucket.points;<EOL>    let buckets = {};<EOL>    _.forEach(values, (","gt":"val, index) => {"}
{"input":"<s> function convertToLogScaleValueBuckets(xBucket, yBucketSplitFactor, logBase) {<EOL>    let values = xBucket.values;<EOL>    let points = xBucket.points;<EOL>    let buckets = {};<EOL>    _.forEach(values, ( val, index) => {<EOL>        let bounds = getLogScaleBucketBounds(val, yBucketSplitFactor, logBase);<EOL>        let bucketNum = bounds.bottom;<EOL>        pushToYBuckets(buckets,","gt":"bucketNum, val, points[index], bounds);"}
{"input":"<s> function formatTime(timeStr) {<EOL>    let format =","gt":"'<STR_LIT>';"}
{"input":"<s> export function indexImpl(i) {<EOL>    if (i < <NUM_LIT>)<EOL>        throw new TypeError(`<STR_LIT>`);<EOL>    return Prism.create((xs) => xs[i], (v, xs) => {<EOL>        if (xs.","gt":"length <= i) {"}
{"input":"<s> export function indexImpl(i) {<EOL>    if (i < <NUM_LIT>)<EOL>        throw new TypeError(`<STR_LIT>`);<EOL>    return Prism.create((xs) => xs[i], (v, xs) => {<EOL>        if (xs. length <= i) {<EOL>            return xs.concat(Array(i - xs.length), [v]);<EOL>        }<EOL>        else if (structEq(v, xs[i])) {<EOL>            return xs;<EOL>        }<EOL>","gt":"else {"}
{"input":"<s> <EOL>function combineTemplate(template) {<EOL>    const keys = [];<EOL>    const values = [];<EOL>    for (const k in template) {<EOL>        keys.push(k);<EOL>        values.push(template[k]);<EOL>    }<EOL>    return Observable.combineLatest(values, (...vs) => {<EOL>","gt":"const r = {};"}
{"input":"<s> <EOL>function combineTemplate(template) {<EOL>    const keys = [];<EOL>    const values = [];<EOL>    for (const k in template) {<EOL>        keys.push(k);<EOL>        values.push(template[k]);<EOL>    }<EOL>    return Observable.combineLatest(values, (...vs) => {<EOL>         const r = {};<EOL>        for (let","gt":"i = <NUM_LIT>; i < keys.length; i++) {"}
{"input":"<s> export async function getAllCookies(client) {<EOL>    const {","gt":"Network } = client;"}
{"input":"<s> export async function nodeExists(client, selector) {<EOL>    const { Runtime } = client;<EOL>    const exists = `<STR_LIT>`;<EOL>","gt":"const expression = `<STR_LIT>`;"}
{"input":"<s> <EOL>export function getSourceFiles(rootFileNames, options) {<EOL>    const program = ts.createProgram(rootFileNames, options);<EOL>    const programmFiles = program.getSourceFiles()<EOL>        .map((file) =>","gt":"file.fileName)"}
{"input":"<s> export function getZipInfo(boilerplate) {<EOL>    let baseUrl = boilerplate;<EOL>    let branch = '<STR_LIT>';<EOL>    let subDir = '<STR_LIT>';<EOL>    const branchMatches = boilerplate.match(/^(.*)\\/tree\\/([a-zA-Z-_0-9]*)\\/?(.*)$/);<EOL>","gt":"if (branchMatches) {"}
{"input":"<s> export function getZipInfo(boilerplate) {<EOL>    let baseUrl = boilerplate;<EOL>    let branch = '<STR_LIT>';<EOL>    let subDir = '<STR_LIT>';<EOL>    const branchMatches = boilerplate.match(/^(.*)\\/tree\\/([a-zA-Z-_0-9]*)\\/?(.*)$/);<EOL>     if (branchMatches) {<EOL>        baseUrl = branchMatches[<NUM_LIT>];<EOL>        branch = branchMatches[<NUM_LIT>];<EOL>","gt":"subDir = branchMatches[<NUM_LIT>];"}
{"input":"<s> export function getZipInfo(boilerplate) {<EOL>    let baseUrl = boilerplate;<EOL>    let branch = '<STR_LIT>';<EOL>    let subDir = '<STR_LIT>';<EOL>    const branchMatches = boilerplate.match(/^(.*)\\/tree\\/([a-zA-Z-_0-9]*)\\/?(.*)$/);<EOL>     if (branchMatches) {<EOL>        baseUrl = branchMatches[<NUM_LIT>];<EOL>        branch = branchMatches[<NUM_LIT>];<EOL>         subDir = branchMatches[<NUM_LIT>];<EOL>    }<EOL>    if (subDir === undefined) {<EOL>        subDir = '<STR_LIT>';<EOL>    }<EOL>    if (!subDir.startsWith(","gt":"'<STR_LIT>')) {"}
{"input":"<s> <EOL>export function main() {<EOL>    return platformBrowserDynamic()<EOL>        .","gt":"bootstrapModule(AppModule)"}
{"input":"<s> export function applyDefaultsToBaseOptions(options) {<EOL>    if (!options.hasOwnProperty(\"<STR_LIT>\")) {<EOL>","gt":"options.autoOrient = true;"}
{"input":"<s> <EOL><EOL><EOL>export default function HaikuDOMAdapter(bytecode, config, safeWindow) {<EOL>    if (!config) {<EOL>        <EOL>        config = {};<EOL>    }<EOL>    if (!config.options) {<EOL>        config.options = {};<EOL>    }<EOL>    if (!safeWindow) {<EOL>        if (typeof window !== '<STR_LIT>') {<EOL>            <EOL>            safeWindow = window;<EOL>        }<EOL>    }<EOL>    if (config.options.useWebkitPrefix === undefined) {<EOL>        <EOL>        if (safeWindow && safeWindow.","gt":"document) {"}
{"input":"<s> function bindEventHandler(component, eventHandlerDescriptor, selector, eventName) {<EOL>    <EOL>    <EOL>    if (eventHandlerDescriptor.original) {<EOL>        eventHandlerDescriptor.handler = eventHandlerDescriptor.original;<EOL>    }<EOL>    eventHandlerDescriptor.original = eventHandlerDescriptor.handler;<EOL>    eventHandlerDescriptor.handler = function _wrappedEventHandler(event, ...args) {<EOL>        <EOL>        <EOL>        if (isPreviewMode(component.config.options.interactionMode)) {<EOL>            component.","gt":"_anyEventChange = true;"}
{"input":"<s> <EOL>export default function clone(thing) {<EOL>    if (Array.isArray(thing)) {<EOL>        const arr = [];<EOL>        for (let i = <NUM_LIT>; i < thing.length; i++) {<EOL>            arr[i] = clone(thing[i]);<EOL>        }<EOL>        return arr;<EOL>    }<EOL>    if (thing && typeof thing === '<STR_LIT>') {<EOL>","gt":"const obj = {};"}
{"input":"<s> function pointsToPath(pointsArray) {<EOL>    return","gt":"svgPoints.toPath(pointsArray);"}
{"input":"<s> <EOL>export default function computeOrientationFlexibly(xIn, yIn, zIn, w, quat) {<EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    if (!quat ||<EOL>        (","gt":"quat.x == null || quat.y == null || quat.z == null || quat.w == null)) {"}
{"input":"<s> <EOL>export default function computeOrientationFlexibly(xIn, yIn, zIn, w, quat) {<EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    if (!quat ||<EOL>        ( quat.x == null || quat.y == null || quat.z == null || quat.w == null)) {<EOL>        throw new Error(","gt":"'<STR_LIT>');"}
{"input":"<s> <EOL>export default function computeOrientationFlexibly(xIn, yIn, zIn, w, quat) {<EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    if (!quat ||<EOL>        ( quat.x == null || quat.y == null || quat.z == null || quat.w == null)) {<EOL>        throw new Error( '<STR_LIT>');<EOL>    }<EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    let x = xIn;<EOL>    let y = yIn;<EOL>    let z = zIn;<EOL>    if (x == null || y == null || z == null) {<EOL>        const sp = -<NUM_LIT> * (quat.y * quat.z - quat.w * quat.x);<EOL>        if (","gt":"Math.abs(sp) > <NUM_LIT>) {"}
{"input":"<s> <EOL>export default function computeOrientationFlexibly(xIn, yIn, zIn, w, quat) {<EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    if (!quat ||<EOL>        ( quat.x == null || quat.y == null || quat.z == null || quat.w == null)) {<EOL>        throw new Error( '<STR_LIT>');<EOL>    }<EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    let x = xIn;<EOL>    let y = yIn;<EOL>    let z = zIn;<EOL>    if (x == null || y == null || z == null) {<EOL>        const sp = -<NUM_LIT> * (quat.y * quat.z - quat.w * quat.x);<EOL>        if ( Math.abs(sp) > <NUM_LIT>) {<EOL>            y = y == null ? Math.PI * <NUM_LIT> * sp : y;<EOL>            x = x == null<EOL>                ? Math.atan2(-quat.x * quat.z + quat.w * quat.y, <NUM_LIT> - quat.y * quat.y - quat.z * quat.z)<EOL>                : x;<EOL>            z = z == null ? <NUM_LIT> : z;<EOL>        }<EOL>        else {<EOL>            y = y == null ? Math.asin(","gt":"sp) : y;"}
{"input":"<s> <EOL>export default function computeOrientationFlexibly(xIn, yIn, zIn, w, quat) {<EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    if (!quat ||<EOL>        ( quat.x == null || quat.y == null || quat.z == null || quat.w == null)) {<EOL>        throw new Error( '<STR_LIT>');<EOL>    }<EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    let x = xIn;<EOL>    let y = yIn;<EOL>    let z = zIn;<EOL>    if (x == null || y == null || z == null) {<EOL>        const sp = -<NUM_LIT> * (quat.y * quat.z - quat.w * quat.x);<EOL>        if ( Math.abs(sp) > <NUM_LIT>) {<EOL>            y = y == null ? Math.PI * <NUM_LIT> * sp : y;<EOL>            x = x == null<EOL>                ? Math.atan2(-quat.x * quat.z + quat.w * quat.y, <NUM_LIT> - quat.y * quat.y - quat.z * quat.z)<EOL>                : x;<EOL>            z = z == null ? <NUM_LIT> : z;<EOL>        }<EOL>        else {<EOL>            y = y == null ? Math.asin( sp) : y;<EOL>            x = x == null<EOL>                ? Math.atan2(quat.x * quat.z + quat.w * quat.y, <NUM_LIT> - quat.x * quat.x - quat.y * quat.y)<EOL>                : x;<EOL>            z = z == null<EOL>                ? Math.atan2(quat.x * quat.y + quat.w * quat.z, <NUM_LIT> - quat.x * quat.x - quat.z * quat.z)<EOL>                : z;<EOL>        }<EOL>    }<EOL>    const hx = x * <NUM_LIT>;<EOL>    const hy = y * <NUM_LIT>;<EOL>    const hz = z * <NUM_LIT>;<EOL>    const","gt":"sx = Math.sin(hx);"}
{"input":"<s> <EOL>export default function computeOrientationFlexibly(xIn, yIn, zIn, w, quat) {<EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    if (!quat ||<EOL>        ( quat.x == null || quat.y == null || quat.z == null || quat.w == null)) {<EOL>        throw new Error( '<STR_LIT>');<EOL>    }<EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    let x = xIn;<EOL>    let y = yIn;<EOL>    let z = zIn;<EOL>    if (x == null || y == null || z == null) {<EOL>        const sp = -<NUM_LIT> * (quat.y * quat.z - quat.w * quat.x);<EOL>        if ( Math.abs(sp) > <NUM_LIT>) {<EOL>            y = y == null ? Math.PI * <NUM_LIT> * sp : y;<EOL>            x = x == null<EOL>                ? Math.atan2(-quat.x * quat.z + quat.w * quat.y, <NUM_LIT> - quat.y * quat.y - quat.z * quat.z)<EOL>                : x;<EOL>            z = z == null ? <NUM_LIT> : z;<EOL>        }<EOL>        else {<EOL>            y = y == null ? Math.asin( sp) : y;<EOL>            x = x == null<EOL>                ? Math.atan2(quat.x * quat.z + quat.w * quat.y, <NUM_LIT> - quat.x * quat.x - quat.y * quat.y)<EOL>                : x;<EOL>            z = z == null<EOL>                ? Math.atan2(quat.x * quat.y + quat.w * quat.z, <NUM_LIT> - quat.x * quat.x - quat.z * quat.z)<EOL>                : z;<EOL>        }<EOL>    }<EOL>    const hx = x * <NUM_LIT>;<EOL>    const hy = y * <NUM_LIT>;<EOL>    const hz = z * <NUM_LIT>;<EOL>    const  sx = Math.sin(hx);<EOL>    const sy = Math.sin(hy);<EOL>    const sz = Math.sin(hz);<EOL>    const cx = Math.cos(hx);<EOL>    const cy = Math.cos(","gt":"hy);"}
{"input":"<s> <EOL>export default function computeOrientationFlexibly(xIn, yIn, zIn, w, quat) {<EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    if (!quat ||<EOL>        ( quat.x == null || quat.y == null || quat.z == null || quat.w == null)) {<EOL>        throw new Error( '<STR_LIT>');<EOL>    }<EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    let x = xIn;<EOL>    let y = yIn;<EOL>    let z = zIn;<EOL>    if (x == null || y == null || z == null) {<EOL>        const sp = -<NUM_LIT> * (quat.y * quat.z - quat.w * quat.x);<EOL>        if ( Math.abs(sp) > <NUM_LIT>) {<EOL>            y = y == null ? Math.PI * <NUM_LIT> * sp : y;<EOL>            x = x == null<EOL>                ? Math.atan2(-quat.x * quat.z + quat.w * quat.y, <NUM_LIT> - quat.y * quat.y - quat.z * quat.z)<EOL>                : x;<EOL>            z = z == null ? <NUM_LIT> : z;<EOL>        }<EOL>        else {<EOL>            y = y == null ? Math.asin( sp) : y;<EOL>            x = x == null<EOL>                ? Math.atan2(quat.x * quat.z + quat.w * quat.y, <NUM_LIT> - quat.x * quat.x - quat.y * quat.y)<EOL>                : x;<EOL>            z = z == null<EOL>                ? Math.atan2(quat.x * quat.y + quat.w * quat.z, <NUM_LIT> - quat.x * quat.x - quat.z * quat.z)<EOL>                : z;<EOL>        }<EOL>    }<EOL>    const hx = x * <NUM_LIT>;<EOL>    const hy = y * <NUM_LIT>;<EOL>    const hz = z * <NUM_LIT>;<EOL>    const  sx = Math.sin(hx);<EOL>    const sy = Math.sin(hy);<EOL>    const sz = Math.sin(hz);<EOL>    const cx = Math.cos(hx);<EOL>    const cy = Math.cos( hy);<EOL>    const cz = Math.cos(hz);<EOL>    const sysz = sy * sz;<EOL>","gt":"const cysz = cy * sz;"}
{"input":"<s> export default function setStyleMatrix(styleObject, format, matrix, usePrefix, devicePixelRatio) {<EOL>    const matrixString = formatTransform(matrix, format, devicePixelRatio);<EOL>    if (usePrefix) {<EOL>        if (!isEqualTransformString(styleObject.webkitTransform, matrixString)) {<EOL>            styleObject.webkitTransform =","gt":"matrixString;"}
{"input":"<s> function warnOnce(warning) {<EOL>    if (warnings[warning]) {<EOL>        return","gt":"void <NUM_LIT>;"}
{"input":"<s> <EOL>export default function assignClass(domElement, className) {<EOL>    if (domElement.className !== className) {<EOL>        domElement.setAttribute(","gt":"'<STR_LIT>', className);"}
{"input":"<s> export default function replaceElement(domElement, virtualElement, parentDomNode, parentVirtualElement, component) {<EOL>    const flexId = getFlexId(virtualElement);<EOL>    if (component.cache[flexId]) {<EOL>        component.cache[flexId] = {};<EOL>    }<EOL>    const newElement = isTextNode(virtualElement)<EOL>        ? createTextNode(domElement, virtualElement)<EOL>        : createTagNode(domElement, virtualElement, parentVirtualElement, component);<EOL>    applyLayout(newElement, virtualElement, parentDomNode,","gt":"parentVirtualElement, component, null);"}
{"input":"<s> <EOL>export default function scale(out, a, v) {<EOL>    const x = v[<NUM_LIT>];<EOL>    const y = v[<NUM_LIT>];<EOL>    const z = v[<NUM_LIT>];<EOL>","gt":"out[<NUM_LIT>] = a[<NUM_LIT>] * x;"}
{"input":"<s> <EOL>export default function scale(out, a, v) {<EOL>    const x = v[<NUM_LIT>];<EOL>    const y = v[<NUM_LIT>];<EOL>    const z = v[<NUM_LIT>];<EOL>     out[<NUM_LIT>] = a[<NUM_LIT>] * x;<EOL>    out[<NUM_LIT>] = a[<NUM_LIT>] * x;<EOL>    out[<NUM_LIT>] = a[<NUM_LIT>] * x;<EOL>    out[","gt":"<NUM_LIT>] = a[<NUM_LIT>] * x;"}
{"input":"<s> <EOL>export default function scale(out, a, v) {<EOL>    const x = v[<NUM_LIT>];<EOL>    const y = v[<NUM_LIT>];<EOL>    const z = v[<NUM_LIT>];<EOL>     out[<NUM_LIT>] = a[<NUM_LIT>] * x;<EOL>    out[<NUM_LIT>] = a[<NUM_LIT>] * x;<EOL>    out[<NUM_LIT>] = a[<NUM_LIT>] * x;<EOL>    out[ <NUM_LIT>] = a[<NUM_LIT>] * x;<EOL>    out[<NUM_LIT>] = a[<NUM_LIT>] * y;<EOL>    out[<NUM_LIT>] = a[<NUM_LIT>] * y;<EOL>    out[<NUM_LIT>] = a[<NUM_LIT>] * y;<EOL>    out[<NUM_LIT>] = a[<NUM_LIT>] *","gt":"y;"}
{"input":"<s> <EOL>export default function scale(out, a, v) {<EOL>    const x = v[<NUM_LIT>];<EOL>    const y = v[<NUM_LIT>];<EOL>    const z = v[<NUM_LIT>];<EOL>     out[<NUM_LIT>] = a[<NUM_LIT>] * x;<EOL>    out[<NUM_LIT>] = a[<NUM_LIT>] * x;<EOL>    out[<NUM_LIT>] = a[<NUM_LIT>] * x;<EOL>    out[ <NUM_LIT>] = a[<NUM_LIT>] * x;<EOL>    out[<NUM_LIT>] = a[<NUM_LIT>] * y;<EOL>    out[<NUM_LIT>] = a[<NUM_LIT>] * y;<EOL>    out[<NUM_LIT>] = a[<NUM_LIT>] * y;<EOL>    out[<NUM_LIT>] = a[<NUM_LIT>] *  y;<EOL>    out[<NUM_LIT>] = a[<NUM_LIT>] * z;<EOL>    out[<NUM_LIT>] = a[<NUM_LIT>] * z;<EOL>    out[<NUM_LIT>] = a[<NUM_LIT>] * z;<EOL>    out[<NUM_LIT>] = a[<NUM_LIT>] * z;<EOL>    out[","gt":"<NUM_LIT>] = a[<NUM_LIT>];"}
{"input":"<s> <EOL>export function addFilter(accountId, area, filter) {<EOL>    return {<EOL>        type: ActionConstants.","gt":"notificationFilter.ADD_FILTER,"}
{"input":"<s> export function setReasonFilter(accountId, repoId, filterName, enabled) {<EOL>    return {<EOL>        type: ActionConstants.repositoryMuteFilters.SET_REASON_FILTER,<EOL>","gt":"accountId,"}
{"input":"<s> export default function createMenu(accountId) {<EOL>    let menu = getNewRemoteElectronMenu();<EOL>    <EOL>    menu.append(getNewRemoteElectronMenuItem({<EOL>        label: '<STR_LIT>',<EOL>        click: () => dispatch(updateAccount(accountId.","gt":"toString(), true))"}
{"input":"<s> export default function createMenu(accountId) {<EOL>    let menu = getNewRemoteElectronMenu();<EOL>    <EOL>    menu.append(getNewRemoteElectronMenuItem({<EOL>        label: '<STR_LIT>',<EOL>        click: () => dispatch(updateAccount(accountId. toString(), true))<EOL>    }));<EOL>    <EOL>    menu.append(getNewRemoteElectronMenuItem({<EOL>","gt":"type: '<STR_LIT>'"}
{"input":"<s> export default function createMenu(accountId) {<EOL>    let menu = getNewRemoteElectronMenu();<EOL>    <EOL>    menu.append(getNewRemoteElectronMenuItem({<EOL>        label: '<STR_LIT>',<EOL>        click: () => dispatch(updateAccount(accountId. toString(), true))<EOL>    }));<EOL>    <EOL>    menu.append(getNewRemoteElectronMenuItem({<EOL>         type: '<STR_LIT>'<EOL>    }));<EOL>    <EOL>    menu.append(getNewRemoteElectronMenuItem({<EOL>","gt":"label: '<STR_LIT>',"}
{"input":"<s> <EOL>export default function filter(input, ruleSet) {<EOL>    if (ruleSet.subjectType.length === <NUM_LIT>) {<EOL>","gt":"return input;"}
{"input":"<s> <EOL>export function getAccountToken(accountId) {<EOL>    let account = getAccount(accountId);<EOL>    if (account ===","gt":"null) {"}
{"input":"<s> <EOL>export function dispatch(action) {<EOL>    return getStore().dispatch(","gt":"action);"}
{"input":"<s> <EOL>export function getScheduledJobs() {<EOL>    return getNodeSchedule().","gt":"scheduledJobs;"}
{"input":"<s> export async function ls(dir) {<EOL>    let files = await deps.fs.readdir(dir);<EOL>    let paths =","gt":"files.map((f) => path.join(dir, f));"}
{"input":"<s> export async function readJSON(file) {<EOL>","gt":"debug('<STR_LIT>', file);"}
{"input":"<s> async function read() {<EOL>    try {<EOL>        let b = await fs.readJSON(info);<EOL>","gt":"return b;"}
{"input":"<s> export function p(confOrType) {<EOL>    if (!Component.inDefinition) {<EOL>        return undefined;<EOL>    }<EOL>    if (typeof confOrType === '<STR_LIT>') {<EOL>        let","gt":"tpe = confOrType;"}
{"input":"<s> export function createMap() {<EOL>    const ret = Object.create(null);<EOL>","gt":"ret[\"<STR_LIT>\"] = undefined;"}
{"input":"<s> function onDidChangeTextDocument(event) {<EOL>    combo++;<EOL>    <EOL>    if (progressBarTimer) {<EOL>","gt":"if (!progressBarTimer.active) {"}
{"input":"<s> function getClassNodeFromTree(className) {<EOL>    var toReturn = null;<EOL>    for (var i = <NUM_LIT>, l = workspaceTree.length; i < l; i++) {<EOL>        var fileNode = workspaceTree[i];<EOL>        for (var","gt":"j = <NUM_LIT>, sl = fileNode.classes.length; j < sl; j++) {"}
{"input":"<s> export function weekDay(year, month, day) {<EOL>    return","gt":"new Date(year, month, day).getDay();"}
{"input":"<s> export function getValueInProperRange(value, max, min = <NUM_LIT>) {<EOL>    return Math.max(Math.min(","gt":"value, max), min);"}
{"input":"<s> export function main() {<EOL>    describe('<STR_LIT>', () => {<EOL>        beforeEach(() => {<EOL>            TestBed.configureTestingModule({<EOL>                declarations: [Infragistics.IgSparklineComponent, TestComponent]<EOL>            });<EOL>        });<EOL>","gt":"it('<STR_LIT>', (done) => {"}
{"input":"<s> export function main() {<EOL>    describe('<STR_LIT>', () => {<EOL>        beforeEach(() => {<EOL>            TestBed.configureTestingModule({<EOL>                declarations: [Infragistics.IgSparklineComponent, TestComponent]<EOL>            });<EOL>        });<EOL>         it('<STR_LIT>', (done) => {<EOL>            var template = '<STR_LIT>';<EOL>            TestBed.overrideComponent(TestComponent, {<EOL>                set: {<EOL>                    template: template<EOL>                }<EOL>            });<EOL>            TestBed.compileComponents().then(() => {<EOL>                let fixture = TestBed.createComponent(TestComponent);<EOL>                fixture.detectChanges();<EOL>                expect(","gt":"fixture.debugElement.componentInstance.viewChild instanceof Infragistics.IgSparklineComponent)"}
{"input":"<s> export function localStorageSyncReducer(_reducer) {<EOL>    return localStorageSync({ keys: ['<STR_LIT>', '<STR_LIT>', '<STR_LIT>'], rehydrate: true,","gt":"storageKeySerializer: keySerializer })(_reducer);"}
{"input":"<s> export function matchRulesFor(world, actorOne, actorTwo, action) {<EOL>    const matchedRules = [];<EOL>    const localRules = getLocalRules(world, actorOne);<EOL>    for (let i = <NUM_LIT>; i < localRules.length; i++) {<EOL>","gt":"const currentRule = localRules[i];"}
{"input":"<s> export function matchRulesFor(world, actorOne, actorTwo, action) {<EOL>    const matchedRules = [];<EOL>    const localRules = getLocalRules(world, actorOne);<EOL>    for (let i = <NUM_LIT>; i < localRules.length; i++) {<EOL>         const currentRule = localRules[i];<EOL>        const isMatch = checkMatch(currentRule, actorOne, actorTwo, action);<EOL>        if (isMatch) {<EOL>            matchedRules.push(currentRule);<EOL>        }<EOL>    }<EOL>    if (!matchedRules.","gt":"length) {"}
{"input":"<s> function requestCompileMir() {<EOL>    return { type: ActionType.","gt":"CompileMirRequest };"}
{"input":"<s> export function toggleConfiguration() {<EOL>","gt":"return { type: ActionType.ToggleConfiguration };"}
{"input":"<s> function _decorate(decorators, target) {<EOL>    Reflect.decorate(","gt":"decorators, target);"}
{"input":"<s> function optional() {<EOL>    return function (target, targetKey, index) {<EOL>        const metadata = new Metadata(METADATA_KEY.OPTIONAL_TAG, true);<EOL>        if (typeof index ===","gt":"\"<STR_LIT>\") {"}
{"input":"<s> function getDependencies(metadataReader, func) {<EOL>","gt":"const constructorName = getFunctionName(func);"}
{"input":"<s> function listMetadataForTarget(serviceIdentifierString, target) {<EOL>    if (target.isTagged() || target.isNamed()) {<EOL>        let m = \"<STR_LIT>\";<EOL>        const namedTag = target.getNamedTag();<EOL>        const otherTags = target.getCustomTags();<EOL>        if (namedTag !== null) {<EOL>            m += namedTag.toString() +","gt":"\"<STR_LIT>\";"}
{"input":"<s> function listMetadataForTarget(serviceIdentifierString, target) {<EOL>    if (target.isTagged() || target.isNamed()) {<EOL>        let m = \"<STR_LIT>\";<EOL>        const namedTag = target.getNamedTag();<EOL>        const otherTags = target.getCustomTags();<EOL>        if (namedTag !== null) {<EOL>            m += namedTag.toString() +  \"<STR_LIT>\";<EOL>        }<EOL>        if (otherTags !== null) {<EOL>            otherTags.forEach((tag) => {<EOL>","gt":"m += tag.toString() + \"<STR_LIT>\";"}
{"input":"<s> function listMetadataForTarget(serviceIdentifierString, target) {<EOL>    if (target.isTagged() || target.isNamed()) {<EOL>        let m = \"<STR_LIT>\";<EOL>        const namedTag = target.getNamedTag();<EOL>        const otherTags = target.getCustomTags();<EOL>        if (namedTag !== null) {<EOL>            m += namedTag.toString() +  \"<STR_LIT>\";<EOL>        }<EOL>        if (otherTags !== null) {<EOL>            otherTags.forEach((tag) => {<EOL>                 m += tag.toString() + \"<STR_LIT>\";<EOL>            });<EOL>        }<EOL>        return","gt":"serviceIdentifierString} - ${m}`<STR_LIT>;"}
{"input":"<s> export async function installGradlePlugins(config, plugins) {<EOL>    log(`<STR_LIT>`);<EOL>    const settingsLines =","gt":"return `<STR_LIT>`"}
{"input":"<s> export async function check(config, checks) {<EOL>    const results = await Promise.all(checks.map((f) => f(config)));<EOL>    const errors = results.filter((r) => r !=","gt":"null);"}
{"input":"<s> export async function checkAppConfig(config) {<EOL>    if (!config.app.appId) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    if (!config.app.appName) {<EOL>        return","gt":"'<STR_LIT>';"}
{"input":"<s> export async function checkAppConfig(config) {<EOL>    if (!config.app.appId) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    if (!config.app.appName) {<EOL>        return  '<STR_LIT>';<EOL>    }<EOL>    const appIdError = await checkAppId(config, config.app.appId);<EOL>    if (appIdError) {<EOL>","gt":"return appIdError;"}
{"input":"<s> export async function checkAppConfig(config) {<EOL>    if (!config.app.appId) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    if (!config.app.appName) {<EOL>        return  '<STR_LIT>';<EOL>    }<EOL>    const appIdError = await checkAppId(config, config.app.appId);<EOL>    if (appIdError) {<EOL>         return appIdError;<EOL>    }<EOL>    const appNameError = await checkAppName(config, config.app.appName);<EOL>    if (","gt":"appNameError) {"}
{"input":"<s> export function removePluginFiles(config, platform) {<EOL>    const webDir = getWebDir(config, platform);<EOL>    const","gt":"pluginsDir = join(webDir, '<STR_LIT>');"}
{"input":"<s> async function promptNewProject(config) {<EOL>    const inquirer = await import('<STR_LIT>');<EOL>    const answers = await inquirer.prompt([{<EOL>            type:","gt":"'<STR_LIT>',"}
{"input":"<s> export async function update(config, platformName, needsUpdate) {<EOL>    runTask(chalk `<STR_LIT>`, async () => {<EOL>        if (platformName === config.ios.name) {<EOL>","gt":"await updateIOS(config, needsUpdate);"}
{"input":"<s> export async function copyWeb(config) {<EOL>    const chalk = require('<STR_LIT>');<EOL>    console.log('<STR_LIT>');<EOL>    if (config.","gt":"app.bundledWebRuntime) {"}
{"input":"<s> export function bundleUpdate(changedFiles, context) {<EOL>    return webpackUpdate(changedFiles, context)<EOL>        .catch((err) => {<EOL>        if (err instanceof","gt":"IgnorableError) {"}
{"input":"<s> export function isDeepLinkingFile(filePath) {<EOL>    const deepLinksDir = getStringPropertyValue(Constants.ENV_VAR_DEEPLINKS_DIR) + sep;<EOL>    const moduleSuffix = getStringPropertyValue(","gt":"Constants.ENV_NG_MODULE_FILE_NAME_SUFFIX);"}
{"input":"<s> function isUserAgentIOS(ua) {<EOL>","gt":"ua = ua.toLowerCase();"}
{"input":"<s> <EOL>function serveIndex(req, res) {<EOL>    const config = req.app.get('<STR_LIT>');<EOL>    <EOL>    const indexFileName = path.join(config.wwwDir, process.env[Constants.ENV_VAR_HTML_TO_SERVE]);<EOL>    fs.readFile(indexFileName, (err, indexHtml) => {<EOL>        if (!indexHtml) {<EOL>            Logger.","gt":"error(`<STR_LIT>`);"}
{"input":"<s> <EOL>function serveIndex(req, res) {<EOL>    const config = req.app.get('<STR_LIT>');<EOL>    <EOL>    const indexFileName = path.join(config.wwwDir, process.env[Constants.ENV_VAR_HTML_TO_SERVE]);<EOL>    fs.readFile(indexFileName, (err, indexHtml) => {<EOL>        if (!indexHtml) {<EOL>            Logger. error(`<STR_LIT>`);<EOL>            res.send('<STR_LIT>');<EOL>            return;<EOL>        }<EOL>","gt":"if (config.useLiveReload) {"}
{"input":"<s> function getSuffixFromGeneratorType(context, type) {<EOL>    if (type === Constants.COMPONENT) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    else if (type === Constants.DIRECTIVE) {<EOL>        return","gt":"'<STR_LIT>';"}
{"input":"<s> function getSuffixFromGeneratorType(context, type) {<EOL>    if (type === Constants.COMPONENT) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    else if (type === Constants.DIRECTIVE) {<EOL>        return  '<STR_LIT>';<EOL>    }<EOL>    else if (type === Constants.PAGE || type === Constants.TABS) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    else if (type === Constants.PIPE) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    else","gt":"if (type === Constants.PROVIDER) {"}
{"input":"<s> <EOL>export function createLinter(context, program) {<EOL>","gt":"return new Linter({"}
{"input":"<s> <EOL>export function lint(linter, config, filePath, fileContents) {<EOL>","gt":"linter.lint(filePath, fileContents, config);"}
{"input":"<s> export function lintUpdateWorker(context, { tsConfig, tsLintConfig, filePaths, typeCheck }) {<EOL>    const program = createProgram(context, tsConfig);<EOL>    return getLintConfig(context,","gt":"tsLintConfig)"}
{"input":"<s> <EOL>export function processLintResult(context, result) {<EOL>    const files = [];<EOL>    <EOL>    if (result.errorCount !== <NUM_LIT> || result.warningCount !== <NUM_LIT>) {<EOL>","gt":"const diagnostics = runTsLintDiagnostics(context, result.failures);"}
{"input":"<s> <EOL>export function processLintResult(context, result) {<EOL>    const files = [];<EOL>    <EOL>    if (result.errorCount !== <NUM_LIT> || result.warningCount !== <NUM_LIT>) {<EOL>         const diagnostics = runTsLintDiagnostics(context, result.failures);<EOL>        printDiagnostics(context, DiagnosticsType.TsLint, diagnostics, true, false);<EOL>        files.push(...getFileNames(context, result.failures));<EOL>    }<EOL>    if (files.length > <NUM_LIT>) {<EOL>        const errorMessage =","gt":"generateErrorMessageForFiles(files);"}
{"input":"<s> function getMockFontDirData() {<EOL>    return [<EOL>        '<STR_LIT>',<EOL>","gt":"'<STR_LIT>',"}
{"input":"<s> function getMockFontDirData() {<EOL>    return [<EOL>        '<STR_LIT>',<EOL>         '<STR_LIT>',<EOL>        '<STR_LIT>',<EOL>        '<STR_LIT>',<EOL>","gt":"'<STR_LIT>',"}
{"input":"<s> function getMockFontDirData() {<EOL>    return [<EOL>        '<STR_LIT>',<EOL>         '<STR_LIT>',<EOL>        '<STR_LIT>',<EOL>        '<STR_LIT>',<EOL>         '<STR_LIT>',<EOL>        '<STR_LIT>',<EOL>        '<STR_LIT>',<EOL>        '<STR_LIT>',<EOL>        '<STR_LIT>',<EOL>        '<STR_LIT>',<EOL>        '<STR_LIT>',<EOL>        '<STR_LIT>',<EOL>","gt":"'<STR_LIT>',"}
{"input":"<s> function getMockFontDirData() {<EOL>    return [<EOL>        '<STR_LIT>',<EOL>         '<STR_LIT>',<EOL>        '<STR_LIT>',<EOL>        '<STR_LIT>',<EOL>         '<STR_LIT>',<EOL>        '<STR_LIT>',<EOL>        '<STR_LIT>',<EOL>        '<STR_LIT>',<EOL>        '<STR_LIT>',<EOL>        '<STR_LIT>',<EOL>        '<STR_LIT>',<EOL>        '<STR_LIT>',<EOL>         '<STR_LIT>',<EOL>        '<STR_LIT>',<EOL>        '<STR_LIT>',<EOL>","gt":"'<STR_LIT>',"}
{"input":"<s> function getMockFontDirData() {<EOL>    return [<EOL>        '<STR_LIT>',<EOL>         '<STR_LIT>',<EOL>        '<STR_LIT>',<EOL>        '<STR_LIT>',<EOL>         '<STR_LIT>',<EOL>        '<STR_LIT>',<EOL>        '<STR_LIT>',<EOL>        '<STR_LIT>',<EOL>        '<STR_LIT>',<EOL>        '<STR_LIT>',<EOL>        '<STR_LIT>',<EOL>        '<STR_LIT>',<EOL>         '<STR_LIT>',<EOL>        '<STR_LIT>',<EOL>        '<STR_LIT>',<EOL>         '<STR_LIT>',<EOL>        '<STR_LIT>',<EOL>        '<STR_LIT>',<EOL>        '<STR_LIT>',<EOL>        '<STR_LIT>',<EOL>        '<STR_LIT>',<EOL>        '<STR_LIT>',<EOL>","gt":"'<STR_LIT>',"}
{"input":"<s> export function writeFilesToDisk(context) {<EOL>    emptyDirSync(context.tmpDir);<EOL>    const files = context.fileCache.getAll();<EOL>    files.forEach((file) => {<EOL>        const dirName = dirname(","gt":"file.path);"}
{"input":"<s> export function writeFilesToDisk(context) {<EOL>    emptyDirSync(context.tmpDir);<EOL>    const files = context.fileCache.getAll();<EOL>    files.forEach((file) => {<EOL>        const dirName = dirname( file.path);<EOL>        const relativePath = relative(process.cwd(), dirName);<EOL>        const tmpPath = join(context.tmpDir, relativePath);<EOL>        const fileName = basename(file.path);<EOL>        const fileToWrite = join(tmpPath, fileName);<EOL>        mkdirpSync(tmpPath);<EOL>        writeFileSync(fileToWrite,","gt":"file.content);"}
{"input":"<s> function preprocessWorker(context) {<EOL>","gt":"const bundlePromise = bundleCoreComponents(context);"}
{"input":"<s> function getTemplatePrefix(htmlFilePath) {<EOL>    return","gt":"resolve(htmlFilePath)}\"<STR_LIT>;"}
{"input":"<s> function getTemplateSuffix(htmlFilePath) {<EOL>    return","gt":"resolve(htmlFilePath)}\"<STR_LIT>;"}
{"input":"<s> export function bundlerStrategy(context) {<EOL>    return","gt":"Constants.BUNDLER_WEBPACK;"}
{"input":"<s> export function paramCase(input) {<EOL>    return removeCaseFromString(","gt":"input, '<STR_LIT>');"}
{"input":"<s> export function getProjectJson() {<EOL>    const projectFile = path.join(process.cwd(), '<STR_LIT>');<EOL>    return","gt":"readFilePromise(projectFile).then(function (textString) {"}
{"input":"<s> <EOL>export function separateArgv(pargv) {<EOL>    const ownArgs = [...pargv];<EOL>    const otherArgs = [];<EOL>    const sepIndex = pargv.","gt":"indexOf('<STR_LIT>');"}
{"input":"<s> function formatCommandHeader(cmd, fullName) {<EOL>    return","gt":"}"}
{"input":"<s> export function getWarning() {<EOL>","gt":"return `<STR_LIT>`"}
{"input":"<s> export function isApp(d) {<EOL>    const details = d;<EOL>","gt":"return details"}
{"input":"<s> export function isAppResponse(r) {<EOL>","gt":"return isAPIResponseSuccess(r)"}
{"input":"<s> export function isSnapshot(s) {<EOL>    const snapshot = s;<EOL>    return snapshot<EOL>        && typeof snapshot.id ===","gt":"'<STR_LIT>'"}
{"input":"<s> export function isUser(u) {<EOL>    const user = u;<EOL>    return","gt":"user"}
{"input":"<s> export function isUserResponse(r) {<EOL>    return","gt":"isAPIResponseSuccess(r)"}
{"input":"<s> export async function isRepoInitialized(dir) {<EOL>    return pathExists(","gt":"path.join(dir, '<STR_LIT>'));"}
{"input":"<s> export async function loadFromPath(p) {<EOL>    const","gt":"s = await fileToString(p);"}
{"input":"<s> export async function validatePrivateKey(keyPath) {<EOL>    try {<EOL>        await fsStat(keyPath);<EOL>    }<EOL>    catch (e) {<EOL>        if (e.code ===","gt":"'<STR_LIT>') {"}
{"input":"<s> export async function validatePrivateKey(keyPath) {<EOL>    try {<EOL>        await fsStat(keyPath);<EOL>    }<EOL>    catch (e) {<EOL>        if (e.code ===  '<STR_LIT>') {<EOL>            throw ERROR_SSH_MISSING_PRIVKEY;<EOL>        }<EOL>        throw e;<EOL>    }<EOL>    const f = await fsReadFile(keyPath, { encoding: '<STR_LIT>' });<EOL>    const lines = f.","gt":"split('<STR_LIT>');"}
{"input":"<s> export function buildIonicAngularEsm(stripDebug, done) {<EOL>    const stream = copySourceToDest(DIST_BUILD_ROOT, true, true, stripDebug);<EOL>    stream.on('<STR_LIT>', () => {<EOL>        <EOL>        createTempTsConfig([join('<STR_LIT>', '<STR_LIT>', '<STR_LIT>')], ES5, ES_2015, join(PROJECT_ROOT, '<STR_LIT>'), join(DIST_BUILD_ROOT, '<STR_LIT>'));<EOL>        runNgc(","gt":"join(DIST_BUILD_ROOT, '<STR_LIT>'), (err) => {"}
{"input":"<s> export function buildIonicAngularEsm(stripDebug, done) {<EOL>    const stream = copySourceToDest(DIST_BUILD_ROOT, true, true, stripDebug);<EOL>    stream.on('<STR_LIT>', () => {<EOL>        <EOL>        createTempTsConfig([join('<STR_LIT>', '<STR_LIT>', '<STR_LIT>')], ES5, ES_2015, join(PROJECT_ROOT, '<STR_LIT>'), join(DIST_BUILD_ROOT, '<STR_LIT>'));<EOL>        runNgc( join(DIST_BUILD_ROOT, '<STR_LIT>'), (err) => {<EOL>            if (err) {<EOL>                done(err);<EOL>                return;<EOL>            }<EOL>            <EOL>            deleteFiles([`<STR_LIT>`,<EOL>                `<STR_LIT>`,<EOL>","gt":"DIST_BUILD_ROOT}/tsconfig.json`,"}
{"input":"<s> <EOL>function ifUndefined(val1, val2) {<EOL>    return (val1 === undefined) ?","gt":"val2 : val1;"}
{"input":"<s> <EOL>function inherit(child, base, properties) {<EOL>    var baseP = base.prototype, childP;<EOL>    childP = child.prototype = Object.create(baseP);<EOL>    childP.","gt":"constructor = child;"}
{"input":"<s> <EOL>function triggerDomEvent(event, data) {<EOL>    var gestureEvent = doc.createEvent('<STR_LIT>');<EOL>    gestureEvent.initEvent(event, true,","gt":"true);"}
{"input":"<s> function testValues() {<EOL>    let parent = document.createElement('<STR_LIT>');<EOL>    let ele = document.createElement('<STR_LIT>');<EOL>","gt":"parent.appendChild(ele);"}
{"input":"<s> export function updateDate(existingData, newData) {<EOL>    if (isPresent(newData) && newData !== '<STR_LIT>') {<EOL>        if (isString(newData)) {<EOL>            <EOL>            <EOL>            newData = parseDate(","gt":"newData);"}
{"input":"<s> export function updateDate(existingData, newData) {<EOL>    if (isPresent(newData) && newData !== '<STR_LIT>') {<EOL>        if (isString(newData)) {<EOL>            <EOL>            <EOL>            newData = parseDate( newData);<EOL>            if (newData) {<EOL>                <EOL>","gt":"Object.assign(existingData, newData);"}
{"input":"<s> export function updateDate(existingData, newData) {<EOL>    if (isPresent(newData) && newData !== '<STR_LIT>') {<EOL>        if (isString(newData)) {<EOL>            <EOL>            <EOL>            newData = parseDate( newData);<EOL>            if (newData) {<EOL>                <EOL>                 Object.assign(existingData, newData);<EOL>                return true;<EOL>            }<EOL>        }<EOL>        else if ((isPresent(newData.year) || isPresent(newData.hour) || isPresent(newData.month) || isPresent(newData.day) || isPresent(newData.minute) || isPresent(newData.second))) {<EOL>            <EOL>            <EOL>            <EOL>            if (isPresent(newData.ampm) && isPresent(newData.hour)) {<EOL>                if (","gt":"newData.ampm.value === '<STR_LIT>') {"}
{"input":"<s> export function updateDate(existingData, newData) {<EOL>    if (isPresent(newData) && newData !== '<STR_LIT>') {<EOL>        if (isString(newData)) {<EOL>            <EOL>            <EOL>            newData = parseDate( newData);<EOL>            if (newData) {<EOL>                <EOL>                 Object.assign(existingData, newData);<EOL>                return true;<EOL>            }<EOL>        }<EOL>        else if ((isPresent(newData.year) || isPresent(newData.hour) || isPresent(newData.month) || isPresent(newData.day) || isPresent(newData.minute) || isPresent(newData.second))) {<EOL>            <EOL>            <EOL>            <EOL>            if (isPresent(newData.ampm) && isPresent(newData.hour)) {<EOL>                if ( newData.ampm.value === '<STR_LIT>') {<EOL>                    newData.hour.value = (newData.hour.value === <NUM_LIT> ? <NUM_LIT> : newData.hour.value + <NUM_LIT>);<EOL>                }<EOL>                else {<EOL>                    newData.hour.value = (newData.hour.value === <NUM_LIT> ? <NUM_LIT> : newData.hour.value);<EOL>                }<EOL>            }<EOL>            <EOL>            <EOL>            for (const k in newData) {<EOL>                existingData[k] = newData[k].value;<EOL>            }<EOL>            return true;<EOL>        }<EOL>        <EOL>        console.warn(`<STR_LIT>`);<EOL>    }<EOL>","gt":"else {"}
{"input":"<s> <EOL>export function requestIonicCallback(functionToLazy) {<EOL>    if ('<STR_LIT>' in window) {<EOL>","gt":"return window.requestIdleCallback(functionToLazy);"}
{"input":"<s> <EOL>function parseCss(node, text) {<EOL>    let t = text.substring(node.start, node.end - <NUM_LIT>);<EOL>    node.parsedCssText = node.cssText = t.trim();<EOL>","gt":"if (node.parent) {"}
{"input":"<s> <EOL>function parseCss(node, text) {<EOL>    let t = text.substring(node.start, node.end - <NUM_LIT>);<EOL>    node.parsedCssText = node.cssText = t.trim();<EOL>     if (node.parent) {<EOL>        let ss = node.previous ? node.previous.end : node.parent.start;<EOL>        t = text.substring(ss, node.start - <NUM_LIT>);<EOL>        t = _expandUnicodeEscapes(t);<EOL>        t = t.replace(MULTI_SPACES_RX,","gt":"'<STR_LIT>');"}
{"input":"<s> <EOL>function parseCss(node, text) {<EOL>    let t = text.substring(node.start, node.end - <NUM_LIT>);<EOL>    node.parsedCssText = node.cssText = t.trim();<EOL>     if (node.parent) {<EOL>        let ss = node.previous ? node.previous.end : node.parent.start;<EOL>        t = text.substring(ss, node.start - <NUM_LIT>);<EOL>        t = _expandUnicodeEscapes(t);<EOL>        t = t.replace(MULTI_SPACES_RX,  '<STR_LIT>');<EOL>        t = t.substring(t.lastIndexOf('<STR_LIT>') + <NUM_LIT>);<EOL>        let s = node.parsedSelector = node.selector = t.trim();<EOL>        node.atRule = (s.indexOf(AT_START) === <NUM_LIT>);<EOL>        <EOL>        if (","gt":"node.atRule) {"}
{"input":"<s> export function createDom() {<EOL>    let dom = null;<EOL>    return {<EOL>        parse(opts) {<EOL>            if (dom) {<EOL>                dom.window.close();<EOL>            }<EOL>            const jsdom = require('<STR_LIT>');<EOL>            const jsdomOptions = {<EOL>","gt":"url: opts.url,"}
{"input":"<s> export function createDom() {<EOL>    let dom = null;<EOL>    return {<EOL>        parse(opts) {<EOL>            if (dom) {<EOL>                dom.window.close();<EOL>            }<EOL>            const jsdom = require('<STR_LIT>');<EOL>            const jsdomOptions = {<EOL>                 url: opts.url,<EOL>                referrer: opts.referrer,<EOL>                userAgent: opts.userAgent<EOL>            };<EOL>            if (opts.console) {<EOL>                jsdomOptions.virtualConsole = new jsdom.VirtualConsole();<EOL>                jsdomOptions.","gt":"virtualConsole.sendTo(opts.console);"}
{"input":"<s> export function createDom() {<EOL>    let dom = null;<EOL>    return {<EOL>        parse(opts) {<EOL>            if (dom) {<EOL>                dom.window.close();<EOL>            }<EOL>            const jsdom = require('<STR_LIT>');<EOL>            const jsdomOptions = {<EOL>                 url: opts.url,<EOL>                referrer: opts.referrer,<EOL>                userAgent: opts.userAgent<EOL>            };<EOL>            if (opts.console) {<EOL>                jsdomOptions.virtualConsole = new jsdom.VirtualConsole();<EOL>                jsdomOptions. virtualConsole.sendTo(opts.console);<EOL>            }<EOL>            dom = new jsdom.JSDOM(opts.html, jsdomOptions);<EOL>            polyfillJsDom(dom.window);<EOL>            return dom.window;<EOL>        },<EOL>        serialize() {<EOL>","gt":"return dom.serialize();"}
{"input":"<s> export function mockRenderer(plt, domApi) {<EOL>","gt":"plt = plt || mockPlatform();"}
{"input":"<s> function getTestBuildConfig() {<EOL>    const sys = mockStencilSystem();<EOL>    const config = {<EOL>        sys: sys,<EOL>        logger: mockLogger(),<EOL>        rootDir: '<STR_LIT>',<EOL>","gt":"suppressTypeScriptErrors: true,"}
{"input":"<s> function getTestBuildConfig() {<EOL>    const sys = mockStencilSystem();<EOL>    const config = {<EOL>        sys: sys,<EOL>        logger: mockLogger(),<EOL>        rootDir: '<STR_LIT>',<EOL>         suppressTypeScriptErrors: true,<EOL>        devMode: true<EOL>    };<EOL>    config.prerender = false;<EOL>","gt":"config.devMode = true;"}
{"input":"<s> function getTestBuildConfig() {<EOL>    const sys = mockStencilSystem();<EOL>    const config = {<EOL>        sys: sys,<EOL>        logger: mockLogger(),<EOL>        rootDir: '<STR_LIT>',<EOL>         suppressTypeScriptErrors: true,<EOL>        devMode: true<EOL>    };<EOL>    config.prerender = false;<EOL>     config.devMode = true;<EOL>    config._isTesting = true;<EOL>    config.serviceWorker = false;<EOL>    config.emptyDist =","gt":"false;"}
{"input":"<s> export function HttpLoaderFactory(http) {<EOL>","gt":"return new TranslateHttpLoader(http);"}
{"input":"<s> <EOL>export function ensureArray(v) {<EOL>    if (!v || !v.length) {<EOL>","gt":"return [];"}
{"input":"<s> export function updateQuery(model, primaryValue, newFields) {<EOL>    let query = `<STR_LIT>`;<EOL>","gt":"for (const key of Object.keys(newFields)) {"}
{"input":"<s> export function ensureExtends() {<EOL>","gt":"let _;"}
{"input":"<s> export default function getGameStatus(rs, game, cave) {<EOL>    const { commons, session, tasks, downloads } = rs;<EOL>    const { credentials } = session;<EOL>    let downloadKeys = getByIds(commons.downloadKeys, commons.downloadKeyIdsByGameId[game.id]);<EOL>    if (!cave) {<EOL>        let caves = getByIds(commons.caves, commons.","gt":"caveIdsByGameId[game.id]);"}
{"input":"<s> export default function getGameStatus(rs, game, cave) {<EOL>    const { commons, session, tasks, downloads } = rs;<EOL>    const { credentials } = session;<EOL>    let downloadKeys = getByIds(commons.downloadKeys, commons.downloadKeyIdsByGameId[game.id]);<EOL>    if (!cave) {<EOL>        let caves = getByIds(commons.caves, commons. caveIdsByGameId[game.id]);<EOL>        cave = first(caves);<EOL>    }<EOL>    const","gt":"downloadKey = first(downloadKeys);"}
{"input":"<s> export default function getGameStatus(rs, game, cave) {<EOL>    const { commons, session, tasks, downloads } = rs;<EOL>    const { credentials } = session;<EOL>    let downloadKeys = getByIds(commons.downloadKeys, commons.downloadKeyIdsByGameId[game.id]);<EOL>    if (!cave) {<EOL>        let caves = getByIds(commons.caves, commons. caveIdsByGameId[game.id]);<EOL>        cave = first(caves);<EOL>    }<EOL>    const  downloadKey = first(downloadKeys);<EOL>    const pressUser = credentials.me.pressUser;<EOL>    const task = first(tasks.tasksByGameId[game.id]);<EOL>    const download = first(getPendingForGame(downloads, game.id));<EOL>    let isActiveDownload = false;<EOL>","gt":"let areDownloadsPaused = false;"}
{"input":"<s> function rawGetGameStatus(game, cave, downloadKey, pressUser, task, download, update, isDownloadActive, areDownloadsPaused) {<EOL>    let access = Access.None;<EOL>    if (!(game.minPrice > <NUM_LIT>)) {<EOL>","gt":"if (game.canBeBought) {"}
{"input":"<s> function rawGetGameStatus(game, cave, downloadKey, pressUser, task, download, update, isDownloadActive, areDownloadsPaused) {<EOL>    let access = Access.None;<EOL>    if (!(game.minPrice > <NUM_LIT>)) {<EOL>         if (game.canBeBought) {<EOL>            access = Access.Pwyw;<EOL>        }<EOL>        else {<EOL>            access =","gt":"Access.Free;"}
{"input":"<s> function rawGetGameStatus(game, cave, downloadKey, pressUser, task, download, update, isDownloadActive, areDownloadsPaused) {<EOL>    let access = Access.None;<EOL>    if (!(game.minPrice > <NUM_LIT>)) {<EOL>         if (game.canBeBought) {<EOL>            access = Access.Pwyw;<EOL>        }<EOL>        else {<EOL>            access =  Access.Free;<EOL>        }<EOL>    }<EOL>    else {<EOL>        <EOL>","gt":"if (downloadKey) {"}
{"input":"<s> function rawGetGameStatus(game, cave, downloadKey, pressUser, task, download, update, isDownloadActive, areDownloadsPaused) {<EOL>    let access = Access.None;<EOL>    if (!(game.minPrice > <NUM_LIT>)) {<EOL>         if (game.canBeBought) {<EOL>            access = Access.Pwyw;<EOL>        }<EOL>        else {<EOL>            access =  Access.Free;<EOL>        }<EOL>    }<EOL>    else {<EOL>        <EOL>         if (downloadKey) {<EOL>            <EOL>            access = Access.Key;<EOL>        }<EOL>        else {<EOL>            <EOL>","gt":"if (game.inPressSystem && pressUser) {"}
{"input":"<s> function rawGetGameStatus(game, cave, downloadKey, pressUser, task, download, update, isDownloadActive, areDownloadsPaused) {<EOL>    let access = Access.None;<EOL>    if (!(game.minPrice > <NUM_LIT>)) {<EOL>         if (game.canBeBought) {<EOL>            access = Access.Pwyw;<EOL>        }<EOL>        else {<EOL>            access =  Access.Free;<EOL>        }<EOL>    }<EOL>    else {<EOL>        <EOL>         if (downloadKey) {<EOL>            <EOL>            access = Access.Key;<EOL>        }<EOL>        else {<EOL>            <EOL>             if (game.inPressSystem && pressUser) {<EOL>                access = Access.Press;<EOL>            }<EOL>            else {<EOL>                <EOL>            }<EOL>        }<EOL>    }<EOL>    let operation = null;<EOL>    if (task) {<EOL>        operation = {<EOL>            type: OperationType.Task,<EOL>            name: task.name,<EOL>            active: true,<EOL>","gt":"paused: false,"}
{"input":"<s> function rawGetGameStatus(game, cave, downloadKey, pressUser, task, download, update, isDownloadActive, areDownloadsPaused) {<EOL>    let access = Access.None;<EOL>    if (!(game.minPrice > <NUM_LIT>)) {<EOL>         if (game.canBeBought) {<EOL>            access = Access.Pwyw;<EOL>        }<EOL>        else {<EOL>            access =  Access.Free;<EOL>        }<EOL>    }<EOL>    else {<EOL>        <EOL>         if (downloadKey) {<EOL>            <EOL>            access = Access.Key;<EOL>        }<EOL>        else {<EOL>            <EOL>             if (game.inPressSystem && pressUser) {<EOL>                access = Access.Press;<EOL>            }<EOL>            else {<EOL>                <EOL>            }<EOL>        }<EOL>    }<EOL>    let operation = null;<EOL>    if (task) {<EOL>        operation = {<EOL>            type: OperationType.Task,<EOL>            name: task.name,<EOL>            active: true,<EOL>             paused: false,<EOL>            progress: task.progress,<EOL>            eta: task.eta,<EOL>            bps: task.bps,<EOL>        };<EOL>    }<EOL>    else if (download) {<EOL>        operation = {<EOL>            type: OperationType.Download,<EOL>            id: download.id,<EOL>            reason: download.reason,<EOL>            active:","gt":"isDownloadActive,"}
{"input":"<s> function rawGetGameStatus(game, cave, downloadKey, pressUser, task, download, update, isDownloadActive, areDownloadsPaused) {<EOL>    let access = Access.None;<EOL>    if (!(game.minPrice > <NUM_LIT>)) {<EOL>         if (game.canBeBought) {<EOL>            access = Access.Pwyw;<EOL>        }<EOL>        else {<EOL>            access =  Access.Free;<EOL>        }<EOL>    }<EOL>    else {<EOL>        <EOL>         if (downloadKey) {<EOL>            <EOL>            access = Access.Key;<EOL>        }<EOL>        else {<EOL>            <EOL>             if (game.inPressSystem && pressUser) {<EOL>                access = Access.Press;<EOL>            }<EOL>            else {<EOL>                <EOL>            }<EOL>        }<EOL>    }<EOL>    let operation = null;<EOL>    if (task) {<EOL>        operation = {<EOL>            type: OperationType.Task,<EOL>            name: task.name,<EOL>            active: true,<EOL>             paused: false,<EOL>            progress: task.progress,<EOL>            eta: task.eta,<EOL>            bps: task.bps,<EOL>        };<EOL>    }<EOL>    else if (download) {<EOL>        operation = {<EOL>            type: OperationType.Download,<EOL>            id: download.id,<EOL>            reason: download.reason,<EOL>            active:  isDownloadActive,<EOL>            paused: areDownloadsPaused,<EOL>            progress: download.progress,<EOL>            eta: download.eta,<EOL>            bps: download.bps,<EOL>        };<EOL>    }<EOL>    const compatible = isPlatformCompatible(game);<EOL>","gt":"return {"}
{"input":"<s> <EOL>export function isLinux64() {<EOL>    if (!hasDeterminedLinux64) {<EOL>        cachedIsLinux64 =","gt":"determineLinux64();"}
{"input":"<s> export function preferencesPath() {<EOL>    return join(app.getPath(\"<STR_LIT>\"),","gt":"\"<STR_LIT>\");"}
{"input":"<s> export async function regAddDefault(ctx, key, value) {<EOL>    await spawn.assert({<EOL>","gt":"command: regPath,"}
{"input":"<s> function computeMenuTemplate(appVersion, credentials, runtime) {<EOL>    const menus = {<EOL>        mainMac: {<EOL>            <EOL>","gt":"submenu: ["}
{"input":"<s> function computeMenuTemplate(appVersion, credentials, runtime) {<EOL>    const menus = {<EOL>        mainMac: {<EOL>            <EOL>             submenu: [<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                    submenu: [],<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>","gt":"localizedLabel: [\"<STR_LIT>\"],"}
{"input":"<s> function computeMenuTemplate(appVersion, credentials, runtime) {<EOL>    const menus = {<EOL>        mainMac: {<EOL>            <EOL>             submenu: [<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                    submenu: [],<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                     localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>            ],<EOL>        },<EOL>        file: {<EOL>            localizedLabel: [\"<STR_LIT>\"],<EOL>            submenu: [<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>","gt":"type: \"<STR_LIT>\","}
{"input":"<s> function computeMenuTemplate(appVersion, credentials, runtime) {<EOL>    const menus = {<EOL>        mainMac: {<EOL>            <EOL>             submenu: [<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                    submenu: [],<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                     localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>            ],<EOL>        },<EOL>        file: {<EOL>            localizedLabel: [\"<STR_LIT>\"],<EOL>            submenu: [<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                     type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>","gt":"type: \"<STR_LIT>\","}
{"input":"<s> function computeMenuTemplate(appVersion, credentials, runtime) {<EOL>    const menus = {<EOL>        mainMac: {<EOL>            <EOL>             submenu: [<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                    submenu: [],<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                     localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>            ],<EOL>        },<EOL>        file: {<EOL>            localizedLabel: [\"<STR_LIT>\"],<EOL>            submenu: [<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                     type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                     type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [","gt":"\"<STR_LIT>\"],"}
{"input":"<s> function computeMenuTemplate(appVersion, credentials, runtime) {<EOL>    const menus = {<EOL>        mainMac: {<EOL>            <EOL>             submenu: [<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                    submenu: [],<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                     localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>            ],<EOL>        },<EOL>        file: {<EOL>            localizedLabel: [\"<STR_LIT>\"],<EOL>            submenu: [<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                     type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                     type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [ \"<STR_LIT>\"],<EOL>                    accelerator:","gt":"\"<STR_LIT>\","}
{"input":"<s> function computeMenuTemplate(appVersion, credentials, runtime) {<EOL>    const menus = {<EOL>        mainMac: {<EOL>            <EOL>             submenu: [<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                    submenu: [],<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                     localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>            ],<EOL>        },<EOL>        file: {<EOL>            localizedLabel: [\"<STR_LIT>\"],<EOL>            submenu: [<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                     type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                     type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [ \"<STR_LIT>\"],<EOL>                    accelerator:  \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: runtime.platform === \"<STR_LIT>\" ? \"<STR_LIT>\" : \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [","gt":"\"<STR_LIT>\"],"}
{"input":"<s> function computeMenuTemplate(appVersion, credentials, runtime) {<EOL>    const menus = {<EOL>        mainMac: {<EOL>            <EOL>             submenu: [<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                    submenu: [],<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                     localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>            ],<EOL>        },<EOL>        file: {<EOL>            localizedLabel: [\"<STR_LIT>\"],<EOL>            submenu: [<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                     type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                     type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [ \"<STR_LIT>\"],<EOL>                    accelerator:  \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: runtime.platform === \"<STR_LIT>\" ? \"<STR_LIT>\" : \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [ \"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>            ],<EOL>        },<EOL>        fileMac: {<EOL>            localizedLabel: [\"<STR_LIT>\"],<EOL>            submenu: [<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [","gt":"\"<STR_LIT>\"],"}
{"input":"<s> function computeMenuTemplate(appVersion, credentials, runtime) {<EOL>    const menus = {<EOL>        mainMac: {<EOL>            <EOL>             submenu: [<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                    submenu: [],<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                     localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>            ],<EOL>        },<EOL>        file: {<EOL>            localizedLabel: [\"<STR_LIT>\"],<EOL>            submenu: [<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                     type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                     type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [ \"<STR_LIT>\"],<EOL>                    accelerator:  \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: runtime.platform === \"<STR_LIT>\" ? \"<STR_LIT>\" : \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [ \"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>            ],<EOL>        },<EOL>        fileMac: {<EOL>            localizedLabel: [\"<STR_LIT>\"],<EOL>            submenu: [<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [ \"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>","gt":"localizedLabel: [\"<STR_LIT>\"],"}
{"input":"<s> function computeMenuTemplate(appVersion, credentials, runtime) {<EOL>    const menus = {<EOL>        mainMac: {<EOL>            <EOL>             submenu: [<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                    submenu: [],<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                     localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>            ],<EOL>        },<EOL>        file: {<EOL>            localizedLabel: [\"<STR_LIT>\"],<EOL>            submenu: [<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                     type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                     type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [ \"<STR_LIT>\"],<EOL>                    accelerator:  \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: runtime.platform === \"<STR_LIT>\" ? \"<STR_LIT>\" : \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [ \"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>            ],<EOL>        },<EOL>        fileMac: {<EOL>            localizedLabel: [\"<STR_LIT>\"],<EOL>            submenu: [<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [ \"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                     localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: runtime.platform === \"<STR_LIT>\" ? \"<STR_LIT>\" : \"<STR_LIT>\",<EOL>                },<EOL>            ],<EOL>        },<EOL>","gt":"edit: {"}
{"input":"<s> function computeMenuTemplate(appVersion, credentials, runtime) {<EOL>    const menus = {<EOL>        mainMac: {<EOL>            <EOL>             submenu: [<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                    submenu: [],<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                     localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>            ],<EOL>        },<EOL>        file: {<EOL>            localizedLabel: [\"<STR_LIT>\"],<EOL>            submenu: [<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                     type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                     type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [ \"<STR_LIT>\"],<EOL>                    accelerator:  \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: runtime.platform === \"<STR_LIT>\" ? \"<STR_LIT>\" : \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [ \"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>            ],<EOL>        },<EOL>        fileMac: {<EOL>            localizedLabel: [\"<STR_LIT>\"],<EOL>            submenu: [<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [ \"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                     localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: runtime.platform === \"<STR_LIT>\" ? \"<STR_LIT>\" : \"<STR_LIT>\",<EOL>                },<EOL>            ],<EOL>        },<EOL>         edit: {<EOL>            localizedLabel: [\"<STR_LIT>\"],<EOL>            visible: false,<EOL>            submenu: [<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>","gt":"role: \"<STR_LIT>\","}
{"input":"<s> function computeMenuTemplate(appVersion, credentials, runtime) {<EOL>    const menus = {<EOL>        mainMac: {<EOL>            <EOL>             submenu: [<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                    submenu: [],<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                     localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>            ],<EOL>        },<EOL>        file: {<EOL>            localizedLabel: [\"<STR_LIT>\"],<EOL>            submenu: [<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                     type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                     type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [ \"<STR_LIT>\"],<EOL>                    accelerator:  \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: runtime.platform === \"<STR_LIT>\" ? \"<STR_LIT>\" : \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [ \"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>            ],<EOL>        },<EOL>        fileMac: {<EOL>            localizedLabel: [\"<STR_LIT>\"],<EOL>            submenu: [<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [ \"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                     localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: runtime.platform === \"<STR_LIT>\" ? \"<STR_LIT>\" : \"<STR_LIT>\",<EOL>                },<EOL>            ],<EOL>        },<EOL>         edit: {<EOL>            localizedLabel: [\"<STR_LIT>\"],<EOL>            visible: false,<EOL>            submenu: [<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                     role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>","gt":"localizedLabel: [\"<STR_LIT>\"],"}
{"input":"<s> function computeMenuTemplate(appVersion, credentials, runtime) {<EOL>    const menus = {<EOL>        mainMac: {<EOL>            <EOL>             submenu: [<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                    submenu: [],<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                     localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>            ],<EOL>        },<EOL>        file: {<EOL>            localizedLabel: [\"<STR_LIT>\"],<EOL>            submenu: [<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                     type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                     type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [ \"<STR_LIT>\"],<EOL>                    accelerator:  \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: runtime.platform === \"<STR_LIT>\" ? \"<STR_LIT>\" : \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [ \"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>            ],<EOL>        },<EOL>        fileMac: {<EOL>            localizedLabel: [\"<STR_LIT>\"],<EOL>            submenu: [<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [ \"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                     localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: runtime.platform === \"<STR_LIT>\" ? \"<STR_LIT>\" : \"<STR_LIT>\",<EOL>                },<EOL>            ],<EOL>        },<EOL>         edit: {<EOL>            localizedLabel: [\"<STR_LIT>\"],<EOL>            visible: false,<EOL>            submenu: [<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                     role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                     localizedLabel: [\"<STR_LIT>\"],<EOL>","gt":"accelerator: \"<STR_LIT>\","}
{"input":"<s> function computeMenuTemplate(appVersion, credentials, runtime) {<EOL>    const menus = {<EOL>        mainMac: {<EOL>            <EOL>             submenu: [<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                    submenu: [],<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                     localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>            ],<EOL>        },<EOL>        file: {<EOL>            localizedLabel: [\"<STR_LIT>\"],<EOL>            submenu: [<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                     type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                     type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [ \"<STR_LIT>\"],<EOL>                    accelerator:  \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: runtime.platform === \"<STR_LIT>\" ? \"<STR_LIT>\" : \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [ \"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>            ],<EOL>        },<EOL>        fileMac: {<EOL>            localizedLabel: [\"<STR_LIT>\"],<EOL>            submenu: [<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [ \"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                     localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: runtime.platform === \"<STR_LIT>\" ? \"<STR_LIT>\" : \"<STR_LIT>\",<EOL>                },<EOL>            ],<EOL>        },<EOL>         edit: {<EOL>            localizedLabel: [\"<STR_LIT>\"],<EOL>            visible: false,<EOL>            submenu: [<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                     role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                     localizedLabel: [\"<STR_LIT>\"],<EOL>                     accelerator: \"<STR_LIT>\",<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator:","gt":"\"<STR_LIT>\","}
{"input":"<s> function computeMenuTemplate(appVersion, credentials, runtime) {<EOL>    const menus = {<EOL>        mainMac: {<EOL>            <EOL>             submenu: [<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                    submenu: [],<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                     localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>            ],<EOL>        },<EOL>        file: {<EOL>            localizedLabel: [\"<STR_LIT>\"],<EOL>            submenu: [<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                     type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                     type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [ \"<STR_LIT>\"],<EOL>                    accelerator:  \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: runtime.platform === \"<STR_LIT>\" ? \"<STR_LIT>\" : \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [ \"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>            ],<EOL>        },<EOL>        fileMac: {<EOL>            localizedLabel: [\"<STR_LIT>\"],<EOL>            submenu: [<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [ \"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                     localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: runtime.platform === \"<STR_LIT>\" ? \"<STR_LIT>\" : \"<STR_LIT>\",<EOL>                },<EOL>            ],<EOL>        },<EOL>         edit: {<EOL>            localizedLabel: [\"<STR_LIT>\"],<EOL>            visible: false,<EOL>            submenu: [<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                     role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                     localizedLabel: [\"<STR_LIT>\"],<EOL>                     accelerator: \"<STR_LIT>\",<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator:  \"<STR_LIT>\",<EOL>                    role:","gt":"\"<STR_LIT>\","}
{"input":"<s> function computeMenuTemplate(appVersion, credentials, runtime) {<EOL>    const menus = {<EOL>        mainMac: {<EOL>            <EOL>             submenu: [<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                    submenu: [],<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                     localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>            ],<EOL>        },<EOL>        file: {<EOL>            localizedLabel: [\"<STR_LIT>\"],<EOL>            submenu: [<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                     type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                     type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [ \"<STR_LIT>\"],<EOL>                    accelerator:  \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: runtime.platform === \"<STR_LIT>\" ? \"<STR_LIT>\" : \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [ \"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>            ],<EOL>        },<EOL>        fileMac: {<EOL>            localizedLabel: [\"<STR_LIT>\"],<EOL>            submenu: [<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [ \"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                     localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: runtime.platform === \"<STR_LIT>\" ? \"<STR_LIT>\" : \"<STR_LIT>\",<EOL>                },<EOL>            ],<EOL>        },<EOL>         edit: {<EOL>            localizedLabel: [\"<STR_LIT>\"],<EOL>            visible: false,<EOL>            submenu: [<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                     role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                     localizedLabel: [\"<STR_LIT>\"],<EOL>                     accelerator: \"<STR_LIT>\",<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator:  \"<STR_LIT>\",<EOL>                    role:  \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>","gt":"role: \"<STR_LIT>\","}
{"input":"<s> function computeMenuTemplate(appVersion, credentials, runtime) {<EOL>    const menus = {<EOL>        mainMac: {<EOL>            <EOL>             submenu: [<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                    submenu: [],<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                     localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>            ],<EOL>        },<EOL>        file: {<EOL>            localizedLabel: [\"<STR_LIT>\"],<EOL>            submenu: [<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                     type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                     type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [ \"<STR_LIT>\"],<EOL>                    accelerator:  \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: runtime.platform === \"<STR_LIT>\" ? \"<STR_LIT>\" : \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [ \"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>            ],<EOL>        },<EOL>        fileMac: {<EOL>            localizedLabel: [\"<STR_LIT>\"],<EOL>            submenu: [<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [ \"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                     localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: runtime.platform === \"<STR_LIT>\" ? \"<STR_LIT>\" : \"<STR_LIT>\",<EOL>                },<EOL>            ],<EOL>        },<EOL>         edit: {<EOL>            localizedLabel: [\"<STR_LIT>\"],<EOL>            visible: false,<EOL>            submenu: [<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                     role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                     localizedLabel: [\"<STR_LIT>\"],<EOL>                     accelerator: \"<STR_LIT>\",<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator:  \"<STR_LIT>\",<EOL>                    role:  \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                     role: \"<STR_LIT>\",<EOL>                },<EOL>            ],<EOL>        },<EOL>","gt":"view: {"}
{"input":"<s> function computeMenuTemplate(appVersion, credentials, runtime) {<EOL>    const menus = {<EOL>        mainMac: {<EOL>            <EOL>             submenu: [<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                    submenu: [],<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                     localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>            ],<EOL>        },<EOL>        file: {<EOL>            localizedLabel: [\"<STR_LIT>\"],<EOL>            submenu: [<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                     type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                     type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [ \"<STR_LIT>\"],<EOL>                    accelerator:  \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: runtime.platform === \"<STR_LIT>\" ? \"<STR_LIT>\" : \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [ \"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>            ],<EOL>        },<EOL>        fileMac: {<EOL>            localizedLabel: [\"<STR_LIT>\"],<EOL>            submenu: [<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [ \"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                     localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: runtime.platform === \"<STR_LIT>\" ? \"<STR_LIT>\" : \"<STR_LIT>\",<EOL>                },<EOL>            ],<EOL>        },<EOL>         edit: {<EOL>            localizedLabel: [\"<STR_LIT>\"],<EOL>            visible: false,<EOL>            submenu: [<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                     role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                     localizedLabel: [\"<STR_LIT>\"],<EOL>                     accelerator: \"<STR_LIT>\",<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator:  \"<STR_LIT>\",<EOL>                    role:  \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                     role: \"<STR_LIT>\",<EOL>                },<EOL>            ],<EOL>        },<EOL>         view: {<EOL>            localizedLabel: [\"<STR_LIT>\"],<EOL>            submenu: [<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>            ],<EOL>        },<EOL>        accountLoggedOut: {<EOL>            localizedLabel: [\"<STR_LIT>\"],<EOL>            submenu: [<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    enabled: false,<EOL>                },<EOL>            ],<EOL>        },<EOL>        account: {<EOL>            localizedLabel: [\"<STR_LIT>\"],<EOL>            submenu: [<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                },<EOL>            ],<EOL>        },<EOL>        help: {<EOL>","gt":"localizedLabel: [\"<STR_LIT>\"],"}
{"input":"<s> function computeMenuTemplate(appVersion, credentials, runtime) {<EOL>    const menus = {<EOL>        mainMac: {<EOL>            <EOL>             submenu: [<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                    submenu: [],<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                     localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>            ],<EOL>        },<EOL>        file: {<EOL>            localizedLabel: [\"<STR_LIT>\"],<EOL>            submenu: [<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                     type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                     type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [ \"<STR_LIT>\"],<EOL>                    accelerator:  \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: runtime.platform === \"<STR_LIT>\" ? \"<STR_LIT>\" : \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [ \"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>            ],<EOL>        },<EOL>        fileMac: {<EOL>            localizedLabel: [\"<STR_LIT>\"],<EOL>            submenu: [<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [ \"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                     localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: runtime.platform === \"<STR_LIT>\" ? \"<STR_LIT>\" : \"<STR_LIT>\",<EOL>                },<EOL>            ],<EOL>        },<EOL>         edit: {<EOL>            localizedLabel: [\"<STR_LIT>\"],<EOL>            visible: false,<EOL>            submenu: [<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                     role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                     localizedLabel: [\"<STR_LIT>\"],<EOL>                     accelerator: \"<STR_LIT>\",<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator:  \"<STR_LIT>\",<EOL>                    role:  \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                     role: \"<STR_LIT>\",<EOL>                },<EOL>            ],<EOL>        },<EOL>         view: {<EOL>            localizedLabel: [\"<STR_LIT>\"],<EOL>            submenu: [<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>            ],<EOL>        },<EOL>        accountLoggedOut: {<EOL>            localizedLabel: [\"<STR_LIT>\"],<EOL>            submenu: [<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    enabled: false,<EOL>                },<EOL>            ],<EOL>        },<EOL>        account: {<EOL>            localizedLabel: [\"<STR_LIT>\"],<EOL>            submenu: [<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                },<EOL>            ],<EOL>        },<EOL>        help: {<EOL>             localizedLabel: [\"<STR_LIT>\"],<EOL>            role: \"<STR_LIT>\",<EOL>            submenu: [<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                },<EOL>                {<EOL>                    label:","gt":"appVersion}`<STR_LIT>,"}
{"input":"<s> function computeMenuTemplate(appVersion, credentials, runtime) {<EOL>    const menus = {<EOL>        mainMac: {<EOL>            <EOL>             submenu: [<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                    submenu: [],<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                     localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>            ],<EOL>        },<EOL>        file: {<EOL>            localizedLabel: [\"<STR_LIT>\"],<EOL>            submenu: [<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                     type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                     type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [ \"<STR_LIT>\"],<EOL>                    accelerator:  \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: runtime.platform === \"<STR_LIT>\" ? \"<STR_LIT>\" : \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [ \"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>            ],<EOL>        },<EOL>        fileMac: {<EOL>            localizedLabel: [\"<STR_LIT>\"],<EOL>            submenu: [<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [ \"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                     localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: runtime.platform === \"<STR_LIT>\" ? \"<STR_LIT>\" : \"<STR_LIT>\",<EOL>                },<EOL>            ],<EOL>        },<EOL>         edit: {<EOL>            localizedLabel: [\"<STR_LIT>\"],<EOL>            visible: false,<EOL>            submenu: [<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                     role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                     localizedLabel: [\"<STR_LIT>\"],<EOL>                     accelerator: \"<STR_LIT>\",<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator:  \"<STR_LIT>\",<EOL>                    role:  \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                     role: \"<STR_LIT>\",<EOL>                },<EOL>            ],<EOL>        },<EOL>         view: {<EOL>            localizedLabel: [\"<STR_LIT>\"],<EOL>            submenu: [<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>            ],<EOL>        },<EOL>        accountLoggedOut: {<EOL>            localizedLabel: [\"<STR_LIT>\"],<EOL>            submenu: [<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    enabled: false,<EOL>                },<EOL>            ],<EOL>        },<EOL>        account: {<EOL>            localizedLabel: [\"<STR_LIT>\"],<EOL>            submenu: [<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                },<EOL>            ],<EOL>        },<EOL>        help: {<EOL>             localizedLabel: [\"<STR_LIT>\"],<EOL>            role: \"<STR_LIT>\",<EOL>            submenu: [<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                },<EOL>                {<EOL>                    label: `<STR_LIT>`,<EOL>                    enabled: false,<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [","gt":"\"<STR_LIT>\"],"}
{"input":"<s> function computeMenuTemplate(appVersion, credentials, runtime) {<EOL>    const menus = {<EOL>        mainMac: {<EOL>            <EOL>             submenu: [<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                    submenu: [],<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                     localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>            ],<EOL>        },<EOL>        file: {<EOL>            localizedLabel: [\"<STR_LIT>\"],<EOL>            submenu: [<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                     type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                     type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [ \"<STR_LIT>\"],<EOL>                    accelerator:  \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: runtime.platform === \"<STR_LIT>\" ? \"<STR_LIT>\" : \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [ \"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>            ],<EOL>        },<EOL>        fileMac: {<EOL>            localizedLabel: [\"<STR_LIT>\"],<EOL>            submenu: [<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [ \"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                     localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: runtime.platform === \"<STR_LIT>\" ? \"<STR_LIT>\" : \"<STR_LIT>\",<EOL>                },<EOL>            ],<EOL>        },<EOL>         edit: {<EOL>            localizedLabel: [\"<STR_LIT>\"],<EOL>            visible: false,<EOL>            submenu: [<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                     role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                     localizedLabel: [\"<STR_LIT>\"],<EOL>                     accelerator: \"<STR_LIT>\",<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator:  \"<STR_LIT>\",<EOL>                    role:  \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                     role: \"<STR_LIT>\",<EOL>                },<EOL>            ],<EOL>        },<EOL>         view: {<EOL>            localizedLabel: [\"<STR_LIT>\"],<EOL>            submenu: [<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>            ],<EOL>        },<EOL>        accountLoggedOut: {<EOL>            localizedLabel: [\"<STR_LIT>\"],<EOL>            submenu: [<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    enabled: false,<EOL>                },<EOL>            ],<EOL>        },<EOL>        account: {<EOL>            localizedLabel: [\"<STR_LIT>\"],<EOL>            submenu: [<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                },<EOL>            ],<EOL>        },<EOL>        help: {<EOL>             localizedLabel: [\"<STR_LIT>\"],<EOL>            role: \"<STR_LIT>\",<EOL>            submenu: [<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                },<EOL>                {<EOL>                    label: `<STR_LIT>`,<EOL>                    enabled: false,<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [ \"<STR_LIT>\"],<EOL>                },<EOL>                {<EOL>","gt":"localizedLabel: [\"<STR_LIT>\"],"}
{"input":"<s> function computeMenuTemplate(appVersion, credentials, runtime) {<EOL>    const menus = {<EOL>        mainMac: {<EOL>            <EOL>             submenu: [<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                    submenu: [],<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                     localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>            ],<EOL>        },<EOL>        file: {<EOL>            localizedLabel: [\"<STR_LIT>\"],<EOL>            submenu: [<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                     type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                     type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [ \"<STR_LIT>\"],<EOL>                    accelerator:  \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: runtime.platform === \"<STR_LIT>\" ? \"<STR_LIT>\" : \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [ \"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>            ],<EOL>        },<EOL>        fileMac: {<EOL>            localizedLabel: [\"<STR_LIT>\"],<EOL>            submenu: [<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [ \"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                     localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: runtime.platform === \"<STR_LIT>\" ? \"<STR_LIT>\" : \"<STR_LIT>\",<EOL>                },<EOL>            ],<EOL>        },<EOL>         edit: {<EOL>            localizedLabel: [\"<STR_LIT>\"],<EOL>            visible: false,<EOL>            submenu: [<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                     role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                     localizedLabel: [\"<STR_LIT>\"],<EOL>                     accelerator: \"<STR_LIT>\",<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator:  \"<STR_LIT>\",<EOL>                    role:  \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                     role: \"<STR_LIT>\",<EOL>                },<EOL>            ],<EOL>        },<EOL>         view: {<EOL>            localizedLabel: [\"<STR_LIT>\"],<EOL>            submenu: [<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>            ],<EOL>        },<EOL>        accountLoggedOut: {<EOL>            localizedLabel: [\"<STR_LIT>\"],<EOL>            submenu: [<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    enabled: false,<EOL>                },<EOL>            ],<EOL>        },<EOL>        account: {<EOL>            localizedLabel: [\"<STR_LIT>\"],<EOL>            submenu: [<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                },<EOL>            ],<EOL>        },<EOL>        help: {<EOL>             localizedLabel: [\"<STR_LIT>\"],<EOL>            role: \"<STR_LIT>\",<EOL>            submenu: [<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                },<EOL>                {<EOL>                    label: `<STR_LIT>`,<EOL>                    enabled: false,<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [ \"<STR_LIT>\"],<EOL>                },<EOL>                {<EOL>                     localizedLabel: [\"<STR_LIT>\"],<EOL>                },<EOL>                {<EOL>","gt":"type: \"<STR_LIT>\","}
{"input":"<s> function computeMenuTemplate(appVersion, credentials, runtime) {<EOL>    const menus = {<EOL>        mainMac: {<EOL>            <EOL>             submenu: [<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                    submenu: [],<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                     localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>            ],<EOL>        },<EOL>        file: {<EOL>            localizedLabel: [\"<STR_LIT>\"],<EOL>            submenu: [<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                     type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                     type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [ \"<STR_LIT>\"],<EOL>                    accelerator:  \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: runtime.platform === \"<STR_LIT>\" ? \"<STR_LIT>\" : \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [ \"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>            ],<EOL>        },<EOL>        fileMac: {<EOL>            localizedLabel: [\"<STR_LIT>\"],<EOL>            submenu: [<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [ \"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                     localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: runtime.platform === \"<STR_LIT>\" ? \"<STR_LIT>\" : \"<STR_LIT>\",<EOL>                },<EOL>            ],<EOL>        },<EOL>         edit: {<EOL>            localizedLabel: [\"<STR_LIT>\"],<EOL>            visible: false,<EOL>            submenu: [<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                     role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                     localizedLabel: [\"<STR_LIT>\"],<EOL>                     accelerator: \"<STR_LIT>\",<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator:  \"<STR_LIT>\",<EOL>                    role:  \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                     role: \"<STR_LIT>\",<EOL>                },<EOL>            ],<EOL>        },<EOL>         view: {<EOL>            localizedLabel: [\"<STR_LIT>\"],<EOL>            submenu: [<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>            ],<EOL>        },<EOL>        accountLoggedOut: {<EOL>            localizedLabel: [\"<STR_LIT>\"],<EOL>            submenu: [<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    enabled: false,<EOL>                },<EOL>            ],<EOL>        },<EOL>        account: {<EOL>            localizedLabel: [\"<STR_LIT>\"],<EOL>            submenu: [<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                },<EOL>            ],<EOL>        },<EOL>        help: {<EOL>             localizedLabel: [\"<STR_LIT>\"],<EOL>            role: \"<STR_LIT>\",<EOL>            submenu: [<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                },<EOL>                {<EOL>                    label: `<STR_LIT>`,<EOL>                    enabled: false,<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [ \"<STR_LIT>\"],<EOL>                },<EOL>                {<EOL>                     localizedLabel: [\"<STR_LIT>\"],<EOL>                },<EOL>                {<EOL>                     type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                },<EOL>            ],<EOL>        },<EOL>    };<EOL>    const","gt":"template = [];"}
{"input":"<s> <EOL><EOL>export async function promisedModal(store, payload) {<EOL>    const modalAction = actions.openModal(payload);<EOL>    const { id } = modalAction.payload;<EOL>","gt":"const p = new Promise((resolve) => {"}
{"input":"<s> function err(e, action) {<EOL>    if (isCancelled(e)) {<EOL>        console.","gt":"warn(`<STR_LIT>`);"}
{"input":"<s> async function setup(store, db) {<EOL>    const ctx = new Context(store, db);<EOL>","gt":"logger.info(\"<STR_LIT>\");"}
{"input":"<s> export default function (watcher) {<EOL>    watcher.on(actions.commandMain, async (store, action) => {<EOL>        const { tab } = store.getState().session.navigation;<EOL>        const sp = Space.fromStore(store, tab);<EOL>        if (","gt":"sp.prefix === \"<STR_LIT>\") {"}
{"input":"<s> export default function (watcher) {<EOL>    watcher.on(actions.commandMain, async (store, action) => {<EOL>        const { tab } = store.getState().session.navigation;<EOL>        const sp = Space.fromStore(store, tab);<EOL>        if ( sp.prefix === \"<STR_LIT>\") {<EOL>","gt":"const game = sp.game();"}
{"input":"<s> export default function (watcher) {<EOL>    watcher.on(actions.commandMain, async (store, action) => {<EOL>        const { tab } = store.getState().session.navigation;<EOL>        const sp = Space.fromStore(store, tab);<EOL>        if ( sp.prefix === \"<STR_LIT>\") {<EOL>             const game = sp.game();<EOL>            if (game) {<EOL>                <EOL>                <EOL>                <EOL>                store.dispatch(actions.queueGame({ game }));<EOL>            }<EOL>        }<EOL>    });<EOL>    watcher.on(actions.commandMain, async (store, action) => {<EOL>        const modals = store.getState().modals;<EOL>        const modal =","gt":"modals[<NUM_LIT>];"}
{"input":"<s> export default function (watcher) {<EOL>    watcher.on(actions.commandMain, async (store, action) => {<EOL>        const { tab } = store.getState().session.navigation;<EOL>        const sp = Space.fromStore(store, tab);<EOL>        if ( sp.prefix === \"<STR_LIT>\") {<EOL>             const game = sp.game();<EOL>            if (game) {<EOL>                <EOL>                <EOL>                <EOL>                store.dispatch(actions.queueGame({ game }));<EOL>            }<EOL>        }<EOL>    });<EOL>    watcher.on(actions.commandMain, async (store, action) => {<EOL>        const modals = store.getState().modals;<EOL>        const modal =  modals[<NUM_LIT>];<EOL>        if (modal) {<EOL>            return;<EOL>        }<EOL>        const page = store.getState().session.navigation.page;<EOL>        const picking = store.getState().session.","gt":"login.picking;"}
{"input":"<s> function withWebContents(store, tab, cb) {<EOL>    const sp = Space.fromStore(store, tab);<EOL>    const { webContentsId } = sp.web();<EOL>    if (!webContentsId) {<EOL>","gt":"return;"}
{"input":"<s> function withWebContents(store, tab, cb) {<EOL>    const sp = Space.fromStore(store, tab);<EOL>    const { webContentsId } = sp.web();<EOL>    if (!webContentsId) {<EOL>         return;<EOL>    }<EOL>    const wc = webContents.fromId(webContentsId);<EOL>    if (!wc || wc.isDestroyed()) {<EOL>","gt":"return;"}
{"input":"<s> <EOL>async function cp(opts) {<EOL>    const { src, dest } = opts;<EOL>    const args =","gt":"[src, dest];"}
{"input":"<s> function getArchiveName(name) {<EOL>    let formula = formulas[name];<EOL>    if (formula.format === \"<STR_LIT>\") {<EOL>","gt":"return `<STR_LIT>`;"}
{"input":"<s> <EOL>export function NOOP_FALSE() {<EOL>    return","gt":"false;"}
{"input":"<s> <EOL>export function getEventCharCode(ev) {<EOL>    const keyCode = ev.keyCode;<EOL>    let charCode = ev.charCode;<EOL>    if (","gt":"charCode === <NUM_LIT> && keyCode === <NUM_LIT>) {"}
{"input":"<s> export function onAbort(handler, capture = false) {<EOL>    return createEventHandler(EventSourceAbort.","gt":"eventSource, handler, capture);"}
{"input":"<s> export function onDragEnd(handler, capture = false) {<EOL>    return createEventHandler(EventSourceDragEnd.","gt":"eventSource, handler, capture);"}
{"input":"<s> export function onInput(handler, capture = false) {<EOL>    return createEventHandler(EventSourceInput.","gt":"eventSource, handler, capture);"}
{"input":"<s> export function onSubmit(handler, capture = false) {<EOL>    return","gt":"createEventHandler(EventSourceSubmit.eventSource, handler, capture);"}
{"input":"<s> export function dispatchMoveEventToRecognizers(event) {<EOL>    if (arena.winner === null) {<EOL>        for (let i = <NUM_LIT>; i < arena.recognizers.length; ++i) {<EOL>            const recognizer = arena.recognizers[i];<EOL>            if (recognizer !==","gt":"null) {"}
{"input":"<s> export function dispatchMoveEventToRecognizers(event) {<EOL>    if (arena.winner === null) {<EOL>        for (let i = <NUM_LIT>; i < arena.recognizers.length; ++i) {<EOL>            const recognizer = arena.recognizers[i];<EOL>            if (recognizer !==  null) {<EOL>                recognizer.pointerMoved(event);<EOL>            }<EOL>        }<EOL>    }<EOL>","gt":"else {"}
{"input":"<s> export function pointerMapGet(map, id) {<EOL>    for (let i = <NUM_LIT>; i < map.length; ++i) {<EOL>        const item = map[i];<EOL>        if (item.id ===","gt":"id) {"}
{"input":"<s> export function pointerMapListPush(map, id, value) {<EOL>    for (let i = <NUM_LIT>; i < map.length; ++i) {<EOL>        const item = map[i];<EOL>        if (item.id === id) {<EOL>            item.","gt":"value.push(value);"}
{"input":"<s> export function pointerMapListPush(map, id, value) {<EOL>    for (let i = <NUM_LIT>; i < map.length; ++i) {<EOL>        const item = map[i];<EOL>        if (item.id === id) {<EOL>            item. value.push(value);<EOL>            return;<EOL>        }<EOL>    }<EOL>    map.push({<EOL>","gt":"id,"}
{"input":"<s> export function createVelocityTracker() {<EOL>    return {<EOL>        samples: new Array(HISTORY_SIZE).fill(","gt":"null),"}
{"input":"<s> <EOL>export function circle(className) {<EOL>    return new VNode(","gt":"VNodeFlags.Element | VNodeFlags.SvgElement, \"<STR_LIT>\", null, className === undefined ? null : className, null);"}
{"input":"<s> export function colgroup(className) {<EOL>    return new VNode(VNodeFlags.Element, \"<STR_LIT>\", null, className === undefined ? null : className,","gt":"null);"}
{"input":"<s> export function fepointlight(className) {<EOL>","gt":"return new VNode(VNodeFlags.Element | VNodeFlags.SvgElement, \"<STR_LIT>\", null, className === undefined ? null : className, null);"}
{"input":"<s> export function font(className) {<EOL>    return new VNode(VNodeFlags.Element, \"<STR_LIT>\", null, className ===","gt":"undefined ? null : className, null);"}
{"input":"<s> export function hr(className) {<EOL>    return new VNode(VNodeFlags.Element |","gt":"VNodeFlags.VoidElement, \"<STR_LIT>\", null, className === undefined ? null : className, null);"}
{"input":"<s> export function inputHidden(className) {<EOL>    return","gt":"new VNode(VNodeFlags.Element | VNodeFlags.InputElement | VNodeFlags.VoidElement, \"<STR_LIT>\", null, className === undefined ? null : className, null);"}
{"input":"<s> export function inputWeek(className) {<EOL>    return new VNode(VNodeFlags.Element | VNodeFlags.InputElement | VNodeFlags.VoidElement,","gt":"\"<STR_LIT>\", null, className === undefined ? null : className, null);"}
{"input":"<s> export function ins(className) {<EOL>    return new VNode(VNodeFlags.","gt":"Element, \"<STR_LIT>\", null, className === undefined ? null : className, null);"}
{"input":"<s> export function kbd(className) {<EOL>    return new VNode(VNodeFlags.Element, \"<STR_LIT>\", null, className === undefined ?","gt":"null : className, null);"}
{"input":"<s> export function noscript(className) {<EOL>    return new VNode(VNodeFlags.","gt":"Element, \"<STR_LIT>\", null, className === undefined ? null : className, null);"}
{"input":"<s> export function option(className) {<EOL>","gt":"return new VNode(VNodeFlags.Element, \"<STR_LIT>\", null, className === undefined ? null : className, null);"}
{"input":"<s> export function stop(className) {<EOL>    return new VNode(","gt":"VNodeFlags.Element | VNodeFlags.SvgElement, \"<STR_LIT>\", null, className === undefined ? null : className, null);"}
{"input":"<s> export function table(className) {<EOL>    return new VNode(","gt":"VNodeFlags.Element, \"<STR_LIT>\", null, className === undefined ? null : className, null);"}
{"input":"<s> export function td(className) {<EOL>    return new VNode(VNodeFlags.","gt":"Element, \"<STR_LIT>\", null, className === undefined ? null : className, null);"}
{"input":"<s> export function use(className) {<EOL>","gt":"return new VNode(VNodeFlags.Element | VNodeFlags.SvgElement, \"<STR_LIT>\", null, className === undefined ? null : className, null);"}
{"input":"<s> export function vec2Negate(v) {<EOL>    return vec2(-v.x, -v.","gt":"y);"}
{"input":"<s> <EOL>export function addAnimation(animation) {<EOL>","gt":"_animations.add(animation);"}
{"input":"<s> <EOL>export function clock() {<EOL>","gt":"return _clock;"}
{"input":"<s> function createFrameTasksGroup() {<EOL>    return {<EOL>        flags:","gt":"<NUM_LIT>,"}
{"input":"<s> function _findVNode(match, vnode) {<EOL>    if (match(vnode) === true) {<EOL>        return vnode;<EOL>    }<EOL>    if ((vnode._flags & (VNodeFlags.Element | VNodeFlags.Text)) !== <NUM_LIT>) {<EOL>        if ((vnode.","gt":"_flags & VNodeFlags.Element) !== <NUM_LIT>) {"}
{"input":"<s> function _findVNode(match, vnode) {<EOL>    if (match(vnode) === true) {<EOL>        return vnode;<EOL>    }<EOL>    if ((vnode._flags & (VNodeFlags.Element | VNodeFlags.Text)) !== <NUM_LIT>) {<EOL>        if ((vnode. _flags & VNodeFlags.Element) !== <NUM_LIT>) {<EOL>            if (vnode._children !== null) {<EOL>                if ((vnode._flags & VNodeFlags.ChildrenArray) !==","gt":"<NUM_LIT>) {"}
{"input":"<s> <EOL>export function setDevModeFlags(flags) {<EOL>","gt":"if (DEV) {"}
{"input":"<s> <EOL>function setHTMLInputValue(input, value) {<EOL>    if (typeof value === \"<STR_LIT>\") {<EOL>        input.","gt":"value = value;"}
{"input":"<s> <EOL>export function createBlueprint(node, context = {}, blueprint) {<EOL>","gt":"throw new Error(\"<STR_LIT>\");"}
{"input":"<s> <EOL>export function a(className) {<EOL>    return new VNode(VNodeFlags.Element, \"<STR_LIT>\", null,","gt":"className === undefined ? null : className, null, \"<STR_LIT>\");"}
{"input":"<s> export function b(className) {<EOL>    return new","gt":"VNode(VNodeFlags.Element, \"<STR_LIT>\", null, className === undefined ? null : className, null, \"<STR_LIT>\");"}
{"input":"<s> export function dd(className) {<EOL>    return new VNode(VNodeFlags.Element, \"<STR_LIT>\", null, className === undefined ?","gt":"null : className, null, \"<STR_LIT>\");"}
{"input":"<s> export function h3(className) {<EOL>    return new VNode(VNodeFlags.Element, \"<STR_LIT>\", null, className === undefined ? null : className,","gt":"null, \"<STR_LIT>\");"}
{"input":"<s> export function inputPassword(className) {<EOL>    return new","gt":"VNode(VNodeFlags.Element | VNodeFlags.InputElement | VNodeFlags.VoidElement, `<STR_LIT>`, null, className === undefined ? null : className, null, null);"}
{"input":"<s> export function inputRadio(className) {<EOL>    return new VNode(VNodeFlags.Element | VNodeFlags.InputElement | VNodeFlags.VoidElement, `<STR_LIT>`, null, className === undefined ? null : className,","gt":"null, null);"}
{"input":"<s> export function sub(className) {<EOL>    return new VNode(VNodeFlags.Element, \"<STR_LIT>\", null, className === undefined ? null : className,","gt":"null, \"<STR_LIT>\");"}
{"input":"<s> <EOL>export function getElementClassNameFromVNode(node) {<EOL>    return node.","gt":"_className;"}
{"input":"<s> <EOL>export function isComponentVNode(node) {<EOL>    return (node._flags &","gt":"VNodeFlags.Component) !== <NUM_LIT>;"}
{"input":"<s> export function discard(className) {<EOL>    return new VNode(VNodeFlags.Element | VNodeFlags.SvgElement, \"<STR_LIT>\", null, className === undefined ?","gt":"null : className, null, \"<STR_LIT>\");"}
{"input":"<s> export function feDiffuseLighting(className) {<EOL>    return new VNode(VNodeFlags.Element | VNodeFlags.SvgElement, \"<STR_LIT>\",","gt":"null, className === undefined ? null : className, null, \"<STR_LIT>\");"}
{"input":"<s> export function feMorphology(className) {<EOL>    return new VNode(","gt":"VNodeFlags.Element | VNodeFlags.SvgElement, \"<STR_LIT>\", null, className === undefined ? null : className, null, \"<STR_LIT>\");"}
{"input":"<s> export function mask(className) {<EOL>","gt":"return new VNode(VNodeFlags.Element | VNodeFlags.SvgElement, \"<STR_LIT>\", null, className === undefined ? null : className, null, \"<STR_LIT>\");"}
{"input":"<s> export function mesh(className) {<EOL>    return new VNode(VNodeFlags.Element |","gt":"VNodeFlags.SvgElement, \"<STR_LIT>\", null, className === undefined ? null : className, null, \"<STR_LIT>\");"}
{"input":"<s> export function svg(className) {<EOL>    return new VNode(VNodeFlags.Element | VNodeFlags.","gt":"SvgElement, \"<STR_LIT>\", null, className === undefined ? null : className, null, \"<STR_LIT>\");"}
{"input":"<s> export function title(className) {<EOL>    return new VNode(VNodeFlags.Element | VNodeFlags.SvgElement, \"<STR_LIT>\", null, className === undefined ? null : className,","gt":"null, \"<STR_LIT>\");"}
{"input":"<s> export function circle(className) {<EOL>    return new VNode(VNodeFlags.Element | VNodeFlags.SvgElement, \"<STR_LIT>\", null, className === undefined ?","gt":"null : className, null, \"<STR_LIT>\");"}
{"input":"<s> export function colorProfile(className) {<EOL>    return new VNode(VNodeFlags.Element | VNodeFlags.SvgElement, \"<STR_LIT>\", null, className === undefined ? null :","gt":"className, null);"}
{"input":"<s> export function currentFrameRead(task) {<EOL>    if ((_flags & SchedulerFlags.CurrentFrameReady) !== <NUM_LIT>) {<EOL>        addFrameTaskRead(_currentFrame,","gt":"task);"}
{"input":"<s> export function nextFrameAfter(task) {<EOL>","gt":"requestNextFrame();"}
{"input":"<s> <EOL>export function requestNextFrame() {<EOL>    if ((_flags & SchedulerFlags.","gt":"NextFramePending) === <NUM_LIT>) {"}
{"input":"<s> export function hasPrevSibling(wrapper, predicate) {<EOL>    const parent = wrapper.parent;<EOL>    if (parent !== null && (parent.vnode._flags & VNodeFlags.ChildrenArray) !== <NUM_LIT>) {<EOL>        const children = parent.vnode._children;<EOL>        let","gt":"prev = null;"}
{"input":"<s> export function hasPrevSibling(wrapper, predicate) {<EOL>    const parent = wrapper.parent;<EOL>    if (parent !== null && (parent.vnode._flags & VNodeFlags.ChildrenArray) !== <NUM_LIT>) {<EOL>        const children = parent.vnode._children;<EOL>        let  prev = null;<EOL>        for (let i = <NUM_LIT>; i < children.length; i++) {<EOL>            const c = children[i];<EOL>            if (wrapper.vnode === c) {<EOL>                return (prev !== null && predicate(new VNodeWrapper(prev, parent, wrapper.context)) === true);<EOL>            }<EOL>            prev =","gt":"c;"}
{"input":"<s> export function clippath(className) {<EOL>    return new VNode(VNodeFlags.Element | VNodeFlags.SvgElement, \"<STR_LIT>\", null,","gt":"className === undefined ? null : className, null);"}
{"input":"<s> export function ellipse(className) {<EOL>    return new VNode(VNodeFlags.Element |","gt":"VNodeFlags.SvgElement, \"<STR_LIT>\", null, className === undefined ? null : className, null);"}
{"input":"<s> export function embed(className) {<EOL>    return new VNode(","gt":"VNodeFlags.Element | VNodeFlags.VoidElement, \"<STR_LIT>\", null, className === undefined ? null : className, null);"}
{"input":"<s> export function fefunca(className) {<EOL>    return new VNode(VNodeFlags.","gt":"Element | VNodeFlags.SvgElement, \"<STR_LIT>\", null, className === undefined ? null : className, null);"}
{"input":"<s> export function h5(className) {<EOL>    return new VNode(VNodeFlags.Element, \"<STR_LIT>\",","gt":"null, className === undefined ? null : className, null);"}
{"input":"<s> export function head(className) {<EOL>    return new VNode(VNodeFlags.Element, \"<STR_LIT>\", null,","gt":"className === undefined ? null : className, null);"}
{"input":"<s> export function inputNumber(className) {<EOL>    return","gt":"new VNode(VNodeFlags.Element | VNodeFlags.InputElement | VNodeFlags.VoidElement, \"<STR_LIT>\", null, className === undefined ? null : className, null);"}
{"input":"<s> export function inputSubmit(className) {<EOL>    return new VNode(VNodeFlags.Element | VNodeFlags.InputElement | VNodeFlags.VoidElement, \"<STR_LIT>\", null, className === undefined ? null :","gt":"className, null);"}
{"input":"<s> export function label(className) {<EOL>    return new VNode(VNodeFlags.Element, \"<STR_LIT>\", null,","gt":"className === undefined ? null : className, null);"}
{"input":"<s> export function isContractParameterHash(type) {<EOL>    return","gt":"isContractParameterType(type.inputType);"}
{"input":"<s> export function operationsToString(ops) {<EOL>    return ops.map(operationToString).join(","gt":"\"<STR_LIT>\");"}
{"input":"<s> function pushResult(stack) {<EOL>","gt":"stack.push(\"<STR_LIT>\");"}
{"input":"<s> function createAnnouncerDiv() {<EOL>    if (announcerDiv) {<EOL>        return announcerDiv;<EOL>    }<EOL>    announcerDiv = document.createElement('<STR_LIT>');<EOL>","gt":"announcerDiv.id = announcerId;"}
{"input":"<s> function createAnnouncerDiv() {<EOL>    if (announcerDiv) {<EOL>        return announcerDiv;<EOL>    }<EOL>    announcerDiv = document.createElement('<STR_LIT>');<EOL>     announcerDiv.id = announcerId;<EOL>    announcerDiv.setAttribute('<STR_LIT>', '<STR_LIT>');<EOL>    let style = announcerDiv.style;<EOL>    style.position = '<STR_LIT>';<EOL>    style.left = '<STR_LIT>';<EOL>    style.top = '<STR_LIT>';<EOL>    style.","gt":"width = '<STR_LIT>';"}
{"input":"<s> function compareStrings(a, b) {<EOL>    return (a < b ? -<NUM_LIT> : (a >","gt":"b ? <NUM_LIT> : <NUM_LIT>));"}
{"input":"<s> <EOL><EOL>function escapeRegExp(value) {<EOL>    return value.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g,","gt":"\"<STR_LIT>\");"}
{"input":"<s> <EOL>export function removeChildren(node) {<EOL>    while (node.","gt":"lastChild) {"}
{"input":"<s> <EOL>export function ConsoleOutputDisableExpressionTemplate() {<EOL>","gt":"return `<STR_LIT>`"}
{"input":"<s> <EOL>export function DebugProtectionFunctionCallTemplate() {<EOL>","gt":"return `<STR_LIT>`"}
{"input":"<s> <EOL>export function Rc4Template() {<EOL>","gt":"return `<STR_LIT>`"}
{"input":"<s> function fix(_settings, document) {<EOL>    return","gt":"document;"}
{"input":"<s> export function fakeTypeDefSource() {<EOL>    return {<EOL>        fetch: () => delay(<NUM_LIT>).","gt":"then(() => typedefs),"}
{"input":"<s> export default function (indent) {<EOL>    return Array(indent * <NUM_LIT> + <NUM_LIT>).","gt":"join(\"<STR_LIT>\");"}
{"input":"<s> export function failingItName() {<EOL>    return window.createTextEditorDecorationType({<EOL>        overviewRulerColor: '<STR_LIT>',<EOL>        overviewRulerLane: OverviewRulerLane.Left,<EOL>        light: {<EOL>            before: {<EOL>                color:","gt":"'<STR_LIT>',"}
{"input":"<s> export function failingItName() {<EOL>    return window.createTextEditorDecorationType({<EOL>        overviewRulerColor: '<STR_LIT>',<EOL>        overviewRulerLane: OverviewRulerLane.Left,<EOL>        light: {<EOL>            before: {<EOL>                color:  '<STR_LIT>',<EOL>                contentText: '<STR_LIT>',<EOL>            },<EOL>        },<EOL>","gt":"dark: {"}
{"input":"<s> export function failingItName() {<EOL>    return window.createTextEditorDecorationType({<EOL>        overviewRulerColor: '<STR_LIT>',<EOL>        overviewRulerLane: OverviewRulerLane.Left,<EOL>        light: {<EOL>            before: {<EOL>                color:  '<STR_LIT>',<EOL>                contentText: '<STR_LIT>',<EOL>            },<EOL>        },<EOL>         dark: {<EOL>            before: {<EOL>                color: '<STR_LIT>',<EOL>","gt":"contentText: '<STR_LIT>',"}
{"input":"<s> export function parseTest(filePath) {<EOL>    const","gt":"parser = getParser(filePath);"}
{"input":"<s> <EOL>export function search(node, key) {<EOL>    if (!node)<EOL>        return null;<EOL>","gt":"if (node.key === key)"}
{"input":"<s> function isInHeap(index, heapSize) {<EOL>","gt":"return index < heapSize;"}
{"input":"<s> <EOL>export function mergeSort(input, start = <NUM_LIT>, end = input.length) {<EOL>    if (end - start <= <NUM_LIT>)<EOL>","gt":"return [];"}
{"input":"<s> function isSPMProject() {<EOL>    return fs.","gt":"existsSync(swiftPackageManifestPath);"}
{"input":"<s> <EOL>export function extractThreadInfo(data) {<EOL>    return {<EOL>        id: parseInt(data.id, <NUM_LIT>),<EOL>        targetId:","gt":"data['<STR_LIT>'],"}
{"input":"<s> export function trace(prefix, msg) {<EOL>    if (isTracingOn) {<EOL>        if (msg) {<EOL>            connection.console.","gt":"log(prefix + msg);"}
{"input":"<s> <EOL>export function demangle(...demangledNames) {<EOL>    const names =","gt":"JSON.stringify(demangledNames.join(\"<STR_LIT>\"));"}
{"input":"<s> function jsonify(s) {<EOL>    return","gt":"s"}
{"input":"<s> function swLog(eventName, event) {<EOL>    console.log('<STR_LIT>' + eventName);<EOL>","gt":"if (event) {"}
{"input":"<s> export function cancelEditing() {<EOL>    return {<EOL>        type:","gt":"\"<STR_LIT>\","}
{"input":"<s> export function resetHiddenQuotes() {<EOL>","gt":"return {"}
{"input":"<s> function showUpdateSuccessNotification() {<EOL>    if (configManager.current.notifyWhenEntryUpdated) {<EOL>        const button = {<EOL>            label: $STR(\"<STR_LIT>\"),<EOL>","gt":"action: \"<STR_LIT>\""}
{"input":"<s> function showUpdateSuccessNotification() {<EOL>    if (configManager.current.notifyWhenEntryUpdated) {<EOL>        const button = {<EOL>            label: $STR(\"<STR_LIT>\"),<EOL>             action: \"<STR_LIT>\"<EOL>        };<EOL>        const messages = [$STR(\"<STR_LIT>\"),<EOL>            $STR(\"<STR_LIT>\"),<EOL>            $STR(\"<STR_LIT>\"),<EOL>            $STR(\"<STR_LIT>\"),<EOL>            $STR(","gt":"\"<STR_LIT>\")];"}
{"input":"<s> function matchFinder(uri) {<EOL>    myPort.postMessage({ findMatches: {","gt":"uri } });"}
{"input":"<s> export function activateCodeActions() {<EOL>    return [<EOL>        vscode.commands.registerCommand('<STR_LIT>', (msg) => annotateFunction(msg)),<EOL>","gt":"vscode.commands.registerCommand('<STR_LIT>', (msg) => replaceSuggestedVariable(msg)),"}
{"input":"<s> <EOL>function getFunctionComments(lines) {<EOL>    try {<EOL>        let documentation = '<STR_LIT>';<EOL>        if (config['<STR_LIT>'] !== true) {<EOL>            return documentation;<EOL>        }<EOL>        let","gt":"inComment = false;"}
{"input":"<s> <EOL>function getFunctionComments(lines) {<EOL>    try {<EOL>        let documentation = '<STR_LIT>';<EOL>        if (config['<STR_LIT>'] !== true) {<EOL>            return documentation;<EOL>        }<EOL>        let  inComment = false;<EOL>        for (let j = lines.length - <NUM_LIT>; j >= <NUM_LIT>; j--) {<EOL>            if (lines[j].trim() === '<STR_LIT>' && !inComment) {<EOL>","gt":"break;"}
{"input":"<s> <EOL>function getFunctionComments(lines) {<EOL>    try {<EOL>        let documentation = '<STR_LIT>';<EOL>        if (config['<STR_LIT>'] !== true) {<EOL>            return documentation;<EOL>        }<EOL>        let  inComment = false;<EOL>        for (let j = lines.length - <NUM_LIT>; j >= <NUM_LIT>; j--) {<EOL>            if (lines[j].trim() === '<STR_LIT>' && !inComment) {<EOL>                 break;<EOL>            }<EOL>            if (lines[j].includes('<STR_LIT>')) {<EOL>","gt":"inComment = true;"}
{"input":"<s> <EOL>function getFunctionComments(lines) {<EOL>    try {<EOL>        let documentation = '<STR_LIT>';<EOL>        if (config['<STR_LIT>'] !== true) {<EOL>            return documentation;<EOL>        }<EOL>        let  inComment = false;<EOL>        for (let j = lines.length - <NUM_LIT>; j >= <NUM_LIT>; j--) {<EOL>            if (lines[j].trim() === '<STR_LIT>' && !inComment) {<EOL>                 break;<EOL>            }<EOL>            if (lines[j].includes('<STR_LIT>')) {<EOL>                 inComment = true;<EOL>            }<EOL>            if (inComment) {<EOL>                documentation = lines[j].trim() + '<STR_LIT>' + documentation;<EOL>            }<EOL>            if (lines[j].includes('<STR_LIT>')) {<EOL>                inComment = false;<EOL>            }<EOL>        }<EOL>        if (documentation !== '<STR_LIT>') {<EOL>            documentation =","gt":"'<STR_LIT>' + documentation;"}
{"input":"<s> function inject(root, title, level) {<EOL>    if (level === <NUM_LIT>) {<EOL>        root.title = title;<EOL>    }<EOL>    else {<EOL>        if (level === <NUM_LIT> ||","gt":"root.children.length === <NUM_LIT>) {"}
{"input":"<s> function inject(root, title, level) {<EOL>    if (level === <NUM_LIT>) {<EOL>        root.title = title;<EOL>    }<EOL>    else {<EOL>        if (level === <NUM_LIT> ||  root.children.length === <NUM_LIT>) {<EOL>            root.children.push({<EOL>                title: null,<EOL>                children: [],<EOL>            });<EOL>        }<EOL>        const lastChild = root.children[","gt":"root.children.length - <NUM_LIT>];"}
{"input":"<s> <EOL>export function mountComponent(descriptor, element, props, sync) {<EOL>    const c = descriptor.mountComponent(element, undefined, props);<EOL>    if (sync) {<EOL>        startMounting();<EOL>        componentAttached(c);<EOL>","gt":"updateComponent(c);"}
{"input":"<s> <EOL>export function mountComponent(descriptor, element, props, sync) {<EOL>    const c = descriptor.mountComponent(element, undefined, props);<EOL>    if (sync) {<EOL>        startMounting();<EOL>        componentAttached(c);<EOL>         updateComponent(c);<EOL>        finishMounting();<EOL>    }<EOL>    else {<EOL>","gt":"nextFrame().write(function () {"}
{"input":"<s> <EOL>export function mountComponent(descriptor, element, props, sync) {<EOL>    const c = descriptor.mountComponent(element, undefined, props);<EOL>    if (sync) {<EOL>        startMounting();<EOL>        componentAttached(c);<EOL>         updateComponent(c);<EOL>        finishMounting();<EOL>    }<EOL>    else {<EOL>         nextFrame().write(function () {<EOL>            startMounting();<EOL>            componentAttached(c);<EOL>            updateComponent(c);<EOL>","gt":"finishMounting();"}
{"input":"<s> <EOL>export function matchesWithAncestors(element, selector, sentinel = null) {<EOL>    while (element !== sentinel) {<EOL>        if (element.matches(selector)) {<EOL>            return","gt":"element;"}
{"input":"<s> <EOL>export function clock() {<EOL>","gt":"return scheduler.clock;"}
{"input":"<s> function vNodeRemoveAllChildren(parent, nodes) {<EOL>    parent.ref.textContent = \"<STR_LIT>\";<EOL>    for (let","gt":"i = <NUM_LIT>; i < nodes.length; i++) {"}
{"input":"<s> export function Put(value) {<EOL>    return () => {","gt":"return; };"}
{"input":"<s> <EOL>export function BodyProp(name) {<EOL>    return () => {","gt":"return; };"}
{"input":"<s> <EOL>export function Security(name, scopes) {<EOL>","gt":"return () => { return; };"}
{"input":"<s> <EOL>function getStateLookingForSetStateCalls(classDeclaration, typeChecker) {<EOL>    const typeNodes = [];<EOL>    for (const member of classDeclaration.members) {<EOL>        if (member && ts.isMethodDeclaration(member) && member.body) {<EOL>            lookForSetState(member.body);<EOL>        }<EOL>    }<EOL>    return typeNodes;<EOL>    function lookForSetState(node) {<EOL>        ts.forEachChild(node,","gt":"lookForSetState);"}
{"input":"<s> <EOL>function getStateLookingForSetStateCalls(classDeclaration, typeChecker) {<EOL>    const typeNodes = [];<EOL>    for (const member of classDeclaration.members) {<EOL>        if (member && ts.isMethodDeclaration(member) && member.body) {<EOL>            lookForSetState(member.body);<EOL>        }<EOL>    }<EOL>    return typeNodes;<EOL>    function lookForSetState(node) {<EOL>        ts.forEachChild(node,  lookForSetState);<EOL>        if (ts.isExpressionStatement(node) &&<EOL>            ts.isCallExpression(node.expression) &&<EOL>            node.expression.expression.getText().match(/setState/)) {<EOL>            const type = typeChecker.getTypeAtLocation(","gt":"node.expression.arguments[<NUM_LIT>]);"}
{"input":"<s> export function SessionStorage(key) {<EOL>    return","gt":"WebStorage(sessionStorage, key);"}
{"input":"<s> export function getSize(filePath) {<EOL>    return","gt":"fs.stat(filePath).then((stats) => stats.size);"}
{"input":"<s> export function getDockerodeImageDataMock() {<EOL>","gt":"return {};"}
{"input":"<s> export function getSettingsMock() {<EOL>    return {<EOL>        locale: LOCALE.DE_DE,<EOL>        connectionSettings: {<EOL>            configType: CONFIG_TYPE.","gt":"SOCKET,"}
{"input":"<s> export function getSettingsMock() {<EOL>    return {<EOL>        locale: LOCALE.DE_DE,<EOL>        connectionSettings: {<EOL>            configType: CONFIG_TYPE. SOCKET,<EOL>            host: '<STR_LIT>',<EOL>            port: <NUM_LIT>,<EOL>            protocol: PROTOCOL.HTTP,<EOL>            caFile: '<STR_LIT>',<EOL>            certFile: '<STR_LIT>',<EOL>","gt":"keyFile: '<STR_LIT>',"}
{"input":"<s> export function main() {<EOL>    describe('<STR_LIT>', () => {<EOL>        beforeEach(() => {<EOL>            TestBed.","gt":"configureTestingModule({"}
{"input":"<s> export function main() {<EOL>    describe('<STR_LIT>', () => {<EOL>        beforeEach(() => {<EOL>            TestBed. configureTestingModule({<EOL>                imports: [FormsModule],<EOL>                declarations: [HomeComponent],<EOL>","gt":"providers: ["}
{"input":"<s> export function main() {<EOL>    describe('<STR_LIT>', () => {<EOL>        beforeEach(() => {<EOL>            TestBed. configureTestingModule({<EOL>                imports: [FormsModule],<EOL>                declarations: [HomeComponent],<EOL>                 providers: [<EOL>                    { provide: NameListService, useValue: new MockNameListService() }<EOL>                ]<EOL>            });<EOL>        });<EOL>        it('<STR_LIT>', async(() => {<EOL>            TestBed<EOL>                .compileComponents()<EOL>                .","gt":"then(() => {"}
{"input":"<s> export function main() {<EOL>    describe('<STR_LIT>', () => {<EOL>        beforeEach(() => {<EOL>            TestBed. configureTestingModule({<EOL>                imports: [FormsModule],<EOL>                declarations: [HomeComponent],<EOL>                 providers: [<EOL>                    { provide: NameListService, useValue: new MockNameListService() }<EOL>                ]<EOL>            });<EOL>        });<EOL>        it('<STR_LIT>', async(() => {<EOL>            TestBed<EOL>                .compileComponents()<EOL>                . then(() => {<EOL>                const fixture = TestBed.createComponent(HomeComponent);<EOL>                const homeInstance = fixture.debugElement.componentInstance;<EOL>                const homeDOMEl = fixture.debugElement.nativeElement;<EOL>                const mockNameListService =","gt":"fixture.debugElement.injector.get(NameListService);"}
{"input":"<s> export function main() {<EOL>    describe('<STR_LIT>', () => {<EOL>        beforeEach(() => {<EOL>            TestBed. configureTestingModule({<EOL>                imports: [FormsModule],<EOL>                declarations: [HomeComponent],<EOL>                 providers: [<EOL>                    { provide: NameListService, useValue: new MockNameListService() }<EOL>                ]<EOL>            });<EOL>        });<EOL>        it('<STR_LIT>', async(() => {<EOL>            TestBed<EOL>                .compileComponents()<EOL>                . then(() => {<EOL>                const fixture = TestBed.createComponent(HomeComponent);<EOL>                const homeInstance = fixture.debugElement.componentInstance;<EOL>                const homeDOMEl = fixture.debugElement.nativeElement;<EOL>                const mockNameListService =  fixture.debugElement.injector.get(NameListService);<EOL>                const nameListServiceSpy = spyOn(mockNameListService, '<STR_LIT>').and.callThrough();<EOL>                mockNameListService.returnValue = ['<STR_LIT>', '<STR_LIT>', '<STR_LIT>'];<EOL>                fixture.detectChanges();<EOL>                expect(homeInstance.nameListService).toEqual(jasmine.any(MockNameListService));<EOL>                expect(homeDOMEl.querySelectorAll('<STR_LIT>').length).toEqual(<NUM_LIT>);<EOL>                expect(nameListServiceSpy.calls.count()).toBe(<NUM_LIT>);<EOL>","gt":"homeInstance.newName = '<STR_LIT>';"}
{"input":"<s> export function getRawMessage(error) {<EOL>    return","gt":"error[ERROR_RAW_MESSAGE];"}
{"input":"<s> function isCommentEnd(code, next) {<EOL>","gt":"return code == chars.$STAR && next == chars.$SLASH;"}
{"input":"<s> function _pseudoSelectorSupportsInnerSelectors(name) {<EOL>    return ['<STR_LIT>', '<STR_LIT>', '<STR_LIT>'].indexOf(name) >=","gt":"<NUM_LIT>;"}
{"input":"<s> function findFirstClosedCycle(keys) {<EOL>    const res = [];<EOL>    for (let i = <NUM_LIT>; i < keys.length; ++i) {<EOL>        if (res.indexOf(","gt":"keys[i]) > -<NUM_LIT>) {"}
{"input":"<s> function applyParams(fnOrArray, key) {<EOL>    if (fnOrArray === Object || fnOrArray === String || fnOrArray === Function ||<EOL>        fnOrArray === Number || fnOrArray === Array) {<EOL>        throw new Error(`<STR_LIT>`);<EOL>    }<EOL>    if (typeof fnOrArray ===","gt":"'<STR_LIT>') {"}
{"input":"<s> function applyParams(fnOrArray, key) {<EOL>    if (fnOrArray === Object || fnOrArray === String || fnOrArray === Function ||<EOL>        fnOrArray === Number || fnOrArray === Array) {<EOL>        throw new Error(`<STR_LIT>`);<EOL>    }<EOL>    if (typeof fnOrArray ===  '<STR_LIT>') {<EOL>        return fnOrArray;<EOL>    }<EOL>    if (Array.isArray(fnOrArray)) {<EOL>        const annotations = fnOrArray;<EOL>        const annoLength = annotations.length - <NUM_LIT>;<EOL>        const fn = fnOrArray[annoLength];<EOL>","gt":"if (typeof fn !== '<STR_LIT>') {"}
{"input":"<s> function applyParams(fnOrArray, key) {<EOL>    if (fnOrArray === Object || fnOrArray === String || fnOrArray === Function ||<EOL>        fnOrArray === Number || fnOrArray === Array) {<EOL>        throw new Error(`<STR_LIT>`);<EOL>    }<EOL>    if (typeof fnOrArray ===  '<STR_LIT>') {<EOL>        return fnOrArray;<EOL>    }<EOL>    if (Array.isArray(fnOrArray)) {<EOL>        const annotations = fnOrArray;<EOL>        const annoLength = annotations.length - <NUM_LIT>;<EOL>        const fn = fnOrArray[annoLength];<EOL>         if (typeof fn !== '<STR_LIT>') {<EOL>            throw new Error(`<STR_LIT>`);<EOL>        }<EOL>        if (annoLength != fn.length) {<EOL>            throw new Error(","gt":"}) in the function: ${stringify(fn)}`<STR_LIT>;"}
{"input":"<s> function applyParams(fnOrArray, key) {<EOL>    if (fnOrArray === Object || fnOrArray === String || fnOrArray === Function ||<EOL>        fnOrArray === Number || fnOrArray === Array) {<EOL>        throw new Error(`<STR_LIT>`);<EOL>    }<EOL>    if (typeof fnOrArray ===  '<STR_LIT>') {<EOL>        return fnOrArray;<EOL>    }<EOL>    if (Array.isArray(fnOrArray)) {<EOL>        const annotations = fnOrArray;<EOL>        const annoLength = annotations.length - <NUM_LIT>;<EOL>        const fn = fnOrArray[annoLength];<EOL>         if (typeof fn !== '<STR_LIT>') {<EOL>            throw new Error(`<STR_LIT>`);<EOL>        }<EOL>        if (annoLength != fn.length) {<EOL>            throw new Error(`<STR_LIT>`);<EOL>        }<EOL>        const paramsAnnotations = [];<EOL>        for (let i = <NUM_LIT>, ii = annotations.length - <NUM_LIT>; i < ii; i++) {<EOL>            const paramAnnotations = [];<EOL>            paramsAnnotations.push(","gt":"paramAnnotations);"}
{"input":"<s> function applyParams(fnOrArray, key) {<EOL>    if (fnOrArray === Object || fnOrArray === String || fnOrArray === Function ||<EOL>        fnOrArray === Number || fnOrArray === Array) {<EOL>        throw new Error(`<STR_LIT>`);<EOL>    }<EOL>    if (typeof fnOrArray ===  '<STR_LIT>') {<EOL>        return fnOrArray;<EOL>    }<EOL>    if (Array.isArray(fnOrArray)) {<EOL>        const annotations = fnOrArray;<EOL>        const annoLength = annotations.length - <NUM_LIT>;<EOL>        const fn = fnOrArray[annoLength];<EOL>         if (typeof fn !== '<STR_LIT>') {<EOL>            throw new Error(`<STR_LIT>`);<EOL>        }<EOL>        if (annoLength != fn.length) {<EOL>            throw new Error(`<STR_LIT>`);<EOL>        }<EOL>        const paramsAnnotations = [];<EOL>        for (let i = <NUM_LIT>, ii = annotations.length - <NUM_LIT>; i < ii; i++) {<EOL>            const paramAnnotations = [];<EOL>            paramsAnnotations.push( paramAnnotations);<EOL>            const annotation = annotations[i];<EOL>            if (Array.isArray(annotation)) {<EOL>                for (let j = <NUM_LIT>; j < annotation.length; j++) {<EOL>                    paramAnnotations.push(extractAnnotation(annotation[j]));<EOL>                }<EOL>            }<EOL>            else if (typeof annotation === '<STR_LIT>') {<EOL>                paramAnnotations.push(","gt":"extractAnnotation(annotation));"}
{"input":"<s> <EOL>function prepareTemplates() {<EOL>    return gulp.src(join(Config.APP_SRC,","gt":"'<STR_LIT>', '<STR_LIT>'))"}
{"input":"<s> <EOL>function processExternalCss() {<EOL>    return getExternalCssStream()<EOL>        .pipe(","gt":"plugins.postcss(processors))"}
{"input":"<s> <EOL>function transformPath() {<EOL>    return function (filepath) {<EOL>        if (filepath.startsWith(`<STR_LIT>`)) {<EOL>            filepath = filepath.replace(`<STR_LIT>`,","gt":"'<STR_LIT>');"}
{"input":"<s> export function serveDocs() {<EOL>    let","gt":"server = express();"}
{"input":"<s> export function delay(ms) {<EOL>    return new Promise(","gt":"function (resolve, reject) {"}
{"input":"<s> function computeTopJoinQuote(input) {<EOL>    var genQt = getQuoteAtTopOfMarket(input);<EOL>    if (input.params.mode === Models.QuotingMode.Top && genQt.bidSz > <NUM_LIT>) {<EOL>        genQt.bidPx += input.minTickIncrement;<EOL>    }<EOL>    var minBid = input.fv.","gt":"price - input.params.width / <NUM_LIT>;"}
{"input":"<s> function computeTopJoinQuote(input) {<EOL>    var genQt = getQuoteAtTopOfMarket(input);<EOL>    if (input.params.mode === Models.QuotingMode.Top && genQt.bidSz > <NUM_LIT>) {<EOL>        genQt.bidPx += input.minTickIncrement;<EOL>    }<EOL>    var minBid = input.fv. price - input.params.width / <NUM_LIT>;<EOL>    genQt.bidPx = Math.min(minBid, genQt.bidPx);<EOL>    if (input.params.mode === Models.QuotingMode.Top && genQt.askSz > <NUM_LIT>) {<EOL>        genQt.askPx -= input.minTickIncrement;<EOL>    }<EOL>    var minAsk = input.fv.price + input.params.width / <NUM_LIT>;<EOL>","gt":"genQt.askPx = Math.max(minAsk, genQt.askPx);"}
{"input":"<s> <EOL>async function updateNoteResources(meta, content, noteGuid, resources) {<EOL>    try {<EOL>        let tagNames = meta[\"<STR_LIT>\"];<EOL>        let title = meta[\"<STR_LIT>\"];<EOL>        let notebook =","gt":"meta[\"<STR_LIT>\"];"}
{"input":"<s> <EOL>async function updateNoteResources(meta, content, noteGuid, resources) {<EOL>    try {<EOL>        let tagNames = meta[\"<STR_LIT>\"];<EOL>        let title = meta[\"<STR_LIT>\"];<EOL>        let notebook =  meta[\"<STR_LIT>\"];<EOL>        const notebookGuid = await getNotebookGuid(notebook);<EOL>        return client.updateNoteResources(noteGuid, title, content, tagNames, notebookGuid, resources || void <NUM_LIT>);<EOL>    }<EOL>","gt":"catch (err) {"}
{"input":"<s> async function arrayFromLiteral() {<EOL>","gt":"\"<STR_LIT>\";"}
{"input":"<s> async function addEqualsInts(x, y) {<EOL>","gt":"\"<STR_LIT>\";"}
{"input":"<s> async function binOrInts(x, y) {<EOL>","gt":"\"<STR_LIT>\";"}
{"input":"<s> async function divideNumbers(x, y) {<EOL>","gt":"\"<STR_LIT>\";"}
{"input":"<s> async function intLessThan(x, y) {<EOL>","gt":"\"<STR_LIT>\";"}
{"input":"<s> async function powInts(base, exponent) {<EOL>","gt":"\"<STR_LIT>\";"}
{"input":"<s> async function numberCondition(condition, trueValue, falseValue) {<EOL>","gt":"\"<STR_LIT>\";"}
{"input":"<s> <EOL>export function isCodeGenerationDiagnostic(error) {<EOL>    return typeof (error.node) !== \"<STR_LIT>\" && typeof (error.","gt":"code) === \"<STR_LIT>\" && error instanceof Error;"}
{"input":"<s> <EOL>export function isMaybeObjectType(type) {<EOL>    if (type.flags & ts.TypeFlags.Union) {<EOL>        const unionType = type;<EOL>        return","gt":"unionType.types.length === <NUM_LIT> &&"}
{"input":"<s> export async function asBoolean() {<EOL>","gt":"\"<STR_LIT>\";"}
{"input":"<s> async function minusImplicitCast() {<EOL>","gt":"\"<STR_LIT>\";"}
{"input":"<s> async function argumentsEvaluationOrder(points, index) {<EOL>","gt":"\"<STR_LIT>\";"}
{"input":"<s> async function plusPlus() {<EOL>    \"<STR_LIT>\";<EOL>    let","gt":"intResult = +<NUM_LIT>;"}
{"input":"<s> function tspSync(points) {<EOL>    \"<STR_LIT>\";<EOL>    let current = points.shift();<EOL>    const solution = [current];<EOL>    while (points.length) {<EOL>        let shortestDistance = <NUM_LIT> ** <NUM_LIT> - <NUM_LIT>;<EOL>","gt":"let nearestIndex = <NUM_LIT>;"}
{"input":"<s> function tspSync(points) {<EOL>    \"<STR_LIT>\";<EOL>    let current = points.shift();<EOL>    const solution = [current];<EOL>    while (points.length) {<EOL>        let shortestDistance = <NUM_LIT> ** <NUM_LIT> - <NUM_LIT>;<EOL>         let nearestIndex = <NUM_LIT>;<EOL>        for (let i = <NUM_LIT>; i < points.length; ++i) {<EOL>            const distance = current.distanceTo(points[i]);<EOL>            if (distance < shortestDistance) {<EOL>","gt":"shortestDistance = distance;"}
{"input":"<s> function tspSync(points) {<EOL>    \"<STR_LIT>\";<EOL>    let current = points.shift();<EOL>    const solution = [current];<EOL>    while (points.length) {<EOL>        let shortestDistance = <NUM_LIT> ** <NUM_LIT> - <NUM_LIT>;<EOL>         let nearestIndex = <NUM_LIT>;<EOL>        for (let i = <NUM_LIT>; i < points.length; ++i) {<EOL>            const distance = current.distanceTo(points[i]);<EOL>            if (distance < shortestDistance) {<EOL>                 shortestDistance = distance;<EOL>                nearestIndex = i;<EOL>            }<EOL>        }<EOL>        current = points[","gt":"nearestIndex];"}
{"input":"<s> async function simpleWhile(arg) {<EOL>    \"<STR_LIT>\";<EOL>","gt":"while (arg) {"}
{"input":"<s> export function flash(x, y, title, scale = <NUM_LIT>) {<EOL>    if (flashIconLazy === undefined) {<EOL>","gt":"const d = `<STR_LIT>7"}
{"input":"<s> <EOL>export function isTabUp(evt) {<EOL>    return","gt":"evt.which === <NUM_LIT> && evt.shiftKey;"}
{"input":"<s> <EOL>export function pluralize(word, count) {<EOL>","gt":"return word + (count > <NUM_LIT> ? \"<STR_LIT>\" : \"<STR_LIT>\");"}
{"input":"<s> export function formatBytes(bytes) {<EOL>    const raw = `<STR_LIT>`;<EOL>    if (bytes >= bytesPerMB) {<EOL>        return","gt":"bytesPerMB, <NUM_LIT>)} MB)`<STR_LIT>;"}
{"input":"<s> <EOL>export function createRequestLabelFull(x, y, name, height) {<EOL>    const blockLabel = createRequestLabel(x, y, name, height);<EOL>    const labelHolder = svg.newG(\"<STR_LIT>\", {}, {<EOL>        clipPath: `<STR_LIT>`,<EOL>    });<EOL>    labelHolder.appendChild(","gt":"svg.newRect({"}
{"input":"<s> <EOL>export function createRequestLabelFull(x, y, name, height) {<EOL>    const blockLabel = createRequestLabel(x, y, name, height);<EOL>    const labelHolder = svg.newG(\"<STR_LIT>\", {}, {<EOL>        clipPath: `<STR_LIT>`,<EOL>    });<EOL>    labelHolder.appendChild( svg.newRect({<EOL>        height: height - <NUM_LIT>,<EOL>        rx: <NUM_LIT>,<EOL>        ry: <NUM_LIT>,<EOL>        <EOL>        <EOL>        width: <NUM_LIT>,<EOL>        x: x - <NUM_LIT>,<EOL>        y:","gt":"y + <NUM_LIT>,"}
{"input":"<s> <EOL><EOL><EOL>function mapLocale(locale) {<EOL>    locale = locale && locale.toLowerCase();<EOL>    if (locale in localizedStrings) {<EOL>","gt":"return locale;"}
{"input":"<s> <EOL><EOL><EOL>function mapLocale(locale) {<EOL>    locale = locale && locale.toLowerCase();<EOL>    if (locale in localizedStrings) {<EOL>         return locale;<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>        return","gt":"'<STR_LIT>';"}
{"input":"<s> <EOL><EOL><EOL>function mapLocale(locale) {<EOL>    locale = locale && locale.toLowerCase();<EOL>    if (locale in localizedStrings) {<EOL>         return locale;<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>        return  '<STR_LIT>';<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>","gt":"return '<STR_LIT>';"}
{"input":"<s> <EOL><EOL><EOL>function mapLocale(locale) {<EOL>    locale = locale && locale.toLowerCase();<EOL>    if (locale in localizedStrings) {<EOL>         return locale;<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>        return  '<STR_LIT>';<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>         return '<STR_LIT>';<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>","gt":"else if (locale.startsWith('<STR_LIT>')) {"}
{"input":"<s> <EOL><EOL><EOL>function mapLocale(locale) {<EOL>    locale = locale && locale.toLowerCase();<EOL>    if (locale in localizedStrings) {<EOL>         return locale;<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>        return  '<STR_LIT>';<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>         return '<STR_LIT>';<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>     else if (locale.startsWith('<STR_LIT>')) {<EOL>","gt":"return '<STR_LIT>';"}
{"input":"<s> <EOL><EOL><EOL>function mapLocale(locale) {<EOL>    locale = locale && locale.toLowerCase();<EOL>    if (locale in localizedStrings) {<EOL>         return locale;<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>        return  '<STR_LIT>';<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>         return '<STR_LIT>';<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>     else if (locale.startsWith('<STR_LIT>')) {<EOL>         return '<STR_LIT>';<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>        return","gt":"'<STR_LIT>';"}
{"input":"<s> <EOL><EOL><EOL>function mapLocale(locale) {<EOL>    locale = locale && locale.toLowerCase();<EOL>    if (locale in localizedStrings) {<EOL>         return locale;<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>        return  '<STR_LIT>';<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>         return '<STR_LIT>';<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>     else if (locale.startsWith('<STR_LIT>')) {<EOL>         return '<STR_LIT>';<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>        return  '<STR_LIT>';<EOL>    }<EOL>    else if (","gt":"locale.startsWith('<STR_LIT>')) {"}
{"input":"<s> <EOL><EOL><EOL>function mapLocale(locale) {<EOL>    locale = locale && locale.toLowerCase();<EOL>    if (locale in localizedStrings) {<EOL>         return locale;<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>        return  '<STR_LIT>';<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>         return '<STR_LIT>';<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>     else if (locale.startsWith('<STR_LIT>')) {<EOL>         return '<STR_LIT>';<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>        return  '<STR_LIT>';<EOL>    }<EOL>    else if ( locale.startsWith('<STR_LIT>')) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>') || locale.startsWith('<STR_LIT>') || locale.startsWith(","gt":"'<STR_LIT>')) {"}
{"input":"<s> <EOL><EOL><EOL>function mapLocale(locale) {<EOL>    locale = locale && locale.toLowerCase();<EOL>    if (locale in localizedStrings) {<EOL>         return locale;<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>        return  '<STR_LIT>';<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>         return '<STR_LIT>';<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>     else if (locale.startsWith('<STR_LIT>')) {<EOL>         return '<STR_LIT>';<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>        return  '<STR_LIT>';<EOL>    }<EOL>    else if ( locale.startsWith('<STR_LIT>')) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>') || locale.startsWith('<STR_LIT>') || locale.startsWith( '<STR_LIT>')) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>        return","gt":"'<STR_LIT>';"}
{"input":"<s> <EOL><EOL><EOL>function mapLocale(locale) {<EOL>    locale = locale && locale.toLowerCase();<EOL>    if (locale in localizedStrings) {<EOL>         return locale;<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>        return  '<STR_LIT>';<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>         return '<STR_LIT>';<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>     else if (locale.startsWith('<STR_LIT>')) {<EOL>         return '<STR_LIT>';<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>        return  '<STR_LIT>';<EOL>    }<EOL>    else if ( locale.startsWith('<STR_LIT>')) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>') || locale.startsWith('<STR_LIT>') || locale.startsWith( '<STR_LIT>')) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>        return  '<STR_LIT>';<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>        if (locale === '<STR_LIT>') {<EOL>            return '<STR_LIT>';<EOL>        }<EOL>        else {<EOL>            return '<STR_LIT>';<EOL>        }<EOL>    }<EOL>    else if (","gt":"locale.startsWith('<STR_LIT>')) {"}
{"input":"<s> <EOL><EOL><EOL>function mapLocale(locale) {<EOL>    locale = locale && locale.toLowerCase();<EOL>    if (locale in localizedStrings) {<EOL>         return locale;<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>        return  '<STR_LIT>';<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>         return '<STR_LIT>';<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>     else if (locale.startsWith('<STR_LIT>')) {<EOL>         return '<STR_LIT>';<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>        return  '<STR_LIT>';<EOL>    }<EOL>    else if ( locale.startsWith('<STR_LIT>')) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>') || locale.startsWith('<STR_LIT>') || locale.startsWith( '<STR_LIT>')) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>        return  '<STR_LIT>';<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>        if (locale === '<STR_LIT>') {<EOL>            return '<STR_LIT>';<EOL>        }<EOL>        else {<EOL>            return '<STR_LIT>';<EOL>        }<EOL>    }<EOL>    else if ( locale.startsWith('<STR_LIT>')) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>        return","gt":"'<STR_LIT>';"}
{"input":"<s> <EOL><EOL><EOL>function mapLocale(locale) {<EOL>    locale = locale && locale.toLowerCase();<EOL>    if (locale in localizedStrings) {<EOL>         return locale;<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>        return  '<STR_LIT>';<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>         return '<STR_LIT>';<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>     else if (locale.startsWith('<STR_LIT>')) {<EOL>         return '<STR_LIT>';<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>        return  '<STR_LIT>';<EOL>    }<EOL>    else if ( locale.startsWith('<STR_LIT>')) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>') || locale.startsWith('<STR_LIT>') || locale.startsWith( '<STR_LIT>')) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>        return  '<STR_LIT>';<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>        if (locale === '<STR_LIT>') {<EOL>            return '<STR_LIT>';<EOL>        }<EOL>        else {<EOL>            return '<STR_LIT>';<EOL>        }<EOL>    }<EOL>    else if ( locale.startsWith('<STR_LIT>')) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>        return  '<STR_LIT>';<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>        return","gt":"'<STR_LIT>';"}
{"input":"<s> function getPackageString(packageObject) {<EOL>    if (!packageObject) {<EOL>        return chalk.magenta(\"<STR_LIT>\").toString();<EOL>    }<EOL>","gt":"var packageString = chalk.green(\"<STR_LIT>\") + packageObject.label + \"<STR_LIT>\" +"}
{"input":"<s> function getPackageString(packageObject) {<EOL>    if (!packageObject) {<EOL>        return chalk.magenta(\"<STR_LIT>\").toString();<EOL>    }<EOL>     var packageString = chalk.green(\"<STR_LIT>\") + packageObject.label + \"<STR_LIT>\" +<EOL>        chalk.green(\"<STR_LIT>\") + packageObject.appVersion + \"<STR_LIT>\" +<EOL>        chalk.green(\"<STR_LIT>\") + (packageObject.isMandatory ? \"<STR_LIT>\" : \"<STR_LIT>\") + \"<STR_LIT>\" +<EOL>        chalk.green(\"<STR_LIT>\") + formatDate(packageObject.uploadTime) + \"<STR_LIT>\" +<EOL>        chalk.green(\"<STR_LIT>\") + (packageObject.releasedBy ? packageObject.releasedBy : \"<STR_LIT>\") +<EOL>        (packageObject.description ? wordwrap(<NUM_LIT>)(\"<STR_LIT>\" + chalk.green(\"<STR_LIT>\") + packageObject.description) : \"<STR_LIT>\");<EOL>","gt":"if (packageObject.isDisabled) {"}
{"input":"<s> function throwForInvalidSemverRange(semverRange) {<EOL>","gt":"if (semver.validRange(semverRange) === null) {"}
{"input":"<s> function accessKeyAdd(commandName, yargs) {<EOL>    isValidCommand = true;<EOL>    yargs.usage(USAGE_PREFIX + \"<STR_LIT>\" + commandName + \"<STR_LIT>\")<EOL>        .demand( <NUM_LIT>,","gt":"<NUM_LIT>)"}
{"input":"<s> <EOL>function mockReturn(bodyText, statusCode, header = {}) {<EOL>    require(\"<STR_LIT>\")(request, [{<EOL>            pattern: \"<STR_LIT>\",<EOL>            fixtures: function (match, params) {<EOL>                var isOk = statusCode >= <NUM_LIT> && statusCode <","gt":"<NUM_LIT>;"}
{"input":"<s> <EOL>function mockReturn(bodyText, statusCode, header = {}) {<EOL>    require(\"<STR_LIT>\")(request, [{<EOL>            pattern: \"<STR_LIT>\",<EOL>            fixtures: function (match, params) {<EOL>                var isOk = statusCode >= <NUM_LIT> && statusCode <  <NUM_LIT>;<EOL>                if (!isOk) {<EOL>                    var err = new Error(bodyText);<EOL>                    err.status = statusCode;<EOL>                    throw err;<EOL>                }<EOL>                return { text: bodyText, status: statusCode,","gt":"ok: isOk, header: header, headers: {} };"}
{"input":"<s> function getTemplate(templateName) {<EOL>    try {<EOL>        return fs.","gt":"readFileSync(path.join(templatesDirectory, templateName + \"<STR_LIT>\"), \"<STR_LIT>\");"}
{"input":"<s> function getCSharpCommand() {<EOL>    return process.platform == \"<STR_LIT>\" ?","gt":"\"<STR_LIT>\" : \"<STR_LIT>\";"}
{"input":"<s> function runBuildCmdAsync(cmd, ...args) {<EOL>    return nodeutil.spawnAsync({<EOL>","gt":"cmd,"}
{"input":"<s> export function augmnetDocsAsync(parsed) {<EOL>    let f0 = fs.readFileSync(parsed.arguments[<NUM_LIT>], \"<STR_LIT>\");<EOL>    let f1 = fs.","gt":"readFileSync(parsed.arguments[<NUM_LIT>], \"<STR_LIT>\");"}
{"input":"<s> function buildFolderAndBrowserifyAsync(p, optional, outputName) {<EOL>    if (!fs.existsSync(path.join(p, \"<STR_LIT>\"))) {<EOL>        if (!optional)<EOL>            U.userError(`<STR_LIT>`);<EOL>","gt":"return Promise.resolve();"}
{"input":"<s> function buildFolderAndBrowserifyAsync(p, optional, outputName) {<EOL>    if (!fs.existsSync(path.join(p, \"<STR_LIT>\"))) {<EOL>        if (!optional)<EOL>            U.userError(`<STR_LIT>`);<EOL>         return Promise.resolve();<EOL>    }<EOL>    const tsConfig = JSON.parse(fs.readFileSync(path.join(p, \"<STR_LIT>\"), \"<STR_LIT>\"));<EOL>    if (","gt":"outputName && tsConfig.compilerOptions.outDir !== `<STR_LIT>`) {"}
{"input":"<s> function buildFolderAndBrowserifyAsync(p, optional, outputName) {<EOL>    if (!fs.existsSync(path.join(p, \"<STR_LIT>\"))) {<EOL>        if (!optional)<EOL>            U.userError(`<STR_LIT>`);<EOL>         return Promise.resolve();<EOL>    }<EOL>    const tsConfig = JSON.parse(fs.readFileSync(path.join(p, \"<STR_LIT>\"), \"<STR_LIT>\"));<EOL>    if ( outputName && tsConfig.compilerOptions.outDir !== `<STR_LIT>`) {<EOL>        U.userError(`<STR_LIT>`);<EOL>    }<EOL>    if (!fs.existsSync(\"<STR_LIT>\")) {<EOL>        U.userError(\"<STR_LIT>\");<EOL>    }<EOL>    pxt.log(`<STR_LIT>`);<EOL>    dirsToWatch.push(p);<EOL>    return nodeutil.spawnAsync({<EOL>","gt":"cmd: \"<STR_LIT>\","}
{"input":"<s> function buildFolderAndBrowserifyAsync(p, optional, outputName) {<EOL>    if (!fs.existsSync(path.join(p, \"<STR_LIT>\"))) {<EOL>        if (!optional)<EOL>            U.userError(`<STR_LIT>`);<EOL>         return Promise.resolve();<EOL>    }<EOL>    const tsConfig = JSON.parse(fs.readFileSync(path.join(p, \"<STR_LIT>\"), \"<STR_LIT>\"));<EOL>    if ( outputName && tsConfig.compilerOptions.outDir !== `<STR_LIT>`) {<EOL>        U.userError(`<STR_LIT>`);<EOL>    }<EOL>    if (!fs.existsSync(\"<STR_LIT>\")) {<EOL>        U.userError(\"<STR_LIT>\");<EOL>    }<EOL>    pxt.log(`<STR_LIT>`);<EOL>    dirsToWatch.push(p);<EOL>    return nodeutil.spawnAsync({<EOL>         cmd: \"<STR_LIT>\",<EOL>        args: [\"<STR_LIT>\"],<EOL>        cwd: p<EOL>    }).then(() => {<EOL>","gt":"const browserify = require('<STR_LIT>');"}
{"input":"<s> function buildFolderAndBrowserifyAsync(p, optional, outputName) {<EOL>    if (!fs.existsSync(path.join(p, \"<STR_LIT>\"))) {<EOL>        if (!optional)<EOL>            U.userError(`<STR_LIT>`);<EOL>         return Promise.resolve();<EOL>    }<EOL>    const tsConfig = JSON.parse(fs.readFileSync(path.join(p, \"<STR_LIT>\"), \"<STR_LIT>\"));<EOL>    if ( outputName && tsConfig.compilerOptions.outDir !== `<STR_LIT>`) {<EOL>        U.userError(`<STR_LIT>`);<EOL>    }<EOL>    if (!fs.existsSync(\"<STR_LIT>\")) {<EOL>        U.userError(\"<STR_LIT>\");<EOL>    }<EOL>    pxt.log(`<STR_LIT>`);<EOL>    dirsToWatch.push(p);<EOL>    return nodeutil.spawnAsync({<EOL>         cmd: \"<STR_LIT>\",<EOL>        args: [\"<STR_LIT>\"],<EOL>        cwd: p<EOL>    }).then(() => {<EOL>         const browserify = require('<STR_LIT>');<EOL>        let b = browserify();<EOL>        nodeutil.allFiles(`<STR_LIT>`).forEach((f) => {<EOL>            if (f.match(/\\.js$/)) {<EOL>                b.add(f);<EOL>            }<EOL>        });<EOL>        let outFile = fs.createWriteStream(`<STR_LIT>`, { encoding: '<STR_LIT>' });<EOL>        b.","gt":"bundle().pipe(outFile);"}
{"input":"<s> function prepBuildOptionsAsync(mode, quick = false) {<EOL>    ensurePkgDir();<EOL>    return mainPkg.loadAsync()<EOL>        .then(() => {<EOL>        if (!quick) {<EOL>            build.buildDalConst(build.thisBuild, mainPkg);<EOL>","gt":"copyCommonFiles();"}
{"input":"<s> function prepBuildOptionsAsync(mode, quick = false) {<EOL>    ensurePkgDir();<EOL>    return mainPkg.loadAsync()<EOL>        .then(() => {<EOL>        if (!quick) {<EOL>            build.buildDalConst(build.thisBuild, mainPkg);<EOL>             copyCommonFiles();<EOL>        }<EOL>        <EOL>","gt":"let target = mainPkg.getTargetOptions();"}
{"input":"<s> function prepBuildOptionsAsync(mode, quick = false) {<EOL>    ensurePkgDir();<EOL>    return mainPkg.loadAsync()<EOL>        .then(() => {<EOL>        if (!quick) {<EOL>            build.buildDalConst(build.thisBuild, mainPkg);<EOL>             copyCommonFiles();<EOL>        }<EOL>        <EOL>         let target = mainPkg.getTargetOptions();<EOL>        if (target.hasHex)<EOL>            target.isNative = true;<EOL>","gt":"switch (mode) {"}
{"input":"<s> function prepBuildOptionsAsync(mode, quick = false) {<EOL>    ensurePkgDir();<EOL>    return mainPkg.loadAsync()<EOL>        .then(() => {<EOL>        if (!quick) {<EOL>            build.buildDalConst(build.thisBuild, mainPkg);<EOL>             copyCommonFiles();<EOL>        }<EOL>        <EOL>         let target = mainPkg.getTargetOptions();<EOL>        if (target.hasHex)<EOL>            target.isNative = true;<EOL>         switch (mode) {<EOL>            case BuildOption.Run:<EOL>            case BuildOption.DebugSim:<EOL>            case BuildOption.GenDocs:<EOL>                target.","gt":"isNative = false;"}
{"input":"<s> export function serialAsync(parsed) {<EOL>    let buf = \"<STR_LIT>\";<EOL>    serial.monitorSerial((","gt":"info, buffer) => {"}
{"input":"<s> export function fileExistsSync(p) {<EOL>    try {<EOL>        let stats = fs.lstatSync(p);<EOL>        return","gt":"stats && stats.isFile();"}
{"input":"<s> export function gitInfoAsync(args, cwd, silent = false) {<EOL>    return Promise.resolve()<EOL>        .then(() => spawnWithPipeAsync({<EOL>","gt":"cmd: \"<STR_LIT>\","}
{"input":"<s> function getName(e) {<EOL>    if (e == null)<EOL>        return null;<EOL>    if (e.kind == \"<STR_LIT>\") {<EOL>        let s = e.id;<EOL>","gt":"let v = lookupVar(s);"}
{"input":"<s> function getName(e) {<EOL>    if (e == null)<EOL>        return null;<EOL>    if (e.kind == \"<STR_LIT>\") {<EOL>        let s = e.id;<EOL>         let v = lookupVar(s);<EOL>        if (v && v.expandsTo)<EOL>            return v.expandsTo;<EOL>        else<EOL>","gt":"return s;"}
{"input":"<s> function getName(e) {<EOL>    if (e == null)<EOL>        return null;<EOL>    if (e.kind == \"<STR_LIT>\") {<EOL>        let s = e.id;<EOL>         let v = lookupVar(s);<EOL>        if (v && v.expandsTo)<EOL>            return v.expandsTo;<EOL>        else<EOL>             return s;<EOL>    }<EOL>    if (e.kind == \"<STR_LIT>\") {<EOL>        let pref = getName(e.value);<EOL>        if (","gt":"pref)"}
{"input":"<s> <EOL>function toTS(mod) {<EOL>    U.assert(mod.kind == \"<STR_LIT>\");<EOL>    resetCtx(mod);<EOL>    if (!mod.vars)<EOL>        mod.","gt":"vars = {};"}
{"input":"<s> <EOL>function toTS(mod) {<EOL>    U.assert(mod.kind == \"<STR_LIT>\");<EOL>    resetCtx(mod);<EOL>    if (!mod.vars)<EOL>        mod. vars = {};<EOL>    let res = mod.body.map(stmt);<EOL>    if (res.every(isEmpty))<EOL>        return null;<EOL>    return [<EOL>        B.","gt":"mkText(\"<STR_LIT>\" + mod.name + \"<STR_LIT>\"),"}
{"input":"<s> function i(parts) {<EOL>    return lbl(parts[","gt":"<NUM_LIT>], [\"<STR_LIT>\"]);"}
{"input":"<s> function initGlobals() {<EOL>    Promise = require(\"<STR_LIT>\");<EOL>    let g = global;<EOL>    g.","gt":"pxt = pxt;"}
{"input":"<s> function decompileTestAsync(filename) {<EOL>    return new Promise((resolve, reject) => {<EOL>        const basename = path.basename(filename);<EOL>        const baselineFile = path.join(baselineDir, replaceFileExtension(basename, \"<STR_LIT>\"));<EOL>        let baselineExists;<EOL>","gt":"try {"}
{"input":"<s> function decompileTestAsync(filename) {<EOL>    return new Promise((resolve, reject) => {<EOL>        const basename = path.basename(filename);<EOL>        const baselineFile = path.join(baselineDir, replaceFileExtension(basename, \"<STR_LIT>\"));<EOL>        let baselineExists;<EOL>         try {<EOL>            const stats = fs.statSync(baselineFile);<EOL>            baselineExists = stats.isFile();<EOL>        }<EOL>        catch (e) {<EOL>            baselineExists = false;<EOL>        }<EOL>        if (!baselineExists) {<EOL>            return reject(\"<STR_LIT>\" + basename);<EOL>        }<EOL>        return decompileAsyncWorker(filename, testBlocksDir)<EOL>            .then((decompiled) => {<EOL>            const baseline = fs.readFileSync(baselineFile, \"<STR_LIT>\");<EOL>            if (!compareBaselines(decompiled, baseline)) {<EOL>                const outFile = path.join(replaceFileExtension(filename,","gt":"\"<STR_LIT>\"));"}
{"input":"<s> export function workerOpAsync(op, arg) {<EOL>    return pxt.worker.getWorker(pxt.","gt":"webConfig.workerjs).opAsync(op, arg);"}
{"input":"<s> export function resetFocus() {<EOL>    let content = document.getElementById('<STR_LIT>');<EOL>    content.","gt":"tabIndex = <NUM_LIT>;"}
{"input":"<s> export function showLoading(id, msg) {<EOL>    pxt.debug(\"<STR_LIT>\" + id);<EOL>    if (loadingQueueMsg[id])<EOL>","gt":"return;"}
{"input":"<s> export function clearCache() {<EOL>","gt":"cachedData = {};"}
{"input":"<s> function memoryDb() {<EOL>    pxt.debug('<STR_LIT>');<EOL>","gt":"inMemory = true;"}
{"input":"<s> function installAsync(h0, text) {<EOL>    const h = h0;<EOL>    let path = h.name.replace(/[^a-zA-Z0-9]+/g, \"<STR_LIT>\").trim().replace(/ /g, \"<STR_LIT>\");<EOL>    if (lookup(path)) {<EOL>        let n = <NUM_LIT>;<EOL>","gt":"while (lookup(path + \"<STR_LIT>\" + n))"}
{"input":"<s> function installAsync(h0, text) {<EOL>    const h = h0;<EOL>    let path = h.name.replace(/[^a-zA-Z0-9]+/g, \"<STR_LIT>\").trim().replace(/ /g, \"<STR_LIT>\");<EOL>    if (lookup(path)) {<EOL>        let n = <NUM_LIT>;<EOL>         while (lookup(path + \"<STR_LIT>\" + n))<EOL>            n++;<EOL>","gt":"path += \"<STR_LIT>\" + n;"}
{"input":"<s> function installAsync(h0, text) {<EOL>    const h = h0;<EOL>    let path = h.name.replace(/[^a-zA-Z0-9]+/g, \"<STR_LIT>\").trim().replace(/ /g, \"<STR_LIT>\");<EOL>    if (lookup(path)) {<EOL>        let n = <NUM_LIT>;<EOL>         while (lookup(path + \"<STR_LIT>\" + n))<EOL>            n++;<EOL>         path += \"<STR_LIT>\" + n;<EOL>        h.name += \"<STR_LIT>\" + n;<EOL>    }<EOL>    h.id = path;<EOL>    h.recentUse = U.nowSeconds();<EOL>    h.modificationTime =","gt":"h.recentUse;"}
{"input":"<s> function installAsync(h0, text) {<EOL>    const h = h0;<EOL>    let path = h.name.replace(/[^a-zA-Z0-9]+/g, \"<STR_LIT>\").trim().replace(/ /g, \"<STR_LIT>\");<EOL>    if (lookup(path)) {<EOL>        let n = <NUM_LIT>;<EOL>         while (lookup(path + \"<STR_LIT>\" + n))<EOL>            n++;<EOL>         path += \"<STR_LIT>\" + n;<EOL>        h.name += \"<STR_LIT>\" + n;<EOL>    }<EOL>    h.id = path;<EOL>    h.recentUse = U.nowSeconds();<EOL>    h.modificationTime =  h.recentUse;<EOL>    h.target = currentTarget;<EOL>    const e = {<EOL>        id: h.id,<EOL>        header: h,<EOL>","gt":"text: text,"}
{"input":"<s> function saveToCloudAsync(h) {<EOL>    return Promise.","gt":"resolve();"}
{"input":"<s> function loadMakeFrameAsync(container) {<EOL>    return new Promise((resolve, reject) => {<EOL>        function waitForReady(ev) {<EOL>            const data = ev.data;<EOL>            if (data.type == \"<STR_LIT>\" && data.","gt":"frameid == FRAME_ID) {"}
{"input":"<s> function loadMakeFrameAsync(container) {<EOL>    return new Promise((resolve, reject) => {<EOL>        function waitForReady(ev) {<EOL>            const data = ev.data;<EOL>            if (data.type == \"<STR_LIT>\" && data. frameid == FRAME_ID) {<EOL>                window.removeEventListener('<STR_LIT>', waitForReady);<EOL>                resolve(iframe);<EOL>            }<EOL>        }<EOL>        <EOL>        window.addEventListener('<STR_LIT>', waitForReady);<EOL>        <EOL>        <EOL>        const iframe = document.createElement(\"<STR_LIT>\");<EOL>        iframe.frameBorder = \"<STR_LIT>\";<EOL>        iframe.setAttribute(\"<STR_LIT>\", \"<STR_LIT>\");<EOL>","gt":"iframe.setAttribute(\"<STR_LIT>\", \"<STR_LIT>\");"}
{"input":"<s> function saveToCloudAsync(h) {<EOL>    return Promise.","gt":"resolve();"}
{"input":"<s> export function overrideToolbox(def) {<EOL>    overrideCategory(loops.nameid, def.loops);<EOL>    overrideCategory(logic.nameid, def.logic);<EOL>    overrideCategory(variables.nameid, def.","gt":"variables);"}
{"input":"<s> export function installAsync(h0, text) {<EOL>","gt":"checkSession();"}
{"input":"<s> function decorateClassMethod(target, propertyKey, descriptor, actionType, actionContext) {<EOL>    if (descriptor && typeof descriptor.value == '<STR_LIT>') {<EOL>","gt":"descriptor.value = wrapFunctionInAction(descriptor.value, actionType, actionContext);"}
{"input":"<s> function wrapFunctionInAction(target, actionType, actionContext) {<EOL>    let decoratedTarget = function () {<EOL>        let returnValue;<EOL>        let passedArguments = arguments;<EOL>","gt":"dispatch(() => {"}
{"input":"<s> function wrapFunctionInAction(target, actionType, actionContext) {<EOL>    let decoratedTarget = function () {<EOL>        let returnValue;<EOL>        let passedArguments = arguments;<EOL>         dispatch(() => {<EOL>            returnValue = target.apply(this, passedArguments);<EOL>            return returnValue;<EOL>        }, actionType, arguments, actionContext);<EOL>        return returnValue;<EOL>    };<EOL>","gt":"setOriginalTarget(decoratedTarget, target);"}
{"input":"<s> export function setActionType(decoratedTarget, actionType) {<EOL>    decoratedTarget.__SATCHELJS_ACTION_TYPE =","gt":"actionType;"}
{"input":"<s> export function raise(actionType, callback) {<EOL>    console.error(\"<STR_LIT>\");<EOL>    <EOL>    let actionToExecute = action(actionType)(() => { });<EOL>    if (","gt":"callback) {"}
{"input":"<s> function resetState() {<EOL>    _.","gt":"resetGlobalState();"}
{"input":"<s> function reloadTypeScriptNodeModule() {<EOL>    var util = require('<STR_LIT>');<EOL>    function log(message, ...rest) {<EOL>        util.log(util.colors.","gt":"cyan('<STR_LIT>'), message, ...rest);"}
{"input":"<s> function reloadTypeScriptNodeModule() {<EOL>    var util = require('<STR_LIT>');<EOL>    function log(message, ...rest) {<EOL>        util.log(util.colors. cyan('<STR_LIT>'), message, ...rest);<EOL>    }<EOL>    function heapUsed() {<EOL>        return (process.memoryUsage().heapUsed / <NUM_LIT> / <NUM_LIT>).toFixed(<NUM_LIT>) + '<STR_LIT>';<EOL>    }<EOL>    return es.through(function (data) {<EOL>        this.emit('<STR_LIT>', data);<EOL>    }, function () {<EOL>        log(","gt":"'<STR_LIT>' + heapUsed());"}
{"input":"<s> function reloadTypeScriptNodeModule() {<EOL>    var util = require('<STR_LIT>');<EOL>    function log(message, ...rest) {<EOL>        util.log(util.colors. cyan('<STR_LIT>'), message, ...rest);<EOL>    }<EOL>    function heapUsed() {<EOL>        return (process.memoryUsage().heapUsed / <NUM_LIT> / <NUM_LIT>).toFixed(<NUM_LIT>) + '<STR_LIT>';<EOL>    }<EOL>    return es.through(function (data) {<EOL>        this.emit('<STR_LIT>', data);<EOL>    }, function () {<EOL>        log( '<STR_LIT>' + heapUsed());<EOL>        <EOL>        <EOL>        <EOL>        <EOL>        <EOL>        <EOL>        <EOL>        <EOL>        <EOL>        log('<STR_LIT>');<EOL>        var resolvedName = require.resolve('<STR_LIT>');<EOL>        var originalModule = require.cache[resolvedName];<EOL>        delete require.cache[resolvedName];<EOL>        var newExports = require('<STR_LIT>');<EOL>        require.","gt":"cache[resolvedName] = originalModule;"}
{"input":"<s> export function fromGitUri(uri) {<EOL>","gt":"return JSON.parse(uri.query);"}
{"input":"<s> function tryLoadMarkdownItPlugins(contributes, extension, engine) {<EOL>    if (contributes['<STR_LIT>']) {<EOL>        extension.activate().then(() => {<EOL>            if (extension.","gt":"exports && extension.exports.extendMarkdownIt) {"}
{"input":"<s> export function getCommand(args) {<EOL>    return","gt":"new Version(args);"}
{"input":"<s> <EOL>export function read(name, message, silent = false) {<EOL>    let promise = new Promise((resolve, reject) => {<EOL>        let schema = {<EOL>            properties: {}<EOL>        };<EOL>","gt":"schema.properties[name] = {"}
{"input":"<s> <EOL>export function read(name, message, silent = false) {<EOL>    let promise = new Promise((resolve, reject) => {<EOL>        let schema = {<EOL>            properties: {}<EOL>        };<EOL>         schema.properties[name] = {<EOL>            required: true,<EOL>            description: message + \"<STR_LIT>\",<EOL>","gt":"hidden: silent"}
{"input":"<s> <EOL>export function read(name, message, silent = false) {<EOL>    let promise = new Promise((resolve, reject) => {<EOL>        let schema = {<EOL>            properties: {}<EOL>        };<EOL>         schema.properties[name] = {<EOL>            required: true,<EOL>            description: message + \"<STR_LIT>\",<EOL>             hidden: silent<EOL>        };<EOL>        Promise.all(queue.filter((x) => x !== promise)).then(() => {<EOL>            prompt.start();<EOL>            prompt.get(schema, (err, result) => {<EOL>","gt":"if (err) {"}
{"input":"<s> <EOL>export function read(name, message, silent = false) {<EOL>    let promise = new Promise((resolve, reject) => {<EOL>        let schema = {<EOL>            properties: {}<EOL>        };<EOL>         schema.properties[name] = {<EOL>            required: true,<EOL>            description: message + \"<STR_LIT>\",<EOL>             hidden: silent<EOL>        };<EOL>        Promise.all(queue.filter((x) => x !== promise)).then(() => {<EOL>            prompt.start();<EOL>            prompt.get(schema, (err, result) => {<EOL>                 if (err) {<EOL>                    reject(err);<EOL>                }<EOL>                else {<EOL>                    resolve(result[name]);<EOL>                }<EOL>                queue.","gt":"shift();"}
{"input":"<s> export function getFailureStringEmptyAltAndNotPresentationRole(tagName) {<EOL>    return","gt":"tagName}> tag is empty and role value is not presentation. \\"}
{"input":"<s> <EOL>function getImplicitRoleForDd() {<EOL>","gt":"return '<STR_LIT>';"}
{"input":"<s> <EOL>function getImplicitRoleForH3() {<EOL>    return","gt":"'<STR_LIT>';"}
{"input":"<s> <EOL>function getImplicitRoleForOption() {<EOL>    return","gt":"'<STR_LIT>';"}
{"input":"<s> <EOL>export function getAllAttributesFromJsxElement(node) {<EOL>    let attributes = null;<EOL>    if (node == null) {<EOL>        return attributes;<EOL>    }<EOL>    else if (isJsxElement(node)) {<EOL>        attributes = node.openingElement.","gt":"attributes.properties;"}
{"input":"<s> <EOL>export function getBooleanLiteral(node) {<EOL>    if (!isJsxAttribute(node)) {<EOL>        throw new Error('<STR_LIT>');<EOL>    }<EOL>    const initializer = node == null ? null : node.initializer;<EOL>    const getBooleanFromString = (value) => {<EOL>        if (value.toLowerCase() === '<STR_LIT>') {<EOL>","gt":"return true;"}
{"input":"<s> <EOL>export function getBooleanLiteral(node) {<EOL>    if (!isJsxAttribute(node)) {<EOL>        throw new Error('<STR_LIT>');<EOL>    }<EOL>    const initializer = node == null ? null : node.initializer;<EOL>    const getBooleanFromString = (value) => {<EOL>        if (value.toLowerCase() === '<STR_LIT>') {<EOL>             return true;<EOL>        }<EOL>        else if (value.toLowerCase() === '<STR_LIT>') {<EOL>            return false;<EOL>        }<EOL>","gt":"else {"}
{"input":"<s> <EOL>export function getBooleanLiteral(node) {<EOL>    if (!isJsxAttribute(node)) {<EOL>        throw new Error('<STR_LIT>');<EOL>    }<EOL>    const initializer = node == null ? null : node.initializer;<EOL>    const getBooleanFromString = (value) => {<EOL>        if (value.toLowerCase() === '<STR_LIT>') {<EOL>             return true;<EOL>        }<EOL>        else if (value.toLowerCase() === '<STR_LIT>') {<EOL>            return false;<EOL>        }<EOL>         else {<EOL>            return undefined;<EOL>        }<EOL>    };<EOL>    if (isStringLiteral(initializer)) {<EOL>        return getBooleanFromString(initializer.text);<EOL>    }<EOL>    else if (isJsxExpression(initializer)) {<EOL>        const","gt":"expression = initializer.expression;"}
{"input":"<s> <EOL>export function getBooleanLiteral(node) {<EOL>    if (!isJsxAttribute(node)) {<EOL>        throw new Error('<STR_LIT>');<EOL>    }<EOL>    const initializer = node == null ? null : node.initializer;<EOL>    const getBooleanFromString = (value) => {<EOL>        if (value.toLowerCase() === '<STR_LIT>') {<EOL>             return true;<EOL>        }<EOL>        else if (value.toLowerCase() === '<STR_LIT>') {<EOL>            return false;<EOL>        }<EOL>         else {<EOL>            return undefined;<EOL>        }<EOL>    };<EOL>    if (isStringLiteral(initializer)) {<EOL>        return getBooleanFromString(initializer.text);<EOL>    }<EOL>    else if (isJsxExpression(initializer)) {<EOL>        const  expression = initializer.expression;<EOL>        if (isStringLiteral(expression)) {<EOL>            return getBooleanFromString(expression.text);<EOL>        }<EOL>        else {<EOL>            if (isTrueKeyword(expression)) {<EOL>                return true;<EOL>            }<EOL>            else if (","gt":"isFalseKeyword(expression)) {"}
{"input":"<s> export function isTrueKeyword(node) {<EOL>    return node && node.","gt":"kind === ts.SyntaxKind.TrueKeyword;"}
{"input":"<s> export function index(req, res) {<EOL>    db.getUsers(function (users) {<EOL>        console.","gt":"dir(users);"}
{"input":"<s> function max(array, selector) {<EOL>    if (!array) {<EOL>        return <NUM_LIT>;<EOL>    }<EOL>    let","gt":"max = <NUM_LIT>;"}
{"input":"<s> <EOL>function getWXConfig(cb) {<EOL>    request.get('<STR_LIT>' + appId + '<STR_LIT>' + appsecret, (err, res, body) => {<EOL>        request.get('<STR_LIT>' + JSON.parse(body).access_token + '<STR_LIT>', (err, res, body) => {<EOL>            let ticket = JSON.parse(body).ticket;<EOL>            let o =","gt":"{"}
{"input":"<s> <EOL>function getWXConfig(cb) {<EOL>    request.get('<STR_LIT>' + appId + '<STR_LIT>' + appsecret, (err, res, body) => {<EOL>        request.get('<STR_LIT>' + JSON.parse(body).access_token + '<STR_LIT>', (err, res, body) => {<EOL>            let ticket = JSON.parse(body).ticket;<EOL>            let o =  {<EOL>                appId: appId,<EOL>                nonceStr: nonceStr,<EOL>                timestamp: new Date().getTime() / <NUM_LIT> + '<STR_LIT>',<EOL>                signature: '<STR_LIT>'<EOL>            };<EOL>            o.signature = sha1('<STR_LIT>' + ticket + '<STR_LIT>' + o.nonceStr + '<STR_LIT>' + o.","gt":"timestamp + '<STR_LIT>' + url).toString();"}
{"input":"<s> function hasTypes(info) {<EOL>    return","gt":"\"<STR_LIT>\" in info || \"<STR_LIT>\" in info;"}
{"input":"<s> function promisifyErrorOrResult(callsBack) {<EOL>    return new Promise((resolve, reject) => {<EOL>        callsBack((err, result) => {<EOL>            if (err) {<EOL>                reject(","gt":"err);"}
{"input":"<s> async function uploadDirectory(container, uploadedDirPath, dirPath, log, filter) {<EOL>    let files = await readdir(dirPath);<EOL>    if (filter) {<EOL>","gt":"files = files.filter(filter);"}
{"input":"<s> export async function readFileAndThrowOnBOM(directory, fileName) {<EOL>    const full = joinPaths(directory, fileName);<EOL>    const text = await readFile(full);<EOL>    if (text.charCodeAt(<NUM_LIT>) === <NUM_LIT>) {<EOL>","gt":"const commands = ["}
{"input":"<s> export async function readFileAndThrowOnBOM(directory, fileName) {<EOL>    const full = joinPaths(directory, fileName);<EOL>    const text = await readFile(full);<EOL>    if (text.charCodeAt(<NUM_LIT>) === <NUM_LIT>) {<EOL>         const commands = [<EOL>            \"<STR_LIT>\",<EOL>            `<STR_LIT>`,<EOL>            `<STR_LIT>`<EOL>        ];<EOL>        throw","gt":"new Error(`<STR_LIT>`);"}
{"input":"<s> function packageUrl(packageName) {<EOL>    return","gt":"url.resolve(npmRegistry, packageName);"}
{"input":"<s> function* flattenData(data) {<EOL>    for (","gt":"const versions of data.values()) {"}
{"input":"<s> <EOL>export async function fetchAndProcessNpmInfo(escapedPackageName, fetcher) {<EOL>    const info = await fetchNpmInfo(escapedPackageName, fetcher);<EOL>    const version = getVersionSemver(info, false);<EOL>","gt":"const { \"<STR_LIT>\": distTags, versions } = info;"}
{"input":"<s> function getLatestVersion(versions) {<EOL>    return best(Object.keys(versions).map(parseAnySemver), (a, b) => {<EOL>        if (a.isPrerelease && !b.isPrerelease) {<EOL>","gt":"return false;"}
{"input":"<s> export async function isDirectory(path) {<EOL>    return (","gt":"await stat(path)).isDirectory();"}
{"input":"<s> export function done(promise) {<EOL>    promise.catch((error) => {<EOL>        console.","gt":"error(error);"}
{"input":"<s> export function hasWindowsSlashes(path) {<EOL>    return path.includes(","gt":"\"<STR_LIT>\");"}
{"input":"<s> async function writePackage(packageDirectory, packageName) {<EOL>    <EOL>    await writeJson(joinPaths(packageDirectory, \"<STR_LIT>\"), {<EOL>        name: `<STR_LIT>`,<EOL>        version: \"<STR_LIT>\",<EOL>","gt":"description: \"<STR_LIT>\","}
{"input":"<s> async function writePackage(packageDirectory, packageName) {<EOL>    <EOL>    await writeJson(joinPaths(packageDirectory, \"<STR_LIT>\"), {<EOL>        name: `<STR_LIT>`,<EOL>        version: \"<STR_LIT>\",<EOL>         description: \"<STR_LIT>\",<EOL>        author: \"<STR_LIT>\",<EOL>        license: \"<STR_LIT>\",<EOL>        repository:","gt":"\"<STR_LIT>\","}
{"input":"<s> async function writePackage(packageDirectory, packageName) {<EOL>    <EOL>    await writeJson(joinPaths(packageDirectory, \"<STR_LIT>\"), {<EOL>        name: `<STR_LIT>`,<EOL>        version: \"<STR_LIT>\",<EOL>         description: \"<STR_LIT>\",<EOL>        author: \"<STR_LIT>\",<EOL>        license: \"<STR_LIT>\",<EOL>        repository:  \"<STR_LIT>\",<EOL>        dependencies: { [fullNpmName(packageName)]: \"<STR_LIT>\" }<EOL>    });<EOL>    <EOL>    await writeJson(joinPaths(packageDirectory, \"<STR_LIT>\"), {<EOL>","gt":"compilerOptions: {"}
{"input":"<s> async function writePackage(packageDirectory, packageName) {<EOL>    <EOL>    await writeJson(joinPaths(packageDirectory, \"<STR_LIT>\"), {<EOL>        name: `<STR_LIT>`,<EOL>        version: \"<STR_LIT>\",<EOL>         description: \"<STR_LIT>\",<EOL>        author: \"<STR_LIT>\",<EOL>        license: \"<STR_LIT>\",<EOL>        repository:  \"<STR_LIT>\",<EOL>        dependencies: { [fullNpmName(packageName)]: \"<STR_LIT>\" }<EOL>    });<EOL>    <EOL>    await writeJson(joinPaths(packageDirectory, \"<STR_LIT>\"), {<EOL>         compilerOptions: {<EOL>            module: \"<STR_LIT>\",<EOL>            target: \"<STR_LIT>\",<EOL>            noImplicitAny: false,<EOL>            strictNullChecks: false,<EOL>","gt":"noEmit: true,"}
{"input":"<s> <EOL>export function cp(src, dest) {<EOL>    if (fileExistsSync(src)) {<EOL>        let targetFile = dest;<EOL>        if (directoryExistsSync(dest)) {<EOL>            targetFile = path.join(dest, path.basename(src));<EOL>        }<EOL>        if (path.","gt":"relative(src, targetFile)) {"}
{"input":"<s> <EOL>export function cp(src, dest) {<EOL>    if (fileExistsSync(src)) {<EOL>        let targetFile = dest;<EOL>        if (directoryExistsSync(dest)) {<EOL>            targetFile = path.join(dest, path.basename(src));<EOL>        }<EOL>        if (path. relative(src, targetFile)) {<EOL>            <EOL>            return;<EOL>        }<EOL>","gt":"copyFileSync(src, targetFile);"}
{"input":"<s> <EOL>export function cp(src, dest) {<EOL>    if (fileExistsSync(src)) {<EOL>        let targetFile = dest;<EOL>        if (directoryExistsSync(dest)) {<EOL>            targetFile = path.join(dest, path.basename(src));<EOL>        }<EOL>        if (path. relative(src, targetFile)) {<EOL>            <EOL>            return;<EOL>        }<EOL>         copyFileSync(src, targetFile);<EOL>    }<EOL>    else if (directoryExistsSync(src)) {<EOL>        copyFolderRecursivelySync(src,","gt":"dest);"}
{"input":"<s> <EOL>export function fileExistsSync(filePath) {<EOL>    try {<EOL>        return fs.statSync(","gt":"filePath).isFile();"}
{"input":"<s> <EOL>export function isArduinoFile(filePath) {<EOL>    return fileExistsSync(filePath) && (","gt":"path.extname(filePath) === \"<STR_LIT>\" || path.extname(filePath) === \"<STR_LIT>\");"}
{"input":"<s> export function openSettings() {<EOL>    return postHTTP(\"<STR_LIT>\", {}).","gt":"then((response) => response.json());"}
{"input":"<s> <EOL>function positionToOffset(str, desiredLine, desiredCol) {<EOL>    if (desiredLine === <NUM_LIT>) {<EOL>        return desiredCol - <NUM_LIT>;<EOL>    }<EOL>    let","gt":"line = <NUM_LIT>, lastNewLineOffset = -<NUM_LIT>;"}
{"input":"<s> <EOL>function positionToOffset(str, desiredLine, desiredCol) {<EOL>    if (desiredLine === <NUM_LIT>) {<EOL>        return desiredCol - <NUM_LIT>;<EOL>    }<EOL>    let  line = <NUM_LIT>, lastNewLineOffset = -<NUM_LIT>;<EOL>    do {<EOL>        if (desiredLine === line) {<EOL>            return lastNewLineOffset + <NUM_LIT> + desiredCol - <NUM_LIT>;<EOL>        }<EOL>        lastNewLineOffset = str.indexOf('<STR_LIT>', lastNewLineOffset + <NUM_LIT>);<EOL>","gt":"line++;"}
{"input":"<s> export function createXlfFilesForCoreBundle() {<EOL>    return through(function (file) {<EOL>        const basename = path.basename(file.path);<EOL>        if (basename === '<STR_LIT>') {<EOL>            if (file.","gt":"isBuffer()) {"}
{"input":"<s> export function createXlfFilesForCoreBundle() {<EOL>    return through(function (file) {<EOL>        const basename = path.basename(file.path);<EOL>        if (basename === '<STR_LIT>') {<EOL>            if (file. isBuffer()) {<EOL>                const xlfs = Object.create(null);<EOL>                const json = JSON.parse(file.","gt":"contents.toString('<STR_LIT>'));"}
{"input":"<s> export function createXlfFilesForCoreBundle() {<EOL>    return through(function (file) {<EOL>        const basename = path.basename(file.path);<EOL>        if (basename === '<STR_LIT>') {<EOL>            if (file. isBuffer()) {<EOL>                const xlfs = Object.create(null);<EOL>                const json = JSON.parse(file. contents.toString('<STR_LIT>'));<EOL>                for (let coreModule in json.keys) {<EOL>                    const projectResource = getResource(coreModule);<EOL>","gt":"const resource = projectResource.name;"}
{"input":"<s> export function createXlfFilesForCoreBundle() {<EOL>    return through(function (file) {<EOL>        const basename = path.basename(file.path);<EOL>        if (basename === '<STR_LIT>') {<EOL>            if (file. isBuffer()) {<EOL>                const xlfs = Object.create(null);<EOL>                const json = JSON.parse(file. contents.toString('<STR_LIT>'));<EOL>                for (let coreModule in json.keys) {<EOL>                    const projectResource = getResource(coreModule);<EOL>                     const resource = projectResource.name;<EOL>                    const project = projectResource.project;<EOL>                    const keys = json.keys[coreModule];<EOL>                    const messages = json.messages[coreModule];<EOL>                    if (keys.length !== messages.length) {<EOL>                        this.emit('<STR_LIT>',","gt":"file.relative} for module ${coreModule}`<STR_LIT>;"}
{"input":"<s> export function createXlfFilesForCoreBundle() {<EOL>    return through(function (file) {<EOL>        const basename = path.basename(file.path);<EOL>        if (basename === '<STR_LIT>') {<EOL>            if (file. isBuffer()) {<EOL>                const xlfs = Object.create(null);<EOL>                const json = JSON.parse(file. contents.toString('<STR_LIT>'));<EOL>                for (let coreModule in json.keys) {<EOL>                    const projectResource = getResource(coreModule);<EOL>                     const resource = projectResource.name;<EOL>                    const project = projectResource.project;<EOL>                    const keys = json.keys[coreModule];<EOL>                    const messages = json.messages[coreModule];<EOL>                    if (keys.length !== messages.length) {<EOL>                        this.emit('<STR_LIT>', `<STR_LIT>`);<EOL>                        return;<EOL>                    }<EOL>                    else {<EOL>                        let xlf = xlfs[resource];<EOL>","gt":"if (!xlf) {"}
{"input":"<s> export function createXlfFilesForCoreBundle() {<EOL>    return through(function (file) {<EOL>        const basename = path.basename(file.path);<EOL>        if (basename === '<STR_LIT>') {<EOL>            if (file. isBuffer()) {<EOL>                const xlfs = Object.create(null);<EOL>                const json = JSON.parse(file. contents.toString('<STR_LIT>'));<EOL>                for (let coreModule in json.keys) {<EOL>                    const projectResource = getResource(coreModule);<EOL>                     const resource = projectResource.name;<EOL>                    const project = projectResource.project;<EOL>                    const keys = json.keys[coreModule];<EOL>                    const messages = json.messages[coreModule];<EOL>                    if (keys.length !== messages.length) {<EOL>                        this.emit('<STR_LIT>', `<STR_LIT>`);<EOL>                        return;<EOL>                    }<EOL>                    else {<EOL>                        let xlf = xlfs[resource];<EOL>                         if (!xlf) {<EOL>                            xlf = new XLF(project);<EOL>                            xlfs[resource] = xlf;<EOL>                        }<EOL>                        xlf.addFile(`<STR_LIT>`, keys, messages);<EOL>                    }<EOL>                }<EOL>                for (let resource in xlfs) {<EOL>                    const xlf = xlfs[resource];<EOL>                    const filePath = `<STR_LIT>`;<EOL>                    const xlfFile = new File({<EOL>                        path: filePath,<EOL>                        contents: Buffer.from(xlf.toString(), '<STR_LIT>')<EOL>                    });<EOL>                    this.queue(","gt":"xlfFile);"}
{"input":"<s> export function createXlfFilesForCoreBundle() {<EOL>    return through(function (file) {<EOL>        const basename = path.basename(file.path);<EOL>        if (basename === '<STR_LIT>') {<EOL>            if (file. isBuffer()) {<EOL>                const xlfs = Object.create(null);<EOL>                const json = JSON.parse(file. contents.toString('<STR_LIT>'));<EOL>                for (let coreModule in json.keys) {<EOL>                    const projectResource = getResource(coreModule);<EOL>                     const resource = projectResource.name;<EOL>                    const project = projectResource.project;<EOL>                    const keys = json.keys[coreModule];<EOL>                    const messages = json.messages[coreModule];<EOL>                    if (keys.length !== messages.length) {<EOL>                        this.emit('<STR_LIT>', `<STR_LIT>`);<EOL>                        return;<EOL>                    }<EOL>                    else {<EOL>                        let xlf = xlfs[resource];<EOL>                         if (!xlf) {<EOL>                            xlf = new XLF(project);<EOL>                            xlfs[resource] = xlf;<EOL>                        }<EOL>                        xlf.addFile(`<STR_LIT>`, keys, messages);<EOL>                    }<EOL>                }<EOL>                for (let resource in xlfs) {<EOL>                    const xlf = xlfs[resource];<EOL>                    const filePath = `<STR_LIT>`;<EOL>                    const xlfFile = new File({<EOL>                        path: filePath,<EOL>                        contents: Buffer.from(xlf.toString(), '<STR_LIT>')<EOL>                    });<EOL>                    this.queue( xlfFile);<EOL>                }<EOL>            }<EOL>            else {<EOL>                this.emit('<STR_LIT>', new Error(`<STR_LIT>`));<EOL>","gt":"return;"}
{"input":"<s> export function processNlsFiles(opts) {<EOL>    return through(function (file) {<EOL>        let fileName = path.basename(file.path);<EOL>        if (fileName === '<STR_LIT>') {<EOL>            let json = null;<EOL>            if (file.isBuffer()) {<EOL>                json = JSON.parse(file.","gt":"contents.toString('<STR_LIT>'));"}
{"input":"<s> export function processNlsFiles(opts) {<EOL>    return through(function (file) {<EOL>        let fileName = path.basename(file.path);<EOL>        if (fileName === '<STR_LIT>') {<EOL>            let json = null;<EOL>            if (file.isBuffer()) {<EOL>                json = JSON.parse(file. contents.toString('<STR_LIT>'));<EOL>            }<EOL>            else {<EOL>                this.emit('<STR_LIT>', `<STR_LIT>`);<EOL>","gt":"return;"}
{"input":"<s> export function processNlsFiles(opts) {<EOL>    return through(function (file) {<EOL>        let fileName = path.basename(file.path);<EOL>        if (fileName === '<STR_LIT>') {<EOL>            let json = null;<EOL>            if (file.isBuffer()) {<EOL>                json = JSON.parse(file. contents.toString('<STR_LIT>'));<EOL>            }<EOL>            else {<EOL>                this.emit('<STR_LIT>', `<STR_LIT>`);<EOL>                 return;<EOL>            }<EOL>            if (BundledFormat.is(json)) {<EOL>                processCoreBundleFormat(opts.","gt":"fileHeader, opts.languages, json, this);"}
{"input":"<s> function clone(object) {<EOL>    var result = {};<EOL>","gt":"for (var id in object) {"}
{"input":"<s> function visitTopLevelDeclarations(sourceFile, visitor) {<EOL>    let stop = false;<EOL>    let visit = (node) => {<EOL>        if (stop) {<EOL>            return;<EOL>        }<EOL>        switch (node.kind) {<EOL>            case ts.SyntaxKind.InterfaceDeclaration:<EOL>            case ts.SyntaxKind.EnumDeclaration:<EOL>            case ts.SyntaxKind.","gt":"ClassDeclaration:"}
{"input":"<s> function visitTopLevelDeclarations(sourceFile, visitor) {<EOL>    let stop = false;<EOL>    let visit = (node) => {<EOL>        if (stop) {<EOL>            return;<EOL>        }<EOL>        switch (node.kind) {<EOL>            case ts.SyntaxKind.InterfaceDeclaration:<EOL>            case ts.SyntaxKind.EnumDeclaration:<EOL>            case ts.SyntaxKind. ClassDeclaration:<EOL>            case ts.SyntaxKind.VariableStatement:<EOL>            case ts.SyntaxKind.TypeAliasDeclaration:<EOL>","gt":"case ts.SyntaxKind.FunctionDeclaration:"}
{"input":"<s> function callbackCaller2(cb) {<EOL>","gt":"cb();"}
{"input":"<s> function makeCompletionItem(rawSnippet) {<EOL>    const item = new CompletionItem(rawSnippet.prefix);<EOL>    item.documentation = rawSnippet.","gt":"description;"}
{"input":"<s> export function enumerateListOfTypeDefinitions(projectRoot) {<EOL>    let typeDefsFolder = CordovaProjectHelper.getCordovaPluginTypeDefsPath(projectRoot);<EOL>    <EOL>","gt":"if (!CordovaProjectHelper.existsSync(typeDefsFolder)) {"}
{"input":"<s> export function asFolder(uri) {<EOL>    let result = uri.toString();<EOL>","gt":"if (result.charAt(result.length - <NUM_LIT>) !== '<STR_LIT>') {"}
{"input":"<s> <EOL>export function checkInstallLockFile() {<EOL>    return","gt":"checkFileExists(getInstallLockPath());"}
{"input":"<s> export function resolveVariables(input) {<EOL>    if (input === null) {<EOL>        return \"<STR_LIT>\";<EOL>    }<EOL>    <EOL>","gt":"let regexp = /\\$\\{((env|config)(.|:))?(.*?)\\}/g;"}
{"input":"<s> export function resolveVariables(input) {<EOL>    if (input === null) {<EOL>        return \"<STR_LIT>\";<EOL>    }<EOL>    <EOL>     let regexp = /\\$\\{((env|config)(.|:))?(.*?)\\}/g;<EOL>    let ret = input.replace(regexp, (match, ignored1, varType, ignored2, name) => {<EOL>        <EOL>        <EOL>        if (varType === undefined) {<EOL>            varType = \"<STR_LIT>\";<EOL>        }<EOL>        let","gt":"newValue = undefined;"}
{"input":"<s> export function resolveVariables(input) {<EOL>    if (input === null) {<EOL>        return \"<STR_LIT>\";<EOL>    }<EOL>    <EOL>     let regexp = /\\$\\{((env|config)(.|:))?(.*?)\\}/g;<EOL>    let ret = input.replace(regexp, (match, ignored1, varType, ignored2, name) => {<EOL>        <EOL>        <EOL>        if (varType === undefined) {<EOL>            varType = \"<STR_LIT>\";<EOL>        }<EOL>        let  newValue = undefined;<EOL>        switch (varType) {<EOL>            case \"<STR_LIT>\": {<EOL>                newValue = process.env[name];<EOL>","gt":"break;"}
{"input":"<s> export function resolveVariables(input) {<EOL>    if (input === null) {<EOL>        return \"<STR_LIT>\";<EOL>    }<EOL>    <EOL>     let regexp = /\\$\\{((env|config)(.|:))?(.*?)\\}/g;<EOL>    let ret = input.replace(regexp, (match, ignored1, varType, ignored2, name) => {<EOL>        <EOL>        <EOL>        if (varType === undefined) {<EOL>            varType = \"<STR_LIT>\";<EOL>        }<EOL>        let  newValue = undefined;<EOL>        switch (varType) {<EOL>            case \"<STR_LIT>\": {<EOL>                newValue = process.env[name];<EOL>                 break;<EOL>            }<EOL>            case \"<STR_LIT>\": {<EOL>                let config = vscode.workspace.getConfiguration();<EOL>                let keys =","gt":"name.split('<STR_LIT>');"}
{"input":"<s> export function spawnChildProcess(process, args, workingDirectory, dataCallback, errorCallback) {<EOL>    return new Promise(function (resolve, reject) {<EOL>        const child = child_process.spawn(process, args, { cwd: workingDirectory });<EOL>        child.stdout.on('<STR_LIT>', (data) => {<EOL>            dataCallback(`<STR_LIT>`);<EOL>        });<EOL>        child.stderr.on(","gt":"'<STR_LIT>', (data) => {"}
{"input":"<s> export function spawnChildProcess(process, args, workingDirectory, dataCallback, errorCallback) {<EOL>    return new Promise(function (resolve, reject) {<EOL>        const child = child_process.spawn(process, args, { cwd: workingDirectory });<EOL>        child.stdout.on('<STR_LIT>', (data) => {<EOL>            dataCallback(`<STR_LIT>`);<EOL>        });<EOL>        child.stderr.on( '<STR_LIT>', (data) => {<EOL>            errorCallback(`<STR_LIT>`);<EOL>        });<EOL>        child.on('<STR_LIT>', (code) => {<EOL>            if (code !==","gt":"<NUM_LIT>) {"}
{"input":"<s> export function spawnChildProcess(process, args, workingDirectory, dataCallback, errorCallback) {<EOL>    return new Promise(function (resolve, reject) {<EOL>        const child = child_process.spawn(process, args, { cwd: workingDirectory });<EOL>        child.stdout.on('<STR_LIT>', (data) => {<EOL>            dataCallback(`<STR_LIT>`);<EOL>        });<EOL>        child.stderr.on( '<STR_LIT>', (data) => {<EOL>            errorCallback(`<STR_LIT>`);<EOL>        });<EOL>        child.on('<STR_LIT>', (code) => {<EOL>            if (code !==  <NUM_LIT>) {<EOL>                reject(new Error(`<STR_LIT>`));<EOL>            }<EOL>","gt":"else {"}
{"input":"<s> function CreateRemoteAttachString(name, type, executable) {<EOL>    return","gt":"executable}\"<STR_LIT>,"}
{"input":"<s> function getMessage(err, document) {<EOL>    let result = null;<EOL>    if (typeof err.message === '<STR_LIT>' || err.message instanceof String) {<EOL>        result = err.message;<EOL>        result = result.replace(/\\r?\\n/g,","gt":"'<STR_LIT>');"}
{"input":"<s> function getMessage(err, document) {<EOL>    let result = null;<EOL>    if (typeof err.message === '<STR_LIT>' || err.message instanceof String) {<EOL>        result = err.message;<EOL>        result = result.replace(/\\r?\\n/g,  '<STR_LIT>');<EOL>        if (/^CLI: /.test(result)) {<EOL>            result = result.substr(<NUM_LIT>);<EOL>        }<EOL>    }<EOL>    else {<EOL>","gt":"result = `<STR_LIT>`;"}
{"input":"<s> export function activate(context) {<EOL>    <EOL>    const status = window.createStatusBarItem(StatusBarAlignment.Left, <NUM_LIT>);<EOL>    context.subscriptions.push(status);<EOL>    <EOL>    context.subscriptions.push(workspace.onDidChangeWorkspaceFolders((e) => updateStatus(status)));<EOL>    <EOL>    context.subscriptions.push(workspace.onDidChangeConfiguration((e) => this.updateStatus(status)));<EOL>    <EOL>    context.subscriptions.push(window.onDidChangeActiveTextEditor((e) => updateStatus(status)));<EOL>    context.subscriptions.push(","gt":"window.onDidChangeTextEditorViewColumn((e) => updateStatus(status)));"}
{"input":"<s> export function deactivate() {<EOL>    if (!client) {<EOL>","gt":"return undefined;"}
{"input":"<s> export function activate(context) {<EOL>    const registration = vscode.languages.registerDocumentLinkProvider({ language: '<STR_LIT>', pattern: '<STR_LIT>' }, _linkProvider);<EOL>","gt":"context.subscriptions.push(registration);"}
{"input":"<s> function _memoize(fn, key) {<EOL>    const memoizeKey = `<STR_LIT>`;<EOL>    return function (...args) {<EOL>        if (!this.hasOwnProperty(memoizeKey)) {<EOL>","gt":"Object.defineProperty(this, memoizeKey, {"}
{"input":"<s> function findGitWin32(onLookup) {<EOL>    return findSystemGitWin32(process.env['<STR_LIT>'], onLookup)<EOL>        .","gt":"then(void <NUM_LIT>, () => findSystemGitWin32(process.env['<STR_LIT>'], onLookup))"}
{"input":"<s> export function assign(destination, ...sources) {<EOL>    for (const source of sources) {<EOL>        Object.keys(source).","gt":"forEach((key) => destination[key] = source[key]);"}
{"input":"<s> export function detectUnicodeEncoding(buffer) {<EOL>    if (buffer.length < <NUM_LIT>) {<EOL>        return null;<EOL>    }<EOL>    const b0 = buffer.readUInt8(<NUM_LIT>);<EOL>    const b1 = buffer.readUInt8(<NUM_LIT>);<EOL>","gt":"if (b0 === <NUM_LIT> && b1 === <NUM_LIT>) {"}
{"input":"<s> export function detectUnicodeEncoding(buffer) {<EOL>    if (buffer.length < <NUM_LIT>) {<EOL>        return null;<EOL>    }<EOL>    const b0 = buffer.readUInt8(<NUM_LIT>);<EOL>    const b1 = buffer.readUInt8(<NUM_LIT>);<EOL>     if (b0 === <NUM_LIT> && b1 === <NUM_LIT>) {<EOL>        return Encoding.UTF16be;<EOL>    }<EOL>    if (b0 === <NUM_LIT> && b1 === <NUM_LIT>) {<EOL>        return Encoding.UTF16le;<EOL>    }<EOL>    if (buffer.length < <NUM_LIT>) {<EOL>        return null;<EOL>    }<EOL>    const b2 = buffer.readUInt8(","gt":"<NUM_LIT>);"}
{"input":"<s> export function find(array, fn) {<EOL>    let result = undefined;<EOL>    array.some((e) => {<EOL>        if (","gt":"fn(e)) {"}
{"input":"<s> function cleanPendingValidation(textDocument) {<EOL>    let request = pendingValidationRequests[textDocument.uri];<EOL>","gt":"if (request) {"}
{"input":"<s> function getPackageInfo(context) {<EOL>    let extensionPackage = require(context.asAbsolutePath('<STR_LIT>'));<EOL>    if (extensionPackage) {<EOL>","gt":"return {"}
{"input":"<s> function cleanPendingValidation(textDocument) {<EOL>    let request = pendingValidationRequests[textDocument.uri];<EOL>    if (","gt":"request) {"}
{"input":"<s> function isBuildTask(name) {<EOL>    for (let buildName of buildNames) {<EOL>        if (","gt":"name.indexOf(buildName) !== -<NUM_LIT>) {"}
{"input":"<s> export function fork(modulePath, args, options, logger, callback) {<EOL>    let callbackCalled = false;<EOL>    const resolve = (result) => {<EOL>        if (","gt":"callbackCalled) {"}
{"input":"<s> export function fork(modulePath, args, options, logger, callback) {<EOL>    let callbackCalled = false;<EOL>    const resolve = (result) => {<EOL>        if ( callbackCalled) {<EOL>            return;<EOL>        }<EOL>        callbackCalled =","gt":"true;"}
{"input":"<s> export function fork(modulePath, args, options, logger, callback) {<EOL>    let callbackCalled = false;<EOL>    const resolve = (result) => {<EOL>        if ( callbackCalled) {<EOL>            return;<EOL>        }<EOL>        callbackCalled =  true;<EOL>        callback(null, result);<EOL>    };<EOL>    const reject = (err) => {<EOL>        if (callbackCalled) {<EOL>            return;<EOL>        }<EOL>","gt":"callbackCalled = true;"}
{"input":"<s> export function fork(modulePath, args, options, logger, callback) {<EOL>    let callbackCalled = false;<EOL>    const resolve = (result) => {<EOL>        if ( callbackCalled) {<EOL>            return;<EOL>        }<EOL>        callbackCalled =  true;<EOL>        callback(null, result);<EOL>    };<EOL>    const reject = (err) => {<EOL>        if (callbackCalled) {<EOL>            return;<EOL>        }<EOL>         callbackCalled = true;<EOL>        callback(err, null);<EOL>    };<EOL>    <EOL>    const stdInPipeName = generatePipeName();<EOL>    const stdOutPipeName = generatePipeName();<EOL>    const stdErrPipeName = generatePipeName();<EOL>    const newEnv = generatePatchedEnv(process.env, stdInPipeName, stdOutPipeName, stdErrPipeName);<EOL>    newEnv['<STR_LIT>'] =","gt":"path.join(modulePath, '<STR_LIT>', '<STR_LIT>', '<STR_LIT>');"}
{"input":"<s> export function fork(modulePath, args, options, logger, callback) {<EOL>    let callbackCalled = false;<EOL>    const resolve = (result) => {<EOL>        if ( callbackCalled) {<EOL>            return;<EOL>        }<EOL>        callbackCalled =  true;<EOL>        callback(null, result);<EOL>    };<EOL>    const reject = (err) => {<EOL>        if (callbackCalled) {<EOL>            return;<EOL>        }<EOL>         callbackCalled = true;<EOL>        callback(err, null);<EOL>    };<EOL>    <EOL>    const stdInPipeName = generatePipeName();<EOL>    const stdOutPipeName = generatePipeName();<EOL>    const stdErrPipeName = generatePipeName();<EOL>    const newEnv = generatePatchedEnv(process.env, stdInPipeName, stdOutPipeName, stdErrPipeName);<EOL>    newEnv['<STR_LIT>'] =  path.join(modulePath, '<STR_LIT>', '<STR_LIT>', '<STR_LIT>');<EOL>    let childProcess;<EOL>    <EOL>    let stdErrServer = net.createServer((stdErrStream) => {<EOL>        <EOL>        childProcess.stderr = stdErrStream;<EOL>    });<EOL>    stdErrServer.listen(","gt":"stdErrPipeName);"}
{"input":"<s> export function fork(modulePath, args, options, logger, callback) {<EOL>    let callbackCalled = false;<EOL>    const resolve = (result) => {<EOL>        if ( callbackCalled) {<EOL>            return;<EOL>        }<EOL>        callbackCalled =  true;<EOL>        callback(null, result);<EOL>    };<EOL>    const reject = (err) => {<EOL>        if (callbackCalled) {<EOL>            return;<EOL>        }<EOL>         callbackCalled = true;<EOL>        callback(err, null);<EOL>    };<EOL>    <EOL>    const stdInPipeName = generatePipeName();<EOL>    const stdOutPipeName = generatePipeName();<EOL>    const stdErrPipeName = generatePipeName();<EOL>    const newEnv = generatePatchedEnv(process.env, stdInPipeName, stdOutPipeName, stdErrPipeName);<EOL>    newEnv['<STR_LIT>'] =  path.join(modulePath, '<STR_LIT>', '<STR_LIT>', '<STR_LIT>');<EOL>    let childProcess;<EOL>    <EOL>    let stdErrServer = net.createServer((stdErrStream) => {<EOL>        <EOL>        childProcess.stderr = stdErrStream;<EOL>    });<EOL>    stdErrServer.listen( stdErrPipeName);<EOL>    <EOL>    let stdOutServer = net.createServer((stdOutStream) => {<EOL>        <EOL>        stdOutStream.once('<STR_LIT>', (_chunk) => {<EOL>            <EOL>            childProcess.stdin = net.connect(stdInPipeName);<EOL>            <EOL>","gt":"childProcess.stdout = stdOutStream;"}
{"input":"<s> export function fork(modulePath, args, options, logger, callback) {<EOL>    let callbackCalled = false;<EOL>    const resolve = (result) => {<EOL>        if ( callbackCalled) {<EOL>            return;<EOL>        }<EOL>        callbackCalled =  true;<EOL>        callback(null, result);<EOL>    };<EOL>    const reject = (err) => {<EOL>        if (callbackCalled) {<EOL>            return;<EOL>        }<EOL>         callbackCalled = true;<EOL>        callback(err, null);<EOL>    };<EOL>    <EOL>    const stdInPipeName = generatePipeName();<EOL>    const stdOutPipeName = generatePipeName();<EOL>    const stdErrPipeName = generatePipeName();<EOL>    const newEnv = generatePatchedEnv(process.env, stdInPipeName, stdOutPipeName, stdErrPipeName);<EOL>    newEnv['<STR_LIT>'] =  path.join(modulePath, '<STR_LIT>', '<STR_LIT>', '<STR_LIT>');<EOL>    let childProcess;<EOL>    <EOL>    let stdErrServer = net.createServer((stdErrStream) => {<EOL>        <EOL>        childProcess.stderr = stdErrStream;<EOL>    });<EOL>    stdErrServer.listen( stdErrPipeName);<EOL>    <EOL>    let stdOutServer = net.createServer((stdOutStream) => {<EOL>        <EOL>        stdOutStream.once('<STR_LIT>', (_chunk) => {<EOL>            <EOL>            childProcess.stdin = net.connect(stdInPipeName);<EOL>            <EOL>             childProcess.stdout = stdOutStream;<EOL>            resolve(childProcess);<EOL>        });<EOL>    });<EOL>    stdOutServer.","gt":"listen(stdOutPipeName);"}
{"input":"<s> export function fork(modulePath, args, options, logger, callback) {<EOL>    let callbackCalled = false;<EOL>    const resolve = (result) => {<EOL>        if ( callbackCalled) {<EOL>            return;<EOL>        }<EOL>        callbackCalled =  true;<EOL>        callback(null, result);<EOL>    };<EOL>    const reject = (err) => {<EOL>        if (callbackCalled) {<EOL>            return;<EOL>        }<EOL>         callbackCalled = true;<EOL>        callback(err, null);<EOL>    };<EOL>    <EOL>    const stdInPipeName = generatePipeName();<EOL>    const stdOutPipeName = generatePipeName();<EOL>    const stdErrPipeName = generatePipeName();<EOL>    const newEnv = generatePatchedEnv(process.env, stdInPipeName, stdOutPipeName, stdErrPipeName);<EOL>    newEnv['<STR_LIT>'] =  path.join(modulePath, '<STR_LIT>', '<STR_LIT>', '<STR_LIT>');<EOL>    let childProcess;<EOL>    <EOL>    let stdErrServer = net.createServer((stdErrStream) => {<EOL>        <EOL>        childProcess.stderr = stdErrStream;<EOL>    });<EOL>    stdErrServer.listen( stdErrPipeName);<EOL>    <EOL>    let stdOutServer = net.createServer((stdOutStream) => {<EOL>        <EOL>        stdOutStream.once('<STR_LIT>', (_chunk) => {<EOL>            <EOL>            childProcess.stdin = net.connect(stdInPipeName);<EOL>            <EOL>             childProcess.stdout = stdOutStream;<EOL>            resolve(childProcess);<EOL>        });<EOL>    });<EOL>    stdOutServer. listen(stdOutPipeName);<EOL>    let serverClosed = false;<EOL>    const","gt":"closeServer = () => {"}
{"input":"<s> export function fork(modulePath, args, options, logger, callback) {<EOL>    let callbackCalled = false;<EOL>    const resolve = (result) => {<EOL>        if ( callbackCalled) {<EOL>            return;<EOL>        }<EOL>        callbackCalled =  true;<EOL>        callback(null, result);<EOL>    };<EOL>    const reject = (err) => {<EOL>        if (callbackCalled) {<EOL>            return;<EOL>        }<EOL>         callbackCalled = true;<EOL>        callback(err, null);<EOL>    };<EOL>    <EOL>    const stdInPipeName = generatePipeName();<EOL>    const stdOutPipeName = generatePipeName();<EOL>    const stdErrPipeName = generatePipeName();<EOL>    const newEnv = generatePatchedEnv(process.env, stdInPipeName, stdOutPipeName, stdErrPipeName);<EOL>    newEnv['<STR_LIT>'] =  path.join(modulePath, '<STR_LIT>', '<STR_LIT>', '<STR_LIT>');<EOL>    let childProcess;<EOL>    <EOL>    let stdErrServer = net.createServer((stdErrStream) => {<EOL>        <EOL>        childProcess.stderr = stdErrStream;<EOL>    });<EOL>    stdErrServer.listen( stdErrPipeName);<EOL>    <EOL>    let stdOutServer = net.createServer((stdOutStream) => {<EOL>        <EOL>        stdOutStream.once('<STR_LIT>', (_chunk) => {<EOL>            <EOL>            childProcess.stdin = net.connect(stdInPipeName);<EOL>            <EOL>             childProcess.stdout = stdOutStream;<EOL>            resolve(childProcess);<EOL>        });<EOL>    });<EOL>    stdOutServer. listen(stdOutPipeName);<EOL>    let serverClosed = false;<EOL>    const  closeServer = () => {<EOL>        if (serverClosed) {<EOL>            return;<EOL>        }<EOL>        serverClosed = true;<EOL>        stdOutServer.close();<EOL>        stdErrServer.close();<EOL>    };<EOL>    <EOL>    logger.info('<STR_LIT>', `<STR_LIT>`);<EOL>    const bootstrapperPath = require.resolve('<STR_LIT>');<EOL>    childProcess = cp.fork(bootstrapperPath, [modulePath].concat(args), {<EOL>        silent: true,<EOL>","gt":"cwd: options.cwd,"}
{"input":"<s> export function fork(modulePath, args, options, logger, callback) {<EOL>    let callbackCalled = false;<EOL>    const resolve = (result) => {<EOL>        if ( callbackCalled) {<EOL>            return;<EOL>        }<EOL>        callbackCalled =  true;<EOL>        callback(null, result);<EOL>    };<EOL>    const reject = (err) => {<EOL>        if (callbackCalled) {<EOL>            return;<EOL>        }<EOL>         callbackCalled = true;<EOL>        callback(err, null);<EOL>    };<EOL>    <EOL>    const stdInPipeName = generatePipeName();<EOL>    const stdOutPipeName = generatePipeName();<EOL>    const stdErrPipeName = generatePipeName();<EOL>    const newEnv = generatePatchedEnv(process.env, stdInPipeName, stdOutPipeName, stdErrPipeName);<EOL>    newEnv['<STR_LIT>'] =  path.join(modulePath, '<STR_LIT>', '<STR_LIT>', '<STR_LIT>');<EOL>    let childProcess;<EOL>    <EOL>    let stdErrServer = net.createServer((stdErrStream) => {<EOL>        <EOL>        childProcess.stderr = stdErrStream;<EOL>    });<EOL>    stdErrServer.listen( stdErrPipeName);<EOL>    <EOL>    let stdOutServer = net.createServer((stdOutStream) => {<EOL>        <EOL>        stdOutStream.once('<STR_LIT>', (_chunk) => {<EOL>            <EOL>            childProcess.stdin = net.connect(stdInPipeName);<EOL>            <EOL>             childProcess.stdout = stdOutStream;<EOL>            resolve(childProcess);<EOL>        });<EOL>    });<EOL>    stdOutServer. listen(stdOutPipeName);<EOL>    let serverClosed = false;<EOL>    const  closeServer = () => {<EOL>        if (serverClosed) {<EOL>            return;<EOL>        }<EOL>        serverClosed = true;<EOL>        stdOutServer.close();<EOL>        stdErrServer.close();<EOL>    };<EOL>    <EOL>    logger.info('<STR_LIT>', `<STR_LIT>`);<EOL>    const bootstrapperPath = require.resolve('<STR_LIT>');<EOL>    childProcess = cp.fork(bootstrapperPath, [modulePath].concat(args), {<EOL>        silent: true,<EOL>         cwd: options.cwd,<EOL>        env: newEnv,<EOL>        execArgv:","gt":"options."}
{"input":"<s> export function fork(modulePath, args, options, logger, callback) {<EOL>    let callbackCalled = false;<EOL>    const resolve = (result) => {<EOL>        if ( callbackCalled) {<EOL>            return;<EOL>        }<EOL>        callbackCalled =  true;<EOL>        callback(null, result);<EOL>    };<EOL>    const reject = (err) => {<EOL>        if (callbackCalled) {<EOL>            return;<EOL>        }<EOL>         callbackCalled = true;<EOL>        callback(err, null);<EOL>    };<EOL>    <EOL>    const stdInPipeName = generatePipeName();<EOL>    const stdOutPipeName = generatePipeName();<EOL>    const stdErrPipeName = generatePipeName();<EOL>    const newEnv = generatePatchedEnv(process.env, stdInPipeName, stdOutPipeName, stdErrPipeName);<EOL>    newEnv['<STR_LIT>'] =  path.join(modulePath, '<STR_LIT>', '<STR_LIT>', '<STR_LIT>');<EOL>    let childProcess;<EOL>    <EOL>    let stdErrServer = net.createServer((stdErrStream) => {<EOL>        <EOL>        childProcess.stderr = stdErrStream;<EOL>    });<EOL>    stdErrServer.listen( stdErrPipeName);<EOL>    <EOL>    let stdOutServer = net.createServer((stdOutStream) => {<EOL>        <EOL>        stdOutStream.once('<STR_LIT>', (_chunk) => {<EOL>            <EOL>            childProcess.stdin = net.connect(stdInPipeName);<EOL>            <EOL>             childProcess.stdout = stdOutStream;<EOL>            resolve(childProcess);<EOL>        });<EOL>    });<EOL>    stdOutServer. listen(stdOutPipeName);<EOL>    let serverClosed = false;<EOL>    const  closeServer = () => {<EOL>        if (serverClosed) {<EOL>            return;<EOL>        }<EOL>        serverClosed = true;<EOL>        stdOutServer.close();<EOL>        stdErrServer.close();<EOL>    };<EOL>    <EOL>    logger.info('<STR_LIT>', `<STR_LIT>`);<EOL>    const bootstrapperPath = require.resolve('<STR_LIT>');<EOL>    childProcess = cp.fork(bootstrapperPath, [modulePath].concat(args), {<EOL>        silent: true,<EOL>         cwd: options.cwd,<EOL>        env: newEnv,<EOL>        execArgv:  options.","gt":"execArgv"}
{"input":"<s> <EOL>export function toggleTestFile() {<EOL>    let editor = vscode.window.activeTextEditor;<EOL>    if (!editor) {<EOL>        vscode.window.showInformationMessage('<STR_LIT>');<EOL>        return;<EOL>    }<EOL>    let currentFilePath = editor.document.fileName;<EOL>    if (!currentFilePath.endsWith('<STR_LIT>')) {<EOL>        vscode.","gt":"window.showInformationMessage('<STR_LIT>');"}
{"input":"<s> <EOL>export function toggleTestFile() {<EOL>    let editor = vscode.window.activeTextEditor;<EOL>    if (!editor) {<EOL>        vscode.window.showInformationMessage('<STR_LIT>');<EOL>        return;<EOL>    }<EOL>    let currentFilePath = editor.document.fileName;<EOL>    if (!currentFilePath.endsWith('<STR_LIT>')) {<EOL>        vscode. window.showInformationMessage('<STR_LIT>');<EOL>        return;<EOL>    }<EOL>    let targetFilePath = '<STR_LIT>';<EOL>    if (currentFilePath.endsWith('<STR_LIT>')) {<EOL>        targetFilePath = currentFilePath.substr(<NUM_LIT>, currentFilePath.lastIndexOf('<STR_LIT>')) +","gt":"'<STR_LIT>';"}
{"input":"<s> <EOL>export function toggleTestFile() {<EOL>    let editor = vscode.window.activeTextEditor;<EOL>    if (!editor) {<EOL>        vscode.window.showInformationMessage('<STR_LIT>');<EOL>        return;<EOL>    }<EOL>    let currentFilePath = editor.document.fileName;<EOL>    if (!currentFilePath.endsWith('<STR_LIT>')) {<EOL>        vscode. window.showInformationMessage('<STR_LIT>');<EOL>        return;<EOL>    }<EOL>    let targetFilePath = '<STR_LIT>';<EOL>    if (currentFilePath.endsWith('<STR_LIT>')) {<EOL>        targetFilePath = currentFilePath.substr(<NUM_LIT>, currentFilePath.lastIndexOf('<STR_LIT>')) +  '<STR_LIT>';<EOL>    }<EOL>    else {<EOL>        targetFilePath = currentFilePath.substr(<NUM_LIT>, currentFilePath.lastIndexOf('<STR_LIT>')) + '<STR_LIT>';<EOL>    }<EOL>    for (let doc of vscode.window.visibleTextEditors) {<EOL>        if (","gt":"doc.document.fileName === targetFilePath) {"}
{"input":"<s> function expandFilePathInOutput(output, cwd) {<EOL>    let lines = output.split('<STR_LIT>');<EOL>    for (let i = <NUM_LIT>; i < lines.length; i++) {<EOL>        let matches =","gt":"lines[i].match(/^\\s+(\\S+_test.go):(\\d+):/);"}
{"input":"<s> export function getBinPath(tool) {<EOL>    return getBinPathWithPreferredGopath(tool, getToolsGopath(),","gt":"getCurrentGoPath());"}
{"input":"<s> <EOL>export function isVendorSupported() {<EOL>    if (vendorSupport != null) {<EOL>        return Promise.resolve(vendorSupport);<EOL>    }<EOL>    return getGoVersion().","gt":"then((version) => {"}
{"input":"<s> <EOL>export function isVendorSupported() {<EOL>    if (vendorSupport != null) {<EOL>        return Promise.resolve(vendorSupport);<EOL>    }<EOL>    return getGoVersion(). then((version) => {<EOL>        if (!version) {<EOL>            return process.env['<STR_LIT>'] === '<STR_LIT>' ? false : true;<EOL>        }<EOL>        switch (version.major) {<EOL>            case <NUM_LIT>:<EOL>                vendorSupport = false;<EOL>","gt":"break;"}
{"input":"<s> <EOL>export function isVendorSupported() {<EOL>    if (vendorSupport != null) {<EOL>        return Promise.resolve(vendorSupport);<EOL>    }<EOL>    return getGoVersion(). then((version) => {<EOL>        if (!version) {<EOL>            return process.env['<STR_LIT>'] === '<STR_LIT>' ? false : true;<EOL>        }<EOL>        switch (version.major) {<EOL>            case <NUM_LIT>:<EOL>                vendorSupport = false;<EOL>                 break;<EOL>            case <NUM_LIT>:<EOL>                vendorSupport = (version.minor > <NUM_LIT> || ((version.minor === <NUM_LIT> || version.minor === <NUM_LIT>) && process.env['<STR_LIT>'] === '<STR_LIT>')) ? true : false;<EOL>                break;<EOL>            default:<EOL>","gt":"vendorSupport = true;"}
{"input":"<s> export function isUUID(value) {<EOL>","gt":"return _UUIDPattern.test(value);"}
{"input":"<s> export function v4() {<EOL>    return","gt":"new V4UUID();"}
{"input":"<s> function setupExitTimer() {<EOL>    const argName = '<STR_LIT>';<EOL>    function runTimer(value) {<EOL>","gt":"try {"}
{"input":"<s> function setupExitTimer() {<EOL>    const argName = '<STR_LIT>';<EOL>    function runTimer(value) {<EOL>         try {<EOL>            let processId = parseInt(value);<EOL>            if (!isNaN(processId)) {<EOL>                exitTimer = setInterval(() => {<EOL>","gt":"try {"}
{"input":"<s> function setupExitTimer() {<EOL>    const argName = '<STR_LIT>';<EOL>    function runTimer(value) {<EOL>         try {<EOL>            let processId = parseInt(value);<EOL>            if (!isNaN(processId)) {<EOL>                exitTimer = setInterval(() => {<EOL>                     try {<EOL>                        process.kill(processId, <NUM_LIT>);<EOL>                    }<EOL>                    catch (ex) {<EOL>                        <EOL>                        process.exit(shutdownReceived ? <NUM_LIT> : <NUM_LIT>);<EOL>                    }<EOL>                },","gt":"<NUM_LIT>);"}
{"input":"<s> export function isUUID(value) {<EOL>    return","gt":"_UUIDPattern.test(value);"}
{"input":"<s> function _readCoverOptions(testsRoot) {<EOL>    let coverConfigPath = paths.join(testsRoot, testOptions.coverConfig);<EOL>    let coverConfig = undefined;<EOL>    if (fs.","gt":"existsSync(coverConfigPath)) {"}
{"input":"<s> <EOL>function setupStandardQueryRequestServiceMock(testSqlToolsServerClient, returnCallback) {<EOL>    testSqlToolsServerClient.setup((x) => x.sendRequest(TypeMoq.It.isValue(QueryExecuteContracts.QueryExecuteRequest.type), TypeMoq.It.isAny()))<EOL>        .callback((type, details) => {<EOL>        assert.","gt":"equal(details.ownerUri, standardUri);"}
{"input":"<s> export function addDisposableNonBubblingMouseOutListener(node, handler) {<EOL>    return addDisposableListener(node, '<STR_LIT>', (e) => {<EOL>        <EOL>        let toElement = (e.relatedTarget || e.toElement);<EOL>        while (","gt":"toElement && toElement !== node) {"}
{"input":"<s> <EOL>export function getDomNodePagePosition(domNode) {<EOL>    let bb = domNode.getBoundingClientRect();<EOL>    return {<EOL>        left:","gt":"bb.left + StandardWindow.scrollX,"}
{"input":"<s> function _renderFormattedText(element, treeNode, actionHandler) {<EOL>    let child;<EOL>    if (treeNode.type === FormatType.Text) {<EOL>        child =","gt":"document.createTextNode(treeNode.content);"}
{"input":"<s> function _renderFormattedText(element, treeNode, actionHandler) {<EOL>    let child;<EOL>    if (treeNode.type === FormatType.Text) {<EOL>        child =  document.createTextNode(treeNode.content);<EOL>    }<EOL>    else if (treeNode.type === FormatType.Bold) {<EOL>","gt":"child = document.createElement('<STR_LIT>');"}
{"input":"<s> function _renderFormattedText(element, treeNode, actionHandler) {<EOL>    let child;<EOL>    if (treeNode.type === FormatType.Text) {<EOL>        child =  document.createTextNode(treeNode.content);<EOL>    }<EOL>    else if (treeNode.type === FormatType.Bold) {<EOL>         child = document.createElement('<STR_LIT>');<EOL>    }<EOL>    else if (treeNode.type === FormatType.Italics) {<EOL>        child = document.createElement('<STR_LIT>');<EOL>    }<EOL>    else if (treeNode.type === FormatType.Action && actionHandler) {<EOL>        const a = document.createElement('<STR_LIT>');<EOL>        a.href = '<STR_LIT>';<EOL>        actionHandler.disposeables.push(DOM.addStandardDisposableListener(a, '<STR_LIT>', (","gt":"event) => {"}
{"input":"<s> function _renderFormattedText(element, treeNode, actionHandler) {<EOL>    let child;<EOL>    if (treeNode.type === FormatType.Text) {<EOL>        child =  document.createTextNode(treeNode.content);<EOL>    }<EOL>    else if (treeNode.type === FormatType.Bold) {<EOL>         child = document.createElement('<STR_LIT>');<EOL>    }<EOL>    else if (treeNode.type === FormatType.Italics) {<EOL>        child = document.createElement('<STR_LIT>');<EOL>    }<EOL>    else if (treeNode.type === FormatType.Action && actionHandler) {<EOL>        const a = document.createElement('<STR_LIT>');<EOL>        a.href = '<STR_LIT>';<EOL>        actionHandler.disposeables.push(DOM.addStandardDisposableListener(a, '<STR_LIT>', ( event) => {<EOL>            actionHandler.callback(String(treeNode.index), event);<EOL>        }));<EOL>        child =","gt":"a;"}
{"input":"<s> function _renderFormattedText(element, treeNode, actionHandler) {<EOL>    let child;<EOL>    if (treeNode.type === FormatType.Text) {<EOL>        child =  document.createTextNode(treeNode.content);<EOL>    }<EOL>    else if (treeNode.type === FormatType.Bold) {<EOL>         child = document.createElement('<STR_LIT>');<EOL>    }<EOL>    else if (treeNode.type === FormatType.Italics) {<EOL>        child = document.createElement('<STR_LIT>');<EOL>    }<EOL>    else if (treeNode.type === FormatType.Action && actionHandler) {<EOL>        const a = document.createElement('<STR_LIT>');<EOL>        a.href = '<STR_LIT>';<EOL>        actionHandler.disposeables.push(DOM.addStandardDisposableListener(a, '<STR_LIT>', ( event) => {<EOL>            actionHandler.callback(String(treeNode.index), event);<EOL>        }));<EOL>        child =  a;<EOL>    }<EOL>    else if (treeNode.type === FormatType.NewLine) {<EOL>        child = document.createElement('<STR_LIT>');<EOL>    }<EOL>    else if (treeNode.type === FormatType.Root) {<EOL>        child = element;<EOL>    }<EOL>","gt":"if (element !== child) {"}
{"input":"<s> export function setARIAContainer(parent) {<EOL>    ariaContainer = document.createElement('<STR_LIT>');<EOL>    ariaContainer.className = '<STR_LIT>';<EOL>    alertContainer = document.createElement('<STR_LIT>');<EOL>    alertContainer.","gt":"className = '<STR_LIT>';"}
{"input":"<s> export function setARIAContainer(parent) {<EOL>    ariaContainer = document.createElement('<STR_LIT>');<EOL>    ariaContainer.className = '<STR_LIT>';<EOL>    alertContainer = document.createElement('<STR_LIT>');<EOL>    alertContainer. className = '<STR_LIT>';<EOL>    alertContainer.setAttribute('<STR_LIT>', '<STR_LIT>');<EOL>    alertContainer.setAttribute('<STR_LIT>', '<STR_LIT>');<EOL>    ariaContainer.appendChild(alertContainer);<EOL>    statusContainer = document.createElement('<STR_LIT>');<EOL>    statusContainer.className = '<STR_LIT>';<EOL>    statusContainer.","gt":"setAttribute('<STR_LIT>', '<STR_LIT>');"}
{"input":"<s> function isInputElement(e) {<EOL>    return e.","gt":"tagName === '<STR_LIT>' || e.tagName === '<STR_LIT>';"}
{"input":"<s> <EOL>export function consolidate(groups) {<EOL>    const result = [];<EOL>    let previousGroup = null;<EOL>    for (let group of groups) {<EOL>        const start = group.range.start;<EOL>","gt":"const end = group.range.end;"}
{"input":"<s> <EOL>export function consolidate(groups) {<EOL>    const result = [];<EOL>    let previousGroup = null;<EOL>    for (let group of groups) {<EOL>        const start = group.range.start;<EOL>         const end = group.range.end;<EOL>        const size = group.size;<EOL>        if (previousGroup && size === previousGroup.size) {<EOL>            previousGroup.range.end = end;<EOL>            continue;<EOL>        }<EOL>","gt":"previousGroup = { range: { start, end }, size };"}
{"input":"<s> export function toThenable(arg) {<EOL>    if (isThenable(arg)) {<EOL>","gt":"return arg;"}
{"input":"<s> function fifo(array, size) {<EOL>","gt":"while (array.length > size) {"}
{"input":"<s> export function illegalState(name) {<EOL>    if (name) {<EOL>        return new","gt":"Error(`<STR_LIT>`);"}
{"input":"<s> function isNumber(code) {<EOL>    return CharCode.Digit0 <=","gt":"code && code <= CharCode.Digit9;"}
{"input":"<s> export function once(fn) {<EOL>    const _this = this;<EOL>    let didCall = false;<EOL>    let result;<EOL>    return","gt":"function () {"}
{"input":"<s> export function once(fn) {<EOL>    const _this = this;<EOL>    let didCall = false;<EOL>    let result;<EOL>    return  function () {<EOL>        if (didCall) {<EOL>            return result;<EOL>        }<EOL>        didCall = true;<EOL>        result = fn.apply(","gt":"_this, arguments);"}
{"input":"<s> function parseExpressionPattern(pattern, value, options) {<EOL>    if (value === false) {<EOL>        return NULL; <EOL>    }<EOL>","gt":"const parsedPattern = parsePattern(pattern, options);"}
{"input":"<s> function parseExpressionPattern(pattern, value, options) {<EOL>    if (value === false) {<EOL>        return NULL; <EOL>    }<EOL>     const parsedPattern = parsePattern(pattern, options);<EOL>    if (parsedPattern === NULL) {<EOL>        return","gt":"NULL;"}
{"input":"<s> function parseExpressionPattern(pattern, value, options) {<EOL>    if (value === false) {<EOL>        return NULL; <EOL>    }<EOL>     const parsedPattern = parsePattern(pattern, options);<EOL>    if (parsedPattern === NULL) {<EOL>        return  NULL;<EOL>    }<EOL>    <EOL>    if (typeof value === '<STR_LIT>') {<EOL>        return parsedPattern;<EOL>    }<EOL>    <EOL>    if (","gt":"value) {"}
{"input":"<s> function parseExpressionPattern(pattern, value, options) {<EOL>    if (value === false) {<EOL>        return NULL; <EOL>    }<EOL>     const parsedPattern = parsePattern(pattern, options);<EOL>    if (parsedPattern === NULL) {<EOL>        return  NULL;<EOL>    }<EOL>    <EOL>    if (typeof value === '<STR_LIT>') {<EOL>        return parsedPattern;<EOL>    }<EOL>    <EOL>    if ( value) {<EOL>        const when = value.when;<EOL>        if (typeof when === '<STR_LIT>') {<EOL>            const siblingsPatternToMatchingPattern = (siblingsPattern) => {<EOL>                let clausePattern = when.replace('<STR_LIT>', siblingsPattern.name);<EOL>","gt":"if (siblingsPattern.siblings.indexOf(clausePattern) !== -<NUM_LIT>) {"}
{"input":"<s> function parseExpressionPattern(pattern, value, options) {<EOL>    if (value === false) {<EOL>        return NULL; <EOL>    }<EOL>     const parsedPattern = parsePattern(pattern, options);<EOL>    if (parsedPattern === NULL) {<EOL>        return  NULL;<EOL>    }<EOL>    <EOL>    if (typeof value === '<STR_LIT>') {<EOL>        return parsedPattern;<EOL>    }<EOL>    <EOL>    if ( value) {<EOL>        const when = value.when;<EOL>        if (typeof when === '<STR_LIT>') {<EOL>            const siblingsPatternToMatchingPattern = (siblingsPattern) => {<EOL>                let clausePattern = when.replace('<STR_LIT>', siblingsPattern.name);<EOL>                 if (siblingsPattern.siblings.indexOf(clausePattern) !== -<NUM_LIT>) {<EOL>                    return pattern;<EOL>                }<EOL>                else {<EOL>                    return null; <EOL>                }<EOL>            };<EOL>            const result = (path, basename, siblingsPatternFn) => {<EOL>                if (!parsedPattern(path, basename)) {<EOL>                    return null;<EOL>                }<EOL>                const siblingsPattern = siblingsPatternFn();<EOL>                if (!siblingsPattern) {<EOL>                    return null; <EOL>                }<EOL>                return TPromise.is(siblingsPattern) ?<EOL>                    siblingsPattern.then(siblingsPatternToMatchingPattern) :<EOL>                    siblingsPatternToMatchingPattern(","gt":"siblingsPattern);"}
{"input":"<s> function starsToRegExp(starCount) {<EOL>    switch (starCount) {<EOL>        case <NUM_LIT>:<EOL>            return '<STR_LIT>';<EOL>","gt":"case <NUM_LIT>:"}
{"input":"<s> <EOL>export function clearTextMimes(onlyUserConfigured) {<EOL>    if (!onlyUserConfigured) {<EOL>        registeredAssociations = [];<EOL>","gt":"nonUserRegisteredAssociations = [];"}
{"input":"<s> export function suggestFilename(langId, prefix) {<EOL>    for (let i = <NUM_LIT>; i < registeredAssociations.length; i++) {<EOL>        const association = registeredAssociations[i];<EOL>        if (association.userConfigured) {<EOL>","gt":"continue;"}
{"input":"<s> export function matchesFuzzyOcticonAware(query, target, enableSeparateSubstringMatching = false) {<EOL>    const { text, octiconOffsets } = target;<EOL>    <EOL>    if (!octiconOffsets || octiconOffsets.length === <NUM_LIT>) {<EOL>        return","gt":"matchesFuzzy(query, text, enableSeparateSubstringMatching);"}
{"input":"<s> export function matchesFuzzyOcticonAware(query, target, enableSeparateSubstringMatching = false) {<EOL>    const { text, octiconOffsets } = target;<EOL>    <EOL>    if (!octiconOffsets || octiconOffsets.length === <NUM_LIT>) {<EOL>        return  matchesFuzzy(query, text, enableSeparateSubstringMatching);<EOL>    }<EOL>    <EOL>    <EOL>    const wordToMatchAgainstWithoutOcticonsTrimmed = ltrim(text, '<STR_LIT>');<EOL>    const leadingWhitespaceOffset = text.length - wordToMatchAgainstWithoutOcticonsTrimmed.length;<EOL>    <EOL>    const matches = matchesFuzzy(query,","gt":"wordToMatchAgainstWithoutOcticonsTrimmed, enableSeparateSubstringMatching);"}
{"input":"<s> export function matchesFuzzyOcticonAware(query, target, enableSeparateSubstringMatching = false) {<EOL>    const { text, octiconOffsets } = target;<EOL>    <EOL>    if (!octiconOffsets || octiconOffsets.length === <NUM_LIT>) {<EOL>        return  matchesFuzzy(query, text, enableSeparateSubstringMatching);<EOL>    }<EOL>    <EOL>    <EOL>    const wordToMatchAgainstWithoutOcticonsTrimmed = ltrim(text, '<STR_LIT>');<EOL>    const leadingWhitespaceOffset = text.length - wordToMatchAgainstWithoutOcticonsTrimmed.length;<EOL>    <EOL>    const matches = matchesFuzzy(query,  wordToMatchAgainstWithoutOcticonsTrimmed, enableSeparateSubstringMatching);<EOL>    <EOL>    if (matches) {<EOL>        for (let i = <NUM_LIT>; i < matches.length; i++) {<EOL>            const octiconOffset = octiconOffsets[matches[i].start] + leadingWhitespaceOffset ;<EOL>","gt":"matches[i].start += octiconOffset;"}
{"input":"<s> export function parseOcticons(text) {<EOL>    const firstOcticonIndex = text.indexOf(octiconStartMarker);<EOL>","gt":"if (firstOcticonIndex === -<NUM_LIT>) {"}
{"input":"<s> export function isAbsolute_win32(path) {<EOL>    if (!path) {<EOL>        return false;<EOL>    }<EOL>    const char0 = path.charCodeAt(<NUM_LIT>);<EOL>    if (char0 === CharCode.Slash ||","gt":"char0 === CharCode.Backslash) {"}
{"input":"<s> export function isAbsolute_win32(path) {<EOL>    if (!path) {<EOL>        return false;<EOL>    }<EOL>    const char0 = path.charCodeAt(<NUM_LIT>);<EOL>    if (char0 === CharCode.Slash ||  char0 === CharCode.Backslash) {<EOL>        return true;<EOL>    }<EOL>    else if ((char0 >= CharCode.A && char0 <= CharCode.Z) || (char0 >= CharCode.a && char0 <= CharCode.z)) {<EOL>        if (path.length > <NUM_LIT> && path.charCodeAt(","gt":"<NUM_LIT>) === CharCode.Colon) {"}
{"input":"<s> function _isNormal(path, win) {<EOL>    return","gt":"win"}
{"input":"<s> <EOL>export function pad(n, l, char = '<STR_LIT>') {<EOL>    let str = '<STR_LIT>' + n;<EOL>","gt":"let r = [str];"}
{"input":"<s> export function stripUTF8BOM(str) {<EOL>","gt":"return startsWithUTF8BOM(str) ? str.substr(<NUM_LIT>) : str;"}
{"input":"<s> <EOL>export function isFunction(obj) {<EOL>    return typeof obj ===","gt":"_typeof.function;"}
{"input":"<s> function _encode(ch) {<EOL>    return","gt":"'<STR_LIT>' + ch.charCodeAt(<NUM_LIT>).toString(<NUM_LIT>).toUpperCase();"}
{"input":"<s> export function parse(entry) {<EOL>    const args = [];<EOL>    let stack;<EOL>    <EOL>    try {<EOL>        const parsedArguments = JSON.parse(entry.arguments);<EOL>        <EOL>        const stackArgument = parsedArguments[parsedArguments.length - <NUM_LIT>];<EOL>        if (stackArgument && stackArgument.__$stack) {<EOL>            parsedArguments.pop(); <EOL>            stack =","gt":"stackArgument.__$stack;"}
{"input":"<s> export function encode(content, encoding, options) {<EOL>    return iconv.encode(content, toNodeEncoding(","gt":"encoding), options);"}
{"input":"<s> export function writeFileAndFlushSync(path, data, options) {<EOL>    options = ensureOptions(options);<EOL>    if (options.encoding) {<EOL>        data = encode(data, options.encoding.charset, { addBOM: options.encoding.addBOM });<EOL>    }<EOL>","gt":"if (!canFlush) {"}
{"input":"<s> export function writeFileAndFlushSync(path, data, options) {<EOL>    options = ensureOptions(options);<EOL>    if (options.encoding) {<EOL>        data = encode(data, options.encoding.charset, { addBOM: options.encoding.addBOM });<EOL>    }<EOL>     if (!canFlush) {<EOL>        return fs.writeFileSync(path, data, { mode: options.mode, flag: options.flag });<EOL>    }<EOL>    <EOL>    const fd = fs.openSync(path, options.flag, options.mode);<EOL>    try {<EOL>        <EOL>        fs.writeFileSync(fd, data);<EOL>        <EOL>        try {<EOL>            fs.fdatasyncSync(fd);<EOL>        }<EOL>        catch (syncError) {<EOL>            console.warn('<STR_LIT>', syncError);<EOL>","gt":"canFlush = false;"}
{"input":"<s> export function sequence(sequences) {<EOL>    Sequence((Array.isArray(sequences)) ?","gt":"sequences : Array.prototype.slice.call(arguments));"}
{"input":"<s> <EOL>export function dirExists(path) {<EOL>    return stat(path).then((","gt":"stat) => stat.isDirectory(), () => false);"}
{"input":"<s> export function getWindowsShell() {<EOL>    return","gt":"process.env['<STR_LIT>'] || '<STR_LIT>';"}
{"input":"<s> function filterNotOk(filter, word, suggestion) {<EOL>    assert(!filter(","gt":"word, suggestion));"}
{"input":"<s> function assertScanError(text, expectedKind, scanError) {<EOL>    var scanner = createScanner(text);<EOL>    scanner.","gt":"scan();"}
{"input":"<s> function assertUrl(raw, scheme, domain, port, path, queryString, fragmentId) {<EOL>    <EOL>    const uri = URI.parse(raw);<EOL>    assert.equal(","gt":"uri.scheme, scheme);"}
{"input":"<s> export function toResource(path) {<EOL>    return URI.file(paths.","gt":"join('<STR_LIT>', Buffer.from(this.test.fullTitle()).toString('<STR_LIT>'), path));"}
{"input":"<s> <EOL>function hide(el) {<EOL>    el.","gt":"classList.add('<STR_LIT>');"}
{"input":"<s> export function startup(configuration) {<EOL>    handshake(","gt":"configuration);"}
{"input":"<s> export function getLastActiveWindow(windows) {<EOL>    const lastFocusedDate = Math.max.apply(Math, windows.map((window) =>","gt":"window.lastFocusTime));"}
{"input":"<s> export function createEditorPagePosition(editorViewDomNode) {<EOL>    let editorPos =","gt":"dom.getDomNodePagePosition(editorViewDomNode);"}
{"input":"<s> function _cursorStyleFromString(cursorStyle, defaultValue) {<EOL>    if (typeof cursorStyle !== '<STR_LIT>') {<EOL>        return defaultValue;<EOL>    }<EOL>    if (cursorStyle === '<STR_LIT>') {<EOL>","gt":"return TextEditorCursorStyle.Line;"}
{"input":"<s> function _cursorStyleFromString(cursorStyle, defaultValue) {<EOL>    if (typeof cursorStyle !== '<STR_LIT>') {<EOL>        return defaultValue;<EOL>    }<EOL>    if (cursorStyle === '<STR_LIT>') {<EOL>         return TextEditorCursorStyle.Line;<EOL>    }<EOL>","gt":"else if (cursorStyle === '<STR_LIT>') {"}
{"input":"<s> function _cursorStyleFromString(cursorStyle, defaultValue) {<EOL>    if (typeof cursorStyle !== '<STR_LIT>') {<EOL>        return defaultValue;<EOL>    }<EOL>    if (cursorStyle === '<STR_LIT>') {<EOL>         return TextEditorCursorStyle.Line;<EOL>    }<EOL>     else if (cursorStyle === '<STR_LIT>') {<EOL>        return TextEditorCursorStyle.Block;<EOL>    }<EOL>    else if (cursorStyle === '<STR_LIT>') {<EOL>        return TextEditorCursorStyle.Underline;<EOL>    }<EOL>    else if (cursorStyle === '<STR_LIT>') {<EOL>        return TextEditorCursorStyle.LineThin;<EOL>    }<EOL>    else if (cursorStyle === '<STR_LIT>') {<EOL>        return TextEditorCursorStyle.","gt":"BlockOutline;"}
{"input":"<s> function adjustMarkerBeforeColumn(markerOffset, markerStickToPreviousCharacter, checkOffset, moveSemantics) {<EOL>    if (markerOffset < checkOffset) {<EOL>        return true;<EOL>    }<EOL>","gt":"if (markerOffset > checkOffset) {"}
{"input":"<s> function adjustMarkerBeforeColumn(markerOffset, markerStickToPreviousCharacter, checkOffset, moveSemantics) {<EOL>    if (markerOffset < checkOffset) {<EOL>        return true;<EOL>    }<EOL>     if (markerOffset > checkOffset) {<EOL>        return false;<EOL>    }<EOL>    if (moveSemantics === MarkerMoveSemantics.ForceMove) {<EOL>        return false;<EOL>    }<EOL>    if (moveSemantics === MarkerMoveSemantics.","gt":"ForceStay) {"}
{"input":"<s> function intervalSearch(T, intervalStart, intervalEnd, filterOwnerId, filterOutValidation, cachedVersionId) {<EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    let node = T.root;<EOL>    let delta = <NUM_LIT>;<EOL>    let","gt":"nodeMaxEnd = <NUM_LIT>;"}
{"input":"<s> function intervalSearch(T, intervalStart, intervalEnd, filterOwnerId, filterOutValidation, cachedVersionId) {<EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    let node = T.root;<EOL>    let delta = <NUM_LIT>;<EOL>    let  nodeMaxEnd = <NUM_LIT>;<EOL>    let nodeStart = <NUM_LIT>;<EOL>    let nodeEnd = <NUM_LIT>;<EOL>    let result = [];<EOL>    let resultLen = <NUM_LIT>;<EOL>    while (node !==","gt":"SENTINEL) {"}
{"input":"<s> function intervalSearch(T, intervalStart, intervalEnd, filterOwnerId, filterOutValidation, cachedVersionId) {<EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    let node = T.root;<EOL>    let delta = <NUM_LIT>;<EOL>    let  nodeMaxEnd = <NUM_LIT>;<EOL>    let nodeStart = <NUM_LIT>;<EOL>    let nodeEnd = <NUM_LIT>;<EOL>    let result = [];<EOL>    let resultLen = <NUM_LIT>;<EOL>    while (node !==  SENTINEL) {<EOL>","gt":"if (getNodeIsVisited(node)) {"}
{"input":"<s> function intervalSearch(T, intervalStart, intervalEnd, filterOwnerId, filterOutValidation, cachedVersionId) {<EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    let node = T.root;<EOL>    let delta = <NUM_LIT>;<EOL>    let  nodeMaxEnd = <NUM_LIT>;<EOL>    let nodeStart = <NUM_LIT>;<EOL>    let nodeEnd = <NUM_LIT>;<EOL>    let result = [];<EOL>    let resultLen = <NUM_LIT>;<EOL>    while (node !==  SENTINEL) {<EOL>         if (getNodeIsVisited(node)) {<EOL>            <EOL>            setNodeIsVisited(node.left, false);<EOL>            setNodeIsVisited(node.right, false);<EOL>            if (node === node.parent.right) {<EOL>                delta -= node.parent.delta;<EOL>            }<EOL>","gt":"node = node."}
{"input":"<s> function intervalSearch(T, intervalStart, intervalEnd, filterOwnerId, filterOutValidation, cachedVersionId) {<EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    let node = T.root;<EOL>    let delta = <NUM_LIT>;<EOL>    let  nodeMaxEnd = <NUM_LIT>;<EOL>    let nodeStart = <NUM_LIT>;<EOL>    let nodeEnd = <NUM_LIT>;<EOL>    let result = [];<EOL>    let resultLen = <NUM_LIT>;<EOL>    while (node !==  SENTINEL) {<EOL>         if (getNodeIsVisited(node)) {<EOL>            <EOL>            setNodeIsVisited(node.left, false);<EOL>            setNodeIsVisited(node.right, false);<EOL>            if (node === node.parent.right) {<EOL>                delta -= node.parent.delta;<EOL>            }<EOL>             node = node.","gt":"parent;"}
{"input":"<s> function intervalSearch(T, intervalStart, intervalEnd, filterOwnerId, filterOutValidation, cachedVersionId) {<EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    let node = T.root;<EOL>    let delta = <NUM_LIT>;<EOL>    let  nodeMaxEnd = <NUM_LIT>;<EOL>    let nodeStart = <NUM_LIT>;<EOL>    let nodeEnd = <NUM_LIT>;<EOL>    let result = [];<EOL>    let resultLen = <NUM_LIT>;<EOL>    while (node !==  SENTINEL) {<EOL>         if (getNodeIsVisited(node)) {<EOL>            <EOL>            setNodeIsVisited(node.left, false);<EOL>            setNodeIsVisited(node.right, false);<EOL>            if (node === node.parent.right) {<EOL>                delta -= node.parent.delta;<EOL>            }<EOL>             node = node. parent;<EOL>            continue;<EOL>        }<EOL>        if (!getNodeIsVisited(node.left)) {<EOL>            <EOL>            nodeMaxEnd = delta + node.maxEnd;<EOL>            if (nodeMaxEnd < intervalStart) {<EOL>                <EOL>                <EOL>                setNodeIsVisited(node, true);<EOL>                continue;<EOL>            }<EOL>            if (node.left !== SENTINEL) {<EOL>                <EOL>                node = node.left;<EOL>                continue;<EOL>            }<EOL>        }<EOL>        <EOL>        nodeStart = delta + node.start;<EOL>        if (nodeStart > intervalEnd) {<EOL>            <EOL>            <EOL>            setNodeIsVisited(node,","gt":"true);"}
{"input":"<s> function intervalSearch(T, intervalStart, intervalEnd, filterOwnerId, filterOutValidation, cachedVersionId) {<EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    let node = T.root;<EOL>    let delta = <NUM_LIT>;<EOL>    let  nodeMaxEnd = <NUM_LIT>;<EOL>    let nodeStart = <NUM_LIT>;<EOL>    let nodeEnd = <NUM_LIT>;<EOL>    let result = [];<EOL>    let resultLen = <NUM_LIT>;<EOL>    while (node !==  SENTINEL) {<EOL>         if (getNodeIsVisited(node)) {<EOL>            <EOL>            setNodeIsVisited(node.left, false);<EOL>            setNodeIsVisited(node.right, false);<EOL>            if (node === node.parent.right) {<EOL>                delta -= node.parent.delta;<EOL>            }<EOL>             node = node. parent;<EOL>            continue;<EOL>        }<EOL>        if (!getNodeIsVisited(node.left)) {<EOL>            <EOL>            nodeMaxEnd = delta + node.maxEnd;<EOL>            if (nodeMaxEnd < intervalStart) {<EOL>                <EOL>                <EOL>                setNodeIsVisited(node, true);<EOL>                continue;<EOL>            }<EOL>            if (node.left !== SENTINEL) {<EOL>                <EOL>                node = node.left;<EOL>                continue;<EOL>            }<EOL>        }<EOL>        <EOL>        nodeStart = delta + node.start;<EOL>        if (nodeStart > intervalEnd) {<EOL>            <EOL>            <EOL>            setNodeIsVisited(node,  true);<EOL>            continue;<EOL>        }<EOL>        nodeEnd = delta + node.end;<EOL>        if (nodeEnd >= intervalStart) {<EOL>            <EOL>            node.setCachedOffsets(nodeStart, nodeEnd, cachedVersionId);<EOL>            let include = true;<EOL>            if (filterOwnerId && node.ownerId && node.ownerId !== filterOwnerId) {<EOL>                include = false;<EOL>            }<EOL>            if (filterOutValidation && getNodeIsForValidation(node)) {<EOL>                include = false;<EOL>            }<EOL>            if (include) {<EOL>","gt":"result[resultLen++] = node;"}
{"input":"<s> function intervalSearch(T, intervalStart, intervalEnd, filterOwnerId, filterOutValidation, cachedVersionId) {<EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    let node = T.root;<EOL>    let delta = <NUM_LIT>;<EOL>    let  nodeMaxEnd = <NUM_LIT>;<EOL>    let nodeStart = <NUM_LIT>;<EOL>    let nodeEnd = <NUM_LIT>;<EOL>    let result = [];<EOL>    let resultLen = <NUM_LIT>;<EOL>    while (node !==  SENTINEL) {<EOL>         if (getNodeIsVisited(node)) {<EOL>            <EOL>            setNodeIsVisited(node.left, false);<EOL>            setNodeIsVisited(node.right, false);<EOL>            if (node === node.parent.right) {<EOL>                delta -= node.parent.delta;<EOL>            }<EOL>             node = node. parent;<EOL>            continue;<EOL>        }<EOL>        if (!getNodeIsVisited(node.left)) {<EOL>            <EOL>            nodeMaxEnd = delta + node.maxEnd;<EOL>            if (nodeMaxEnd < intervalStart) {<EOL>                <EOL>                <EOL>                setNodeIsVisited(node, true);<EOL>                continue;<EOL>            }<EOL>            if (node.left !== SENTINEL) {<EOL>                <EOL>                node = node.left;<EOL>                continue;<EOL>            }<EOL>        }<EOL>        <EOL>        nodeStart = delta + node.start;<EOL>        if (nodeStart > intervalEnd) {<EOL>            <EOL>            <EOL>            setNodeIsVisited(node,  true);<EOL>            continue;<EOL>        }<EOL>        nodeEnd = delta + node.end;<EOL>        if (nodeEnd >= intervalStart) {<EOL>            <EOL>            node.setCachedOffsets(nodeStart, nodeEnd, cachedVersionId);<EOL>            let include = true;<EOL>            if (filterOwnerId && node.ownerId && node.ownerId !== filterOwnerId) {<EOL>                include = false;<EOL>            }<EOL>            if (filterOutValidation && getNodeIsForValidation(node)) {<EOL>                include = false;<EOL>            }<EOL>            if (include) {<EOL>                 result[resultLen++] = node;<EOL>            }<EOL>        }<EOL>        setNodeIsVisited(node,","gt":"true);"}
{"input":"<s> export function createTextBufferFactoryFromSnapshot(snapshot) {<EOL>    let builder = createTextBufferBuilder();<EOL>    let","gt":"chunk;"}
{"input":"<s> function getDefaultMetadata(topLevelLanguageId) {<EOL>    return ((topLevelLanguageId << MetadataConsts.LANGUAGEID_OFFSET)<EOL>        | (StandardTokenType.","gt":"Other << MetadataConsts.TOKEN_TYPE_OFFSET)"}
{"input":"<s> export function ensureValidWordDefinition(wordDefinition) {<EOL>    let result = DEFAULT_WORD_REGEXP;<EOL>    if (wordDefinition && (wordDefinition instanceof RegExp)) {<EOL>        if (!wordDefinition.global) {<EOL>            let flags = '<STR_LIT>';<EOL>            if (wordDefinition.ignoreCase) {<EOL>","gt":"flags += '<STR_LIT>';"}
{"input":"<s> export function ensureValidWordDefinition(wordDefinition) {<EOL>    let result = DEFAULT_WORD_REGEXP;<EOL>    if (wordDefinition && (wordDefinition instanceof RegExp)) {<EOL>        if (!wordDefinition.global) {<EOL>            let flags = '<STR_LIT>';<EOL>            if (wordDefinition.ignoreCase) {<EOL>                 flags += '<STR_LIT>';<EOL>            }<EOL>            if (wordDefinition.multiline) {<EOL>                flags += '<STR_LIT>';<EOL>            }<EOL>            result = new RegExp(wordDefinition.source, flags);<EOL>        }<EOL>        else {<EOL>","gt":"result = wordDefinition;"}
{"input":"<s> function isInside(line, range) {<EOL>    return line >= range.startLineNumber &&","gt":"line <= range.endLineNumber;"}
{"input":"<s> function testCopyLinesDownCommand(lines, selection, expectedLines, expectedSelection) {<EOL>    testCommand(lines, null, selection, (sel) => new","gt":"CopyLinesCommand(sel, true), expectedLines, expectedSelection);"}
{"input":"<s> function codeActionsComparator(a, b) {<EOL>    const aHasDiags = !isFalsyOrEmpty(a.diagnostics);<EOL>    const bHasDiags = !isFalsyOrEmpty(b.diagnostics);<EOL>    if (aHasDiags) {<EOL>        if (bHasDiags) {<EOL>            return a.diagnostics[<NUM_LIT>].","gt":"message.localeCompare(b.diagnostics[<NUM_LIT>].message);"}
{"input":"<s> function snippetUpComparator(a, b) {<EOL>    if (a.suggestion.type !== b.suggestion.type) {<EOL>        if (a.suggestion.type === '<STR_LIT>') {<EOL>","gt":"return -<NUM_LIT>;"}
{"input":"<s> <EOL>export function setTheme(themeName) {<EOL>    StaticServices.standaloneThemeService.get().","gt":"setTheme(themeName);"}
{"input":"<s> <EOL>export function registerDocumentHighlightProvider(languageId, provider) {<EOL>    return modes.DocumentHighlightProviderRegistry.","gt":"register(languageId, provider);"}
{"input":"<s> <EOL>export function registerLinkProvider(languageId, provider) {<EOL>    return modes.LinkProviderRegistry.register(languageId,","gt":"provider);"}
{"input":"<s> <EOL>export function registerSignatureHelpProvider(languageId, provider) {<EOL>    return modes.SignatureHelpProviderRegistry.register(languageId,","gt":"provider);"}
{"input":"<s> <EOL>export function setMonarchTokensProvider(languageId, languageDef) {<EOL>    let lexer = compile(","gt":"languageId, languageDef);"}
{"input":"<s> function getBuiltinRules(builtinTheme) {<EOL>    switch (builtinTheme) {<EOL>        case VS_THEME_NAME:<EOL>            return","gt":"vs;"}
{"input":"<s> function moveToCenter(cursor, select) {<EOL>    move(cursor, {","gt":"to: CursorMove.RawDirection.ViewPortCenter, select: select });"}
{"input":"<s> function moveLeft(cursor, inSelectionMode = false) {<EOL>    if (inSelectionMode) {<EOL>        CoreNavigationCommands.CursorLeftSelect.runCoreEditorCommand(","gt":"cursor, {});"}
{"input":"<s> function getRandomInt(min, max) {<EOL>    return Math.floor(Math.random() * (","gt":"max - min + <NUM_LIT>)) + min;"}
{"input":"<s> function printTree(T) {<EOL>    if (T.root === SENTINEL) {<EOL>        console.log(`<STR_LIT>`);<EOL>","gt":"return;"}
{"input":"<s> function modelHasDecoration(model, startLineNumber, startColumn, endLineNumber, endColumn, className) {<EOL>    modelHasDecorations(model, [{<EOL>            range: new Range(startLineNumber, startColumn, endLineNumber,","gt":"endColumn),"}
{"input":"<s> function createModel(text) {<EOL>    return {<EOL>        getLineTokens: (lineNumber) => {<EOL>            return null;<EOL>        },<EOL>        getLineContent: (lineNumber) => {<EOL>","gt":"return text;"}
{"input":"<s> export function keyFromOverrideIdentifier(overrideIdentifier) {<EOL>    return","gt":"overrideIdentifier}]`<STR_LIT>;"}
{"input":"<s> function getDefaultValue(type) {<EOL>    const t = Array.isArray(type) ? type[<NUM_LIT>] : type;<EOL>    switch (t) {<EOL>        case '<STR_LIT>':<EOL>            return false;<EOL>        case","gt":"'<STR_LIT>':"}
{"input":"<s> function getDefaultValue(type) {<EOL>    const t = Array.isArray(type) ? type[<NUM_LIT>] : type;<EOL>    switch (t) {<EOL>        case '<STR_LIT>':<EOL>            return false;<EOL>        case  '<STR_LIT>':<EOL>        case '<STR_LIT>':<EOL>            return <NUM_LIT>;<EOL>        case '<STR_LIT>':<EOL>","gt":"return '<STR_LIT>';"}
{"input":"<s> function getDefaultValue(type) {<EOL>    const t = Array.isArray(type) ? type[<NUM_LIT>] : type;<EOL>    switch (t) {<EOL>        case '<STR_LIT>':<EOL>            return false;<EOL>        case  '<STR_LIT>':<EOL>        case '<STR_LIT>':<EOL>            return <NUM_LIT>;<EOL>        case '<STR_LIT>':<EOL>             return '<STR_LIT>';<EOL>        case '<STR_LIT>':<EOL>            return [];<EOL>        case '<STR_LIT>':<EOL>","gt":"return {};"}
{"input":"<s> function cmp(a, b) {<EOL>    let aType = a.getType();<EOL>    let bType = b.getType();<EOL>    if (aType !== bType) {<EOL>        return aType - bType;<EOL>    }<EOL>","gt":"switch (aType) {"}
{"input":"<s> function cmp(a, b) {<EOL>    let aType = a.getType();<EOL>    let bType = b.getType();<EOL>    if (aType !== bType) {<EOL>        return aType - bType;<EOL>    }<EOL>     switch (aType) {<EOL>        case ContextKeyExprType.Defined:<EOL>            return a.cmp(b);<EOL>        case ContextKeyExprType.Not:<EOL>            return a.cmp(b);<EOL>        case ContextKeyExprType.","gt":"Equals:"}
{"input":"<s> function cmp(a, b) {<EOL>    let aType = a.getType();<EOL>    let bType = b.getType();<EOL>    if (aType !== bType) {<EOL>        return aType - bType;<EOL>    }<EOL>     switch (aType) {<EOL>        case ContextKeyExprType.Defined:<EOL>            return a.cmp(b);<EOL>        case ContextKeyExprType.Not:<EOL>            return a.cmp(b);<EOL>        case ContextKeyExprType. Equals:<EOL>            return a.cmp(b);<EOL>        case ContextKeyExprType.NotEquals:<EOL>            return a.cmp(b);<EOL>        case","gt":"ContextKeyExprType.Regex:"}
{"input":"<s> export function adoptToGalleryExtensionId(id) {<EOL>    return id.replace(EXTENSION_IDENTIFIER_REGEX, (match, publisher,","gt":"name) => getGalleryExtensionId(publisher, name));"}
{"input":"<s> export function getMaliciousExtensionsSet(report) {<EOL>    const result = new Set();<EOL>    for (const extension of report) {<EOL>        if (","gt":"extension.malicious) {"}
{"input":"<s> export function isValidVersionStr(version) {<EOL>","gt":"version = version.trim();"}
{"input":"<s> export function attachBadgeStyler(widget, themeService, style) {<EOL>    return attachStyler(themeService, {<EOL>        badgeBackground: (","gt":"style && style.badgeBackground) || badgeBackground,"}
{"input":"<s> export function registerThemingParticipant(participant) {<EOL>    return themingRegistry.onThemeChange(","gt":"participant);"}
{"input":"<s> export function isRawFileWorkspaceFolder(thing) {<EOL>    return thing<EOL>        &&","gt":"typeof thing === '<STR_LIT>'"}
{"input":"<s> export function isSingleFolderWorkspaceIdentifier(obj) {<EOL>    return typeof obj ===","gt":"'<STR_LIT>';"}
{"input":"<s> function defineAPI(factory, extensionPaths) {<EOL>    <EOL>    const extApiImpl = new Map();<EOL>    let defaultApiImpl;<EOL>    const node_module = require.__$__nodeRequire('<STR_LIT>');<EOL>","gt":"const original = node_module._load;"}
{"input":"<s> function defineAPI(factory, extensionPaths) {<EOL>    <EOL>    const extApiImpl = new Map();<EOL>    let defaultApiImpl;<EOL>    const node_module = require.__$__nodeRequire('<STR_LIT>');<EOL>     const original = node_module._load;<EOL>    node_module._load = function load(request, parent, isMain) {<EOL>        if (request !== '<STR_LIT>') {<EOL>            return","gt":"original.apply(this, arguments);"}
{"input":"<s> function defineAPI(factory, extensionPaths) {<EOL>    <EOL>    const extApiImpl = new Map();<EOL>    let defaultApiImpl;<EOL>    const node_module = require.__$__nodeRequire('<STR_LIT>');<EOL>     const original = node_module._load;<EOL>    node_module._load = function load(request, parent, isMain) {<EOL>        if (request !== '<STR_LIT>') {<EOL>            return  original.apply(this, arguments);<EOL>        }<EOL>        <EOL>        const ext = extensionPaths.findSubstr(parent.","gt":"filename);"}
{"input":"<s> function defineAPI(factory, extensionPaths) {<EOL>    <EOL>    const extApiImpl = new Map();<EOL>    let defaultApiImpl;<EOL>    const node_module = require.__$__nodeRequire('<STR_LIT>');<EOL>     const original = node_module._load;<EOL>    node_module._load = function load(request, parent, isMain) {<EOL>        if (request !== '<STR_LIT>') {<EOL>            return  original.apply(this, arguments);<EOL>        }<EOL>        <EOL>        const ext = extensionPaths.findSubstr(parent. filename);<EOL>        if (ext) {<EOL>            let apiImpl = extApiImpl.get(ext.id);<EOL>","gt":"if (!apiImpl) {"}
{"input":"<s> function defineAPI(factory, extensionPaths) {<EOL>    <EOL>    const extApiImpl = new Map();<EOL>    let defaultApiImpl;<EOL>    const node_module = require.__$__nodeRequire('<STR_LIT>');<EOL>     const original = node_module._load;<EOL>    node_module._load = function load(request, parent, isMain) {<EOL>        if (request !== '<STR_LIT>') {<EOL>            return  original.apply(this, arguments);<EOL>        }<EOL>        <EOL>        const ext = extensionPaths.findSubstr(parent. filename);<EOL>        if (ext) {<EOL>            let apiImpl = extApiImpl.get(ext.id);<EOL>             if (!apiImpl) {<EOL>                apiImpl = factory(ext);<EOL>                extApiImpl.set(ext.id, apiImpl);<EOL>            }<EOL>            return","gt":"apiImpl;"}
{"input":"<s> export function initializeExtensionApi(extensionService, apiFactory) {<EOL>    return extensionService.getExtensionPathIndex().then((trie) => defineAPI(apiFactory,","gt":"trie));"}
{"input":"<s> function getIconPath(decorations) {<EOL>    if (!decorations) {<EOL>        return undefined;<EOL>    }<EOL>","gt":"else if (typeof decorations.iconPath === '<STR_LIT>') {"}
{"input":"<s> function getIconPath(decorations) {<EOL>    if (!decorations) {<EOL>        return undefined;<EOL>    }<EOL>     else if (typeof decorations.iconPath === '<STR_LIT>') {<EOL>        return URI.file(decorations.iconPath).toString();<EOL>    }<EOL>    else if (decorations.iconPath) {<EOL>        return","gt":"decorations.iconPath}`<STR_LIT>;"}
{"input":"<s> export function toHover(info) {<EOL>    return new types.","gt":"Hover(info.contents.map(MarkdownString.to), toRange(info.range));"}
{"input":"<s> <EOL>function patchProcess(allowExit) {<EOL>    process.exit = function (code) {<EOL>        if (allowExit) {<EOL>            exit(code);<EOL>        }<EOL>        else {<EOL>            const err = new Error('<STR_LIT>');<EOL>            console.warn(err.stack);<EOL>        }<EOL>    };<EOL>    process.","gt":"crash = function () {"}
{"input":"<s> export function renderVariable(tree, variable, data, showChanged) {<EOL>    if (variable.available) {<EOL>        data.name.textContent = replaceWhitespace(variable.name);<EOL>        data.name.title = variable.type ? variable.type : variable.name;<EOL>        dom.toggleClass(data.name, '<STR_LIT>', !!variable.presentationHint && variable.presentationHint.kind === '<STR_LIT>');<EOL>    }<EOL>","gt":"if (variable.value) {"}
{"input":"<s> export function renderVariable(tree, variable, data, showChanged) {<EOL>    if (variable.available) {<EOL>        data.name.textContent = replaceWhitespace(variable.name);<EOL>        data.name.title = variable.type ? variable.type : variable.name;<EOL>        dom.toggleClass(data.name, '<STR_LIT>', !!variable.presentationHint && variable.presentationHint.kind === '<STR_LIT>');<EOL>    }<EOL>     if (variable.value) {<EOL>        data.name.textContent += variable.name ? '<STR_LIT>' : '<STR_LIT>';<EOL>        renderExpressionValue(variable, data.value, {<EOL>            showChanged,<EOL>            maxValueLength: MAX_VALUE_RENDER_LENGTH_IN_VIEWLET,<EOL>            preserveWhitespace:","gt":"false,"}
{"input":"<s> function trimLongName(name) {<EOL>    if (name && name.length > <NUM_LIT>) {<EOL>        return","gt":"<NUM_LIT>, <NUM_LIT>)}...`<STR_LIT>;"}
{"input":"<s> function toResource(self, path) {<EOL>    return URI.file(join(","gt":"'<STR_LIT>', Buffer.from(self.test.fullTitle()).toString('<STR_LIT>'), path));"}
{"input":"<s> export function getSettingsTargetName(target, resource, workspaceContextService) {<EOL>    switch (target) {<EOL>        case ConfigurationTarget.USER:<EOL>            return localize('<STR_LIT>', \"<STR_LIT>\");<EOL>        case ConfigurationTarget.","gt":"WORKSPACE:"}
{"input":"<s> export function getSettingsTargetName(target, resource, workspaceContextService) {<EOL>    switch (target) {<EOL>        case ConfigurationTarget.USER:<EOL>            return localize('<STR_LIT>', \"<STR_LIT>\");<EOL>        case ConfigurationTarget. WORKSPACE:<EOL>            return localize('<STR_LIT>', \"<STR_LIT>\");<EOL>        case ConfigurationTarget.WORKSPACE_FOLDER:<EOL>            const folder = workspaceContextService.getWorkspaceFolder(resource);<EOL>            return folder ?","gt":"folder.name : '<STR_LIT>';"}
{"input":"<s> export function appendKeyBindingLabel(label, keyBinding, keyBindingService2) {<EOL>    if (typeof keyBinding === '<STR_LIT>') {<EOL>        const resolvedKeybindings = keyBindingService2.resolveKeybinding(createKeybinding(keyBinding, OS));<EOL>        return doAppendKeyBindingLabel(label, resolvedKeybindings.length > <NUM_LIT> ? resolvedKeybindings[<NUM_LIT>] :","gt":"null);"}
{"input":"<s> function patternListToIExpression(patterns) {<EOL>    return patterns.","gt":"length ?"}
{"input":"<s> async function createLanguageSnippetFile(pick) {<EOL>    if (await exists(pick.filepath)) {<EOL>        return;<EOL>    }<EOL>    const","gt":"contents = ["}
{"input":"<s> async function createLanguageSnippetFile(pick) {<EOL>    if (await exists(pick.filepath)) {<EOL>        return;<EOL>    }<EOL>    const  contents = [<EOL>        '<STR_LIT>',<EOL>        '<STR_LIT>' + pick.label + '<STR_LIT>',<EOL>","gt":"'<STR_LIT>',"}
{"input":"<s> async function createLanguageSnippetFile(pick) {<EOL>    if (await exists(pick.filepath)) {<EOL>        return;<EOL>    }<EOL>    const  contents = [<EOL>        '<STR_LIT>',<EOL>        '<STR_LIT>' + pick.label + '<STR_LIT>',<EOL>         '<STR_LIT>',<EOL>        '<STR_LIT>',<EOL>        '<STR_LIT>',<EOL>        '<STR_LIT>',<EOL>        '<STR_LIT>',<EOL>","gt":"'<STR_LIT>',"}
{"input":"<s> function assertPresentation(actual, expected) {<EOL>    assert.strictEqual(typeof actual, typeof expected);<EOL>","gt":"if (actual && expected) {"}
{"input":"<s> function sendProcessTitle() {<EOL>    process.send({<EOL>","gt":"type: '<STR_LIT>',"}
{"input":"<s> export function getConfirmMessage(start, resourcesToConfirm) {<EOL>    const message = [start];<EOL>    message.push('<STR_LIT>');<EOL>    message.push(...resourcesToConfirm.slice(<NUM_LIT>, MAX_CONFIRM_FILES).map((r) => basename(r.fsPath)));<EOL>","gt":"if (resourcesToConfirm.length > MAX_CONFIRM_FILES) {"}
{"input":"<s> function toResource(path) {<EOL>    return URI.from({","gt":"scheme: '<STR_LIT>', path });"}
{"input":"<s> function getSiblings(file) {<EOL>    return new TPromise((resolve, reject) => {<EOL>        extfs.readdir(path.dirname(file), (error, files) => {<EOL>","gt":"if (error) {"}
{"input":"<s> export function setup() {<EOL>    describe('<STR_LIT>', () => {<EOL>        before(function () {<EOL>            this.app.suiteName = '<STR_LIT>';<EOL>        });<EOL>","gt":"it('<STR_LIT>', async function () {"}
{"input":"<s> export function setup() {<EOL>    describe('<STR_LIT>', () => {<EOL>        before(function () {<EOL>            this.app.suiteName = '<STR_LIT>';<EOL>        });<EOL>         it('<STR_LIT>', async function () {<EOL>            const app = this.app;<EOL>            await app.workbench.search.openSearchViewlet();<EOL>            await","gt":"app.workbench.search.searchFor('<STR_LIT>');"}
{"input":"<s> export function setup() {<EOL>    describe('<STR_LIT>', () => {<EOL>        before(function () {<EOL>            this.app.suiteName = '<STR_LIT>';<EOL>        });<EOL>         it('<STR_LIT>', async function () {<EOL>            const app = this.app;<EOL>            await app.workbench.search.openSearchViewlet();<EOL>            await  app.workbench.search.searchFor('<STR_LIT>');<EOL>            await app.workbench.search.waitForResultText('<STR_LIT>');<EOL>        });<EOL>        it('<STR_LIT>', async function () {<EOL>            const app = this.app;<EOL>            await app.workbench.","gt":"search.searchFor('<STR_LIT>');"}
{"input":"<s> export function setup() {<EOL>    describe('<STR_LIT>', () => {<EOL>        before(function () {<EOL>            this.app.suiteName = '<STR_LIT>';<EOL>        });<EOL>         it('<STR_LIT>', async function () {<EOL>            const app = this.app;<EOL>            await app.workbench.search.openSearchViewlet();<EOL>            await  app.workbench.search.searchFor('<STR_LIT>');<EOL>            await app.workbench.search.waitForResultText('<STR_LIT>');<EOL>        });<EOL>        it('<STR_LIT>', async function () {<EOL>            const app = this.app;<EOL>            await app.workbench. search.searchFor('<STR_LIT>');<EOL>            await app.workbench.search.showQueryDetails();<EOL>            await app.workbench.search.setFilesToIncludeText('<STR_LIT>');<EOL>            await app.workbench.search.submitSearch();<EOL>            await app.workbench.search.","gt":"waitForResultText('<STR_LIT>');"}
{"input":"<s> export function setup() {<EOL>    describe('<STR_LIT>', () => {<EOL>        before(function () {<EOL>            this.app.suiteName = '<STR_LIT>';<EOL>        });<EOL>         it('<STR_LIT>', async function () {<EOL>            const app = this.app;<EOL>            await app.workbench.search.openSearchViewlet();<EOL>            await  app.workbench.search.searchFor('<STR_LIT>');<EOL>            await app.workbench.search.waitForResultText('<STR_LIT>');<EOL>        });<EOL>        it('<STR_LIT>', async function () {<EOL>            const app = this.app;<EOL>            await app.workbench. search.searchFor('<STR_LIT>');<EOL>            await app.workbench.search.showQueryDetails();<EOL>            await app.workbench.search.setFilesToIncludeText('<STR_LIT>');<EOL>            await app.workbench.search.submitSearch();<EOL>            await app.workbench.search. waitForResultText('<STR_LIT>');<EOL>            await app.workbench.search.setFilesToIncludeText('<STR_LIT>');<EOL>            await app.workbench.search.hideQueryDetails();<EOL>        });<EOL>        it('<STR_LIT>', async function () {<EOL>            const app = this.","gt":"app;"}
{"input":"<s> export function setup() {<EOL>    describe('<STR_LIT>', () => {<EOL>        before(function () {<EOL>            this.app.suiteName = '<STR_LIT>';<EOL>        });<EOL>         it('<STR_LIT>', async function () {<EOL>            const app = this.app;<EOL>            await app.workbench.search.openSearchViewlet();<EOL>            await  app.workbench.search.searchFor('<STR_LIT>');<EOL>            await app.workbench.search.waitForResultText('<STR_LIT>');<EOL>        });<EOL>        it('<STR_LIT>', async function () {<EOL>            const app = this.app;<EOL>            await app.workbench. search.searchFor('<STR_LIT>');<EOL>            await app.workbench.search.showQueryDetails();<EOL>            await app.workbench.search.setFilesToIncludeText('<STR_LIT>');<EOL>            await app.workbench.search.submitSearch();<EOL>            await app.workbench.search. waitForResultText('<STR_LIT>');<EOL>            await app.workbench.search.setFilesToIncludeText('<STR_LIT>');<EOL>            await app.workbench.search.hideQueryDetails();<EOL>        });<EOL>        it('<STR_LIT>', async function () {<EOL>            const app = this. app;<EOL>            await app.workbench.search.searchFor('<STR_LIT>');<EOL>            await app.workbench.search.removeFileMatch(<NUM_LIT>);<EOL>            await app.workbench.search.waitForResultText('<STR_LIT>');<EOL>        });<EOL>        it('<STR_LIT>', async function () {<EOL>            const app = this.app;<EOL>            await app.workbench.search.searchFor('<STR_LIT>');<EOL>            await app.workbench.search.expandReplace();<EOL>","gt":"await app.workbench.search.setReplaceText('<STR_LIT>');"}
{"input":"<s> export function setup() {<EOL>    describe('<STR_LIT>', () => {<EOL>        before(function () {<EOL>            this.app.suiteName = '<STR_LIT>';<EOL>        });<EOL>         it('<STR_LIT>', async function () {<EOL>            const app = this.app;<EOL>            await app.workbench.search.openSearchViewlet();<EOL>            await  app.workbench.search.searchFor('<STR_LIT>');<EOL>            await app.workbench.search.waitForResultText('<STR_LIT>');<EOL>        });<EOL>        it('<STR_LIT>', async function () {<EOL>            const app = this.app;<EOL>            await app.workbench. search.searchFor('<STR_LIT>');<EOL>            await app.workbench.search.showQueryDetails();<EOL>            await app.workbench.search.setFilesToIncludeText('<STR_LIT>');<EOL>            await app.workbench.search.submitSearch();<EOL>            await app.workbench.search. waitForResultText('<STR_LIT>');<EOL>            await app.workbench.search.setFilesToIncludeText('<STR_LIT>');<EOL>            await app.workbench.search.hideQueryDetails();<EOL>        });<EOL>        it('<STR_LIT>', async function () {<EOL>            const app = this. app;<EOL>            await app.workbench.search.searchFor('<STR_LIT>');<EOL>            await app.workbench.search.removeFileMatch(<NUM_LIT>);<EOL>            await app.workbench.search.waitForResultText('<STR_LIT>');<EOL>        });<EOL>        it('<STR_LIT>', async function () {<EOL>            const app = this.app;<EOL>            await app.workbench.search.searchFor('<STR_LIT>');<EOL>            await app.workbench.search.expandReplace();<EOL>             await app.workbench.search.setReplaceText('<STR_LIT>');<EOL>            await app.workbench.search.replaceFileMatch(<NUM_LIT>);<EOL>            await app.workbench.saveOpenedFile();<EOL>","gt":"await app.workbench.search.waitForResultText('<STR_LIT>');"}
{"input":"<s> function isExcludedFromLinterOptions(config, fileName) {<EOL>    if (config === undefined || config.linterOptions === undefined || config.linterOptions.exclude === undefined) {<EOL>        return","gt":"false;"}
{"input":"<s> <EOL>export function areSettingsValid(widgetSettings) {<EOL>    return (widgetSettings.projectId != null &&<EOL>        widgetSettings.teamId != null &&<EOL>        widgetSettings.workItemType != null &&<EOL>        widgetSettings.fields != null &&<EOL>","gt":"widgetSettings.fields.every((o) => o.fieldQueryName != null &&"}
{"input":"<s> <EOL>export function areSettingsValid(widgetSettings) {<EOL>    return (widgetSettings.projectId != null &&<EOL>        widgetSettings.teamId != null &&<EOL>        widgetSettings.workItemType != null &&<EOL>        widgetSettings.fields != null &&<EOL>         widgetSettings.fields.every((o) => o.fieldQueryName != null &&<EOL>            o.fieldReferenceName != null &&<EOL>            o.fieldType != null &&<EOL>            o.operator != null &&<EOL>            o.","gt":"value != null &&"}
{"input":"<s> <EOL>export function areSettingsValid(widgetSettings) {<EOL>    return (widgetSettings.projectId != null &&<EOL>        widgetSettings.teamId != null &&<EOL>        widgetSettings.workItemType != null &&<EOL>        widgetSettings.fields != null &&<EOL>         widgetSettings.fields.every((o) => o.fieldQueryName != null &&<EOL>            o.fieldReferenceName != null &&<EOL>            o.fieldType != null &&<EOL>            o.operator != null &&<EOL>            o. value != null &&<EOL>            (o.value != \"<STR_LIT>\" || o.fieldType == \"<STR_LIT>\")) && <EOL>        (widgetSettings.aggregation.aggregationMode != null &&<EOL>            (widgetSettings.","gt":"aggregation.aggregationMode == AggregationMode.count ||"}
{"input":"<s> function pathExistsAsFile(path) {<EOL>    try {<EOL>        return tl.","gt":"stats(path).isFile();"}
{"input":"<s> function publishTestResults(publishJUnitResults, testResultsFiles) {<EOL>    if (publishJUnitResults == '<STR_LIT>') {<EOL>        <EOL>        if (testResultsFiles.indexOf('<STR_LIT>') >= <NUM_LIT> || testResultsFiles.indexOf('<STR_LIT>') >= <NUM_LIT>) {<EOL>            tl.debug('<STR_LIT>');<EOL>            var buildFolder = tl.getVariable('<STR_LIT>');<EOL>            var allFiles =","gt":"tl.find(buildFolder);"}
{"input":"<s> function publishTestResults(publishJUnitResults, testResultsFiles) {<EOL>    if (publishJUnitResults == '<STR_LIT>') {<EOL>        <EOL>        if (testResultsFiles.indexOf('<STR_LIT>') >= <NUM_LIT> || testResultsFiles.indexOf('<STR_LIT>') >= <NUM_LIT>) {<EOL>            tl.debug('<STR_LIT>');<EOL>            var buildFolder = tl.getVariable('<STR_LIT>');<EOL>            var allFiles =  tl.find(buildFolder);<EOL>            var matchingTestResultsFiles = tl.match(allFiles, testResultsFiles, { matchBase: true });<EOL>        }<EOL>        else {<EOL>            tl.debug('<STR_LIT>');<EOL>            var","gt":"matchingTestResultsFiles = [testResultsFiles];"}
{"input":"<s> function publishTestResults(publishJUnitResults, testResultsFiles) {<EOL>    if (publishJUnitResults == '<STR_LIT>') {<EOL>        <EOL>        if (testResultsFiles.indexOf('<STR_LIT>') >= <NUM_LIT> || testResultsFiles.indexOf('<STR_LIT>') >= <NUM_LIT>) {<EOL>            tl.debug('<STR_LIT>');<EOL>            var buildFolder = tl.getVariable('<STR_LIT>');<EOL>            var allFiles =  tl.find(buildFolder);<EOL>            var matchingTestResultsFiles = tl.match(allFiles, testResultsFiles, { matchBase: true });<EOL>        }<EOL>        else {<EOL>            tl.debug('<STR_LIT>');<EOL>            var  matchingTestResultsFiles = [testResultsFiles];<EOL>        }<EOL>        if (!matchingTestResultsFiles || matchingTestResultsFiles.length == <NUM_LIT>) {<EOL>            tl.warning('<STR_LIT>' + testResultsFiles + '<STR_LIT>');<EOL>            return","gt":"<NUM_LIT>;"}
{"input":"<s> function getSonarQubeGradlePluginVersion() {<EOL>    let pluginVersion = '<STR_LIT>';<EOL>","gt":"let userSpecifiedVersion = tl.getInput('<STR_LIT>');"}
{"input":"<s> export function getSystemAccessToken() {<EOL>    let auth = tl.getEndpointAuthorization('<STR_LIT>', false);<EOL>    if (auth.scheme === '<STR_LIT>') {<EOL>","gt":"tl.debug(tl.loc('<STR_LIT>'));"}
{"input":"<s> export function getTempPath() {<EOL>    let tempNpmrcDir = tl.getVariable('<STR_LIT>')<EOL>        || tl.getVariable('<STR_LIT>')<EOL>        || process.","gt":"cwd();"}
{"input":"<s> function pushTags(connection, imageName) {<EOL>    var baseImageName = imageUtils.imageNameWithoutTag(imageName);<EOL>    var builtImageName = imageName + (baseImageName === imageName ? \"<STR_LIT>\" : \"<STR_LIT>\");<EOL>    return dockerPush(connection, builtImageName)<EOL>        .then(function pushAdditionalTags() {<EOL>        var","gt":"promise;"}
{"input":"<s> function pushTags(connection, imageName) {<EOL>    var baseImageName = imageUtils.imageNameWithoutTag(imageName);<EOL>    var builtImageName = imageName + (baseImageName === imageName ? \"<STR_LIT>\" : \"<STR_LIT>\");<EOL>    return dockerPush(connection, builtImageName)<EOL>        .then(function pushAdditionalTags() {<EOL>        var  promise;<EOL>        tl.getDelimitedInput(\"<STR_LIT>\", \"<STR_LIT>\").forEach((tag) => {<EOL>            promise = pushTag(promise, connection, baseImageName + \"<STR_LIT>\" + tag);<EOL>        });<EOL>        return promise;<EOL>    })<EOL>        .then(","gt":"function pushSourceTags() {"}
{"input":"<s> function pushTags(connection, imageName) {<EOL>    var baseImageName = imageUtils.imageNameWithoutTag(imageName);<EOL>    var builtImageName = imageName + (baseImageName === imageName ? \"<STR_LIT>\" : \"<STR_LIT>\");<EOL>    return dockerPush(connection, builtImageName)<EOL>        .then(function pushAdditionalTags() {<EOL>        var  promise;<EOL>        tl.getDelimitedInput(\"<STR_LIT>\", \"<STR_LIT>\").forEach((tag) => {<EOL>            promise = pushTag(promise, connection, baseImageName + \"<STR_LIT>\" + tag);<EOL>        });<EOL>        return promise;<EOL>    })<EOL>        .then( function pushSourceTags() {<EOL>        var promise;<EOL>        var includeSourceTags = tl.getBoolInput(\"<STR_LIT>\");<EOL>","gt":"if (includeSourceTags) {"}
{"input":"<s> function pushTags(connection, imageName) {<EOL>    var baseImageName = imageUtils.imageNameWithoutTag(imageName);<EOL>    var builtImageName = imageName + (baseImageName === imageName ? \"<STR_LIT>\" : \"<STR_LIT>\");<EOL>    return dockerPush(connection, builtImageName)<EOL>        .then(function pushAdditionalTags() {<EOL>        var  promise;<EOL>        tl.getDelimitedInput(\"<STR_LIT>\", \"<STR_LIT>\").forEach((tag) => {<EOL>            promise = pushTag(promise, connection, baseImageName + \"<STR_LIT>\" + tag);<EOL>        });<EOL>        return promise;<EOL>    })<EOL>        .then( function pushSourceTags() {<EOL>        var promise;<EOL>        var includeSourceTags = tl.getBoolInput(\"<STR_LIT>\");<EOL>         if (includeSourceTags) {<EOL>            sourceUtils.getSourceTags().forEach((tag) => {<EOL>                promise = pushTag(promise, connection, baseImageName + \"<STR_LIT>\" + tag);<EOL>            });<EOL>        }<EOL>        return","gt":"promise;"}
{"input":"<s> function getNameSpace() {<EOL>    var args = [];<EOL>    var namespace = tl.getInput(\"<STR_LIT>\", false);<EOL>    if (","gt":"namespace) {"}
{"input":"<s> export async function run(packerHost) {<EOL>    var command = packerHost.createPackerTool();<EOL>    command.arg(\"<STR_LIT>\");<EOL>    <EOL>    var variableProviders = packerHost.getTemplateVariablesProviders();<EOL>    for (var provider","gt":"of variableProviders) {"}
{"input":"<s> export async function run(packerHost) {<EOL>    var command = packerHost.createPackerTool();<EOL>    command.arg(\"<STR_LIT>\");<EOL>    <EOL>    var variableProviders = packerHost.getTemplateVariablesProviders();<EOL>    for (var provider  of variableProviders) {<EOL>        var variables = await provider.getTemplateVariables(packerHost);<EOL>        variables.forEach((value, key) => {<EOL>            command.arg([\"<STR_LIT>\", util.format(\"<STR_LIT>\", key, value)]);<EOL>        });<EOL>    }<EOL>    command.arg(packerHost.getTemplateFileProvider().getTemplateFileLocation(packerHost));<EOL>    console.log(tl.loc(\"<STR_LIT>\"));<EOL>","gt":"var result = command.execSync();"}
{"input":"<s> function isDtaEngineRequired() {<EOL>    const batchType = tl.getInput('<STR_LIT>');<EOL>    if (batchType && batchType === '<STR_LIT>') {<EOL>        const batchSize = tl.getInput('<STR_LIT>');<EOL>        if (batchSize && batchSize === '<STR_LIT>') {<EOL>            return true;<EOL>        }<EOL>    }<EOL>    else if (batchType && batchType === '<STR_LIT>') {<EOL>","gt":"return true;"}
{"input":"<s> function isDtaEngineRequired() {<EOL>    const batchType = tl.getInput('<STR_LIT>');<EOL>    if (batchType && batchType === '<STR_LIT>') {<EOL>        const batchSize = tl.getInput('<STR_LIT>');<EOL>        if (batchSize && batchSize === '<STR_LIT>') {<EOL>            return true;<EOL>        }<EOL>    }<EOL>    else if (batchType && batchType === '<STR_LIT>') {<EOL>         return true;<EOL>    }<EOL>    else if (batchType && batchType === '<STR_LIT>') {<EOL>","gt":"return true;"}
{"input":"<s> function isDtaEngineRequired() {<EOL>    const batchType = tl.getInput('<STR_LIT>');<EOL>    if (batchType && batchType === '<STR_LIT>') {<EOL>        const batchSize = tl.getInput('<STR_LIT>');<EOL>        if (batchSize && batchSize === '<STR_LIT>') {<EOL>            return true;<EOL>        }<EOL>    }<EOL>    else if (batchType && batchType === '<STR_LIT>') {<EOL>         return true;<EOL>    }<EOL>    else if (batchType && batchType === '<STR_LIT>') {<EOL>         return true;<EOL>    }<EOL>    const testType = tl.getInput('<STR_LIT>');<EOL>    tl.","gt":"debug('<STR_LIT>' + testType);"}
{"input":"<s> function isDtaEngineRequired() {<EOL>    const batchType = tl.getInput('<STR_LIT>');<EOL>    if (batchType && batchType === '<STR_LIT>') {<EOL>        const batchSize = tl.getInput('<STR_LIT>');<EOL>        if (batchSize && batchSize === '<STR_LIT>') {<EOL>            return true;<EOL>        }<EOL>    }<EOL>    else if (batchType && batchType === '<STR_LIT>') {<EOL>         return true;<EOL>    }<EOL>    else if (batchType && batchType === '<STR_LIT>') {<EOL>         return true;<EOL>    }<EOL>    const testType = tl.getInput('<STR_LIT>');<EOL>    tl. debug('<STR_LIT>' + testType);<EOL>    if (testType.toLowerCase() === '<STR_LIT>' || testType.toLowerCase() === '<STR_LIT>') {<EOL>        return true;<EOL>    }<EOL>    const parallelExecution = tl.getVariable('<STR_LIT>');<EOL>    tl.debug('<STR_LIT>' + parallelExecution);<EOL>    if (parallelExecution && parallelExecution.toLowerCase() === '<STR_LIT>') {<EOL>        const","gt":"dontDistribute = tl.getBoolInput('<STR_LIT>');"}
{"input":"<s> function getTestSelectorBasedInputs(testConfiguration) {<EOL>    const testSelection = testConfiguration.testSelection.toLowerCase();<EOL>    switch (testSelection) {<EOL>","gt":"case '<STR_LIT>':"}
{"input":"<s> function getTestSelectorBasedInputs(testConfiguration) {<EOL>    const testSelection = testConfiguration.testSelection.toLowerCase();<EOL>    switch (testSelection) {<EOL>         case '<STR_LIT>':<EOL>            console.log(tl.loc('<STR_LIT>', tl.loc('<STR_LIT>')));<EOL>            testConfiguration.testplan = parseInt(tl.getInput('<STR_LIT>'));<EOL>            console.log(tl.loc('<STR_LIT>', testConfiguration.testplan));<EOL>","gt":"testConfiguration.testPlanConfigId = parseInt(tl.getInput('<STR_LIT>'));"}
{"input":"<s> function getTestSelectorBasedInputs(testConfiguration) {<EOL>    const testSelection = testConfiguration.testSelection.toLowerCase();<EOL>    switch (testSelection) {<EOL>         case '<STR_LIT>':<EOL>            console.log(tl.loc('<STR_LIT>', tl.loc('<STR_LIT>')));<EOL>            testConfiguration.testplan = parseInt(tl.getInput('<STR_LIT>'));<EOL>            console.log(tl.loc('<STR_LIT>', testConfiguration.testplan));<EOL>             testConfiguration.testPlanConfigId = parseInt(tl.getInput('<STR_LIT>'));<EOL>            console.log(tl.loc('<STR_LIT>', testConfiguration.testPlanConfigId));<EOL>            const testSuiteStrings = tl.getDelimitedInput('<STR_LIT>', '<STR_LIT>', true);<EOL>            testConfiguration.testSuites = new Array();<EOL>","gt":"testSuiteStrings.forEach((element) => {"}
{"input":"<s> function getTestSelectorBasedInputs(testConfiguration) {<EOL>    const testSelection = testConfiguration.testSelection.toLowerCase();<EOL>    switch (testSelection) {<EOL>         case '<STR_LIT>':<EOL>            console.log(tl.loc('<STR_LIT>', tl.loc('<STR_LIT>')));<EOL>            testConfiguration.testplan = parseInt(tl.getInput('<STR_LIT>'));<EOL>            console.log(tl.loc('<STR_LIT>', testConfiguration.testplan));<EOL>             testConfiguration.testPlanConfigId = parseInt(tl.getInput('<STR_LIT>'));<EOL>            console.log(tl.loc('<STR_LIT>', testConfiguration.testPlanConfigId));<EOL>            const testSuiteStrings = tl.getDelimitedInput('<STR_LIT>', '<STR_LIT>', true);<EOL>            testConfiguration.testSuites = new Array();<EOL>             testSuiteStrings.forEach((element) => {<EOL>                const","gt":"testSuiteId = parseInt(element);"}
{"input":"<s> function getTestSelectorBasedInputs(testConfiguration) {<EOL>    const testSelection = testConfiguration.testSelection.toLowerCase();<EOL>    switch (testSelection) {<EOL>         case '<STR_LIT>':<EOL>            console.log(tl.loc('<STR_LIT>', tl.loc('<STR_LIT>')));<EOL>            testConfiguration.testplan = parseInt(tl.getInput('<STR_LIT>'));<EOL>            console.log(tl.loc('<STR_LIT>', testConfiguration.testplan));<EOL>             testConfiguration.testPlanConfigId = parseInt(tl.getInput('<STR_LIT>'));<EOL>            console.log(tl.loc('<STR_LIT>', testConfiguration.testPlanConfigId));<EOL>            const testSuiteStrings = tl.getDelimitedInput('<STR_LIT>', '<STR_LIT>', true);<EOL>            testConfiguration.testSuites = new Array();<EOL>             testSuiteStrings.forEach((element) => {<EOL>                const  testSuiteId = parseInt(element);<EOL>                console.log(tl.loc('<STR_LIT>', testSuiteId));<EOL>                testConfiguration.testSuites.push(testSuiteId);<EOL>            });<EOL>            testConfiguration.sourceFilter = ['<STR_LIT>', '<STR_LIT>'];<EOL>            tl.debug('<STR_LIT>' + testConfiguration.sourceFilter);<EOL>            break;<EOL>        case '<STR_LIT>':<EOL>            console.log(tl.loc('<STR_LIT>',","gt":"tl.loc('<STR_LIT>')));"}
{"input":"<s> function getTestSelectorBasedInputs(testConfiguration) {<EOL>    const testSelection = testConfiguration.testSelection.toLowerCase();<EOL>    switch (testSelection) {<EOL>         case '<STR_LIT>':<EOL>            console.log(tl.loc('<STR_LIT>', tl.loc('<STR_LIT>')));<EOL>            testConfiguration.testplan = parseInt(tl.getInput('<STR_LIT>'));<EOL>            console.log(tl.loc('<STR_LIT>', testConfiguration.testplan));<EOL>             testConfiguration.testPlanConfigId = parseInt(tl.getInput('<STR_LIT>'));<EOL>            console.log(tl.loc('<STR_LIT>', testConfiguration.testPlanConfigId));<EOL>            const testSuiteStrings = tl.getDelimitedInput('<STR_LIT>', '<STR_LIT>', true);<EOL>            testConfiguration.testSuites = new Array();<EOL>             testSuiteStrings.forEach((element) => {<EOL>                const  testSuiteId = parseInt(element);<EOL>                console.log(tl.loc('<STR_LIT>', testSuiteId));<EOL>                testConfiguration.testSuites.push(testSuiteId);<EOL>            });<EOL>            testConfiguration.sourceFilter = ['<STR_LIT>', '<STR_LIT>'];<EOL>            tl.debug('<STR_LIT>' + testConfiguration.sourceFilter);<EOL>            break;<EOL>        case '<STR_LIT>':<EOL>            console.log(tl.loc('<STR_LIT>',  tl.loc('<STR_LIT>')));<EOL>            testConfiguration.sourceFilter = tl.getDelimitedInput('<STR_LIT>', '<STR_LIT>', true);<EOL>            console.log(tl.loc('<STR_LIT>', testConfiguration.sourceFilter));<EOL>            testConfiguration.testcaseFilter = tl.getInput('<STR_LIT>');<EOL>            console.log(tl.loc('<STR_LIT>', testConfiguration.testcaseFilter));<EOL>            break;<EOL>        case '<STR_LIT>':<EOL>            console.log(tl.loc('<STR_LIT>', tl.loc('<STR_LIT>')));<EOL>            testConfiguration.","gt":"onDemandTestRunId = tl.getInput('<STR_LIT>');"}
{"input":"<s> function publishTestResults(testResultsDirectory) {<EOL>    try {<EOL>        if (testResultsDirectory) {<EOL>            const resultFiles = tl.findMatch(testResultsDirectory, path.join(testResultsDirectory, '<STR_LIT>'));<EOL>            if (resultFiles && resultFiles.length !== <NUM_LIT>) {<EOL>                const tp = new","gt":"tl.TestPublisher('<STR_LIT>');"}
{"input":"<s> function publishTestResults(testResultsDirectory) {<EOL>    try {<EOL>        if (testResultsDirectory) {<EOL>            const resultFiles = tl.findMatch(testResultsDirectory, path.join(testResultsDirectory, '<STR_LIT>'));<EOL>            if (resultFiles && resultFiles.length !== <NUM_LIT>) {<EOL>                const tp = new  tl.TestPublisher('<STR_LIT>');<EOL>                tp.publish(resultFiles, '<STR_LIT>', vstestConfig.buildPlatform, vstestConfig.buildConfig, vstestConfig.testRunTitle, vstestConfig.publishRunAttachments);<EOL>            }<EOL>","gt":"else {"}
{"input":"<s> function publishTestResults(testResultsDirectory) {<EOL>    try {<EOL>        if (testResultsDirectory) {<EOL>            const resultFiles = tl.findMatch(testResultsDirectory, path.join(testResultsDirectory, '<STR_LIT>'));<EOL>            if (resultFiles && resultFiles.length !== <NUM_LIT>) {<EOL>                const tp = new  tl.TestPublisher('<STR_LIT>');<EOL>                tp.publish(resultFiles, '<STR_LIT>', vstestConfig.buildPlatform, vstestConfig.buildConfig, vstestConfig.testRunTitle, vstestConfig.publishRunAttachments);<EOL>            }<EOL>             else {<EOL>                console.log('<STR_LIT>');<EOL>                tl.warning(tl.loc('<STR_LIT>'));<EOL>            }<EOL>        }<EOL>","gt":"else {"}
{"input":"<s> export function processResponse(url, res, contents, onResult) {<EOL>    if (res.statusCode > <NUM_LIT>) {<EOL>        <EOL>        var msg = httpCodes[res.statusCode] ? \"<STR_LIT>\" + httpCodes[res.statusCode] : \"<STR_LIT>\";<EOL>        msg += '<STR_LIT>' + res.statusCode + '<STR_LIT>';<EOL>        if (contents && contents.length > <NUM_LIT>) {<EOL>            var","gt":"soapObj = contents;"}
{"input":"<s> function assertPathProperty(validatedPropertyName, absolutePath, relativePath) {<EOL>    const resolvedRelativePath = path.","gt":"resolve(__dirname, relativePath);"}
{"input":"<s> <EOL>export function clearStyles(option = ClearStyleOptions.all) {<EOL>    if (option === ClearStyleOptions.all || option === ClearStyleOptions.onlyNonThemable) {<EOL>        clearStylesInternal(_themeState.registeredStyles);<EOL>","gt":"_themeState.registeredStyles = [];"}
{"input":"<s> function listenerCount(emitter, evnt) {<EOL>    if (emitter.listenerCount) {<EOL>","gt":"return emitter.listenerCount(evnt);"}
{"input":"<s> async function appToIntrospection(handler) {<EOL>    const structure = await handler.getStructure();<EOL>    return {<EOL>        state: handler.state,<EOL>        appName: handler.appName,<EOL>        appDir: handler.","gt":"appDir,"}
{"input":"<s> async function appToIntrospection(handler) {<EOL>    const structure = await handler.getStructure();<EOL>    return {<EOL>        state: handler.state,<EOL>        appName: handler.appName,<EOL>        appDir: handler. appDir,<EOL>        appId: handler.appId,<EOL>        pids: handler.pids,<EOL>        uptime: handler.uptime,<EOL>        startCount: handler.","gt":"startCount,"}
{"input":"<s> async function appToIntrospection(handler) {<EOL>    const structure = await handler.getStructure();<EOL>    return {<EOL>        state: handler.state,<EOL>        appName: handler.appName,<EOL>        appDir: handler. appDir,<EOL>        appId: handler.appId,<EOL>        pids: handler.pids,<EOL>        uptime: handler.uptime,<EOL>        startCount: handler. startCount,<EOL>        restartCount: handler.restartCount,<EOL>        representation: handler.appRepresentation,<EOL>","gt":"complex: structure,"}
{"input":"<s> export function calcAppName(dir) {<EOL>    let ret;<EOL>    try {<EOL>        const pkg = require(join(process.cwd(), '<STR_LIT>'));<EOL>        pkg.","gt":"name.toString();"}
{"input":"<s> export function calcAppName(dir) {<EOL>    let ret;<EOL>    try {<EOL>        const pkg = require(join(process.cwd(), '<STR_LIT>'));<EOL>        pkg. name.toString();<EOL>        ret = removePkgNameScope(pkg.name);<EOL>    }<EOL>    catch (err) {<EOL>        ret = null;<EOL>    }<EOL>","gt":"if (!ret && dir) {"}
{"input":"<s> <EOL>export function chunkProcessor(observableArray, processor, debounce = <NUM_LIT>, maxChunkSize = <NUM_LIT>) {<EOL>    if (!isObservableArray(observableArray))<EOL>        throw new Error(\"<STR_LIT>\");<EOL>    if (!isAction(processor))<EOL>        processor =","gt":"action(\"<STR_LIT>\", processor);"}
{"input":"<s> <EOL>export function chunkProcessor(observableArray, processor, debounce = <NUM_LIT>, maxChunkSize = <NUM_LIT>) {<EOL>    if (!isObservableArray(observableArray))<EOL>        throw new Error(\"<STR_LIT>\");<EOL>    if (!isAction(processor))<EOL>        processor =  action(\"<STR_LIT>\", processor);<EOL>    const runner = () => {<EOL>        while (observableArray.length > <NUM_LIT>) {<EOL>            let","gt":"chunkSize = maxChunkSize === <NUM_LIT>"}
{"input":"<s> <EOL>function escapeString(str) {<EOL>    return","gt":"str.replace('<STR_LIT>', '<STR_LIT>');"}
{"input":"<s> function sortData(data, order) {<EOL>    data = data.map((item) => {<EOL>        let index = order.indexOf(item.symbol);<EOL>        if (","gt":"index < <NUM_LIT>) {"}
{"input":"<s> function mobileAndTabletcheck() {<EOL>    var i = !<NUM_LIT>;<EOL>    return","gt":"function (a) {"}
{"input":"<s> function tokenkind(kind) {<EOL>","gt":"return { name: getTokenName(kind), kind: kind };"}
{"input":"<s> <EOL>export function async(source, opts) {<EOL>","gt":"const works = getWorks(source, ReaderAsync, opts);"}
{"input":"<s> export function prepare(options) {<EOL>    const opts = Object.assign({<EOL>        cwd: process.cwd(),<EOL>        deep: true,<EOL>","gt":"ignore: [],"}
{"input":"<s> export function prepare(options) {<EOL>    const opts = Object.assign({<EOL>        cwd: process.cwd(),<EOL>        deep: true,<EOL>         ignore: [],<EOL>","gt":"dot: false,"}
{"input":"<s> export function prepare(options) {<EOL>    const opts = Object.assign({<EOL>        cwd: process.cwd(),<EOL>        deep: true,<EOL>         ignore: [],<EOL>         dot: false,<EOL>        stats: false,<EOL>","gt":"onlyFiles: true,"}
{"input":"<s> export function prepare(options) {<EOL>    const opts = Object.assign({<EOL>        cwd: process.cwd(),<EOL>        deep: true,<EOL>         ignore: [],<EOL>         dot: false,<EOL>        stats: false,<EOL>         onlyFiles: true,<EOL>        onlyDirectories: false,<EOL>        followSymlinkedDirectories: true,<EOL>        unique: true,<EOL>        markDirectories: false,<EOL>","gt":"absolute: false,"}
{"input":"<s> export function prepare(options) {<EOL>    const opts = Object.assign({<EOL>        cwd: process.cwd(),<EOL>        deep: true,<EOL>         ignore: [],<EOL>         dot: false,<EOL>        stats: false,<EOL>         onlyFiles: true,<EOL>        onlyDirectories: false,<EOL>        followSymlinkedDirectories: true,<EOL>        unique: true,<EOL>        markDirectories: false,<EOL>         absolute: false,<EOL>        nobrace: false,<EOL>        brace: true,<EOL>        noglobstar: false,<EOL>","gt":"globstar: true,"}
{"input":"<s> export function prepare(options) {<EOL>    const opts = Object.assign({<EOL>        cwd: process.cwd(),<EOL>        deep: true,<EOL>         ignore: [],<EOL>         dot: false,<EOL>        stats: false,<EOL>         onlyFiles: true,<EOL>        onlyDirectories: false,<EOL>        followSymlinkedDirectories: true,<EOL>        unique: true,<EOL>        markDirectories: false,<EOL>         absolute: false,<EOL>        nobrace: false,<EOL>        brace: true,<EOL>        noglobstar: false,<EOL>         globstar: true,<EOL>        noext: false,<EOL>        extension: true,<EOL>        nocase:","gt":"false,"}
{"input":"<s> export function prepare(options) {<EOL>    const opts = Object.assign({<EOL>        cwd: process.cwd(),<EOL>        deep: true,<EOL>         ignore: [],<EOL>         dot: false,<EOL>        stats: false,<EOL>         onlyFiles: true,<EOL>        onlyDirectories: false,<EOL>        followSymlinkedDirectories: true,<EOL>        unique: true,<EOL>        markDirectories: false,<EOL>         absolute: false,<EOL>        nobrace: false,<EOL>        brace: true,<EOL>        noglobstar: false,<EOL>         globstar: true,<EOL>        noext: false,<EOL>        extension: true,<EOL>        nocase:  false,<EOL>        case: true,<EOL>        matchBase: false,<EOL>        transform: null<EOL>    }, options);<EOL>    if (opts.onlyDirectories) {<EOL>        opts.onlyFiles = false;<EOL>    }<EOL>    opts.brace = !opts.","gt":"nobrace;"}
{"input":"<s> <EOL>export function getPositivePatterns(patterns) {<EOL>    return patternUtils.getPositivePatterns(","gt":"patterns);"}
{"input":"<s> <EOL>export function groupPatternsByBaseDirectory(patterns) {<EOL>    return patterns.reduce((collection, pattern) => {<EOL>        const base = patternUtils.getBaseDirectory(pattern);<EOL>        if (base in collection) {<EOL>            collection[base].push(","gt":"pattern);"}
{"input":"<s> function getDeepFilterInstance(options) {<EOL>    const preparedOptions = optionsManager.prepare(options);<EOL>","gt":"return new DeepFilter(preparedOptions, {"}
{"input":"<s> export function bityOrderStatusSucceededSwap(payload) {<EOL>    return {<EOL>        type: TypeKeys.","gt":"SWAP_BITY_ORDER_STATUS_SUCCEEDED,"}
{"input":"<s> export function shapeshiftOrderStatusSucceededSwap(payload) {<EOL>    return {<EOL>        type: TypeKeys.","gt":"SWAP_SHAPESHIFT_ORDER_STATUS_SUCCEEDED,"}
{"input":"<s> export function startPollShapeshiftOrderStatus() {<EOL>","gt":"return {"}
{"input":"<s> <EOL>export function hexEncodeData(value) {<EOL>    return","gt":"bufferToHex(toBuffer(value));"}
{"input":"<s> function formatErrors(response, apiType) {<EOL>    if (response.error) {<EOL>        <EOL>        <EOL>        <EOL>        <EOL>        const lines = response.error.message.split('<STR_LIT>');<EOL>        if (lines.length > <NUM_LIT>) {<EOL>            return lines[<NUM_LIT>].split('<STR_LIT>').pop();<EOL>        }<EOL>        else {<EOL>","gt":"return `<STR_LIT>`;"}
{"input":"<s> function updateWalletValues(wallets, newWallet) {<EOL>    return wallets.map((w) => {<EOL>        if (w.address === newWallet.address) {<EOL>","gt":"return {"}
{"input":"<s> function setWalletTokens(state) {<EOL>    return {<EOL>        ...","gt":"state,"}
{"input":"<s> export function* setField(payload) {<EOL>    const etherTransaction = yield select(isEtherTransaction);<EOL>    if (etherTransaction) {<EOL>        yield","gt":"put(setToField(payload));"}
{"input":"<s> export function* updateBalances() {<EOL>    const updateAccount = yield fork(updateAccountBalance);<EOL>    const updateToken = yield fork(","gt":"updateTokenBalances);"}
{"input":"<s> export function getNodeOptions(state) {<EOL>    return [...getStaticNodeOptions(","gt":"state), ...getCustomNodeOptions(state)];"}
{"input":"<s> export function getWalletConfig(state) {<EOL>","gt":"return state.wallet.config;"}
{"input":"<s> export function ensV3Url(name) {<EOL>","gt":"return `<STR_LIT>`;"}
{"input":"<s> function promiseFromChildProcess(command) {<EOL>    return new Promise((resolve, reject) => {<EOL>        return","gt":"exec(command, (err, stdout) => {"}
{"input":"<s> export function main() {<EOL>    t.describe('<STR_LIT>', () => {<EOL>        t.be(testModuleConfig);<EOL>        t.it('<STR_LIT>', t.async(() => {<EOL>            TestBed.compileComponents()<EOL>                .then(() => {<EOL>                let fixture =","gt":"TestBed.createComponent(TestComponent);"}
{"input":"<s> export function main() {<EOL>    t.describe('<STR_LIT>', () => {<EOL>        t.be(testModuleConfig);<EOL>        t.it('<STR_LIT>', t.async(() => {<EOL>            TestBed.compileComponents()<EOL>                .then(() => {<EOL>                let fixture =  TestBed.createComponent(TestComponent);<EOL>                fixture.detectChanges();<EOL>                let homeInstance = fixture.debugElement.children[<NUM_LIT>].componentInstance;<EOL>                let homeDOMEl = fixture.debugElement.children[<NUM_LIT>].nativeElement;<EOL>                t.e(homeDOMEl.","gt":"querySelectorAll('<STR_LIT>').length).toEqual(<NUM_LIT>);"}
{"input":"<s> export function main() {<EOL>    t.describe('<STR_LIT>', () => {<EOL>        t.be(testModuleConfig);<EOL>        t.it('<STR_LIT>', t.async(() => {<EOL>            TestBed.compileComponents()<EOL>                .then(() => {<EOL>                let fixture =  TestBed.createComponent(TestComponent);<EOL>                fixture.detectChanges();<EOL>                let homeInstance = fixture.debugElement.children[<NUM_LIT>].componentInstance;<EOL>                let homeDOMEl = fixture.debugElement.children[<NUM_LIT>].nativeElement;<EOL>                t.e(homeDOMEl. querySelectorAll('<STR_LIT>').length).toEqual(<NUM_LIT>);<EOL>                homeInstance.newName = '<STR_LIT>';<EOL>                homeInstance.addName();<EOL>                fixture.detectChanges();<EOL>","gt":"t.e(homeDOMEl.querySelectorAll('<STR_LIT>').length).toEqual(<NUM_LIT>);"}
{"input":"<s> <EOL>export function GET_HTTP_PROVIDERS_INJECTOR(additionalProviders) {<EOL>    if (additionalProviders) {<EOL>","gt":"providers = providers.concat(additionalProviders);"}
{"input":"<s> export function cons() {<EOL>    return","gt":"console;"}
{"input":"<s> export function consoleLogTarget(consoleService) {<EOL>    return new","gt":"ConsoleTarget(consoleService, { minLogLevel: LogLevel.Debug });"}
{"input":"<s> <EOL>function getBuildType() {<EOL>    let type = (argv['<STR_LIT>'] || argv['<STR_LIT>'] || '<STR_LIT>').toLowerCase();<EOL>    let base = argv['<STR_LIT>'];<EOL>    let prodKeyword = !!base.filter((o) => o.indexOf(BUILD_TYPES.PRODUCTION) >=","gt":"<NUM_LIT>).pop();"}
{"input":"<s> async function createProjectFile(testInjector) {<EOL>    const tempFolder = temp.mkdirSync(\"<STR_LIT>\");<EOL>    const options = testInjector.resolve(\"<STR_LIT>\");<EOL>    options.path = tempFolder;<EOL>","gt":"const projectData = {"}
{"input":"<s> export function onModalFrame(args) {<EOL>    const view = args.object;<EOL>","gt":"const frame = new Frame();"}
{"input":"<s> function markAsUnread(id) {<EOL>","gt":"loadReadArticles()[id] = false;"}
{"input":"<s> export function pageNavigatingTo(args) {<EOL>    var page = args.object;<EOL>    page.bindingContext =","gt":"dataModel;"}
{"input":"<s> export function doNotShowAndroidKeyboard(args) {<EOL>    let searchBar = args.object;<EOL>    if (","gt":"searchBar.android) {"}
{"input":"<s> export function saveChanges(args) {<EOL>    var page = args.object.page;<EOL>    var dataForm = viewModule.getViewById(page, \"<STR_LIT>\");<EOL>    dataForm.commitAll();<EOL>","gt":"if (dataForm.hasValidationErrors()) {"}
{"input":"<s> export function saveChanges(args) {<EOL>    var page = args.object.page;<EOL>    var dataForm = viewModule.getViewById(page, \"<STR_LIT>\");<EOL>    dataForm.commitAll();<EOL>     if (dataForm.hasValidationErrors()) {<EOL>        return;<EOL>    }<EOL>    if (model.isNew) {<EOL>        model.reservations.","gt":"push(model.currentReservation);"}
{"input":"<s> export function drawerLoaded(args) {<EOL>    var drawer = args.object;<EOL>    drawer.gesturesEnabled = false;<EOL>    if (!drawer.autoCloseAssigned) {<EOL>","gt":"drawer.autoCloseAssigned = true;"}
{"input":"<s> export function drawerLoaded(args) {<EOL>    var drawer = args.object;<EOL>    drawer.gesturesEnabled = false;<EOL>    if (!drawer.autoCloseAssigned) {<EOL>         drawer.autoCloseAssigned = true;<EOL>        drawer.page.on(\"<STR_LIT>\", (args) => {<EOL>            drawer.closeDrawer();<EOL>        });<EOL>        if (drawer.ios) {<EOL>            drawer.ios.defaultSideDrawer.style.shadowMode = TKSideDrawerShadowMode.TKSideDrawerShadowModeSideDrawer;<EOL>            drawer.ios.defaultSideDrawer.style.","gt":"dimOpacity = <NUM_LIT>;"}
{"input":"<s> export function openLink(args) {<EOL>    navigator.openLink(args.","gt":"object);"}
{"input":"<s> export function fromObjectRecursive(source) {<EOL>    let observable =","gt":"new ObservableFromObject();"}
{"input":"<s> export function minFps() {<EOL>    return","gt":"_minFps;"}
{"input":"<s> export function reset() {<EOL>","gt":"_minFps = <NUM_LIT>;"}
{"input":"<s> export function stop() {<EOL>    if (!native) {<EOL>","gt":"return;"}
{"input":"<s> export function Experimental(target, key, descriptor) {<EOL>    if (descriptor) {<EOL>        var originalMethod = descriptor.value;<EOL>        descriptor.value = function (...args) {<EOL>","gt":"console.log(`<STR_LIT>`);"}
{"input":"<s> export function Experimental(target, key, descriptor) {<EOL>    if (descriptor) {<EOL>        var originalMethod = descriptor.value;<EOL>        descriptor.value = function (...args) {<EOL>             console.log(`<STR_LIT>`);<EOL>            return originalMethod.apply(this, args);<EOL>        };<EOL>        return descriptor;<EOL>    }<EOL>    else {<EOL>        console.log(","gt":"target)} is experimental`<STR_LIT>;"}
{"input":"<s> export function getString(arg) {<EOL>    return new Promise((resolve, reject) => {<EOL>        httpRequest.request(typeof arg === \"<STR_LIT>\" ? { url: arg, method: \"<STR_LIT>\" } : arg)<EOL>            .then((r) => {<EOL>","gt":"try {"}
{"input":"<s> function getFileName(path) {<EOL>    let fileName = typeof path === \"<STR_LIT>\" ? path.trim() : \"<STR_LIT>\";<EOL>    if (fileName.indexOf(\"<STR_LIT>\") ===","gt":"<NUM_LIT>) {"}
{"input":"<s> function countersProfileFunctionFactory(fn, name, type = MemberType.Instance) {<EOL>    profileNames.push(name);<EOL>    return function () {<EOL>        start(name);<EOL>","gt":"try {"}
{"input":"<s> function countersProfileFunctionFactory(fn, name, type = MemberType.Instance) {<EOL>    profileNames.push(name);<EOL>    return function () {<EOL>        start(name);<EOL>         try {<EOL>            return fn.apply(this, arguments);<EOL>        }<EOL>        finally {<EOL>            stop(","gt":"name);"}
{"input":"<s> export function start(name) {<EOL>    let info = timers[name];<EOL>    if (info) {<EOL>        info.currentStart = time();<EOL>        info.runCount++;<EOL>    }<EOL>    else {<EOL>        info = {<EOL>            totalTime: <NUM_LIT>,<EOL>","gt":"count: <NUM_LIT>,"}
{"input":"<s> export function trace(message, start, end) {<EOL>    log(","gt":"message}  (${start}ms. - ${end}ms.)`<STR_LIT>;"}
{"input":"<s> function createHandlerAndGetId() {<EOL>    if (!timeoutHandler) {<EOL>        timeoutHandler = new","gt":"android.os.Handler(android.os.Looper.myLooper());"}
{"input":"<s> export function isEnabled() {<EOL>","gt":"return enabled;"}
{"input":"<s> export function write(message, category, type) {<EOL>    <EOL>    let i;<EOL>    if (type === messageType.error) {<EOL>        for (i = <NUM_LIT>; i < _writers.length; i++) {<EOL>            _writers[i].write(message, category, type);<EOL>        }<EOL>        return;<EOL>    }<EOL>    if (!enabled) {<EOL>","gt":"return;"}
{"input":"<s> export function write(message, category, type) {<EOL>    <EOL>    let i;<EOL>    if (type === messageType.error) {<EOL>        for (i = <NUM_LIT>; i < _writers.length; i++) {<EOL>            _writers[i].write(message, category, type);<EOL>        }<EOL>        return;<EOL>    }<EOL>    if (!enabled) {<EOL>         return;<EOL>    }<EOL>    if (!(category in _categories)) {<EOL>","gt":"return;"}
{"input":"<s> function generateItemId() {<EOL>","gt":"actionItemIdGenerator++;"}
{"input":"<s> function getIconVisibility(iconVisibility) {<EOL>    switch (iconVisibility) {<EOL>        case \"<STR_LIT>\":<EOL>","gt":"return true;"}
{"input":"<s> export function loadPage(moduleNamePath, fileName, context) {<EOL>    const","gt":"componentModule = loadInternal(fileName, context, moduleNamePath);"}
{"input":"<s> <EOL><EOL>export function isEventOrGesture(name, view) {<EOL>    if (typeof name === \"<STR_LIT>\") {<EOL>        let","gt":"eventOrGestureName = getEventOrGestureName(name);"}
{"input":"<s> export function _getProperties() {<EOL>    return getPropertiesFromMap(symbolPropertyMap)","gt":";"}
{"input":"<s> export function getSetProperties(view) {<EOL>    const result = [];<EOL>    Object.getOwnPropertyNames(view).forEach((prop) => {<EOL>        result.push([prop, view[prop]]);<EOL>    });<EOL>    let symbols = Object.getOwnPropertySymbols(","gt":"view);"}
{"input":"<s> export function getSetProperties(view) {<EOL>    const result = [];<EOL>    Object.getOwnPropertyNames(view).forEach((prop) => {<EOL>        result.push([prop, view[prop]]);<EOL>    });<EOL>    let symbols = Object.getOwnPropertySymbols( view);<EOL>    for (let symbol of symbols) {<EOL>        const property = symbolPropertyMap[symbol];<EOL>        if (!property) {<EOL>            continue;<EOL>        }<EOL>","gt":"const value = view[property.key];"}
{"input":"<s> export function confirm(arg) {<EOL>    return new Promise((resolve, reject) => {<EOL>        try {<EOL>            const options = !isDialogOptions(arg) ? { title: CONFIRM, okButtonText: OK, cancelButtonText: CANCEL, message: arg + \"<STR_LIT>\" } : arg;<EOL>            const alert = createAlertDialog(","gt":"options);"}
{"input":"<s> export function confirm(arg) {<EOL>    return new Promise((resolve, reject) => {<EOL>        try {<EOL>            const options = !isDialogOptions(arg) ? { title: CONFIRM, okButtonText: OK, cancelButtonText: CANCEL, message: arg + \"<STR_LIT>\" } : arg;<EOL>            const alert = createAlertDialog( options);<EOL>            addButtonsToAlertDialog(alert, options, function (result) { resolve(result); });<EOL>            showDialog(alert);<EOL>        }<EOL>        catch (ex) {<EOL>","gt":"reject(ex);"}
{"input":"<s> function isString(value) {<EOL>    return typeof","gt":"value === \"<STR_LIT>\";"}
{"input":"<s> function getDialogResult(buttons, index) {<EOL>    let hasCancel = buttons & allertButtons.cancel;<EOL>    let hasNeutral = buttons & allertButtons.neutral;<EOL>    let hasOk = buttons & allertButtons.ok;<EOL>    if (hasCancel && hasNeutral && hasOk) {<EOL>","gt":"return index === <NUM_LIT> ? false : index === <NUM_LIT> ? true : undefined;"}
{"input":"<s> function getDialogResult(buttons, index) {<EOL>    let hasCancel = buttons & allertButtons.cancel;<EOL>    let hasNeutral = buttons & allertButtons.neutral;<EOL>    let hasOk = buttons & allertButtons.ok;<EOL>    if (hasCancel && hasNeutral && hasOk) {<EOL>         return index === <NUM_LIT> ? false : index === <NUM_LIT> ? true : undefined;<EOL>    }<EOL>","gt":"else if (buttons & hasNeutral && hasOk) {"}
{"input":"<s> function getDialogResult(buttons, index) {<EOL>    let hasCancel = buttons & allertButtons.cancel;<EOL>    let hasNeutral = buttons & allertButtons.neutral;<EOL>    let hasOk = buttons & allertButtons.ok;<EOL>    if (hasCancel && hasNeutral && hasOk) {<EOL>         return index === <NUM_LIT> ? false : index === <NUM_LIT> ? true : undefined;<EOL>    }<EOL>     else if (buttons & hasNeutral && hasOk) {<EOL>        return index === <NUM_LIT> ? undefined : true;<EOL>    }<EOL>    else if (hasCancel && hasOk) {<EOL>        return index !== <NUM_LIT>;<EOL>    }<EOL>    else if (hasCancel && hasNeutral) {<EOL>        return index === <NUM_LIT> ? false : undefined;<EOL>    }<EOL>    else if (hasCancel) {<EOL>","gt":"return false;"}
{"input":"<s> export function _getAnimatedEntries(frameId) {<EOL>    return waitingQueue.","gt":"get(frameId);"}
{"input":"<s> function setupNewFragmentFadeTransition(navTransition, entry) {<EOL>    setupCurrentFragmentFadeTransition(navTransition, entry);<EOL>    const fadeInEnter = new android.","gt":"transition.Fade(android.transition.Fade.IN);"}
{"input":"<s> export function stack() {<EOL>    return","gt":"frameStack;"}
{"input":"<s> function clearNonUniformBorders(nativeView) {<EOL>    if (nativeView.borderLayer) {<EOL>        nativeView.borderLayer.removeFromSuperlayer();<EOL>    }<EOL>    if (","gt":"nativeView.hasBorderMask) {"}
{"input":"<s> function clearNonUniformBorders(nativeView) {<EOL>    if (nativeView.borderLayer) {<EOL>        nativeView.borderLayer.removeFromSuperlayer();<EOL>    }<EOL>    if ( nativeView.hasBorderMask) {<EOL>        nativeView.layer.mask = nativeView.borderOriginalMask;<EOL>        nativeView.hasBorderMask = false;<EOL>        nativeView.","gt":"borderOriginalMask = null;"}
{"input":"<s> function clearNonUniformBorders(nativeView) {<EOL>    if (nativeView.borderLayer) {<EOL>        nativeView.borderLayer.removeFromSuperlayer();<EOL>    }<EOL>    if ( nativeView.hasBorderMask) {<EOL>        nativeView.layer.mask = nativeView.borderOriginalMask;<EOL>        nativeView.hasBorderMask = false;<EOL>        nativeView. borderOriginalMask = null;<EOL>    }<EOL>    if (nativeView.topBorderLayer) {<EOL>        nativeView.topBorderLayer.removeFromSuperlayer();<EOL>    }<EOL>    if (nativeView.rightBorderLayer) {<EOL>        nativeView.rightBorderLayer.removeFromSuperlayer();<EOL>    }<EOL>    if (nativeView.bottomBorderLayer) {<EOL>","gt":"nativeView.bottomBorderLayer.removeFromSuperlayer();"}
{"input":"<s> function getDrawParams(image, background, width, height) {<EOL>    if (!image) {<EOL>","gt":"return null;"}
{"input":"<s> function getDrawParams(image, background, width, height) {<EOL>    if (!image) {<EOL>         return null;<EOL>    }<EOL>","gt":"const res = {"}
{"input":"<s> function getDrawParams(image, background, width, height) {<EOL>    if (!image) {<EOL>         return null;<EOL>    }<EOL>     const res = {<EOL>        repeatX: true,<EOL>        repeatY: true,<EOL>        posX: <NUM_LIT>,<EOL>        posY: <NUM_LIT>,<EOL>    };<EOL>    <EOL>    if (background.repeat) {<EOL>        switch (background.repeat.toLowerCase()) {<EOL>","gt":"case \"<STR_LIT>\":"}
{"input":"<s> function getDrawParams(image, background, width, height) {<EOL>    if (!image) {<EOL>         return null;<EOL>    }<EOL>     const res = {<EOL>        repeatX: true,<EOL>        repeatY: true,<EOL>        posX: <NUM_LIT>,<EOL>        posY: <NUM_LIT>,<EOL>    };<EOL>    <EOL>    if (background.repeat) {<EOL>        switch (background.repeat.toLowerCase()) {<EOL>             case \"<STR_LIT>\":<EOL>                res.repeatX = false;<EOL>                res.repeatY = false;<EOL>                break;<EOL>            case \"<STR_LIT>\":<EOL>                res.repeatY =","gt":"false;"}
{"input":"<s> function getDrawParams(image, background, width, height) {<EOL>    if (!image) {<EOL>         return null;<EOL>    }<EOL>     const res = {<EOL>        repeatX: true,<EOL>        repeatY: true,<EOL>        posX: <NUM_LIT>,<EOL>        posY: <NUM_LIT>,<EOL>    };<EOL>    <EOL>    if (background.repeat) {<EOL>        switch (background.repeat.toLowerCase()) {<EOL>             case \"<STR_LIT>\":<EOL>                res.repeatX = false;<EOL>                res.repeatY = false;<EOL>                break;<EOL>            case \"<STR_LIT>\":<EOL>                res.repeatY =  false;<EOL>                break;<EOL>","gt":"case \"<STR_LIT>\":"}
{"input":"<s> function getDrawParams(image, background, width, height) {<EOL>    if (!image) {<EOL>         return null;<EOL>    }<EOL>     const res = {<EOL>        repeatX: true,<EOL>        repeatY: true,<EOL>        posX: <NUM_LIT>,<EOL>        posY: <NUM_LIT>,<EOL>    };<EOL>    <EOL>    if (background.repeat) {<EOL>        switch (background.repeat.toLowerCase()) {<EOL>             case \"<STR_LIT>\":<EOL>                res.repeatX = false;<EOL>                res.repeatY = false;<EOL>                break;<EOL>            case \"<STR_LIT>\":<EOL>                res.repeatY =  false;<EOL>                break;<EOL>             case \"<STR_LIT>\":<EOL>                res.repeatX = false;<EOL>                break;<EOL>        }<EOL>    }<EOL>    const imageSize = image.size;<EOL>    let imageWidth = imageSize.width;<EOL>    let imageHeight = imageSize.height;<EOL>    <EOL>    const size = background.","gt":"size;"}
{"input":"<s> function getDrawParams(image, background, width, height) {<EOL>    if (!image) {<EOL>         return null;<EOL>    }<EOL>     const res = {<EOL>        repeatX: true,<EOL>        repeatY: true,<EOL>        posX: <NUM_LIT>,<EOL>        posY: <NUM_LIT>,<EOL>    };<EOL>    <EOL>    if (background.repeat) {<EOL>        switch (background.repeat.toLowerCase()) {<EOL>             case \"<STR_LIT>\":<EOL>                res.repeatX = false;<EOL>                res.repeatY = false;<EOL>                break;<EOL>            case \"<STR_LIT>\":<EOL>                res.repeatY =  false;<EOL>                break;<EOL>             case \"<STR_LIT>\":<EOL>                res.repeatX = false;<EOL>                break;<EOL>        }<EOL>    }<EOL>    const imageSize = image.size;<EOL>    let imageWidth = imageSize.width;<EOL>    let imageHeight = imageSize.height;<EOL>    <EOL>    const size = background. size;<EOL>    if (size) {<EOL>        const values =","gt":"cssParse(size);"}
{"input":"<s> function getDrawParams(image, background, width, height) {<EOL>    if (!image) {<EOL>         return null;<EOL>    }<EOL>     const res = {<EOL>        repeatX: true,<EOL>        repeatY: true,<EOL>        posX: <NUM_LIT>,<EOL>        posY: <NUM_LIT>,<EOL>    };<EOL>    <EOL>    if (background.repeat) {<EOL>        switch (background.repeat.toLowerCase()) {<EOL>             case \"<STR_LIT>\":<EOL>                res.repeatX = false;<EOL>                res.repeatY = false;<EOL>                break;<EOL>            case \"<STR_LIT>\":<EOL>                res.repeatY =  false;<EOL>                break;<EOL>             case \"<STR_LIT>\":<EOL>                res.repeatX = false;<EOL>                break;<EOL>        }<EOL>    }<EOL>    const imageSize = image.size;<EOL>    let imageWidth = imageSize.width;<EOL>    let imageHeight = imageSize.height;<EOL>    <EOL>    const size = background. size;<EOL>    if (size) {<EOL>        const values =  cssParse(size);<EOL>        if (values.length === <NUM_LIT>) {<EOL>            const vx = values[<NUM_LIT>];<EOL>            const vy = values[<NUM_LIT>];<EOL>            if (vx.unit === \"<STR_LIT>\" && vy.unit === \"<STR_LIT>\") {<EOL>                imageWidth = width * vx.value / <NUM_LIT>;<EOL>                imageHeight = height * vy.value / <NUM_LIT>;<EOL>                res.sizeX = imageWidth;<EOL>                res.sizeY = imageHeight;<EOL>            }<EOL>            else if (vx.type === \"<STR_LIT>\" && vy.type === \"<STR_LIT>\" &&<EOL>                ((vx.unit ===","gt":"\"<STR_LIT>\" && vy.unit === \"<STR_LIT>\") || (vx.unit === \"<STR_LIT>\" && vy.unit === \"<STR_LIT>\"))) {"}
{"input":"<s> function getDrawParams(image, background, width, height) {<EOL>    if (!image) {<EOL>         return null;<EOL>    }<EOL>     const res = {<EOL>        repeatX: true,<EOL>        repeatY: true,<EOL>        posX: <NUM_LIT>,<EOL>        posY: <NUM_LIT>,<EOL>    };<EOL>    <EOL>    if (background.repeat) {<EOL>        switch (background.repeat.toLowerCase()) {<EOL>             case \"<STR_LIT>\":<EOL>                res.repeatX = false;<EOL>                res.repeatY = false;<EOL>                break;<EOL>            case \"<STR_LIT>\":<EOL>                res.repeatY =  false;<EOL>                break;<EOL>             case \"<STR_LIT>\":<EOL>                res.repeatX = false;<EOL>                break;<EOL>        }<EOL>    }<EOL>    const imageSize = image.size;<EOL>    let imageWidth = imageSize.width;<EOL>    let imageHeight = imageSize.height;<EOL>    <EOL>    const size = background. size;<EOL>    if (size) {<EOL>        const values =  cssParse(size);<EOL>        if (values.length === <NUM_LIT>) {<EOL>            const vx = values[<NUM_LIT>];<EOL>            const vy = values[<NUM_LIT>];<EOL>            if (vx.unit === \"<STR_LIT>\" && vy.unit === \"<STR_LIT>\") {<EOL>                imageWidth = width * vx.value / <NUM_LIT>;<EOL>                imageHeight = height * vy.value / <NUM_LIT>;<EOL>                res.sizeX = imageWidth;<EOL>                res.sizeY = imageHeight;<EOL>            }<EOL>            else if (vx.type === \"<STR_LIT>\" && vy.type === \"<STR_LIT>\" &&<EOL>                ((vx.unit ===  \"<STR_LIT>\" && vy.unit === \"<STR_LIT>\") || (vx.unit === \"<STR_LIT>\" && vy.unit === \"<STR_LIT>\"))) {<EOL>                imageWidth = vx.value;<EOL>                imageHeight = vy.value;<EOL>                res.sizeX = imageWidth;<EOL>                res.sizeY = imageHeight;<EOL>            }<EOL>        }<EOL>        else if (values.length === <NUM_LIT> && values[<NUM_LIT>].type === \"<STR_LIT>\") {<EOL>            let scale = <NUM_LIT>;<EOL>            if (values[<NUM_LIT>].string === \"<STR_LIT>\") {<EOL>                scale = Math.max(width / imageWidth, height / imageHeight);<EOL>            }<EOL>            else","gt":"if (values[<NUM_LIT>].string === \"<STR_LIT>\") {"}
{"input":"<s> function getDrawParams(image, background, width, height) {<EOL>    if (!image) {<EOL>         return null;<EOL>    }<EOL>     const res = {<EOL>        repeatX: true,<EOL>        repeatY: true,<EOL>        posX: <NUM_LIT>,<EOL>        posY: <NUM_LIT>,<EOL>    };<EOL>    <EOL>    if (background.repeat) {<EOL>        switch (background.repeat.toLowerCase()) {<EOL>             case \"<STR_LIT>\":<EOL>                res.repeatX = false;<EOL>                res.repeatY = false;<EOL>                break;<EOL>            case \"<STR_LIT>\":<EOL>                res.repeatY =  false;<EOL>                break;<EOL>             case \"<STR_LIT>\":<EOL>                res.repeatX = false;<EOL>                break;<EOL>        }<EOL>    }<EOL>    const imageSize = image.size;<EOL>    let imageWidth = imageSize.width;<EOL>    let imageHeight = imageSize.height;<EOL>    <EOL>    const size = background. size;<EOL>    if (size) {<EOL>        const values =  cssParse(size);<EOL>        if (values.length === <NUM_LIT>) {<EOL>            const vx = values[<NUM_LIT>];<EOL>            const vy = values[<NUM_LIT>];<EOL>            if (vx.unit === \"<STR_LIT>\" && vy.unit === \"<STR_LIT>\") {<EOL>                imageWidth = width * vx.value / <NUM_LIT>;<EOL>                imageHeight = height * vy.value / <NUM_LIT>;<EOL>                res.sizeX = imageWidth;<EOL>                res.sizeY = imageHeight;<EOL>            }<EOL>            else if (vx.type === \"<STR_LIT>\" && vy.type === \"<STR_LIT>\" &&<EOL>                ((vx.unit ===  \"<STR_LIT>\" && vy.unit === \"<STR_LIT>\") || (vx.unit === \"<STR_LIT>\" && vy.unit === \"<STR_LIT>\"))) {<EOL>                imageWidth = vx.value;<EOL>                imageHeight = vy.value;<EOL>                res.sizeX = imageWidth;<EOL>                res.sizeY = imageHeight;<EOL>            }<EOL>        }<EOL>        else if (values.length === <NUM_LIT> && values[<NUM_LIT>].type === \"<STR_LIT>\") {<EOL>            let scale = <NUM_LIT>;<EOL>            if (values[<NUM_LIT>].string === \"<STR_LIT>\") {<EOL>                scale = Math.max(width / imageWidth, height / imageHeight);<EOL>            }<EOL>            else  if (values[<NUM_LIT>].string === \"<STR_LIT>\") {<EOL>                scale = Math.min(width / imageWidth, height / imageHeight);<EOL>            }<EOL>            if (scale > <NUM_LIT>) {<EOL>                imageWidth *= scale;<EOL>                imageHeight *= scale;<EOL>                res.","gt":"sizeX = imageWidth;"}
{"input":"<s> function getDrawParams(image, background, width, height) {<EOL>    if (!image) {<EOL>         return null;<EOL>    }<EOL>     const res = {<EOL>        repeatX: true,<EOL>        repeatY: true,<EOL>        posX: <NUM_LIT>,<EOL>        posY: <NUM_LIT>,<EOL>    };<EOL>    <EOL>    if (background.repeat) {<EOL>        switch (background.repeat.toLowerCase()) {<EOL>             case \"<STR_LIT>\":<EOL>                res.repeatX = false;<EOL>                res.repeatY = false;<EOL>                break;<EOL>            case \"<STR_LIT>\":<EOL>                res.repeatY =  false;<EOL>                break;<EOL>             case \"<STR_LIT>\":<EOL>                res.repeatX = false;<EOL>                break;<EOL>        }<EOL>    }<EOL>    const imageSize = image.size;<EOL>    let imageWidth = imageSize.width;<EOL>    let imageHeight = imageSize.height;<EOL>    <EOL>    const size = background. size;<EOL>    if (size) {<EOL>        const values =  cssParse(size);<EOL>        if (values.length === <NUM_LIT>) {<EOL>            const vx = values[<NUM_LIT>];<EOL>            const vy = values[<NUM_LIT>];<EOL>            if (vx.unit === \"<STR_LIT>\" && vy.unit === \"<STR_LIT>\") {<EOL>                imageWidth = width * vx.value / <NUM_LIT>;<EOL>                imageHeight = height * vy.value / <NUM_LIT>;<EOL>                res.sizeX = imageWidth;<EOL>                res.sizeY = imageHeight;<EOL>            }<EOL>            else if (vx.type === \"<STR_LIT>\" && vy.type === \"<STR_LIT>\" &&<EOL>                ((vx.unit ===  \"<STR_LIT>\" && vy.unit === \"<STR_LIT>\") || (vx.unit === \"<STR_LIT>\" && vy.unit === \"<STR_LIT>\"))) {<EOL>                imageWidth = vx.value;<EOL>                imageHeight = vy.value;<EOL>                res.sizeX = imageWidth;<EOL>                res.sizeY = imageHeight;<EOL>            }<EOL>        }<EOL>        else if (values.length === <NUM_LIT> && values[<NUM_LIT>].type === \"<STR_LIT>\") {<EOL>            let scale = <NUM_LIT>;<EOL>            if (values[<NUM_LIT>].string === \"<STR_LIT>\") {<EOL>                scale = Math.max(width / imageWidth, height / imageHeight);<EOL>            }<EOL>            else  if (values[<NUM_LIT>].string === \"<STR_LIT>\") {<EOL>                scale = Math.min(width / imageWidth, height / imageHeight);<EOL>            }<EOL>            if (scale > <NUM_LIT>) {<EOL>                imageWidth *= scale;<EOL>                imageHeight *= scale;<EOL>                res. sizeX = imageWidth;<EOL>                res.sizeY =","gt":"imageHeight;"}
{"input":"<s> function getDrawParams(image, background, width, height) {<EOL>    if (!image) {<EOL>         return null;<EOL>    }<EOL>     const res = {<EOL>        repeatX: true,<EOL>        repeatY: true,<EOL>        posX: <NUM_LIT>,<EOL>        posY: <NUM_LIT>,<EOL>    };<EOL>    <EOL>    if (background.repeat) {<EOL>        switch (background.repeat.toLowerCase()) {<EOL>             case \"<STR_LIT>\":<EOL>                res.repeatX = false;<EOL>                res.repeatY = false;<EOL>                break;<EOL>            case \"<STR_LIT>\":<EOL>                res.repeatY =  false;<EOL>                break;<EOL>             case \"<STR_LIT>\":<EOL>                res.repeatX = false;<EOL>                break;<EOL>        }<EOL>    }<EOL>    const imageSize = image.size;<EOL>    let imageWidth = imageSize.width;<EOL>    let imageHeight = imageSize.height;<EOL>    <EOL>    const size = background. size;<EOL>    if (size) {<EOL>        const values =  cssParse(size);<EOL>        if (values.length === <NUM_LIT>) {<EOL>            const vx = values[<NUM_LIT>];<EOL>            const vy = values[<NUM_LIT>];<EOL>            if (vx.unit === \"<STR_LIT>\" && vy.unit === \"<STR_LIT>\") {<EOL>                imageWidth = width * vx.value / <NUM_LIT>;<EOL>                imageHeight = height * vy.value / <NUM_LIT>;<EOL>                res.sizeX = imageWidth;<EOL>                res.sizeY = imageHeight;<EOL>            }<EOL>            else if (vx.type === \"<STR_LIT>\" && vy.type === \"<STR_LIT>\" &&<EOL>                ((vx.unit ===  \"<STR_LIT>\" && vy.unit === \"<STR_LIT>\") || (vx.unit === \"<STR_LIT>\" && vy.unit === \"<STR_LIT>\"))) {<EOL>                imageWidth = vx.value;<EOL>                imageHeight = vy.value;<EOL>                res.sizeX = imageWidth;<EOL>                res.sizeY = imageHeight;<EOL>            }<EOL>        }<EOL>        else if (values.length === <NUM_LIT> && values[<NUM_LIT>].type === \"<STR_LIT>\") {<EOL>            let scale = <NUM_LIT>;<EOL>            if (values[<NUM_LIT>].string === \"<STR_LIT>\") {<EOL>                scale = Math.max(width / imageWidth, height / imageHeight);<EOL>            }<EOL>            else  if (values[<NUM_LIT>].string === \"<STR_LIT>\") {<EOL>                scale = Math.min(width / imageWidth, height / imageHeight);<EOL>            }<EOL>            if (scale > <NUM_LIT>) {<EOL>                imageWidth *= scale;<EOL>                imageHeight *= scale;<EOL>                res. sizeX = imageWidth;<EOL>                res.sizeY =  imageHeight;<EOL>            }<EOL>        }<EOL>    }<EOL>    <EOL>    const position = background.position;<EOL>    if (position) {<EOL>        const v = parsePosition(position);<EOL>        if (v) {<EOL>            const spaceX = width - imageWidth;<EOL>            const spaceY = height - imageHeight;<EOL>            if (v.x.unit === \"<STR_LIT>\" && v.y.unit === \"<STR_LIT>\") {<EOL>                res.","gt":"posX = spaceX * v.x.value / <NUM_LIT>;"}
{"input":"<s> function getDrawParams(image, background, width, height) {<EOL>    if (!image) {<EOL>         return null;<EOL>    }<EOL>     const res = {<EOL>        repeatX: true,<EOL>        repeatY: true,<EOL>        posX: <NUM_LIT>,<EOL>        posY: <NUM_LIT>,<EOL>    };<EOL>    <EOL>    if (background.repeat) {<EOL>        switch (background.repeat.toLowerCase()) {<EOL>             case \"<STR_LIT>\":<EOL>                res.repeatX = false;<EOL>                res.repeatY = false;<EOL>                break;<EOL>            case \"<STR_LIT>\":<EOL>                res.repeatY =  false;<EOL>                break;<EOL>             case \"<STR_LIT>\":<EOL>                res.repeatX = false;<EOL>                break;<EOL>        }<EOL>    }<EOL>    const imageSize = image.size;<EOL>    let imageWidth = imageSize.width;<EOL>    let imageHeight = imageSize.height;<EOL>    <EOL>    const size = background. size;<EOL>    if (size) {<EOL>        const values =  cssParse(size);<EOL>        if (values.length === <NUM_LIT>) {<EOL>            const vx = values[<NUM_LIT>];<EOL>            const vy = values[<NUM_LIT>];<EOL>            if (vx.unit === \"<STR_LIT>\" && vy.unit === \"<STR_LIT>\") {<EOL>                imageWidth = width * vx.value / <NUM_LIT>;<EOL>                imageHeight = height * vy.value / <NUM_LIT>;<EOL>                res.sizeX = imageWidth;<EOL>                res.sizeY = imageHeight;<EOL>            }<EOL>            else if (vx.type === \"<STR_LIT>\" && vy.type === \"<STR_LIT>\" &&<EOL>                ((vx.unit ===  \"<STR_LIT>\" && vy.unit === \"<STR_LIT>\") || (vx.unit === \"<STR_LIT>\" && vy.unit === \"<STR_LIT>\"))) {<EOL>                imageWidth = vx.value;<EOL>                imageHeight = vy.value;<EOL>                res.sizeX = imageWidth;<EOL>                res.sizeY = imageHeight;<EOL>            }<EOL>        }<EOL>        else if (values.length === <NUM_LIT> && values[<NUM_LIT>].type === \"<STR_LIT>\") {<EOL>            let scale = <NUM_LIT>;<EOL>            if (values[<NUM_LIT>].string === \"<STR_LIT>\") {<EOL>                scale = Math.max(width / imageWidth, height / imageHeight);<EOL>            }<EOL>            else  if (values[<NUM_LIT>].string === \"<STR_LIT>\") {<EOL>                scale = Math.min(width / imageWidth, height / imageHeight);<EOL>            }<EOL>            if (scale > <NUM_LIT>) {<EOL>                imageWidth *= scale;<EOL>                imageHeight *= scale;<EOL>                res. sizeX = imageWidth;<EOL>                res.sizeY =  imageHeight;<EOL>            }<EOL>        }<EOL>    }<EOL>    <EOL>    const position = background.position;<EOL>    if (position) {<EOL>        const v = parsePosition(position);<EOL>        if (v) {<EOL>            const spaceX = width - imageWidth;<EOL>            const spaceY = height - imageHeight;<EOL>            if (v.x.unit === \"<STR_LIT>\" && v.y.unit === \"<STR_LIT>\") {<EOL>                res. posX = spaceX * v.x.value / <NUM_LIT>;<EOL>                res.posY = spaceY * v.y.value / <NUM_LIT>;<EOL>            }<EOL>            else if (v.x.type === \"<STR_LIT>\" && v.y.type === \"<STR_LIT>\" &&<EOL>                ((v.x.unit === \"<STR_LIT>\" && v.y.unit === \"<STR_LIT>\") || (v.x.unit === \"<STR_LIT>\" && v.y.unit === \"<STR_LIT>\"))) {<EOL>","gt":"res.posX = v.x.value;"}
{"input":"<s> function getDrawParams(image, background, width, height) {<EOL>    if (!image) {<EOL>         return null;<EOL>    }<EOL>     const res = {<EOL>        repeatX: true,<EOL>        repeatY: true,<EOL>        posX: <NUM_LIT>,<EOL>        posY: <NUM_LIT>,<EOL>    };<EOL>    <EOL>    if (background.repeat) {<EOL>        switch (background.repeat.toLowerCase()) {<EOL>             case \"<STR_LIT>\":<EOL>                res.repeatX = false;<EOL>                res.repeatY = false;<EOL>                break;<EOL>            case \"<STR_LIT>\":<EOL>                res.repeatY =  false;<EOL>                break;<EOL>             case \"<STR_LIT>\":<EOL>                res.repeatX = false;<EOL>                break;<EOL>        }<EOL>    }<EOL>    const imageSize = image.size;<EOL>    let imageWidth = imageSize.width;<EOL>    let imageHeight = imageSize.height;<EOL>    <EOL>    const size = background. size;<EOL>    if (size) {<EOL>        const values =  cssParse(size);<EOL>        if (values.length === <NUM_LIT>) {<EOL>            const vx = values[<NUM_LIT>];<EOL>            const vy = values[<NUM_LIT>];<EOL>            if (vx.unit === \"<STR_LIT>\" && vy.unit === \"<STR_LIT>\") {<EOL>                imageWidth = width * vx.value / <NUM_LIT>;<EOL>                imageHeight = height * vy.value / <NUM_LIT>;<EOL>                res.sizeX = imageWidth;<EOL>                res.sizeY = imageHeight;<EOL>            }<EOL>            else if (vx.type === \"<STR_LIT>\" && vy.type === \"<STR_LIT>\" &&<EOL>                ((vx.unit ===  \"<STR_LIT>\" && vy.unit === \"<STR_LIT>\") || (vx.unit === \"<STR_LIT>\" && vy.unit === \"<STR_LIT>\"))) {<EOL>                imageWidth = vx.value;<EOL>                imageHeight = vy.value;<EOL>                res.sizeX = imageWidth;<EOL>                res.sizeY = imageHeight;<EOL>            }<EOL>        }<EOL>        else if (values.length === <NUM_LIT> && values[<NUM_LIT>].type === \"<STR_LIT>\") {<EOL>            let scale = <NUM_LIT>;<EOL>            if (values[<NUM_LIT>].string === \"<STR_LIT>\") {<EOL>                scale = Math.max(width / imageWidth, height / imageHeight);<EOL>            }<EOL>            else  if (values[<NUM_LIT>].string === \"<STR_LIT>\") {<EOL>                scale = Math.min(width / imageWidth, height / imageHeight);<EOL>            }<EOL>            if (scale > <NUM_LIT>) {<EOL>                imageWidth *= scale;<EOL>                imageHeight *= scale;<EOL>                res. sizeX = imageWidth;<EOL>                res.sizeY =  imageHeight;<EOL>            }<EOL>        }<EOL>    }<EOL>    <EOL>    const position = background.position;<EOL>    if (position) {<EOL>        const v = parsePosition(position);<EOL>        if (v) {<EOL>            const spaceX = width - imageWidth;<EOL>            const spaceY = height - imageHeight;<EOL>            if (v.x.unit === \"<STR_LIT>\" && v.y.unit === \"<STR_LIT>\") {<EOL>                res. posX = spaceX * v.x.value / <NUM_LIT>;<EOL>                res.posY = spaceY * v.y.value / <NUM_LIT>;<EOL>            }<EOL>            else if (v.x.type === \"<STR_LIT>\" && v.y.type === \"<STR_LIT>\" &&<EOL>                ((v.x.unit === \"<STR_LIT>\" && v.y.unit === \"<STR_LIT>\") || (v.x.unit === \"<STR_LIT>\" && v.y.unit === \"<STR_LIT>\"))) {<EOL>                 res.posX = v.x.value;<EOL>                res.posY =","gt":"v.y.value;"}
{"input":"<s> function getDrawParams(image, background, width, height) {<EOL>    if (!image) {<EOL>         return null;<EOL>    }<EOL>     const res = {<EOL>        repeatX: true,<EOL>        repeatY: true,<EOL>        posX: <NUM_LIT>,<EOL>        posY: <NUM_LIT>,<EOL>    };<EOL>    <EOL>    if (background.repeat) {<EOL>        switch (background.repeat.toLowerCase()) {<EOL>             case \"<STR_LIT>\":<EOL>                res.repeatX = false;<EOL>                res.repeatY = false;<EOL>                break;<EOL>            case \"<STR_LIT>\":<EOL>                res.repeatY =  false;<EOL>                break;<EOL>             case \"<STR_LIT>\":<EOL>                res.repeatX = false;<EOL>                break;<EOL>        }<EOL>    }<EOL>    const imageSize = image.size;<EOL>    let imageWidth = imageSize.width;<EOL>    let imageHeight = imageSize.height;<EOL>    <EOL>    const size = background. size;<EOL>    if (size) {<EOL>        const values =  cssParse(size);<EOL>        if (values.length === <NUM_LIT>) {<EOL>            const vx = values[<NUM_LIT>];<EOL>            const vy = values[<NUM_LIT>];<EOL>            if (vx.unit === \"<STR_LIT>\" && vy.unit === \"<STR_LIT>\") {<EOL>                imageWidth = width * vx.value / <NUM_LIT>;<EOL>                imageHeight = height * vy.value / <NUM_LIT>;<EOL>                res.sizeX = imageWidth;<EOL>                res.sizeY = imageHeight;<EOL>            }<EOL>            else if (vx.type === \"<STR_LIT>\" && vy.type === \"<STR_LIT>\" &&<EOL>                ((vx.unit ===  \"<STR_LIT>\" && vy.unit === \"<STR_LIT>\") || (vx.unit === \"<STR_LIT>\" && vy.unit === \"<STR_LIT>\"))) {<EOL>                imageWidth = vx.value;<EOL>                imageHeight = vy.value;<EOL>                res.sizeX = imageWidth;<EOL>                res.sizeY = imageHeight;<EOL>            }<EOL>        }<EOL>        else if (values.length === <NUM_LIT> && values[<NUM_LIT>].type === \"<STR_LIT>\") {<EOL>            let scale = <NUM_LIT>;<EOL>            if (values[<NUM_LIT>].string === \"<STR_LIT>\") {<EOL>                scale = Math.max(width / imageWidth, height / imageHeight);<EOL>            }<EOL>            else  if (values[<NUM_LIT>].string === \"<STR_LIT>\") {<EOL>                scale = Math.min(width / imageWidth, height / imageHeight);<EOL>            }<EOL>            if (scale > <NUM_LIT>) {<EOL>                imageWidth *= scale;<EOL>                imageHeight *= scale;<EOL>                res. sizeX = imageWidth;<EOL>                res.sizeY =  imageHeight;<EOL>            }<EOL>        }<EOL>    }<EOL>    <EOL>    const position = background.position;<EOL>    if (position) {<EOL>        const v = parsePosition(position);<EOL>        if (v) {<EOL>            const spaceX = width - imageWidth;<EOL>            const spaceY = height - imageHeight;<EOL>            if (v.x.unit === \"<STR_LIT>\" && v.y.unit === \"<STR_LIT>\") {<EOL>                res. posX = spaceX * v.x.value / <NUM_LIT>;<EOL>                res.posY = spaceY * v.y.value / <NUM_LIT>;<EOL>            }<EOL>            else if (v.x.type === \"<STR_LIT>\" && v.y.type === \"<STR_LIT>\" &&<EOL>                ((v.x.unit === \"<STR_LIT>\" && v.y.unit === \"<STR_LIT>\") || (v.x.unit === \"<STR_LIT>\" && v.y.unit === \"<STR_LIT>\"))) {<EOL>                 res.posX = v.x.value;<EOL>                res.posY =  v.y.value;<EOL>            }<EOL>            else if (v.x.type === \"<STR_LIT>\" && v.y.type === \"<STR_LIT>\") {<EOL>                if (v.x.string.toLowerCase() === \"<STR_LIT>\") {<EOL>                    res.posX = spaceX /","gt":"<NUM_LIT>;"}
{"input":"<s> function getDrawParams(image, background, width, height) {<EOL>    if (!image) {<EOL>         return null;<EOL>    }<EOL>     const res = {<EOL>        repeatX: true,<EOL>        repeatY: true,<EOL>        posX: <NUM_LIT>,<EOL>        posY: <NUM_LIT>,<EOL>    };<EOL>    <EOL>    if (background.repeat) {<EOL>        switch (background.repeat.toLowerCase()) {<EOL>             case \"<STR_LIT>\":<EOL>                res.repeatX = false;<EOL>                res.repeatY = false;<EOL>                break;<EOL>            case \"<STR_LIT>\":<EOL>                res.repeatY =  false;<EOL>                break;<EOL>             case \"<STR_LIT>\":<EOL>                res.repeatX = false;<EOL>                break;<EOL>        }<EOL>    }<EOL>    const imageSize = image.size;<EOL>    let imageWidth = imageSize.width;<EOL>    let imageHeight = imageSize.height;<EOL>    <EOL>    const size = background. size;<EOL>    if (size) {<EOL>        const values =  cssParse(size);<EOL>        if (values.length === <NUM_LIT>) {<EOL>            const vx = values[<NUM_LIT>];<EOL>            const vy = values[<NUM_LIT>];<EOL>            if (vx.unit === \"<STR_LIT>\" && vy.unit === \"<STR_LIT>\") {<EOL>                imageWidth = width * vx.value / <NUM_LIT>;<EOL>                imageHeight = height * vy.value / <NUM_LIT>;<EOL>                res.sizeX = imageWidth;<EOL>                res.sizeY = imageHeight;<EOL>            }<EOL>            else if (vx.type === \"<STR_LIT>\" && vy.type === \"<STR_LIT>\" &&<EOL>                ((vx.unit ===  \"<STR_LIT>\" && vy.unit === \"<STR_LIT>\") || (vx.unit === \"<STR_LIT>\" && vy.unit === \"<STR_LIT>\"))) {<EOL>                imageWidth = vx.value;<EOL>                imageHeight = vy.value;<EOL>                res.sizeX = imageWidth;<EOL>                res.sizeY = imageHeight;<EOL>            }<EOL>        }<EOL>        else if (values.length === <NUM_LIT> && values[<NUM_LIT>].type === \"<STR_LIT>\") {<EOL>            let scale = <NUM_LIT>;<EOL>            if (values[<NUM_LIT>].string === \"<STR_LIT>\") {<EOL>                scale = Math.max(width / imageWidth, height / imageHeight);<EOL>            }<EOL>            else  if (values[<NUM_LIT>].string === \"<STR_LIT>\") {<EOL>                scale = Math.min(width / imageWidth, height / imageHeight);<EOL>            }<EOL>            if (scale > <NUM_LIT>) {<EOL>                imageWidth *= scale;<EOL>                imageHeight *= scale;<EOL>                res. sizeX = imageWidth;<EOL>                res.sizeY =  imageHeight;<EOL>            }<EOL>        }<EOL>    }<EOL>    <EOL>    const position = background.position;<EOL>    if (position) {<EOL>        const v = parsePosition(position);<EOL>        if (v) {<EOL>            const spaceX = width - imageWidth;<EOL>            const spaceY = height - imageHeight;<EOL>            if (v.x.unit === \"<STR_LIT>\" && v.y.unit === \"<STR_LIT>\") {<EOL>                res. posX = spaceX * v.x.value / <NUM_LIT>;<EOL>                res.posY = spaceY * v.y.value / <NUM_LIT>;<EOL>            }<EOL>            else if (v.x.type === \"<STR_LIT>\" && v.y.type === \"<STR_LIT>\" &&<EOL>                ((v.x.unit === \"<STR_LIT>\" && v.y.unit === \"<STR_LIT>\") || (v.x.unit === \"<STR_LIT>\" && v.y.unit === \"<STR_LIT>\"))) {<EOL>                 res.posX = v.x.value;<EOL>                res.posY =  v.y.value;<EOL>            }<EOL>            else if (v.x.type === \"<STR_LIT>\" && v.y.type === \"<STR_LIT>\") {<EOL>                if (v.x.string.toLowerCase() === \"<STR_LIT>\") {<EOL>                    res.posX = spaceX /  <NUM_LIT>;<EOL>                }<EOL>                else if (","gt":"v.x.string.toLowerCase() === \"<STR_LIT>\") {"}
{"input":"<s> function getDrawParams(image, background, width, height) {<EOL>    if (!image) {<EOL>         return null;<EOL>    }<EOL>     const res = {<EOL>        repeatX: true,<EOL>        repeatY: true,<EOL>        posX: <NUM_LIT>,<EOL>        posY: <NUM_LIT>,<EOL>    };<EOL>    <EOL>    if (background.repeat) {<EOL>        switch (background.repeat.toLowerCase()) {<EOL>             case \"<STR_LIT>\":<EOL>                res.repeatX = false;<EOL>                res.repeatY = false;<EOL>                break;<EOL>            case \"<STR_LIT>\":<EOL>                res.repeatY =  false;<EOL>                break;<EOL>             case \"<STR_LIT>\":<EOL>                res.repeatX = false;<EOL>                break;<EOL>        }<EOL>    }<EOL>    const imageSize = image.size;<EOL>    let imageWidth = imageSize.width;<EOL>    let imageHeight = imageSize.height;<EOL>    <EOL>    const size = background. size;<EOL>    if (size) {<EOL>        const values =  cssParse(size);<EOL>        if (values.length === <NUM_LIT>) {<EOL>            const vx = values[<NUM_LIT>];<EOL>            const vy = values[<NUM_LIT>];<EOL>            if (vx.unit === \"<STR_LIT>\" && vy.unit === \"<STR_LIT>\") {<EOL>                imageWidth = width * vx.value / <NUM_LIT>;<EOL>                imageHeight = height * vy.value / <NUM_LIT>;<EOL>                res.sizeX = imageWidth;<EOL>                res.sizeY = imageHeight;<EOL>            }<EOL>            else if (vx.type === \"<STR_LIT>\" && vy.type === \"<STR_LIT>\" &&<EOL>                ((vx.unit ===  \"<STR_LIT>\" && vy.unit === \"<STR_LIT>\") || (vx.unit === \"<STR_LIT>\" && vy.unit === \"<STR_LIT>\"))) {<EOL>                imageWidth = vx.value;<EOL>                imageHeight = vy.value;<EOL>                res.sizeX = imageWidth;<EOL>                res.sizeY = imageHeight;<EOL>            }<EOL>        }<EOL>        else if (values.length === <NUM_LIT> && values[<NUM_LIT>].type === \"<STR_LIT>\") {<EOL>            let scale = <NUM_LIT>;<EOL>            if (values[<NUM_LIT>].string === \"<STR_LIT>\") {<EOL>                scale = Math.max(width / imageWidth, height / imageHeight);<EOL>            }<EOL>            else  if (values[<NUM_LIT>].string === \"<STR_LIT>\") {<EOL>                scale = Math.min(width / imageWidth, height / imageHeight);<EOL>            }<EOL>            if (scale > <NUM_LIT>) {<EOL>                imageWidth *= scale;<EOL>                imageHeight *= scale;<EOL>                res. sizeX = imageWidth;<EOL>                res.sizeY =  imageHeight;<EOL>            }<EOL>        }<EOL>    }<EOL>    <EOL>    const position = background.position;<EOL>    if (position) {<EOL>        const v = parsePosition(position);<EOL>        if (v) {<EOL>            const spaceX = width - imageWidth;<EOL>            const spaceY = height - imageHeight;<EOL>            if (v.x.unit === \"<STR_LIT>\" && v.y.unit === \"<STR_LIT>\") {<EOL>                res. posX = spaceX * v.x.value / <NUM_LIT>;<EOL>                res.posY = spaceY * v.y.value / <NUM_LIT>;<EOL>            }<EOL>            else if (v.x.type === \"<STR_LIT>\" && v.y.type === \"<STR_LIT>\" &&<EOL>                ((v.x.unit === \"<STR_LIT>\" && v.y.unit === \"<STR_LIT>\") || (v.x.unit === \"<STR_LIT>\" && v.y.unit === \"<STR_LIT>\"))) {<EOL>                 res.posX = v.x.value;<EOL>                res.posY =  v.y.value;<EOL>            }<EOL>            else if (v.x.type === \"<STR_LIT>\" && v.y.type === \"<STR_LIT>\") {<EOL>                if (v.x.string.toLowerCase() === \"<STR_LIT>\") {<EOL>                    res.posX = spaceX /  <NUM_LIT>;<EOL>                }<EOL>                else if ( v.x.string.toLowerCase() === \"<STR_LIT>\") {<EOL>                    res.posX =","gt":"spaceX;"}
{"input":"<s> function createSimpleSelectorFromAst(ast) {<EOL>    switch (ast.type) {<EOL>        case \"<STR_LIT>\": return new UniversalSelector();<EOL>        case \"<STR_LIT>\": return new IdSelector(","gt":"ast.identifier);"}
{"input":"<s> function getFontFamilyRespectingGenericFonts(fontFamily) {<EOL>    if (!fontFamily) {<EOL>        return fontFamily;<EOL>    }<EOL>    switch (","gt":"fontFamily.toLowerCase()) {"}
{"input":"<s> function getFontFamilyRespectingGenericFonts(fontFamily) {<EOL>    if (!fontFamily) {<EOL>        return fontFamily;<EOL>    }<EOL>    switch ( fontFamily.toLowerCase()) {<EOL>        case genericFontFamilies.serif:<EOL>            return DEFAULT_SERIF;<EOL>        case genericFontFamilies.monospace:<EOL>            return DEFAULT_MONOSPACE;<EOL>","gt":"default:"}
{"input":"<s> function registerCustomFonts() {<EOL>    const appDir = fs.knownFolders.currentApp().path;<EOL>    const fontsDir = fs.path.join(appDir,","gt":"\"<STR_LIT>\");"}
{"input":"<s> function getCapitalizedString(str) {<EOL>    let words = str.split(\"<STR_LIT>\");<EOL>    let newWords = [];<EOL>    for (","gt":"let i = <NUM_LIT>, length = words.length; i < length; i++) {"}
{"input":"<s> function getMinutes(hour) {<EOL>    return","gt":"hour * <NUM_LIT>;"}
{"input":"<s> export function GC() {<EOL>","gt":"gc();"}
{"input":"<s> export function copyRuntime(path) {<EOL>    copySync(join(","gt":"__dirname, \"<STR_LIT>\"), path);"}
{"input":"<s> export async function deployContract(contractName) {<EOL>    return new Promise((resolve, reject) => {<EOL>        const dirPath = join(__dirname, \"<STR_LIT>\");<EOL>        const fileName = `<STR_LIT>`;<EOL>        const abi = JSON.parse(readFileSync(join(dirPath, fileName + \"<STR_LIT>\"), \"<STR_LIT>\"));<EOL>        const bin = readFileSync(join(dirPath, fileName + \"<STR_LIT>\"), \"<STR_LIT>\");<EOL>","gt":"const code = \"<STR_LIT>\" + bin;"}
{"input":"<s> export async function deployContract(contractName) {<EOL>    return new Promise((resolve, reject) => {<EOL>        const dirPath = join(__dirname, \"<STR_LIT>\");<EOL>        const fileName = `<STR_LIT>`;<EOL>        const abi = JSON.parse(readFileSync(join(dirPath, fileName + \"<STR_LIT>\"), \"<STR_LIT>\"));<EOL>        const bin = readFileSync(join(dirPath, fileName + \"<STR_LIT>\"), \"<STR_LIT>\");<EOL>         const code = \"<STR_LIT>\" + bin;<EOL>        const contract = web3.eth.contract(abi);<EOL>        contract.new({ from: accounts[<NUM_LIT>], data: code, gas: GAS_LIMIT_STANDARD }, (err, contract) => {<EOL>            <EOL>            <EOL>            if (err) {<EOL>                reject(err);<EOL>            }<EOL>            else if (contract.","gt":"address) {"}
{"input":"<s> function extractLogLevel(options) {<EOL>    if (options.loglevel)<EOL>        return options.loglevel;<EOL>    if (options.","gt":"silent)"}
{"input":"<s> function dequote(input) {<EOL>    input = input.trim();<EOL>    const singleQuote = input.startsWith(\"<STR_LIT>\") && input.endsWith(\"<STR_LIT>\");<EOL>    const doubleQuote = input.","gt":"startsWith('<STR_LIT>') && input.endsWith('<STR_LIT>');"}
{"input":"<s> function getAriaState(compiled) {<EOL>    const stars = getStars(","gt":"compiled, '<STR_LIT>');"}
{"input":"<s> function getStar(compiled, num) {<EOL>    return getStars(","gt":"compiled)[num - <NUM_LIT>];"}
{"input":"<s> function getState(element) {<EOL>    const stars = getStars(element instanceof","gt":"DebugElement ? element.nativeElement : element);"}
{"input":"<s> export function isService(annotation) {<EOL>    return annotation instanceof","gt":"InjectableMetadata;"}
{"input":"<s> export function isPromise(obj) {<EOL>    return obj instanceof","gt":"_global.Promise;"}
{"input":"<s> export function reducer(state, action) {<EOL>    if (environment.production) {<EOL>        return","gt":"productionReducer(state, action);"}
{"input":"<s> export function mapAsync(list, mapFn) {<EOL>    return Promise.all(list.map(","gt":"mapFn));"}
{"input":"<s> <EOL>export async function minifyUmdBundles(config) {<EOL>    const uglifyArgs = ['<STR_LIT>', '<STR_LIT>', '<STR_LIT>'];<EOL>    await mapAsync(util.getAllPackages(config), async (pkg) => {<EOL>        const topLevelName = util.getTopLevelName(pkg);<EOL>        if (!util.shouldBundle(config, topLevelName)) {<EOL>","gt":"return;"}
{"input":"<s> <EOL>export async function minifyUmdBundles(config) {<EOL>    const uglifyArgs = ['<STR_LIT>', '<STR_LIT>', '<STR_LIT>'];<EOL>    await mapAsync(util.getAllPackages(config), async (pkg) => {<EOL>        const topLevelName = util.getTopLevelName(pkg);<EOL>        if (!util.shouldBundle(config, topLevelName)) {<EOL>             return;<EOL>        }<EOL>        const destinationName = util.getDestinationName(pkg);<EOL>        const file = `<STR_LIT>`;<EOL>","gt":"const out = `<STR_LIT>`;"}
{"input":"<s> <EOL>export async function minifyUmdBundles(config) {<EOL>    const uglifyArgs = ['<STR_LIT>', '<STR_LIT>', '<STR_LIT>'];<EOL>    await mapAsync(util.getAllPackages(config), async (pkg) => {<EOL>        const topLevelName = util.getTopLevelName(pkg);<EOL>        if (!util.shouldBundle(config, topLevelName)) {<EOL>             return;<EOL>        }<EOL>        const destinationName = util.getDestinationName(pkg);<EOL>        const file = `<STR_LIT>`;<EOL>         const out = `<STR_LIT>`;<EOL>        return util.exec('<STR_LIT>', [<EOL>            file,<EOL>            ...uglifyArgs,<EOL>","gt":"out}`<STR_LIT>,"}
{"input":"<s> export function getTopLevelPackages(config) {<EOL>    return config.packages.map((packageDescription) =>","gt":"packageDescription.name);"}
{"input":"<s> export function reducer(state = initialState, action) {<EOL>    switch (action.type) {<EOL>        case BookActionTypes.SearchComplete:<EOL>        case CollectionActionTypes.LoadSuccess: {<EOL>            <EOL>","gt":"return adapter.addMany(action.payload, {"}
{"input":"<s> export function reducer(state = initialState, action) {<EOL>    switch (action.type) {<EOL>        case BookActionTypes.SearchComplete:<EOL>        case CollectionActionTypes.LoadSuccess: {<EOL>            <EOL>             return adapter.addMany(action.payload, {<EOL>                ...state,<EOL>                selectedBookId: state.selectedBookId,<EOL>            });<EOL>        }<EOL>        case BookActionTypes.Load: {<EOL>            <EOL>            return adapter.addOne(action.payload, {<EOL>                ...state,<EOL>                selectedBookId:","gt":"state.selectedBookId,"}
{"input":"<s> export function reducer(state = initialState, action) {<EOL>    switch (action.type) {<EOL>        case BookActionTypes.SearchComplete:<EOL>        case CollectionActionTypes.LoadSuccess: {<EOL>            <EOL>             return adapter.addMany(action.payload, {<EOL>                ...state,<EOL>                selectedBookId: state.selectedBookId,<EOL>            });<EOL>        }<EOL>        case BookActionTypes.Load: {<EOL>            <EOL>            return adapter.addOne(action.payload, {<EOL>                ...state,<EOL>                selectedBookId:  state.selectedBookId,<EOL>            });<EOL>        }<EOL>        case BookActionTypes.Select: {<EOL>            return {<EOL>                ...state,<EOL>","gt":"selectedBookId: action.payload,"}
{"input":"<s> export function routerReducer(state, action) {<EOL>    switch (action.type) {<EOL>        case ROUTER_NAVIGATION:<EOL>        case ROUTER_ERROR:<EOL>        case","gt":"ROUTER_CANCEL:"}
{"input":"<s> export function routerReducer(state, action) {<EOL>    switch (action.type) {<EOL>        case ROUTER_NAVIGATION:<EOL>        case ROUTER_ERROR:<EOL>        case  ROUTER_CANCEL:<EOL>            return {<EOL>                state: action.payload.routerState,<EOL>                navigationId: action.payload.event.id,<EOL>            };<EOL>","gt":"default:"}
{"input":"<s> export function provideRouterConnector() {<EOL>    return {<EOL>","gt":"provide: APP_BOOTSTRAP_LISTENER,"}
{"input":"<s> export function _createOptions(_options) {<EOL>    const DEFAULT_OPTIONS = { monitor: noMonitor };<EOL>    let options = typeof _options === '<STR_LIT>' ? _options() : _options;<EOL>    options = Object.assign({},","gt":"DEFAULT_OPTIONS, options);"}
{"input":"<s> export function _createReduxDevtoolsExtension() {<EOL>    const legacyExtensionKey = '<STR_LIT>';<EOL>    const extensionKey = '<STR_LIT>';<EOL>    if (typeof window === '<STR_LIT>' && typeof window[legacyExtensionKey] !== '<STR_LIT>') {<EOL>        return window[","gt":"legacyExtensionKey];"}
{"input":"<s> export function _createReduxDevtoolsExtension() {<EOL>    const legacyExtensionKey = '<STR_LIT>';<EOL>    const extensionKey = '<STR_LIT>';<EOL>    if (typeof window === '<STR_LIT>' && typeof window[legacyExtensionKey] !== '<STR_LIT>') {<EOL>        return window[ legacyExtensionKey];<EOL>    }<EOL>    else if (typeof window === '<STR_LIT>' && typeof window[extensionKey] !== '<STR_LIT>') {<EOL>        return window[extensionKey];<EOL>    }<EOL>","gt":"else {"}
{"input":"<s> <EOL>function recomputeStates(computedStates, minInvalidatedStateIndex, reducer, committedState, actionsById, stagedActionIds, skippedActionIds) {<EOL>    <EOL>    <EOL>    if (minInvalidatedStateIndex >= computedStates.length &&<EOL>","gt":"computedStates.length === stagedActionIds.length) {"}
{"input":"<s> <EOL>function recomputeStates(computedStates, minInvalidatedStateIndex, reducer, committedState, actionsById, stagedActionIds, skippedActionIds) {<EOL>    <EOL>    <EOL>    if (minInvalidatedStateIndex >= computedStates.length &&<EOL>         computedStates.length === stagedActionIds.length) {<EOL>        return computedStates;<EOL>    }<EOL>    const","gt":"nextComputedStates = computedStates.slice(<NUM_LIT>, minInvalidatedStateIndex);"}
{"input":"<s> <EOL>function recomputeStates(computedStates, minInvalidatedStateIndex, reducer, committedState, actionsById, stagedActionIds, skippedActionIds) {<EOL>    <EOL>    <EOL>    if (minInvalidatedStateIndex >= computedStates.length &&<EOL>         computedStates.length === stagedActionIds.length) {<EOL>        return computedStates;<EOL>    }<EOL>    const  nextComputedStates = computedStates.slice(<NUM_LIT>, minInvalidatedStateIndex);<EOL>    for (let i = minInvalidatedStateIndex; i < stagedActionIds.length; i++) {<EOL>        const actionId = stagedActionIds[i];<EOL>        const action = actionsById[actionId].action;<EOL>        const","gt":"previousEntry = nextComputedStates[i - <NUM_LIT>];"}
{"input":"<s> <EOL>function recomputeStates(computedStates, minInvalidatedStateIndex, reducer, committedState, actionsById, stagedActionIds, skippedActionIds) {<EOL>    <EOL>    <EOL>    if (minInvalidatedStateIndex >= computedStates.length &&<EOL>         computedStates.length === stagedActionIds.length) {<EOL>        return computedStates;<EOL>    }<EOL>    const  nextComputedStates = computedStates.slice(<NUM_LIT>, minInvalidatedStateIndex);<EOL>    for (let i = minInvalidatedStateIndex; i < stagedActionIds.length; i++) {<EOL>        const actionId = stagedActionIds[i];<EOL>        const action = actionsById[actionId].action;<EOL>        const  previousEntry = nextComputedStates[i - <NUM_LIT>];<EOL>        const previousState = previousEntry ? previousEntry.state : committedState;<EOL>        const previousError = previousEntry ? previousEntry.error : undefined;<EOL>        const shouldSkip = skippedActionIds.indexOf(actionId) > -<NUM_LIT>;<EOL>        const entry = shouldSkip ?<EOL>","gt":"previousEntry :"}
{"input":"<s> export function bootstrapFactory(appRef, transferState, request, cache) {<EOL>    return () => appRef.isStable<EOL>        .pipe(filter((stable) => stable), first())<EOL>        .subscribe(() => {<EOL>","gt":"transferState.set(REQ_KEY, {"}
{"input":"<s> function add(...customEvents) {<EOL>    customEvents.forEach((","gt":"event) => events.add(event));"}
{"input":"<s> <EOL>export function extract(s) {<EOL>    return","gt":"s;"}
{"input":"<s> function querySelector(s) {<EOL>    return document.","gt":"querySelector(s);"}
{"input":"<s> export function controlLengthValidator(length) {<EOL>    return (control) => {<EOL>        if (control.value && control.value.length !==","gt":"length) {"}
{"input":"<s> export function controlLengthValidator(length) {<EOL>    return (control) => {<EOL>        if (control.value && control.value.length !==  length) {<EOL>            return { validLength: { valid: false } };<EOL>        }<EOL>        else {<EOL>","gt":"return null;"}
{"input":"<s> <EOL>export function assertNoErrors(res) {<EOL>    for (let i = <NUM_LIT>; i < res.results.length; i += <NUM_LIT>) {<EOL>        const { error } = res.results[i];<EOL>","gt":"if (error) {"}
{"input":"<s> function copyNodeModule(path, name) {<EOL>    execSync(","gt":"}/node_modules/${name}`<STR_LIT>;"}
{"input":"<s> function updateMain(angularJsImport, options) {<EOL>    return (host) => {<EOL>        const { mainPath, moduleClassName, moduleSpec, bootstrapComponentClassName, bootstrapComponentFileName } = readBootstrapInfo(host, options.app);<EOL>","gt":"host.overwrite(mainPath,"}
{"input":"<s> export function addEntryComponents(source, modulePath, symbolName) {<EOL>    return _addSymbolToNgModuleMetadata(source,","gt":"modulePath, '<STR_LIT>', symbolName);"}
{"input":"<s> export function readCliConfigFile() {<EOL>","gt":"return JSON.parse(fs.readFileSync('<STR_LIT>', '<STR_LIT>'));"}
{"input":"<s> export function wrapIntoFormat(fn) {<EOL>    return (host, context) => {<EOL>        context.addTask(new","gt":"FormatFiles());"}
{"input":"<s> function getPatternsFromApps(affectedFiles) {<EOL>    const roots = getProjectRoots(getTouchedProjects(affectedFiles));<EOL>    if (roots.length === <NUM_LIT>) {<EOL>        return [];<EOL>    }<EOL>    else if (roots.length === <NUM_LIT>) {<EOL>        return [`<STR_LIT>`];<EOL>    }<EOL>","gt":"else {"}
{"input":"<s> function prettierPath() {<EOL>    const basePath = path.dirname(resolve.sync('<STR_LIT>', { basedir:","gt":"__dirname }));"}
{"input":"<s> export function localDataFactory() {<EOL>","gt":"return () => {"}
{"input":"<s> function _randWord(array) {<EOL>    let index =","gt":"Math.floor(Math.random() * array.length);"}
{"input":"<s> function continuousPulseStepTwo() {<EOL>    return {<EOL>        opacity:","gt":"'<STR_LIT>',"}
{"input":"<s> function _darken(hsl, factor) {<EOL>    return {<EOL>","gt":"h: hsl.h,"}
{"input":"<s> <EOL>function getStartDateOfWeek(date, firstDayOfWeek) {<EOL>    let daysOffset = firstDayOfWeek - date.getDay();<EOL>    if (","gt":"daysOffset > <NUM_LIT>) {"}
{"input":"<s> <EOL>export function getNextElement(rootElement, currentElement, checkNode, suppressParentTraversal, suppressChildTraversal, includeElementsInFocusZones, allowFocusRoot) {<EOL>    if (!currentElement ||<EOL>        (currentElement === rootElement && suppressChildTraversal && !allowFocusRoot)) {<EOL>        return null;<EOL>    }<EOL>    let isCurrentElementVisible = isElementVisible(currentElement);<EOL>    <EOL>    if (checkNode && isCurrentElementVisible && isElementTabbable(currentElement)) {<EOL>        return currentElement;<EOL>    }<EOL>    <EOL>    if (!suppressChildTraversal && isCurrentElementVisible &&<EOL>        (includeElementsInFocusZones || !(isElementFocusZone(currentElement) ||","gt":"isElementFocusSubZone(currentElement)))) {"}
{"input":"<s> <EOL>export function getNextElement(rootElement, currentElement, checkNode, suppressParentTraversal, suppressChildTraversal, includeElementsInFocusZones, allowFocusRoot) {<EOL>    if (!currentElement ||<EOL>        (currentElement === rootElement && suppressChildTraversal && !allowFocusRoot)) {<EOL>        return null;<EOL>    }<EOL>    let isCurrentElementVisible = isElementVisible(currentElement);<EOL>    <EOL>    if (checkNode && isCurrentElementVisible && isElementTabbable(currentElement)) {<EOL>        return currentElement;<EOL>    }<EOL>    <EOL>    if (!suppressChildTraversal && isCurrentElementVisible &&<EOL>        (includeElementsInFocusZones || !(isElementFocusZone(currentElement) ||  isElementFocusSubZone(currentElement)))) {<EOL>        const childMatch = getNextElement(rootElement, currentElement.firstElementChild, true, true, false, includeElementsInFocusZones, allowFocusRoot);<EOL>        if (childMatch) {<EOL>            return childMatch;<EOL>        }<EOL>    }<EOL>    if (currentElement === rootElement) {<EOL>        return null;<EOL>    }<EOL>    <EOL>    const siblingMatch = getNextElement(rootElement, currentElement.nextElementSibling, true, true, false, includeElementsInFocusZones,","gt":"allowFocusRoot);"}
{"input":"<s> <EOL>export function setMemoizeWeakMap(weakMap) {<EOL>    _weakMap =","gt":"weakMap;"}
{"input":"<s> function truncateStringReverse(str, maxLength = <NUM_LIT>) {<EOL>    const reversedString = toArray(","gt":"str).reverse().join('<STR_LIT>');"}
{"input":"<s> function updateState(self, state) {<EOL>    each(Omni.viewModelStatefulProperties, (x) => {<EOL>        if (","gt":"has(state, x)) {"}
{"input":"<s> export function sum(arr, selector) {<EOL>    return arr.","gt":"reduce((prev, curr) => prev + selector(curr), <NUM_LIT>);"}
{"input":"<s> export async function activate(thisExtension, context, reporter, logger, channel) {<EOL>    _debugUtil = new CoreClrDebugUtil(context.extensionPath, logger);<EOL>    _logger = logger;<EOL>    if (!CoreClrDebugUtil.existsSync(_debugUtil.","gt":"debugAdapterDir())) {"}
{"input":"<s> export async function activate(thisExtension, context, reporter, logger, channel) {<EOL>    _debugUtil = new CoreClrDebugUtil(context.extensionPath, logger);<EOL>    _logger = logger;<EOL>    if (!CoreClrDebugUtil.existsSync(_debugUtil. debugAdapterDir())) {<EOL>        let platformInformation;<EOL>        try {<EOL>            platformInformation = await PlatformInformation.","gt":"GetCurrent();"}
{"input":"<s> export async function activate(thisExtension, context, reporter, logger, channel) {<EOL>    _debugUtil = new CoreClrDebugUtil(context.extensionPath, logger);<EOL>    _logger = logger;<EOL>    if (!CoreClrDebugUtil.existsSync(_debugUtil. debugAdapterDir())) {<EOL>        let platformInformation;<EOL>        try {<EOL>            platformInformation = await PlatformInformation. GetCurrent();<EOL>        }<EOL>        catch (err) {<EOL>            <EOL>            logger.appendLine(","gt":"\"<STR_LIT>\");"}
{"input":"<s> export async function activate(thisExtension, context, reporter, logger, channel) {<EOL>    _debugUtil = new CoreClrDebugUtil(context.extensionPath, logger);<EOL>    _logger = logger;<EOL>    if (!CoreClrDebugUtil.existsSync(_debugUtil. debugAdapterDir())) {<EOL>        let platformInformation;<EOL>        try {<EOL>            platformInformation = await PlatformInformation. GetCurrent();<EOL>        }<EOL>        catch (err) {<EOL>            <EOL>            logger.appendLine( \"<STR_LIT>\");<EOL>            showInstallErrorMessage(channel);<EOL>        }<EOL>        if (","gt":"platformInformation) {"}
{"input":"<s> export async function activate(thisExtension, context, reporter, logger, channel) {<EOL>    _debugUtil = new CoreClrDebugUtil(context.extensionPath, logger);<EOL>    _logger = logger;<EOL>    if (!CoreClrDebugUtil.existsSync(_debugUtil. debugAdapterDir())) {<EOL>        let platformInformation;<EOL>        try {<EOL>            platformInformation = await PlatformInformation. GetCurrent();<EOL>        }<EOL>        catch (err) {<EOL>            <EOL>            logger.appendLine( \"<STR_LIT>\");<EOL>            showInstallErrorMessage(channel);<EOL>        }<EOL>        if ( platformInformation) {<EOL>            if (platformInformation.architecture !== \"<STR_LIT>\") {<EOL>                if (platformInformation.isWindows() && platformInformation.architecture === \"<STR_LIT>\") {<EOL>                    logger.appendLine(`<STR_LIT>`);<EOL>                }<EOL>                else {<EOL>                    logger.appendLine(`<STR_LIT>`);<EOL>                }<EOL>            }<EOL>            else {<EOL>","gt":"logger.appendLine(\"<STR_LIT>\");"}
{"input":"<s> async function completeDebuggerInstall(logger, channel) {<EOL>    return _debugUtil.checkDotNetCli()<EOL>        .then((dotnetInfo) => {<EOL>        if (os.platform() === \"<STR_LIT>\" && !CoreClrDebugUtil.isMacOSSupported()) {<EOL>            logger.appendLine(\"<STR_LIT>\");<EOL>            channel.show();<EOL>            return","gt":"false;"}
{"input":"<s> async function completeDebuggerInstall(logger, channel) {<EOL>    return _debugUtil.checkDotNetCli()<EOL>        .then((dotnetInfo) => {<EOL>        if (os.platform() === \"<STR_LIT>\" && !CoreClrDebugUtil.isMacOSSupported()) {<EOL>            logger.appendLine(\"<STR_LIT>\");<EOL>            channel.show();<EOL>            return  false;<EOL>        }<EOL>        <EOL>        CoreClrDebugUtil.writeEmptyFile(_debugUtil.installCompleteFilePath());<EOL>        vscode.window.setStatusBarMessage('<STR_LIT>', <NUM_LIT>);<EOL>","gt":"return true;"}
{"input":"<s> async function completeDebuggerInstall(logger, channel) {<EOL>    return _debugUtil.checkDotNetCli()<EOL>        .then((dotnetInfo) => {<EOL>        if (os.platform() === \"<STR_LIT>\" && !CoreClrDebugUtil.isMacOSSupported()) {<EOL>            logger.appendLine(\"<STR_LIT>\");<EOL>            channel.show();<EOL>            return  false;<EOL>        }<EOL>        <EOL>        CoreClrDebugUtil.writeEmptyFile(_debugUtil.installCompleteFilePath());<EOL>        vscode.window.setStatusBarMessage('<STR_LIT>', <NUM_LIT>);<EOL>         return true;<EOL>    }, (err) => {<EOL>        <EOL>        <EOL>        showDotnetToolsWarning(","gt":"err.ErrorMessage || _debugUtil.defaultDotNetCliErrorMessage());"}
{"input":"<s> <EOL><EOL><EOL>function GetSysNativePathIfNeeded() {<EOL>    return PlatformInformation.GetCurrent().then((platformInfo) => {<EOL>        let env = process.env;<EOL>        if (platformInfo.isWindows() && platformInfo.","gt":"architecture === \"<STR_LIT>\") {"}
{"input":"<s> export function findExecutableProjectJsonProjects(projects, configurationName) {<EOL>    let result = [];<EOL>    projects.forEach((project) => {<EOL>        project.Configurations.forEach((configuration) => {<EOL>            if (configuration.Name === configurationName && configuration.EmitEntryPoint ===","gt":"true) {"}
{"input":"<s> export function serializeAppConfig(config) {<EOL>    return {<EOL>        appId: config.appId.serialize(),<EOL>        subdomain: config.subdomain,<EOL>","gt":"httpUseOneSignalCom: config.httpUseOneSignalCom,"}
{"input":"<s> export function serializeAppConfig(config) {<EOL>    return {<EOL>        appId: config.appId.serialize(),<EOL>        subdomain: config.subdomain,<EOL>         httpUseOneSignalCom: config.httpUseOneSignalCom,<EOL>        cookieSyncEnabled: config.cookieSyncEnabled,<EOL>        safariWebId: config.safariWebId,<EOL>        vapidPublicKey: config.vapidPublicKey,<EOL>        emailAuthRequired:","gt":"config.emailAuthRequired,"}
{"input":"<s> export function logMethodCall(methodName, ...args) {<EOL>    return log.debug(","gt":"join('<STR_LIT>')})`<STR_LIT>;"}
{"input":"<s> <EOL>export function trimUndefined(object) {<EOL>    for (var property in object) {<EOL>        if (object.hasOwnProperty(property)) {<EOL>            if (object[","gt":"property] === undefined) {"}
{"input":"<s> export function setConfigValue(k, v) {<EOL>    return {<EOL>        type: \"<STR_LIT>\",<EOL>","gt":"payload: {"}
{"input":"<s> <EOL>export function nodeRequire(moduleName) {<EOL>    return window[\"<STR_LIT>\"](","gt":"moduleName);"}
{"input":"<s> function updateMenu(browserWindow, loadInit) {<EOL>    const menu = buildMenu(browserWindow, loadInit);<EOL>    if (process.platform === \"<STR_LIT>\") {<EOL>        <EOL>","gt":"Menu.setApplicationMenu(menu);"}
{"input":"<s> <EOL><EOL>export function initialize() {<EOL>    tracer =","gt":"new Tracer();"}
{"input":"<s> function parseSortSpecifier(sortSpecifier) {<EOL>    if (isObject(sortSpecifier)) {<EOL>        let s = sortSpecifier;<EOL>        s.kind = s.kind || '<STR_LIT>';<EOL>        s.","gt":"order = s.order || '<STR_LIT>';"}
{"input":"<s> function parseSortSpecifier(sortSpecifier) {<EOL>    if (isObject(sortSpecifier)) {<EOL>        let s = sortSpecifier;<EOL>        s.kind = s.kind || '<STR_LIT>';<EOL>        s. order = s.order || '<STR_LIT>';<EOL>        return s;<EOL>    }<EOL>    else if (typeof sortSpecifier === '<STR_LIT>') {<EOL>        return","gt":"parseSortSpecifierString(sortSpecifier);"}
{"input":"<s> function parseSortSpecifierString(sortSpecifier) {<EOL>    let attribute;<EOL>    let order;<EOL>    if (sortSpecifier[<NUM_LIT>] === '<STR_LIT>') {<EOL>        attribute = sortSpecifier.slice(<NUM_LIT>);<EOL>        order =","gt":"'<STR_LIT>';"}
{"input":"<s> function parseSortSpecifierString(sortSpecifier) {<EOL>    let attribute;<EOL>    let order;<EOL>    if (sortSpecifier[<NUM_LIT>] === '<STR_LIT>') {<EOL>        attribute = sortSpecifier.slice(<NUM_LIT>);<EOL>        order =  '<STR_LIT>';<EOL>    }<EOL>    else {<EOL>        attribute = sortSpecifier;<EOL>","gt":"order = '<STR_LIT>';"}
{"input":"<s> function parseSortSpecifierString(sortSpecifier) {<EOL>    let attribute;<EOL>    let order;<EOL>    if (sortSpecifier[<NUM_LIT>] === '<STR_LIT>') {<EOL>        attribute = sortSpecifier.slice(<NUM_LIT>);<EOL>        order =  '<STR_LIT>';<EOL>    }<EOL>    else {<EOL>        attribute = sortSpecifier;<EOL>         order = '<STR_LIT>';<EOL>    }<EOL>    return {<EOL>","gt":"kind: '<STR_LIT>',"}
{"input":"<s> <EOL>function get(key, map) {<EOL>    return tryGetHash(undefined, map._config.hash(","gt":"key), key, map);"}
{"input":"<s> <EOL>function remove(key, map) {<EOL>    return removeHash(map._config.","gt":"hash(key), key, map);"}
{"input":"<s> function values(map) {<EOL>    return visit(map,","gt":"buildValues);"}
{"input":"<s> <EOL>export function capitalize(str) {<EOL>    return str.charAt(<NUM_LIT>).","gt":"toUpperCase() + str.slice(<NUM_LIT>);"}
{"input":"<s> export function extractThumbUrl(media) {<EOL>    return extractThumbnail(getSnippet(","gt":"media));"}
{"input":"<s> export function updateTriggeredFlag(scroll, scrollState, triggered, isScrollingDown) {<EOL>    if (isScrollingDown) {<EOL>        scrollState.","gt":"triggered.down = scroll;"}
{"input":"<s> function setPremove(state, orig, dest, meta) {<EOL>","gt":"unsetPredrop(state);"}
{"input":"<s> export function toggleOrientation(state) {<EOL>    state.orientation = opposite(state.orientation);<EOL>    state.animation.","gt":"current ="}
{"input":"<s> function renderCircle(brush, pos, current, bounds) {<EOL>    const o = pos2px(pos, bounds), widths = circleWidth(bounds), radius = (bounds.width +","gt":"bounds.height) / <NUM_LIT>;"}
{"input":"<s> function renderCircle(brush, pos, current, bounds) {<EOL>    const o = pos2px(pos, bounds), widths = circleWidth(bounds), radius = (bounds.width +  bounds.height) / <NUM_LIT>;<EOL>    return setAttributes(createElement('<STR_LIT>'), {<EOL>        stroke: brush.color,<EOL>        '<STR_LIT>': widths[current ? <NUM_LIT> : <NUM_LIT>],<EOL>        fill: '<STR_LIT>',<EOL>        opacity: opacity(brush, current),<EOL>","gt":"cx: o[<NUM_LIT>],"}
{"input":"<s> function renderShape(state, { shape, current, hash }, brushes, arrowDests, bounds) {<EOL>    let el;<EOL>    if (shape.piece)<EOL>        el = renderPiece(state.drawable.pieces.baseUrl, orient(key2pos(shape.orig), state.orientation), shape.piece, bounds);<EOL>    else {<EOL>        const orig =","gt":"orient(key2pos(shape.orig), state.orientation);"}
{"input":"<s> function renderShape(state, { shape, current, hash }, brushes, arrowDests, bounds) {<EOL>    let el;<EOL>    if (shape.piece)<EOL>        el = renderPiece(state.drawable.pieces.baseUrl, orient(key2pos(shape.orig), state.orientation), shape.piece, bounds);<EOL>    else {<EOL>        const orig =  orient(key2pos(shape.orig), state.orientation);<EOL>        if (shape.orig && shape.dest) {<EOL>            let brush = brushes[shape.brush];<EOL>            if (shape.modifiers)<EOL>","gt":"brush = makeCustomBrush(brush, shape.modifiers);"}
{"input":"<s> function renderShape(state, { shape, current, hash }, brushes, arrowDests, bounds) {<EOL>    let el;<EOL>    if (shape.piece)<EOL>        el = renderPiece(state.drawable.pieces.baseUrl, orient(key2pos(shape.orig), state.orientation), shape.piece, bounds);<EOL>    else {<EOL>        const orig =  orient(key2pos(shape.orig), state.orientation);<EOL>        if (shape.orig && shape.dest) {<EOL>            let brush = brushes[shape.brush];<EOL>            if (shape.modifiers)<EOL>                 brush = makeCustomBrush(brush, shape.modifiers);<EOL>            el = renderArrow(brush, orig, orient(key2pos(shape.dest), state.orientation), current, arrowDests[shape.dest] > <NUM_LIT>, bounds);<EOL>        }<EOL>        else<EOL>            el = renderCircle(brushes[shape.","gt":"brush], orig, current, bounds);"}
{"input":"<s> function renderCoords(elems, className) {<EOL>    const el = createEl('<STR_LIT>', className);<EOL>    let f;<EOL>    for (","gt":"let i in elems) {"}
{"input":"<s> <EOL>export function ipv6Address(ip) {<EOL>    return term({<EOL>        generate: ip ||","gt":"\"<STR_LIT>\","}
{"input":"<s> <EOL>export function iso8601Date(date) {<EOL>    return term({<EOL>","gt":"generate: date || \"<STR_LIT>\","}
{"input":"<s> export function trainingLog(message) {<EOL>","gt":"messageElement.innerText = `<STR_LIT>`;"}
{"input":"<s> function convertZScale(z) {<EOL>    return (","gt":"<NUM_LIT> - z);"}
{"input":"<s> function runHTML() {<EOL>","gt":"iframeElement.contentWindow.postMessage(JSON.stringify({ '<STR_LIT>': htmlEditor.getValue() }), '<STR_LIT>');"}
{"input":"<s> export function assertDayHidden(day, expectHidden = true) {<EOL>","gt":"assert.equal(isDayHidden(day), expectHidden);"}
{"input":"<s> export function expectCellLoading(cell, cellType, loading = true) {<EOL>    if (loading) {<EOL>        expect(cell.classList.contains(CoreClasses.LOADING)).to.be.true;<EOL>        expect(cell.querySelector(`<STR_LIT>`)).to.not.be.null;<EOL>        if (cellType !== CellType.BODY_CELL) {<EOL>            const headerNameText = cellType === CellType.COLUMN_HEADER<EOL>                ? cell.","gt":"querySelector(`<STR_LIT>`)"}
{"input":"<s> <EOL>export function multiTime() {<EOL>    <EOL>    <EOL>    const candidateFormats = [<EOL>        {<EOL>","gt":"specifier: \"<STR_LIT>\","}
{"input":"<s> <EOL>export function multiTime() {<EOL>    <EOL>    <EOL>    const candidateFormats = [<EOL>        {<EOL>             specifier: \"<STR_LIT>\",<EOL>            predicate: (d) => d.getMilliseconds() !== <NUM_LIT>,<EOL>        },<EOL>        {<EOL>            specifier: \"<STR_LIT>\",<EOL>            predicate: (d) => d.getSeconds() !== <NUM_LIT>,<EOL>        },<EOL>        {<EOL>            specifier: \"<STR_LIT>\",<EOL>            predicate: (d) => d.getMinutes() !== <NUM_LIT>,<EOL>        },<EOL>        {<EOL>","gt":"specifier: \"<STR_LIT>\","}
{"input":"<s> <EOL>export function multiTime() {<EOL>    <EOL>    <EOL>    const candidateFormats = [<EOL>        {<EOL>             specifier: \"<STR_LIT>\",<EOL>            predicate: (d) => d.getMilliseconds() !== <NUM_LIT>,<EOL>        },<EOL>        {<EOL>            specifier: \"<STR_LIT>\",<EOL>            predicate: (d) => d.getSeconds() !== <NUM_LIT>,<EOL>        },<EOL>        {<EOL>            specifier: \"<STR_LIT>\",<EOL>            predicate: (d) => d.getMinutes() !== <NUM_LIT>,<EOL>        },<EOL>        {<EOL>             specifier: \"<STR_LIT>\",<EOL>            predicate: (d) => d.getHours() !== <NUM_LIT>,<EOL>        },<EOL>        {<EOL>","gt":"specifier: \"<STR_LIT>\","}
{"input":"<s> <EOL>export function multiTime() {<EOL>    <EOL>    <EOL>    const candidateFormats = [<EOL>        {<EOL>             specifier: \"<STR_LIT>\",<EOL>            predicate: (d) => d.getMilliseconds() !== <NUM_LIT>,<EOL>        },<EOL>        {<EOL>            specifier: \"<STR_LIT>\",<EOL>            predicate: (d) => d.getSeconds() !== <NUM_LIT>,<EOL>        },<EOL>        {<EOL>            specifier: \"<STR_LIT>\",<EOL>            predicate: (d) => d.getMinutes() !== <NUM_LIT>,<EOL>        },<EOL>        {<EOL>             specifier: \"<STR_LIT>\",<EOL>            predicate: (d) => d.getHours() !== <NUM_LIT>,<EOL>        },<EOL>        {<EOL>             specifier: \"<STR_LIT>\",<EOL>            predicate: (d) => d.getDay() !== <NUM_LIT> && d.getDate() !== <NUM_LIT>,<EOL>        },<EOL>        {<EOL>            specifier: \"<STR_LIT>\",<EOL>            predicate: (d) => d.getDate() !== <NUM_LIT>,<EOL>        },<EOL>        {<EOL>            specifier: \"<STR_LIT>\",<EOL>            predicate: (d) =>","gt":"d.getMonth() !== <NUM_LIT>,"}
{"input":"<s> <EOL>export function time(specifier, useUTC = DEFAULT_USE_UTC) {<EOL>    if (useUTC) {<EOL>        return d3.utcFormat(","gt":"specifier);"}
{"input":"<s> export function square() {<EOL>    return (","gt":"symbolSize) => {"}
{"input":"<s> export function resolveAttributes(projector, attrKeys, datum, index) {<EOL>    const attrs = {};<EOL>    for (const attrKey of attrKeys) {<EOL>        if (projector.","gt":"hasOwnProperty(attrKey)) {"}
{"input":"<s> function squareOverlapsBounds(width, height, x, y, size) {<EOL>","gt":"return (x + size >= <NUM_LIT> && x - size <= width &&"}
{"input":"<s> export function signRef(a) {<EOL>    return","gt":"new ReferenceSignature(a);"}
{"input":"<s> <EOL>export function integerTickGenerator() {<EOL>    return function (s) {<EOL>        const defaultTicks =","gt":"s.defaultTicks();"}
{"input":"<s> function attrsObject$1(transition, map) {<EOL>    for (const","gt":"name in map)"}
{"input":"<s> export function entityBounds(element) {<EOL>    if (element instanceof SVGElement) {<EOL>        return elementBBox(d3.select(element));<EOL>    }<EOL>    else if (","gt":"element instanceof HTMLElement) {"}
{"input":"<s> export function entityBounds(element) {<EOL>    if (element instanceof SVGElement) {<EOL>        return elementBBox(d3.select(element));<EOL>    }<EOL>    else if ( element instanceof HTMLElement) {<EOL>        const rect = element.getBoundingClientRect();<EOL>        return { x: rect.left, y: rect.top, width: rect.width, height: rect.height };<EOL>    }<EOL>","gt":"else {"}
{"input":"<s> <EOL>function _parseRange(input) {<EOL>    if (typeof (input) === \"<STR_LIT>\") {<EOL>        const value = input;<EOL>        return {","gt":"min: value, max: value };"}
{"input":"<s> <EOL>export function inRange(x, a, b) {<EOL>    return (nativeMath.min(a, b) <= x && x <= nativeMath.","gt":"max(a, b));"}
{"input":"<s> function hasKeyProp(attributes) {<EOL>    return","gt":"attributes.properties"}
{"input":"<s> function buildDocumentationDataFile(documentation, metadataJson) {<EOL>","gt":"const dataJson = JSON.stringify(metadataJson, undefined, <NUM_LIT>);"}
{"input":"<s> function isRule(ruleName) {<EOL>    let result = cache.get(ruleName);<EOL>    if (result ===","gt":"undefined) {"}
{"input":"<s> function everyRule() {<EOL>    return fs.readdirSync(srcRulesDir)<EOL>        .filter((","gt":"file) => /Rule.ts$/.test(file))"}
{"input":"<s> <EOL>export function HttpLoaderFactory(http) {<EOL>    return new","gt":"TranslateHttpLoader(http, '<STR_LIT>', '<STR_LIT>');"}
{"input":"<s> <EOL>export function testIterator(factory) {<EOL>    describe('<STR_LIT>', () => {<EOL>        it('<STR_LIT>', () => {<EOL>            let [it] = factory();<EOL>            expect(it.iter()).to.equal(it);<EOL>        });<EOL>    });<EOL>    describe('<STR_LIT>', () => {<EOL>        it(","gt":"'<STR_LIT>', () => {"}
{"input":"<s> <EOL>export function testIterator(factory) {<EOL>    describe('<STR_LIT>', () => {<EOL>        it('<STR_LIT>', () => {<EOL>            let [it] = factory();<EOL>            expect(it.iter()).to.equal(it);<EOL>        });<EOL>    });<EOL>    describe('<STR_LIT>', () => {<EOL>        it( '<STR_LIT>', () => {<EOL>            let [it, results] = factory();<EOL>            let it2 = it.clone();<EOL>            expect(it).to.not.equal(it2);<EOL>            expect(toArray(it)).to.deep.equal(results);<EOL>            expect(toArray(it2)).to.","gt":"deep.equal(results);"}
{"input":"<s> <EOL>export function testIterator(factory) {<EOL>    describe('<STR_LIT>', () => {<EOL>        it('<STR_LIT>', () => {<EOL>            let [it] = factory();<EOL>            expect(it.iter()).to.equal(it);<EOL>        });<EOL>    });<EOL>    describe('<STR_LIT>', () => {<EOL>        it( '<STR_LIT>', () => {<EOL>            let [it, results] = factory();<EOL>            let it2 = it.clone();<EOL>            expect(it).to.not.equal(it2);<EOL>            expect(toArray(it)).to.deep.equal(results);<EOL>            expect(toArray(it2)).to. deep.equal(results);<EOL>        });<EOL>    });<EOL>    describe('<STR_LIT>', () => {<EOL>        it('<STR_LIT>', () => {<EOL>            let value;<EOL>            let [","gt":"it, results] = factory();"}
{"input":"<s> function doneCb(status) {<EOL>    process.exit(","gt":"status);"}
{"input":"<s> <EOL>export default function getGlobalRequire() {<EOL>    const reqVar = eval('<STR_LIT>');<EOL>    return reqVar ? reqVar :","gt":"function (moduleName) {"}
{"input":"<s> <EOL>export function arraycopyNoCheck(src, srcPos, dest, destPos, length) {<EOL>    var j = destPos;<EOL>    var end = srcPos +","gt":"length;"}
{"input":"<s> <EOL>async function createServer(app, options) {<EOL>    const opt = { spdy: { protocols: [options.protocol] } };<EOL>    if (isHttps(options.protocol)) {<EOL>        const keys = await getTLSCertificate(options.keyPath, options.certPath);<EOL>        opt.","gt":"key = keys.key;"}
{"input":"<s> <EOL>async function createServer(app, options) {<EOL>    const opt = { spdy: { protocols: [options.protocol] } };<EOL>    if (isHttps(options.protocol)) {<EOL>        const keys = await getTLSCertificate(options.keyPath, options.certPath);<EOL>        opt. key = keys.key;<EOL>        opt.cert = keys.cert;<EOL>    }<EOL>    else {<EOL>        opt.spdy.plain = true;<EOL>","gt":"opt.spdy.ssl = false;"}
{"input":"<s> export async function run(_env, args, output) {<EOL>    await wrapResult(output, _run(","gt":"args, output));"}
{"input":"<s> <EOL>export async function parseArgs(context, args) {<EOL>    const parser = nomnom();<EOL>    parser.script('<STR_LIT>');<EOL>    parser.options(ARG_CONFIG);<EOL>    const plugins = await context.","gt":"plugins();"}
{"input":"<s> <EOL>export async function parseArgs(context, args) {<EOL>    const parser = nomnom();<EOL>    parser.script('<STR_LIT>');<EOL>    parser.options(ARG_CONFIG);<EOL>    const plugins = await context. plugins();<EOL>    plugins.forEach(_configurePluginOptions.bind(null, parser));<EOL>    const options = _expandOptionPaths(normalize(parser.parse(args)));<EOL>    if (options._ && options._.length > <NUM_LIT>) {<EOL>","gt":"options.suites = options._;"}
{"input":"<s> export function init(gulp, dependencies) {<EOL>    if (!dependencies) {<EOL>        dependencies = [];<EOL>    }<EOL>    <EOL>","gt":"gulp.task('<STR_LIT>', ['<STR_LIT>']);"}
{"input":"<s> <EOL>export async function setupOverrides(context) {<EOL>    if (context.","gt":"options.registerHooks) {"}
{"input":"<s> function runIntegrationSuiteForDir(dirname, options, skip) {<EOL>    runsIntegrationSuite(dirname, options, skip, function (testResults) {<EOL>        const golden = JSON.parse(fs.readFileSync(path.join(integrationDir, dirname, '<STR_LIT>'), '<STR_LIT>'));<EOL>        let variantsGolden;<EOL>        if (isVariantsGolden(golden)) {<EOL>            variantsGolden =","gt":"golden;"}
{"input":"<s> function runIntegrationSuiteForDir(dirname, options, skip) {<EOL>    runsIntegrationSuite(dirname, options, skip, function (testResults) {<EOL>        const golden = JSON.parse(fs.readFileSync(path.join(integrationDir, dirname, '<STR_LIT>'), '<STR_LIT>'));<EOL>        let variantsGolden;<EOL>        if (isVariantsGolden(golden)) {<EOL>            variantsGolden =  golden;<EOL>        }<EOL>        else {<EOL>","gt":"variantsGolden = { variants: { '<STR_LIT>': golden } };"}
{"input":"<s> <EOL>export function setUsedModule(module, version, bundled) {<EOL>    prettierInformation =","gt":"'<STR_LIT>' : '<STR_LIT>'}`<STR_LIT>;"}
{"input":"<s> function toggleStatusBarItem(editor) {<EOL>    if (editor !== undefined) {<EOL>        <EOL>        <EOL>        <EOL>        <EOL>        if (['<STR_LIT>', '<STR_LIT>'].some((part) => editor.document.uri.scheme === part)) {<EOL>            return;<EOL>        }<EOL>        const score = languages.match(allEnabledLanguages(),","gt":"editor.document);"}
{"input":"<s> function toggleStatusBarItem(editor) {<EOL>    if (editor !== undefined) {<EOL>        <EOL>        <EOL>        <EOL>        <EOL>        if (['<STR_LIT>', '<STR_LIT>'].some((part) => editor.document.uri.scheme === part)) {<EOL>            return;<EOL>        }<EOL>        const score = languages.match(allEnabledLanguages(),  editor.document);<EOL>        if (score > <NUM_LIT>) {<EOL>            statusBarItem.show();<EOL>        }<EOL>","gt":"else {"}
{"input":"<s> <EOL>function selectorsCreator(wf) {<EOL>    const allLanguages = allEnabledLanguages();<EOL>    const allRangeLanguages = allJSLanguages();<EOL>    const { disableLanguages } = getConfig(wf.uri);<EOL>    const relativePattern = new RelativePattern(","gt":"wf, '<STR_LIT>');"}
{"input":"<s> function distributeGraph(model) {<EOL>    let nodes = mapElements(model);<EOL>    let edges = mapEdges(model);<EOL>    let graph = new dagre.graphlib.Graph();<EOL>    graph.setGraph({});<EOL>    graph.setDefaultEdgeLabel(function () {<EOL>","gt":"return {};"}
{"input":"<s> <EOL>export function execTask(binPath, args, options = {}) {<EOL>    return (done) => {<EOL>        const childProcess = child_process.spawn(binPath, args);<EOL>        if (!options.silent) {<EOL>            childProcess.stdout.on('<STR_LIT>', (data) => {<EOL>","gt":"process.stdout.write(data);"}
{"input":"<s> <EOL>export function execTask(binPath, args, options = {}) {<EOL>    return (done) => {<EOL>        const childProcess = child_process.spawn(binPath, args);<EOL>        if (!options.silent) {<EOL>            childProcess.stdout.on('<STR_LIT>', (data) => {<EOL>                 process.stdout.write(data);<EOL>            });<EOL>            childProcess.stderr.on('<STR_LIT>', (data) => {<EOL>                process.stderr.","gt":"write(data);"}
{"input":"<s> <EOL>export function execTask(binPath, args, options = {}) {<EOL>    return (done) => {<EOL>        const childProcess = child_process.spawn(binPath, args);<EOL>        if (!options.silent) {<EOL>            childProcess.stdout.on('<STR_LIT>', (data) => {<EOL>                 process.stdout.write(data);<EOL>            });<EOL>            childProcess.stderr.on('<STR_LIT>', (data) => {<EOL>                process.stderr. write(data);<EOL>            });<EOL>        }<EOL>        childProcess.on('<STR_LIT>', (code) => {<EOL>            if (code != <NUM_LIT>) {<EOL>                if (options.errMessage ===","gt":"undefined) {"}
{"input":"<s> <EOL>export function serverTask(livereload = true) {<EOL>    return () => {<EOL>        gulpConnect.server({<EOL>","gt":"root: '<STR_LIT>',"}
{"input":"<s> export function userReducer(state = initialState, action) {<EOL>    switch (action.type) {<EOL>        case UserActionTypes.EditUser: {<EOL>            return {<EOL>                ...","gt":"state,"}
{"input":"<s> export function userReducer(state = initialState, action) {<EOL>    switch (action.type) {<EOL>        case UserActionTypes.EditUser: {<EOL>            return {<EOL>                ... state,<EOL>                user: action.payload<EOL>            };<EOL>        }<EOL>        default: {<EOL>            return","gt":"state;"}
{"input":"<s> export function Deal(value) {<EOL>    let title = value;<EOL>    for (","gt":"let rp of regs) {"}
{"input":"<s> async function getFileList(para) {<EOL>    let _files = [];<EOL>    if (!vscode.workspace.workspaceFolders) {<EOL>","gt":"return [];"}
{"input":"<s> async function getFileList(para) {<EOL>    let _files = [];<EOL>    if (!vscode.workspace.workspaceFolders) {<EOL>         return [];<EOL>    }<EOL>    if (!para) {<EOL>        for (let folder of vscode.workspace.workspaceFolders) {<EOL>            _files.push(...await getFileList(folder.","gt":"uri));"}
{"input":"<s> async function getFileList(para) {<EOL>    let _files = [];<EOL>    if (!vscode.workspace.workspaceFolders) {<EOL>         return [];<EOL>    }<EOL>    if (!para) {<EOL>        for (let folder of vscode.workspace.workspaceFolders) {<EOL>            _files.push(...await getFileList(folder. uri));<EOL>        }<EOL>    }<EOL>    else if (para instanceof Array) {<EOL>        for (let u of","gt":"para.filter((p) => p instanceof vscode.Uri)) {"}
{"input":"<s> async function getFileList(para) {<EOL>    let _files = [];<EOL>    if (!vscode.workspace.workspaceFolders) {<EOL>         return [];<EOL>    }<EOL>    if (!para) {<EOL>        for (let folder of vscode.workspace.workspaceFolders) {<EOL>            _files.push(...await getFileList(folder. uri));<EOL>        }<EOL>    }<EOL>    else if (para instanceof Array) {<EOL>        for (let u of  para.filter((p) => p instanceof vscode.Uri)) {<EOL>            _files.push(...await getFileList(u));<EOL>        }<EOL>    }<EOL>    else if (para instanceof vscode.Uri) {<EOL>        if (fs.statSync(para.fsPath).isDirectory()) {<EOL>            let exts = config.fileExtensions(para);<EOL>            let folder = vscode.workspace.getWorkspaceFolder(para);<EOL>            let","gt":"relPath = path.relative(folder.uri.fsPath, para.fsPath);"}
{"input":"<s> function getIndex(v, tag) {<EOL>    if (valueTag(v) !== tag) {<EOL>","gt":"throw \"<STR_LIT>\";"}
{"input":"<s> function elmNameStyle(original, upper) {<EOL>    const words = splitIntoWords(","gt":"original);"}
{"input":"<s> export function camelCase(str) {<EOL>","gt":"return decapitalize(pascalCase(str));"}
{"input":"<s> function triviallyStructurallyCompatible(x, y) {<EOL>    if (x.typeRef.getIndex() === y.typeRef.getIndex())<EOL>","gt":"return true;"}
{"input":"<s> function callAndReportFailure(message, f) {<EOL>    try {<EOL>        return","gt":"f();"}
{"input":"<s> export function resolvePathToJestBin(root, pathToJest) {<EOL>    let jest = pathToJest;<EOL>    if (!path.isAbsolute(jest)) {<EOL>        jest = path.join(root,","gt":"jest);"}
{"input":"<s> export function resolvePathToJestBin(root, pathToJest) {<EOL>    let jest = pathToJest;<EOL>    if (!path.isAbsolute(jest)) {<EOL>        jest = path.join(root,  jest);<EOL>    }<EOL>    const basename =","gt":"path.basename(jest);"}
{"input":"<s> export function resolvePathToJestBin(root, pathToJest) {<EOL>    let jest = pathToJest;<EOL>    if (!path.isAbsolute(jest)) {<EOL>        jest = path.join(root,  jest);<EOL>    }<EOL>    const basename =  path.basename(jest);<EOL>    switch (basename) {<EOL>","gt":"case \"<STR_LIT>\": {"}
{"input":"<s> export function resolvePathToJestBin(root, pathToJest) {<EOL>    let jest = pathToJest;<EOL>    if (!path.isAbsolute(jest)) {<EOL>        jest = path.join(root,  jest);<EOL>    }<EOL>    const basename =  path.basename(jest);<EOL>    switch (basename) {<EOL>         case \"<STR_LIT>\": {<EOL>            return jest;<EOL>        }<EOL>        case \"<STR_LIT>\": {<EOL>            <EOL>            const line = fs.readFileSync(jest, \"<STR_LIT>\").split(\"<STR_LIT>\")[<NUM_LIT>];<EOL>            const match = /^\\s*\"[^\"]+\"\\s+\"%~dp0\\\\([^\"]+)\"/.exec(line);<EOL>            return path.join(path.dirname(jest), match[<NUM_LIT>]);<EOL>        }<EOL>        case \"<STR_LIT>\": {<EOL>            <EOL>            const lines = fs.readFileSync(jest, \"<STR_LIT>\").split(\"<STR_LIT>\");<EOL>            switch (lines[","gt":"<NUM_LIT>]) {"}
{"input":"<s> export function resolvePathToJestBin(root, pathToJest) {<EOL>    let jest = pathToJest;<EOL>    if (!path.isAbsolute(jest)) {<EOL>        jest = path.join(root,  jest);<EOL>    }<EOL>    const basename =  path.basename(jest);<EOL>    switch (basename) {<EOL>         case \"<STR_LIT>\": {<EOL>            return jest;<EOL>        }<EOL>        case \"<STR_LIT>\": {<EOL>            <EOL>            const line = fs.readFileSync(jest, \"<STR_LIT>\").split(\"<STR_LIT>\")[<NUM_LIT>];<EOL>            const match = /^\\s*\"[^\"]+\"\\s+\"%~dp0\\\\([^\"]+)\"/.exec(line);<EOL>            return path.join(path.dirname(jest), match[<NUM_LIT>]);<EOL>        }<EOL>        case \"<STR_LIT>\": {<EOL>            <EOL>            const lines = fs.readFileSync(jest, \"<STR_LIT>\").split(\"<STR_LIT>\");<EOL>            switch (lines[ <NUM_LIT>]) {<EOL>                case \"<STR_LIT>\": {<EOL>                    return jest;<EOL>                }<EOL>                case \"<STR_LIT>\": {<EOL>                    const line = lines[<NUM_LIT>];<EOL>                    const match = /^\\s*\"[^\"]+\"\\s+\"$basedir\\/([^\"]+)\"/.exec(line);<EOL>                    if (match) {<EOL>                        return path.join(path.","gt":"dirname(jest), match[<NUM_LIT>]);"}
{"input":"<s> export function getMajesticConfig(rootPath) {<EOL>    const packageJsonObj =","gt":"__non_webpack_require__(pathToPackageJSON(rootPath));"}
{"input":"<s> function concatTokens(left, right) {<EOL>    return left.","gt":"concat(right);"}
{"input":"<s> export function ss3(char) {<EOL>","gt":"return `<STR_LIT>`;"}
{"input":"<s> export function a1TransclusionDirective() {<EOL>    return {<EOL>        restrict: '<STR_LIT>',<EOL>","gt":"transclude: true,"}
{"input":"<s> export function allowanonymous(params) {<EOL>    params = params || {};<EOL>    return function (target, propertyKey) {<EOL>        MetaUtils.","gt":"addMetaData(target, {"}
{"input":"<s> export function inject(injectType) {<EOL>    function getInjectType(target, propertyKey, parameterIndex, decoratorType) {<EOL>        if (injectType) {<EOL>            return","gt":"injectType;"}
{"input":"<s> export function inject(injectType) {<EOL>    function getInjectType(target, propertyKey, parameterIndex, decoratorType) {<EOL>        if (injectType) {<EOL>            return  injectType;<EOL>        }<EOL>        let type;<EOL>        if (decoratorType === DecoratorType.PARAM) {<EOL>            var paramTypes =","gt":"Utils.getDesignParamType(target, propertyKey, parameterIndex);"}
{"input":"<s> export function inject(injectType) {<EOL>    function getInjectType(target, propertyKey, parameterIndex, decoratorType) {<EOL>        if (injectType) {<EOL>            return  injectType;<EOL>        }<EOL>        let type;<EOL>        if (decoratorType === DecoratorType.PARAM) {<EOL>            var paramTypes =  Utils.getDesignParamType(target, propertyKey, parameterIndex);<EOL>            type = paramTypes && paramTypes.length && parameterIndex < paramTypes.length<EOL>                ? paramTypes[","gt":"parameterIndex]"}
{"input":"<s> export function inject(injectType) {<EOL>    function getInjectType(target, propertyKey, parameterIndex, decoratorType) {<EOL>        if (injectType) {<EOL>            return  injectType;<EOL>        }<EOL>        let type;<EOL>        if (decoratorType === DecoratorType.PARAM) {<EOL>            var paramTypes =  Utils.getDesignParamType(target, propertyKey, parameterIndex);<EOL>            type = paramTypes && paramTypes.length && parameterIndex < paramTypes.length<EOL>                ? paramTypes[ parameterIndex]<EOL>                : null;<EOL>        }<EOL>        else if (decoratorType === DecoratorType.PROPERTY) {<EOL>            type = Utils.getDesignType(target, propertyKey);<EOL>        }<EOL>","gt":"else {"}
{"input":"<s> export function inject(injectType) {<EOL>    function getInjectType(target, propertyKey, parameterIndex, decoratorType) {<EOL>        if (injectType) {<EOL>            return  injectType;<EOL>        }<EOL>        let type;<EOL>        if (decoratorType === DecoratorType.PARAM) {<EOL>            var paramTypes =  Utils.getDesignParamType(target, propertyKey, parameterIndex);<EOL>            type = paramTypes && paramTypes.length && parameterIndex < paramTypes.length<EOL>                ? paramTypes[ parameterIndex]<EOL>                : null;<EOL>        }<EOL>        else if (decoratorType === DecoratorType.PROPERTY) {<EOL>            type = Utils.getDesignType(target, propertyKey);<EOL>        }<EOL>         else {<EOL>            winstonLog.logError(`<STR_LIT>`);<EOL>            throw '<STR_LIT>';<EOL>        }<EOL>        if (!type) {<EOL>            winstonLog.logError(`<STR_LIT>`);<EOL>            console.log(target);<EOL>            throw","gt":"'<STR_LIT>';"}
{"input":"<s> export function inject(injectType) {<EOL>    function getInjectType(target, propertyKey, parameterIndex, decoratorType) {<EOL>        if (injectType) {<EOL>            return  injectType;<EOL>        }<EOL>        let type;<EOL>        if (decoratorType === DecoratorType.PARAM) {<EOL>            var paramTypes =  Utils.getDesignParamType(target, propertyKey, parameterIndex);<EOL>            type = paramTypes && paramTypes.length && parameterIndex < paramTypes.length<EOL>                ? paramTypes[ parameterIndex]<EOL>                : null;<EOL>        }<EOL>        else if (decoratorType === DecoratorType.PROPERTY) {<EOL>            type = Utils.getDesignType(target, propertyKey);<EOL>        }<EOL>         else {<EOL>            winstonLog.logError(`<STR_LIT>`);<EOL>            throw '<STR_LIT>';<EOL>        }<EOL>        if (!type) {<EOL>            winstonLog.logError(`<STR_LIT>`);<EOL>            console.log(target);<EOL>            throw  '<STR_LIT>';<EOL>        }<EOL>        return type;<EOL>    }<EOL>    return function (target, propertyKey, parameterIndex) {<EOL>        <EOL>        if (arguments.length === <NUM_LIT>) {<EOL>            MetaUtils.addMetaData(target, {<EOL>                decorator: Decorators.INJECT,<EOL>","gt":"decoratorType: DecoratorType.PARAM,"}
{"input":"<s> export function inject(injectType) {<EOL>    function getInjectType(target, propertyKey, parameterIndex, decoratorType) {<EOL>        if (injectType) {<EOL>            return  injectType;<EOL>        }<EOL>        let type;<EOL>        if (decoratorType === DecoratorType.PARAM) {<EOL>            var paramTypes =  Utils.getDesignParamType(target, propertyKey, parameterIndex);<EOL>            type = paramTypes && paramTypes.length && parameterIndex < paramTypes.length<EOL>                ? paramTypes[ parameterIndex]<EOL>                : null;<EOL>        }<EOL>        else if (decoratorType === DecoratorType.PROPERTY) {<EOL>            type = Utils.getDesignType(target, propertyKey);<EOL>        }<EOL>         else {<EOL>            winstonLog.logError(`<STR_LIT>`);<EOL>            throw '<STR_LIT>';<EOL>        }<EOL>        if (!type) {<EOL>            winstonLog.logError(`<STR_LIT>`);<EOL>            console.log(target);<EOL>            throw  '<STR_LIT>';<EOL>        }<EOL>        return type;<EOL>    }<EOL>    return function (target, propertyKey, parameterIndex) {<EOL>        <EOL>        if (arguments.length === <NUM_LIT>) {<EOL>            MetaUtils.addMetaData(target, {<EOL>                decorator: Decorators.INJECT,<EOL>                 decoratorType: DecoratorType.PARAM,<EOL>                params: { type: getInjectType(target, propertyKey, parameterIndex, DecoratorType.PARAM) },<EOL>                propertyKey: propertyKey,<EOL>                paramIndex: parameterIndex<EOL>            });<EOL>            return;<EOL>        }<EOL>        <EOL>        else {<EOL>            injectType = getInjectType(target,","gt":"propertyKey, parameterIndex, DecoratorType.PROPERTY);"}
{"input":"<s> export function inject(injectType) {<EOL>    function getInjectType(target, propertyKey, parameterIndex, decoratorType) {<EOL>        if (injectType) {<EOL>            return  injectType;<EOL>        }<EOL>        let type;<EOL>        if (decoratorType === DecoratorType.PARAM) {<EOL>            var paramTypes =  Utils.getDesignParamType(target, propertyKey, parameterIndex);<EOL>            type = paramTypes && paramTypes.length && parameterIndex < paramTypes.length<EOL>                ? paramTypes[ parameterIndex]<EOL>                : null;<EOL>        }<EOL>        else if (decoratorType === DecoratorType.PROPERTY) {<EOL>            type = Utils.getDesignType(target, propertyKey);<EOL>        }<EOL>         else {<EOL>            winstonLog.logError(`<STR_LIT>`);<EOL>            throw '<STR_LIT>';<EOL>        }<EOL>        if (!type) {<EOL>            winstonLog.logError(`<STR_LIT>`);<EOL>            console.log(target);<EOL>            throw  '<STR_LIT>';<EOL>        }<EOL>        return type;<EOL>    }<EOL>    return function (target, propertyKey, parameterIndex) {<EOL>        <EOL>        if (arguments.length === <NUM_LIT>) {<EOL>            MetaUtils.addMetaData(target, {<EOL>                decorator: Decorators.INJECT,<EOL>                 decoratorType: DecoratorType.PARAM,<EOL>                params: { type: getInjectType(target, propertyKey, parameterIndex, DecoratorType.PARAM) },<EOL>                propertyKey: propertyKey,<EOL>                paramIndex: parameterIndex<EOL>            });<EOL>            return;<EOL>        }<EOL>        <EOL>        else {<EOL>            injectType = getInjectType(target,  propertyKey, parameterIndex, DecoratorType.PROPERTY);<EOL>            let injectedProp = null;<EOL>            <EOL>            var getter = function () {<EOL>","gt":"if (!injectedProp) {"}
{"input":"<s> export function inject(injectType) {<EOL>    function getInjectType(target, propertyKey, parameterIndex, decoratorType) {<EOL>        if (injectType) {<EOL>            return  injectType;<EOL>        }<EOL>        let type;<EOL>        if (decoratorType === DecoratorType.PARAM) {<EOL>            var paramTypes =  Utils.getDesignParamType(target, propertyKey, parameterIndex);<EOL>            type = paramTypes && paramTypes.length && parameterIndex < paramTypes.length<EOL>                ? paramTypes[ parameterIndex]<EOL>                : null;<EOL>        }<EOL>        else if (decoratorType === DecoratorType.PROPERTY) {<EOL>            type = Utils.getDesignType(target, propertyKey);<EOL>        }<EOL>         else {<EOL>            winstonLog.logError(`<STR_LIT>`);<EOL>            throw '<STR_LIT>';<EOL>        }<EOL>        if (!type) {<EOL>            winstonLog.logError(`<STR_LIT>`);<EOL>            console.log(target);<EOL>            throw  '<STR_LIT>';<EOL>        }<EOL>        return type;<EOL>    }<EOL>    return function (target, propertyKey, parameterIndex) {<EOL>        <EOL>        if (arguments.length === <NUM_LIT>) {<EOL>            MetaUtils.addMetaData(target, {<EOL>                decorator: Decorators.INJECT,<EOL>                 decoratorType: DecoratorType.PARAM,<EOL>                params: { type: getInjectType(target, propertyKey, parameterIndex, DecoratorType.PARAM) },<EOL>                propertyKey: propertyKey,<EOL>                paramIndex: parameterIndex<EOL>            });<EOL>            return;<EOL>        }<EOL>        <EOL>        else {<EOL>            injectType = getInjectType(target,  propertyKey, parameterIndex, DecoratorType.PROPERTY);<EOL>            let injectedProp = null;<EOL>            <EOL>            var getter = function () {<EOL>                 if (!injectedProp) {<EOL>                    injectedProp = Container.resolve(injectType);<EOL>                    <EOL>                    <EOL>                    <EOL>                }<EOL>                return injectedProp;<EOL>            };<EOL>            var setter = function (value) {<EOL>                injectedProp = value;<EOL>            };<EOL>            <EOL>","gt":"if (!(delete target[propertyKey])) {"}
{"input":"<s> export function inject(injectType) {<EOL>    function getInjectType(target, propertyKey, parameterIndex, decoratorType) {<EOL>        if (injectType) {<EOL>            return  injectType;<EOL>        }<EOL>        let type;<EOL>        if (decoratorType === DecoratorType.PARAM) {<EOL>            var paramTypes =  Utils.getDesignParamType(target, propertyKey, parameterIndex);<EOL>            type = paramTypes && paramTypes.length && parameterIndex < paramTypes.length<EOL>                ? paramTypes[ parameterIndex]<EOL>                : null;<EOL>        }<EOL>        else if (decoratorType === DecoratorType.PROPERTY) {<EOL>            type = Utils.getDesignType(target, propertyKey);<EOL>        }<EOL>         else {<EOL>            winstonLog.logError(`<STR_LIT>`);<EOL>            throw '<STR_LIT>';<EOL>        }<EOL>        if (!type) {<EOL>            winstonLog.logError(`<STR_LIT>`);<EOL>            console.log(target);<EOL>            throw  '<STR_LIT>';<EOL>        }<EOL>        return type;<EOL>    }<EOL>    return function (target, propertyKey, parameterIndex) {<EOL>        <EOL>        if (arguments.length === <NUM_LIT>) {<EOL>            MetaUtils.addMetaData(target, {<EOL>                decorator: Decorators.INJECT,<EOL>                 decoratorType: DecoratorType.PARAM,<EOL>                params: { type: getInjectType(target, propertyKey, parameterIndex, DecoratorType.PARAM) },<EOL>                propertyKey: propertyKey,<EOL>                paramIndex: parameterIndex<EOL>            });<EOL>            return;<EOL>        }<EOL>        <EOL>        else {<EOL>            injectType = getInjectType(target,  propertyKey, parameterIndex, DecoratorType.PROPERTY);<EOL>            let injectedProp = null;<EOL>            <EOL>            var getter = function () {<EOL>                 if (!injectedProp) {<EOL>                    injectedProp = Container.resolve(injectType);<EOL>                    <EOL>                    <EOL>                    <EOL>                }<EOL>                return injectedProp;<EOL>            };<EOL>            var setter = function (value) {<EOL>                injectedProp = value;<EOL>            };<EOL>            <EOL>             if (!(delete target[propertyKey])) {<EOL>                winstonLog.logError(`<STR_LIT>`);<EOL>                throw \"<STR_LIT>\";<EOL>            }<EOL>            <EOL>            Object.defineProperty(target, propertyKey, {<EOL>","gt":"get: getter,"}
{"input":"<s> export function inject(injectType) {<EOL>    function getInjectType(target, propertyKey, parameterIndex, decoratorType) {<EOL>        if (injectType) {<EOL>            return  injectType;<EOL>        }<EOL>        let type;<EOL>        if (decoratorType === DecoratorType.PARAM) {<EOL>            var paramTypes =  Utils.getDesignParamType(target, propertyKey, parameterIndex);<EOL>            type = paramTypes && paramTypes.length && parameterIndex < paramTypes.length<EOL>                ? paramTypes[ parameterIndex]<EOL>                : null;<EOL>        }<EOL>        else if (decoratorType === DecoratorType.PROPERTY) {<EOL>            type = Utils.getDesignType(target, propertyKey);<EOL>        }<EOL>         else {<EOL>            winstonLog.logError(`<STR_LIT>`);<EOL>            throw '<STR_LIT>';<EOL>        }<EOL>        if (!type) {<EOL>            winstonLog.logError(`<STR_LIT>`);<EOL>            console.log(target);<EOL>            throw  '<STR_LIT>';<EOL>        }<EOL>        return type;<EOL>    }<EOL>    return function (target, propertyKey, parameterIndex) {<EOL>        <EOL>        if (arguments.length === <NUM_LIT>) {<EOL>            MetaUtils.addMetaData(target, {<EOL>                decorator: Decorators.INJECT,<EOL>                 decoratorType: DecoratorType.PARAM,<EOL>                params: { type: getInjectType(target, propertyKey, parameterIndex, DecoratorType.PARAM) },<EOL>                propertyKey: propertyKey,<EOL>                paramIndex: parameterIndex<EOL>            });<EOL>            return;<EOL>        }<EOL>        <EOL>        else {<EOL>            injectType = getInjectType(target,  propertyKey, parameterIndex, DecoratorType.PROPERTY);<EOL>            let injectedProp = null;<EOL>            <EOL>            var getter = function () {<EOL>                 if (!injectedProp) {<EOL>                    injectedProp = Container.resolve(injectType);<EOL>                    <EOL>                    <EOL>                    <EOL>                }<EOL>                return injectedProp;<EOL>            };<EOL>            var setter = function (value) {<EOL>                injectedProp = value;<EOL>            };<EOL>            <EOL>             if (!(delete target[propertyKey])) {<EOL>                winstonLog.logError(`<STR_LIT>`);<EOL>                throw \"<STR_LIT>\";<EOL>            }<EOL>            <EOL>            Object.defineProperty(target, propertyKey, {<EOL>                 get: getter,<EOL>                set: setter,<EOL>","gt":"enumerable:"}
{"input":"<s> export function inject(injectType) {<EOL>    function getInjectType(target, propertyKey, parameterIndex, decoratorType) {<EOL>        if (injectType) {<EOL>            return  injectType;<EOL>        }<EOL>        let type;<EOL>        if (decoratorType === DecoratorType.PARAM) {<EOL>            var paramTypes =  Utils.getDesignParamType(target, propertyKey, parameterIndex);<EOL>            type = paramTypes && paramTypes.length && parameterIndex < paramTypes.length<EOL>                ? paramTypes[ parameterIndex]<EOL>                : null;<EOL>        }<EOL>        else if (decoratorType === DecoratorType.PROPERTY) {<EOL>            type = Utils.getDesignType(target, propertyKey);<EOL>        }<EOL>         else {<EOL>            winstonLog.logError(`<STR_LIT>`);<EOL>            throw '<STR_LIT>';<EOL>        }<EOL>        if (!type) {<EOL>            winstonLog.logError(`<STR_LIT>`);<EOL>            console.log(target);<EOL>            throw  '<STR_LIT>';<EOL>        }<EOL>        return type;<EOL>    }<EOL>    return function (target, propertyKey, parameterIndex) {<EOL>        <EOL>        if (arguments.length === <NUM_LIT>) {<EOL>            MetaUtils.addMetaData(target, {<EOL>                decorator: Decorators.INJECT,<EOL>                 decoratorType: DecoratorType.PARAM,<EOL>                params: { type: getInjectType(target, propertyKey, parameterIndex, DecoratorType.PARAM) },<EOL>                propertyKey: propertyKey,<EOL>                paramIndex: parameterIndex<EOL>            });<EOL>            return;<EOL>        }<EOL>        <EOL>        else {<EOL>            injectType = getInjectType(target,  propertyKey, parameterIndex, DecoratorType.PROPERTY);<EOL>            let injectedProp = null;<EOL>            <EOL>            var getter = function () {<EOL>                 if (!injectedProp) {<EOL>                    injectedProp = Container.resolve(injectType);<EOL>                    <EOL>                    <EOL>                    <EOL>                }<EOL>                return injectedProp;<EOL>            };<EOL>            var setter = function (value) {<EOL>                injectedProp = value;<EOL>            };<EOL>            <EOL>             if (!(delete target[propertyKey])) {<EOL>                winstonLog.logError(`<STR_LIT>`);<EOL>                throw \"<STR_LIT>\";<EOL>            }<EOL>            <EOL>            Object.defineProperty(target, propertyKey, {<EOL>                 get: getter,<EOL>                set: setter,<EOL>                 enumerable:","gt":"true,"}
{"input":"<s> export function getDbSpecifcModel(schemaName, schema) {<EOL>    var database = PrincipalContext.get(CoreUtils.resources.userDatabase);<EOL>    if (database && allConnections[database]) {<EOL>        return allConnections[database].","gt":"model(schemaName, schema);"}
{"input":"<s> export function document(params) {<EOL>    params = params || {};<EOL>    return function (target) {<EOL>        console.log(\"<STR_LIT>\" + params.name);<EOL>        if (_dcoumentDecoratorCache[params.name]) {<EOL>","gt":"return;"}
{"input":"<s> export function document(params) {<EOL>    params = params || {};<EOL>    return function (target) {<EOL>        console.log(\"<STR_LIT>\" + params.name);<EOL>        if (_dcoumentDecoratorCache[params.name]) {<EOL>             return;<EOL>        }<EOL>        _dcoumentDecoratorCache[params.name] = params;<EOL>        <EOL>        MetaUtils.addMetaData((target.","gt":"prototype || target), {"}
{"input":"<s> export function document(params) {<EOL>    params = params || {};<EOL>    return function (target) {<EOL>        console.log(\"<STR_LIT>\" + params.name);<EOL>        if (_dcoumentDecoratorCache[params.name]) {<EOL>             return;<EOL>        }<EOL>        _dcoumentDecoratorCache[params.name] = params;<EOL>        <EOL>        MetaUtils.addMetaData((target. prototype || target), {<EOL>            decorator: Decorators.DOCUMENT,<EOL>            decoratorType: DecoratorType.CLASS,<EOL>","gt":"modelType: DecoratorType.MODEL,"}
{"input":"<s> <EOL>export function bulkPut(model, objArr, batchSize, donotLoadChilds) {<EOL>    if (!objArr || !objArr.length)<EOL>        return Q.when([]);<EOL>    <EOL>    mongooseHelper.updateWriteCount();<EOL>    var asyncCalls = [];<EOL>    var length = objArr.","gt":"length;"}
{"input":"<s> <EOL>export function bulkPut(model, objArr, batchSize, donotLoadChilds) {<EOL>    if (!objArr || !objArr.length)<EOL>        return Q.when([]);<EOL>    <EOL>    mongooseHelper.updateWriteCount();<EOL>    var asyncCalls = [];<EOL>    var length = objArr. length;<EOL>    var ids = objArr.map((x) => x._id);<EOL>    var bulk = model.collection.initializeUnorderedBulkOp();<EOL>    var asyncCalls =","gt":"[];"}
{"input":"<s> <EOL>export function bulkPut(model, objArr, batchSize, donotLoadChilds) {<EOL>    if (!objArr || !objArr.length)<EOL>        return Q.when([]);<EOL>    <EOL>    mongooseHelper.updateWriteCount();<EOL>    var asyncCalls = [];<EOL>    var length = objArr. length;<EOL>    var ids = objArr.map((x) => x._id);<EOL>    var bulk = model.collection.initializeUnorderedBulkOp();<EOL>    var asyncCalls =  [];<EOL>    if (!batchSize) {<EOL>        asyncCalls.push(executeBulkPut(model, objArr, donotLoadChilds));<EOL>    }<EOL>    else {<EOL>        for (let curCount = <NUM_LIT>; curCount < objArr.length; curCount += batchSize) {<EOL>            asyncCalls.","gt":"push(executeBulkPut(model, objArr.slice(curCount, curCount + batchSize), donotLoadChilds));"}
{"input":"<s> <EOL>export function del(model, id) {<EOL>    <EOL>    let newModel = mongooseHelper.getChangedModelForDynamicSchema(model, id);<EOL>    return newModel.findByIdAndRemove(mongooseHelper.setShardCondition(model, { '<STR_LIT>': id })).lean().then((response) => {<EOL>        return mongooseHelper.deleteCascade(model, [response]).then((x) => {<EOL>            return mongooseHelper.deleteEmbeddedFromParent(model, EntityChange.delete, [response])<EOL>                .","gt":"then((res) => {"}
{"input":"<s> <EOL>export function del(model, id) {<EOL>    <EOL>    let newModel = mongooseHelper.getChangedModelForDynamicSchema(model, id);<EOL>    return newModel.findByIdAndRemove(mongooseHelper.setShardCondition(model, { '<STR_LIT>': id })).lean().then((response) => {<EOL>        return mongooseHelper.deleteCascade(model, [response]).then((x) => {<EOL>            return mongooseHelper.deleteEmbeddedFromParent(model, EntityChange.delete, [response])<EOL>                . then((res) => {<EOL>                <EOL>","gt":"return ({ delete: '<STR_LIT>' });"}
{"input":"<s> <EOL>export function findOne(model, id, donotLoadChilds) {<EOL>    <EOL>    let newModel = mongooseHelper.getChangedModelForDynamicSchema(model, id);<EOL>    return newModel.findOne(mongooseHelper.setShardCondition(model, { '<STR_LIT>': id })).lean().then((result) => {<EOL>        return mongooseHelper.embeddedChildren1(model, [","gt":"result], false, donotLoadChilds)"}
{"input":"<s> <EOL>export function findOne(model, id, donotLoadChilds) {<EOL>    <EOL>    let newModel = mongooseHelper.getChangedModelForDynamicSchema(model, id);<EOL>    return newModel.findOne(mongooseHelper.setShardCondition(model, { '<STR_LIT>': id })).lean().then((result) => {<EOL>        return mongooseHelper.embeddedChildren1(model, [ result], false, donotLoadChilds)<EOL>            .then((r) => {<EOL>            <EOL>            return result;<EOL>        });<EOL>    }).catch((error) => {<EOL>","gt":"winstonLog.logError(`<STR_LIT>`);"}
{"input":"<s> <EOL>export function post(model, obj) {<EOL>    <EOL>    mongooseHelper.updateWriteCount();<EOL>    let clonedObj = mongooseHelper.removeTransientProperties(model, obj);<EOL>    clonedObj[ConstantKeys.TempId] = clonedObj._id ? clonedObj._id : Utils.autogenerateIds(","gt":"model);"}
{"input":"<s> <EOL>export function post(model, obj) {<EOL>    <EOL>    mongooseHelper.updateWriteCount();<EOL>    let clonedObj = mongooseHelper.removeTransientProperties(model, obj);<EOL>    clonedObj[ConstantKeys.TempId] = clonedObj._id ? clonedObj._id : Utils.autogenerateIds( model);<EOL>","gt":"return mongooseHelper.addChildModelToParent(model, [clonedObj])"}
{"input":"<s> <EOL>export function post(model, obj) {<EOL>    <EOL>    mongooseHelper.updateWriteCount();<EOL>    let clonedObj = mongooseHelper.removeTransientProperties(model, obj);<EOL>    clonedObj[ConstantKeys.TempId] = clonedObj._id ? clonedObj._id : Utils.autogenerateIds( model);<EOL>     return mongooseHelper.addChildModelToParent(model, [clonedObj])<EOL>        .then((result) => {<EOL>        <EOL>        <EOL>        <EOL>        <EOL>        <EOL>        <EOL>        <EOL>        if (clonedObj[ConstantKeys.TempId]) {<EOL>            clonedObj._id = clonedObj[ConstantKeys.TempId];<EOL>            delete clonedObj[ConstantKeys.TempId];<EOL>        }<EOL>        mongooseHelper.setUniqueIdFromShard(clonedObj);<EOL>        mongooseHelper.setShardCondition(model, clonedObj);<EOL>        <EOL>        if (_arrayPropListSchema[model.modelName]) {<EOL>            _arrayPropListSchema[model.modelName].","gt":"forEach((prop) => {"}
{"input":"<s> <EOL>export function post(model, obj) {<EOL>    <EOL>    mongooseHelper.updateWriteCount();<EOL>    let clonedObj = mongooseHelper.removeTransientProperties(model, obj);<EOL>    clonedObj[ConstantKeys.TempId] = clonedObj._id ? clonedObj._id : Utils.autogenerateIds( model);<EOL>     return mongooseHelper.addChildModelToParent(model, [clonedObj])<EOL>        .then((result) => {<EOL>        <EOL>        <EOL>        <EOL>        <EOL>        <EOL>        <EOL>        <EOL>        if (clonedObj[ConstantKeys.TempId]) {<EOL>            clonedObj._id = clonedObj[ConstantKeys.TempId];<EOL>            delete clonedObj[ConstantKeys.TempId];<EOL>        }<EOL>        mongooseHelper.setUniqueIdFromShard(clonedObj);<EOL>        mongooseHelper.setShardCondition(model, clonedObj);<EOL>        <EOL>        if (_arrayPropListSchema[model.modelName]) {<EOL>            _arrayPropListSchema[model.modelName]. forEach((prop) => {<EOL>                if (!clonedObj[prop]) {<EOL>                    clonedObj[prop] = [];<EOL>                }<EOL>            });<EOL>        }<EOL>        let newModel = mongooseHelper.getNewModelFromObject(model, clonedObj);<EOL>        return Q.nbind(newModel.create, newModel)(clonedObj).then((result) => {<EOL>            let resObj = Utils.toObject(result);<EOL>","gt":"Object.assign(obj, resObj);"}
{"input":"<s> <EOL>export function put(model, id, obj) {<EOL>    <EOL>    <EOL>    return bulkPut(model, [obj]).then((res) => {<EOL>        if (res.length) {<EOL>            <EOL>            Object.assign(obj, res[<NUM_LIT>]);<EOL>            <EOL>            return obj;<EOL>        }<EOL>        <EOL>        return [];<EOL>    }).","gt":"catch((error) => {"}
{"input":"<s> export function column(params) {<EOL>    return function (target, propertyKey) {<EOL>        console.log('<STR_LIT>', propertyKey, '<STR_LIT>', target);<EOL>","gt":"MetaUtils.addMetaData(target, {"}
{"input":"<s> export function AddAllFakeFunctions() {<EOL>    database[ModelNames.course] = [];<EOL>    _mongooseModel[ModelNames.course] = Mongoose.model(ModelNames.course, new Mongoose.Schema(course.prototype.schema()));<EOL>    _databaseCalls[ModelNames.course] =","gt":"new courseRepository();"}
{"input":"<s> function bindActions(actions, intent$, self) {<EOL>    let _actions = {<EOL>        fromEvent(e) {<EOL>            return intent$.next(e);<EOL>        },<EOL>        fromPromise(p) {<EOL>            return","gt":"p.then((x) => intent$.next(x));"}
{"input":"<s> function bindActions(actions, intent$, self) {<EOL>    let _actions = {<EOL>        fromEvent(e) {<EOL>            return intent$.next(e);<EOL>        },<EOL>        fromPromise(p) {<EOL>            return  p.then((x) => intent$.next(x));<EOL>        },<EOL>        terminate(a) {<EOL>            if (process.env.NODE_ENV == '<STR_LIT>')<EOL>                console.error('<STR_LIT>');<EOL>            return intent$.","gt":"complete(a);"}
{"input":"<s> function bindActions(actions, intent$, self) {<EOL>    let _actions = {<EOL>        fromEvent(e) {<EOL>            return intent$.next(e);<EOL>        },<EOL>        fromPromise(p) {<EOL>            return  p.then((x) => intent$.next(x));<EOL>        },<EOL>        terminate(a) {<EOL>            if (process.env.NODE_ENV == '<STR_LIT>')<EOL>                console.error('<STR_LIT>');<EOL>            return intent$. complete(a);<EOL>        }<EOL>    };<EOL>    for (let a in actions) {<EOL>","gt":"_actions[a] = (...args) => {"}
{"input":"<s> function isSFC(Component) {<EOL>    return (","gt":"typeof Component == '<STR_LIT>');"}
{"input":"<s> function getRandom() {<EOL>    let min = <NUM_LIT>, max =","gt":"Math.pow(<NUM_LIT>, <NUM_LIT>) - <NUM_LIT>;"}
{"input":"<s> async function* tick(t) {<EOL>    let i = <NUM_LIT>;<EOL>","gt":"while (<NUM_LIT>) {"}
{"input":"<s> export function debounce(func, wait, immediate = false) {<EOL>    var timeout;<EOL>    return function () {<EOL>        var context = this, args = arguments;<EOL>        var later = function () {<EOL>            timeout =","gt":"null;"}
{"input":"<s> export function debounce(func, wait, immediate = false) {<EOL>    var timeout;<EOL>    return function () {<EOL>        var context = this, args = arguments;<EOL>        var later = function () {<EOL>            timeout =  null;<EOL>            if (!immediate)<EOL>                func.apply(context, args);<EOL>        };<EOL>        var callNow = immediate && !timeout;<EOL>        clearTimeout(timeout);<EOL>","gt":"timeout = setTimeout(later, wait);"}
{"input":"<s> export function isTextLike(contentType) {<EOL>","gt":"return contentType.search(/text\\/plain/i) !== -<NUM_LIT>;"}
{"input":"<s> <EOL>export function getChildDebugElementByType(parent, type) {<EOL>    return parent.","gt":"query(By.directive(type));"}
{"input":"<s> function setIncompleteClasspathSeverity(severity) {<EOL>    const","gt":"config = getJavaConfiguration();"}
{"input":"<s> function checkJavaRuntime() {<EOL>    return new Promise((resolve, reject) => {<EOL>        let source;<EOL>        let","gt":"javaHome = readJavaConfig();"}
{"input":"<s> function checkJavaRuntime() {<EOL>    return new Promise((resolve, reject) => {<EOL>        let source;<EOL>        let  javaHome = readJavaConfig();<EOL>        if (javaHome) {<EOL>            source = '<STR_LIT>';<EOL>        }<EOL>","gt":"else {"}
{"input":"<s> function checkJavaRuntime() {<EOL>    return new Promise((resolve, reject) => {<EOL>        let source;<EOL>        let  javaHome = readJavaConfig();<EOL>        if (javaHome) {<EOL>            source = '<STR_LIT>';<EOL>        }<EOL>         else {<EOL>            javaHome = process.env['<STR_LIT>'];<EOL>            if (javaHome) {<EOL>                source = '<STR_LIT>';<EOL>            }<EOL>","gt":"else {"}
{"input":"<s> function checkJavaRuntime() {<EOL>    return new Promise((resolve, reject) => {<EOL>        let source;<EOL>        let  javaHome = readJavaConfig();<EOL>        if (javaHome) {<EOL>            source = '<STR_LIT>';<EOL>        }<EOL>         else {<EOL>            javaHome = process.env['<STR_LIT>'];<EOL>            if (javaHome) {<EOL>                source = '<STR_LIT>';<EOL>            }<EOL>             else {<EOL>                javaHome = process.env['<STR_LIT>'];<EOL>                source = '<STR_LIT>';<EOL>            }<EOL>        }<EOL>        if (javaHome) {<EOL>            javaHome = expandHomeDir(javaHome);<EOL>            if (!pathExists.sync(javaHome)) {<EOL>                openJDKDownload(","gt":"reject, source + '<STR_LIT>');"}
{"input":"<s> function checkJavaRuntime() {<EOL>    return new Promise((resolve, reject) => {<EOL>        let source;<EOL>        let  javaHome = readJavaConfig();<EOL>        if (javaHome) {<EOL>            source = '<STR_LIT>';<EOL>        }<EOL>         else {<EOL>            javaHome = process.env['<STR_LIT>'];<EOL>            if (javaHome) {<EOL>                source = '<STR_LIT>';<EOL>            }<EOL>             else {<EOL>                javaHome = process.env['<STR_LIT>'];<EOL>                source = '<STR_LIT>';<EOL>            }<EOL>        }<EOL>        if (javaHome) {<EOL>            javaHome = expandHomeDir(javaHome);<EOL>            if (!pathExists.sync(javaHome)) {<EOL>                openJDKDownload( reject, source + '<STR_LIT>');<EOL>            }<EOL>            if (!pathExists.sync(path.resolve(javaHome, '<STR_LIT>', JAVAC_FILENAME))) {<EOL>                openJDKDownload(reject, source + '<STR_LIT>');<EOL>            }<EOL>            return resolve(javaHome);<EOL>        }<EOL>        <EOL>        findJavaHome(function (","gt":"err, home) {"}
{"input":"<s> function reducer2(state, action) {<EOL>    if (isCustomAction(action)) {<EOL>        let a = action.payload.a;<EOL>    }<EOL>    else if (isCustomAction2(","gt":"action)) {"}
{"input":"<s> function reducer2(state, action) {<EOL>    if (isCustomAction(action)) {<EOL>        let a = action.payload.a;<EOL>    }<EOL>    else if (isCustomAction2( action)) {<EOL>        let a = action.payload.a;<EOL>        let b = action.meta.b;<EOL>    }<EOL>    else if (isCustomAction3(","gt":"action)) {"}
{"input":"<s> function load() {<EOL>    init();<EOL>    const itemBox = document.getElementById('<STR_LIT>');<EOL>    const","gt":"citekeyBox = document.getElementById('<STR_LIT>');"}
{"input":"<s> function showDyingDialog(title, detail) {<EOL>    dialog.showMessageBox({<EOL>        type: '<STR_LIT>',<EOL>        message:","gt":"title,"}
{"input":"<s> export function send(channel, ...args) {<EOL>    log.","gt":"info('<STR_LIT>', channel, args);"}
{"input":"<s> function reloadPreview() {<EOL>    if (document.getElementById('<STR_LIT>') !== null) {<EOL>        renderMarkdownPreview(watching_path);<EOL>    }<EOL>    else","gt":"if (document.getElementById('<STR_LIT>') !== null) {"}
{"input":"<s> function parseFlags(tx) {<EOL>    const settings = {};<EOL>    if (tx.TransactionType !== '<STR_LIT>') {<EOL>        return","gt":"settings;"}
{"input":"<s> function parseFlags(tx) {<EOL>    const settings = {};<EOL>    if (tx.TransactionType !== '<STR_LIT>') {<EOL>        return  settings;<EOL>    }<EOL>    const node = getAccountRootModifiedNode(tx);<EOL>    const oldFlags = _.get(","gt":"node.PreviousFields, '<STR_LIT>');"}
{"input":"<s> function parseFlags(tx) {<EOL>    const settings = {};<EOL>    if (tx.TransactionType !== '<STR_LIT>') {<EOL>        return  settings;<EOL>    }<EOL>    const node = getAccountRootModifiedNode(tx);<EOL>    const oldFlags = _.get( node.PreviousFields, '<STR_LIT>');<EOL>    const newFlags = _.get(node.FinalFields, '<STR_LIT>');<EOL>    if (oldFlags !== undefined && newFlags !== undefined) {<EOL>        const changedFlags = oldFlags ^ newFlags;<EOL>","gt":"const setFlags = newFlags & changedFlags;"}
{"input":"<s> function parseFlags(tx) {<EOL>    const settings = {};<EOL>    if (tx.TransactionType !== '<STR_LIT>') {<EOL>        return  settings;<EOL>    }<EOL>    const node = getAccountRootModifiedNode(tx);<EOL>    const oldFlags = _.get( node.PreviousFields, '<STR_LIT>');<EOL>    const newFlags = _.get(node.FinalFields, '<STR_LIT>');<EOL>    if (oldFlags !== undefined && newFlags !== undefined) {<EOL>        const changedFlags = oldFlags ^ newFlags;<EOL>         const setFlags = newFlags & changedFlags;<EOL>        const clearedFlags = oldFlags & changedFlags;<EOL>        _.forEach(AccountFlags, (flagValue, flagName) => {<EOL>            if (setFlags & flagValue) {<EOL>                settings[flagName] =","gt":"true;"}
{"input":"<s> function parseFlags(tx) {<EOL>    const settings = {};<EOL>    if (tx.TransactionType !== '<STR_LIT>') {<EOL>        return  settings;<EOL>    }<EOL>    const node = getAccountRootModifiedNode(tx);<EOL>    const oldFlags = _.get( node.PreviousFields, '<STR_LIT>');<EOL>    const newFlags = _.get(node.FinalFields, '<STR_LIT>');<EOL>    if (oldFlags !== undefined && newFlags !== undefined) {<EOL>        const changedFlags = oldFlags ^ newFlags;<EOL>         const setFlags = newFlags & changedFlags;<EOL>        const clearedFlags = oldFlags & changedFlags;<EOL>        _.forEach(AccountFlags, (flagValue, flagName) => {<EOL>            if (setFlags & flagValue) {<EOL>                settings[flagName] =  true;<EOL>            }<EOL>            else if (clearedFlags & flagValue) {<EOL>                settings[flagName] =","gt":"false;"}
{"input":"<s> function parseFlags(tx) {<EOL>    const settings = {};<EOL>    if (tx.TransactionType !== '<STR_LIT>') {<EOL>        return  settings;<EOL>    }<EOL>    const node = getAccountRootModifiedNode(tx);<EOL>    const oldFlags = _.get( node.PreviousFields, '<STR_LIT>');<EOL>    const newFlags = _.get(node.FinalFields, '<STR_LIT>');<EOL>    if (oldFlags !== undefined && newFlags !== undefined) {<EOL>        const changedFlags = oldFlags ^ newFlags;<EOL>         const setFlags = newFlags & changedFlags;<EOL>        const clearedFlags = oldFlags & changedFlags;<EOL>        _.forEach(AccountFlags, (flagValue, flagName) => {<EOL>            if (setFlags & flagValue) {<EOL>                settings[flagName] =  true;<EOL>            }<EOL>            else if (clearedFlags & flagValue) {<EOL>                settings[flagName] =  false;<EOL>            }<EOL>        });<EOL>    }<EOL>    <EOL>    <EOL>    <EOL>    const oldField = _.get(node.PreviousFields, '<STR_LIT>');<EOL>    const newField = _.get(","gt":"node.FinalFields, '<STR_LIT>');"}
{"input":"<s> function removeEmptyCounterparty(amount) {<EOL>","gt":"if (amount.counterparty === '<STR_LIT>') {"}
{"input":"<s> function formatSettings(response) {<EOL>    const data = response.account_data;<EOL>    const parsedFlags = parseFlags(","gt":"data.Flags);"}
{"input":"<s> function transactionFilter(address, filters, tx) {<EOL>    if (filters.excludeFailures && tx.outcome.result !== '<STR_LIT>') {<EOL>        return false;<EOL>    }<EOL>    if (filters.types && !_.includes(filters.types, tx.type)) {<EOL>","gt":"return false;"}
{"input":"<s> function transactionFilter(address, filters, tx) {<EOL>    if (filters.excludeFailures && tx.outcome.result !== '<STR_LIT>') {<EOL>        return false;<EOL>    }<EOL>    if (filters.types && !_.includes(filters.types, tx.type)) {<EOL>         return false;<EOL>    }<EOL>    if (filters.initiated === true && tx.address !== address) {<EOL>        return false;<EOL>    }<EOL>    if (filters.initiated === false && tx.address === address) {<EOL>        return false;<EOL>    }<EOL>","gt":"if (filters.counterparty && !counterpartyFilter(filters, tx)) {"}
{"input":"<s> function ensureLedgerVersion(options) {<EOL>    if (Boolean(options) && options.ledgerVersion !== undefined &&<EOL>        options.","gt":"ledgerVersion !== null) {"}
{"input":"<s> function generateAddressAPI(options) {<EOL>    validate.generateAddress({ options });<EOL>    try {<EOL>        return","gt":"generateAddress(options);"}
{"input":"<s> function convertMemo(memo) {<EOL>    return {<EOL>        Memo: common.removeUndefined({<EOL>            MemoData: memo.data ? convertStringToHex(memo.data) :","gt":"undefined,"}
{"input":"<s> <EOL>export function containsEs6Syntax(value) {<EOL>    <EOL>    const","gt":"ES6_SYNTAX_REGEX = /(^class | class )|(^const | const )|(^let | let )|(^async | async )|(^await | await )|(^yield | yield )|(=>)|function\\*|\\`/gm;"}
{"input":"<s> <EOL>export function Language() {<EOL>    function DecoratorFactory(target, propertyKey) {<EOL>        let subscription;<EOL>        const targetNgOnInit = target.","gt":"ngOnInit;"}
{"input":"<s> <EOL>export function Language() {<EOL>    function DecoratorFactory(target, propertyKey) {<EOL>        let subscription;<EOL>        const targetNgOnInit = target. ngOnInit;<EOL>        function ngOnInit() {<EOL>            const translation = InjectorRef.get(TranslationService);<EOL>            if (typeof propertyKey !== \"<STR_LIT>\") {<EOL>                <EOL>                subscription = translation.translationChanged().subscribe((language) => {<EOL>                    this[propertyKey] = language;<EOL>                });<EOL>            }<EOL>            if (targetNgOnInit) {<EOL>                targetNgOnInit.apply(this);<EOL>            }<EOL>        }<EOL>        target.ngOnInit = ngOnInit;<EOL>        const targetNgOnDestroy = target.ngOnDestroy;<EOL>        function ngOnDestroy() {<EOL>            if (typeof subscription !==","gt":"\"<STR_LIT>\") {"}
{"input":"<s> <EOL>export function Language() {<EOL>    function DecoratorFactory(target, propertyKey) {<EOL>        let subscription;<EOL>        const targetNgOnInit = target. ngOnInit;<EOL>        function ngOnInit() {<EOL>            const translation = InjectorRef.get(TranslationService);<EOL>            if (typeof propertyKey !== \"<STR_LIT>\") {<EOL>                <EOL>                subscription = translation.translationChanged().subscribe((language) => {<EOL>                    this[propertyKey] = language;<EOL>                });<EOL>            }<EOL>            if (targetNgOnInit) {<EOL>                targetNgOnInit.apply(this);<EOL>            }<EOL>        }<EOL>        target.ngOnInit = ngOnInit;<EOL>        const targetNgOnDestroy = target.ngOnDestroy;<EOL>        function ngOnDestroy() {<EOL>            if (typeof subscription !==  \"<STR_LIT>\") {<EOL>                subscription.unsubscribe();<EOL>            }<EOL>            if (targetNgOnDestroy) {<EOL>                targetNgOnDestroy.apply(this);<EOL>            }<EOL>        }<EOL>        target.","gt":"ngOnDestroy = ngOnDestroy;"}
{"input":"<s> <EOL>export function l10nValidateNumber(digits, MIN_VALUE = Number.MIN_VALUE, MAX_VALUE = Number.MAX_VALUE) {<EOL>    const locale = InjectorRef.get(LocaleService);<EOL>    const localeValidation = InjectorRef.get(LocaleValidation);<EOL>    let defaultLocale;<EOL>    let","gt":"NUMBER_REGEXP;"}
{"input":"<s> <EOL>export function l10nValidateNumber(digits, MIN_VALUE = Number.MIN_VALUE, MAX_VALUE = Number.MAX_VALUE) {<EOL>    const locale = InjectorRef.get(LocaleService);<EOL>    const localeValidation = InjectorRef.get(LocaleValidation);<EOL>    let defaultLocale;<EOL>    let  NUMBER_REGEXP;<EOL>    return (","gt":"formControl) => {"}
{"input":"<s> <EOL>export function l10nValidateNumber(digits, MIN_VALUE = Number.MIN_VALUE, MAX_VALUE = Number.MAX_VALUE) {<EOL>    const locale = InjectorRef.get(LocaleService);<EOL>    const localeValidation = InjectorRef.get(LocaleValidation);<EOL>    let defaultLocale;<EOL>    let  NUMBER_REGEXP;<EOL>    return ( formControl) => {<EOL>        if (formControl.value == null || formControl.value == \"<STR_LIT>\")<EOL>","gt":"return null;"}
{"input":"<s> <EOL>export function l10nValidateNumber(digits, MIN_VALUE = Number.MIN_VALUE, MAX_VALUE = Number.MAX_VALUE) {<EOL>    const locale = InjectorRef.get(LocaleService);<EOL>    const localeValidation = InjectorRef.get(LocaleValidation);<EOL>    let defaultLocale;<EOL>    let  NUMBER_REGEXP;<EOL>    return ( formControl) => {<EOL>        if (formControl.value == null || formControl.value == \"<STR_LIT>\")<EOL>             return null;<EOL>        if (defaultLocale != locale.getDefaultLocale()) {<EOL>            NUMBER_REGEXP = localeValidation.getRegExp(digits);<EOL>            defaultLocale = locale.getDefaultLocale();<EOL>        }<EOL>        if (NUMBER_REGEXP.test(formControl.","gt":"value)) {"}
{"input":"<s> <EOL>export function l10nValidateNumber(digits, MIN_VALUE = Number.MIN_VALUE, MAX_VALUE = Number.MAX_VALUE) {<EOL>    const locale = InjectorRef.get(LocaleService);<EOL>    const localeValidation = InjectorRef.get(LocaleValidation);<EOL>    let defaultLocale;<EOL>    let  NUMBER_REGEXP;<EOL>    return ( formControl) => {<EOL>        if (formControl.value == null || formControl.value == \"<STR_LIT>\")<EOL>             return null;<EOL>        if (defaultLocale != locale.getDefaultLocale()) {<EOL>            NUMBER_REGEXP = localeValidation.getRegExp(digits);<EOL>            defaultLocale = locale.getDefaultLocale();<EOL>        }<EOL>        if (NUMBER_REGEXP.test(formControl. value)) {<EOL>            const parsedValue = localeValidation.parseNumber(formControl.value);<EOL>            if (parsedValue != null && parsedValue < MIN_VALUE) {<EOL>                return {<EOL>","gt":"minValue: {"}
{"input":"<s> <EOL>export function l10nValidateNumber(digits, MIN_VALUE = Number.MIN_VALUE, MAX_VALUE = Number.MAX_VALUE) {<EOL>    const locale = InjectorRef.get(LocaleService);<EOL>    const localeValidation = InjectorRef.get(LocaleValidation);<EOL>    let defaultLocale;<EOL>    let  NUMBER_REGEXP;<EOL>    return ( formControl) => {<EOL>        if (formControl.value == null || formControl.value == \"<STR_LIT>\")<EOL>             return null;<EOL>        if (defaultLocale != locale.getDefaultLocale()) {<EOL>            NUMBER_REGEXP = localeValidation.getRegExp(digits);<EOL>            defaultLocale = locale.getDefaultLocale();<EOL>        }<EOL>        if (NUMBER_REGEXP.test(formControl. value)) {<EOL>            const parsedValue = localeValidation.parseNumber(formControl.value);<EOL>            if (parsedValue != null && parsedValue < MIN_VALUE) {<EOL>                return {<EOL>                     minValue: {<EOL>                        valid: false<EOL>                    }<EOL>                };<EOL>            }<EOL>            else if (parsedValue != null && parsedValue > MAX_VALUE) {<EOL>                return {<EOL>                    maxValue: {<EOL>                        valid: false<EOL>                    }<EOL>                };<EOL>            }<EOL>","gt":"return null;"}
{"input":"<s> <EOL>export function CookiesParams(expression, useType) {<EOL>    return ParamRegistry.decorate(","gt":"CookiesFilter, { expression, useType });"}
{"input":"<s> <EOL>export function isDate(target) {<EOL>    return target === Date ||","gt":"target instanceof Date;"}
{"input":"<s> <EOL>export function inject(targets, func) {<EOL>    loadInjector();<EOL>    return (done) => {<EOL>        let isDoneInjected = false;<EOL>        const args = targets.map((target) => {<EOL>            if (target === Done) {<EOL>                isDoneInjected =","gt":"true;"}
{"input":"<s> <EOL>export function inject(targets, func) {<EOL>    loadInjector();<EOL>    return (done) => {<EOL>        let isDoneInjected = false;<EOL>        const args = targets.map((target) => {<EOL>            if (target === Done) {<EOL>                isDoneInjected =  true;<EOL>                return done;<EOL>            }<EOL>            <EOL>","gt":"if (!InjectorService.has(target)) {"}
{"input":"<s> function visitOp(n, c, depth) {<EOL>    <EOL>    switch (n.t) {<EOL>        case t.","gt":"instr: {"}
{"input":"<s> function visitOp(n, c, depth) {<EOL>    <EOL>    switch (n.t) {<EOL>        case t. instr: {<EOL>            if (n.v == <NUM_LIT> || n.v == <NUM_LIT> ) {<EOL>                depth--;<EOL>            }<EOL>","gt":"return c.writeln(depth, opcodes.get(n.v));"}
{"input":"<s> function visitOp(n, c, depth) {<EOL>    <EOL>    switch (n.t) {<EOL>        case t. instr: {<EOL>            if (n.v == <NUM_LIT> || n.v == <NUM_LIT> ) {<EOL>                depth--;<EOL>            }<EOL>             return c.writeln(depth, opcodes.get(n.v));<EOL>        }<EOL>        case t.instr_imm1: {<EOL>            return c.writeln(depth, opcodes.get(n.v) + '<STR_LIT>' + fmtimm(n.imm));<EOL>        }<EOL>","gt":"case t.instr_pre: {"}
{"input":"<s> function visitOp(n, c, depth) {<EOL>    <EOL>    switch (n.t) {<EOL>        case t. instr: {<EOL>            if (n.v == <NUM_LIT> || n.v == <NUM_LIT> ) {<EOL>                depth--;<EOL>            }<EOL>             return c.writeln(depth, opcodes.get(n.v));<EOL>        }<EOL>        case t.instr_imm1: {<EOL>            return c.writeln(depth, opcodes.get(n.v) + '<STR_LIT>' + fmtimm(n.imm));<EOL>        }<EOL>         case t.instr_pre: {<EOL>            visitOps(n.pre, c, depth);<EOL>            return c.writeln(depth, opcodes.get(n.v));<EOL>        }<EOL>        case t.instr_pre1: {<EOL>            visitOp(n.pre, c, depth);<EOL>            return c.writeln(depth, opcodes.get(n.v));<EOL>        }<EOL>","gt":"case t.instr_imm1_post: {"}
{"input":"<s> function visitOp(n, c, depth) {<EOL>    <EOL>    switch (n.t) {<EOL>        case t. instr: {<EOL>            if (n.v == <NUM_LIT> || n.v == <NUM_LIT> ) {<EOL>                depth--;<EOL>            }<EOL>             return c.writeln(depth, opcodes.get(n.v));<EOL>        }<EOL>        case t.instr_imm1: {<EOL>            return c.writeln(depth, opcodes.get(n.v) + '<STR_LIT>' + fmtimm(n.imm));<EOL>        }<EOL>         case t.instr_pre: {<EOL>            visitOps(n.pre, c, depth);<EOL>            return c.writeln(depth, opcodes.get(n.v));<EOL>        }<EOL>        case t.instr_pre1: {<EOL>            visitOp(n.pre, c, depth);<EOL>            return c.writeln(depth, opcodes.get(n.v));<EOL>        }<EOL>         case t.instr_imm1_post: {<EOL>            c.writeln(depth, opcodes.get(n.v) + '<STR_LIT>' + fmtimm(n.imm));<EOL>            return visitOps(n.post, c, depth + <NUM_LIT>);<EOL>        }<EOL>        case t.instr_pre_imm: {<EOL>            visitOps(n.pre, c, depth);<EOL>            return c.writeln(depth, opcodes.get(n.v) + fmtimmv(n.imm));<EOL>        }<EOL>","gt":"case t.instr_pre_imm_post: {"}
{"input":"<s> <EOL><EOL>export function concatMapTo(innerObservable, resultSelector) {<EOL>    return","gt":"this.lift(new MergeMapToOperator(innerObservable, resultSelector, <NUM_LIT>));"}
{"input":"<s> <EOL><EOL>export function distinctUntilChanged(compare, keySelector) {<EOL>","gt":"return this.lift(new DistinctUntilChangedOperator(compare, keySelector));"}
{"input":"<s> <EOL><EOL>export function _do(nextOrObserver, error, complete) {<EOL>    return this.lift(","gt":"new DoOperator(nextOrObserver, error, complete));"}
{"input":"<s> <EOL>export function partition(predicate, thisArg) {<EOL>    return [<EOL>","gt":"filter.call(this, predicate, thisArg),"}
{"input":"<s> <EOL><EOL>export function switchMapTo(innerObservable, resultSelector) {<EOL>","gt":"return this.lift(new SwitchMapToOperator(innerObservable, resultSelector));"}
{"input":"<s> <EOL>export function timestamp(scheduler = async) {<EOL>    return","gt":"this.lift(new TimestampOperator(scheduler));"}
{"input":"<s> async function swActivate() {<EOL>    const keys = await caches.keys();<EOL>    let deletes = [];<EOL>    for (var key of","gt":"keys) {"}
{"input":"<s> async function swInstall() {<EOL>    const rs = await fetch('<STR_LIT>');<EOL>","gt":"const body = await rs.text();"}
{"input":"<s> function onTouchMove(e) {<EOL>    if (appState.pickerOpen) {<EOL>","gt":"return;"}
{"input":"<s> export function Info() {<EOL>    <EOL>    let project = ws.url.split('<STR_LIT>')[<NUM_LIT>];<EOL>    if (injectify.debug)<EOL>        project = project.substring(<NUM_LIT>);<EOL>    <EOL>    let url = ws.url.split('<STR_LIT>');<EOL>    let protocol = `<STR_LIT>`;<EOL>    let server = protocol + url[","gt":"<NUM_LIT>];"}
{"input":"<s> export function Info() {<EOL>    <EOL>    let project = ws.url.split('<STR_LIT>')[<NUM_LIT>];<EOL>    if (injectify.debug)<EOL>        project = project.substring(<NUM_LIT>);<EOL>    <EOL>    let url = ws.url.split('<STR_LIT>');<EOL>    let protocol = `<STR_LIT>`;<EOL>    let server = protocol + url[ <NUM_LIT>];<EOL>    return {<EOL>        '<STR_LIT>': atob(project),<EOL>        '<STR_LIT>': {<EOL>            '<STR_LIT>': ws.url,<EOL>            '<STR_LIT>':","gt":"server"}
{"input":"<s> export function Info() {<EOL>    <EOL>    let project = ws.url.split('<STR_LIT>')[<NUM_LIT>];<EOL>    if (injectify.debug)<EOL>        project = project.substring(<NUM_LIT>);<EOL>    <EOL>    let url = ws.url.split('<STR_LIT>');<EOL>    let protocol = `<STR_LIT>`;<EOL>    let server = protocol + url[ <NUM_LIT>];<EOL>    return {<EOL>        '<STR_LIT>': atob(project),<EOL>        '<STR_LIT>': {<EOL>            '<STR_LIT>': ws.url,<EOL>            '<STR_LIT>':  server<EOL>        },<EOL>        '<STR_LIT>': client.id,<EOL>        '<STR_LIT>': client.platform,<EOL>        '<STR_LIT>': injectify.duration,<EOL>        '<STR_LIT>': injectify.debug,<EOL>        '<STR_LIT>':","gt":"client.os,"}
{"input":"<s> <EOL>export function generateParserModule(options) {<EOL>    return genUmdModule({ name: options.name, rules: options.","gt":"rules });"}
{"input":"<s> export function getProductionOverriddenForClass(className) {<EOL>    return","gt":"getFromNestedHashTable(className, CLASS_TO_PRODUCTION_OVERRIDEN);"}
{"input":"<s> export function addTerminalToCst(node, token, tokenTypeName) {<EOL>    if (node.children[tokenTypeName] === undefined) {<EOL>","gt":"node.children[tokenTypeName] = [token];"}
{"input":"<s> function buildManySepProd(prodRange, allRanges) {<EOL>    return buildRepetitionWithSep(prodRange, allRanges,","gt":"RepetitionWithSeparator, manyWithSeparatorRegEx);"}
{"input":"<s> export function createAtLeastOneSepRanges(text) {<EOL>","gt":"return createOperatorProdRangeParenthesis(text, ProdType.AT_LEAST_ONE_SEP, atLeastOneWithSeparatorRegExGlobal);"}
{"input":"<s> function createOperatorProdRangeInternal(text, prodType, pattern, findTerminatorOffSet) {<EOL>    let operatorRanges = [];<EOL>    let matched;<EOL>    while ((matched = pattern.exec(text))) {<EOL>        let start = matched.index;<EOL>        <EOL>        let stop = findTerminatorOffSet(start + matched[<NUM_LIT>].length, text);<EOL>        let currRange = new Range(start, stop);<EOL>        let currText = text.substr(start, stop - start + <NUM_LIT>);<EOL>","gt":"operatorRanges.push({"}
{"input":"<s> function createOperatorProdRangeInternal(text, prodType, pattern, findTerminatorOffSet) {<EOL>    let operatorRanges = [];<EOL>    let matched;<EOL>    while ((matched = pattern.exec(text))) {<EOL>        let start = matched.index;<EOL>        <EOL>        let stop = findTerminatorOffSet(start + matched[<NUM_LIT>].length, text);<EOL>        let currRange = new Range(start, stop);<EOL>        let currText = text.substr(start, stop - start + <NUM_LIT>);<EOL>         operatorRanges.push({<EOL>            range: currRange,<EOL>            text: currText,<EOL>","gt":"type: prodType"}
{"input":"<s> function createRefOrTerminalProdRangeInternal(text, prodType, pattern) {<EOL>    let prodRanges = [];<EOL>    let matched;<EOL>    while ((matched = pattern.exec(text))) {<EOL>        let start = matched.index;<EOL>","gt":"let stop = pattern.lastIndex;"}
{"input":"<s> function createRefOrTerminalProdRangeInternal(text, prodType, pattern) {<EOL>    let prodRanges = [];<EOL>    let matched;<EOL>    while ((matched = pattern.exec(text))) {<EOL>        let start = matched.index;<EOL>         let stop = pattern.lastIndex;<EOL>        let currRange = new Range(start, stop);<EOL>        let currText = matched[<NUM_LIT>];<EOL>        prodRanges.push({<EOL>            range: currRange,<EOL>            text: currText,<EOL>            type:","gt":"prodType"}
{"input":"<s> export function hasExtendingTokensTypesProperty(tokType) {<EOL>    return has(tokType,","gt":"\"<STR_LIT>\");"}
{"input":"<s> export function tokenStructuredMatcher(tokInstance, tokConstructor) {<EOL>    const instanceType = tokInstance.tokenTypeIdx;<EOL>    if (instanceType === tokConstructor.tokenTypeIdx) {<EOL>","gt":"return true;"}
{"input":"<s> function objectBoxStyle(size) {<EOL>    let width = '<STR_LIT>';<EOL>    let height = '<STR_LIT>';<EOL>    if (size.vertical) {<EOL>        height = size.vertical === '<STR_LIT>'<EOL>            ?","gt":"'<STR_LIT>'"}
{"input":"<s> function objectBoxStyle(size) {<EOL>    let width = '<STR_LIT>';<EOL>    let height = '<STR_LIT>';<EOL>    if (size.vertical) {<EOL>        height = size.vertical === '<STR_LIT>'<EOL>            ?  '<STR_LIT>'<EOL>            : `<STR_LIT>`;<EOL>    }<EOL>    if (size.horizontal) {<EOL>        width =","gt":"size.horizontal === '<STR_LIT>'"}
{"input":"<s> function objectBoxStyle(size) {<EOL>    let width = '<STR_LIT>';<EOL>    let height = '<STR_LIT>';<EOL>    if (size.vertical) {<EOL>        height = size.vertical === '<STR_LIT>'<EOL>            ?  '<STR_LIT>'<EOL>            : `<STR_LIT>`;<EOL>    }<EOL>    if (size.horizontal) {<EOL>        width =  size.horizontal === '<STR_LIT>'<EOL>            ? '<STR_LIT>'<EOL>            : `<STR_LIT>`;<EOL>    }<EOL>","gt":"return {"}
{"input":"<s> async function textViewerCommandExecutor(textViewer, commandId, commandArguments) {<EOL>    const selectedTabSize = await textViewer.getTab().showNumberInput({<EOL>        title: \"<STR_LIT>\",<EOL>        value:","gt":"textViewer.getTabSize(),"}
{"input":"<s> function getConfig() {<EOL>    return","gt":"config;"}
{"input":"<s> function pathToUrl(path) {<EOL>    if (process.platform === \"<STR_LIT>\") {<EOL>","gt":"return path.replace(/\\\\/g, \"<STR_LIT>\");"}
{"input":"<s> function readDefaultUserShell(userName) {<EOL>    if (process.platform === \"<STR_LIT>\") {<EOL>        return readDefaultUserShellFromOpenDirectory(","gt":"userName);"}
{"input":"<s> <EOL>function replaceInSelection(cm, searchExp, replacement) {<EOL>    const selectionsText = cm.getDoc().getSelections();<EOL>","gt":"const replacements = selectionsText.map((str) => {"}
{"input":"<s> function readEmulatorScreenString(emulator) {<EOL>    let result = lineToString(emulator.lineAtRow(<NUM_LIT>));<EOL>    let row = <NUM_LIT>;<EOL>    while (true) {<EOL>        const line = emulator.","gt":"lineAtRow(row);"}
{"input":"<s> function readEmulatorScreenString(emulator) {<EOL>    let result = lineToString(emulator.lineAtRow(<NUM_LIT>));<EOL>    let row = <NUM_LIT>;<EOL>    while (true) {<EOL>        const line = emulator. lineAtRow(row);<EOL>        if (line == null) {<EOL>            break;<EOL>        }<EOL>        result += '<STR_LIT>' + lineToString(line);<EOL>","gt":"row++;"}
{"input":"<s> <EOL>export function to2DigitHex(value) {<EOL>    const h =","gt":"value.toString(<NUM_LIT>);"}
{"input":"<s> function handleCommandPaletteRequest(ev) {<EOL>    const path = ev.composedPath();<EOL>    const requestCommandableStack = path.filter((el) => isCommandable(el));<EOL>    doLater(() => {<EOL>        const commandableStack =","gt":"[...requestCommandableStack, { executeCommand, getCommandPaletteEntries }];"}
{"input":"<s> function handleCommandPaletteRequest(ev) {<EOL>    const path = ev.composedPath();<EOL>    const requestCommandableStack = path.filter((el) => isCommandable(el));<EOL>    doLater(() => {<EOL>        const commandableStack =  [...requestCommandableStack, { executeCommand, getCommandPaletteEntries }];<EOL>        const firstCommandable =","gt":"commandableStack[<NUM_LIT>];"}
{"input":"<s> function handleCommandPaletteRequest(ev) {<EOL>    const path = ev.composedPath();<EOL>    const requestCommandableStack = path.filter((el) => isCommandable(el));<EOL>    doLater(() => {<EOL>        const commandableStack =  [...requestCommandableStack, { executeCommand, getCommandPaletteEntries }];<EOL>        const firstCommandable =  commandableStack[<NUM_LIT>];<EOL>        if (firstCommandable instanceof HTMLElement) {<EOL>            commandPaletteRequestSource = firstCommandable;<EOL>        }<EOL>        commandPaletteRequestEntries = _.flatten(commandableStack.map((commandable) => {<EOL>            let result = commandable.getCommandPaletteEntries(commandableStack);<EOL>            if (commandable instanceof EtTerminal) {<EOL>                result = [...result, ...extensionManager.getExtensionBridge().getWorkspaceTerminalCommands(commandable)];<EOL>            }<EOL>            else if (commandable instanceof TextViewer) {<EOL>                result = [...result, ...extensionManager.getExtensionBridge().getWorkspaceTextViewerCommands(commandable)];<EOL>            }<EOL>","gt":"return result;"}
{"input":"<s> function handleCommandPaletteRequest(ev) {<EOL>    const path = ev.composedPath();<EOL>    const requestCommandableStack = path.filter((el) => isCommandable(el));<EOL>    doLater(() => {<EOL>        const commandableStack =  [...requestCommandableStack, { executeCommand, getCommandPaletteEntries }];<EOL>        const firstCommandable =  commandableStack[<NUM_LIT>];<EOL>        if (firstCommandable instanceof HTMLElement) {<EOL>            commandPaletteRequestSource = firstCommandable;<EOL>        }<EOL>        commandPaletteRequestEntries = _.flatten(commandableStack.map((commandable) => {<EOL>            let result = commandable.getCommandPaletteEntries(commandableStack);<EOL>            if (commandable instanceof EtTerminal) {<EOL>                result = [...result, ...extensionManager.getExtensionBridge().getWorkspaceTerminalCommands(commandable)];<EOL>            }<EOL>            else if (commandable instanceof TextViewer) {<EOL>                result = [...result, ...extensionManager.getExtensionBridge().getWorkspaceTextViewerCommands(commandable)];<EOL>            }<EOL>             return result;<EOL>        }));<EOL>        const paletteEntries = commandPaletteRequestEntries.map((entry, index) => {<EOL>            return {<EOL>                id: \"<STR_LIT>\" +","gt":"index,"}
{"input":"<s> function handleCommandPaletteRequest(ev) {<EOL>    const path = ev.composedPath();<EOL>    const requestCommandableStack = path.filter((el) => isCommandable(el));<EOL>    doLater(() => {<EOL>        const commandableStack =  [...requestCommandableStack, { executeCommand, getCommandPaletteEntries }];<EOL>        const firstCommandable =  commandableStack[<NUM_LIT>];<EOL>        if (firstCommandable instanceof HTMLElement) {<EOL>            commandPaletteRequestSource = firstCommandable;<EOL>        }<EOL>        commandPaletteRequestEntries = _.flatten(commandableStack.map((commandable) => {<EOL>            let result = commandable.getCommandPaletteEntries(commandableStack);<EOL>            if (commandable instanceof EtTerminal) {<EOL>                result = [...result, ...extensionManager.getExtensionBridge().getWorkspaceTerminalCommands(commandable)];<EOL>            }<EOL>            else if (commandable instanceof TextViewer) {<EOL>                result = [...result, ...extensionManager.getExtensionBridge().getWorkspaceTextViewerCommands(commandable)];<EOL>            }<EOL>             return result;<EOL>        }));<EOL>        const paletteEntries = commandPaletteRequestEntries.map((entry, index) => {<EOL>            return {<EOL>                id: \"<STR_LIT>\" +  index,<EOL>                group: entry.group,<EOL>                iconLeft: entry.iconLeft,<EOL>                iconRight: entry.iconRight,<EOL>                label: entry.label,<EOL>                shortcut: entry.shortcut<EOL>            };<EOL>        });<EOL>        const shortcut = keyBindingManager.getKeyBindingContexts().context(\"<STR_LIT>\").mapCommandToKeyBinding(\"<STR_LIT>\");<EOL>        commandPalette.titleSecondary = shortcut !== null ? shortcut : \"<STR_LIT>\";<EOL>","gt":"commandPalette.setEntries(paletteEntries);"}
{"input":"<s> function handleCommandPaletteRequest(ev) {<EOL>    const path = ev.composedPath();<EOL>    const requestCommandableStack = path.filter((el) => isCommandable(el));<EOL>    doLater(() => {<EOL>        const commandableStack =  [...requestCommandableStack, { executeCommand, getCommandPaletteEntries }];<EOL>        const firstCommandable =  commandableStack[<NUM_LIT>];<EOL>        if (firstCommandable instanceof HTMLElement) {<EOL>            commandPaletteRequestSource = firstCommandable;<EOL>        }<EOL>        commandPaletteRequestEntries = _.flatten(commandableStack.map((commandable) => {<EOL>            let result = commandable.getCommandPaletteEntries(commandableStack);<EOL>            if (commandable instanceof EtTerminal) {<EOL>                result = [...result, ...extensionManager.getExtensionBridge().getWorkspaceTerminalCommands(commandable)];<EOL>            }<EOL>            else if (commandable instanceof TextViewer) {<EOL>                result = [...result, ...extensionManager.getExtensionBridge().getWorkspaceTextViewerCommands(commandable)];<EOL>            }<EOL>             return result;<EOL>        }));<EOL>        const paletteEntries = commandPaletteRequestEntries.map((entry, index) => {<EOL>            return {<EOL>                id: \"<STR_LIT>\" +  index,<EOL>                group: entry.group,<EOL>                iconLeft: entry.iconLeft,<EOL>                iconRight: entry.iconRight,<EOL>                label: entry.label,<EOL>                shortcut: entry.shortcut<EOL>            };<EOL>        });<EOL>        const shortcut = keyBindingManager.getKeyBindingContexts().context(\"<STR_LIT>\").mapCommandToKeyBinding(\"<STR_LIT>\");<EOL>        commandPalette.titleSecondary = shortcut !== null ? shortcut : \"<STR_LIT>\";<EOL>         commandPalette.setEntries(paletteEntries);<EOL>        const contextElement = requestCommandableStack[requestCommandableStack.length - <NUM_LIT>];<EOL>        if (SupportsDialogStack.isSupportsDialogStack(contextElement)) {<EOL>            commandPaletteDisposable =","gt":"contextElement.showDialog(commandPalette);"}
{"input":"<s> function handleDevToolsStatus(msg) {<EOL>    const devToolsStatusMessage = msg;<EOL>    const developerToolMenu = document.getElementById(","gt":"\"<STR_LIT>\");"}
{"input":"<s> function elementSupportsFocus(content) {<EOL>    return content instanceof EtTerminal || content instanceof EmptyPaneMenu || content instanceof","gt":"EtViewerTab;"}
{"input":"<s> function findPathToTabWidget(infoNode, tabWidget) {<EOL>    if (infoNode.type === \"<STR_LIT>\") {<EOL>        for (const kid of infoNode.children) {<EOL>            const path = findPathToTabWidget(kid, tabWidget);<EOL>            if (path != null) {<EOL>                return [","gt":"infoNode, ...path];"}
{"input":"<s> function findPathToTabWidget(infoNode, tabWidget) {<EOL>    if (infoNode.type === \"<STR_LIT>\") {<EOL>        for (const kid of infoNode.children) {<EOL>            const path = findPathToTabWidget(kid, tabWidget);<EOL>            if (path != null) {<EOL>                return [ infoNode, ...path];<EOL>            }<EOL>        }<EOL>        return null;<EOL>    }<EOL>    else {<EOL>        if (infoNode.tabWidget === tabWidget) {<EOL>            return [","gt":"infoNode];"}
{"input":"<s> function getCssText() {<EOL>    return","gt":"cssText;"}
{"input":"<s> function px(value) {<EOL>    if (value === null || value === undefined || value === \"<STR_LIT>\") {<EOL>","gt":"return <NUM_LIT>;"}
{"input":"<s> export function test3Scrollables(test) {<EOL>    const vsa = new VirtualScrollArea.VirtualScrollArea();<EOL>    const scrollbar = SetupScrollbar(vsa);<EOL>    const","gt":"container = SetUpScrollContainer(vsa, <NUM_LIT>);"}
{"input":"<s> export function test3Scrollables(test) {<EOL>    const vsa = new VirtualScrollArea.VirtualScrollArea();<EOL>    const scrollbar = SetupScrollbar(vsa);<EOL>    const  container = SetUpScrollContainer(vsa, <NUM_LIT>);<EOL>    const scrollable1 = SetupScrollable(vsa, <NUM_LIT>, <NUM_LIT>, <NUM_LIT>);<EOL>    const scrollable2 = SetupScrollable(","gt":"vsa, <NUM_LIT>, <NUM_LIT>, <NUM_LIT>);"}
{"input":"<s> export function test3Scrollables(test) {<EOL>    const vsa = new VirtualScrollArea.VirtualScrollArea();<EOL>    const scrollbar = SetupScrollbar(vsa);<EOL>    const  container = SetUpScrollContainer(vsa, <NUM_LIT>);<EOL>    const scrollable1 = SetupScrollable(vsa, <NUM_LIT>, <NUM_LIT>, <NUM_LIT>);<EOL>    const scrollable2 = SetupScrollable( vsa, <NUM_LIT>, <NUM_LIT>, <NUM_LIT>);<EOL>    const scrollable3 = SetupScrollable(vsa, <NUM_LIT>, <NUM_LIT>, <NUM_LIT>);<EOL>    vsa.updateContainerHeight(","gt":"container.getBoundingClientRect().height);"}
{"input":"<s> export function test3Scrollables(test) {<EOL>    const vsa = new VirtualScrollArea.VirtualScrollArea();<EOL>    const scrollbar = SetupScrollbar(vsa);<EOL>    const  container = SetUpScrollContainer(vsa, <NUM_LIT>);<EOL>    const scrollable1 = SetupScrollable(vsa, <NUM_LIT>, <NUM_LIT>, <NUM_LIT>);<EOL>    const scrollable2 = SetupScrollable( vsa, <NUM_LIT>, <NUM_LIT>, <NUM_LIT>);<EOL>    const scrollable3 = SetupScrollable(vsa, <NUM_LIT>, <NUM_LIT>, <NUM_LIT>);<EOL>    vsa.updateContainerHeight( container.getBoundingClientRect().height);<EOL>    test.equal(scrollbar.getPosition(), <NUM_LIT>);<EOL>    test.equal(scrollbar.getLength(), <NUM_LIT>);<EOL>    test.equal(scrollable1.getScrollOffset(), <NUM_LIT>);<EOL>","gt":"vsa.scrollTo(<NUM_LIT>);"}
{"input":"<s> export function test3Scrollables(test) {<EOL>    const vsa = new VirtualScrollArea.VirtualScrollArea();<EOL>    const scrollbar = SetupScrollbar(vsa);<EOL>    const  container = SetUpScrollContainer(vsa, <NUM_LIT>);<EOL>    const scrollable1 = SetupScrollable(vsa, <NUM_LIT>, <NUM_LIT>, <NUM_LIT>);<EOL>    const scrollable2 = SetupScrollable( vsa, <NUM_LIT>, <NUM_LIT>, <NUM_LIT>);<EOL>    const scrollable3 = SetupScrollable(vsa, <NUM_LIT>, <NUM_LIT>, <NUM_LIT>);<EOL>    vsa.updateContainerHeight( container.getBoundingClientRect().height);<EOL>    test.equal(scrollbar.getPosition(), <NUM_LIT>);<EOL>    test.equal(scrollbar.getLength(), <NUM_LIT>);<EOL>    test.equal(scrollable1.getScrollOffset(), <NUM_LIT>);<EOL>     vsa.scrollTo(<NUM_LIT>);<EOL>    test.equal(scrollbar.getPosition(), <NUM_LIT>);<EOL>    test.equal(container.scrollTop, <NUM_LIT>);<EOL>    test.equal(scrollable1.getScrollOffset(), <NUM_LIT>);<EOL>    test.equal(","gt":"scrollable2.getScrollOffset(), <NUM_LIT>);"}
{"input":"<s> export function test3Scrollables(test) {<EOL>    const vsa = new VirtualScrollArea.VirtualScrollArea();<EOL>    const scrollbar = SetupScrollbar(vsa);<EOL>    const  container = SetUpScrollContainer(vsa, <NUM_LIT>);<EOL>    const scrollable1 = SetupScrollable(vsa, <NUM_LIT>, <NUM_LIT>, <NUM_LIT>);<EOL>    const scrollable2 = SetupScrollable( vsa, <NUM_LIT>, <NUM_LIT>, <NUM_LIT>);<EOL>    const scrollable3 = SetupScrollable(vsa, <NUM_LIT>, <NUM_LIT>, <NUM_LIT>);<EOL>    vsa.updateContainerHeight( container.getBoundingClientRect().height);<EOL>    test.equal(scrollbar.getPosition(), <NUM_LIT>);<EOL>    test.equal(scrollbar.getLength(), <NUM_LIT>);<EOL>    test.equal(scrollable1.getScrollOffset(), <NUM_LIT>);<EOL>     vsa.scrollTo(<NUM_LIT>);<EOL>    test.equal(scrollbar.getPosition(), <NUM_LIT>);<EOL>    test.equal(container.scrollTop, <NUM_LIT>);<EOL>    test.equal(scrollable1.getScrollOffset(), <NUM_LIT>);<EOL>    test.equal( scrollable2.getScrollOffset(), <NUM_LIT>);<EOL>    test.equal(scrollable3.getScrollOffset(), <NUM_LIT>);<EOL>    vsa.scrollTo(<NUM_LIT>);<EOL>    test.equal(scrollbar.getPosition(), <NUM_LIT>);<EOL>    test.equal(container.","gt":"scrollTop, <NUM_LIT>);"}
{"input":"<s> export function test3Scrollables(test) {<EOL>    const vsa = new VirtualScrollArea.VirtualScrollArea();<EOL>    const scrollbar = SetupScrollbar(vsa);<EOL>    const  container = SetUpScrollContainer(vsa, <NUM_LIT>);<EOL>    const scrollable1 = SetupScrollable(vsa, <NUM_LIT>, <NUM_LIT>, <NUM_LIT>);<EOL>    const scrollable2 = SetupScrollable( vsa, <NUM_LIT>, <NUM_LIT>, <NUM_LIT>);<EOL>    const scrollable3 = SetupScrollable(vsa, <NUM_LIT>, <NUM_LIT>, <NUM_LIT>);<EOL>    vsa.updateContainerHeight( container.getBoundingClientRect().height);<EOL>    test.equal(scrollbar.getPosition(), <NUM_LIT>);<EOL>    test.equal(scrollbar.getLength(), <NUM_LIT>);<EOL>    test.equal(scrollable1.getScrollOffset(), <NUM_LIT>);<EOL>     vsa.scrollTo(<NUM_LIT>);<EOL>    test.equal(scrollbar.getPosition(), <NUM_LIT>);<EOL>    test.equal(container.scrollTop, <NUM_LIT>);<EOL>    test.equal(scrollable1.getScrollOffset(), <NUM_LIT>);<EOL>    test.equal( scrollable2.getScrollOffset(), <NUM_LIT>);<EOL>    test.equal(scrollable3.getScrollOffset(), <NUM_LIT>);<EOL>    vsa.scrollTo(<NUM_LIT>);<EOL>    test.equal(scrollbar.getPosition(), <NUM_LIT>);<EOL>    test.equal(container. scrollTop, <NUM_LIT>);<EOL>    test.equal(scrollable1.getScrollOffset(), <NUM_LIT>);<EOL>    test.equal(scrollable2.getScrollOffset(), <NUM_LIT>);<EOL>    test.equal(scrollable3.getScrollOffset(), <NUM_LIT>);<EOL>    vsa.scrollTo(<NUM_LIT>);<EOL>    test.equal(scrollbar.getPosition(), <NUM_LIT>);<EOL>    test.equal(container.scrollTop, <NUM_LIT>);<EOL>    test.equal(scrollable1.getScrollOffset(), <NUM_LIT>);<EOL>    test.equal(","gt":"scrollable2.getScrollOffset(), <NUM_LIT>);"}
{"input":"<s> export function createBulkFileSync(metadata, size) {<EOL>    const msg = { type: Messages.MessageType.BULK_FILE_CREATE, metadata, size };<EOL>    const event =","gt":"ipc.sendSync(Messages.CHANNEL_NAME, msg);"}
{"input":"<s> <EOL><EOL>export function toUrl(resourceName) {<EOL>    let","gt":"mainPath = __dirname;"}
{"input":"<s> export function mergeHeaders(target, source) {<EOL>    if (typeof source !== \"<STR_LIT>\" && source !== null) {<EOL>","gt":"const temp = new Request(\"<STR_LIT>\", { headers: source });"}
{"input":"<s> <EOL>export function pipe(context) {<EOL>    return next(context)<EOL>        .then((ctx) => returnResult(ctx))<EOL>        .catch((e) => {<EOL>        Logger.","gt":"log({"}
{"input":"<s> function isCaptureQualifier(qualifier) {<EOL>    return qualifier.type ===","gt":"'<STR_LIT>'"}
{"input":"<s> <EOL>function reportDiagnostics(diagnostics, baseDir) {<EOL>    if (diagnostics && diagnostics.length && diagnostics[<NUM_LIT>]) {<EOL>        console.error(formatDiagnostics(diagnostics,","gt":"baseDir));"}
{"input":"<s> <EOL>export function setAssignMethod(obj, propertyName, writeOnce = false) {<EOL>    validateMethodName.call(obj, propertyName);<EOL>    const key = privateKey(propertyName);<EOL>    objectDefinePropertyValue(","gt":"obj, propertyName, (value) => {"}
{"input":"<s> function setVCRef(key, vcRef) {<EOL>    if (!vcRefCollection.hasOwnProperty(key)) {<EOL>","gt":"vcRefCollection[key] = [];"}
{"input":"<s> export function getClosestToken(color, type, layerType) {<EOL>    let lowestDistance = Number.POSITIVE_INFINITY;<EOL>    let currentDistance;<EOL>    let closestToken;<EOL>    const cacheKey =","gt":"`<STR_LIT>`;"}
{"input":"<s> export function getClosestToken(color, type, layerType) {<EOL>    let lowestDistance = Number.POSITIVE_INFINITY;<EOL>    let currentDistance;<EOL>    let closestToken;<EOL>    const cacheKey =  `<STR_LIT>`;<EOL>    const cachedToken = closestTokenCache[cacheKey];<EOL>    if (cachedToken) {<EOL>","gt":"return cachedToken;"}
{"input":"<s> export function getClosestToken(color, type, layerType) {<EOL>    let lowestDistance = Number.POSITIVE_INFINITY;<EOL>    let currentDistance;<EOL>    let closestToken;<EOL>    const cacheKey =  `<STR_LIT>`;<EOL>    const cachedToken = closestTokenCache[cacheKey];<EOL>    if (cachedToken) {<EOL>         return cachedToken;<EOL>    }<EOL>    const relevantTokens = getRelevantTokens(type, layerType);<EOL>    relevantTokens.forEach((token) => {<EOL>        currentDistance =","gt":"rgbaDistance(color, token.value);"}
{"input":"<s> export function alphaForDraggerY(y, sliderHeight) {<EOL>    const offsetY =","gt":"clamp(y, <NUM_LIT>, sliderHeight);"}
{"input":"<s> export function alphaForOffset(offset, sliderHeight) {<EOL>    const selectionHeight =","gt":"offset - VERTICAL_PADDING;"}
{"input":"<s> <EOL>export function getStaticCustomProperties(tokens) {<EOL>    return Object.entries(tokens)<EOL>        .filter(([tokenGroup]) =>","gt":"tokenGroup !== '<STR_LIT>')"}
{"input":"<s> <EOL><EOL>export function ScrollLock(_) {<EOL>    const scrollLockManager = useScrollLockManager();<EOL>    useEffect(() => {<EOL>","gt":"scrollLockManager.registerScrollLock();"}
{"input":"<s> export function closestParentMatch(element, matcher) {<EOL>    let parent = element.parentElement;<EOL>    while (parent) {<EOL>        if (","gt":"parent.matches(matcher))"}
{"input":"<s> export function dateIsSelected(day, range) {<EOL>    if (day == null) {<EOL>        return","gt":"false;"}
{"input":"<s> export function findFirstFocusableNode(element, onlyDescendants = true) {<EOL>    if (!onlyDescendants && matches(element, FOCUSABLE_SELECTOR)) {<EOL>        return","gt":"element;"}
{"input":"<s> export function useContainerScroll() {<EOL>    const scrolledContainerRef =","gt":"useContext(ScrollContext);"}
{"input":"<s> function horizontallyOverlaps(rect1, rect2) {<EOL>    const rect1Left = rect1.left;<EOL>    const rect1Right = rect1.left +","gt":"rect1.width;"}
{"input":"<s> function createDiv() {<EOL>    return","gt":"document.createElement('<STR_LIT>');"}
{"input":"<s> <EOL>export function getKeyframeNames(motionTokenGroup) {<EOL>    return Object.","gt":"keys(motionTokenGroup)"}
{"input":"<s> <EOL>export function qat(something) {<EOL>    return","gt":"something;"}
{"input":"<s> function getRootLength(path) {<EOL>    if (path.charCodeAt(<NUM_LIT>) === CharacterCodes.slash) {<EOL>        if (path.charCodeAt(<NUM_LIT>) !== CharacterCodes.slash)<EOL>            return <NUM_LIT>;<EOL>        const p1 = path.indexOf('<STR_LIT>', <NUM_LIT>);<EOL>        if (p1 < <NUM_LIT>)<EOL>","gt":"return <NUM_LIT>;"}
{"input":"<s> function getRootLength(path) {<EOL>    if (path.charCodeAt(<NUM_LIT>) === CharacterCodes.slash) {<EOL>        if (path.charCodeAt(<NUM_LIT>) !== CharacterCodes.slash)<EOL>            return <NUM_LIT>;<EOL>        const p1 = path.indexOf('<STR_LIT>', <NUM_LIT>);<EOL>        if (p1 < <NUM_LIT>)<EOL>             return <NUM_LIT>;<EOL>        const p2 = path.indexOf('<STR_LIT>', p1 + <NUM_LIT>);<EOL>        if (p2 < <NUM_LIT>)<EOL>","gt":"return p1 + <NUM_LIT>;"}
{"input":"<s> function getRootLength(path) {<EOL>    if (path.charCodeAt(<NUM_LIT>) === CharacterCodes.slash) {<EOL>        if (path.charCodeAt(<NUM_LIT>) !== CharacterCodes.slash)<EOL>            return <NUM_LIT>;<EOL>        const p1 = path.indexOf('<STR_LIT>', <NUM_LIT>);<EOL>        if (p1 < <NUM_LIT>)<EOL>             return <NUM_LIT>;<EOL>        const p2 = path.indexOf('<STR_LIT>', p1 + <NUM_LIT>);<EOL>        if (p2 < <NUM_LIT>)<EOL>             return p1 + <NUM_LIT>;<EOL>        return p2 + <NUM_LIT>;<EOL>    }<EOL>    if (path.","gt":"charCodeAt(<NUM_LIT>) === CharacterCodes.colon) {"}
{"input":"<s> function getRootLength(path) {<EOL>    if (path.charCodeAt(<NUM_LIT>) === CharacterCodes.slash) {<EOL>        if (path.charCodeAt(<NUM_LIT>) !== CharacterCodes.slash)<EOL>            return <NUM_LIT>;<EOL>        const p1 = path.indexOf('<STR_LIT>', <NUM_LIT>);<EOL>        if (p1 < <NUM_LIT>)<EOL>             return <NUM_LIT>;<EOL>        const p2 = path.indexOf('<STR_LIT>', p1 + <NUM_LIT>);<EOL>        if (p2 < <NUM_LIT>)<EOL>             return p1 + <NUM_LIT>;<EOL>        return p2 + <NUM_LIT>;<EOL>    }<EOL>    if (path. charCodeAt(<NUM_LIT>) === CharacterCodes.colon) {<EOL>        if (path.charCodeAt(<NUM_LIT>) === CharacterCodes.slash)<EOL>            return <NUM_LIT>;<EOL>        return <NUM_LIT>;<EOL>    }<EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    if (path.lastIndexOf(","gt":"'<STR_LIT>', <NUM_LIT>) === <NUM_LIT>) {"}
{"input":"<s> <EOL>export function isSymbolDescriptorMatch(query, symbol) {<EOL>    for (const key of Object.keys(query)) {<EOL>        if (!query[key]) {<EOL>            continue;<EOL>        }<EOL>","gt":"if (key === '<STR_LIT>') {"}
{"input":"<s> <EOL>export function isSymbolDescriptorMatch(query, symbol) {<EOL>    for (const key of Object.keys(query)) {<EOL>        if (!query[key]) {<EOL>            continue;<EOL>        }<EOL>         if (key === '<STR_LIT>') {<EOL>            if (!symbol.package || !isPackageDescriptorMatch(query.package, symbol.package)) {<EOL>                return false;<EOL>            }<EOL>","gt":"continue;"}
{"input":"<s> <EOL>export function isSymbolDescriptorMatch(query, symbol) {<EOL>    for (const key of Object.keys(query)) {<EOL>        if (!query[key]) {<EOL>            continue;<EOL>        }<EOL>         if (key === '<STR_LIT>') {<EOL>            if (!symbol.package || !isPackageDescriptorMatch(query.package, symbol.package)) {<EOL>                return false;<EOL>            }<EOL>             continue;<EOL>        }<EOL>        if (query[key] !== symbol[key]) {<EOL>            return","gt":"false;"}
{"input":"<s> <EOL>export function fadeOut(el, dur, complete) {<EOL>    fade(el, <NUM_LIT>, <NUM_LIT>,","gt":"dur, complete);"}
{"input":"<s> <EOL>function initBladeShapeVerts(shape, numBlades, offset) {<EOL>    let noise = <NUM_LIT>;<EOL>    for (let i = <NUM_LIT>; i < numBlades; ++i) {<EOL>        noise = Math.abs(simplex(offset[i * <NUM_LIT> + <NUM_LIT>] * <NUM_LIT>, offset[i * <NUM_LIT> + <NUM_LIT>] * <NUM_LIT>));<EOL>        noise =","gt":"noise * noise * noise;"}
{"input":"<s> <EOL>function initBladeShapeVerts(shape, numBlades, offset) {<EOL>    let noise = <NUM_LIT>;<EOL>    for (let i = <NUM_LIT>; i < numBlades; ++i) {<EOL>        noise = Math.abs(simplex(offset[i * <NUM_LIT> + <NUM_LIT>] * <NUM_LIT>, offset[i * <NUM_LIT> + <NUM_LIT>] * <NUM_LIT>));<EOL>        noise =  noise * noise * noise;<EOL>        noise *= <NUM_LIT>;<EOL>        shape[i * <NUM_LIT> + <NUM_LIT>] = BLADE_WIDTH + Math.random() * BLADE_WIDTH * <NUM_LIT>; <EOL>        shape[i * <NUM_LIT> + <NUM_LIT>] = BLADE_HEIGHT_MIN + Math.pow(Math.random(), <NUM_LIT>) * (BLADE_HEIGHT_MAX - BLADE_HEIGHT_MIN) + <EOL>            noise;<EOL>        shape[i * <NUM_LIT> + <NUM_LIT>] = <NUM_LIT> + Math.random() *","gt":"<NUM_LIT>;"}
{"input":"<s> export function getKeyState(code) {<EOL>    return","gt":"keyStates[code];"}
{"input":"<s> export function update(t, x, y) {<EOL>    const ix = Math.floor(x / t.cellSize);<EOL>    const iy = Math.floor(y / t.cellSize);<EOL>    const ox = ix * t.cellSize;<EOL>    const oy = iy *","gt":"t.cellSize;"}
{"input":"<s> export function update(t, x, y) {<EOL>    const ix = Math.floor(x / t.cellSize);<EOL>    const iy = Math.floor(y / t.cellSize);<EOL>    const ox = ix * t.cellSize;<EOL>    const oy = iy *  t.cellSize;<EOL>    const mat = t.mesh.material;<EOL>    let p = mat.uniforms['<STR_LIT>'].value;<EOL>    p[<NUM_LIT>] = ox;<EOL>    p[<NUM_LIT>] = oy;<EOL>    p = mat.","gt":"uniforms['<STR_LIT>'].value;"}
{"input":"<s> <EOL><EOL>export function $e(id) {<EOL>    return","gt":"document.getElementById(id);"}
{"input":"<s> export function isPureMode() {<EOL>    return storage.","gt":"getItem(PUREMODE, '<STR_LIT>') === '<STR_LIT>';"}
{"input":"<s> export function setPureMode(val) {<EOL>","gt":"storage.setItem(PUREMODE, val ? '<STR_LIT>' : '<STR_LIT>');"}
{"input":"<s> export function sendMessage(type, data) {<EOL>    return new Promise((res, rej) => {<EOL>        let curId = ++lastCbId;<EOL>        let timeoutId = window.setTimeout(() => {<EOL>            delete msgCallbacks[curId];<EOL>            rej(new Error('<STR_LIT>'));<EOL>        },","gt":"<NUM_LIT>);"}
{"input":"<s> export function sendMessage(type, data) {<EOL>    return new Promise((res, rej) => {<EOL>        let curId = ++lastCbId;<EOL>        let timeoutId = window.setTimeout(() => {<EOL>            delete msgCallbacks[curId];<EOL>            rej(new Error('<STR_LIT>'));<EOL>        },  <NUM_LIT>);<EOL>        msgCallbacks[curId] = (result) => {<EOL>            delete msgCallbacks[curId];<EOL>            window.clearTimeout(timeoutId);<EOL>","gt":"res(result);"}
{"input":"<s> export function sendMessage(type, data) {<EOL>    return new Promise((res, rej) => {<EOL>        let curId = ++lastCbId;<EOL>        let timeoutId = window.setTimeout(() => {<EOL>            delete msgCallbacks[curId];<EOL>            rej(new Error('<STR_LIT>'));<EOL>        },  <NUM_LIT>);<EOL>        msgCallbacks[curId] = (result) => {<EOL>            delete msgCallbacks[curId];<EOL>            window.clearTimeout(timeoutId);<EOL>             res(result);<EOL>        };<EOL>        window.postMessage({<EOL>            type:","gt":"type,"}
{"input":"<s> <EOL>function nls() {<EOL>    var input = through();<EOL>    var output = input.pipe(through(function (f) {<EOL>        if (!f.sourceMap) {<EOL>","gt":"return this.emit('<STR_LIT>', new Error(`<STR_LIT>`));"}
{"input":"<s> <EOL>function nls() {<EOL>    var input = through();<EOL>    var output = input.pipe(through(function (f) {<EOL>        if (!f.sourceMap) {<EOL>             return this.emit('<STR_LIT>', new Error(`<STR_LIT>`));<EOL>        }<EOL>        let source = f.sourceMap.sources[<NUM_LIT>];<EOL>","gt":"if (!source) {"}
{"input":"<s> <EOL>function nls() {<EOL>    var input = through();<EOL>    var output = input.pipe(through(function (f) {<EOL>        if (!f.sourceMap) {<EOL>             return this.emit('<STR_LIT>', new Error(`<STR_LIT>`));<EOL>        }<EOL>        let source = f.sourceMap.sources[<NUM_LIT>];<EOL>         if (!source) {<EOL>            return this.emit('<STR_LIT>', new Error(`<STR_LIT>`));<EOL>        }<EOL>        const root = f.sourceMap.sourceRoot;<EOL>        if (","gt":"root) {"}
{"input":"<s> <EOL>function nls() {<EOL>    var input = through();<EOL>    var output = input.pipe(through(function (f) {<EOL>        if (!f.sourceMap) {<EOL>             return this.emit('<STR_LIT>', new Error(`<STR_LIT>`));<EOL>        }<EOL>        let source = f.sourceMap.sources[<NUM_LIT>];<EOL>         if (!source) {<EOL>            return this.emit('<STR_LIT>', new Error(`<STR_LIT>`));<EOL>        }<EOL>        const root = f.sourceMap.sourceRoot;<EOL>        if ( root) {<EOL>            source = path.join(root, source);<EOL>        }<EOL>        const typescript = f.sourceMap.sourcesContent[<NUM_LIT>];<EOL>        if (!typescript) {<EOL>            return this.emit('<STR_LIT>', new Error(","gt":"relative} does not have the original content in the source map.`<STR_LIT>;"}
{"input":"<s> function isPropertyAssignment(node) {<EOL>    return node &&","gt":"node.kind === ts.SyntaxKind.PropertyAssignment;"}
{"input":"<s> export function activateColorDecorations(decoratorProvider, supportedLanguages) {<EOL>    let disposables = [];<EOL>    let colorsDecorationType = window.createTextEditorDecorationType(decorationType);<EOL>","gt":"disposables.push(colorsDecorationType);"}
{"input":"<s> export function activateColorDecorations(decoratorProvider, supportedLanguages) {<EOL>    let disposables = [];<EOL>    let colorsDecorationType = window.createTextEditorDecorationType(decorationType);<EOL>     disposables.push(colorsDecorationType);<EOL>    let pendingUpdateRequests = {};<EOL>    <EOL>    window.visibleTextEditors.forEach((editor) => {<EOL>","gt":"if (editor.document) {"}
{"input":"<s> export function activateColorDecorations(decoratorProvider, supportedLanguages) {<EOL>    let disposables = [];<EOL>    let colorsDecorationType = window.createTextEditorDecorationType(decorationType);<EOL>     disposables.push(colorsDecorationType);<EOL>    let pendingUpdateRequests = {};<EOL>    <EOL>    window.visibleTextEditors.forEach((editor) => {<EOL>         if (editor.document) {<EOL>            triggerUpdateDecorations(editor.document);<EOL>        }<EOL>    });<EOL>    <EOL>    window.onDidChangeActiveTextEditor((","gt":"editor) => {"}
{"input":"<s> export function activateColorDecorations(decoratorProvider, supportedLanguages) {<EOL>    let disposables = [];<EOL>    let colorsDecorationType = window.createTextEditorDecorationType(decorationType);<EOL>     disposables.push(colorsDecorationType);<EOL>    let pendingUpdateRequests = {};<EOL>    <EOL>    window.visibleTextEditors.forEach((editor) => {<EOL>         if (editor.document) {<EOL>            triggerUpdateDecorations(editor.document);<EOL>        }<EOL>    });<EOL>    <EOL>    window.onDidChangeActiveTextEditor(( editor) => {<EOL>        if (editor) {<EOL>            triggerUpdateDecorations(editor.document);<EOL>        }<EOL>    }, null, disposables);<EOL>    workspace.onDidChangeTextDocument((event) => triggerUpdateDecorations(event.document), null, disposables);<EOL>    workspace.onDidOpenTextDocument(triggerUpdateDecorations, null, disposables);<EOL>    workspace.","gt":"onDidCloseTextDocument(triggerUpdateDecorations, null, disposables);"}
{"input":"<s> export function activateColorDecorations(decoratorProvider, supportedLanguages) {<EOL>    let disposables = [];<EOL>    let colorsDecorationType = window.createTextEditorDecorationType(decorationType);<EOL>     disposables.push(colorsDecorationType);<EOL>    let pendingUpdateRequests = {};<EOL>    <EOL>    window.visibleTextEditors.forEach((editor) => {<EOL>         if (editor.document) {<EOL>            triggerUpdateDecorations(editor.document);<EOL>        }<EOL>    });<EOL>    <EOL>    window.onDidChangeActiveTextEditor(( editor) => {<EOL>        if (editor) {<EOL>            triggerUpdateDecorations(editor.document);<EOL>        }<EOL>    }, null, disposables);<EOL>    workspace.onDidChangeTextDocument((event) => triggerUpdateDecorations(event.document), null, disposables);<EOL>    workspace.onDidOpenTextDocument(triggerUpdateDecorations, null, disposables);<EOL>    workspace. onDidCloseTextDocument(triggerUpdateDecorations, null, disposables);<EOL>    function triggerUpdateDecorations(document) {<EOL>        let triggerUpdate = supportedLanguages[document.languageId];<EOL>        let uri = document.uri.toString();<EOL>        let timeout = pendingUpdateRequests[uri];<EOL>        if (typeof timeout !== '<STR_LIT>') {<EOL>            clearTimeout(timeout);<EOL>            triggerUpdate =","gt":"true;"}
{"input":"<s> export function activateColorDecorations(decoratorProvider, supportedLanguages) {<EOL>    let disposables = [];<EOL>    let colorsDecorationType = window.createTextEditorDecorationType(decorationType);<EOL>     disposables.push(colorsDecorationType);<EOL>    let pendingUpdateRequests = {};<EOL>    <EOL>    window.visibleTextEditors.forEach((editor) => {<EOL>         if (editor.document) {<EOL>            triggerUpdateDecorations(editor.document);<EOL>        }<EOL>    });<EOL>    <EOL>    window.onDidChangeActiveTextEditor(( editor) => {<EOL>        if (editor) {<EOL>            triggerUpdateDecorations(editor.document);<EOL>        }<EOL>    }, null, disposables);<EOL>    workspace.onDidChangeTextDocument((event) => triggerUpdateDecorations(event.document), null, disposables);<EOL>    workspace.onDidOpenTextDocument(triggerUpdateDecorations, null, disposables);<EOL>    workspace. onDidCloseTextDocument(triggerUpdateDecorations, null, disposables);<EOL>    function triggerUpdateDecorations(document) {<EOL>        let triggerUpdate = supportedLanguages[document.languageId];<EOL>        let uri = document.uri.toString();<EOL>        let timeout = pendingUpdateRequests[uri];<EOL>        if (typeof timeout !== '<STR_LIT>') {<EOL>            clearTimeout(timeout);<EOL>            triggerUpdate =  true; <EOL>        }<EOL>        if (triggerUpdate) {<EOL>            pendingUpdateRequests[uri] = setTimeout(() => {<EOL>                updateDecorations(uri);<EOL>                delete pendingUpdateRequests[uri];<EOL>            }, <NUM_LIT>);<EOL>        }<EOL>    }<EOL>    function updateDecorations(uri) {<EOL>        window.visibleTextEditors.forEach((editor) => {<EOL>            let document = editor.document;<EOL>            if (document && document.uri.","gt":"toString() === uri) {"}
{"input":"<s> export function activateColorDecorations(decoratorProvider, supportedLanguages) {<EOL>    let disposables = [];<EOL>    let colorsDecorationType = window.createTextEditorDecorationType(decorationType);<EOL>     disposables.push(colorsDecorationType);<EOL>    let pendingUpdateRequests = {};<EOL>    <EOL>    window.visibleTextEditors.forEach((editor) => {<EOL>         if (editor.document) {<EOL>            triggerUpdateDecorations(editor.document);<EOL>        }<EOL>    });<EOL>    <EOL>    window.onDidChangeActiveTextEditor(( editor) => {<EOL>        if (editor) {<EOL>            triggerUpdateDecorations(editor.document);<EOL>        }<EOL>    }, null, disposables);<EOL>    workspace.onDidChangeTextDocument((event) => triggerUpdateDecorations(event.document), null, disposables);<EOL>    workspace.onDidOpenTextDocument(triggerUpdateDecorations, null, disposables);<EOL>    workspace. onDidCloseTextDocument(triggerUpdateDecorations, null, disposables);<EOL>    function triggerUpdateDecorations(document) {<EOL>        let triggerUpdate = supportedLanguages[document.languageId];<EOL>        let uri = document.uri.toString();<EOL>        let timeout = pendingUpdateRequests[uri];<EOL>        if (typeof timeout !== '<STR_LIT>') {<EOL>            clearTimeout(timeout);<EOL>            triggerUpdate =  true; <EOL>        }<EOL>        if (triggerUpdate) {<EOL>            pendingUpdateRequests[uri] = setTimeout(() => {<EOL>                updateDecorations(uri);<EOL>                delete pendingUpdateRequests[uri];<EOL>            }, <NUM_LIT>);<EOL>        }<EOL>    }<EOL>    function updateDecorations(uri) {<EOL>        window.visibleTextEditors.forEach((editor) => {<EOL>            let document = editor.document;<EOL>            if (document && document.uri. toString() === uri) {<EOL>                updateDecorationForEditor(editor);<EOL>            }<EOL>        });<EOL>    }<EOL>    function updateDecorationForEditor(editor) {<EOL>        let document = editor.document;<EOL>        if (supportedLanguages[document.languageId]) {<EOL>            decoratorProvider(document.uri.toString()).then((ranges) => {<EOL>                let decorations = ranges.map((range) => {<EOL>                    let color = document.getText(","gt":"range);"}
{"input":"<s> export function activateColorDecorations(decoratorProvider, supportedLanguages) {<EOL>    let disposables = [];<EOL>    let colorsDecorationType = window.createTextEditorDecorationType(decorationType);<EOL>     disposables.push(colorsDecorationType);<EOL>    let pendingUpdateRequests = {};<EOL>    <EOL>    window.visibleTextEditors.forEach((editor) => {<EOL>         if (editor.document) {<EOL>            triggerUpdateDecorations(editor.document);<EOL>        }<EOL>    });<EOL>    <EOL>    window.onDidChangeActiveTextEditor(( editor) => {<EOL>        if (editor) {<EOL>            triggerUpdateDecorations(editor.document);<EOL>        }<EOL>    }, null, disposables);<EOL>    workspace.onDidChangeTextDocument((event) => triggerUpdateDecorations(event.document), null, disposables);<EOL>    workspace.onDidOpenTextDocument(triggerUpdateDecorations, null, disposables);<EOL>    workspace. onDidCloseTextDocument(triggerUpdateDecorations, null, disposables);<EOL>    function triggerUpdateDecorations(document) {<EOL>        let triggerUpdate = supportedLanguages[document.languageId];<EOL>        let uri = document.uri.toString();<EOL>        let timeout = pendingUpdateRequests[uri];<EOL>        if (typeof timeout !== '<STR_LIT>') {<EOL>            clearTimeout(timeout);<EOL>            triggerUpdate =  true; <EOL>        }<EOL>        if (triggerUpdate) {<EOL>            pendingUpdateRequests[uri] = setTimeout(() => {<EOL>                updateDecorations(uri);<EOL>                delete pendingUpdateRequests[uri];<EOL>            }, <NUM_LIT>);<EOL>        }<EOL>    }<EOL>    function updateDecorations(uri) {<EOL>        window.visibleTextEditors.forEach((editor) => {<EOL>            let document = editor.document;<EOL>            if (document && document.uri. toString() === uri) {<EOL>                updateDecorationForEditor(editor);<EOL>            }<EOL>        });<EOL>    }<EOL>    function updateDecorationForEditor(editor) {<EOL>        let document = editor.document;<EOL>        if (supportedLanguages[document.languageId]) {<EOL>            decoratorProvider(document.uri.toString()).then((ranges) => {<EOL>                let decorations = ranges.map((range) => {<EOL>                    let color = document.getText( range);<EOL>                    return {<EOL>                        range: range,<EOL>                        renderOptions: {<EOL>                            before: {<EOL>                                backgroundColor:","gt":"color"}
{"input":"<s> <EOL>function encodeURIComponent2(str) {<EOL>    return encodeURIComponent(str).","gt":"replace(/[!'()*]/g, _encode);"}
{"input":"<s> function showPreview(uri, sideBySide = false) {<EOL>    let resource = uri;<EOL>    if (!(resource instanceof Uri)) {<EOL>        if (vscode.window.activeTextEditor) {<EOL>            <EOL>            resource = vscode.window.activeTextEditor.document.uri;<EOL>        }<EOL>    }<EOL>    if (!(resource instanceof Uri)) {<EOL>        if (!vscode.window.activeTextEditor) {<EOL>            <EOL>            return vscode.commands.executeCommand('<STR_LIT>');<EOL>        }<EOL>        <EOL>        return;<EOL>    }<EOL>    let thenable = vscode.commands.executeCommand('<STR_LIT>', getMarkdownUri(resource), getViewColumn(sideBySide),","gt":"path.basename(resource.fsPath)}'<STR_LIT>;"}
{"input":"<s> function textSpan2Range(value) {<EOL>    return new Range(value.start.line - <NUM_LIT>, value.","gt":"start.offset - <NUM_LIT>, value.end.line - <NUM_LIT>, value.end.offset - <NUM_LIT>);"}
{"input":"<s> function generatePatchedEnv(env, stdInPipeName, stdOutPipeName, stdErrPipeName) {<EOL>    <EOL>    var newEnv = {};<EOL>    for (var key in env) {<EOL>","gt":"newEnv[key] = env[key];"}
{"input":"<s> function generatePatchedEnv(env, stdInPipeName, stdOutPipeName, stdErrPipeName) {<EOL>    <EOL>    var newEnv = {};<EOL>    for (var key in env) {<EOL>         newEnv[key] = env[key];<EOL>    }<EOL>    newEnv['<STR_LIT>'] = stdInPipeName;<EOL>    newEnv['<STR_LIT>'] = stdOutPipeName;<EOL>    newEnv['<STR_LIT>'] =","gt":"stdErrPipeName;"}
{"input":"<s> export function array(value) {<EOL>    return","gt":"Array.isArray(value);"}
{"input":"<s> export function undefined(value) {<EOL>    return typeof","gt":"value === '<STR_LIT>';"}
{"input":"<s> function bar() {<EOL>    var a = <NUM_LIT>;<EOL>    a = <NUM_LIT>;<EOL>    a = <NUM_LIT>;<EOL>    a = <NUM_LIT>;<EOL>    a = <NUM_LIT>;<EOL>    a =","gt":"<NUM_LIT>;"}
{"input":"<s> function bar() {<EOL>    var a = <NUM_LIT>;<EOL>    a = <NUM_LIT>;<EOL>    a = <NUM_LIT>;<EOL>    a = <NUM_LIT>;<EOL>    a = <NUM_LIT>;<EOL>    a =  <NUM_LIT>;<EOL>    a = <NUM_LIT>;<EOL>    a = <NUM_LIT>;<EOL>    a =","gt":"<NUM_LIT>;"}
{"input":"<s> function bar() {<EOL>    var a = <NUM_LIT>;<EOL>    a = <NUM_LIT>;<EOL>    a = <NUM_LIT>;<EOL>    a = <NUM_LIT>;<EOL>    a = <NUM_LIT>;<EOL>    a =  <NUM_LIT>;<EOL>    a = <NUM_LIT>;<EOL>    a = <NUM_LIT>;<EOL>    a =  <NUM_LIT>;<EOL>    a = <NUM_LIT>;<EOL>    a = <NUM_LIT>;<EOL>    a =","gt":"<NUM_LIT>;"}
{"input":"<s> function bar() {<EOL>    var a = <NUM_LIT>;<EOL>    a = <NUM_LIT>;<EOL>    a = <NUM_LIT>;<EOL>    a = <NUM_LIT>;<EOL>    a = <NUM_LIT>;<EOL>    a =  <NUM_LIT>;<EOL>    a = <NUM_LIT>;<EOL>    a = <NUM_LIT>;<EOL>    a =  <NUM_LIT>;<EOL>    a = <NUM_LIT>;<EOL>    a = <NUM_LIT>;<EOL>    a =  <NUM_LIT>;<EOL>    a = <NUM_LIT>;<EOL>    a = <NUM_LIT>;<EOL>","gt":"a = <NUM_LIT>;"}
{"input":"<s> function bar() {<EOL>    var a = <NUM_LIT>;<EOL>    a = <NUM_LIT>;<EOL>    a = <NUM_LIT>;<EOL>    a = <NUM_LIT>;<EOL>    a = <NUM_LIT>;<EOL>    a =  <NUM_LIT>;<EOL>    a = <NUM_LIT>;<EOL>    a = <NUM_LIT>;<EOL>    a =  <NUM_LIT>;<EOL>    a = <NUM_LIT>;<EOL>    a = <NUM_LIT>;<EOL>    a =  <NUM_LIT>;<EOL>    a = <NUM_LIT>;<EOL>    a = <NUM_LIT>;<EOL>     a = <NUM_LIT>;<EOL>    a = <NUM_LIT>;<EOL>    a = <NUM_LIT>;<EOL>    a = <NUM_LIT>;<EOL>    a = <NUM_LIT>;<EOL>    a = <NUM_LIT>;<EOL>    a = <NUM_LIT>;<EOL>","gt":"a = <NUM_LIT>;"}
{"input":"<s> <EOL>function positionToOffset(str, desiredLine, desiredCol) {<EOL>    if (desiredLine === <NUM_LIT>) {<EOL>        return desiredCol - <NUM_LIT>;<EOL>    }<EOL>    let line =","gt":"<NUM_LIT>, lastNewLineOffset = -<NUM_LIT>;"}
{"input":"<s> <EOL>function positionToOffset(str, desiredLine, desiredCol) {<EOL>    if (desiredLine === <NUM_LIT>) {<EOL>        return desiredCol - <NUM_LIT>;<EOL>    }<EOL>    let line =  <NUM_LIT>, lastNewLineOffset = -<NUM_LIT>;<EOL>    do {<EOL>        if (desiredLine === line) {<EOL>            return lastNewLineOffset + <NUM_LIT> + desiredCol - <NUM_LIT>;<EOL>        }<EOL>        lastNewLineOffset = str.indexOf('<STR_LIT>', lastNewLineOffset + <NUM_LIT>);<EOL>","gt":"line++;"}
{"input":"<s> function isObjectLiteral(node) {<EOL>    return","gt":"node && node.kind === ts.SyntaxKind.ObjectLiteralExpression;"}
{"input":"<s> export function setZoomLevel(zoomLevel) {<EOL>    ZoomManager.INSTANCE.setZoomLevel(","gt":"zoomLevel);"}
{"input":"<s> <EOL><EOL>export function getTotalWidth(element) {<EOL>    let margin =","gt":"sizeUtils.getMarginLeft(element) + sizeUtils.getMarginRight(element);"}
{"input":"<s> export function isInDOM(node) {<EOL>    while (node) {<EOL>        if (node === document.body) {<EOL>            return","gt":"true;"}
{"input":"<s> function formatTagType(char) {<EOL>    switch (char) {<EOL>        case '<STR_LIT>':<EOL>            return FormatType.Bold;<EOL>        case","gt":"'<STR_LIT>':"}
{"input":"<s> function formatTagType(char) {<EOL>    switch (char) {<EOL>        case '<STR_LIT>':<EOL>            return FormatType.Bold;<EOL>        case  '<STR_LIT>':<EOL>            return FormatType.Italics;<EOL>        case '<STR_LIT>':<EOL>            return FormatType.Action;<EOL>        case '<STR_LIT>':<EOL>            return FormatType.ActionClose;<EOL>","gt":"default:"}
{"input":"<s> function insertMessage(target, msg) {<EOL>    if (!ariaContainer) {<EOL>        <EOL>","gt":"return;"}
{"input":"<s> export function lookupOrInsert(from, stringOrNumber, alternate) {<EOL>    const key = String(stringOrNumber);<EOL>    if (contains(from, key)) {<EOL>        return from[key];<EOL>    }<EOL>    else {<EOL>        if (typeof alternate === '<STR_LIT>') {<EOL>            alternate = alternate();<EOL>        }<EOL>        from[key] =","gt":"alternate;"}
{"input":"<s> <EOL>function hex2rgba(hex) {<EOL>    function parseHex(str) {<EOL>        return parseInt('<STR_LIT>' + str);<EOL>    }<EOL>","gt":"if (hex.charAt(<NUM_LIT>) === '<STR_LIT>' && hex.length >= <NUM_LIT>) {"}
{"input":"<s> <EOL>function hex2rgba(hex) {<EOL>    function parseHex(str) {<EOL>        return parseInt('<STR_LIT>' + str);<EOL>    }<EOL>     if (hex.charAt(<NUM_LIT>) === '<STR_LIT>' && hex.length >= <NUM_LIT>) {<EOL>        let r = parseHex(hex.substr(<NUM_LIT>, <NUM_LIT>));<EOL>        let g = parseHex(hex.substr(<NUM_LIT>, <NUM_LIT>));<EOL>        let b = parseHex(hex.substr(<NUM_LIT>, <NUM_LIT>));<EOL>        let a = hex.length === <NUM_LIT> ? parseHex(hex.substr(<NUM_LIT>, <NUM_LIT>)) / <NUM_LIT> : <NUM_LIT>;<EOL>        return { r,","gt":"g, b, a };"}
{"input":"<s> <EOL>export function canceled() {<EOL>","gt":"let error = new Error(canceledName);"}
{"input":"<s> function nextWord(word, start) {<EOL>    for (let i = start; i < word.length; i++) {<EOL>        let c = word.charCodeAt(i);<EOL>        if (","gt":"isWhitespace(c) || (i > <NUM_LIT> && isWhitespace(word.charCodeAt(i - <NUM_LIT>)))) {"}
{"input":"<s> function isDigit(ch) {<EOL>    return ch >= CharacterCodes.","gt":"_0 && ch <= CharacterCodes._9;"}
{"input":"<s> export function countToArray(fromOrTo, to) {<EOL>    var result = [];<EOL>    var fn = (i) => result.push(i);<EOL>    if (","gt":"types.isUndefined(to)) {"}
{"input":"<s> export function singlePagePager(elements) {<EOL>    return {<EOL>","gt":"firstPage: elements,"}
{"input":"<s> function _isNormal(path, win) {<EOL>","gt":"return win"}
{"input":"<s> export function resolveCommandOptions(options, variables) {<EOL>    let result = Objects.clone(options);<EOL>    if (result.cwd) {<EOL>","gt":"result.cwd = variables.resolve(result.cwd);"}
{"input":"<s> <EOL>export function commonPrefixLength(a, b) {<EOL>    let i, len = Math.min(a.length, b.length);<EOL>    for (i = <NUM_LIT>; i < len; i++) {<EOL>","gt":"if (a.charCodeAt(i) !== b.charCodeAt(i)) {"}
{"input":"<s> export function removeAnsiEscapeCodes(str) {<EOL>    if (str) {<EOL>        str = str.replace(EL, '<STR_LIT>');<EOL>        str = str.replace(LF,","gt":"'<STR_LIT>');"}
{"input":"<s> function Sequence(sequences) {<EOL>    <EOL>    <EOL>    let","gt":"errorHandler = sequences.splice(<NUM_LIT>, <NUM_LIT>)[<NUM_LIT>];"}
{"input":"<s> function Sequence(sequences) {<EOL>    <EOL>    <EOL>    let  errorHandler = sequences.splice(<NUM_LIT>, <NUM_LIT>)[<NUM_LIT>]; <EOL>    let sequenceResult = null;<EOL>    loop(sequences, (sequence, clb) => {<EOL>        let sequenceFunction = function (error, result) {<EOL>            <EOL>            if (error === true || error === false) {<EOL>                result = error;<EOL>                error = null;<EOL>            }<EOL>            <EOL>            if (error) {<EOL>","gt":"clb(error, null);"}
{"input":"<s> export function writeFileAndFlush(path, data, encoding = '<STR_LIT>') {<EOL>    return nfcall(extfs.writeFileAndFlush, path, data,","gt":"encoding);"}
{"input":"<s> function hasNoContent(context) {<EOL>    return context.","gt":"res.statusCode === <NUM_LIT>;"}
{"input":"<s> function removeFromParent(element) {<EOL>    try {<EOL>        element.parentElement.removeChild(","gt":"element);"}
{"input":"<s> function assertTree(input, expected) {<EOL>    var errors = [];<EOL>    var actual = parseTree(input, errors);<EOL>    assert.equal(errors.length, <NUM_LIT>);<EOL>    let checkParent = (node) => {<EOL>","gt":"if (node.children) {"}
{"input":"<s> function assertUrl(raw, scheme, domain, port, path, queryString, fragmentId) {<EOL>    <EOL>    var uri = URI.parse(raw);<EOL>    assert.","gt":"equal(uri.scheme, scheme);"}
{"input":"<s> function quit(accessor, arg) {<EOL>    const logService = accessor.get(ILogService);<EOL>    let exitCode = <NUM_LIT>;<EOL>    if (typeof arg === '<STR_LIT>') {<EOL>        logService.log(arg);<EOL>    }<EOL>    else {<EOL>        exitCode = <NUM_LIT>; <EOL>        if (arg.stack) {<EOL>            console.error(arg.","gt":"stack);"}
{"input":"<s> function quit(accessor, arg) {<EOL>    const logService = accessor.get(ILogService);<EOL>    let exitCode = <NUM_LIT>;<EOL>    if (typeof arg === '<STR_LIT>') {<EOL>        logService.log(arg);<EOL>    }<EOL>    else {<EOL>        exitCode = <NUM_LIT>; <EOL>        if (arg.stack) {<EOL>            console.error(arg. stack);<EOL>        }<EOL>        else {<EOL>","gt":"console.error('<STR_LIT>' + arg.toString());"}
{"input":"<s> <EOL>export function create(domElement, options, services) {<EOL>    startup.initStaticServicesIfNecessary();<EOL>    services = shallowClone(services);<EOL>    var editorService = null;<EOL>    if (!services || !services.editorService) {<EOL>        editorService = new SimpleEditorService();<EOL>","gt":"services.editorService = editorService;"}
{"input":"<s> <EOL>export function create(domElement, options, services) {<EOL>    startup.initStaticServicesIfNecessary();<EOL>    services = shallowClone(services);<EOL>    var editorService = null;<EOL>    if (!services || !services.editorService) {<EOL>        editorService = new SimpleEditorService();<EOL>         services.editorService = editorService;<EOL>    }<EOL>    if (!services.openerService) {<EOL>        services.openerService = new OpenerService(editorService, services.commandService);<EOL>    }<EOL>","gt":"var t = prepareServices(domElement, services);"}
{"input":"<s> <EOL>export function create(domElement, options, services) {<EOL>    startup.initStaticServicesIfNecessary();<EOL>    services = shallowClone(services);<EOL>    var editorService = null;<EOL>    if (!services || !services.editorService) {<EOL>        editorService = new SimpleEditorService();<EOL>         services.editorService = editorService;<EOL>    }<EOL>    if (!services.openerService) {<EOL>        services.openerService = new OpenerService(editorService, services.commandService);<EOL>    }<EOL>     var t = prepareServices(domElement, services);<EOL>    var","gt":"result = t.ctx.instantiationService.createInstance(StandaloneEditor, domElement, options, t.toDispose);"}
{"input":"<s> <EOL>export function setupServices(services) {<EOL>","gt":"return startup.setupServices(services);"}
{"input":"<s> <EOL>export function createMonacoLanguagesAPI() {<EOL>    return {<EOL>        register: register,<EOL>        getLanguages: getLanguages,<EOL>        onLanguage: onLanguage,<EOL>        <EOL>        setLanguageConfiguration:","gt":"setLanguageConfiguration,"}
{"input":"<s> <EOL>export function createMonacoLanguagesAPI() {<EOL>    return {<EOL>        register: register,<EOL>        getLanguages: getLanguages,<EOL>        onLanguage: onLanguage,<EOL>        <EOL>        setLanguageConfiguration:  setLanguageConfiguration,<EOL>        setTokensProvider: setTokensProvider,<EOL>        setMonarchTokensProvider: setMonarchTokensProvider,<EOL>        registerReferenceProvider:","gt":"registerReferenceProvider,"}
{"input":"<s> <EOL>export function createMonacoLanguagesAPI() {<EOL>    return {<EOL>        register: register,<EOL>        getLanguages: getLanguages,<EOL>        onLanguage: onLanguage,<EOL>        <EOL>        setLanguageConfiguration:  setLanguageConfiguration,<EOL>        setTokensProvider: setTokensProvider,<EOL>        setMonarchTokensProvider: setMonarchTokensProvider,<EOL>        registerReferenceProvider:  registerReferenceProvider,<EOL>        registerRenameProvider: registerRenameProvider,<EOL>        registerCompletionItemProvider: registerCompletionItemProvider,<EOL>","gt":"registerSignatureHelpProvider: registerSignatureHelpProvider,"}
{"input":"<s> <EOL>export function createMonacoLanguagesAPI() {<EOL>    return {<EOL>        register: register,<EOL>        getLanguages: getLanguages,<EOL>        onLanguage: onLanguage,<EOL>        <EOL>        setLanguageConfiguration:  setLanguageConfiguration,<EOL>        setTokensProvider: setTokensProvider,<EOL>        setMonarchTokensProvider: setMonarchTokensProvider,<EOL>        registerReferenceProvider:  registerReferenceProvider,<EOL>        registerRenameProvider: registerRenameProvider,<EOL>        registerCompletionItemProvider: registerCompletionItemProvider,<EOL>         registerSignatureHelpProvider: registerSignatureHelpProvider,<EOL>        registerHoverProvider: registerHoverProvider,<EOL>        registerDocumentSymbolProvider: registerDocumentSymbolProvider,<EOL>","gt":"registerDocumentHighlightProvider: registerDocumentHighlightProvider,"}
{"input":"<s> <EOL>export function createMonacoLanguagesAPI() {<EOL>    return {<EOL>        register: register,<EOL>        getLanguages: getLanguages,<EOL>        onLanguage: onLanguage,<EOL>        <EOL>        setLanguageConfiguration:  setLanguageConfiguration,<EOL>        setTokensProvider: setTokensProvider,<EOL>        setMonarchTokensProvider: setMonarchTokensProvider,<EOL>        registerReferenceProvider:  registerReferenceProvider,<EOL>        registerRenameProvider: registerRenameProvider,<EOL>        registerCompletionItemProvider: registerCompletionItemProvider,<EOL>         registerSignatureHelpProvider: registerSignatureHelpProvider,<EOL>        registerHoverProvider: registerHoverProvider,<EOL>        registerDocumentSymbolProvider: registerDocumentSymbolProvider,<EOL>         registerDocumentHighlightProvider: registerDocumentHighlightProvider,<EOL>        registerDefinitionProvider: registerDefinitionProvider,<EOL>        registerCodeLensProvider: registerCodeLensProvider,<EOL>        registerCodeActionProvider: registerCodeActionProvider,<EOL>        registerDocumentFormattingEditProvider: registerDocumentFormattingEditProvider,<EOL>        registerDocumentRangeFormattingEditProvider: registerDocumentRangeFormattingEditProvider,<EOL>        registerOnTypeFormattingEditProvider:","gt":"registerOnTypeFormattingEditProvider,"}
{"input":"<s> function shallowClone(obj) {<EOL>    let r = {};<EOL>    if (obj) {<EOL>","gt":"let keys = Object.keys(obj);"}
{"input":"<s> function cursorBlinkingStyleFromString(cursorBlinkingStyle) {<EOL>    switch (cursorBlinkingStyle) {<EOL>        case '<STR_LIT>':<EOL>            return editorCommon.TextEditorCursorBlinkingStyle.Blink;<EOL>        case '<STR_LIT>':<EOL>","gt":"return editorCommon.TextEditorCursorBlinkingStyle.Smooth;"}
{"input":"<s> function cursorBlinkingStyleFromString(cursorBlinkingStyle) {<EOL>    switch (cursorBlinkingStyle) {<EOL>        case '<STR_LIT>':<EOL>            return editorCommon.TextEditorCursorBlinkingStyle.Blink;<EOL>        case '<STR_LIT>':<EOL>             return editorCommon.TextEditorCursorBlinkingStyle.Smooth;<EOL>        case '<STR_LIT>':<EOL>            return editorCommon.TextEditorCursorBlinkingStyle.Phase;<EOL>        case '<STR_LIT>':<EOL>            return editorCommon.TextEditorCursorBlinkingStyle.Expand;<EOL>        case '<STR_LIT>': <EOL>","gt":"case '<STR_LIT>':"}
{"input":"<s> function cursorStyleFromString(cursorStyle) {<EOL>    if (cursorStyle === '<STR_LIT>') {<EOL>        return editorCommon.TextEditorCursorStyle.Line;<EOL>    }<EOL>    else if (cursorStyle ===","gt":"'<STR_LIT>') {"}
{"input":"<s> function cursorStyleFromString(cursorStyle) {<EOL>    if (cursorStyle === '<STR_LIT>') {<EOL>        return editorCommon.TextEditorCursorStyle.Line;<EOL>    }<EOL>    else if (cursorStyle ===  '<STR_LIT>') {<EOL>        return editorCommon.TextEditorCursorStyle.Block;<EOL>    }<EOL>    else if (cursorStyle === '<STR_LIT>') {<EOL>","gt":"return editorCommon.TextEditorCursorStyle.Underline;"}
{"input":"<s> <EOL>export function isCommonDiffEditor(thing) {<EOL>    if (thing && typeof thing.getEditorType === '<STR_LIT>') {<EOL>        return thing.getEditorType() === EditorType.","gt":"ICodeEditor;"}
{"input":"<s> <EOL>function computePlusOneIndentLevel(line, tabSize) {<EOL>    let indent = <NUM_LIT>;<EOL>    let i = <NUM_LIT>;<EOL>    let len = line.length;<EOL>    while (","gt":"i < len) {"}
{"input":"<s> <EOL>function computePlusOneIndentLevel(line, tabSize) {<EOL>    let indent = <NUM_LIT>;<EOL>    let i = <NUM_LIT>;<EOL>    let len = line.length;<EOL>    while ( i < len) {<EOL>        let chCode = line.charCodeAt(i);<EOL>        if (chCode === <NUM_LIT> ) {<EOL>","gt":"indent++;"}
{"input":"<s> function toLineTokensFromDeflated(tokens, textLength) {<EOL>    if (textLength === <NUM_LIT>) {<EOL>        return null;<EOL>    }<EOL>","gt":"if (!tokens || tokens.length === <NUM_LIT>) {"}
{"input":"<s> <EOL>export function sanitize(s) {<EOL>    return s.","gt":"replace(/[&<>'\"_]/g, '<STR_LIT>');"}
{"input":"<s> <EOL><EOL>export function throwError(lexer, msg) {<EOL>    throw new Error(","gt":"languageId}: ${msg}`<STR_LIT>;"}
{"input":"<s> export function nullTokenize(modeId, buffer, state, deltaOffset = <NUM_LIT>, stopAtOffset) {<EOL>    let tokens = [new Token(deltaOffset, '<STR_LIT>')];<EOL>    let modeTransitions = [new ModeTransition(deltaOffset, modeId)];<EOL>","gt":"return {"}
{"input":"<s> function isQuickFix(quickfix) {<EOL>","gt":"return quickfix"}
{"input":"<s> export function getCodeActions(model, range) {<EOL>    const quickFixes = [];<EOL>    let ids = new IdGenerator('<STR_LIT>');<EOL>    const promises = CodeActionProviderRegistry.all(model).map((support) => {<EOL>        return asWinJsPromise((token) => {<EOL>            return support.provideCodeActions(model, range,","gt":"token);"}
{"input":"<s> export function getCodeActions(model, range) {<EOL>    const quickFixes = [];<EOL>    let ids = new IdGenerator('<STR_LIT>');<EOL>    const promises = CodeActionProviderRegistry.all(model).map((support) => {<EOL>        return asWinJsPromise((token) => {<EOL>            return support.provideCodeActions(model, range,  token);<EOL>        }).then((result) => {<EOL>            if (!Array.","gt":"isArray(result)) {"}
{"input":"<s> export function getCodeActions(model, range) {<EOL>    const quickFixes = [];<EOL>    let ids = new IdGenerator('<STR_LIT>');<EOL>    const promises = CodeActionProviderRegistry.all(model).map((support) => {<EOL>        return asWinJsPromise((token) => {<EOL>            return support.provideCodeActions(model, range,  token);<EOL>        }).then((result) => {<EOL>            if (!Array. isArray(result)) {<EOL>                return;<EOL>            }<EOL>            for (let fix of result) {<EOL>                quickFixes.push({<EOL>","gt":"command: fix.command,"}
{"input":"<s> function matchesColor(text) {<EOL>    return text && text.","gt":"match(colorRegExp) ? text : null;"}
{"input":"<s> function deleteWordRight(cursor) {<EOL>","gt":"cursorCommand(cursor, H.DeleteWordRight);"}
{"input":"<s> function getRandomInt(min, max) {<EOL>    return Math.floor(Math.random() * (max -","gt":"min + <NUM_LIT>)) + min;"}
{"input":"<s> function equalRange(left, right) {<EOL>    if (left.startLineNumber !== right.startLineNumber) {<EOL>        assert.ok(false, '<STR_LIT>' + left.startLineNumber + '<STR_LIT>' + right.startLineNumber);<EOL>    }<EOL>    else if (left.","gt":"endLineNumber !== right.endLineNumber) {"}
{"input":"<s> function equalRange(left, right) {<EOL>    if (left.startLineNumber !== right.startLineNumber) {<EOL>        assert.ok(false, '<STR_LIT>' + left.startLineNumber + '<STR_LIT>' + right.startLineNumber);<EOL>    }<EOL>    else if (left. endLineNumber !== right.endLineNumber) {<EOL>        assert.ok(false, '<STR_LIT>' + left.endLineNumber + '<STR_LIT>' + right.endLineNumber);<EOL>    }<EOL>    else if (left.startColumn !== right.startColumn) {<EOL>        assert.ok(false, '<STR_LIT>' + left.startColumn + '<STR_LIT>' + right.startColumn);<EOL>    }<EOL>","gt":"else if (left.endColumn !== right.endColumn) {"}
{"input":"<s> export function executeTests(tokenizationSupport, tests) {<EOL>    for (var i = <NUM_LIT>, len = tests.length; i < len; i++) {<EOL>        assert.ok(true,","gt":"'<STR_LIT>' + i);"}
{"input":"<s> export function testModelBuilder(chunks, opts = TextModel.DEFAULT_CREATION_OPTIONS) {<EOL>    let expectedRawText = TextModel.toRawText(chunks.join('<STR_LIT>'), opts);<EOL>    let expectedHash = computeHash(expectedRawText);<EOL>    let builder = new ModelBuilder();<EOL>    for (let i = <NUM_LIT>,","gt":"len = chunks.length; i < len; i++) {"}
{"input":"<s> export function testModelBuilder(chunks, opts = TextModel.DEFAULT_CREATION_OPTIONS) {<EOL>    let expectedRawText = TextModel.toRawText(chunks.join('<STR_LIT>'), opts);<EOL>    let expectedHash = computeHash(expectedRawText);<EOL>    let builder = new ModelBuilder();<EOL>    for (let i = <NUM_LIT>,  len = chunks.length; i < len; i++) {<EOL>        builder.acceptChunk(chunks[i]);<EOL>    }<EOL>    let actual = builder.finish(opts);<EOL>    assert.deepEqual({<EOL>        rawText: expectedRawText,<EOL>        hash:","gt":"expectedHash"}
{"input":"<s> function isInterestingToken(tokenType) {<EOL>    switch (tokenType) {<EOL>        case DELIM_START:<EOL>        case","gt":"DELIM_END:"}
{"input":"<s> function getDefaultValue(type) {<EOL>    const t = Array.isArray(type) ? type[<NUM_LIT>] : type;<EOL>    switch (t) {<EOL>        case '<STR_LIT>':<EOL>            return false;<EOL>","gt":"case '<STR_LIT>':"}
{"input":"<s> function getDefaultValue(type) {<EOL>    const t = Array.isArray(type) ? type[<NUM_LIT>] : type;<EOL>    switch (t) {<EOL>        case '<STR_LIT>':<EOL>            return false;<EOL>         case '<STR_LIT>':<EOL>        case '<STR_LIT>':<EOL>            return <NUM_LIT>;<EOL>        case '<STR_LIT>':<EOL>            return","gt":"'<STR_LIT>';"}
{"input":"<s> function getDefaultValue(type) {<EOL>    const t = Array.isArray(type) ? type[<NUM_LIT>] : type;<EOL>    switch (t) {<EOL>        case '<STR_LIT>':<EOL>            return false;<EOL>         case '<STR_LIT>':<EOL>        case '<STR_LIT>':<EOL>            return <NUM_LIT>;<EOL>        case '<STR_LIT>':<EOL>            return  '<STR_LIT>';<EOL>        case '<STR_LIT>':<EOL>            return [];<EOL>        case '<STR_LIT>':<EOL>","gt":"return {};"}
{"input":"<s> export function setNode(root, key, value) {<EOL>    const segments = key.split('<STR_LIT>');<EOL>    const last = segments.pop();<EOL>    let curr = root;<EOL>    segments.forEach((s) => {<EOL>        let obj = curr[s];<EOL>","gt":"switch (typeof obj) {"}
{"input":"<s> export function setNode(root, key, value) {<EOL>    const segments = key.split('<STR_LIT>');<EOL>    const last = segments.pop();<EOL>    let curr = root;<EOL>    segments.forEach((s) => {<EOL>        let obj = curr[s];<EOL>         switch (typeof obj) {<EOL>            case '<STR_LIT>':<EOL>                obj = curr[s] = Object.create(null);<EOL>                break;<EOL>","gt":"case '<STR_LIT>':"}
{"input":"<s> export function setNode(root, key, value) {<EOL>    const segments = key.split('<STR_LIT>');<EOL>    const last = segments.pop();<EOL>    let curr = root;<EOL>    segments.forEach((s) => {<EOL>        let obj = curr[s];<EOL>         switch (typeof obj) {<EOL>            case '<STR_LIT>':<EOL>                obj = curr[s] = Object.create(null);<EOL>                break;<EOL>             case '<STR_LIT>':<EOL>                break;<EOL>            default:<EOL>                console.","gt":"log('<STR_LIT>' + key + '<STR_LIT>' + s + '<STR_LIT>' + JSON.stringify(obj));"}
{"input":"<s> export function parseVersion(version) {<EOL>    if (!isValidVersionStr(version)) {<EOL>        return null;<EOL>    }<EOL>    version = version.trim();<EOL>","gt":"if (version === '<STR_LIT>') {"}
{"input":"<s> export function parseVersion(version) {<EOL>    if (!isValidVersionStr(version)) {<EOL>        return null;<EOL>    }<EOL>    version = version.trim();<EOL>     if (version === '<STR_LIT>') {<EOL>        return {<EOL>            hasCaret: false,<EOL>            majorBase: <NUM_LIT>,<EOL>            majorMustEqual:","gt":"false,"}
{"input":"<s> export function parseVersion(version) {<EOL>    if (!isValidVersionStr(version)) {<EOL>        return null;<EOL>    }<EOL>    version = version.trim();<EOL>     if (version === '<STR_LIT>') {<EOL>        return {<EOL>            hasCaret: false,<EOL>            majorBase: <NUM_LIT>,<EOL>            majorMustEqual:  false,<EOL>            minorBase: <NUM_LIT>,<EOL>            minorMustEqual: false,<EOL>            patchBase:","gt":"<NUM_LIT>,"}
{"input":"<s> export function parseVersion(version) {<EOL>    if (!isValidVersionStr(version)) {<EOL>        return null;<EOL>    }<EOL>    version = version.trim();<EOL>     if (version === '<STR_LIT>') {<EOL>        return {<EOL>            hasCaret: false,<EOL>            majorBase: <NUM_LIT>,<EOL>            majorMustEqual:  false,<EOL>            minorBase: <NUM_LIT>,<EOL>            minorMustEqual: false,<EOL>            patchBase:  <NUM_LIT>,<EOL>            patchMustEqual: false,<EOL>            preRelease:","gt":"null"}
{"input":"<s> export function parseVersion(version) {<EOL>    if (!isValidVersionStr(version)) {<EOL>        return null;<EOL>    }<EOL>    version = version.trim();<EOL>     if (version === '<STR_LIT>') {<EOL>        return {<EOL>            hasCaret: false,<EOL>            majorBase: <NUM_LIT>,<EOL>            majorMustEqual:  false,<EOL>            minorBase: <NUM_LIT>,<EOL>            minorMustEqual: false,<EOL>            patchBase:  <NUM_LIT>,<EOL>            patchMustEqual: false,<EOL>            preRelease:  null<EOL>        };<EOL>    }<EOL>    let m = version.match(VERSION_REGEXP);<EOL>    return {<EOL>        hasCaret: !!m[<NUM_LIT>],<EOL>        majorBase: m[<NUM_LIT>] === '<STR_LIT>' ? <NUM_LIT> : parseInt(m[<NUM_LIT>], <NUM_LIT>),<EOL>","gt":"majorMustEqual: (m[<NUM_LIT>] === '<STR_LIT>' ? false : true),"}
{"input":"<s> export function registerSingleton(id, ctor) {<EOL>    _registry.","gt":"push({ id, descriptor: new SyncDescriptor(ctor) });"}
{"input":"<s> function randomMarkerData() {<EOL>    return {<EOL>        severity: <NUM_LIT>,<EOL>        message: Math.random().toString(","gt":"<NUM_LIT>),"}
{"input":"<s> function getOrCreateMachineId(storageService) {<EOL>    const key = '<STR_LIT>';<EOL>    let result = storageService.get(key);<EOL>","gt":"if (result) {"}
{"input":"<s> function setWordDefinitionFor(modeId, wordDefinition) {<EOL>    _modeId2WordDefinition[","gt":"modeId] = wordDefinition;"}
{"input":"<s> export function fromHover(hover) {<EOL>    return {<EOL>        range:","gt":"fromRange(hover.range),"}
{"input":"<s> export function fromViewColumn(column) {<EOL>    let editorColumn = EditorPosition.LEFT;<EOL>    if (typeof column !== '<STR_LIT>') {<EOL>        <EOL>    }<EOL>    else if (column === types.ViewColumn.Two) {<EOL>        editorColumn = EditorPosition.CENTER;<EOL>    }<EOL>    else if (column === types.ViewColumn.Three) {<EOL>        editorColumn =","gt":"EditorPosition.RIGHT;"}
{"input":"<s> function moveActiveEditorToGroup(args, activeEditor, accessor) {<EOL>    let newPosition = activeEditor.position;<EOL>    switch (args.to) {<EOL>        case ActiveEditorMovePositioning.LEFT:<EOL>            newPosition = newPosition - <NUM_LIT>;<EOL>","gt":"break;"}
{"input":"<s> function moveActiveEditorToGroup(args, activeEditor, accessor) {<EOL>    let newPosition = activeEditor.position;<EOL>    switch (args.to) {<EOL>        case ActiveEditorMovePositioning.LEFT:<EOL>            newPosition = newPosition - <NUM_LIT>;<EOL>             break;<EOL>        case ActiveEditorMovePositioning.RIGHT:<EOL>            newPosition = newPosition + <NUM_LIT>;<EOL>","gt":"break;"}
{"input":"<s> function moveActiveEditorToGroup(args, activeEditor, accessor) {<EOL>    let newPosition = activeEditor.position;<EOL>    switch (args.to) {<EOL>        case ActiveEditorMovePositioning.LEFT:<EOL>            newPosition = newPosition - <NUM_LIT>;<EOL>             break;<EOL>        case ActiveEditorMovePositioning.RIGHT:<EOL>            newPosition = newPosition + <NUM_LIT>;<EOL>             break;<EOL>        case ActiveEditorMovePositioning.FIRST:<EOL>            newPosition = Position.LEFT;<EOL>            break;<EOL>        case ActiveEditorMovePositioning.LAST:<EOL>","gt":"newPosition = Position.RIGHT;"}
{"input":"<s> function moveActiveEditorToGroup(args, activeEditor, accessor) {<EOL>    let newPosition = activeEditor.position;<EOL>    switch (args.to) {<EOL>        case ActiveEditorMovePositioning.LEFT:<EOL>            newPosition = newPosition - <NUM_LIT>;<EOL>             break;<EOL>        case ActiveEditorMovePositioning.RIGHT:<EOL>            newPosition = newPosition + <NUM_LIT>;<EOL>             break;<EOL>        case ActiveEditorMovePositioning.FIRST:<EOL>            newPosition = Position.LEFT;<EOL>            break;<EOL>        case ActiveEditorMovePositioning.LAST:<EOL>             newPosition = Position.RIGHT;<EOL>            break;<EOL>        case ActiveEditorMovePositioning.CENTER:<EOL>            newPosition = Position.CENTER;<EOL>            break;<EOL>        case","gt":"ActiveEditorMovePositioning.POSITION:"}
{"input":"<s> function registerDiffEditorCommands() {<EOL>    KeybindingsRegistry.registerCommandAndKeybindingRule({<EOL>        id: '<STR_LIT>',<EOL>        weight: KeybindingsRegistry.WEIGHT.workbenchContrib(),<EOL>","gt":"when: TextCompareEditorVisible,"}
{"input":"<s> function registerDiffEditorCommands() {<EOL>    KeybindingsRegistry.registerCommandAndKeybindingRule({<EOL>        id: '<STR_LIT>',<EOL>        weight: KeybindingsRegistry.WEIGHT.workbenchContrib(),<EOL>         when: TextCompareEditorVisible,<EOL>","gt":"primary: null,"}
{"input":"<s> function registerDiffEditorCommands() {<EOL>    KeybindingsRegistry.registerCommandAndKeybindingRule({<EOL>        id: '<STR_LIT>',<EOL>        weight: KeybindingsRegistry.WEIGHT.workbenchContrib(),<EOL>         when: TextCompareEditorVisible,<EOL>         primary: null,<EOL>        handler: (accessor) => navigateInDiffEditor(accessor, true)<EOL>    });<EOL>    KeybindingsRegistry.","gt":"registerCommandAndKeybindingRule({"}
{"input":"<s> function registerDiffEditorCommands() {<EOL>    KeybindingsRegistry.registerCommandAndKeybindingRule({<EOL>        id: '<STR_LIT>',<EOL>        weight: KeybindingsRegistry.WEIGHT.workbenchContrib(),<EOL>         when: TextCompareEditorVisible,<EOL>         primary: null,<EOL>        handler: (accessor) => navigateInDiffEditor(accessor, true)<EOL>    });<EOL>    KeybindingsRegistry. registerCommandAndKeybindingRule({<EOL>        id: '<STR_LIT>',<EOL>        weight: KeybindingsRegistry.WEIGHT.workbenchContrib(),<EOL>        when:","gt":"TextCompareEditorVisible,"}
{"input":"<s> function registerDiffEditorCommands() {<EOL>    KeybindingsRegistry.registerCommandAndKeybindingRule({<EOL>        id: '<STR_LIT>',<EOL>        weight: KeybindingsRegistry.WEIGHT.workbenchContrib(),<EOL>         when: TextCompareEditorVisible,<EOL>         primary: null,<EOL>        handler: (accessor) => navigateInDiffEditor(accessor, true)<EOL>    });<EOL>    KeybindingsRegistry. registerCommandAndKeybindingRule({<EOL>        id: '<STR_LIT>',<EOL>        weight: KeybindingsRegistry.WEIGHT.workbenchContrib(),<EOL>        when:  TextCompareEditorVisible,<EOL>        primary: null,<EOL>        handler: (accessor) => navigateInDiffEditor(accessor, false)<EOL>    });<EOL>    function navigateInDiffEditor(accessor, next) {<EOL>        let editorService = accessor.get(IWorkbenchEditorService);<EOL>        const candidates = [editorService.getActiveEditor(), ...editorService.getVisibleEditors()].","gt":"filter((e) => e instanceof TextDiffEditor);"}
{"input":"<s> function registerDiffEditorCommands() {<EOL>    KeybindingsRegistry.registerCommandAndKeybindingRule({<EOL>        id: '<STR_LIT>',<EOL>        weight: KeybindingsRegistry.WEIGHT.workbenchContrib(),<EOL>         when: TextCompareEditorVisible,<EOL>         primary: null,<EOL>        handler: (accessor) => navigateInDiffEditor(accessor, true)<EOL>    });<EOL>    KeybindingsRegistry. registerCommandAndKeybindingRule({<EOL>        id: '<STR_LIT>',<EOL>        weight: KeybindingsRegistry.WEIGHT.workbenchContrib(),<EOL>        when:  TextCompareEditorVisible,<EOL>        primary: null,<EOL>        handler: (accessor) => navigateInDiffEditor(accessor, false)<EOL>    });<EOL>    function navigateInDiffEditor(accessor, next) {<EOL>        let editorService = accessor.get(IWorkbenchEditorService);<EOL>        const candidates = [editorService.getActiveEditor(), ...editorService.getVisibleEditors()]. filter((e) => e instanceof TextDiffEditor);<EOL>        if (candidates.length > <NUM_LIT>) {<EOL>            next ? candidates[<NUM_LIT>].getDiffNavigator().next() : candidates[<NUM_LIT>].getDiffNavigator().previous();<EOL>        }<EOL>    }<EOL>    KeybindingsRegistry.registerCommandAndKeybindingRule({<EOL>        id: '<STR_LIT>',<EOL>        weight: KeybindingsRegistry.WEIGHT.workbenchContrib(<NUM_LIT>),<EOL>        handler(accessor) {<EOL>            console.log(`<STR_LIT>`);<EOL>        },<EOL>        when: undefined,<EOL>        primary:","gt":"undefined"}
{"input":"<s> function getCodeEditor(editorWidget) {<EOL>    if (editorWidget) {<EOL>        if (editorWidget.getEditorType() === EditorType.IDiffEditor) {<EOL>            return editorWidget.","gt":"getModifiedEditor();"}
{"input":"<s> function navigateKeybinding(shift) {<EOL>    if (shift) {<EOL>        return {<EOL>            primary: KeyMod.CtrlCmd | KeyMod.Shift | KeyCode.KEY_P,<EOL>            secondary: [KeyMod.CtrlCmd | KeyMod.Shift | KeyCode.KEY_E, KeyMod.","gt":"CtrlCmd | KeyMod.Shift | KeyCode.Tab],"}
{"input":"<s> function navigateKeybinding(shift) {<EOL>    if (shift) {<EOL>        return {<EOL>            primary: KeyMod.CtrlCmd | KeyMod.Shift | KeyCode.KEY_P,<EOL>            secondary: [KeyMod.CtrlCmd | KeyMod.Shift | KeyCode.KEY_E, KeyMod. CtrlCmd | KeyMod.Shift | KeyCode.Tab],<EOL>            mac: {<EOL>                primary: KeyMod.CtrlCmd | KeyMod.Shift | KeyCode.KEY_P,<EOL>                secondary: [KeyMod.WinCtrl | KeyMod.","gt":"Shift | KeyCode.Tab]"}
{"input":"<s> function navigateKeybinding(shift) {<EOL>    if (shift) {<EOL>        return {<EOL>            primary: KeyMod.CtrlCmd | KeyMod.Shift | KeyCode.KEY_P,<EOL>            secondary: [KeyMod.CtrlCmd | KeyMod.Shift | KeyCode.KEY_E, KeyMod. CtrlCmd | KeyMod.Shift | KeyCode.Tab],<EOL>            mac: {<EOL>                primary: KeyMod.CtrlCmd | KeyMod.Shift | KeyCode.KEY_P,<EOL>                secondary: [KeyMod.WinCtrl | KeyMod. Shift | KeyCode.Tab]<EOL>            }<EOL>        };<EOL>    }<EOL>","gt":"else {"}
{"input":"<s> function navigateKeybinding(shift) {<EOL>    if (shift) {<EOL>        return {<EOL>            primary: KeyMod.CtrlCmd | KeyMod.Shift | KeyCode.KEY_P,<EOL>            secondary: [KeyMod.CtrlCmd | KeyMod.Shift | KeyCode.KEY_E, KeyMod. CtrlCmd | KeyMod.Shift | KeyCode.Tab],<EOL>            mac: {<EOL>                primary: KeyMod.CtrlCmd | KeyMod.Shift | KeyCode.KEY_P,<EOL>                secondary: [KeyMod.WinCtrl | KeyMod. Shift | KeyCode.Tab]<EOL>            }<EOL>        };<EOL>    }<EOL>     else {<EOL>        return {<EOL>            primary: KeyMod.CtrlCmd | KeyCode.KEY_P,<EOL>            secondary: [KeyMod.CtrlCmd | KeyCode.KEY_E, KeyMod.CtrlCmd | KeyCode.Tab],<EOL>            mac: {<EOL>","gt":"primary: KeyMod.CtrlCmd | KeyCode.KEY_P,"}
{"input":"<s> function getKeyValue(key) {<EOL>    let value = window.localStorage.getItem(key);<EOL>    if (!value) {<EOL>        var name = key + \"<STR_LIT>\";<EOL>        var ca = document.cookie.split('<STR_LIT>');<EOL>        for (var i = <NUM_LIT>;","gt":"i < ca.length; i++) {"}
{"input":"<s> export function formatPII(value, excludePII, args) {<EOL>    return value.replace(_formatPIIRegexp, function (match, group) {<EOL>        if (excludePII && group.length > <NUM_LIT> && group[<NUM_LIT>] !== '<STR_LIT>') {<EOL>            return","gt":"match;"}
{"input":"<s> function toReadablePath(path) {<EOL>    if (!platform.isWindows) {<EOL>","gt":"return path;"}
{"input":"<s> function findSpecificGit(path) {<EOL>    return new TPromise((c, e) => {<EOL>        const buffers = [];<EOL>        const child =","gt":"spawn(path, ['<STR_LIT>']);"}
{"input":"<s> function fatal(err) {<EOL>    console.","gt":"error(err);"}
{"input":"<s> export function newConfigFile(value) {<EOL>    try {<EOL>        const root = Object.create(null);<EOL>        const contents = json.parse(value) || {};<EOL>        for (let key in contents) {<EOL>","gt":"model.setNode(root, key, contents[key]);"}
{"input":"<s> export function newConfigFile(value) {<EOL>    try {<EOL>        const root = Object.create(null);<EOL>        const contents = json.parse(value) || {};<EOL>        for (let key in contents) {<EOL>             model.setNode(root, key, contents[key]);<EOL>        }<EOL>        return {<EOL>            contents: root<EOL>        };<EOL>    }<EOL>    catch (e) {<EOL>        return {<EOL>","gt":"contents: {},"}
{"input":"<s> function _processThemeObject(themeId, themeDocument) {<EOL>    let cssRules = [];<EOL>    let themeSettings = themeDocument.settings;<EOL>    if (Array.","gt":"isArray(themeSettings)) {"}
{"input":"<s> function toResource(path) {<EOL>    return","gt":"URI.file(paths.join('<STR_LIT>', path));"}
{"input":"<s> <EOL>export function uniqueConstraint(constraintName, fields) {<EOL>    return (","gt":"target) => {"}
{"input":"<s> function getMapping(wetland, entity) {<EOL>    return wetland.getEntityManager().","gt":"getMapping(entity);"}
{"input":"<s> function testUsers(manager, bypassLifecyclehooks) {<EOL>    let usersFromFile = require(path.join(fixturesDir, getType(bypassLifecyclehooks), '<STR_LIT>'));<EOL>    return manager.getRepository(User)<EOL>        .find(null, { populate: ['<STR_LIT>'] })<EOL>        .","gt":"then((users) => {"}
{"input":"<s> export function createJsonHttp(xhrBackend, requestOptions) {<EOL>","gt":"const ngHttp = new Http(xhrBackend, requestOptions);"}
{"input":"<s> export default function Item(sources) {<EOL>    const state$ = sources.onion.state$;<EOL>    const vdom$ = state$.map((state) => li('<STR_LIT>', [<EOL>        span('<STR_LIT>', `<STR_LIT>`),<EOL>        span(","gt":"'<STR_LIT>', '<STR_LIT>'),"}
{"input":"<s> export default function Item(sources) {<EOL>    const state$ = sources.onion.state$;<EOL>    const vdom$ = state$.map((state) => li('<STR_LIT>', [<EOL>        span('<STR_LIT>', `<STR_LIT>`),<EOL>        span( '<STR_LIT>', '<STR_LIT>'),<EOL>        button('<STR_LIT>', '<STR_LIT>'),<EOL>        button('<STR_LIT>', '<STR_LIT>'),<EOL>        span('<STR_LIT>',","gt":"state.count}`<STR_LIT>,"}
{"input":"<s> export default function Item(sources) {<EOL>    const state$ = sources.onion.state$;<EOL>    const vdom$ = state$.map((state) => li('<STR_LIT>', [<EOL>        span('<STR_LIT>', `<STR_LIT>`),<EOL>        span( '<STR_LIT>', '<STR_LIT>'),<EOL>        button('<STR_LIT>', '<STR_LIT>'),<EOL>        button('<STR_LIT>', '<STR_LIT>'),<EOL>        span('<STR_LIT>', `<STR_LIT>`),<EOL>    ]));<EOL>    const removeReducer$ = sources.DOM<EOL>        .select('<STR_LIT>').events('<STR_LIT>')<EOL>        .mapTo(function removeReducer(prevState) {<EOL>","gt":"return void <NUM_LIT>;"}
{"input":"<s> export function joinNetwork(dat) {<EOL>    return Observable.","gt":"bindNodeCallback(dat.joinNetwork.bind(dat))();"}
{"input":"<s> function connectedPub(peer) {<EOL>    return peer.","gt":"state === '<STR_LIT>';"}
{"input":"<s> function isAddAttribute(diff) {<EOL>    return diff.","gt":"action === '<STR_LIT>';"}
{"input":"<s> function splitReplaceDiff(diff) {<EOL>    if (diff.action !== '<STR_LIT>') {<EOL>        return [diff];<EOL>    }<EOL>    if (!isWildcardComment(diff.oldValue)) {<EOL>        return [diff];<EOL>    }<EOL>    const removeDiff = {<EOL>        action: '<STR_LIT>',<EOL>        route: diff.route,<EOL>        element:","gt":"diff.oldValue,"}
{"input":"<s> function splitReplaceDiff(diff) {<EOL>    if (diff.action !== '<STR_LIT>') {<EOL>        return [diff];<EOL>    }<EOL>    if (!isWildcardComment(diff.oldValue)) {<EOL>        return [diff];<EOL>    }<EOL>    const removeDiff = {<EOL>        action: '<STR_LIT>',<EOL>        route: diff.route,<EOL>        element:  diff.oldValue,<EOL>    };<EOL>    const addDiff = {<EOL>        action:","gt":"'<STR_LIT>',"}
{"input":"<s> function isNotNull(x) {<EOL>    return x !==","gt":"null;"}
{"input":"<s> export function dialogDriver(request$) {<EOL>    const response$ = xs.create();<EOL>    request$.addListener({<EOL>        next: (request) => {<EOL>            const","gt":"category = request.category;"}
{"input":"<s> export function dialogDriver(request$) {<EOL>    const response$ = xs.create();<EOL>    request$.addListener({<EOL>        next: (request) => {<EOL>            const  category = request.category;<EOL>            const dialog = new DialogAndroid();<EOL>            dialog.set({<EOL>                ...","gt":"request,"}
{"input":"<s> export function dialogDriver(request$) {<EOL>    const response$ = xs.create();<EOL>    request$.addListener({<EOL>        next: (request) => {<EOL>            const  category = request.category;<EOL>            const dialog = new DialogAndroid();<EOL>            dialog.set({<EOL>                ... request,<EOL>                onPositive: () => {<EOL>                    response$.shamefullySendNext({ category, type: '<STR_LIT>' });<EOL>                },<EOL>                onNegative: () => {<EOL>                    response$.shamefullySendNext({ category, type:","gt":"'<STR_LIT>' });"}
{"input":"<s> export function isContactMsg(msg) {<EOL>    return msg.value.content &&","gt":"msg.value.content.type === '<STR_LIT>';"}
{"input":"<s> function cp(a) {<EOL>    const l = a.length;<EOL>","gt":"const b = Array(l);"}
{"input":"<s> export function getModule(name) {<EOL>","gt":"return modules.get(name);"}
{"input":"<s> export function rect() {<EOL>    return compile(`<STR_LIT>`)[","gt":"\"<STR_LIT>\"];"}
{"input":"<s> export function cloneDate(d) {<EOL>    return new Date(d.","gt":"getTime());"}
{"input":"<s> <EOL>export function AfterAll(n) {<EOL>    return","gt":"decorator(n);"}
{"input":"<s> <EOL>export function Delay(wait, ...args) {<EOL>    return decorator(","gt":"wait, ...args);"}
{"input":"<s> <EOL>export function Flow(...fns) {<EOL>    return","gt":"decorator(...fns);"}
{"input":"<s> <EOL>export function assignProperty(to, from, prop) {<EOL>    const descriptor = Object.getOwnPropertyDescriptor(to, prop);<EOL>    if (!descriptor || descriptor.configurable) {<EOL>        const srcDescriptor = Object.getOwnPropertyDescriptor(from, prop);<EOL>        if (","gt":"isObject(srcDescriptor)) {"}
{"input":"<s> <EOL>export function assignProperty(to, from, prop) {<EOL>    const descriptor = Object.getOwnPropertyDescriptor(to, prop);<EOL>    if (!descriptor || descriptor.configurable) {<EOL>        const srcDescriptor = Object.getOwnPropertyDescriptor(from, prop);<EOL>        if ( isObject(srcDescriptor)) {<EOL>            Object.defineProperty(to, prop, srcDescriptor);<EOL>        }<EOL>        else {<EOL>            to[","gt":"prop] = from[prop];"}
{"input":"<s> <EOL>export function bind(fn, context) {<EOL>    return copyMetadata(fn.","gt":"bind(context), fn);"}
{"input":"<s> <EOL>export function resolveFunction(method, context, target, throwNotFound = true) {<EOL>    if (isFunction(method)) {<EOL>        return method;<EOL>    }<EOL>    else if (isString(method)) {<EOL>        if (context &&","gt":"isFunction(context[method])) {"}
{"input":"<s> <EOL>async function authenticateRequest(getStrategy, request, setCurrentUser) {<EOL>    const strategy = await getStrategy();<EOL>    if (!strategy) {<EOL>        <EOL>","gt":"return undefined;"}
{"input":"<s> <EOL>async function authenticateRequest(getStrategy, request, setCurrentUser) {<EOL>    const strategy = await getStrategy();<EOL>    if (!strategy) {<EOL>        <EOL>         return undefined;<EOL>    }<EOL>    if (!strategy.authenticate) {<EOL>        return Promise.reject(new Error('<STR_LIT>'));<EOL>    }<EOL>    const strategyAdapter = new StrategyAdapter(strategy);<EOL>    const user = await","gt":"strategyAdapter.authenticate(request);"}
{"input":"<s> <EOL>function isBinding(element) {<EOL>    return element != null && element.","gt":"type === '<STR_LIT>';"}
{"input":"<s> <EOL>export function instantiateClass(ctor, ctx, session, <EOL><EOL>nonInjectedArgs) {<EOL>    <EOL>    if (debug.enabled) {<EOL>        debug('<STR_LIT>',","gt":"getTargetName(ctor));"}
{"input":"<s> <EOL>export function instantiateClass(ctor, ctx, session, <EOL><EOL>nonInjectedArgs) {<EOL>    <EOL>    if (debug.enabled) {<EOL>        debug('<STR_LIT>',  getTargetName(ctor));<EOL>        if (nonInjectedArgs && nonInjectedArgs.length) {<EOL>            debug(","gt":"'<STR_LIT>', nonInjectedArgs);"}
{"input":"<s> <EOL>export function instantiateClass(ctor, ctx, session, <EOL><EOL>nonInjectedArgs) {<EOL>    <EOL>    if (debug.enabled) {<EOL>        debug('<STR_LIT>',  getTargetName(ctor));<EOL>        if (nonInjectedArgs && nonInjectedArgs.length) {<EOL>            debug( '<STR_LIT>', nonInjectedArgs);<EOL>        }<EOL>    }<EOL>    const argsOrPromise = resolveInjectedArguments(ctor, '<STR_LIT>', ctx, session);<EOL>    const propertiesOrPromise = resolveInjectedProperties(ctor, ctx, session);<EOL>    let inst;<EOL>    if (","gt":"isPromise(argsOrPromise)) {"}
{"input":"<s> <EOL>export function instantiateClass(ctor, ctx, session, <EOL><EOL>nonInjectedArgs) {<EOL>    <EOL>    if (debug.enabled) {<EOL>        debug('<STR_LIT>',  getTargetName(ctor));<EOL>        if (nonInjectedArgs && nonInjectedArgs.length) {<EOL>            debug( '<STR_LIT>', nonInjectedArgs);<EOL>        }<EOL>    }<EOL>    const argsOrPromise = resolveInjectedArguments(ctor, '<STR_LIT>', ctx, session);<EOL>    const propertiesOrPromise = resolveInjectedProperties(ctor, ctx, session);<EOL>    let inst;<EOL>    if ( isPromise(argsOrPromise)) {<EOL>        <EOL>        inst = argsOrPromise.then((args) => {<EOL>            <EOL>            if (debug.enabled) {<EOL>                debug('<STR_LIT>', ctor.name, args);<EOL>            }<EOL>            return","gt":"new ctor(...args);"}
{"input":"<s> <EOL>export function instantiateClass(ctor, ctx, session, <EOL><EOL>nonInjectedArgs) {<EOL>    <EOL>    if (debug.enabled) {<EOL>        debug('<STR_LIT>',  getTargetName(ctor));<EOL>        if (nonInjectedArgs && nonInjectedArgs.length) {<EOL>            debug( '<STR_LIT>', nonInjectedArgs);<EOL>        }<EOL>    }<EOL>    const argsOrPromise = resolveInjectedArguments(ctor, '<STR_LIT>', ctx, session);<EOL>    const propertiesOrPromise = resolveInjectedProperties(ctor, ctx, session);<EOL>    let inst;<EOL>    if ( isPromise(argsOrPromise)) {<EOL>        <EOL>        inst = argsOrPromise.then((args) => {<EOL>            <EOL>            if (debug.enabled) {<EOL>                debug('<STR_LIT>', ctor.name, args);<EOL>            }<EOL>            return  new ctor(...args);<EOL>        });<EOL>    }<EOL>    else {<EOL>        <EOL>        if (debug.enabled) {<EOL>            debug(","gt":"'<STR_LIT>', ctor.name, argsOrPromise);"}
{"input":"<s> <EOL>export function instantiateClass(ctor, ctx, session, <EOL><EOL>nonInjectedArgs) {<EOL>    <EOL>    if (debug.enabled) {<EOL>        debug('<STR_LIT>',  getTargetName(ctor));<EOL>        if (nonInjectedArgs && nonInjectedArgs.length) {<EOL>            debug( '<STR_LIT>', nonInjectedArgs);<EOL>        }<EOL>    }<EOL>    const argsOrPromise = resolveInjectedArguments(ctor, '<STR_LIT>', ctx, session);<EOL>    const propertiesOrPromise = resolveInjectedProperties(ctor, ctx, session);<EOL>    let inst;<EOL>    if ( isPromise(argsOrPromise)) {<EOL>        <EOL>        inst = argsOrPromise.then((args) => {<EOL>            <EOL>            if (debug.enabled) {<EOL>                debug('<STR_LIT>', ctor.name, args);<EOL>            }<EOL>            return  new ctor(...args);<EOL>        });<EOL>    }<EOL>    else {<EOL>        <EOL>        if (debug.enabled) {<EOL>            debug( '<STR_LIT>', ctor.name, argsOrPromise);<EOL>        }<EOL>        <EOL>        inst = new ctor(...argsOrPromise);<EOL>    }<EOL>    if (isPromise(propertiesOrPromise)) {<EOL>        return propertiesOrPromise.then((props) => {<EOL>            <EOL>            if (","gt":"debug.enabled) {"}
{"input":"<s> <EOL>export function instantiateClass(ctor, ctx, session, <EOL><EOL>nonInjectedArgs) {<EOL>    <EOL>    if (debug.enabled) {<EOL>        debug('<STR_LIT>',  getTargetName(ctor));<EOL>        if (nonInjectedArgs && nonInjectedArgs.length) {<EOL>            debug( '<STR_LIT>', nonInjectedArgs);<EOL>        }<EOL>    }<EOL>    const argsOrPromise = resolveInjectedArguments(ctor, '<STR_LIT>', ctx, session);<EOL>    const propertiesOrPromise = resolveInjectedProperties(ctor, ctx, session);<EOL>    let inst;<EOL>    if ( isPromise(argsOrPromise)) {<EOL>        <EOL>        inst = argsOrPromise.then((args) => {<EOL>            <EOL>            if (debug.enabled) {<EOL>                debug('<STR_LIT>', ctor.name, args);<EOL>            }<EOL>            return  new ctor(...args);<EOL>        });<EOL>    }<EOL>    else {<EOL>        <EOL>        if (debug.enabled) {<EOL>            debug( '<STR_LIT>', ctor.name, argsOrPromise);<EOL>        }<EOL>        <EOL>        inst = new ctor(...argsOrPromise);<EOL>    }<EOL>    if (isPromise(propertiesOrPromise)) {<EOL>        return propertiesOrPromise.then((props) => {<EOL>            <EOL>            if ( debug.enabled) {<EOL>                debug('<STR_LIT>', ctor.name, props);<EOL>            }<EOL>            if (isPromise(inst)) {<EOL>                <EOL>                return inst.then((obj) => Object.assign(obj, props));<EOL>            }<EOL>            else {<EOL>                <EOL>                return Object.assign(inst, props);<EOL>            }<EOL>        });<EOL>    }<EOL>    else {<EOL>        if (isPromise(inst)) {<EOL>            <EOL>","gt":"if (debug.enabled) {"}
{"input":"<s> <EOL>export function createEmptyApiSpec() {<EOL>    return {<EOL>        swagger: '<STR_LIT>',<EOL>","gt":"basePath: '<STR_LIT>',"}
{"input":"<s> <EOL><EOL>function ensurePromise(p) {<EOL>    if (p && isPromise(p)) {<EOL>","gt":"return p;"}
{"input":"<s> <EOL>export function writeErrorToResponse(response, error) {<EOL>    const e = error;<EOL>    const statusCode = (response.statusCode = e.statusCode || e.status || <NUM_LIT>);<EOL>    if (e.headers) {<EOL>        <EOL>        for (const","gt":"h in e.headers) {"}
{"input":"<s> <EOL>export function writeErrorToResponse(response, error) {<EOL>    const e = error;<EOL>    const statusCode = (response.statusCode = e.statusCode || e.status || <NUM_LIT>);<EOL>    if (e.headers) {<EOL>        <EOL>        for (const  h in e.headers) {<EOL>            response.setHeader(h, e.headers[h]);<EOL>        }<EOL>    }<EOL>    <EOL>    const errObj = {<EOL>","gt":"statusCode,"}
{"input":"<s> <EOL>export function createClientForHandler(handler) {<EOL>","gt":"const server = http.createServer(handler);"}
{"input":"<s> export default function getPaths(callback) {<EOL>    let dataPath;<EOL>    let corePath = argv[\"<STR_LIT>\"] != null ? path.resolve(argv[\"<STR_LIT>\"]) : null;<EOL>    if (corePath != null) {<EOL>","gt":"dataPath = corePath;"}
{"input":"<s> export default function getPaths(callback) {<EOL>    let dataPath;<EOL>    let corePath = argv[\"<STR_LIT>\"] != null ? path.resolve(argv[\"<STR_LIT>\"]) : null;<EOL>    if (corePath != null) {<EOL>         dataPath = corePath;<EOL>        process.nextTick(() => { callback(null, corePath, dataPath); });<EOL>","gt":"return;"}
{"input":"<s> export default function getPaths(callback) {<EOL>    let dataPath;<EOL>    let corePath = argv[\"<STR_LIT>\"] != null ? path.resolve(argv[\"<STR_LIT>\"]) : null;<EOL>    if (corePath != null) {<EOL>         dataPath = corePath;<EOL>        process.nextTick(() => { callback(null, corePath, dataPath); });<EOL>         return;<EOL>    }<EOL>    try {<EOL>        dataPath = path.join(","gt":"electron.app.getPath(\"<STR_LIT>\"), \"<STR_LIT>\");"}
{"input":"<s> export default function getPaths(callback) {<EOL>    let dataPath;<EOL>    let corePath = argv[\"<STR_LIT>\"] != null ? path.resolve(argv[\"<STR_LIT>\"]) : null;<EOL>    if (corePath != null) {<EOL>         dataPath = corePath;<EOL>        process.nextTick(() => { callback(null, corePath, dataPath); });<EOL>         return;<EOL>    }<EOL>    try {<EOL>        dataPath = path.join( electron.app.getPath(\"<STR_LIT>\"), \"<STR_LIT>\");<EOL>    }<EOL>    catch (err) {<EOL>        process.nextTick(() => { callback(new LocalizedError(\"<STR_LIT>\", { details: err.message })); });<EOL>        return;<EOL>    }<EOL>    console.","gt":"log(dataPath);"}
{"input":"<s> export default function getPaths(callback) {<EOL>    let dataPath;<EOL>    let corePath = argv[\"<STR_LIT>\"] != null ? path.resolve(argv[\"<STR_LIT>\"]) : null;<EOL>    if (corePath != null) {<EOL>         dataPath = corePath;<EOL>        process.nextTick(() => { callback(null, corePath, dataPath); });<EOL>         return;<EOL>    }<EOL>    try {<EOL>        dataPath = path.join( electron.app.getPath(\"<STR_LIT>\"), \"<STR_LIT>\");<EOL>    }<EOL>    catch (err) {<EOL>        process.nextTick(() => { callback(new LocalizedError(\"<STR_LIT>\", { details: err.message })); });<EOL>        return;<EOL>    }<EOL>    console. log(dataPath);<EOL>    if (!fs.existsSync(dataPath)) {<EOL>        <EOL>        <EOL>        let oldDataPath;<EOL>        switch (","gt":"process.platform) {"}
{"input":"<s> export default function getPaths(callback) {<EOL>    let dataPath;<EOL>    let corePath = argv[\"<STR_LIT>\"] != null ? path.resolve(argv[\"<STR_LIT>\"]) : null;<EOL>    if (corePath != null) {<EOL>         dataPath = corePath;<EOL>        process.nextTick(() => { callback(null, corePath, dataPath); });<EOL>         return;<EOL>    }<EOL>    try {<EOL>        dataPath = path.join( electron.app.getPath(\"<STR_LIT>\"), \"<STR_LIT>\");<EOL>    }<EOL>    catch (err) {<EOL>        process.nextTick(() => { callback(new LocalizedError(\"<STR_LIT>\", { details: err.message })); });<EOL>        return;<EOL>    }<EOL>    console. log(dataPath);<EOL>    if (!fs.existsSync(dataPath)) {<EOL>        <EOL>        <EOL>        let oldDataPath;<EOL>        switch ( process.platform) {<EOL>            case \"<STR_LIT>\":<EOL>                if (process.env.APPDATA != null)<EOL>                    oldDataPath = path.join(process.env.APPDATA, \"<STR_LIT>\");<EOL>                break;<EOL>            case \"<STR_LIT>\":<EOL>                if (","gt":"process.env.HOME != null)"}
{"input":"<s> export default function getPaths(callback) {<EOL>    let dataPath;<EOL>    let corePath = argv[\"<STR_LIT>\"] != null ? path.resolve(argv[\"<STR_LIT>\"]) : null;<EOL>    if (corePath != null) {<EOL>         dataPath = corePath;<EOL>        process.nextTick(() => { callback(null, corePath, dataPath); });<EOL>         return;<EOL>    }<EOL>    try {<EOL>        dataPath = path.join( electron.app.getPath(\"<STR_LIT>\"), \"<STR_LIT>\");<EOL>    }<EOL>    catch (err) {<EOL>        process.nextTick(() => { callback(new LocalizedError(\"<STR_LIT>\", { details: err.message })); });<EOL>        return;<EOL>    }<EOL>    console. log(dataPath);<EOL>    if (!fs.existsSync(dataPath)) {<EOL>        <EOL>        <EOL>        let oldDataPath;<EOL>        switch ( process.platform) {<EOL>            case \"<STR_LIT>\":<EOL>                if (process.env.APPDATA != null)<EOL>                    oldDataPath = path.join(process.env.APPDATA, \"<STR_LIT>\");<EOL>                break;<EOL>            case \"<STR_LIT>\":<EOL>                if ( process.env.HOME != null)<EOL>                    oldDataPath = path.join(process.env.HOME, \"<STR_LIT>\", \"<STR_LIT>\");<EOL>                break;<EOL>            default:<EOL>                if (process.env.XDG_DATA_HOME != null)<EOL>                    oldDataPath = path.join(process.env.XDG_DATA_HOME, \"<STR_LIT>\");<EOL>                else if (process.env.HOME != null)<EOL>                    oldDataPath = path.join(process.env.HOME, \"<STR_LIT>\", \"<STR_LIT>\");<EOL>        }<EOL>        if (oldDataPath != null && fs.existsSync(oldDataPath)) {<EOL>","gt":"console.log(`<STR_LIT>`);"}
{"input":"<s> export default function getPaths(callback) {<EOL>    let dataPath;<EOL>    let corePath = argv[\"<STR_LIT>\"] != null ? path.resolve(argv[\"<STR_LIT>\"]) : null;<EOL>    if (corePath != null) {<EOL>         dataPath = corePath;<EOL>        process.nextTick(() => { callback(null, corePath, dataPath); });<EOL>         return;<EOL>    }<EOL>    try {<EOL>        dataPath = path.join( electron.app.getPath(\"<STR_LIT>\"), \"<STR_LIT>\");<EOL>    }<EOL>    catch (err) {<EOL>        process.nextTick(() => { callback(new LocalizedError(\"<STR_LIT>\", { details: err.message })); });<EOL>        return;<EOL>    }<EOL>    console. log(dataPath);<EOL>    if (!fs.existsSync(dataPath)) {<EOL>        <EOL>        <EOL>        let oldDataPath;<EOL>        switch ( process.platform) {<EOL>            case \"<STR_LIT>\":<EOL>                if (process.env.APPDATA != null)<EOL>                    oldDataPath = path.join(process.env.APPDATA, \"<STR_LIT>\");<EOL>                break;<EOL>            case \"<STR_LIT>\":<EOL>                if ( process.env.HOME != null)<EOL>                    oldDataPath = path.join(process.env.HOME, \"<STR_LIT>\", \"<STR_LIT>\");<EOL>                break;<EOL>            default:<EOL>                if (process.env.XDG_DATA_HOME != null)<EOL>                    oldDataPath = path.join(process.env.XDG_DATA_HOME, \"<STR_LIT>\");<EOL>                else if (process.env.HOME != null)<EOL>                    oldDataPath = path.join(process.env.HOME, \"<STR_LIT>\", \"<STR_LIT>\");<EOL>        }<EOL>        if (oldDataPath != null && fs.existsSync(oldDataPath)) {<EOL>             console.log(`<STR_LIT>`);<EOL>            fs.renameSync(oldDataPath, dataPath);<EOL>        }<EOL>    }<EOL>    corePath = path.join(dataPath, \"<STR_LIT>\");<EOL>    fs.mkdir(dataPath, (err) => {<EOL>        if (err !=","gt":"null && err.code !== \"<STR_LIT>\") {"}
{"input":"<s> export function onPresenceUpdated() {<EOL>    if (settings.presence !== \"<STR_LIT>\") {<EOL>        if (socket == null)<EOL>            connect();<EOL>","gt":"else {"}
{"input":"<s> export function onPresenceUpdated() {<EOL>    if (settings.presence !== \"<STR_LIT>\") {<EOL>        if (socket == null)<EOL>            connect();<EOL>         else {<EOL>            <EOL>            <EOL>            irc.write(`<STR_LIT>`);<EOL>        }<EOL>    }<EOL>","gt":"else {"}
{"input":"<s> export function setStatus(text) {<EOL>","gt":"statusElt.textContent = text;"}
{"input":"<s> export function load(contextNames, callback) {<EOL>    async.each(contextNames, loadContext.bind(null, languageCode, contexts), () => {<EOL>        if (languageCode === \"<STR_LIT>\") {<EOL>","gt":"callback();"}
{"input":"<s> function onDisconnected() {<EOL>    SupClient.Dialogs.cancelDialogIfAny();<EOL>    data.projects = null;<EOL>","gt":"ui.projectsTreeView.clearSelection();"}
{"input":"<s> function onClickToggleNotifications(event) {<EOL>    let notificationsDisabled = (localStorage.getItem(\"<STR_LIT>\") != null) ? true : false;<EOL>    notificationsDisabled = !notificationsDisabled;<EOL>    if (!notificationsDisabled) {<EOL>        localStorage.removeItem(","gt":"\"<STR_LIT>\");"}
{"input":"<s> function onClickToggleNotifications(event) {<EOL>    let notificationsDisabled = (localStorage.getItem(\"<STR_LIT>\") != null) ? true : false;<EOL>    notificationsDisabled = !notificationsDisabled;<EOL>    if (!notificationsDisabled) {<EOL>        localStorage.removeItem( \"<STR_LIT>\");<EOL>        event.target.classList.remove(\"<STR_LIT>\");<EOL>        event.target.title = SupClient.i18n.t(\"<STR_LIT>\");<EOL>    }<EOL>    else {<EOL>        localStorage.setItem(\"<STR_LIT>\", \"<STR_LIT>\");<EOL>        event.target.classList.","gt":"add(\"<STR_LIT>\");"}
{"input":"<s> function onSetEntryProperty(id, key, value) {<EOL>    entries.client_setProperty(id, key, value);<EOL>    const entryElt = entriesTreeView.widget.treeRoot.querySelector(`<STR_LIT>`);<EOL>    switch (key) {<EOL>        case \"<STR_LIT>\":<EOL>            entryElt.","gt":"querySelector(\"<STR_LIT>\").textContent = value;"}
{"input":"<s> function onSetManifestProperty(key, value) {<EOL>    manifest.client_setProperty(key, value);<EOL>    switch (key) {<EOL>","gt":"case \"<STR_LIT>\":"}
{"input":"<s> function destroyRunWindow() {<EOL>    runWindowDestroyTimeout = null;<EOL>","gt":"if (runWindow != null) {"}
{"input":"<s> function initPlugin(systemFolderName, systemId, pluginName) {<EOL>    const pluginSlug = pluginName.replace(/\\//g, \"<STR_LIT>\").replace(/[A-Z]/g, (x) => `<STR_LIT>`);<EOL>    const packageJSON = JSON.stringify({<EOL>        name: `<STR_LIT>`,<EOL>        description: `<STR_LIT>`,<EOL>","gt":"scripts: {"}
{"input":"<s> function initPlugin(systemFolderName, systemId, pluginName) {<EOL>    const pluginSlug = pluginName.replace(/\\//g, \"<STR_LIT>\").replace(/[A-Z]/g, (x) => `<STR_LIT>`);<EOL>    const packageJSON = JSON.stringify({<EOL>        name: `<STR_LIT>`,<EOL>        description: `<STR_LIT>`,<EOL>         scripts: {<EOL>            \"<STR_LIT>\": \"<STR_LIT>\"<EOL>        }<EOL>    }, null, <NUM_LIT>) + \"<STR_LIT>\";<EOL>    const pluginPath =","gt":"}/${systemFolderName}/plugins/${pluginName}`<STR_LIT>;"}
{"input":"<s> function initPlugin(systemFolderName, systemId, pluginName) {<EOL>    const pluginSlug = pluginName.replace(/\\//g, \"<STR_LIT>\").replace(/[A-Z]/g, (x) => `<STR_LIT>`);<EOL>    const packageJSON = JSON.stringify({<EOL>        name: `<STR_LIT>`,<EOL>        description: `<STR_LIT>`,<EOL>         scripts: {<EOL>            \"<STR_LIT>\": \"<STR_LIT>\"<EOL>        }<EOL>    }, null, <NUM_LIT>) + \"<STR_LIT>\";<EOL>    const pluginPath = `<STR_LIT>`;<EOL>    mkdirp.sync(pluginPath);<EOL>    fs.writeFileSync(`<STR_LIT>`, packageJSON);<EOL>    const tsconfigJSON = JSON.","gt":"stringify({"}
{"input":"<s> function initPlugin(systemFolderName, systemId, pluginName) {<EOL>    const pluginSlug = pluginName.replace(/\\//g, \"<STR_LIT>\").replace(/[A-Z]/g, (x) => `<STR_LIT>`);<EOL>    const packageJSON = JSON.stringify({<EOL>        name: `<STR_LIT>`,<EOL>        description: `<STR_LIT>`,<EOL>         scripts: {<EOL>            \"<STR_LIT>\": \"<STR_LIT>\"<EOL>        }<EOL>    }, null, <NUM_LIT>) + \"<STR_LIT>\";<EOL>    const pluginPath = `<STR_LIT>`;<EOL>    mkdirp.sync(pluginPath);<EOL>    fs.writeFileSync(`<STR_LIT>`, packageJSON);<EOL>    const tsconfigJSON = JSON. stringify({<EOL>        \"<STR_LIT>\": {<EOL>            \"<STR_LIT>\": \"<STR_LIT>\",<EOL>","gt":"\"<STR_LIT>\": \"<STR_LIT>\","}
{"input":"<s> function initPlugin(systemFolderName, systemId, pluginName) {<EOL>    const pluginSlug = pluginName.replace(/\\//g, \"<STR_LIT>\").replace(/[A-Z]/g, (x) => `<STR_LIT>`);<EOL>    const packageJSON = JSON.stringify({<EOL>        name: `<STR_LIT>`,<EOL>        description: `<STR_LIT>`,<EOL>         scripts: {<EOL>            \"<STR_LIT>\": \"<STR_LIT>\"<EOL>        }<EOL>    }, null, <NUM_LIT>) + \"<STR_LIT>\";<EOL>    const pluginPath = `<STR_LIT>`;<EOL>    mkdirp.sync(pluginPath);<EOL>    fs.writeFileSync(`<STR_LIT>`, packageJSON);<EOL>    const tsconfigJSON = JSON. stringify({<EOL>        \"<STR_LIT>\": {<EOL>            \"<STR_LIT>\": \"<STR_LIT>\",<EOL>             \"<STR_LIT>\": \"<STR_LIT>\",<EOL>            \"<STR_LIT>\": true,<EOL>            \"<STR_LIT>\": [\"<STR_LIT>\"]<EOL>        },<EOL>        \"<STR_LIT>\": [<EOL>","gt":"\"<STR_LIT>\","}
{"input":"<s> function onKeyDown(event) {<EOL>    <EOL>    if (event.keyCode === <NUM_LIT>) {<EOL>","gt":"sendHotkey(\"<STR_LIT>\");"}
{"input":"<s> function onKeyDown(event) {<EOL>    <EOL>    if (event.keyCode === <NUM_LIT>) {<EOL>         sendHotkey(\"<STR_LIT>\");<EOL>        return;<EOL>    }<EOL>    <EOL>    if (event.keyCode === <NUM_LIT>)<EOL>        isBackspaceDown = true;<EOL>    if (dialogs.BaseDialog.","gt":"activeDialog != null)"}
{"input":"<s> function onKeyDown(event) {<EOL>    <EOL>    if (event.keyCode === <NUM_LIT>) {<EOL>         sendHotkey(\"<STR_LIT>\");<EOL>        return;<EOL>    }<EOL>    <EOL>    if (event.keyCode === <NUM_LIT>)<EOL>        isBackspaceDown = true;<EOL>    if (dialogs.BaseDialog. activeDialog != null)<EOL>        return;<EOL>    const ctrlOrCmd = event.ctrlKey || event.metaKey;<EOL>    <EOL>    if (event.","gt":"keyCode === <NUM_LIT> && ctrlOrCmd) {"}
{"input":"<s> function onKeyDown(event) {<EOL>    <EOL>    if (event.keyCode === <NUM_LIT>) {<EOL>         sendHotkey(\"<STR_LIT>\");<EOL>        return;<EOL>    }<EOL>    <EOL>    if (event.keyCode === <NUM_LIT>)<EOL>        isBackspaceDown = true;<EOL>    if (dialogs.BaseDialog. activeDialog != null)<EOL>        return;<EOL>    const ctrlOrCmd = event.ctrlKey || event.metaKey;<EOL>    <EOL>    if (event. keyCode === <NUM_LIT> && ctrlOrCmd) {<EOL>        event.","gt":"preventDefault();"}
{"input":"<s> function onKeyDown(event) {<EOL>    <EOL>    if (event.keyCode === <NUM_LIT>) {<EOL>         sendHotkey(\"<STR_LIT>\");<EOL>        return;<EOL>    }<EOL>    <EOL>    if (event.keyCode === <NUM_LIT>)<EOL>        isBackspaceDown = true;<EOL>    if (dialogs.BaseDialog. activeDialog != null)<EOL>        return;<EOL>    const ctrlOrCmd = event.ctrlKey || event.metaKey;<EOL>    <EOL>    if (event. keyCode === <NUM_LIT> && ctrlOrCmd) {<EOL>        event. preventDefault();<EOL>        if (event.shiftKey)<EOL>            sendHotkey(\"<STR_LIT>\");<EOL>        else<EOL>            sendHotkey(\"<STR_LIT>\");<EOL>        return;<EOL>    }<EOL>    <EOL>    if ((event.keyCode === <NUM_LIT> || event.keyCode === <NUM_LIT>) && ctrlOrCmd) {<EOL>        event.preventDefault();<EOL>        sendHotkey(\"<STR_LIT>\");<EOL>        return;<EOL>    }<EOL>    <EOL>    if (event.","gt":"keyCode === <NUM_LIT> && ctrlOrCmd) {"}
{"input":"<s> function onKeyDown(event) {<EOL>    <EOL>    if (event.keyCode === <NUM_LIT>) {<EOL>         sendHotkey(\"<STR_LIT>\");<EOL>        return;<EOL>    }<EOL>    <EOL>    if (event.keyCode === <NUM_LIT>)<EOL>        isBackspaceDown = true;<EOL>    if (dialogs.BaseDialog. activeDialog != null)<EOL>        return;<EOL>    const ctrlOrCmd = event.ctrlKey || event.metaKey;<EOL>    <EOL>    if (event. keyCode === <NUM_LIT> && ctrlOrCmd) {<EOL>        event. preventDefault();<EOL>        if (event.shiftKey)<EOL>            sendHotkey(\"<STR_LIT>\");<EOL>        else<EOL>            sendHotkey(\"<STR_LIT>\");<EOL>        return;<EOL>    }<EOL>    <EOL>    if ((event.keyCode === <NUM_LIT> || event.keyCode === <NUM_LIT>) && ctrlOrCmd) {<EOL>        event.preventDefault();<EOL>        sendHotkey(\"<STR_LIT>\");<EOL>        return;<EOL>    }<EOL>    <EOL>    if (event. keyCode === <NUM_LIT> && ctrlOrCmd) {<EOL>        event.preventDefault();<EOL>        sendHotkey(\"<STR_LIT>\");<EOL>        return;<EOL>    }<EOL>    <EOL>    if (event.keyCode === <NUM_LIT> && event.ctrlKey) {<EOL>        event.preventDefault();<EOL>","gt":"if (event.shiftKey)"}
{"input":"<s> function onKeyDown(event) {<EOL>    <EOL>    if (event.keyCode === <NUM_LIT>) {<EOL>         sendHotkey(\"<STR_LIT>\");<EOL>        return;<EOL>    }<EOL>    <EOL>    if (event.keyCode === <NUM_LIT>)<EOL>        isBackspaceDown = true;<EOL>    if (dialogs.BaseDialog. activeDialog != null)<EOL>        return;<EOL>    const ctrlOrCmd = event.ctrlKey || event.metaKey;<EOL>    <EOL>    if (event. keyCode === <NUM_LIT> && ctrlOrCmd) {<EOL>        event. preventDefault();<EOL>        if (event.shiftKey)<EOL>            sendHotkey(\"<STR_LIT>\");<EOL>        else<EOL>            sendHotkey(\"<STR_LIT>\");<EOL>        return;<EOL>    }<EOL>    <EOL>    if ((event.keyCode === <NUM_LIT> || event.keyCode === <NUM_LIT>) && ctrlOrCmd) {<EOL>        event.preventDefault();<EOL>        sendHotkey(\"<STR_LIT>\");<EOL>        return;<EOL>    }<EOL>    <EOL>    if (event. keyCode === <NUM_LIT> && ctrlOrCmd) {<EOL>        event.preventDefault();<EOL>        sendHotkey(\"<STR_LIT>\");<EOL>        return;<EOL>    }<EOL>    <EOL>    if (event.keyCode === <NUM_LIT> && event.ctrlKey) {<EOL>        event.preventDefault();<EOL>         if (event.shiftKey)<EOL>            sendHotkey(\"<STR_LIT>\");<EOL>        else<EOL>            sendHotkey(\"<STR_LIT>\");<EOL>","gt":"return;"}
{"input":"<s> function onKeyDown(event) {<EOL>    <EOL>    if (event.keyCode === <NUM_LIT>) {<EOL>         sendHotkey(\"<STR_LIT>\");<EOL>        return;<EOL>    }<EOL>    <EOL>    if (event.keyCode === <NUM_LIT>)<EOL>        isBackspaceDown = true;<EOL>    if (dialogs.BaseDialog. activeDialog != null)<EOL>        return;<EOL>    const ctrlOrCmd = event.ctrlKey || event.metaKey;<EOL>    <EOL>    if (event. keyCode === <NUM_LIT> && ctrlOrCmd) {<EOL>        event. preventDefault();<EOL>        if (event.shiftKey)<EOL>            sendHotkey(\"<STR_LIT>\");<EOL>        else<EOL>            sendHotkey(\"<STR_LIT>\");<EOL>        return;<EOL>    }<EOL>    <EOL>    if ((event.keyCode === <NUM_LIT> || event.keyCode === <NUM_LIT>) && ctrlOrCmd) {<EOL>        event.preventDefault();<EOL>        sendHotkey(\"<STR_LIT>\");<EOL>        return;<EOL>    }<EOL>    <EOL>    if (event. keyCode === <NUM_LIT> && ctrlOrCmd) {<EOL>        event.preventDefault();<EOL>        sendHotkey(\"<STR_LIT>\");<EOL>        return;<EOL>    }<EOL>    <EOL>    if (event.keyCode === <NUM_LIT> && event.ctrlKey) {<EOL>        event.preventDefault();<EOL>         if (event.shiftKey)<EOL>            sendHotkey(\"<STR_LIT>\");<EOL>        else<EOL>            sendHotkey(\"<STR_LIT>\");<EOL>         return;<EOL>    }<EOL>    <EOL>    if (event.keyCode === <NUM_LIT>) {<EOL>        event.preventDefault();<EOL>        if (helpCallback != null)<EOL>            helpCallback();<EOL>        return;<EOL>    }<EOL>    <EOL>    if (event.keyCode === <NUM_LIT> || (event.keyCode === <NUM_LIT> && event.","gt":"metaKey)) {"}
{"input":"<s> function onKeyDown(event) {<EOL>    <EOL>    if (event.keyCode === <NUM_LIT>) {<EOL>         sendHotkey(\"<STR_LIT>\");<EOL>        return;<EOL>    }<EOL>    <EOL>    if (event.keyCode === <NUM_LIT>)<EOL>        isBackspaceDown = true;<EOL>    if (dialogs.BaseDialog. activeDialog != null)<EOL>        return;<EOL>    const ctrlOrCmd = event.ctrlKey || event.metaKey;<EOL>    <EOL>    if (event. keyCode === <NUM_LIT> && ctrlOrCmd) {<EOL>        event. preventDefault();<EOL>        if (event.shiftKey)<EOL>            sendHotkey(\"<STR_LIT>\");<EOL>        else<EOL>            sendHotkey(\"<STR_LIT>\");<EOL>        return;<EOL>    }<EOL>    <EOL>    if ((event.keyCode === <NUM_LIT> || event.keyCode === <NUM_LIT>) && ctrlOrCmd) {<EOL>        event.preventDefault();<EOL>        sendHotkey(\"<STR_LIT>\");<EOL>        return;<EOL>    }<EOL>    <EOL>    if (event. keyCode === <NUM_LIT> && ctrlOrCmd) {<EOL>        event.preventDefault();<EOL>        sendHotkey(\"<STR_LIT>\");<EOL>        return;<EOL>    }<EOL>    <EOL>    if (event.keyCode === <NUM_LIT> && event.ctrlKey) {<EOL>        event.preventDefault();<EOL>         if (event.shiftKey)<EOL>            sendHotkey(\"<STR_LIT>\");<EOL>        else<EOL>            sendHotkey(\"<STR_LIT>\");<EOL>         return;<EOL>    }<EOL>    <EOL>    if (event.keyCode === <NUM_LIT>) {<EOL>        event.preventDefault();<EOL>        if (helpCallback != null)<EOL>            helpCallback();<EOL>        return;<EOL>    }<EOL>    <EOL>    if (event.keyCode === <NUM_LIT> || (event.keyCode === <NUM_LIT> && event. metaKey)) {<EOL>        event.preventDefault();<EOL>        sendHotkey(\"<STR_LIT>\");<EOL>        return;<EOL>    }<EOL>    <EOL>    if (event.keyCode === <NUM_LIT> || (event.keyCode === <NUM_LIT> && event.metaKey && event.","gt":"shiftKey)) {"}
{"input":"<s> export function getTreeViewInsertionPoint(treeView) {<EOL>    let selectedElt = treeView.selectedNodes[<NUM_LIT>];<EOL>    let parentId;<EOL>    let index;<EOL>    if (","gt":"selectedElt != null) {"}
{"input":"<s> export function getTreeViewInsertionPoint(treeView) {<EOL>    let selectedElt = treeView.selectedNodes[<NUM_LIT>];<EOL>    let parentId;<EOL>    let index;<EOL>    if ( selectedElt != null) {<EOL>        if (selectedElt.classList.contains(\"<STR_LIT>\")) {<EOL>            parentId = selectedElt.dataset[\"<STR_LIT>\"];<EOL>        }<EOL>        else {<EOL>            if (selectedElt.parentElement.classList.contains(\"<STR_LIT>\")) {<EOL>                parentId = selectedElt.parentElement.previousElementSibling != null ? selectedElt.parentElement.previousElementSibling.dataset[\"<STR_LIT>\"] : null;<EOL>            }<EOL>            index = <NUM_LIT>;<EOL>            while (selectedElt.previousElementSibling != null) {<EOL>                selectedElt = selectedElt.previousElementSibling;<EOL>                if (selectedElt.tagName === \"<STR_LIT>\")<EOL>","gt":"index++;"}
{"input":"<s> export default function readFile(file, type, callback) {<EOL>    const reader = new FileReader;<EOL>    reader.onload = (event) => {<EOL>        let data;<EOL>        if (type === \"<STR_LIT>\") {<EOL>            try {<EOL>","gt":"data = JSON.parse(event.target.result);"}
{"input":"<s> export default function readFile(file, type, callback) {<EOL>    const reader = new FileReader;<EOL>    reader.onload = (event) => {<EOL>        let data;<EOL>        if (type === \"<STR_LIT>\") {<EOL>            try {<EOL>                 data = JSON.parse(event.target.result);<EOL>            }<EOL>            catch (err) {<EOL>","gt":"callback(err, null);"}
{"input":"<s> export default function readFile(file, type, callback) {<EOL>    const reader = new FileReader;<EOL>    reader.onload = (event) => {<EOL>        let data;<EOL>        if (type === \"<STR_LIT>\") {<EOL>            try {<EOL>                 data = JSON.parse(event.target.result);<EOL>            }<EOL>            catch (err) {<EOL>                 callback(err, null);<EOL>                return;<EOL>            }<EOL>        }<EOL>        else {<EOL>            data = event.target.result;<EOL>        }<EOL>        callback(null, data);<EOL>    };<EOL>    switch (type) {<EOL>        case \"<STR_LIT>\":<EOL>        case \"<STR_LIT>\":<EOL>            reader.readAsText(file);<EOL>","gt":"break;"}
{"input":"<s> function onAssetReceived() {<EOL>    <EOL>    ui.nodesTreeView.clearSelection();<EOL>    ui.nodesTreeView.treeRoot.innerHTML = \"<STR_LIT>\";<EOL>    function walk(node, parentNode,","gt":"parentElt) {"}
{"input":"<s> function onAssetReceived() {<EOL>    <EOL>    ui.nodesTreeView.clearSelection();<EOL>    ui.nodesTreeView.treeRoot.innerHTML = \"<STR_LIT>\";<EOL>    function walk(node, parentNode,  parentElt) {<EOL>        const liElt = createNodeElement(node);<EOL>        ui.nodesTreeView.append(liElt, \"<STR_LIT>\", parentElt);<EOL>        if (node.children != null &&","gt":"node.children.length > <NUM_LIT>) {"}
{"input":"<s> function onAssetReceived() {<EOL>    <EOL>    ui.nodesTreeView.clearSelection();<EOL>    ui.nodesTreeView.treeRoot.innerHTML = \"<STR_LIT>\";<EOL>    function walk(node, parentNode,  parentElt) {<EOL>        const liElt = createNodeElement(node);<EOL>        ui.nodesTreeView.append(liElt, \"<STR_LIT>\", parentElt);<EOL>        if (node.children != null &&  node.children.length > <NUM_LIT>) {<EOL>            liElt.classList.add(\"<STR_LIT>\");<EOL>            for (const child of node.children)<EOL>                walk(child, node, liElt);<EOL>        }<EOL>    }<EOL>    for (const node of data.cubicModelUpdater.cubicModelAsset.nodes.pub)<EOL>        walk(node, null, null);<EOL>    const pub = data.cubicModelUpdater.cubicModelAsset.pub;<EOL>    ui.pixelsPerUnitInput.value = pub.pixelsPerUnit.","gt":"toString();"}
{"input":"<s> function onTransformModeClick(event) {<EOL>    const target = event.target;<EOL>    if (target.tagName !== \"<STR_LIT>\")<EOL>        return;<EOL>    if (target.id === \"<STR_LIT>\") {<EOL>        engine.transformHandleComponent.setSpace(target.checked ? \"<STR_LIT>\" : \"<STR_LIT>\");<EOL>    }<EOL>    else {<EOL>        const transformSpaceCheckbox = document.getElementById(\"<STR_LIT>\");<EOL>        transformSpaceCheckbox.disabled = target.value === \"<STR_LIT>\";<EOL>        engine.","gt":"transformHandleComponent.setMode(target.value);"}
{"input":"<s> function onTransformModeClick(event) {<EOL>    const target = event.target;<EOL>    if (target.tagName !== \"<STR_LIT>\")<EOL>        return;<EOL>    if (target.id === \"<STR_LIT>\") {<EOL>        engine.transformHandleComponent.setSpace(target.checked ? \"<STR_LIT>\" : \"<STR_LIT>\");<EOL>    }<EOL>    else {<EOL>        const transformSpaceCheckbox = document.getElementById(\"<STR_LIT>\");<EOL>        transformSpaceCheckbox.disabled = target.value === \"<STR_LIT>\";<EOL>        engine. transformHandleComponent.setMode(target.value);<EOL>        if (target.value === \"<STR_LIT>\") {<EOL>            ui.translateMode = target.dataset[\"<STR_LIT>\"];<EOL>            const linkShapeToPivot = document.getElementById(\"<STR_LIT>\").checked;<EOL>            if (ui.translateMode ===","gt":"\"<STR_LIT>\" && linkShapeToPivot)"}
{"input":"<s> export function lateStart(player, callback) {<EOL>    const sceneId = player.resources.gameSettings.startupSceneId;<EOL>    if (sceneId != null) {<EOL>        const","gt":"outerAsset = player.getOuterAsset(sceneId);"}
{"input":"<s> export function importComponent(entry, projectClient, nodeId, callback) {<EOL>    projectClient.editAsset(SupClient.query.asset, \"<STR_LIT>\", nodeId, \"<STR_LIT>\", null, (","gt":"componentId) => {"}
{"input":"<s> function onChangeActive() {<EOL>    const stopRendering = !hasStarted || !isTabActive;<EOL>    if (stopRendering) {<EOL>        if (animationFrame != null) {<EOL>","gt":"cancelAnimationFrame(animationFrame);"}
{"input":"<s> function onChangeActive() {<EOL>    const stopRendering = !hasStarted || !isTabActive;<EOL>    if (stopRendering) {<EOL>        if (animationFrame != null) {<EOL>             cancelAnimationFrame(animationFrame);<EOL>            animationFrame = null;<EOL>        }<EOL>    }<EOL>    else if (","gt":"animationFrame == null) {"}
{"input":"<s> function tick(timestamp = <NUM_LIT>) {<EOL>    accumulatedTime += timestamp - lastTimestamp;<EOL>    lastTimestamp = timestamp;<EOL>    const { updates, timeLeft } = engine.gameInstance.","gt":"tick(accumulatedTime, update);"}
{"input":"<s> export function setupAttribute(attribute) {<EOL>    const rowElt = document.createElement(\"<STR_LIT>\");<EOL>    rowElt.dataset[\"<STR_LIT>\"] = attribute.id;<EOL>","gt":"ui.attributesList.insertBefore(rowElt, ui.attributesList.lastChild);"}
{"input":"<s> export function setupAttribute(attribute) {<EOL>    const rowElt = document.createElement(\"<STR_LIT>\");<EOL>    rowElt.dataset[\"<STR_LIT>\"] = attribute.id;<EOL>     ui.attributesList.insertBefore(rowElt, ui.attributesList.lastChild);<EOL>    const nameElt = document.createElement(\"<STR_LIT>\");<EOL>    const nameInputElt = document.createElement(\"<STR_LIT>\");<EOL>    nameInputElt.classList.","gt":"add(\"<STR_LIT>\");"}
{"input":"<s> export function setupAttribute(attribute) {<EOL>    const rowElt = document.createElement(\"<STR_LIT>\");<EOL>    rowElt.dataset[\"<STR_LIT>\"] = attribute.id;<EOL>     ui.attributesList.insertBefore(rowElt, ui.attributesList.lastChild);<EOL>    const nameElt = document.createElement(\"<STR_LIT>\");<EOL>    const nameInputElt = document.createElement(\"<STR_LIT>\");<EOL>    nameInputElt.classList. add(\"<STR_LIT>\");<EOL>    nameInputElt.addEventListener(\"<STR_LIT>\", (event) => {<EOL>        if (event.target.value === \"<STR_LIT>\")<EOL>            data.projectClient.editAsset(SupClient.query.asset, \"<STR_LIT>\", rowElt.dataset[\"<STR_LIT>\"]);<EOL>        else<EOL>            data.projectClient.editAsset(SupClient.query.asset, \"<STR_LIT>\", rowElt.dataset[\"<STR_LIT>\"], \"<STR_LIT>\", event.target.value);<EOL>    });<EOL>    nameInputElt.value = attribute.","gt":"name;"}
{"input":"<s> export function setupAttribute(attribute) {<EOL>    const rowElt = document.createElement(\"<STR_LIT>\");<EOL>    rowElt.dataset[\"<STR_LIT>\"] = attribute.id;<EOL>     ui.attributesList.insertBefore(rowElt, ui.attributesList.lastChild);<EOL>    const nameElt = document.createElement(\"<STR_LIT>\");<EOL>    const nameInputElt = document.createElement(\"<STR_LIT>\");<EOL>    nameInputElt.classList. add(\"<STR_LIT>\");<EOL>    nameInputElt.addEventListener(\"<STR_LIT>\", (event) => {<EOL>        if (event.target.value === \"<STR_LIT>\")<EOL>            data.projectClient.editAsset(SupClient.query.asset, \"<STR_LIT>\", rowElt.dataset[\"<STR_LIT>\"]);<EOL>        else<EOL>            data.projectClient.editAsset(SupClient.query.asset, \"<STR_LIT>\", rowElt.dataset[\"<STR_LIT>\"], \"<STR_LIT>\", event.target.value);<EOL>    });<EOL>    nameInputElt.value = attribute. name;<EOL>    nameElt.appendChild(nameInputElt);<EOL>    rowElt.appendChild(nameElt);<EOL>    const typeElt = document.createElement(\"<STR_LIT>\");<EOL>    const","gt":"selectTypeElt = document.createElement(\"<STR_LIT>\");"}
{"input":"<s> export function setupAttribute(attribute) {<EOL>    const rowElt = document.createElement(\"<STR_LIT>\");<EOL>    rowElt.dataset[\"<STR_LIT>\"] = attribute.id;<EOL>     ui.attributesList.insertBefore(rowElt, ui.attributesList.lastChild);<EOL>    const nameElt = document.createElement(\"<STR_LIT>\");<EOL>    const nameInputElt = document.createElement(\"<STR_LIT>\");<EOL>    nameInputElt.classList. add(\"<STR_LIT>\");<EOL>    nameInputElt.addEventListener(\"<STR_LIT>\", (event) => {<EOL>        if (event.target.value === \"<STR_LIT>\")<EOL>            data.projectClient.editAsset(SupClient.query.asset, \"<STR_LIT>\", rowElt.dataset[\"<STR_LIT>\"]);<EOL>        else<EOL>            data.projectClient.editAsset(SupClient.query.asset, \"<STR_LIT>\", rowElt.dataset[\"<STR_LIT>\"], \"<STR_LIT>\", event.target.value);<EOL>    });<EOL>    nameInputElt.value = attribute. name;<EOL>    nameElt.appendChild(nameInputElt);<EOL>    rowElt.appendChild(nameElt);<EOL>    const typeElt = document.createElement(\"<STR_LIT>\");<EOL>    const  selectTypeElt = document.createElement(\"<STR_LIT>\");<EOL>    for (const type of Attributes.schema[\"<STR_LIT>\"].items) {<EOL>        const optionElt = document.createElement(\"<STR_LIT>\");<EOL>        optionElt.textContent = type;<EOL>        selectTypeElt.appendChild(optionElt);<EOL>    }<EOL>    selectTypeElt.classList.","gt":"add(\"<STR_LIT>\");"}
{"input":"<s> function setupProperty(path, value) {<EOL>    switch (path) {<EOL>        case","gt":"\"<STR_LIT>\":"}
{"input":"<s> function clearInfoPopup() {<EOL>    if (ui.infoElement.parentElement != null)<EOL>        ui.","gt":"infoElement.parentElement.removeChild(ui.infoElement);"}
{"input":"<s> <EOL>export function matcher(pattern, topLevel = true) {<EOL>    if (pattern instanceof Array) {<EOL>        return ArrayMatcher(pattern, topLevel);<EOL>    }<EOL>    else if (pattern instanceof RegExp) {<EOL>","gt":"return RegExpMatcher(pattern);"}
{"input":"<s> export async function uploadBuildArtifacts(gistId, gistCloneUrl, artifactDirs, buildLog, token) {<EOL>    let targetDir = getGistTempdir(gistId);<EOL>    <EOL>    await","gt":"addFilesToGist(gistCloneUrl, targetDir, buildLog, token);"}
{"input":"<s> export function fetchAllOpenPRs(nwo) {<EOL>    return githubPaginate(apiUrl(`<STR_LIT>`), undefined,","gt":"<NUM_LIT> * <NUM_LIT>);"}
{"input":"<s> export async function fetchAllRefsWithInfo(nwo) {<EOL>    let openPRs = (await fetchAllOpenPRs(nwo));<EOL>    let refList = openPRs.map((x) => x.head.ref);<EOL>    let refToPR = openPRs.reduce((acc, x) => {<EOL>        acc[x.","gt":"head.ref] = x;"}
{"input":"<s> export async function fetchAllRefsWithInfo(nwo) {<EOL>    let openPRs = (await fetchAllOpenPRs(nwo));<EOL>    let refList = openPRs.map((x) => x.head.ref);<EOL>    let refToPR = openPRs.reduce((acc, x) => {<EOL>        acc[x. head.ref] = x;<EOL>        return acc;<EOL>    }, {});<EOL>    let theMap = await asyncMap(refList, async (ref) => {<EOL>        let repoName = refToPR[ref].head.","gt":"repo.full_name;"}
{"input":"<s> export async function fetchAllRefsWithInfo(nwo) {<EOL>    let openPRs = (await fetchAllOpenPRs(nwo));<EOL>    let refList = openPRs.map((x) => x.head.ref);<EOL>    let refToPR = openPRs.reduce((acc, x) => {<EOL>        acc[x. head.ref] = x;<EOL>        return acc;<EOL>    }, {});<EOL>    let theMap = await asyncMap(refList, async (ref) => {<EOL>        let repoName = refToPR[ref].head. repo.full_name;<EOL>        let shaHint = refToPR[ref].head.sha;<EOL>        try {<EOL>            let ret = await fetchSingleRef(repoName, ref, shaHint);<EOL>            return ret;<EOL>        }<EOL>        catch (e) {<EOL>            d(`<STR_LIT>`);<EOL>            return null;<EOL>        }<EOL>    });<EOL>    let refs = Array.from(theMap.values());<EOL>    <EOL>    let repoInfo = await fetchRepoInfo(nwo);<EOL>    let defaultBranch = repoInfo.default_branch;<EOL>    let","gt":"result = await fetchSingleRef(nwo, defaultBranch);"}
{"input":"<s> export async function fetchAllRefsWithInfo(nwo) {<EOL>    let openPRs = (await fetchAllOpenPRs(nwo));<EOL>    let refList = openPRs.map((x) => x.head.ref);<EOL>    let refToPR = openPRs.reduce((acc, x) => {<EOL>        acc[x. head.ref] = x;<EOL>        return acc;<EOL>    }, {});<EOL>    let theMap = await asyncMap(refList, async (ref) => {<EOL>        let repoName = refToPR[ref].head. repo.full_name;<EOL>        let shaHint = refToPR[ref].head.sha;<EOL>        try {<EOL>            let ret = await fetchSingleRef(repoName, ref, shaHint);<EOL>            return ret;<EOL>        }<EOL>        catch (e) {<EOL>            d(`<STR_LIT>`);<EOL>            return null;<EOL>        }<EOL>    });<EOL>    let refs = Array.from(theMap.values());<EOL>    <EOL>    let repoInfo = await fetchRepoInfo(nwo);<EOL>    let defaultBranch = repoInfo.default_branch;<EOL>    let  result = await fetchSingleRef(nwo, defaultBranch);<EOL>    refs.push(result);<EOL>    <EOL>    refs = refs.filter((x) => x !== null);<EOL>    let commitInfo = await asyncMap(refs.map((ref) => ref.object.url), async (x) => {<EOL>        try {<EOL>            return (await cachedGitHub(x)).result;<EOL>        }<EOL>        catch (e) {<EOL>            d(","gt":"x} but failed: ${e.message}`<STR_LIT>;"}
{"input":"<s> function sum(params) {<EOL>    var res = <NUM_LIT>;<EOL>    for (var i = <NUM_LIT>; i < params.","gt":"length; i++) {"}
{"input":"<s> function read_json(file) {<EOL>    return JSON.parse(fs.readFileSync(file,","gt":"'<STR_LIT>'));"}
{"input":"<s> export function getDatabase(connection) {<EOL>    switch (getSQLVersion(connection)) {<EOL>        case SQLVersion.MYSQL:<EOL>","gt":"return new MysqlDatabase(connection);"}
{"input":"<s> <EOL>export function count(countFrom, countTo, countDecimals, countDuration, callback) {<EOL>    const startVal = Number(countFrom);<EOL>    const endVal = Number(countTo);<EOL>    const countDown = (startVal > endVal);<EOL>    const decimals = Math.","gt":"max(<NUM_LIT>, countDecimals);"}
{"input":"<s> <EOL>export function count(countFrom, countTo, countDecimals, countDuration, callback) {<EOL>    const startVal = Number(countFrom);<EOL>    const endVal = Number(countTo);<EOL>    const countDown = (startVal > endVal);<EOL>    const decimals = Math. max(<NUM_LIT>, countDecimals);<EOL>    const","gt":"dec = Math.pow(<NUM_LIT>, decimals);"}
{"input":"<s> <EOL>export function count(countFrom, countTo, countDecimals, countDuration, callback) {<EOL>    const startVal = Number(countFrom);<EOL>    const endVal = Number(countTo);<EOL>    const countDown = (startVal > endVal);<EOL>    const decimals = Math. max(<NUM_LIT>, countDecimals);<EOL>    const  dec = Math.pow(<NUM_LIT>, decimals);<EOL>    const duration = Number(countDuration) * <NUM_LIT>;<EOL>    let","gt":"startTime;"}
{"input":"<s> <EOL>export function count(countFrom, countTo, countDecimals, countDuration, callback) {<EOL>    const startVal = Number(countFrom);<EOL>    const endVal = Number(countTo);<EOL>    const countDown = (startVal > endVal);<EOL>    const decimals = Math. max(<NUM_LIT>, countDecimals);<EOL>    const  dec = Math.pow(<NUM_LIT>, decimals);<EOL>    const duration = Number(countDuration) * <NUM_LIT>;<EOL>    let  startTime;<EOL>    function runCount(timestamp) {<EOL>        let frameVal;<EOL>        const progress = timestamp - startTime;<EOL>        if (countDown) {<EOL>            frameVal = startVal - easeOutExpo(","gt":"progress, <NUM_LIT>, startVal - endVal, duration);"}
{"input":"<s> <EOL>export function count(countFrom, countTo, countDecimals, countDuration, callback) {<EOL>    const startVal = Number(countFrom);<EOL>    const endVal = Number(countTo);<EOL>    const countDown = (startVal > endVal);<EOL>    const decimals = Math. max(<NUM_LIT>, countDecimals);<EOL>    const  dec = Math.pow(<NUM_LIT>, decimals);<EOL>    const duration = Number(countDuration) * <NUM_LIT>;<EOL>    let  startTime;<EOL>    function runCount(timestamp) {<EOL>        let frameVal;<EOL>        const progress = timestamp - startTime;<EOL>        if (countDown) {<EOL>            frameVal = startVal - easeOutExpo( progress, <NUM_LIT>, startVal - endVal, duration);<EOL>        }<EOL>        else {<EOL>            frameVal = easeOutExpo(progress, startVal, endVal - startVal, duration);<EOL>        }<EOL>        if (countDown) {<EOL>            frameVal = (frameVal < endVal) ? endVal : frameVal;<EOL>        }<EOL>        else {<EOL>            frameVal = (","gt":"frameVal > endVal) ? endVal : frameVal;"}
{"input":"<s> <EOL>export function count(countFrom, countTo, countDecimals, countDuration, callback) {<EOL>    const startVal = Number(countFrom);<EOL>    const endVal = Number(countTo);<EOL>    const countDown = (startVal > endVal);<EOL>    const decimals = Math. max(<NUM_LIT>, countDecimals);<EOL>    const  dec = Math.pow(<NUM_LIT>, decimals);<EOL>    const duration = Number(countDuration) * <NUM_LIT>;<EOL>    let  startTime;<EOL>    function runCount(timestamp) {<EOL>        let frameVal;<EOL>        const progress = timestamp - startTime;<EOL>        if (countDown) {<EOL>            frameVal = startVal - easeOutExpo( progress, <NUM_LIT>, startVal - endVal, duration);<EOL>        }<EOL>        else {<EOL>            frameVal = easeOutExpo(progress, startVal, endVal - startVal, duration);<EOL>        }<EOL>        if (countDown) {<EOL>            frameVal = (frameVal < endVal) ? endVal : frameVal;<EOL>        }<EOL>        else {<EOL>            frameVal = ( frameVal > endVal) ? endVal : frameVal;<EOL>        }<EOL>        frameVal = Math.round(frameVal * dec) / dec;<EOL>        const tick = progress < duration;<EOL>        callback({<EOL>            value: frameVal,<EOL>            progress,<EOL>            timestamp,<EOL>","gt":"finished: !tick"}
{"input":"<s> <EOL>export function id() {<EOL>    let newId = ('<STR_LIT>' + (Math.random() * Math.pow(<NUM_LIT>, <NUM_LIT>) << <NUM_LIT>).toString(<NUM_LIT>)).slice(-<NUM_LIT>);<EOL>    <EOL>    newId =","gt":"newId}`<STR_LIT>;"}
{"input":"<s> <EOL>export function deCamelCase(str) {<EOL>","gt":"return str"}
{"input":"<s> function setupExpress(app) {<EOL>    <EOL>    if (level === '<STR_LIT>') {<EOL>        app.use(expressWinston.errorLogger({<EOL>            transports: [<EOL>                new winston.transports.","gt":"Console({"}
{"input":"<s> function setupExpress(app) {<EOL>    <EOL>    if (level === '<STR_LIT>') {<EOL>        app.use(expressWinston.errorLogger({<EOL>            transports: [<EOL>                new winston.transports. Console({<EOL>                    json: true,<EOL>","gt":"colorize: true"}
{"input":"<s> function setupExpress(app) {<EOL>    <EOL>    if (level === '<STR_LIT>') {<EOL>        app.use(expressWinston.errorLogger({<EOL>            transports: [<EOL>                new winston.transports. Console({<EOL>                    json: true,<EOL>                     colorize: true<EOL>                })<EOL>            ]<EOL>        }));<EOL>    }<EOL>    <EOL>    if (level === '<STR_LIT>') {<EOL>        app.use(expressWinston.logger({<EOL>            transports: [<EOL>                new winston.transports.Console({<EOL>                    json:","gt":"true,"}
{"input":"<s> function setupSwaggerSecurity(middleware) {<EOL>    return middleware.swaggerSecurity({<EOL>        jwt_token: (req, authOrSecDef, scopes, callback) => {<EOL>            passport.authenticate('<STR_LIT>', { session: false }, (err, user, info) => {<EOL>                if (","gt":"err)"}
{"input":"<s> function setupSwaggerSecurity(middleware) {<EOL>    return middleware.swaggerSecurity({<EOL>        jwt_token: (req, authOrSecDef, scopes, callback) => {<EOL>            passport.authenticate('<STR_LIT>', { session: false }, (err, user, info) => {<EOL>                if ( err)<EOL>                    callback(new Error('<STR_LIT>'));<EOL>                if (!user)<EOL>                    callback(new Error('<STR_LIT>'));<EOL>                req.user = user;<EOL>                return callback();<EOL>            })(req, null,","gt":"callback);"}
{"input":"<s> function mapRelation(rel, modelName, relName) {<EOL>    types[modelName].fields[relName] = {<EOL>        relation: true,<EOL>","gt":"embed: rel.embed,"}
{"input":"<s> function pluralModelName(model) {<EOL>    return '<STR_LIT>' +","gt":"_.upperFirst(model.pluralModelName);"}
{"input":"<s> <EOL>export function pushIf(arr, item) {<EOL>","gt":"return arr.indexOf(item) < <NUM_LIT> && arr.push(item) > <NUM_LIT>;"}
{"input":"<s> export function selectTest() {<EOL>    assert.deepEqual(array.select([<EOL>        { \"<STR_LIT>\": \"<STR_LIT>\", \"<STR_LIT>\": <NUM_LIT> },<EOL>        { \"<STR_LIT>\": \"<STR_LIT>\", \"<STR_LIT>\": <NUM_LIT> },<EOL>        { \"<STR_LIT>\": \"<STR_LIT>\", \"<STR_LIT>\": <NUM_LIT> },<EOL>        { \"<STR_LIT>\": \"<STR_LIT>\",","gt":"\"<STR_LIT>\": <NUM_LIT> }"}
{"input":"<s> export function selectTest() {<EOL>    assert.deepEqual(array.select([<EOL>        { \"<STR_LIT>\": \"<STR_LIT>\", \"<STR_LIT>\": <NUM_LIT> },<EOL>        { \"<STR_LIT>\": \"<STR_LIT>\", \"<STR_LIT>\": <NUM_LIT> },<EOL>        { \"<STR_LIT>\": \"<STR_LIT>\", \"<STR_LIT>\": <NUM_LIT> },<EOL>        { \"<STR_LIT>\": \"<STR_LIT>\",  \"<STR_LIT>\": <NUM_LIT> }<EOL>    ], (item) => item.user), [\"<STR_LIT>\", \"<STR_LIT>\", \"<STR_LIT>\",","gt":"\"<STR_LIT>\"]);"}
{"input":"<s> export function selectTest() {<EOL>    assert.deepEqual(array.select([<EOL>        { \"<STR_LIT>\": \"<STR_LIT>\", \"<STR_LIT>\": <NUM_LIT> },<EOL>        { \"<STR_LIT>\": \"<STR_LIT>\", \"<STR_LIT>\": <NUM_LIT> },<EOL>        { \"<STR_LIT>\": \"<STR_LIT>\", \"<STR_LIT>\": <NUM_LIT> },<EOL>        { \"<STR_LIT>\": \"<STR_LIT>\",  \"<STR_LIT>\": <NUM_LIT> }<EOL>    ], (item) => item.user), [\"<STR_LIT>\", \"<STR_LIT>\", \"<STR_LIT>\",  \"<STR_LIT>\"]);<EOL>    assert.deepEqual(array.select([<EOL>        { \"<STR_LIT>\": \"<STR_LIT>\", \"<STR_LIT>\": <NUM_LIT> },<EOL>        { \"<STR_LIT>\": \"<STR_LIT>\",","gt":"\"<STR_LIT>\": <NUM_LIT> },"}
{"input":"<s> export function mulTest() {<EOL>    assert.strictEqual(bigInteger.mul(\"<STR_LIT>\",","gt":"\"<STR_LIT>\"), \"<STR_LIT>\");"}
{"input":"<s> <EOL>export function isIp(value) {<EOL>","gt":"return /^(?:localhost|::1|(?:[01]?\\d?\\d|2[0-4]\\d|25[0-5])(\\.(?:[01]?\\d?\\d|2[0-4]\\d|25[0-5])){3})$/.test(value);"}
{"input":"<s> export function isChineseIdTest() {<EOL>    assert.strictEqual(check.isChineseId(\"<STR_LIT>\"),","gt":"true);"}
{"input":"<s> <EOL>export function lighten(color, value) {<EOL>","gt":"const hsl = toHSL(color);"}
{"input":"<s> export function getTimezoneTest() {<EOL>    assert.","gt":"strictEqual(date.getTimezone(new Date(\"<STR_LIT>\")), \"<STR_LIT>\");"}
{"input":"<s> export function decodeGB2312Test() {<EOL>    assert.strictEqual(","gt":"gb2312.decodeGB2312(\"<STR_LIT>\"), \"<STR_LIT>\");"}
{"input":"<s> <EOL>export function getIntegerLength(num) {<EOL>","gt":"return num === <NUM_LIT> ? <NUM_LIT> : Math.floor(Math.log(num) / Math.log(<NUM_LIT>)) + <NUM_LIT>;"}
{"input":"<s> <EOL>export function isInteger(num) {<EOL>    return Math.floor(num) ===","gt":"num;"}
{"input":"<s> <EOL>export function addSetter(obj, key, callback) {<EOL>    let originalData;<EOL>    Object.defineProperty(obj, key, {<EOL>        get() {<EOL>            return","gt":"originalData;"}
{"input":"<s> <EOL>export function addSetter(obj, key, callback) {<EOL>    let originalData;<EOL>    Object.defineProperty(obj, key, {<EOL>        get() {<EOL>            return  originalData;<EOL>        },<EOL>        set(value) {<EOL>            originalData = value;<EOL>","gt":"callback();"}
{"input":"<s> <EOL>export function insertBefore(obj, newKey, newValue, refKey) {<EOL>    let tmpObj;<EOL>    for (const key in obj) {<EOL>        if (key === refKey) {<EOL>            tmpObj = {};<EOL>        }<EOL>        if (tmpObj) {<EOL>            tmpObj[key] = obj[key];<EOL>            delete obj[key];<EOL>        }<EOL>    }<EOL>","gt":"obj[newKey] = newValue;"}
{"input":"<s> export function addCallbackTest() {<EOL>    class A {<EOL>        func = null;<EOL>    }<EOL>    let c = <NUM_LIT>;<EOL>","gt":"const a = new A();"}
{"input":"<s> export function addCallbackTest() {<EOL>    class A {<EOL>        func = null;<EOL>    }<EOL>    let c = <NUM_LIT>;<EOL>     const a = new A();<EOL>    object.addCallback(a, \"<STR_LIT>\", () => {<EOL>        assert.equal(++c, <NUM_LIT>);<EOL>    });<EOL>    object.addCallback(","gt":"a, \"<STR_LIT>\", () => {"}
{"input":"<s> export function addCallbackTest() {<EOL>    class A {<EOL>        func = null;<EOL>    }<EOL>    let c = <NUM_LIT>;<EOL>     const a = new A();<EOL>    object.addCallback(a, \"<STR_LIT>\", () => {<EOL>        assert.equal(++c, <NUM_LIT>);<EOL>    });<EOL>    object.addCallback( a, \"<STR_LIT>\", () => {<EOL>        assert.equal(++c, <NUM_LIT>);<EOL>        return false;<EOL>    });<EOL>    object.","gt":"addCallback(a, \"<STR_LIT>\", () => {"}
{"input":"<s> export function diffTest() {<EOL>    assert.deepEqual(object.diff({ a: <NUM_LIT>, c: <NUM_LIT> }, { b: <NUM_LIT>, c: <NUM_LIT> }), { left: [","gt":"\"<STR_LIT>\"], right: [\"<STR_LIT>\"], both: [\"<STR_LIT>\"] });"}
{"input":"<s> export function findIndexTest() {<EOL>    assert.strictEqual([<NUM_LIT>, <NUM_LIT>].findIndex(function (item) {","gt":"return item > <NUM_LIT>; }), <NUM_LIT>);"}
{"input":"<s> export function forEachTest() {<EOL>","gt":"let all = \"<STR_LIT>\";"}
{"input":"<s> <EOL>export function bounce(x) {<EOL>    for (let i = <NUM_LIT>, j = <NUM_LIT>; <NUM_LIT>; i += j, j /= <NUM_LIT>) {<EOL>","gt":"if (x >= (<NUM_LIT> - <NUM_LIT> * i) / <NUM_LIT>) {"}
{"input":"<s> <EOL>export function sinusoidal(x) {<EOL>    return <NUM_LIT> - Math.sin((","gt":"<NUM_LIT> - x) * Math.PI / <NUM_LIT>);"}
{"input":"<s> export function urlTest() {<EOL>    assert.strictEqual(Url.format(Url.parse(","gt":"\"<STR_LIT>\")), \"<STR_LIT>\");"}
{"input":"<s> <EOL>export function encodeUTF8(value) {<EOL>    let result = \"<STR_LIT>\";<EOL>    for (let i = <NUM_LIT>; i < value.length;","gt":"i++) {"}
{"input":"<s> export function getSubcookieAndSetSubcookieTest() {<EOL>    cookieMore.setSubcookie(\"<STR_LIT>\", \"<STR_LIT>\", \"<STR_LIT>\");<EOL>    assert.equal(cookieMore.getSubcookie(\"<STR_LIT>\", \"<STR_LIT>\"),","gt":"\"<STR_LIT>\");"}
{"input":"<s> <EOL>export default function noContextMenu(elem) {<EOL>    elem.addEventListener(\"<STR_LIT>\", (","gt":"e) => e.preventDefault());"}
{"input":"<s> <EOL>function preload(url) {<EOL>    new","gt":"Image().src = url;"}
{"input":"<s> <EOL>export default function toggleFullScreen(elem = document.documentElement) {<EOL>    if (document.fullscreenElement || document.mozFullScreenElement || document.webkitFullscreenElement || document.msFullscreenElement) {<EOL>        const func = document.exitFullscreen || document.msExitFullscreen || document.mozCancelFullScreen || document.webkitExitFullscreen;<EOL>        if (func) {<EOL>            func.call(document);<EOL>","gt":"return false;"}
{"input":"<s> <EOL>export default function toggleFullScreen(elem = document.documentElement) {<EOL>    if (document.fullscreenElement || document.mozFullScreenElement || document.webkitFullscreenElement || document.msFullscreenElement) {<EOL>        const func = document.exitFullscreen || document.msExitFullscreen || document.mozCancelFullScreen || document.webkitExitFullscreen;<EOL>        if (func) {<EOL>            func.call(document);<EOL>             return false;<EOL>        }<EOL>    }<EOL>    else {<EOL>        const func = elem.requestFullscreen || elem.msRequestFullscreen || elem.mozRequestFullScreen || elem.webkitRequestFullscreen;<EOL>        if (func) {<EOL>","gt":"func.call(elem, Element.ALLOW_KEYBOARD_INPUT);"}
{"input":"<s> export function recallChatMessageFetch(activityId) {<EOL>    return","gt":"this.put(`<STR_LIT>`);"}
{"input":"<s> export function getFileFetch(fileId, query) {<EOL>    return this.get(","gt":"fileId}`<STR_LIT>;"}
{"input":"<s> <EOL>export function parseHeaders(rawHeader) {<EOL>    const head = Object.create(null);<EOL>    const pairs = rawHeader.trim().split('<STR_LIT>');<EOL>    pairs.","gt":"forEach((header) => {"}
{"input":"<s> export function mock(sdk) {<EOL>    const mockFetch = new MockFetch;<EOL>    const methods = ['<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>'];<EOL>    return (m, schedule) => {<EOL>","gt":"methods.forEach((method) => {"}
{"input":"<s> function blue(str) {<EOL>    return","gt":"'<STR_LIT>' + str + '<STR_LIT>';"}
{"input":"<s> function watch(paths) {<EOL>    return Observable.from(paths)<EOL>        .map((p) => path.join(process.cwd(), p))<EOL>        .flatMap((path) => Observable.create((","gt":"observer) => {"}
{"input":"<s> export function reduceMatrix(matrix, factor) {<EOL>    if (matrix.length !== matrix[<NUM_LIT>].length) {<EOL>        throw new Error(\"<STR_LIT>\");<EOL>    }<EOL>    if (matrix.length % factor !== <NUM_LIT>) {<EOL>        throw new","gt":"Error(\"<STR_LIT>\" +"}
{"input":"<s> export function reduceMatrix(matrix, factor) {<EOL>    if (matrix.length !== matrix[<NUM_LIT>].length) {<EOL>        throw new Error(\"<STR_LIT>\");<EOL>    }<EOL>    if (matrix.length % factor !== <NUM_LIT>) {<EOL>        throw new  Error(\"<STR_LIT>\" +<EOL>            \"<STR_LIT>\");<EOL>    }<EOL>    let","gt":"result = new Array(matrix.length / factor);"}
{"input":"<s> <EOL>export function getOutputNode(network) {<EOL>    return network[network.length -","gt":"<NUM_LIT>][<NUM_LIT>];"}
{"input":"<s> function route(nodes, groups, margin, groupMargin) {<EOL>    nodes.forEach((d) => {<EOL>        d.routerNode = {<EOL>            name: d.name,<EOL>            bounds:","gt":"d.bounds.inflate(-margin)"}
{"input":"<s> function route(nodes, groups, margin, groupMargin) {<EOL>    nodes.forEach((d) => {<EOL>        d.routerNode = {<EOL>            name: d.name,<EOL>            bounds:  d.bounds.inflate(-margin)<EOL>        };<EOL>    });<EOL>    groups.forEach((","gt":"d) => {"}
{"input":"<s> function route(nodes, groups, margin, groupMargin) {<EOL>    nodes.forEach((d) => {<EOL>        d.routerNode = {<EOL>            name: d.name,<EOL>            bounds:  d.bounds.inflate(-margin)<EOL>        };<EOL>    });<EOL>    groups.forEach(( d) => {<EOL>        d.routerNode = {<EOL>            bounds: d.bounds.inflate(-groupMargin),<EOL>            children: (typeof d.groups !== '<STR_LIT>' ? d.groups.map((c) => nodes.length + c.id) : [])<EOL>                .concat(typeof d.leaves !== '<STR_LIT>' ? d.leaves.map((c) => c.index) : [])<EOL>        };<EOL>    });<EOL>    let gridRouterNodes = nodes.concat(groups).map((d, i) => {<EOL>        d.routerNode.id = i;<EOL>","gt":"return d.routerNode;"}
{"input":"<s> export function generateXConstraints(rs, vars) {<EOL>","gt":"return generateConstraints(rs, vars, xRect, <NUM_LIT>);"}
{"input":"<s> function readJsonFile(path) {<EOL>    return JSON.","gt":"parse(fs.readFileSync(path, { encoding: '<STR_LIT>' }));"}
{"input":"<s> export function addEventListener(element, type, listener, useCapture) {<EOL>    element.addEventListener(type, listener,","gt":"useCapture);"}
{"input":"<s> export function isCancelled(err) {<EOL>    return !!err &&","gt":"err.message === cancelledMessage;"}
{"input":"<s> export function openJsonRpcSocket(options, onOpen) {<EOL>    openSocket(options, (socket) => {<EOL>        const webSocket = toIWebSocket(","gt":"socket);"}
{"input":"<s> export async function assertInstallation(expectation) {<EOL>    const waitForWillInstall = new Promise((resolve) => appProject.onWillInstall(resolve));<EOL>    const waitForDidInstall = new Promise((resolve) => appProject.onDidInstall(resolve));<EOL>    await waitForWillInstall;<EOL>    const result = await waitForDidInstall;<EOL>    if (expectation.","gt":"installed) {"}
{"input":"<s> export function bindNodeExtensionServer(bind, args) {<EOL>    if (args) {<EOL>        bind(NpmClientOptions).toConstantValue(args);<EOL>        bind(ApplicationProjectOptions).toConstantValue(args);<EOL>    }<EOL>","gt":"else {"}
{"input":"<s> export function bindNodeExtensionServer(bind, args) {<EOL>    if (args) {<EOL>        bind(NpmClientOptions).toConstantValue(args);<EOL>        bind(ApplicationProjectOptions).toConstantValue(args);<EOL>    }<EOL>     else {<EOL>        bind(ApplicationProjectCliContribution).toSelf().inSingletonScope();<EOL>        bind(CliContribution).toDynamicValue((ctx) => ctx.container.get(ApplicationProjectCliContribution)).inSingletonScope();<EOL>        bind(NpmClientOptions).toDynamicValue((ctx) => ctx.container.get(ApplicationProjectCliContribution).args).inSingletonScope();<EOL>","gt":"bind(ApplicationProjectOptions).toDynamicValue((ctx) => ctx.container.get(ApplicationProjectCliContribution).args).inSingletonScope();"}
{"input":"<s> export function bindNodeExtensionServer(bind, args) {<EOL>    if (args) {<EOL>        bind(NpmClientOptions).toConstantValue(args);<EOL>        bind(ApplicationProjectOptions).toConstantValue(args);<EOL>    }<EOL>     else {<EOL>        bind(ApplicationProjectCliContribution).toSelf().inSingletonScope();<EOL>        bind(CliContribution).toDynamicValue((ctx) => ctx.container.get(ApplicationProjectCliContribution)).inSingletonScope();<EOL>        bind(NpmClientOptions).toDynamicValue((ctx) => ctx.container.get(ApplicationProjectCliContribution).args).inSingletonScope();<EOL>         bind(ApplicationProjectOptions).toDynamicValue((ctx) => ctx.container.get(ApplicationProjectCliContribution).args).inSingletonScope();<EOL>    }<EOL>    bind(NpmClient).toSelf().inSingletonScope();<EOL>    bind(ApplicationProject).toSelf().","gt":"inSingletonScope();"}
{"input":"<s> export function bindGitDecorationsPreferences(bind) {<EOL>    bind(GitDecorationsPreferences).toDynamicValue((ctx) => {<EOL>        const","gt":"preferences = ctx.container.get(PreferenceService);"}
{"input":"<s> export function loadMonaco(vsRequire) {<EOL>    return new Promise((resolve) => {<EOL>        vsRequire([\"<STR_LIT>\"], () => {<EOL>            vsRequire([<EOL>","gt":"'<STR_LIT>',"}
{"input":"<s> export function loadMonaco(vsRequire) {<EOL>    return new Promise((resolve) => {<EOL>        vsRequire([\"<STR_LIT>\"], () => {<EOL>            vsRequire([<EOL>                 '<STR_LIT>',<EOL>","gt":"'<STR_LIT>',"}
{"input":"<s> export function loadMonaco(vsRequire) {<EOL>    return new Promise((resolve) => {<EOL>        vsRequire([\"<STR_LIT>\"], () => {<EOL>            vsRequire([<EOL>                 '<STR_LIT>',<EOL>                 '<STR_LIT>',<EOL>                '<STR_LIT>',<EOL>                '<STR_LIT>',<EOL>                '<STR_LIT>',<EOL>                '<STR_LIT>',<EOL>                '<STR_LIT>',<EOL>                '<STR_LIT>',<EOL>                '<STR_LIT>',<EOL>                '<STR_LIT>',<EOL>                '<STR_LIT>',<EOL>                '<STR_LIT>',<EOL>                '<STR_LIT>',<EOL>                '<STR_LIT>',<EOL>                '<STR_LIT>',<EOL>                '<STR_LIT>',<EOL>                '<STR_LIT>',<EOL>                '<STR_LIT>',<EOL>                '<STR_LIT>',<EOL>                '<STR_LIT>',<EOL>                '<STR_LIT>'<EOL>            ], (basic, css, html, json, commands, actions, registry, resolver, resolvedKeybinding, keyCodes, editorCommonExtensions, simpleServices, standaloneServices, quickOpen, quickOpenWidget, quickOpenModel, filters, styler, platform, modes, cancellation) => {<EOL>                const global = self;<EOL>                global.monaco.commands = commands;<EOL>                global.monaco.actions = actions;<EOL>                global.monaco.keybindings = Object.assign({}, registry, resolver, resolvedKeybinding, keyCodes);<EOL>                global.monaco.services = Object.assign({}, simpleServices, standaloneServices);<EOL>                global.monaco.quickOpen = Object.assign({},","gt":"quickOpen, quickOpenWidget, quickOpenModel);"}
{"input":"<s> export function loadMonaco(vsRequire) {<EOL>    return new Promise((resolve) => {<EOL>        vsRequire([\"<STR_LIT>\"], () => {<EOL>            vsRequire([<EOL>                 '<STR_LIT>',<EOL>                 '<STR_LIT>',<EOL>                '<STR_LIT>',<EOL>                '<STR_LIT>',<EOL>                '<STR_LIT>',<EOL>                '<STR_LIT>',<EOL>                '<STR_LIT>',<EOL>                '<STR_LIT>',<EOL>                '<STR_LIT>',<EOL>                '<STR_LIT>',<EOL>                '<STR_LIT>',<EOL>                '<STR_LIT>',<EOL>                '<STR_LIT>',<EOL>                '<STR_LIT>',<EOL>                '<STR_LIT>',<EOL>                '<STR_LIT>',<EOL>                '<STR_LIT>',<EOL>                '<STR_LIT>',<EOL>                '<STR_LIT>',<EOL>                '<STR_LIT>',<EOL>                '<STR_LIT>'<EOL>            ], (basic, css, html, json, commands, actions, registry, resolver, resolvedKeybinding, keyCodes, editorCommonExtensions, simpleServices, standaloneServices, quickOpen, quickOpenWidget, quickOpenModel, filters, styler, platform, modes, cancellation) => {<EOL>                const global = self;<EOL>                global.monaco.commands = commands;<EOL>                global.monaco.actions = actions;<EOL>                global.monaco.keybindings = Object.assign({}, registry, resolver, resolvedKeybinding, keyCodes);<EOL>                global.monaco.services = Object.assign({}, simpleServices, standaloneServices);<EOL>                global.monaco.quickOpen = Object.assign({},  quickOpen, quickOpenWidget, quickOpenModel);<EOL>                global.monaco.filters = filters;<EOL>                global.monaco.theme = styler;<EOL>                global.monaco.","gt":"platform = platform;"}
{"input":"<s> <EOL>export function loadVsRequire(context) {<EOL>    <EOL>    <EOL>    const originalRequire = context.require;<EOL>","gt":"return new Promise((resolve) => {"}
{"input":"<s> <EOL>export function loadVsRequire(context) {<EOL>    <EOL>    <EOL>    const originalRequire = context.require;<EOL>     return new Promise((resolve) => {<EOL>        window.onload = () => {<EOL>            const vsLoader = document.createElement('<STR_LIT>');<EOL>","gt":"vsLoader.type = '<STR_LIT>';"}
{"input":"<s> <EOL>export function loadVsRequire(context) {<EOL>    <EOL>    <EOL>    const originalRequire = context.require;<EOL>     return new Promise((resolve) => {<EOL>        window.onload = () => {<EOL>            const vsLoader = document.createElement('<STR_LIT>');<EOL>             vsLoader.type = '<STR_LIT>';<EOL>            vsLoader.src = '<STR_LIT>';<EOL>            vsLoader.charset = '<STR_LIT>';<EOL>            vsLoader.addEventListener('<STR_LIT>', () => {<EOL>                <EOL>                const amdRequire = context.require;<EOL>                if (originalRequire) {<EOL>                    context.require = originalRequire;<EOL>                }<EOL>","gt":"resolve(amdRequire);"}
{"input":"<s> export function registerJavaScript() {<EOL>    monaco.languages.register({<EOL>        id: JAVASCRIPT_LANGUAGE_ID,<EOL>        extensions: ['<STR_LIT>', '<STR_LIT>'],<EOL>        aliases: [","gt":"JAVASCRIPT_LANGUAGE_NAME, '<STR_LIT>', '<STR_LIT>'],"}
{"input":"<s> export function registerJavaScript() {<EOL>    monaco.languages.register({<EOL>        id: JAVASCRIPT_LANGUAGE_ID,<EOL>        extensions: ['<STR_LIT>', '<STR_LIT>'],<EOL>        aliases: [ JAVASCRIPT_LANGUAGE_NAME, '<STR_LIT>', '<STR_LIT>'],<EOL>        mimetypes: ['<STR_LIT>']<EOL>    });<EOL>    monaco.languages.onLanguage(JAVASCRIPT_LANGUAGE_ID, () => {<EOL>        monaco.languages.setLanguageConfiguration(JAVASCRIPT_LANGUAGE_ID,","gt":"genericEditConfiguration);"}
{"input":"<s> function createExecutor(config) {<EOL>    const executor = new Browser(config);<EOL>    executor.","gt":"registerLoader((_config) => (_modules) => Promise.resolve());"}
{"input":"<s> <EOL><EOL>export function u8aToHex(array) {<EOL>    const results = [];<EOL>","gt":"array.forEach((arrayByte) => {"}
{"input":"<s> export function addDocumentListener(ev, handler, passive = true) {<EOL>    document.addEventListener(","gt":"ev, handler, supportsPassive ? { passive: passive } : false);"}
{"input":"<s> function average(array) {<EOL>    if (array.length === <NUM_LIT>) {<EOL>        return","gt":"<NUM_LIT>;"}
{"input":"<s> <EOL>function isScrollable(el) {<EOL>    const cs = getComputedStyle(el);<EOL>    if (el.scrollHeight > el.clientHeight && (cs.overflowY === \"<STR_LIT>\" || cs.overflowY === \"<STR_LIT>\")) {<EOL>","gt":"return true;"}
{"input":"<s> export function expectSubscriptions() {<EOL>    if (!window.rxTestScheduler) {<EOL>        throw","gt":"'<STR_LIT>';"}
{"input":"<s> function unquote(s) {<EOL>    if (s[<NUM_LIT>] === '<STR_LIT>' && s[s.length - <NUM_LIT>] === '<STR_LIT>') {<EOL>        return","gt":"JSON.parse(s);"}
{"input":"<s> function testFlatCacheObject() {<EOL>    <EOL>    createCachedSelector(fooSelector, combinerSelector)(fooSelector, {<EOL>        cacheObject: new FlatCacheObject()<EOL>    });<EOL>    <EOL>    const cacheObject = new FlatCacheObject();<EOL>    cacheObject.set('<STR_LIT>', () => { });<EOL>    cacheObject.set(<NUM_LIT>, () => { });<EOL>    const result1 = cacheObject.get('<STR_LIT>');<EOL>    const","gt":"result2 = cacheObject.get(<NUM_LIT>);"}
{"input":"<s> <EOL>export function ArrayMaxSize(max, validationOptions) {<EOL>    return function (object, propertyName) {<EOL>        const args = {<EOL>            type: ValidationTypes.ARRAY_MAX_SIZE,<EOL>            target:","gt":"object.constructor,"}
{"input":"<s> <EOL>export function IsAlphanumeric(validationOptions) {<EOL>    return function (object, propertyName) {<EOL>        const args = {<EOL>","gt":"type: ValidationTypes.IS_ALPHANUMERIC,"}
{"input":"<s> <EOL>export function useContainer(iocContainer, options) {<EOL>    userContainer =","gt":"iocContainer;"}
{"input":"<s> <EOL>export function UploadedFile(name, options) {<EOL>    return function (object, methodName, index) {<EOL>        getMetadataArgsStorage().params.push({<EOL>            type: \"<STR_LIT>\",<EOL>            object:","gt":"object,"}
{"input":"<s> <EOL>export function UploadedFile(name, options) {<EOL>    return function (object, methodName, index) {<EOL>        getMetadataArgsStorage().params.push({<EOL>            type: \"<STR_LIT>\",<EOL>            object:  object,<EOL>            method: methodName,<EOL>            index: index,<EOL>            name: name,<EOL>            parse: false,<EOL>            required: options ? options.required : undefined,<EOL>            extraOptions: options ?","gt":"options.options : undefined"}
{"input":"<s> <EOL>export function createExecutor(driver, options = {}) {<EOL>    <EOL>    let controllerClasses;<EOL>    if (options && options.controllers &&","gt":"options.controllers.length) {"}
{"input":"<s> <EOL>export function createExecutor(driver, options = {}) {<EOL>    <EOL>    let controllerClasses;<EOL>    if (options && options.controllers &&  options.controllers.length) {<EOL>        controllerClasses = options.controllers.filter((controller) => controller instanceof Function);<EOL>        const controllerDirs = options.controllers.filter((controller) => typeof controller === \"<STR_LIT>\");<EOL>        controllerClasses.","gt":"push(...importClassesFromDirectories(controllerDirs));"}
{"input":"<s> <EOL>export function createExecutor(driver, options = {}) {<EOL>    <EOL>    let controllerClasses;<EOL>    if (options && options.controllers &&  options.controllers.length) {<EOL>        controllerClasses = options.controllers.filter((controller) => controller instanceof Function);<EOL>        const controllerDirs = options.controllers.filter((controller) => typeof controller === \"<STR_LIT>\");<EOL>        controllerClasses. push(...importClassesFromDirectories(controllerDirs));<EOL>    }<EOL>    let","gt":"middlewareClasses;"}
{"input":"<s> <EOL>export function createExecutor(driver, options = {}) {<EOL>    <EOL>    let controllerClasses;<EOL>    if (options && options.controllers &&  options.controllers.length) {<EOL>        controllerClasses = options.controllers.filter((controller) => controller instanceof Function);<EOL>        const controllerDirs = options.controllers.filter((controller) => typeof controller === \"<STR_LIT>\");<EOL>        controllerClasses. push(...importClassesFromDirectories(controllerDirs));<EOL>    }<EOL>    let  middlewareClasses;<EOL>    if (options && options.middlewares && options.middlewares.length) {<EOL>        middlewareClasses = options.middlewares.filter((controller) => controller instanceof Function);<EOL>        const middlewareDirs = options.middlewares.filter((controller) => typeof controller === \"<STR_LIT>\");<EOL>","gt":"middlewareClasses.push(...importClassesFromDirectories(middlewareDirs));"}
{"input":"<s> <EOL>export function createExecutor(driver, options = {}) {<EOL>    <EOL>    let controllerClasses;<EOL>    if (options && options.controllers &&  options.controllers.length) {<EOL>        controllerClasses = options.controllers.filter((controller) => controller instanceof Function);<EOL>        const controllerDirs = options.controllers.filter((controller) => typeof controller === \"<STR_LIT>\");<EOL>        controllerClasses. push(...importClassesFromDirectories(controllerDirs));<EOL>    }<EOL>    let  middlewareClasses;<EOL>    if (options && options.middlewares && options.middlewares.length) {<EOL>        middlewareClasses = options.middlewares.filter((controller) => controller instanceof Function);<EOL>        const middlewareDirs = options.middlewares.filter((controller) => typeof controller === \"<STR_LIT>\");<EOL>         middlewareClasses.push(...importClassesFromDirectories(middlewareDirs));<EOL>    }<EOL>    let interceptorClasses;<EOL>    if (options && options.interceptors && options.interceptors.length) {<EOL>        interceptorClasses = options.interceptors.filter((controller) => controller instanceof Function);<EOL>        const interceptorDirs = options.interceptors.filter((controller) => typeof controller === \"<STR_LIT>\");<EOL>        interceptorClasses.push(...importClassesFromDirectories(interceptorDirs));<EOL>    }<EOL>","gt":"if (options && options.development !== undefined) {"}
{"input":"<s> <EOL>export function createExecutor(driver, options = {}) {<EOL>    <EOL>    let controllerClasses;<EOL>    if (options && options.controllers &&  options.controllers.length) {<EOL>        controllerClasses = options.controllers.filter((controller) => controller instanceof Function);<EOL>        const controllerDirs = options.controllers.filter((controller) => typeof controller === \"<STR_LIT>\");<EOL>        controllerClasses. push(...importClassesFromDirectories(controllerDirs));<EOL>    }<EOL>    let  middlewareClasses;<EOL>    if (options && options.middlewares && options.middlewares.length) {<EOL>        middlewareClasses = options.middlewares.filter((controller) => controller instanceof Function);<EOL>        const middlewareDirs = options.middlewares.filter((controller) => typeof controller === \"<STR_LIT>\");<EOL>         middlewareClasses.push(...importClassesFromDirectories(middlewareDirs));<EOL>    }<EOL>    let interceptorClasses;<EOL>    if (options && options.interceptors && options.interceptors.length) {<EOL>        interceptorClasses = options.interceptors.filter((controller) => controller instanceof Function);<EOL>        const interceptorDirs = options.interceptors.filter((controller) => typeof controller === \"<STR_LIT>\");<EOL>        interceptorClasses.push(...importClassesFromDirectories(interceptorDirs));<EOL>    }<EOL>     if (options && options.development !== undefined) {<EOL>        driver.developmentMode = options.development;<EOL>    }<EOL>    else {<EOL>        driver.developmentMode = process.env.NODE_ENV !== \"<STR_LIT>\";<EOL>    }<EOL>","gt":"if (options.defaultErrorHandler !== undefined) {"}
{"input":"<s> <EOL>export function createExecutor(driver, options = {}) {<EOL>    <EOL>    let controllerClasses;<EOL>    if (options && options.controllers &&  options.controllers.length) {<EOL>        controllerClasses = options.controllers.filter((controller) => controller instanceof Function);<EOL>        const controllerDirs = options.controllers.filter((controller) => typeof controller === \"<STR_LIT>\");<EOL>        controllerClasses. push(...importClassesFromDirectories(controllerDirs));<EOL>    }<EOL>    let  middlewareClasses;<EOL>    if (options && options.middlewares && options.middlewares.length) {<EOL>        middlewareClasses = options.middlewares.filter((controller) => controller instanceof Function);<EOL>        const middlewareDirs = options.middlewares.filter((controller) => typeof controller === \"<STR_LIT>\");<EOL>         middlewareClasses.push(...importClassesFromDirectories(middlewareDirs));<EOL>    }<EOL>    let interceptorClasses;<EOL>    if (options && options.interceptors && options.interceptors.length) {<EOL>        interceptorClasses = options.interceptors.filter((controller) => controller instanceof Function);<EOL>        const interceptorDirs = options.interceptors.filter((controller) => typeof controller === \"<STR_LIT>\");<EOL>        interceptorClasses.push(...importClassesFromDirectories(interceptorDirs));<EOL>    }<EOL>     if (options && options.development !== undefined) {<EOL>        driver.developmentMode = options.development;<EOL>    }<EOL>    else {<EOL>        driver.developmentMode = process.env.NODE_ENV !== \"<STR_LIT>\";<EOL>    }<EOL>     if (options.defaultErrorHandler !== undefined) {<EOL>        driver.isDefaultErrorHandlingEnabled = options.defaultErrorHandler;<EOL>    }<EOL>    else {<EOL>        driver.isDefaultErrorHandlingEnabled = true;<EOL>    }<EOL>    if (options.classTransformer !== undefined) {<EOL>        driver.useClassTransformer =","gt":"options.classTransformer;"}
{"input":"<s> <EOL>export function createExecutor(driver, options = {}) {<EOL>    <EOL>    let controllerClasses;<EOL>    if (options && options.controllers &&  options.controllers.length) {<EOL>        controllerClasses = options.controllers.filter((controller) => controller instanceof Function);<EOL>        const controllerDirs = options.controllers.filter((controller) => typeof controller === \"<STR_LIT>\");<EOL>        controllerClasses. push(...importClassesFromDirectories(controllerDirs));<EOL>    }<EOL>    let  middlewareClasses;<EOL>    if (options && options.middlewares && options.middlewares.length) {<EOL>        middlewareClasses = options.middlewares.filter((controller) => controller instanceof Function);<EOL>        const middlewareDirs = options.middlewares.filter((controller) => typeof controller === \"<STR_LIT>\");<EOL>         middlewareClasses.push(...importClassesFromDirectories(middlewareDirs));<EOL>    }<EOL>    let interceptorClasses;<EOL>    if (options && options.interceptors && options.interceptors.length) {<EOL>        interceptorClasses = options.interceptors.filter((controller) => controller instanceof Function);<EOL>        const interceptorDirs = options.interceptors.filter((controller) => typeof controller === \"<STR_LIT>\");<EOL>        interceptorClasses.push(...importClassesFromDirectories(interceptorDirs));<EOL>    }<EOL>     if (options && options.development !== undefined) {<EOL>        driver.developmentMode = options.development;<EOL>    }<EOL>    else {<EOL>        driver.developmentMode = process.env.NODE_ENV !== \"<STR_LIT>\";<EOL>    }<EOL>     if (options.defaultErrorHandler !== undefined) {<EOL>        driver.isDefaultErrorHandlingEnabled = options.defaultErrorHandler;<EOL>    }<EOL>    else {<EOL>        driver.isDefaultErrorHandlingEnabled = true;<EOL>    }<EOL>    if (options.classTransformer !== undefined) {<EOL>        driver.useClassTransformer =  options.classTransformer;<EOL>    }<EOL>    else {<EOL>        driver.useClassTransformer = true;<EOL>    }<EOL>","gt":"if (options.validation !== undefined) {"}
{"input":"<s> <EOL>export function createExecutor(driver, options = {}) {<EOL>    <EOL>    let controllerClasses;<EOL>    if (options && options.controllers &&  options.controllers.length) {<EOL>        controllerClasses = options.controllers.filter((controller) => controller instanceof Function);<EOL>        const controllerDirs = options.controllers.filter((controller) => typeof controller === \"<STR_LIT>\");<EOL>        controllerClasses. push(...importClassesFromDirectories(controllerDirs));<EOL>    }<EOL>    let  middlewareClasses;<EOL>    if (options && options.middlewares && options.middlewares.length) {<EOL>        middlewareClasses = options.middlewares.filter((controller) => controller instanceof Function);<EOL>        const middlewareDirs = options.middlewares.filter((controller) => typeof controller === \"<STR_LIT>\");<EOL>         middlewareClasses.push(...importClassesFromDirectories(middlewareDirs));<EOL>    }<EOL>    let interceptorClasses;<EOL>    if (options && options.interceptors && options.interceptors.length) {<EOL>        interceptorClasses = options.interceptors.filter((controller) => controller instanceof Function);<EOL>        const interceptorDirs = options.interceptors.filter((controller) => typeof controller === \"<STR_LIT>\");<EOL>        interceptorClasses.push(...importClassesFromDirectories(interceptorDirs));<EOL>    }<EOL>     if (options && options.development !== undefined) {<EOL>        driver.developmentMode = options.development;<EOL>    }<EOL>    else {<EOL>        driver.developmentMode = process.env.NODE_ENV !== \"<STR_LIT>\";<EOL>    }<EOL>     if (options.defaultErrorHandler !== undefined) {<EOL>        driver.isDefaultErrorHandlingEnabled = options.defaultErrorHandler;<EOL>    }<EOL>    else {<EOL>        driver.isDefaultErrorHandlingEnabled = true;<EOL>    }<EOL>    if (options.classTransformer !== undefined) {<EOL>        driver.useClassTransformer =  options.classTransformer;<EOL>    }<EOL>    else {<EOL>        driver.useClassTransformer = true;<EOL>    }<EOL>     if (options.validation !== undefined) {<EOL>        driver.enableValidation = !!options.validation;<EOL>        if (options.validation instanceof Object)<EOL>            driver.validationOptions = options.validation;<EOL>    }<EOL>    else {<EOL>        driver.enableValidation = true;<EOL>    }<EOL>    driver.classToPlainTransformOptions = options.classToPlainTransformOptions;<EOL>    driver.plainToClassTransformOptions = options.","gt":"plainToClassTransformOptions;"}
{"input":"<s> <EOL>export function createExecutor(driver, options = {}) {<EOL>    <EOL>    let controllerClasses;<EOL>    if (options && options.controllers &&  options.controllers.length) {<EOL>        controllerClasses = options.controllers.filter((controller) => controller instanceof Function);<EOL>        const controllerDirs = options.controllers.filter((controller) => typeof controller === \"<STR_LIT>\");<EOL>        controllerClasses. push(...importClassesFromDirectories(controllerDirs));<EOL>    }<EOL>    let  middlewareClasses;<EOL>    if (options && options.middlewares && options.middlewares.length) {<EOL>        middlewareClasses = options.middlewares.filter((controller) => controller instanceof Function);<EOL>        const middlewareDirs = options.middlewares.filter((controller) => typeof controller === \"<STR_LIT>\");<EOL>         middlewareClasses.push(...importClassesFromDirectories(middlewareDirs));<EOL>    }<EOL>    let interceptorClasses;<EOL>    if (options && options.interceptors && options.interceptors.length) {<EOL>        interceptorClasses = options.interceptors.filter((controller) => controller instanceof Function);<EOL>        const interceptorDirs = options.interceptors.filter((controller) => typeof controller === \"<STR_LIT>\");<EOL>        interceptorClasses.push(...importClassesFromDirectories(interceptorDirs));<EOL>    }<EOL>     if (options && options.development !== undefined) {<EOL>        driver.developmentMode = options.development;<EOL>    }<EOL>    else {<EOL>        driver.developmentMode = process.env.NODE_ENV !== \"<STR_LIT>\";<EOL>    }<EOL>     if (options.defaultErrorHandler !== undefined) {<EOL>        driver.isDefaultErrorHandlingEnabled = options.defaultErrorHandler;<EOL>    }<EOL>    else {<EOL>        driver.isDefaultErrorHandlingEnabled = true;<EOL>    }<EOL>    if (options.classTransformer !== undefined) {<EOL>        driver.useClassTransformer =  options.classTransformer;<EOL>    }<EOL>    else {<EOL>        driver.useClassTransformer = true;<EOL>    }<EOL>     if (options.validation !== undefined) {<EOL>        driver.enableValidation = !!options.validation;<EOL>        if (options.validation instanceof Object)<EOL>            driver.validationOptions = options.validation;<EOL>    }<EOL>    else {<EOL>        driver.enableValidation = true;<EOL>    }<EOL>    driver.classToPlainTransformOptions = options.classToPlainTransformOptions;<EOL>    driver.plainToClassTransformOptions = options. plainToClassTransformOptions;<EOL>    if (options.errorOverridingMap !== undefined)<EOL>        driver.errorOverridingMap = options.errorOverridingMap;<EOL>    if (options.routePrefix !== undefined)<EOL>        driver.routePrefix = options.routePrefix;<EOL>    if (options.currentUserChecker !== undefined)<EOL>        driver.","gt":"currentUserChecker = options.currentUserChecker;"}
{"input":"<s> <EOL>export function createExecutor(driver, options = {}) {<EOL>    <EOL>    let controllerClasses;<EOL>    if (options && options.controllers &&  options.controllers.length) {<EOL>        controllerClasses = options.controllers.filter((controller) => controller instanceof Function);<EOL>        const controllerDirs = options.controllers.filter((controller) => typeof controller === \"<STR_LIT>\");<EOL>        controllerClasses. push(...importClassesFromDirectories(controllerDirs));<EOL>    }<EOL>    let  middlewareClasses;<EOL>    if (options && options.middlewares && options.middlewares.length) {<EOL>        middlewareClasses = options.middlewares.filter((controller) => controller instanceof Function);<EOL>        const middlewareDirs = options.middlewares.filter((controller) => typeof controller === \"<STR_LIT>\");<EOL>         middlewareClasses.push(...importClassesFromDirectories(middlewareDirs));<EOL>    }<EOL>    let interceptorClasses;<EOL>    if (options && options.interceptors && options.interceptors.length) {<EOL>        interceptorClasses = options.interceptors.filter((controller) => controller instanceof Function);<EOL>        const interceptorDirs = options.interceptors.filter((controller) => typeof controller === \"<STR_LIT>\");<EOL>        interceptorClasses.push(...importClassesFromDirectories(interceptorDirs));<EOL>    }<EOL>     if (options && options.development !== undefined) {<EOL>        driver.developmentMode = options.development;<EOL>    }<EOL>    else {<EOL>        driver.developmentMode = process.env.NODE_ENV !== \"<STR_LIT>\";<EOL>    }<EOL>     if (options.defaultErrorHandler !== undefined) {<EOL>        driver.isDefaultErrorHandlingEnabled = options.defaultErrorHandler;<EOL>    }<EOL>    else {<EOL>        driver.isDefaultErrorHandlingEnabled = true;<EOL>    }<EOL>    if (options.classTransformer !== undefined) {<EOL>        driver.useClassTransformer =  options.classTransformer;<EOL>    }<EOL>    else {<EOL>        driver.useClassTransformer = true;<EOL>    }<EOL>     if (options.validation !== undefined) {<EOL>        driver.enableValidation = !!options.validation;<EOL>        if (options.validation instanceof Object)<EOL>            driver.validationOptions = options.validation;<EOL>    }<EOL>    else {<EOL>        driver.enableValidation = true;<EOL>    }<EOL>    driver.classToPlainTransformOptions = options.classToPlainTransformOptions;<EOL>    driver.plainToClassTransformOptions = options. plainToClassTransformOptions;<EOL>    if (options.errorOverridingMap !== undefined)<EOL>        driver.errorOverridingMap = options.errorOverridingMap;<EOL>    if (options.routePrefix !== undefined)<EOL>        driver.routePrefix = options.routePrefix;<EOL>    if (options.currentUserChecker !== undefined)<EOL>        driver. currentUserChecker = options.currentUserChecker;<EOL>    if (options.authorizationChecker !== undefined)<EOL>        driver.authorizationChecker = options.authorizationChecker;<EOL>    driver.cors =","gt":"options.cors;"}
{"input":"<s> <EOL>function getCompilerDigest(obj) {<EOL>    return crypto.createHash('<STR_LIT>').update(JSON.","gt":"stringify(obj), '<STR_LIT>').digest('<STR_LIT>');"}
{"input":"<s> <EOL>export function parse(value) {<EOL>    return typeof","gt":"value === '<STR_LIT>' ? JSON.parse(value) : undefined;"}
{"input":"<s> function isCommandLine(args) {<EOL>    return typeof args ===","gt":"'<STR_LIT>';"}
{"input":"<s> function getArray(key, obj1, obj2) {<EOL>    return _.union(obj1[key] || [],","gt":"obj2[key] || []).sort();"}
{"input":"<s> export function replaceType(originalContents, typeName, newTypeBody) {<EOL>    return originalContents.","gt":"replace(new RegExp(`<STR_LIT>`, \"<STR_LIT>\"), `<STR_LIT>`);"}
{"input":"<s> function fakeDate(defaultDate) {<EOL>    global.Date = (arg) => new _Date(","gt":"typeof arg !== '<STR_LIT>' ? arg : defaultDate);"}
{"input":"<s> function hashPriority(priority) {<EOL>    if (typeof priority === '<STR_LIT>') {<EOL>        return","gt":"priority)}`<STR_LIT>;"}
{"input":"<s> <EOL><EOL>export function isReservedWord(s) {<EOL>    var keywords = ['<STR_LIT>', '<STR_LIT>', '<STR_LIT>',<EOL>        '<STR_LIT>', '<STR_LIT>', '<STR_LIT>'];<EOL>    for (var k in","gt":"keywords) {"}
{"input":"<s> <EOL><EOL>export function arrayBufferToBuffer(ab) {<EOL>    return new Buffer(","gt":"ab);"}
{"input":"<s> function getRandomInt(min, max) {<EOL>    return Math.floor(Math.random() * (max - min +","gt":"<NUM_LIT>)) + min;"}
{"input":"<s> function firstChildOf(internalTreeDebugElement) {<EOL>    return internalTreeDebugElement.","gt":"query(By.directive(TreeInternalComponent));"}
{"input":"<s> function setMonth(fixture, month) {<EOL>    fixture.componentInstance.month = month","gt":";"}
{"input":"<s> export function apiMove(state, orig, dest) {<EOL>    return","gt":"baseMove(state, orig, dest);"}
{"input":"<s> export function canDrop(state, orig, dest) {<EOL>    const piece = state.pieces[","gt":"orig];"}
{"input":"<s> export function canMove(state, orig, dest) {<EOL>    return orig !==","gt":"dest && isMovable(state, orig) && (state.movable.free || (state.movable.dests !== null && util.containsX(state.movable.dests[orig], dest)));"}
{"input":"<s> function stoppedPlaying(name) {<EOL>    setPlaying(name,","gt":"false);"}
{"input":"<s> export function berserkableBy(data) {<EOL>    return data.tournament &&<EOL>        data.tournament.","gt":"berserkable &&"}
{"input":"<s> export function isOpponentTurn(data) {<EOL>    return isPlayerPlaying(data) && data.game.player !== data.","gt":"player.color;"}
{"input":"<s> export function playable(data) {<EOL>    return","gt":"data.game.source !== '<STR_LIT>' && data.game.status.id < gameStatus.ids.aborted;"}
{"input":"<s> export function publicUrl(data) {<EOL>    return '<STR_LIT>' + data.game.","gt":"id;"}
{"input":"<s> export function takebackable(data) {<EOL>    return !!(","gt":"playable(data) && data.takebackable && !data.tournament && playedTurns(data) > <NUM_LIT> && !data.player.proposingTakeback && !data.opponent.proposingTakeback);"}
{"input":"<s> export function isMoveRequest(r) {<EOL>    return r.u !==","gt":"undefined;"}
{"input":"<s> function setQueryParams(params) {<EOL>    const","gt":"path = get().replace(/\\?.+$/, '<STR_LIT>');"}
{"input":"<s> function isSession(data) {<EOL>","gt":"return data.id !== undefined;"}
{"input":"<s> function withStorage(f) {<EOL>    <EOL>","gt":"try {"}
{"input":"<s> function skill(level) {<EOL>    return Math.round((level - <NUM_LIT>) * (","gt":"maxSkill / <NUM_LIT>));"}
{"input":"<s> export function requestComputerAnalysis(gameId) {<EOL>    return fetchText(","gt":"gameId}/request-analysis`, {"}
{"input":"<s> function cpWinningChances(cp) {<EOL>    return","gt":"rawWinningChances(Math.min(Math.max(-<NUM_LIT>, cp), <NUM_LIT>));"}
{"input":"<s> function clockContent(centis) {<EOL>    if (centis === undefined)<EOL>        return h('<STR_LIT>', ['<STR_LIT>']);<EOL>    const date = new Date(centis * <NUM_LIT>), millis = date.getUTCMilliseconds(), sep = '<STR_LIT>', baseStr = pad2(date.getUTCMinutes()) + sep + pad2(date.getUTCSeconds());<EOL>","gt":"if (centis >= <NUM_LIT>)"}
{"input":"<s> function clockContent(centis) {<EOL>    if (centis === undefined)<EOL>        return h('<STR_LIT>', ['<STR_LIT>']);<EOL>    const date = new Date(centis * <NUM_LIT>), millis = date.getUTCMilliseconds(), sep = '<STR_LIT>', baseStr = pad2(date.getUTCMinutes()) + sep + pad2(date.getUTCSeconds());<EOL>     if (centis >= <NUM_LIT>)<EOL>        return h('<STR_LIT>', [Math.floor(centis / <NUM_LIT>) + sep + baseStr]);<EOL>    const tenthsStr = Math.floor(millis / <NUM_LIT>).toString();<EOL>    return h('<STR_LIT>', [<EOL>","gt":"baseStr,"}
{"input":"<s> function renderClock(color, centis, current) {<EOL>    return","gt":"h('<STR_LIT>', {"}
{"input":"<s> export default function renderGameAnalysis(ctrl) {<EOL>    const isPortrait = helper.isPortrait();<EOL>    const vd = helper.","gt":"viewportDim();"}
{"input":"<s> export function renderMove(ctx, node) {<EOL>    const ev = getBestEval({ client: node.ceval, server: node.eval }) || {};<EOL>","gt":"return [h('<STR_LIT>', fixCrazySan(node.san))]"}
{"input":"<s> function castlingButton(ctrl, c) {<EOL>    const cur = ctrl.data.editor.castles[c[<NUM_LIT>]];<EOL>","gt":"return h('<STR_LIT>', {"}
{"input":"<s> export function getLI(e) {<EOL>    const target = e.target","gt":";"}
{"input":"<s> export function slidesOutRight(callback, elID) {<EOL>    return function (fromBB) {<EOL>","gt":"const el = document.getElementById(elID);"}
{"input":"<s> export function respond(id, response) {<EOL>    return fetchJSON('<STR_LIT>' + id, {<EOL>","gt":"method: '<STR_LIT>',"}
{"input":"<s> export function thread(id) {<EOL>","gt":"return fetchJSON('<STR_LIT>' + id, {}, true);"}
{"input":"<s> function sendResponse(form) {<EOL>    const id = form[<NUM_LIT>].value;<EOL>    const response = form[<NUM_LIT>].value;<EOL>    if (!response)<EOL>        return;<EOL>    xhr.","gt":"respond(id, response)"}
{"input":"<s> function sendResponse(form) {<EOL>    const id = form[<NUM_LIT>].value;<EOL>    const response = form[<NUM_LIT>].value;<EOL>    if (!response)<EOL>        return;<EOL>    xhr. respond(id, response)<EOL>        .then((data) => {<EOL>        if (data.ok) {<EOL>            router.set('<STR_LIT>' + id);<EOL>        }<EOL>        else {<EOL>","gt":"redraw();"}
{"input":"<s> function stopAndClose(fromBB) {<EOL>    if (","gt":"fromBB !== '<STR_LIT>' && isOpenAndSeeking)"}
{"input":"<s> function open() {<EOL>    if (xhr.cachedPools.length === <NUM_LIT>) {<EOL>        xhr.lobby(false).","gt":"then(redraw);"}
{"input":"<s> function reload(ground, data, sit) {<EOL>    ground.","gt":"reconfigure(makeConfig(data, sit));"}
{"input":"<s> export function chatView(ctrl) {<EOL>    if (!ctrl.showing)<EOL>        return null;<EOL>    const player = ctrl.root.data.player;<EOL>    let","gt":"header = (!ctrl.root.data.opponent.user || ctrl.root.data.player.spectator) ? i18n('<STR_LIT>') : ctrl.root.data.opponent.user.username;"}
{"input":"<s> export function chatView(ctrl) {<EOL>    if (!ctrl.showing)<EOL>        return null;<EOL>    const player = ctrl.root.data.player;<EOL>    let  header = (!ctrl.root.data.opponent.user || ctrl.root.data.player.spectator) ? i18n('<STR_LIT>') : ctrl.root.data.opponent.user.username;<EOL>    const watchers = ctrl.root.data.watchers;<EOL>    if (ctrl.root.data.player.spectator && watchers && watchers.nb >= <NUM_LIT>) {<EOL>        header = i18n(","gt":"'<STR_LIT>') + '<STR_LIT>' + watchers.nb;"}
{"input":"<s> export function chatView(ctrl) {<EOL>    if (!ctrl.showing)<EOL>        return null;<EOL>    const player = ctrl.root.data.player;<EOL>    let  header = (!ctrl.root.data.opponent.user || ctrl.root.data.player.spectator) ? i18n('<STR_LIT>') : ctrl.root.data.opponent.user.username;<EOL>    const watchers = ctrl.root.data.watchers;<EOL>    if (ctrl.root.data.player.spectator && watchers && watchers.nb >= <NUM_LIT>) {<EOL>        header = i18n( '<STR_LIT>') + '<STR_LIT>' + watchers.nb;<EOL>    }<EOL>    return h('<STR_LIT>', { oncreate: helper.slidesInUp }, [<EOL>        h(","gt":"'<STR_LIT>', ["}
{"input":"<s> export function chatView(ctrl) {<EOL>    if (!ctrl.showing)<EOL>        return null;<EOL>    const player = ctrl.root.data.player;<EOL>    let  header = (!ctrl.root.data.opponent.user || ctrl.root.data.player.spectator) ? i18n('<STR_LIT>') : ctrl.root.data.opponent.user.username;<EOL>    const watchers = ctrl.root.data.watchers;<EOL>    if (ctrl.root.data.player.spectator && watchers && watchers.nb >= <NUM_LIT>) {<EOL>        header = i18n( '<STR_LIT>') + '<STR_LIT>' + watchers.nb;<EOL>    }<EOL>    return h('<STR_LIT>', { oncreate: helper.slidesInUp }, [<EOL>        h( '<STR_LIT>', [<EOL>            h('<STR_LIT>', {<EOL>                oncreate: helper.ontap(helper.slidesOutDown(ctrl.close, '<STR_LIT>'))<EOL>            }, closeIcon),<EOL>            h('<STR_LIT>', header)<EOL>        ]),<EOL>        h(","gt":"'<STR_LIT>', ["}
{"input":"<s> export function chatView(ctrl) {<EOL>    if (!ctrl.showing)<EOL>        return null;<EOL>    const player = ctrl.root.data.player;<EOL>    let  header = (!ctrl.root.data.opponent.user || ctrl.root.data.player.spectator) ? i18n('<STR_LIT>') : ctrl.root.data.opponent.user.username;<EOL>    const watchers = ctrl.root.data.watchers;<EOL>    if (ctrl.root.data.player.spectator && watchers && watchers.nb >= <NUM_LIT>) {<EOL>        header = i18n( '<STR_LIT>') + '<STR_LIT>' + watchers.nb;<EOL>    }<EOL>    return h('<STR_LIT>', { oncreate: helper.slidesInUp }, [<EOL>        h( '<STR_LIT>', [<EOL>            h('<STR_LIT>', {<EOL>                oncreate: helper.ontap(helper.slidesOutDown(ctrl.close, '<STR_LIT>'))<EOL>            }, closeIcon),<EOL>            h('<STR_LIT>', header)<EOL>        ]),<EOL>        h( '<STR_LIT>', [<EOL>            h('<STR_LIT>', {<EOL>                oncreate: ({ dom }) => scrollChatToBottom(dom),<EOL>                onupdate: ({ dom }) => scrollChatToBottom(dom)<EOL>            }, [<EOL>                h('<STR_LIT>', ctrl.selectLines().map((msg, i, all) => {<EOL>                    if (ctrl.root.data.player.spectator)<EOL>                        return spectatorChatRender(msg, i, all);<EOL>                    else<EOL>                        return playerChatRender(player, msg,","gt":"i,"}
{"input":"<s> export function chatView(ctrl) {<EOL>    if (!ctrl.showing)<EOL>        return null;<EOL>    const player = ctrl.root.data.player;<EOL>    let  header = (!ctrl.root.data.opponent.user || ctrl.root.data.player.spectator) ? i18n('<STR_LIT>') : ctrl.root.data.opponent.user.username;<EOL>    const watchers = ctrl.root.data.watchers;<EOL>    if (ctrl.root.data.player.spectator && watchers && watchers.nb >= <NUM_LIT>) {<EOL>        header = i18n( '<STR_LIT>') + '<STR_LIT>' + watchers.nb;<EOL>    }<EOL>    return h('<STR_LIT>', { oncreate: helper.slidesInUp }, [<EOL>        h( '<STR_LIT>', [<EOL>            h('<STR_LIT>', {<EOL>                oncreate: helper.ontap(helper.slidesOutDown(ctrl.close, '<STR_LIT>'))<EOL>            }, closeIcon),<EOL>            h('<STR_LIT>', header)<EOL>        ]),<EOL>        h( '<STR_LIT>', [<EOL>            h('<STR_LIT>', {<EOL>                oncreate: ({ dom }) => scrollChatToBottom(dom),<EOL>                onupdate: ({ dom }) => scrollChatToBottom(dom)<EOL>            }, [<EOL>                h('<STR_LIT>', ctrl.selectLines().map((msg, i, all) => {<EOL>                    if (ctrl.root.data.player.spectator)<EOL>                        return spectatorChatRender(msg, i, all);<EOL>                    else<EOL>                        return playerChatRender(player, msg,  i,","gt":"all);"}
{"input":"<s> export function chatView(ctrl) {<EOL>    if (!ctrl.showing)<EOL>        return null;<EOL>    const player = ctrl.root.data.player;<EOL>    let  header = (!ctrl.root.data.opponent.user || ctrl.root.data.player.spectator) ? i18n('<STR_LIT>') : ctrl.root.data.opponent.user.username;<EOL>    const watchers = ctrl.root.data.watchers;<EOL>    if (ctrl.root.data.player.spectator && watchers && watchers.nb >= <NUM_LIT>) {<EOL>        header = i18n( '<STR_LIT>') + '<STR_LIT>' + watchers.nb;<EOL>    }<EOL>    return h('<STR_LIT>', { oncreate: helper.slidesInUp }, [<EOL>        h( '<STR_LIT>', [<EOL>            h('<STR_LIT>', {<EOL>                oncreate: helper.ontap(helper.slidesOutDown(ctrl.close, '<STR_LIT>'))<EOL>            }, closeIcon),<EOL>            h('<STR_LIT>', header)<EOL>        ]),<EOL>        h( '<STR_LIT>', [<EOL>            h('<STR_LIT>', {<EOL>                oncreate: ({ dom }) => scrollChatToBottom(dom),<EOL>                onupdate: ({ dom }) => scrollChatToBottom(dom)<EOL>            }, [<EOL>                h('<STR_LIT>', ctrl.selectLines().map((msg, i, all) => {<EOL>                    if (ctrl.root.data.player.spectator)<EOL>                        return spectatorChatRender(msg, i, all);<EOL>                    else<EOL>                        return playerChatRender(player, msg,  i,  all);<EOL>                }))<EOL>            ]),<EOL>            h('<STR_LIT>', {<EOL>                onsubmit: (e) => {<EOL>                    e.preventDefault();<EOL>                    const target = e.target;<EOL>                    const ta = target[<NUM_LIT>];<EOL>                    ta.focus();<EOL>","gt":"const msg = ta.value.trim();"}
{"input":"<s> export function chatView(ctrl) {<EOL>    if (!ctrl.showing)<EOL>        return null;<EOL>    const player = ctrl.root.data.player;<EOL>    let  header = (!ctrl.root.data.opponent.user || ctrl.root.data.player.spectator) ? i18n('<STR_LIT>') : ctrl.root.data.opponent.user.username;<EOL>    const watchers = ctrl.root.data.watchers;<EOL>    if (ctrl.root.data.player.spectator && watchers && watchers.nb >= <NUM_LIT>) {<EOL>        header = i18n( '<STR_LIT>') + '<STR_LIT>' + watchers.nb;<EOL>    }<EOL>    return h('<STR_LIT>', { oncreate: helper.slidesInUp }, [<EOL>        h( '<STR_LIT>', [<EOL>            h('<STR_LIT>', {<EOL>                oncreate: helper.ontap(helper.slidesOutDown(ctrl.close, '<STR_LIT>'))<EOL>            }, closeIcon),<EOL>            h('<STR_LIT>', header)<EOL>        ]),<EOL>        h( '<STR_LIT>', [<EOL>            h('<STR_LIT>', {<EOL>                oncreate: ({ dom }) => scrollChatToBottom(dom),<EOL>                onupdate: ({ dom }) => scrollChatToBottom(dom)<EOL>            }, [<EOL>                h('<STR_LIT>', ctrl.selectLines().map((msg, i, all) => {<EOL>                    if (ctrl.root.data.player.spectator)<EOL>                        return spectatorChatRender(msg, i, all);<EOL>                    else<EOL>                        return playerChatRender(player, msg,  i,  all);<EOL>                }))<EOL>            ]),<EOL>            h('<STR_LIT>', {<EOL>                onsubmit: (e) => {<EOL>                    e.preventDefault();<EOL>                    const target = e.target;<EOL>                    const ta = target[<NUM_LIT>];<EOL>                    ta.focus();<EOL>                     const msg = ta.value.trim();<EOL>                    if (!validateMsg(msg))<EOL>                        return;<EOL>                    ctrl.inputValue = '<STR_LIT>';<EOL>                    ta.setAttribute('<STR_LIT>', '<STR_LIT>');<EOL>                    ta.style.paddingTop = '<STR_LIT>';<EOL>                    socket.send('<STR_LIT>', msg);<EOL>                    const sendButton = document.getElementById('<STR_LIT>');<EOL>                    if (sendButton) {<EOL>                        sendButton.classList.","gt":"add('<STR_LIT>');"}
{"input":"<s> export function chatView(ctrl) {<EOL>    if (!ctrl.showing)<EOL>        return null;<EOL>    const player = ctrl.root.data.player;<EOL>    let  header = (!ctrl.root.data.opponent.user || ctrl.root.data.player.spectator) ? i18n('<STR_LIT>') : ctrl.root.data.opponent.user.username;<EOL>    const watchers = ctrl.root.data.watchers;<EOL>    if (ctrl.root.data.player.spectator && watchers && watchers.nb >= <NUM_LIT>) {<EOL>        header = i18n( '<STR_LIT>') + '<STR_LIT>' + watchers.nb;<EOL>    }<EOL>    return h('<STR_LIT>', { oncreate: helper.slidesInUp }, [<EOL>        h( '<STR_LIT>', [<EOL>            h('<STR_LIT>', {<EOL>                oncreate: helper.ontap(helper.slidesOutDown(ctrl.close, '<STR_LIT>'))<EOL>            }, closeIcon),<EOL>            h('<STR_LIT>', header)<EOL>        ]),<EOL>        h( '<STR_LIT>', [<EOL>            h('<STR_LIT>', {<EOL>                oncreate: ({ dom }) => scrollChatToBottom(dom),<EOL>                onupdate: ({ dom }) => scrollChatToBottom(dom)<EOL>            }, [<EOL>                h('<STR_LIT>', ctrl.selectLines().map((msg, i, all) => {<EOL>                    if (ctrl.root.data.player.spectator)<EOL>                        return spectatorChatRender(msg, i, all);<EOL>                    else<EOL>                        return playerChatRender(player, msg,  i,  all);<EOL>                }))<EOL>            ]),<EOL>            h('<STR_LIT>', {<EOL>                onsubmit: (e) => {<EOL>                    e.preventDefault();<EOL>                    const target = e.target;<EOL>                    const ta = target[<NUM_LIT>];<EOL>                    ta.focus();<EOL>                     const msg = ta.value.trim();<EOL>                    if (!validateMsg(msg))<EOL>                        return;<EOL>                    ctrl.inputValue = '<STR_LIT>';<EOL>                    ta.setAttribute('<STR_LIT>', '<STR_LIT>');<EOL>                    ta.style.paddingTop = '<STR_LIT>';<EOL>                    socket.send('<STR_LIT>', msg);<EOL>                    const sendButton = document.getElementById('<STR_LIT>');<EOL>                    if (sendButton) {<EOL>                        sendButton.classList. add('<STR_LIT>');<EOL>                    }<EOL>                }<EOL>            }, [<EOL>                h('<STR_LIT>', {<EOL>                    placeholder: ctrl.canTalk(ctrl.root.data) ? i18n('<STR_LIT>') : '<STR_LIT>',<EOL>                    disabled: !ctrl.canTalk(","gt":"ctrl.root.data),"}
{"input":"<s> export function chatView(ctrl) {<EOL>    if (!ctrl.showing)<EOL>        return null;<EOL>    const player = ctrl.root.data.player;<EOL>    let  header = (!ctrl.root.data.opponent.user || ctrl.root.data.player.spectator) ? i18n('<STR_LIT>') : ctrl.root.data.opponent.user.username;<EOL>    const watchers = ctrl.root.data.watchers;<EOL>    if (ctrl.root.data.player.spectator && watchers && watchers.nb >= <NUM_LIT>) {<EOL>        header = i18n( '<STR_LIT>') + '<STR_LIT>' + watchers.nb;<EOL>    }<EOL>    return h('<STR_LIT>', { oncreate: helper.slidesInUp }, [<EOL>        h( '<STR_LIT>', [<EOL>            h('<STR_LIT>', {<EOL>                oncreate: helper.ontap(helper.slidesOutDown(ctrl.close, '<STR_LIT>'))<EOL>            }, closeIcon),<EOL>            h('<STR_LIT>', header)<EOL>        ]),<EOL>        h( '<STR_LIT>', [<EOL>            h('<STR_LIT>', {<EOL>                oncreate: ({ dom }) => scrollChatToBottom(dom),<EOL>                onupdate: ({ dom }) => scrollChatToBottom(dom)<EOL>            }, [<EOL>                h('<STR_LIT>', ctrl.selectLines().map((msg, i, all) => {<EOL>                    if (ctrl.root.data.player.spectator)<EOL>                        return spectatorChatRender(msg, i, all);<EOL>                    else<EOL>                        return playerChatRender(player, msg,  i,  all);<EOL>                }))<EOL>            ]),<EOL>            h('<STR_LIT>', {<EOL>                onsubmit: (e) => {<EOL>                    e.preventDefault();<EOL>                    const target = e.target;<EOL>                    const ta = target[<NUM_LIT>];<EOL>                    ta.focus();<EOL>                     const msg = ta.value.trim();<EOL>                    if (!validateMsg(msg))<EOL>                        return;<EOL>                    ctrl.inputValue = '<STR_LIT>';<EOL>                    ta.setAttribute('<STR_LIT>', '<STR_LIT>');<EOL>                    ta.style.paddingTop = '<STR_LIT>';<EOL>                    socket.send('<STR_LIT>', msg);<EOL>                    const sendButton = document.getElementById('<STR_LIT>');<EOL>                    if (sendButton) {<EOL>                        sendButton.classList. add('<STR_LIT>');<EOL>                    }<EOL>                }<EOL>            }, [<EOL>                h('<STR_LIT>', {<EOL>                    placeholder: ctrl.canTalk(ctrl.root.data) ? i18n('<STR_LIT>') : '<STR_LIT>',<EOL>                    disabled: !ctrl.canTalk( ctrl.root.data),<EOL>                    rows: <NUM_LIT>,<EOL>                    maxlength: <NUM_LIT>,<EOL>                    value:","gt":"ctrl.inputValue,"}
{"input":"<s> export function chatView(ctrl) {<EOL>    if (!ctrl.showing)<EOL>        return null;<EOL>    const player = ctrl.root.data.player;<EOL>    let  header = (!ctrl.root.data.opponent.user || ctrl.root.data.player.spectator) ? i18n('<STR_LIT>') : ctrl.root.data.opponent.user.username;<EOL>    const watchers = ctrl.root.data.watchers;<EOL>    if (ctrl.root.data.player.spectator && watchers && watchers.nb >= <NUM_LIT>) {<EOL>        header = i18n( '<STR_LIT>') + '<STR_LIT>' + watchers.nb;<EOL>    }<EOL>    return h('<STR_LIT>', { oncreate: helper.slidesInUp }, [<EOL>        h( '<STR_LIT>', [<EOL>            h('<STR_LIT>', {<EOL>                oncreate: helper.ontap(helper.slidesOutDown(ctrl.close, '<STR_LIT>'))<EOL>            }, closeIcon),<EOL>            h('<STR_LIT>', header)<EOL>        ]),<EOL>        h( '<STR_LIT>', [<EOL>            h('<STR_LIT>', {<EOL>                oncreate: ({ dom }) => scrollChatToBottom(dom),<EOL>                onupdate: ({ dom }) => scrollChatToBottom(dom)<EOL>            }, [<EOL>                h('<STR_LIT>', ctrl.selectLines().map((msg, i, all) => {<EOL>                    if (ctrl.root.data.player.spectator)<EOL>                        return spectatorChatRender(msg, i, all);<EOL>                    else<EOL>                        return playerChatRender(player, msg,  i,  all);<EOL>                }))<EOL>            ]),<EOL>            h('<STR_LIT>', {<EOL>                onsubmit: (e) => {<EOL>                    e.preventDefault();<EOL>                    const target = e.target;<EOL>                    const ta = target[<NUM_LIT>];<EOL>                    ta.focus();<EOL>                     const msg = ta.value.trim();<EOL>                    if (!validateMsg(msg))<EOL>                        return;<EOL>                    ctrl.inputValue = '<STR_LIT>';<EOL>                    ta.setAttribute('<STR_LIT>', '<STR_LIT>');<EOL>                    ta.style.paddingTop = '<STR_LIT>';<EOL>                    socket.send('<STR_LIT>', msg);<EOL>                    const sendButton = document.getElementById('<STR_LIT>');<EOL>                    if (sendButton) {<EOL>                        sendButton.classList. add('<STR_LIT>');<EOL>                    }<EOL>                }<EOL>            }, [<EOL>                h('<STR_LIT>', {<EOL>                    placeholder: ctrl.canTalk(ctrl.root.data) ? i18n('<STR_LIT>') : '<STR_LIT>',<EOL>                    disabled: !ctrl.canTalk( ctrl.root.data),<EOL>                    rows: <NUM_LIT>,<EOL>                    maxlength: <NUM_LIT>,<EOL>                    value:  ctrl.inputValue,<EOL>                    style: { lineHeight: '<STR_LIT>', margin: '<STR_LIT>', paddingTop: '<STR_LIT>' },<EOL>                    oninput(e) {<EOL>                        const ta = e.target;<EOL>                        if (ta.value.length > <NUM_LIT>)<EOL>                            ta.value = ta.value.substr(<NUM_LIT>, <NUM_LIT>);<EOL>                        ctrl.inputValue = ta.value;<EOL>                        const style = window.getComputedStyle(ta);<EOL>                        const taLineHeight = parseInt(style.lineHeight || '<STR_LIT>', <NUM_LIT>);<EOL>                        const taHeight = calculateContentHeight(","gt":"ta, taLineHeight);"}
{"input":"<s> export function chatView(ctrl) {<EOL>    if (!ctrl.showing)<EOL>        return null;<EOL>    const player = ctrl.root.data.player;<EOL>    let  header = (!ctrl.root.data.opponent.user || ctrl.root.data.player.spectator) ? i18n('<STR_LIT>') : ctrl.root.data.opponent.user.username;<EOL>    const watchers = ctrl.root.data.watchers;<EOL>    if (ctrl.root.data.player.spectator && watchers && watchers.nb >= <NUM_LIT>) {<EOL>        header = i18n( '<STR_LIT>') + '<STR_LIT>' + watchers.nb;<EOL>    }<EOL>    return h('<STR_LIT>', { oncreate: helper.slidesInUp }, [<EOL>        h( '<STR_LIT>', [<EOL>            h('<STR_LIT>', {<EOL>                oncreate: helper.ontap(helper.slidesOutDown(ctrl.close, '<STR_LIT>'))<EOL>            }, closeIcon),<EOL>            h('<STR_LIT>', header)<EOL>        ]),<EOL>        h( '<STR_LIT>', [<EOL>            h('<STR_LIT>', {<EOL>                oncreate: ({ dom }) => scrollChatToBottom(dom),<EOL>                onupdate: ({ dom }) => scrollChatToBottom(dom)<EOL>            }, [<EOL>                h('<STR_LIT>', ctrl.selectLines().map((msg, i, all) => {<EOL>                    if (ctrl.root.data.player.spectator)<EOL>                        return spectatorChatRender(msg, i, all);<EOL>                    else<EOL>                        return playerChatRender(player, msg,  i,  all);<EOL>                }))<EOL>            ]),<EOL>            h('<STR_LIT>', {<EOL>                onsubmit: (e) => {<EOL>                    e.preventDefault();<EOL>                    const target = e.target;<EOL>                    const ta = target[<NUM_LIT>];<EOL>                    ta.focus();<EOL>                     const msg = ta.value.trim();<EOL>                    if (!validateMsg(msg))<EOL>                        return;<EOL>                    ctrl.inputValue = '<STR_LIT>';<EOL>                    ta.setAttribute('<STR_LIT>', '<STR_LIT>');<EOL>                    ta.style.paddingTop = '<STR_LIT>';<EOL>                    socket.send('<STR_LIT>', msg);<EOL>                    const sendButton = document.getElementById('<STR_LIT>');<EOL>                    if (sendButton) {<EOL>                        sendButton.classList. add('<STR_LIT>');<EOL>                    }<EOL>                }<EOL>            }, [<EOL>                h('<STR_LIT>', {<EOL>                    placeholder: ctrl.canTalk(ctrl.root.data) ? i18n('<STR_LIT>') : '<STR_LIT>',<EOL>                    disabled: !ctrl.canTalk( ctrl.root.data),<EOL>                    rows: <NUM_LIT>,<EOL>                    maxlength: <NUM_LIT>,<EOL>                    value:  ctrl.inputValue,<EOL>                    style: { lineHeight: '<STR_LIT>', margin: '<STR_LIT>', paddingTop: '<STR_LIT>' },<EOL>                    oninput(e) {<EOL>                        const ta = e.target;<EOL>                        if (ta.value.length > <NUM_LIT>)<EOL>                            ta.value = ta.value.substr(<NUM_LIT>, <NUM_LIT>);<EOL>                        ctrl.inputValue = ta.value;<EOL>                        const style = window.getComputedStyle(ta);<EOL>                        const taLineHeight = parseInt(style.lineHeight || '<STR_LIT>', <NUM_LIT>);<EOL>                        const taHeight = calculateContentHeight( ta, taLineHeight);<EOL>                        const computedNbLines = Math.ceil(taHeight / taLineHeight);<EOL>                        const nbLines = computedNbLines <= <NUM_LIT> ? <NUM_LIT> :<EOL>                            computedNbLines > <NUM_LIT> ? <NUM_LIT> : computedNbLines - <NUM_LIT>;<EOL>                        ta.setAttribute('<STR_LIT>', String(nbLines));<EOL>                        if (nbLines === <NUM_LIT>)<EOL>                            ta.style.","gt":"paddingTop ="}
{"input":"<s> export function chatView(ctrl) {<EOL>    if (!ctrl.showing)<EOL>        return null;<EOL>    const player = ctrl.root.data.player;<EOL>    let  header = (!ctrl.root.data.opponent.user || ctrl.root.data.player.spectator) ? i18n('<STR_LIT>') : ctrl.root.data.opponent.user.username;<EOL>    const watchers = ctrl.root.data.watchers;<EOL>    if (ctrl.root.data.player.spectator && watchers && watchers.nb >= <NUM_LIT>) {<EOL>        header = i18n( '<STR_LIT>') + '<STR_LIT>' + watchers.nb;<EOL>    }<EOL>    return h('<STR_LIT>', { oncreate: helper.slidesInUp }, [<EOL>        h( '<STR_LIT>', [<EOL>            h('<STR_LIT>', {<EOL>                oncreate: helper.ontap(helper.slidesOutDown(ctrl.close, '<STR_LIT>'))<EOL>            }, closeIcon),<EOL>            h('<STR_LIT>', header)<EOL>        ]),<EOL>        h( '<STR_LIT>', [<EOL>            h('<STR_LIT>', {<EOL>                oncreate: ({ dom }) => scrollChatToBottom(dom),<EOL>                onupdate: ({ dom }) => scrollChatToBottom(dom)<EOL>            }, [<EOL>                h('<STR_LIT>', ctrl.selectLines().map((msg, i, all) => {<EOL>                    if (ctrl.root.data.player.spectator)<EOL>                        return spectatorChatRender(msg, i, all);<EOL>                    else<EOL>                        return playerChatRender(player, msg,  i,  all);<EOL>                }))<EOL>            ]),<EOL>            h('<STR_LIT>', {<EOL>                onsubmit: (e) => {<EOL>                    e.preventDefault();<EOL>                    const target = e.target;<EOL>                    const ta = target[<NUM_LIT>];<EOL>                    ta.focus();<EOL>                     const msg = ta.value.trim();<EOL>                    if (!validateMsg(msg))<EOL>                        return;<EOL>                    ctrl.inputValue = '<STR_LIT>';<EOL>                    ta.setAttribute('<STR_LIT>', '<STR_LIT>');<EOL>                    ta.style.paddingTop = '<STR_LIT>';<EOL>                    socket.send('<STR_LIT>', msg);<EOL>                    const sendButton = document.getElementById('<STR_LIT>');<EOL>                    if (sendButton) {<EOL>                        sendButton.classList. add('<STR_LIT>');<EOL>                    }<EOL>                }<EOL>            }, [<EOL>                h('<STR_LIT>', {<EOL>                    placeholder: ctrl.canTalk(ctrl.root.data) ? i18n('<STR_LIT>') : '<STR_LIT>',<EOL>                    disabled: !ctrl.canTalk( ctrl.root.data),<EOL>                    rows: <NUM_LIT>,<EOL>                    maxlength: <NUM_LIT>,<EOL>                    value:  ctrl.inputValue,<EOL>                    style: { lineHeight: '<STR_LIT>', margin: '<STR_LIT>', paddingTop: '<STR_LIT>' },<EOL>                    oninput(e) {<EOL>                        const ta = e.target;<EOL>                        if (ta.value.length > <NUM_LIT>)<EOL>                            ta.value = ta.value.substr(<NUM_LIT>, <NUM_LIT>);<EOL>                        ctrl.inputValue = ta.value;<EOL>                        const style = window.getComputedStyle(ta);<EOL>                        const taLineHeight = parseInt(style.lineHeight || '<STR_LIT>', <NUM_LIT>);<EOL>                        const taHeight = calculateContentHeight( ta, taLineHeight);<EOL>                        const computedNbLines = Math.ceil(taHeight / taLineHeight);<EOL>                        const nbLines = computedNbLines <= <NUM_LIT> ? <NUM_LIT> :<EOL>                            computedNbLines > <NUM_LIT> ? <NUM_LIT> : computedNbLines - <NUM_LIT>;<EOL>                        ta.setAttribute('<STR_LIT>', String(nbLines));<EOL>                        if (nbLines === <NUM_LIT>)<EOL>                            ta.style. paddingTop =","gt":"'<STR_LIT>';"}
{"input":"<s> export function chatView(ctrl) {<EOL>    if (!ctrl.showing)<EOL>        return null;<EOL>    const player = ctrl.root.data.player;<EOL>    let  header = (!ctrl.root.data.opponent.user || ctrl.root.data.player.spectator) ? i18n('<STR_LIT>') : ctrl.root.data.opponent.user.username;<EOL>    const watchers = ctrl.root.data.watchers;<EOL>    if (ctrl.root.data.player.spectator && watchers && watchers.nb >= <NUM_LIT>) {<EOL>        header = i18n( '<STR_LIT>') + '<STR_LIT>' + watchers.nb;<EOL>    }<EOL>    return h('<STR_LIT>', { oncreate: helper.slidesInUp }, [<EOL>        h( '<STR_LIT>', [<EOL>            h('<STR_LIT>', {<EOL>                oncreate: helper.ontap(helper.slidesOutDown(ctrl.close, '<STR_LIT>'))<EOL>            }, closeIcon),<EOL>            h('<STR_LIT>', header)<EOL>        ]),<EOL>        h( '<STR_LIT>', [<EOL>            h('<STR_LIT>', {<EOL>                oncreate: ({ dom }) => scrollChatToBottom(dom),<EOL>                onupdate: ({ dom }) => scrollChatToBottom(dom)<EOL>            }, [<EOL>                h('<STR_LIT>', ctrl.selectLines().map((msg, i, all) => {<EOL>                    if (ctrl.root.data.player.spectator)<EOL>                        return spectatorChatRender(msg, i, all);<EOL>                    else<EOL>                        return playerChatRender(player, msg,  i,  all);<EOL>                }))<EOL>            ]),<EOL>            h('<STR_LIT>', {<EOL>                onsubmit: (e) => {<EOL>                    e.preventDefault();<EOL>                    const target = e.target;<EOL>                    const ta = target[<NUM_LIT>];<EOL>                    ta.focus();<EOL>                     const msg = ta.value.trim();<EOL>                    if (!validateMsg(msg))<EOL>                        return;<EOL>                    ctrl.inputValue = '<STR_LIT>';<EOL>                    ta.setAttribute('<STR_LIT>', '<STR_LIT>');<EOL>                    ta.style.paddingTop = '<STR_LIT>';<EOL>                    socket.send('<STR_LIT>', msg);<EOL>                    const sendButton = document.getElementById('<STR_LIT>');<EOL>                    if (sendButton) {<EOL>                        sendButton.classList. add('<STR_LIT>');<EOL>                    }<EOL>                }<EOL>            }, [<EOL>                h('<STR_LIT>', {<EOL>                    placeholder: ctrl.canTalk(ctrl.root.data) ? i18n('<STR_LIT>') : '<STR_LIT>',<EOL>                    disabled: !ctrl.canTalk( ctrl.root.data),<EOL>                    rows: <NUM_LIT>,<EOL>                    maxlength: <NUM_LIT>,<EOL>                    value:  ctrl.inputValue,<EOL>                    style: { lineHeight: '<STR_LIT>', margin: '<STR_LIT>', paddingTop: '<STR_LIT>' },<EOL>                    oninput(e) {<EOL>                        const ta = e.target;<EOL>                        if (ta.value.length > <NUM_LIT>)<EOL>                            ta.value = ta.value.substr(<NUM_LIT>, <NUM_LIT>);<EOL>                        ctrl.inputValue = ta.value;<EOL>                        const style = window.getComputedStyle(ta);<EOL>                        const taLineHeight = parseInt(style.lineHeight || '<STR_LIT>', <NUM_LIT>);<EOL>                        const taHeight = calculateContentHeight( ta, taLineHeight);<EOL>                        const computedNbLines = Math.ceil(taHeight / taLineHeight);<EOL>                        const nbLines = computedNbLines <= <NUM_LIT> ? <NUM_LIT> :<EOL>                            computedNbLines > <NUM_LIT> ? <NUM_LIT> : computedNbLines - <NUM_LIT>;<EOL>                        ta.setAttribute('<STR_LIT>', String(nbLines));<EOL>                        if (nbLines === <NUM_LIT>)<EOL>                            ta.style. paddingTop =  '<STR_LIT>';<EOL>                        else<EOL>                            ta.style.paddingTop = '<STR_LIT>';<EOL>                        const sendButton = document.getElementById('<STR_LIT>');<EOL>","gt":"if (sendButton) {"}
{"input":"<s> export function chatView(ctrl) {<EOL>    if (!ctrl.showing)<EOL>        return null;<EOL>    const player = ctrl.root.data.player;<EOL>    let  header = (!ctrl.root.data.opponent.user || ctrl.root.data.player.spectator) ? i18n('<STR_LIT>') : ctrl.root.data.opponent.user.username;<EOL>    const watchers = ctrl.root.data.watchers;<EOL>    if (ctrl.root.data.player.spectator && watchers && watchers.nb >= <NUM_LIT>) {<EOL>        header = i18n( '<STR_LIT>') + '<STR_LIT>' + watchers.nb;<EOL>    }<EOL>    return h('<STR_LIT>', { oncreate: helper.slidesInUp }, [<EOL>        h( '<STR_LIT>', [<EOL>            h('<STR_LIT>', {<EOL>                oncreate: helper.ontap(helper.slidesOutDown(ctrl.close, '<STR_LIT>'))<EOL>            }, closeIcon),<EOL>            h('<STR_LIT>', header)<EOL>        ]),<EOL>        h( '<STR_LIT>', [<EOL>            h('<STR_LIT>', {<EOL>                oncreate: ({ dom }) => scrollChatToBottom(dom),<EOL>                onupdate: ({ dom }) => scrollChatToBottom(dom)<EOL>            }, [<EOL>                h('<STR_LIT>', ctrl.selectLines().map((msg, i, all) => {<EOL>                    if (ctrl.root.data.player.spectator)<EOL>                        return spectatorChatRender(msg, i, all);<EOL>                    else<EOL>                        return playerChatRender(player, msg,  i,  all);<EOL>                }))<EOL>            ]),<EOL>            h('<STR_LIT>', {<EOL>                onsubmit: (e) => {<EOL>                    e.preventDefault();<EOL>                    const target = e.target;<EOL>                    const ta = target[<NUM_LIT>];<EOL>                    ta.focus();<EOL>                     const msg = ta.value.trim();<EOL>                    if (!validateMsg(msg))<EOL>                        return;<EOL>                    ctrl.inputValue = '<STR_LIT>';<EOL>                    ta.setAttribute('<STR_LIT>', '<STR_LIT>');<EOL>                    ta.style.paddingTop = '<STR_LIT>';<EOL>                    socket.send('<STR_LIT>', msg);<EOL>                    const sendButton = document.getElementById('<STR_LIT>');<EOL>                    if (sendButton) {<EOL>                        sendButton.classList. add('<STR_LIT>');<EOL>                    }<EOL>                }<EOL>            }, [<EOL>                h('<STR_LIT>', {<EOL>                    placeholder: ctrl.canTalk(ctrl.root.data) ? i18n('<STR_LIT>') : '<STR_LIT>',<EOL>                    disabled: !ctrl.canTalk( ctrl.root.data),<EOL>                    rows: <NUM_LIT>,<EOL>                    maxlength: <NUM_LIT>,<EOL>                    value:  ctrl.inputValue,<EOL>                    style: { lineHeight: '<STR_LIT>', margin: '<STR_LIT>', paddingTop: '<STR_LIT>' },<EOL>                    oninput(e) {<EOL>                        const ta = e.target;<EOL>                        if (ta.value.length > <NUM_LIT>)<EOL>                            ta.value = ta.value.substr(<NUM_LIT>, <NUM_LIT>);<EOL>                        ctrl.inputValue = ta.value;<EOL>                        const style = window.getComputedStyle(ta);<EOL>                        const taLineHeight = parseInt(style.lineHeight || '<STR_LIT>', <NUM_LIT>);<EOL>                        const taHeight = calculateContentHeight( ta, taLineHeight);<EOL>                        const computedNbLines = Math.ceil(taHeight / taLineHeight);<EOL>                        const nbLines = computedNbLines <= <NUM_LIT> ? <NUM_LIT> :<EOL>                            computedNbLines > <NUM_LIT> ? <NUM_LIT> : computedNbLines - <NUM_LIT>;<EOL>                        ta.setAttribute('<STR_LIT>', String(nbLines));<EOL>                        if (nbLines === <NUM_LIT>)<EOL>                            ta.style. paddingTop =  '<STR_LIT>';<EOL>                        else<EOL>                            ta.style.paddingTop = '<STR_LIT>';<EOL>                        const sendButton = document.getElementById('<STR_LIT>');<EOL>                         if (sendButton) {<EOL>","gt":"if (validateMsg(ctrl.inputValue))"}
{"input":"<s> export function chatView(ctrl) {<EOL>    if (!ctrl.showing)<EOL>        return null;<EOL>    const player = ctrl.root.data.player;<EOL>    let  header = (!ctrl.root.data.opponent.user || ctrl.root.data.player.spectator) ? i18n('<STR_LIT>') : ctrl.root.data.opponent.user.username;<EOL>    const watchers = ctrl.root.data.watchers;<EOL>    if (ctrl.root.data.player.spectator && watchers && watchers.nb >= <NUM_LIT>) {<EOL>        header = i18n( '<STR_LIT>') + '<STR_LIT>' + watchers.nb;<EOL>    }<EOL>    return h('<STR_LIT>', { oncreate: helper.slidesInUp }, [<EOL>        h( '<STR_LIT>', [<EOL>            h('<STR_LIT>', {<EOL>                oncreate: helper.ontap(helper.slidesOutDown(ctrl.close, '<STR_LIT>'))<EOL>            }, closeIcon),<EOL>            h('<STR_LIT>', header)<EOL>        ]),<EOL>        h( '<STR_LIT>', [<EOL>            h('<STR_LIT>', {<EOL>                oncreate: ({ dom }) => scrollChatToBottom(dom),<EOL>                onupdate: ({ dom }) => scrollChatToBottom(dom)<EOL>            }, [<EOL>                h('<STR_LIT>', ctrl.selectLines().map((msg, i, all) => {<EOL>                    if (ctrl.root.data.player.spectator)<EOL>                        return spectatorChatRender(msg, i, all);<EOL>                    else<EOL>                        return playerChatRender(player, msg,  i,  all);<EOL>                }))<EOL>            ]),<EOL>            h('<STR_LIT>', {<EOL>                onsubmit: (e) => {<EOL>                    e.preventDefault();<EOL>                    const target = e.target;<EOL>                    const ta = target[<NUM_LIT>];<EOL>                    ta.focus();<EOL>                     const msg = ta.value.trim();<EOL>                    if (!validateMsg(msg))<EOL>                        return;<EOL>                    ctrl.inputValue = '<STR_LIT>';<EOL>                    ta.setAttribute('<STR_LIT>', '<STR_LIT>');<EOL>                    ta.style.paddingTop = '<STR_LIT>';<EOL>                    socket.send('<STR_LIT>', msg);<EOL>                    const sendButton = document.getElementById('<STR_LIT>');<EOL>                    if (sendButton) {<EOL>                        sendButton.classList. add('<STR_LIT>');<EOL>                    }<EOL>                }<EOL>            }, [<EOL>                h('<STR_LIT>', {<EOL>                    placeholder: ctrl.canTalk(ctrl.root.data) ? i18n('<STR_LIT>') : '<STR_LIT>',<EOL>                    disabled: !ctrl.canTalk( ctrl.root.data),<EOL>                    rows: <NUM_LIT>,<EOL>                    maxlength: <NUM_LIT>,<EOL>                    value:  ctrl.inputValue,<EOL>                    style: { lineHeight: '<STR_LIT>', margin: '<STR_LIT>', paddingTop: '<STR_LIT>' },<EOL>                    oninput(e) {<EOL>                        const ta = e.target;<EOL>                        if (ta.value.length > <NUM_LIT>)<EOL>                            ta.value = ta.value.substr(<NUM_LIT>, <NUM_LIT>);<EOL>                        ctrl.inputValue = ta.value;<EOL>                        const style = window.getComputedStyle(ta);<EOL>                        const taLineHeight = parseInt(style.lineHeight || '<STR_LIT>', <NUM_LIT>);<EOL>                        const taHeight = calculateContentHeight( ta, taLineHeight);<EOL>                        const computedNbLines = Math.ceil(taHeight / taLineHeight);<EOL>                        const nbLines = computedNbLines <= <NUM_LIT> ? <NUM_LIT> :<EOL>                            computedNbLines > <NUM_LIT> ? <NUM_LIT> : computedNbLines - <NUM_LIT>;<EOL>                        ta.setAttribute('<STR_LIT>', String(nbLines));<EOL>                        if (nbLines === <NUM_LIT>)<EOL>                            ta.style. paddingTop =  '<STR_LIT>';<EOL>                        else<EOL>                            ta.style.paddingTop = '<STR_LIT>';<EOL>                        const sendButton = document.getElementById('<STR_LIT>');<EOL>                         if (sendButton) {<EOL>                             if (validateMsg(ctrl.inputValue))<EOL>                                sendButton.classList.remove('<STR_LIT>');<EOL>","gt":"else"}
{"input":"<s> export function syncNote(gameId, notes) {<EOL>    return fetchText(`<STR_LIT>`, {<EOL>        method: '<STR_LIT>',<EOL>        headers: {<EOL>","gt":"'<STR_LIT>': '<STR_LIT>',"}
{"input":"<s> export function syncNote(gameId, notes) {<EOL>    return fetchText(`<STR_LIT>`, {<EOL>        method: '<STR_LIT>',<EOL>        headers: {<EOL>             '<STR_LIT>': '<STR_LIT>',<EOL>            '<STR_LIT>': '<STR_LIT>'<EOL>        },<EOL>        body: serializeQueryParameters({ text: notes })<EOL>    }, false)<EOL>        .catch((err) => {<EOL>        window.plugins.toast.","gt":"show(i18n('<STR_LIT>'), '<STR_LIT>', '<STR_LIT>');"}
{"input":"<s> function open() {<EOL>    router.backbutton.stack.push(helper.","gt":"slidesOutDown(close, '<STR_LIT>'));"}
{"input":"<s> export default function makeConfig(ctrl, userMove) {<EOL>    return {<EOL>        batchRAF: batchRequestAnimationFrame,<EOL>        fen:","gt":"ctrl.data.puzzle.fen,"}
{"input":"<s> export default function makeConfig(ctrl, userMove) {<EOL>    return {<EOL>        batchRAF: batchRequestAnimationFrame,<EOL>        fen:  ctrl.data.puzzle.fen,<EOL>        orientation: ctrl.data.puzzle.color,<EOL>        coordinates: settings.game.coords(),<EOL>        turnColor: ctrl.node.ply % <NUM_LIT> === <NUM_LIT> ?","gt":"'<STR_LIT>' : '<STR_LIT>',"}
{"input":"<s> export default function makeConfig(ctrl, userMove) {<EOL>    return {<EOL>        batchRAF: batchRequestAnimationFrame,<EOL>        fen:  ctrl.data.puzzle.fen,<EOL>        orientation: ctrl.data.puzzle.color,<EOL>        coordinates: settings.game.coords(),<EOL>        turnColor: ctrl.node.ply % <NUM_LIT> === <NUM_LIT> ?  '<STR_LIT>' : '<STR_LIT>',<EOL>        highlight: {<EOL>            lastMove: settings.game.highlights(),<EOL>            check: settings.game.highlights()<EOL>        },<EOL>        movable: {<EOL>            free: false,<EOL>","gt":"color: ctrl.data.puzzle.color,"}
{"input":"<s> export default function makeConfig(ctrl, userMove) {<EOL>    return {<EOL>        batchRAF: batchRequestAnimationFrame,<EOL>        fen:  ctrl.data.puzzle.fen,<EOL>        orientation: ctrl.data.puzzle.color,<EOL>        coordinates: settings.game.coords(),<EOL>        turnColor: ctrl.node.ply % <NUM_LIT> === <NUM_LIT> ?  '<STR_LIT>' : '<STR_LIT>',<EOL>        highlight: {<EOL>            lastMove: settings.game.highlights(),<EOL>            check: settings.game.highlights()<EOL>        },<EOL>        movable: {<EOL>            free: false,<EOL>             color: ctrl.data.puzzle.color,<EOL>            showDests: settings.game.pieceDestinations()<EOL>        },<EOL>        events: {<EOL>","gt":"move: userMove"}
{"input":"<s> <EOL>export function nbRemainingPuzzles(database, user) {<EOL>    return database.fetch(","gt":"user.id)"}
{"input":"<s> export function readDests(lines) {<EOL>    if (lines === undefined)<EOL>        return null;<EOL>    if (isDestMap(lines))<EOL>        return","gt":"lines;"}
{"input":"<s> export function readDests(lines) {<EOL>    if (lines === undefined)<EOL>        return null;<EOL>    if (isDestMap(lines))<EOL>        return  lines;<EOL>    const dests = {};<EOL>    if (lines && isString(lines))<EOL>        lines.split('<STR_LIT>').forEach((line) => {<EOL>            dests[piotr2key[line[<NUM_LIT>]]] = line.split('<STR_LIT>').slice(<NUM_LIT>).map((","gt":"c) => piotr2key[c]);"}
{"input":"<s> function linkReplace(match, before, url) {<EOL>    if (url.indexOf('<STR_LIT>') !== -<NUM_LIT>)<EOL>","gt":"return match;"}
{"input":"<s> export function hasNetwork() {<EOL>    return window.navigator.connection.type !== Connection.","gt":"NONE;"}
{"input":"<s> export function lichessAssetSrc(path) {<EOL>    return","gt":"apiEndPoint}/assets/${path}`<STR_LIT>;"}
{"input":"<s> function idleTimer(delay, onIdle, onWakeUp) {<EOL>    const events = ['<STR_LIT>'];<EOL>    let listening = false;<EOL>    let active = true;<EOL>    let lastSeenActive =","gt":"Date.now();"}
{"input":"<s> function idleTimer(delay, onIdle, onWakeUp) {<EOL>    const events = ['<STR_LIT>'];<EOL>    let listening = false;<EOL>    let active = true;<EOL>    let lastSeenActive =  Date.now();<EOL>    let intervalID;<EOL>    const","gt":"onActivity = () => {"}
{"input":"<s> function idleTimer(delay, onIdle, onWakeUp) {<EOL>    const events = ['<STR_LIT>'];<EOL>    let listening = false;<EOL>    let active = true;<EOL>    let lastSeenActive =  Date.now();<EOL>    let intervalID;<EOL>    const  onActivity = () => {<EOL>        if (!active) {<EOL>            <EOL>            onWakeUp();<EOL>        }<EOL>        active = true;<EOL>        lastSeenActive = Date.now();<EOL>        stopListening();<EOL>    };<EOL>    const startListening = () => {<EOL>        if (!listening) {<EOL>            events.forEach((e) => {<EOL>                document.addEventListener(","gt":"e, onActivity);"}
{"input":"<s> function idleTimer(delay, onIdle, onWakeUp) {<EOL>    const events = ['<STR_LIT>'];<EOL>    let listening = false;<EOL>    let active = true;<EOL>    let lastSeenActive =  Date.now();<EOL>    let intervalID;<EOL>    const  onActivity = () => {<EOL>        if (!active) {<EOL>            <EOL>            onWakeUp();<EOL>        }<EOL>        active = true;<EOL>        lastSeenActive = Date.now();<EOL>        stopListening();<EOL>    };<EOL>    const startListening = () => {<EOL>        if (!listening) {<EOL>            events.forEach((e) => {<EOL>                document.addEventListener( e, onActivity);<EOL>            });<EOL>            listening = true;<EOL>        }<EOL>    };<EOL>    const stopListening = () => {<EOL>","gt":"if (listening) {"}
{"input":"<s> function idleTimer(delay, onIdle, onWakeUp) {<EOL>    const events = ['<STR_LIT>'];<EOL>    let listening = false;<EOL>    let active = true;<EOL>    let lastSeenActive =  Date.now();<EOL>    let intervalID;<EOL>    const  onActivity = () => {<EOL>        if (!active) {<EOL>            <EOL>            onWakeUp();<EOL>        }<EOL>        active = true;<EOL>        lastSeenActive = Date.now();<EOL>        stopListening();<EOL>    };<EOL>    const startListening = () => {<EOL>        if (!listening) {<EOL>            events.forEach((e) => {<EOL>                document.addEventListener( e, onActivity);<EOL>            });<EOL>            listening = true;<EOL>        }<EOL>    };<EOL>    const stopListening = () => {<EOL>         if (listening) {<EOL>            events.forEach((e) => {<EOL>                document.removeEventListener(e, onActivity);<EOL>            });<EOL>            listening = false;<EOL>        }<EOL>    };<EOL>    const cancel = () => {<EOL>        clearInterval(","gt":"intervalID);"}
{"input":"<s> function idleTimer(delay, onIdle, onWakeUp) {<EOL>    const events = ['<STR_LIT>'];<EOL>    let listening = false;<EOL>    let active = true;<EOL>    let lastSeenActive =  Date.now();<EOL>    let intervalID;<EOL>    const  onActivity = () => {<EOL>        if (!active) {<EOL>            <EOL>            onWakeUp();<EOL>        }<EOL>        active = true;<EOL>        lastSeenActive = Date.now();<EOL>        stopListening();<EOL>    };<EOL>    const startListening = () => {<EOL>        if (!listening) {<EOL>            events.forEach((e) => {<EOL>                document.addEventListener( e, onActivity);<EOL>            });<EOL>            listening = true;<EOL>        }<EOL>    };<EOL>    const stopListening = () => {<EOL>         if (listening) {<EOL>            events.forEach((e) => {<EOL>                document.removeEventListener(e, onActivity);<EOL>            });<EOL>            listening = false;<EOL>        }<EOL>    };<EOL>    const cancel = () => {<EOL>        clearInterval( intervalID);<EOL>        stopListening();<EOL>    };<EOL>    intervalID = setInterval(() => {<EOL>","gt":"if (active && Date.now() - lastSeenActive > delay) {"}
{"input":"<s> export default function getDefaultConfig(resourceName) {<EOL>    return {<EOL>","gt":"key: \"<STR_LIT>\","}
{"input":"<s> function getValid() {<EOL>    return {<EOL>        id:","gt":"<NUM_LIT>,"}
{"input":"<s> export default function makeScope(config, reducerName) {<EOL>    return","gt":"config.resourceName + \"<STR_LIT>\" + reducerName;"}
{"input":"<s> function generateRandomNum() {<EOL>    return (","gt":"Math.floor(new Date().getTime() + Math.random() * <NUM_LIT>)).toString();"}
{"input":"<s> function retain(obj, attr) {<EOL>    const newObj = Object.create(null);<EOL>    for (const item in obj) {<EOL>        if (obj.hasOwnProperty(item)) {<EOL>            const arrAttr =","gt":"Array.isArray(attr) ? attr : [attr];"}
{"input":"<s> function generateRandomNum() {<EOL>    return (Math.","gt":"floor(new Date().getTime() + Math.random() * <NUM_LIT>)).toString();"}
{"input":"<s> function setPolarCoord(chart, coord) {<EOL>    let newCoord = {};<EOL>    if (coord.radius && (coord.radius < <NUM_LIT> || coord.radius > <NUM_LIT>) ||<EOL>        coord.innerRadius && (coord.innerRadius < <NUM_LIT> || coord.innerRadius > <NUM_LIT>)) {<EOL>        throw new Error(","gt":"'<STR_LIT>');"}
{"input":"<s> function setPolarCoord(chart, coord) {<EOL>    let newCoord = {};<EOL>    if (coord.radius && (coord.radius < <NUM_LIT> || coord.radius > <NUM_LIT>) ||<EOL>        coord.innerRadius && (coord.innerRadius < <NUM_LIT> || coord.innerRadius > <NUM_LIT>)) {<EOL>        throw new Error( '<STR_LIT>');<EOL>    }<EOL>","gt":"if (coord.radius) {"}
{"input":"<s> function setPolarCoord(chart, coord) {<EOL>    let newCoord = {};<EOL>    if (coord.radius && (coord.radius < <NUM_LIT> || coord.radius > <NUM_LIT>) ||<EOL>        coord.innerRadius && (coord.innerRadius < <NUM_LIT> || coord.innerRadius > <NUM_LIT>)) {<EOL>        throw new Error( '<STR_LIT>');<EOL>    }<EOL>     if (coord.radius) {<EOL>        newCoord = { ...newCoord, radius: coord.radius };<EOL>    }<EOL>    if (coord.innerRadius) {<EOL>        newCoord = { ...newCoord,","gt":"innerRadius: coord.innerRadius };"}
{"input":"<s> function setPolarCoord(chart, coord) {<EOL>    let newCoord = {};<EOL>    if (coord.radius && (coord.radius < <NUM_LIT> || coord.radius > <NUM_LIT>) ||<EOL>        coord.innerRadius && (coord.innerRadius < <NUM_LIT> || coord.innerRadius > <NUM_LIT>)) {<EOL>        throw new Error( '<STR_LIT>');<EOL>    }<EOL>     if (coord.radius) {<EOL>        newCoord = { ...newCoord, radius: coord.radius };<EOL>    }<EOL>    if (coord.innerRadius) {<EOL>        newCoord = { ...newCoord,  innerRadius: coord.innerRadius };<EOL>    }<EOL>    if (coord.startAngle || coord.endAngle) {<EOL>        if (coord.startAngle && (coord.startAngle < -<NUM_LIT> || coord.startAngle > <NUM_LIT>)) {<EOL>            throw new Error('<STR_LIT>');<EOL>        }<EOL>        else {<EOL>            newCoord = {<EOL>                ...newCoord,<EOL>                startAngle: degreeToRadian(coord.startAngle),<EOL>            };<EOL>        }<EOL>        if (coord.endAngle && (coord.endAngle < -<NUM_LIT> || coord.endAngle > <NUM_LIT>)) {<EOL>            throw new Error('<STR_LIT>');<EOL>        }<EOL>        else {<EOL>            newCoord = {<EOL>                ...newCoord,<EOL>                endAngle: degreeToRadian(coord.endAngle),<EOL>            };<EOL>        }<EOL>    }<EOL>    const polarCoord = chart.coord(coord.type, { ...newCoord });<EOL>    switch (coord.direction) {<EOL>        case '<STR_LIT>':<EOL>            polarCoord.transpose();<EOL>            break;<EOL>","gt":"case '<STR_LIT>':"}
{"input":"<s> function setPolarCoord(chart, coord) {<EOL>    let newCoord = {};<EOL>    if (coord.radius && (coord.radius < <NUM_LIT> || coord.radius > <NUM_LIT>) ||<EOL>        coord.innerRadius && (coord.innerRadius < <NUM_LIT> || coord.innerRadius > <NUM_LIT>)) {<EOL>        throw new Error( '<STR_LIT>');<EOL>    }<EOL>     if (coord.radius) {<EOL>        newCoord = { ...newCoord, radius: coord.radius };<EOL>    }<EOL>    if (coord.innerRadius) {<EOL>        newCoord = { ...newCoord,  innerRadius: coord.innerRadius };<EOL>    }<EOL>    if (coord.startAngle || coord.endAngle) {<EOL>        if (coord.startAngle && (coord.startAngle < -<NUM_LIT> || coord.startAngle > <NUM_LIT>)) {<EOL>            throw new Error('<STR_LIT>');<EOL>        }<EOL>        else {<EOL>            newCoord = {<EOL>                ...newCoord,<EOL>                startAngle: degreeToRadian(coord.startAngle),<EOL>            };<EOL>        }<EOL>        if (coord.endAngle && (coord.endAngle < -<NUM_LIT> || coord.endAngle > <NUM_LIT>)) {<EOL>            throw new Error('<STR_LIT>');<EOL>        }<EOL>        else {<EOL>            newCoord = {<EOL>                ...newCoord,<EOL>                endAngle: degreeToRadian(coord.endAngle),<EOL>            };<EOL>        }<EOL>    }<EOL>    const polarCoord = chart.coord(coord.type, { ...newCoord });<EOL>    switch (coord.direction) {<EOL>        case '<STR_LIT>':<EOL>            polarCoord.transpose();<EOL>            break;<EOL>         case '<STR_LIT>':<EOL>            polarCoord.reflect('<STR_LIT>');<EOL>            break;<EOL>        case '<STR_LIT>':<EOL>            polarCoord.reflect(","gt":"'<STR_LIT>');"}
{"input":"<s> function setSeriesAdjust(chart, currSeries) {<EOL>    const adjust = currSeries.adjust;<EOL>","gt":"if (!_.isNil(adjust)) {"}
{"input":"<s> export function weatherReducer(state, action) {<EOL>    switch (action.type) {<EOL>        case WEATHER_GET:<EOL>            return Object.assign({}, state, {<EOL>","gt":"isFetching: true,"}
{"input":"<s> export function weatherReducer(state, action) {<EOL>    switch (action.type) {<EOL>        case WEATHER_GET:<EOL>            return Object.assign({}, state, {<EOL>                 isFetching: true,<EOL>                airQualityError:","gt":"false,"}
{"input":"<s> export function weatherReducer(state, action) {<EOL>    switch (action.type) {<EOL>        case WEATHER_GET:<EOL>            return Object.assign({}, state, {<EOL>                 isFetching: true,<EOL>                airQualityError:  false,<EOL>                dataError: false,<EOL>                forecastError:","gt":"false"}
{"input":"<s> export function weatherReducer(state, action) {<EOL>    switch (action.type) {<EOL>        case WEATHER_GET:<EOL>            return Object.assign({}, state, {<EOL>                 isFetching: true,<EOL>                airQualityError:  false,<EOL>                dataError: false,<EOL>                forecastError:  false<EOL>            });<EOL>        case AIR_QUALITY_GET_SUCCESS:<EOL>            return Object.assign({}, state, {<EOL>                airQuality: action.payload<EOL>            });<EOL>","gt":"case AIR_QUALITY_GET_FAIL:"}
{"input":"<s> export function weatherReducer(state, action) {<EOL>    switch (action.type) {<EOL>        case WEATHER_GET:<EOL>            return Object.assign({}, state, {<EOL>                 isFetching: true,<EOL>                airQualityError:  false,<EOL>                dataError: false,<EOL>                forecastError:  false<EOL>            });<EOL>        case AIR_QUALITY_GET_SUCCESS:<EOL>            return Object.assign({}, state, {<EOL>                airQuality: action.payload<EOL>            });<EOL>         case AIR_QUALITY_GET_FAIL:<EOL>            return Object.assign({}, state, {<EOL>                airQualityError: true<EOL>            });<EOL>","gt":"case WEATHER_GET_SUCCESS:"}
{"input":"<s> export function weatherReducer(state, action) {<EOL>    switch (action.type) {<EOL>        case WEATHER_GET:<EOL>            return Object.assign({}, state, {<EOL>                 isFetching: true,<EOL>                airQualityError:  false,<EOL>                dataError: false,<EOL>                forecastError:  false<EOL>            });<EOL>        case AIR_QUALITY_GET_SUCCESS:<EOL>            return Object.assign({}, state, {<EOL>                airQuality: action.payload<EOL>            });<EOL>         case AIR_QUALITY_GET_FAIL:<EOL>            return Object.assign({}, state, {<EOL>                airQualityError: true<EOL>            });<EOL>         case WEATHER_GET_SUCCESS:<EOL>            return Object.assign({}, state, {<EOL>                data: action.payload<EOL>            });<EOL>        case WEATHER_GET_FAIL:<EOL>            return Object.","gt":"assign({}, state, {"}
{"input":"<s> export function weatherReducer(state, action) {<EOL>    switch (action.type) {<EOL>        case WEATHER_GET:<EOL>            return Object.assign({}, state, {<EOL>                 isFetching: true,<EOL>                airQualityError:  false,<EOL>                dataError: false,<EOL>                forecastError:  false<EOL>            });<EOL>        case AIR_QUALITY_GET_SUCCESS:<EOL>            return Object.assign({}, state, {<EOL>                airQuality: action.payload<EOL>            });<EOL>         case AIR_QUALITY_GET_FAIL:<EOL>            return Object.assign({}, state, {<EOL>                airQualityError: true<EOL>            });<EOL>         case WEATHER_GET_SUCCESS:<EOL>            return Object.assign({}, state, {<EOL>                data: action.payload<EOL>            });<EOL>        case WEATHER_GET_FAIL:<EOL>            return Object. assign({}, state, {<EOL>                dataError: true<EOL>            });<EOL>        case WEATHER_DATA_GET_SUCCESS:<EOL>            return Object.assign({}, state, {<EOL>                forecast: action.payload,<EOL>                isFetching: false<EOL>            });<EOL>        case WEATHER_DATA_GET_FAIL:<EOL>            return Object.","gt":"assign({}, state, {"}
{"input":"<s> export default function () {<EOL>    describe(\"<STR_LIT>\", () => {<EOL>        let buttonInGroupService;<EOL>        beforeEach(() => {<EOL>            buttonInGroupService = new ButtonInGroupService();<EOL>        });<EOL>","gt":"it(\"<STR_LIT>\", () => {"}
{"input":"<s> export default function () {<EOL>    describe(\"<STR_LIT>\", () => {<EOL>        let buttonInGroupService;<EOL>        beforeEach(() => {<EOL>            buttonInGroupService = new ButtonInGroupService();<EOL>        });<EOL>         it(\"<STR_LIT>\", () => {<EOL>            let testButton;<EOL>            buttonInGroupService.changes.subscribe((button) => {<EOL>                testButton = button;<EOL>            });<EOL>            const mockButton = new ClrButton(null);<EOL>            mockButton.inMenu = true;<EOL>            buttonInGroupService.","gt":"updateButtonGroup(mockButton);"}
{"input":"<s> export default function () {<EOL>    describe(\"<STR_LIT>\", function () {<EOL>        beforeEach(function () {<EOL>            this.domAdapter =","gt":"new DomAdapter();"}
{"input":"<s> export default function () {<EOL>    describe(\"<STR_LIT>\", function () {<EOL>        beforeEach(function () {<EOL>            this.domAdapter =  new DomAdapter();<EOL>            this.element = document.createElement(\"<STR_LIT>\");<EOL>            this.element.appendChild(document.","gt":"createTextNode(\"<STR_LIT>\"));"}
{"input":"<s> export default function () {<EOL>    describe(\"<STR_LIT>\", function () {<EOL>        beforeEach(function () {<EOL>            this.domAdapter =  new DomAdapter();<EOL>            this.element = document.createElement(\"<STR_LIT>\");<EOL>            this.element.appendChild(document. createTextNode(\"<STR_LIT>\"));<EOL>            document.body.appendChild(this.element);<EOL>        });<EOL>        afterEach(function () {<EOL>            document.body.removeChild(this.element);<EOL>        });<EOL>","gt":"it(\"<STR_LIT>\", function () {"}
{"input":"<s> export default function () {<EOL>    describe(\"<STR_LIT>\", function () {<EOL>        beforeEach(function () {<EOL>            this.domAdapter =  new DomAdapter();<EOL>            this.element = document.createElement(\"<STR_LIT>\");<EOL>            this.element.appendChild(document. createTextNode(\"<STR_LIT>\"));<EOL>            document.body.appendChild(this.element);<EOL>        });<EOL>        afterEach(function () {<EOL>            document.body.removeChild(this.element);<EOL>        });<EOL>         it(\"<STR_LIT>\", function () {<EOL>            const child = document.createElement(\"<STR_LIT>\");<EOL>            child.style.width = \"<STR_LIT>\";<EOL>            child.style.height = \"<STR_LIT>\";<EOL>            this.element.appendChild(child);<EOL>            expect(this.domAdapter.scrollWidth(this.element)).toBe(<NUM_LIT>);<EOL>        });<EOL>        it(\"<STR_LIT>\", function () {<EOL>            expect(this.domAdapter.scrollBarWidth(this.element)).toBe(<NUM_LIT>);<EOL>            this.element.style.overflow = \"<STR_LIT>\";<EOL>            <EOL>            <EOL>            if (/PhantomJS/.test(","gt":"window.navigator.userAgent)) {"}
{"input":"<s> export default function () {<EOL>    describe(\"<STR_LIT>\", function () {<EOL>        beforeEach(function () {<EOL>            this.domAdapter =  new DomAdapter();<EOL>            this.element = document.createElement(\"<STR_LIT>\");<EOL>            this.element.appendChild(document. createTextNode(\"<STR_LIT>\"));<EOL>            document.body.appendChild(this.element);<EOL>        });<EOL>        afterEach(function () {<EOL>            document.body.removeChild(this.element);<EOL>        });<EOL>         it(\"<STR_LIT>\", function () {<EOL>            const child = document.createElement(\"<STR_LIT>\");<EOL>            child.style.width = \"<STR_LIT>\";<EOL>            child.style.height = \"<STR_LIT>\";<EOL>            this.element.appendChild(child);<EOL>            expect(this.domAdapter.scrollWidth(this.element)).toBe(<NUM_LIT>);<EOL>        });<EOL>        it(\"<STR_LIT>\", function () {<EOL>            expect(this.domAdapter.scrollBarWidth(this.element)).toBe(<NUM_LIT>);<EOL>            this.element.style.overflow = \"<STR_LIT>\";<EOL>            <EOL>            <EOL>            if (/PhantomJS/.test( window.navigator.userAgent)) {<EOL>                expect(this.domAdapter.scrollBarWidth(this.element)).toBeGreaterThan(<NUM_LIT>);<EOL>            }<EOL>        });<EOL>        it(\"<STR_LIT>\", function () {<EOL>            const child = document.createElement(\"<STR_LIT>\");<EOL>            child.style.width = \"<STR_LIT>\";<EOL>","gt":"child.style.height = \"<STR_LIT>\";"}
{"input":"<s> export default function () {<EOL>    describe(\"<STR_LIT>\", function () {<EOL>        beforeEach(function () {<EOL>            this.domAdapter =  new DomAdapter();<EOL>            this.element = document.createElement(\"<STR_LIT>\");<EOL>            this.element.appendChild(document. createTextNode(\"<STR_LIT>\"));<EOL>            document.body.appendChild(this.element);<EOL>        });<EOL>        afterEach(function () {<EOL>            document.body.removeChild(this.element);<EOL>        });<EOL>         it(\"<STR_LIT>\", function () {<EOL>            const child = document.createElement(\"<STR_LIT>\");<EOL>            child.style.width = \"<STR_LIT>\";<EOL>            child.style.height = \"<STR_LIT>\";<EOL>            this.element.appendChild(child);<EOL>            expect(this.domAdapter.scrollWidth(this.element)).toBe(<NUM_LIT>);<EOL>        });<EOL>        it(\"<STR_LIT>\", function () {<EOL>            expect(this.domAdapter.scrollBarWidth(this.element)).toBe(<NUM_LIT>);<EOL>            this.element.style.overflow = \"<STR_LIT>\";<EOL>            <EOL>            <EOL>            if (/PhantomJS/.test( window.navigator.userAgent)) {<EOL>                expect(this.domAdapter.scrollBarWidth(this.element)).toBeGreaterThan(<NUM_LIT>);<EOL>            }<EOL>        });<EOL>        it(\"<STR_LIT>\", function () {<EOL>            const child = document.createElement(\"<STR_LIT>\");<EOL>            child.style.width = \"<STR_LIT>\";<EOL>             child.style.height = \"<STR_LIT>\";<EOL>            this.element.replaceChild(child, this.element.firstChild);<EOL>            expect(this.domAdapter.computedHeight(this.element)).toBe(<NUM_LIT>);<EOL>        });<EOL>        describe(\"<STR_LIT>\", function () {<EOL>            it(\"<STR_LIT>\", function () {<EOL>                expect(this.domAdapter.userDefinedWidth(this.element)).toBe(<NUM_LIT>);<EOL>                this.element.style.width = \"<STR_LIT>\";<EOL>                expect(this.domAdapter.userDefinedWidth(this.element)).toBe(<NUM_LIT>);<EOL>            });<EOL>            it(\"<STR_LIT>\", function () {<EOL>                expect(this.domAdapter.userDefinedWidth(this.element)).toBe(","gt":"<NUM_LIT>);"}
{"input":"<s> export default function () {<EOL>    describe(\"<STR_LIT>\", function () {<EOL>        beforeEach(function () {<EOL>            this.domAdapter =  new DomAdapter();<EOL>            this.element = document.createElement(\"<STR_LIT>\");<EOL>            this.element.appendChild(document. createTextNode(\"<STR_LIT>\"));<EOL>            document.body.appendChild(this.element);<EOL>        });<EOL>        afterEach(function () {<EOL>            document.body.removeChild(this.element);<EOL>        });<EOL>         it(\"<STR_LIT>\", function () {<EOL>            const child = document.createElement(\"<STR_LIT>\");<EOL>            child.style.width = \"<STR_LIT>\";<EOL>            child.style.height = \"<STR_LIT>\";<EOL>            this.element.appendChild(child);<EOL>            expect(this.domAdapter.scrollWidth(this.element)).toBe(<NUM_LIT>);<EOL>        });<EOL>        it(\"<STR_LIT>\", function () {<EOL>            expect(this.domAdapter.scrollBarWidth(this.element)).toBe(<NUM_LIT>);<EOL>            this.element.style.overflow = \"<STR_LIT>\";<EOL>            <EOL>            <EOL>            if (/PhantomJS/.test( window.navigator.userAgent)) {<EOL>                expect(this.domAdapter.scrollBarWidth(this.element)).toBeGreaterThan(<NUM_LIT>);<EOL>            }<EOL>        });<EOL>        it(\"<STR_LIT>\", function () {<EOL>            const child = document.createElement(\"<STR_LIT>\");<EOL>            child.style.width = \"<STR_LIT>\";<EOL>             child.style.height = \"<STR_LIT>\";<EOL>            this.element.replaceChild(child, this.element.firstChild);<EOL>            expect(this.domAdapter.computedHeight(this.element)).toBe(<NUM_LIT>);<EOL>        });<EOL>        describe(\"<STR_LIT>\", function () {<EOL>            it(\"<STR_LIT>\", function () {<EOL>                expect(this.domAdapter.userDefinedWidth(this.element)).toBe(<NUM_LIT>);<EOL>                this.element.style.width = \"<STR_LIT>\";<EOL>                expect(this.domAdapter.userDefinedWidth(this.element)).toBe(<NUM_LIT>);<EOL>            });<EOL>            it(\"<STR_LIT>\", function () {<EOL>                expect(this.domAdapter.userDefinedWidth(this.element)).toBe( <NUM_LIT>);<EOL>                const style = document.createElement(\"<STR_LIT>\");<EOL>                style.appendChild(document.createTextNode(\"<STR_LIT>\"));<EOL>                document.body.appendChild(style);<EOL>                this.element.classList.add(\"<STR_LIT>\");<EOL>","gt":"expect(this.domAdapter.userDefinedWidth(this.element)).toBe(<NUM_LIT>);"}
{"input":"<s> export default function () {<EOL>    describe(\"<STR_LIT>\", function () {<EOL>        beforeEach(function () {<EOL>            this.domAdapter =  new DomAdapter();<EOL>            this.element = document.createElement(\"<STR_LIT>\");<EOL>            this.element.appendChild(document. createTextNode(\"<STR_LIT>\"));<EOL>            document.body.appendChild(this.element);<EOL>        });<EOL>        afterEach(function () {<EOL>            document.body.removeChild(this.element);<EOL>        });<EOL>         it(\"<STR_LIT>\", function () {<EOL>            const child = document.createElement(\"<STR_LIT>\");<EOL>            child.style.width = \"<STR_LIT>\";<EOL>            child.style.height = \"<STR_LIT>\";<EOL>            this.element.appendChild(child);<EOL>            expect(this.domAdapter.scrollWidth(this.element)).toBe(<NUM_LIT>);<EOL>        });<EOL>        it(\"<STR_LIT>\", function () {<EOL>            expect(this.domAdapter.scrollBarWidth(this.element)).toBe(<NUM_LIT>);<EOL>            this.element.style.overflow = \"<STR_LIT>\";<EOL>            <EOL>            <EOL>            if (/PhantomJS/.test( window.navigator.userAgent)) {<EOL>                expect(this.domAdapter.scrollBarWidth(this.element)).toBeGreaterThan(<NUM_LIT>);<EOL>            }<EOL>        });<EOL>        it(\"<STR_LIT>\", function () {<EOL>            const child = document.createElement(\"<STR_LIT>\");<EOL>            child.style.width = \"<STR_LIT>\";<EOL>             child.style.height = \"<STR_LIT>\";<EOL>            this.element.replaceChild(child, this.element.firstChild);<EOL>            expect(this.domAdapter.computedHeight(this.element)).toBe(<NUM_LIT>);<EOL>        });<EOL>        describe(\"<STR_LIT>\", function () {<EOL>            it(\"<STR_LIT>\", function () {<EOL>                expect(this.domAdapter.userDefinedWidth(this.element)).toBe(<NUM_LIT>);<EOL>                this.element.style.width = \"<STR_LIT>\";<EOL>                expect(this.domAdapter.userDefinedWidth(this.element)).toBe(<NUM_LIT>);<EOL>            });<EOL>            it(\"<STR_LIT>\", function () {<EOL>                expect(this.domAdapter.userDefinedWidth(this.element)).toBe( <NUM_LIT>);<EOL>                const style = document.createElement(\"<STR_LIT>\");<EOL>                style.appendChild(document.createTextNode(\"<STR_LIT>\"));<EOL>                document.body.appendChild(style);<EOL>                this.element.classList.add(\"<STR_LIT>\");<EOL>                 expect(this.domAdapter.userDefinedWidth(this.element)).toBe(<NUM_LIT>);<EOL>                document.body.removeChild(style);<EOL>            });<EOL>            it(\"<STR_LIT>\",","gt":"function () {"}
{"input":"<s> export default function () {<EOL>    describe(\"<STR_LIT>\", function () {<EOL>        let context;<EOL>        beforeEach(function () {<EOL>            context = this.create(ClrDropdownMenu, SimpleTest, [IfOpenService]);<EOL>            context.getClarityProvider(IfOpenService).open =","gt":"true;"}
{"input":"<s> export default function () {<EOL>    describe(\"<STR_LIT>\", function () {<EOL>        let context;<EOL>        beforeEach(function () {<EOL>            context = this.create(ClrDropdownMenu, SimpleTest, [IfOpenService]);<EOL>            context.getClarityProvider(IfOpenService).open =  true;<EOL>            context.detectChanges();<EOL>        });<EOL>        it(\"<STR_LIT>\", function () {<EOL>            expect(context.","gt":"clarityElement.textContent.trim()).toMatch(\"<STR_LIT>\");"}
{"input":"<s> export default function () {<EOL>    describe(\"<STR_LIT>\", function () {<EOL>        let context;<EOL>        beforeEach(function () {<EOL>            context = this.create(ClrDropdownMenu, SimpleTest, [IfOpenService]);<EOL>            context.getClarityProvider(IfOpenService).open =  true;<EOL>            context.detectChanges();<EOL>        });<EOL>        it(\"<STR_LIT>\", function () {<EOL>            expect(context. clarityElement.textContent.trim()).toMatch(\"<STR_LIT>\");<EOL>        });<EOL>        it(\"<STR_LIT>\", () => {<EOL>            expect(","gt":"context.testElement.querySelector(\"<STR_LIT>\")).not.toBeNull();"}
{"input":"<s> export default function () {<EOL>    describe(\"<STR_LIT>\", function () {<EOL>        let context;<EOL>        beforeEach(function () {<EOL>            context = this.create(ClrDropdownMenu, SimpleTest, [IfOpenService]);<EOL>            context.getClarityProvider(IfOpenService).open =  true;<EOL>            context.detectChanges();<EOL>        });<EOL>        it(\"<STR_LIT>\", function () {<EOL>            expect(context. clarityElement.textContent.trim()).toMatch(\"<STR_LIT>\");<EOL>        });<EOL>        it(\"<STR_LIT>\", () => {<EOL>            expect( context.testElement.querySelector(\"<STR_LIT>\")).not.toBeNull();<EOL>        });<EOL>        it(\"<STR_LIT>\", () => {<EOL>            <EOL>            expect(context.clarityDirective.anchorPoint).toEqual(Point.BOTTOM_LEFT);<EOL>            expect(context.clarityDirective.popoverPoint).toEqual(Point.LEFT_TOP);<EOL>            context.clarityDirective.position = \"<STR_LIT>\";<EOL>            context.detectChanges();<EOL>            expect(context.clarityDirective.anchorPoint).toEqual(Point.BOTTOM_RIGHT);<EOL>            expect(context.clarityDirective.popoverPoint).toEqual(","gt":"Point.RIGHT_TOP);"}
{"input":"<s> export default function () {<EOL>    describe(\"<STR_LIT>\", function () {<EOL>        let ifActiveService;<EOL>        beforeEach(function () {<EOL>            ifActiveService =","gt":"new IfActiveService();"}
{"input":"<s> export default function () {<EOL>    describe(\"<STR_LIT>\", function () {<EOL>        let ifActiveService;<EOL>        beforeEach(function () {<EOL>            ifActiveService =  new IfActiveService();<EOL>        });<EOL>        describe(\"<STR_LIT>\",","gt":"function () {"}
{"input":"<s> export default function () {<EOL>    describe(\"<STR_LIT>\", function () {<EOL>        let ifActiveService;<EOL>        beforeEach(function () {<EOL>            ifActiveService =  new IfActiveService();<EOL>        });<EOL>        describe(\"<STR_LIT>\",  function () {<EOL>            it(\"<STR_LIT>\", function () {<EOL>                let nbChanges =","gt":"<NUM_LIT>;"}
{"input":"<s> export default function () {<EOL>    describe(\"<STR_LIT>\", function () {<EOL>        let ifActiveService;<EOL>        beforeEach(function () {<EOL>            ifActiveService =  new IfActiveService();<EOL>        });<EOL>        describe(\"<STR_LIT>\",  function () {<EOL>            it(\"<STR_LIT>\", function () {<EOL>                let nbChanges =  <NUM_LIT>;<EOL>                let currentChange;<EOL>                <EOL>                ifActiveService.currentChange.subscribe((change) => {<EOL>                    nbChanges++;<EOL>","gt":"currentChange = change;"}
{"input":"<s> export default function () {<EOL>    describe(\"<STR_LIT>\", function () {<EOL>        let ifActiveService;<EOL>        beforeEach(function () {<EOL>            ifActiveService =  new IfActiveService();<EOL>        });<EOL>        describe(\"<STR_LIT>\",  function () {<EOL>            it(\"<STR_LIT>\", function () {<EOL>                let nbChanges =  <NUM_LIT>;<EOL>                let currentChange;<EOL>                <EOL>                ifActiveService.currentChange.subscribe((change) => {<EOL>                    nbChanges++;<EOL>                     currentChange = change;<EOL>                });<EOL>                <EOL>                expect(ifActiveService).toBeDefined();<EOL>                expect(nbChanges).toEqual(<NUM_LIT>);<EOL>                expect(","gt":"currentChange).not.toBeDefined();"}
{"input":"<s> export default function () {<EOL>    describe(\"<STR_LIT>\", function () {<EOL>        let ifActiveService;<EOL>        beforeEach(function () {<EOL>            ifActiveService =  new IfActiveService();<EOL>        });<EOL>        describe(\"<STR_LIT>\",  function () {<EOL>            it(\"<STR_LIT>\", function () {<EOL>                let nbChanges =  <NUM_LIT>;<EOL>                let currentChange;<EOL>                <EOL>                ifActiveService.currentChange.subscribe((change) => {<EOL>                    nbChanges++;<EOL>                     currentChange = change;<EOL>                });<EOL>                <EOL>                expect(ifActiveService).toBeDefined();<EOL>                expect(nbChanges).toEqual(<NUM_LIT>);<EOL>                expect( currentChange).not.toBeDefined();<EOL>                <EOL>                ifActiveService.current = <NUM_LIT>;<EOL>                expect(nbChanges).toEqual(<NUM_LIT>);<EOL>                expect(currentChange).toEqual(","gt":"<NUM_LIT>);"}
{"input":"<s> export default function () {<EOL>    describe(\"<STR_LIT>\", function () {<EOL>        let ifActiveService;<EOL>        beforeEach(function () {<EOL>            ifActiveService =  new IfActiveService();<EOL>        });<EOL>        describe(\"<STR_LIT>\",  function () {<EOL>            it(\"<STR_LIT>\", function () {<EOL>                let nbChanges =  <NUM_LIT>;<EOL>                let currentChange;<EOL>                <EOL>                ifActiveService.currentChange.subscribe((change) => {<EOL>                    nbChanges++;<EOL>                     currentChange = change;<EOL>                });<EOL>                <EOL>                expect(ifActiveService).toBeDefined();<EOL>                expect(nbChanges).toEqual(<NUM_LIT>);<EOL>                expect( currentChange).not.toBeDefined();<EOL>                <EOL>                ifActiveService.current = <NUM_LIT>;<EOL>                expect(nbChanges).toEqual(<NUM_LIT>);<EOL>                expect(currentChange).toEqual( <NUM_LIT>);<EOL>                <EOL>                ifActiveService.current = <NUM_LIT>;<EOL>                expect(nbChanges).toEqual(<NUM_LIT>);<EOL>                expect(currentChange).toEqual(<NUM_LIT>);<EOL>            });<EOL>            it(\"<STR_LIT>\", function () {<EOL>                expect(ifActiveService.current).not.toBeDefined();<EOL>                ifActiveService.current = <NUM_LIT>;<EOL>                expect(ifActiveService.current).toEqual(","gt":"<NUM_LIT>);"}
{"input":"<s> export default function () {<EOL>    describe(\"<STR_LIT>\", function () {<EOL>        let ifActiveService;<EOL>        beforeEach(function () {<EOL>            ifActiveService =  new IfActiveService();<EOL>        });<EOL>        describe(\"<STR_LIT>\",  function () {<EOL>            it(\"<STR_LIT>\", function () {<EOL>                let nbChanges =  <NUM_LIT>;<EOL>                let currentChange;<EOL>                <EOL>                ifActiveService.currentChange.subscribe((change) => {<EOL>                    nbChanges++;<EOL>                     currentChange = change;<EOL>                });<EOL>                <EOL>                expect(ifActiveService).toBeDefined();<EOL>                expect(nbChanges).toEqual(<NUM_LIT>);<EOL>                expect( currentChange).not.toBeDefined();<EOL>                <EOL>                ifActiveService.current = <NUM_LIT>;<EOL>                expect(nbChanges).toEqual(<NUM_LIT>);<EOL>                expect(currentChange).toEqual( <NUM_LIT>);<EOL>                <EOL>                ifActiveService.current = <NUM_LIT>;<EOL>                expect(nbChanges).toEqual(<NUM_LIT>);<EOL>                expect(currentChange).toEqual(<NUM_LIT>);<EOL>            });<EOL>            it(\"<STR_LIT>\", function () {<EOL>                expect(ifActiveService.current).not.toBeDefined();<EOL>                ifActiveService.current = <NUM_LIT>;<EOL>                expect(ifActiveService.current).toEqual( <NUM_LIT>);<EOL>            });<EOL>            it(\"<STR_LIT>\", function () {<EOL>                const init = <NUM_LIT>;<EOL>                let","gt":"test;"}
{"input":"<s> export default function () {<EOL>    describe(\"<STR_LIT>\", function () {<EOL>        describe(\"<STR_LIT>\", function () {<EOL>            beforeEach(","gt":"function () {"}
{"input":"<s> export default function () {<EOL>    describe(\"<STR_LIT>\", function () {<EOL>        describe(\"<STR_LIT>\", function () {<EOL>            beforeEach( function () {<EOL>                <EOL>                TestBed.configureTestingModule({ declarations: [IfExpanded, SimpleTest, TestCounter], providers: [Expand] });<EOL>                this.fixture = TestBed.","gt":"createComponent(SimpleTest);"}
{"input":"<s> export default function () {<EOL>    describe(\"<STR_LIT>\", function () {<EOL>        describe(\"<STR_LIT>\", function () {<EOL>            beforeEach( function () {<EOL>                <EOL>                TestBed.configureTestingModule({ declarations: [IfExpanded, SimpleTest, TestCounter], providers: [Expand] });<EOL>                this.fixture = TestBed. createComponent(SimpleTest);<EOL>                this.fixture.detectChanges();<EOL>                this.","gt":"testComponent = this.fixture.componentInstance;"}
{"input":"<s> export default function () {<EOL>    describe(\"<STR_LIT>\", function () {<EOL>        describe(\"<STR_LIT>\", function () {<EOL>            beforeEach( function () {<EOL>                <EOL>                TestBed.configureTestingModule({ declarations: [IfExpanded, SimpleTest, TestCounter], providers: [Expand] });<EOL>                this.fixture = TestBed. createComponent(SimpleTest);<EOL>                this.fixture.detectChanges();<EOL>                this. testComponent = this.fixture.componentInstance;<EOL>                this.testElement = this.fixture.nativeElement;<EOL>                this.clarityDirective = this.fixture.componentInstance.ifExpanded;<EOL>                this.expand = TestBed.get(Expand);<EOL>            });<EOL>            afterEach(","gt":"function () {"}
{"input":"<s> export default function () {<EOL>    describe(\"<STR_LIT>\", function () {<EOL>        describe(\"<STR_LIT>\", function () {<EOL>            beforeEach( function () {<EOL>                <EOL>                TestBed.configureTestingModule({ declarations: [IfExpanded, SimpleTest, TestCounter], providers: [Expand] });<EOL>                this.fixture = TestBed. createComponent(SimpleTest);<EOL>                this.fixture.detectChanges();<EOL>                this. testComponent = this.fixture.componentInstance;<EOL>                this.testElement = this.fixture.nativeElement;<EOL>                this.clarityDirective = this.fixture.componentInstance.ifExpanded;<EOL>                this.expand = TestBed.get(Expand);<EOL>            });<EOL>            afterEach( function () {<EOL>                this.fixture.destroy();<EOL>            });<EOL>            it(\"<STR_LIT>\", function () {<EOL>                expect(this.testElement.textContent.trim()).toBe(\"<STR_LIT>\");<EOL>            });<EOL>            it(\"<STR_LIT>\", function () {<EOL>                this.expand.expanded = true;<EOL>                this.","gt":"fixture.detectChanges();"}
{"input":"<s> export default function () {<EOL>    describe(\"<STR_LIT>\", function () {<EOL>        describe(\"<STR_LIT>\", function () {<EOL>            beforeEach( function () {<EOL>                <EOL>                TestBed.configureTestingModule({ declarations: [IfExpanded, SimpleTest, TestCounter], providers: [Expand] });<EOL>                this.fixture = TestBed. createComponent(SimpleTest);<EOL>                this.fixture.detectChanges();<EOL>                this. testComponent = this.fixture.componentInstance;<EOL>                this.testElement = this.fixture.nativeElement;<EOL>                this.clarityDirective = this.fixture.componentInstance.ifExpanded;<EOL>                this.expand = TestBed.get(Expand);<EOL>            });<EOL>            afterEach( function () {<EOL>                this.fixture.destroy();<EOL>            });<EOL>            it(\"<STR_LIT>\", function () {<EOL>                expect(this.testElement.textContent.trim()).toBe(\"<STR_LIT>\");<EOL>            });<EOL>            it(\"<STR_LIT>\", function () {<EOL>                this.expand.expanded = true;<EOL>                this. fixture.detectChanges();<EOL>                expect(this.testElement.textContent.trim()).toBe(\"<STR_LIT>\");<EOL>            });<EOL>            it(\"<STR_LIT>\", function () {<EOL>                this.expand.expanded = true;<EOL>                this.fixture.detectChanges();<EOL>                this.expand.expanded = false;<EOL>                this.","gt":"fixture.detectChanges();"}
{"input":"<s> export default function () {<EOL>    describe(\"<STR_LIT>\", function () {<EOL>        describe(\"<STR_LIT>\", function () {<EOL>            beforeEach( function () {<EOL>                <EOL>                TestBed.configureTestingModule({ declarations: [IfExpanded, SimpleTest, TestCounter], providers: [Expand] });<EOL>                this.fixture = TestBed. createComponent(SimpleTest);<EOL>                this.fixture.detectChanges();<EOL>                this. testComponent = this.fixture.componentInstance;<EOL>                this.testElement = this.fixture.nativeElement;<EOL>                this.clarityDirective = this.fixture.componentInstance.ifExpanded;<EOL>                this.expand = TestBed.get(Expand);<EOL>            });<EOL>            afterEach( function () {<EOL>                this.fixture.destroy();<EOL>            });<EOL>            it(\"<STR_LIT>\", function () {<EOL>                expect(this.testElement.textContent.trim()).toBe(\"<STR_LIT>\");<EOL>            });<EOL>            it(\"<STR_LIT>\", function () {<EOL>                this.expand.expanded = true;<EOL>                this. fixture.detectChanges();<EOL>                expect(this.testElement.textContent.trim()).toBe(\"<STR_LIT>\");<EOL>            });<EOL>            it(\"<STR_LIT>\", function () {<EOL>                this.expand.expanded = true;<EOL>                this.fixture.detectChanges();<EOL>                this.expand.expanded = false;<EOL>                this. fixture.detectChanges();<EOL>                expect(this.testElement.textContent.trim()).toBe(\"<STR_LIT>\");<EOL>            });<EOL>            it(\"<STR_LIT>\", function () {<EOL>                expect(this.testComponent.counter.total).toBe(<NUM_LIT>);<EOL>            });<EOL>            it(\"<STR_LIT>\", function () {<EOL>                this.expand.expanded = true;<EOL>                this.","gt":"fixture.detectChanges();"}
{"input":"<s> export default function () {<EOL>    describe(\"<STR_LIT>\", function () {<EOL>        describe(\"<STR_LIT>\", function () {<EOL>            beforeEach( function () {<EOL>                <EOL>                TestBed.configureTestingModule({ declarations: [IfExpanded, SimpleTest, TestCounter], providers: [Expand] });<EOL>                this.fixture = TestBed. createComponent(SimpleTest);<EOL>                this.fixture.detectChanges();<EOL>                this. testComponent = this.fixture.componentInstance;<EOL>                this.testElement = this.fixture.nativeElement;<EOL>                this.clarityDirective = this.fixture.componentInstance.ifExpanded;<EOL>                this.expand = TestBed.get(Expand);<EOL>            });<EOL>            afterEach( function () {<EOL>                this.fixture.destroy();<EOL>            });<EOL>            it(\"<STR_LIT>\", function () {<EOL>                expect(this.testElement.textContent.trim()).toBe(\"<STR_LIT>\");<EOL>            });<EOL>            it(\"<STR_LIT>\", function () {<EOL>                this.expand.expanded = true;<EOL>                this. fixture.detectChanges();<EOL>                expect(this.testElement.textContent.trim()).toBe(\"<STR_LIT>\");<EOL>            });<EOL>            it(\"<STR_LIT>\", function () {<EOL>                this.expand.expanded = true;<EOL>                this.fixture.detectChanges();<EOL>                this.expand.expanded = false;<EOL>                this. fixture.detectChanges();<EOL>                expect(this.testElement.textContent.trim()).toBe(\"<STR_LIT>\");<EOL>            });<EOL>            it(\"<STR_LIT>\", function () {<EOL>                expect(this.testComponent.counter.total).toBe(<NUM_LIT>);<EOL>            });<EOL>            it(\"<STR_LIT>\", function () {<EOL>                this.expand.expanded = true;<EOL>                this. fixture.detectChanges();<EOL>                expect(this.testElement.textContent.trim()).toBe(\"<STR_LIT>\");<EOL>                this.expand.expanded = false;<EOL>                this.fixture.detectChanges();<EOL>                this.expand.","gt":"expanded = true;"}
{"input":"<s> export default function () {<EOL>    describe(\"<STR_LIT>\", function () {<EOL>        describe(\"<STR_LIT>\", function () {<EOL>            beforeEach( function () {<EOL>                <EOL>                TestBed.configureTestingModule({ declarations: [IfExpanded, SimpleTest, TestCounter], providers: [Expand] });<EOL>                this.fixture = TestBed. createComponent(SimpleTest);<EOL>                this.fixture.detectChanges();<EOL>                this. testComponent = this.fixture.componentInstance;<EOL>                this.testElement = this.fixture.nativeElement;<EOL>                this.clarityDirective = this.fixture.componentInstance.ifExpanded;<EOL>                this.expand = TestBed.get(Expand);<EOL>            });<EOL>            afterEach( function () {<EOL>                this.fixture.destroy();<EOL>            });<EOL>            it(\"<STR_LIT>\", function () {<EOL>                expect(this.testElement.textContent.trim()).toBe(\"<STR_LIT>\");<EOL>            });<EOL>            it(\"<STR_LIT>\", function () {<EOL>                this.expand.expanded = true;<EOL>                this. fixture.detectChanges();<EOL>                expect(this.testElement.textContent.trim()).toBe(\"<STR_LIT>\");<EOL>            });<EOL>            it(\"<STR_LIT>\", function () {<EOL>                this.expand.expanded = true;<EOL>                this.fixture.detectChanges();<EOL>                this.expand.expanded = false;<EOL>                this. fixture.detectChanges();<EOL>                expect(this.testElement.textContent.trim()).toBe(\"<STR_LIT>\");<EOL>            });<EOL>            it(\"<STR_LIT>\", function () {<EOL>                expect(this.testComponent.counter.total).toBe(<NUM_LIT>);<EOL>            });<EOL>            it(\"<STR_LIT>\", function () {<EOL>                this.expand.expanded = true;<EOL>                this. fixture.detectChanges();<EOL>                expect(this.testElement.textContent.trim()).toBe(\"<STR_LIT>\");<EOL>                this.expand.expanded = false;<EOL>                this.fixture.detectChanges();<EOL>                this.expand. expanded = true;<EOL>                this.fixture.detectChanges();<EOL>","gt":"expect(this.testElement.textContent.trim()).toBe(\"<STR_LIT>\");"}
{"input":"<s> export default function () {<EOL>    describe(\"<STR_LIT>\", function () {<EOL>        describe(\"<STR_LIT>\", function () {<EOL>            beforeEach( function () {<EOL>                <EOL>                TestBed.configureTestingModule({ declarations: [IfExpanded, SimpleTest, TestCounter], providers: [Expand] });<EOL>                this.fixture = TestBed. createComponent(SimpleTest);<EOL>                this.fixture.detectChanges();<EOL>                this. testComponent = this.fixture.componentInstance;<EOL>                this.testElement = this.fixture.nativeElement;<EOL>                this.clarityDirective = this.fixture.componentInstance.ifExpanded;<EOL>                this.expand = TestBed.get(Expand);<EOL>            });<EOL>            afterEach( function () {<EOL>                this.fixture.destroy();<EOL>            });<EOL>            it(\"<STR_LIT>\", function () {<EOL>                expect(this.testElement.textContent.trim()).toBe(\"<STR_LIT>\");<EOL>            });<EOL>            it(\"<STR_LIT>\", function () {<EOL>                this.expand.expanded = true;<EOL>                this. fixture.detectChanges();<EOL>                expect(this.testElement.textContent.trim()).toBe(\"<STR_LIT>\");<EOL>            });<EOL>            it(\"<STR_LIT>\", function () {<EOL>                this.expand.expanded = true;<EOL>                this.fixture.detectChanges();<EOL>                this.expand.expanded = false;<EOL>                this. fixture.detectChanges();<EOL>                expect(this.testElement.textContent.trim()).toBe(\"<STR_LIT>\");<EOL>            });<EOL>            it(\"<STR_LIT>\", function () {<EOL>                expect(this.testComponent.counter.total).toBe(<NUM_LIT>);<EOL>            });<EOL>            it(\"<STR_LIT>\", function () {<EOL>                this.expand.expanded = true;<EOL>                this. fixture.detectChanges();<EOL>                expect(this.testElement.textContent.trim()).toBe(\"<STR_LIT>\");<EOL>                this.expand.expanded = false;<EOL>                this.fixture.detectChanges();<EOL>                this.expand. expanded = true;<EOL>                this.fixture.detectChanges();<EOL>                 expect(this.testElement.textContent.trim()).toBe(\"<STR_LIT>\");<EOL>            });<EOL>        });<EOL>        describe(\"<STR_LIT>\", function () {<EOL>            beforeEach(function () {<EOL>                <EOL>                TestBed.configureTestingModule({ declarations: [IfExpanded, NgIfTest], providers: [Expand] });<EOL>                this.fixture = TestBed.","gt":"createComponent(NgIfTest);"}
{"input":"<s> export default function () {<EOL>    describe(\"<STR_LIT>\", function () {<EOL>        describe(\"<STR_LIT>\", function () {<EOL>            beforeEach( function () {<EOL>                <EOL>                TestBed.configureTestingModule({ declarations: [IfExpanded, SimpleTest, TestCounter], providers: [Expand] });<EOL>                this.fixture = TestBed. createComponent(SimpleTest);<EOL>                this.fixture.detectChanges();<EOL>                this. testComponent = this.fixture.componentInstance;<EOL>                this.testElement = this.fixture.nativeElement;<EOL>                this.clarityDirective = this.fixture.componentInstance.ifExpanded;<EOL>                this.expand = TestBed.get(Expand);<EOL>            });<EOL>            afterEach( function () {<EOL>                this.fixture.destroy();<EOL>            });<EOL>            it(\"<STR_LIT>\", function () {<EOL>                expect(this.testElement.textContent.trim()).toBe(\"<STR_LIT>\");<EOL>            });<EOL>            it(\"<STR_LIT>\", function () {<EOL>                this.expand.expanded = true;<EOL>                this. fixture.detectChanges();<EOL>                expect(this.testElement.textContent.trim()).toBe(\"<STR_LIT>\");<EOL>            });<EOL>            it(\"<STR_LIT>\", function () {<EOL>                this.expand.expanded = true;<EOL>                this.fixture.detectChanges();<EOL>                this.expand.expanded = false;<EOL>                this. fixture.detectChanges();<EOL>                expect(this.testElement.textContent.trim()).toBe(\"<STR_LIT>\");<EOL>            });<EOL>            it(\"<STR_LIT>\", function () {<EOL>                expect(this.testComponent.counter.total).toBe(<NUM_LIT>);<EOL>            });<EOL>            it(\"<STR_LIT>\", function () {<EOL>                this.expand.expanded = true;<EOL>                this. fixture.detectChanges();<EOL>                expect(this.testElement.textContent.trim()).toBe(\"<STR_LIT>\");<EOL>                this.expand.expanded = false;<EOL>                this.fixture.detectChanges();<EOL>                this.expand. expanded = true;<EOL>                this.fixture.detectChanges();<EOL>                 expect(this.testElement.textContent.trim()).toBe(\"<STR_LIT>\");<EOL>            });<EOL>        });<EOL>        describe(\"<STR_LIT>\", function () {<EOL>            beforeEach(function () {<EOL>                <EOL>                TestBed.configureTestingModule({ declarations: [IfExpanded, NgIfTest], providers: [Expand] });<EOL>                this.fixture = TestBed. createComponent(NgIfTest);<EOL>                this.fixture.detectChanges();<EOL>                this.testComponent = this.fixture.componentInstance;<EOL>                this.expand = TestBed.get(Expand);<EOL>            });<EOL>            afterEach(function () {<EOL>                this.fixture.","gt":"destroy();"}
{"input":"<s> export default function () {<EOL>    describe(\"<STR_LIT>\", function () {<EOL>        describe(\"<STR_LIT>\", function () {<EOL>            beforeEach( function () {<EOL>                <EOL>                TestBed.configureTestingModule({ declarations: [IfExpanded, SimpleTest, TestCounter], providers: [Expand] });<EOL>                this.fixture = TestBed. createComponent(SimpleTest);<EOL>                this.fixture.detectChanges();<EOL>                this. testComponent = this.fixture.componentInstance;<EOL>                this.testElement = this.fixture.nativeElement;<EOL>                this.clarityDirective = this.fixture.componentInstance.ifExpanded;<EOL>                this.expand = TestBed.get(Expand);<EOL>            });<EOL>            afterEach( function () {<EOL>                this.fixture.destroy();<EOL>            });<EOL>            it(\"<STR_LIT>\", function () {<EOL>                expect(this.testElement.textContent.trim()).toBe(\"<STR_LIT>\");<EOL>            });<EOL>            it(\"<STR_LIT>\", function () {<EOL>                this.expand.expanded = true;<EOL>                this. fixture.detectChanges();<EOL>                expect(this.testElement.textContent.trim()).toBe(\"<STR_LIT>\");<EOL>            });<EOL>            it(\"<STR_LIT>\", function () {<EOL>                this.expand.expanded = true;<EOL>                this.fixture.detectChanges();<EOL>                this.expand.expanded = false;<EOL>                this. fixture.detectChanges();<EOL>                expect(this.testElement.textContent.trim()).toBe(\"<STR_LIT>\");<EOL>            });<EOL>            it(\"<STR_LIT>\", function () {<EOL>                expect(this.testComponent.counter.total).toBe(<NUM_LIT>);<EOL>            });<EOL>            it(\"<STR_LIT>\", function () {<EOL>                this.expand.expanded = true;<EOL>                this. fixture.detectChanges();<EOL>                expect(this.testElement.textContent.trim()).toBe(\"<STR_LIT>\");<EOL>                this.expand.expanded = false;<EOL>                this.fixture.detectChanges();<EOL>                this.expand. expanded = true;<EOL>                this.fixture.detectChanges();<EOL>                 expect(this.testElement.textContent.trim()).toBe(\"<STR_LIT>\");<EOL>            });<EOL>        });<EOL>        describe(\"<STR_LIT>\", function () {<EOL>            beforeEach(function () {<EOL>                <EOL>                TestBed.configureTestingModule({ declarations: [IfExpanded, NgIfTest], providers: [Expand] });<EOL>                this.fixture = TestBed. createComponent(NgIfTest);<EOL>                this.fixture.detectChanges();<EOL>                this.testComponent = this.fixture.componentInstance;<EOL>                this.expand = TestBed.get(Expand);<EOL>            });<EOL>            afterEach(function () {<EOL>                this.fixture. destroy();<EOL>            });<EOL>            it(","gt":"\"<STR_LIT>\", function () {"}
{"input":"<s> export default function () {<EOL>    describe(\"<STR_LIT>\", function () {<EOL>        describe(\"<STR_LIT>\", function () {<EOL>            beforeEach( function () {<EOL>                <EOL>                TestBed.configureTestingModule({ declarations: [IfExpanded, SimpleTest, TestCounter], providers: [Expand] });<EOL>                this.fixture = TestBed. createComponent(SimpleTest);<EOL>                this.fixture.detectChanges();<EOL>                this. testComponent = this.fixture.componentInstance;<EOL>                this.testElement = this.fixture.nativeElement;<EOL>                this.clarityDirective = this.fixture.componentInstance.ifExpanded;<EOL>                this.expand = TestBed.get(Expand);<EOL>            });<EOL>            afterEach( function () {<EOL>                this.fixture.destroy();<EOL>            });<EOL>            it(\"<STR_LIT>\", function () {<EOL>                expect(this.testElement.textContent.trim()).toBe(\"<STR_LIT>\");<EOL>            });<EOL>            it(\"<STR_LIT>\", function () {<EOL>                this.expand.expanded = true;<EOL>                this. fixture.detectChanges();<EOL>                expect(this.testElement.textContent.trim()).toBe(\"<STR_LIT>\");<EOL>            });<EOL>            it(\"<STR_LIT>\", function () {<EOL>                this.expand.expanded = true;<EOL>                this.fixture.detectChanges();<EOL>                this.expand.expanded = false;<EOL>                this. fixture.detectChanges();<EOL>                expect(this.testElement.textContent.trim()).toBe(\"<STR_LIT>\");<EOL>            });<EOL>            it(\"<STR_LIT>\", function () {<EOL>                expect(this.testComponent.counter.total).toBe(<NUM_LIT>);<EOL>            });<EOL>            it(\"<STR_LIT>\", function () {<EOL>                this.expand.expanded = true;<EOL>                this. fixture.detectChanges();<EOL>                expect(this.testElement.textContent.trim()).toBe(\"<STR_LIT>\");<EOL>                this.expand.expanded = false;<EOL>                this.fixture.detectChanges();<EOL>                this.expand. expanded = true;<EOL>                this.fixture.detectChanges();<EOL>                 expect(this.testElement.textContent.trim()).toBe(\"<STR_LIT>\");<EOL>            });<EOL>        });<EOL>        describe(\"<STR_LIT>\", function () {<EOL>            beforeEach(function () {<EOL>                <EOL>                TestBed.configureTestingModule({ declarations: [IfExpanded, NgIfTest], providers: [Expand] });<EOL>                this.fixture = TestBed. createComponent(NgIfTest);<EOL>                this.fixture.detectChanges();<EOL>                this.testComponent = this.fixture.componentInstance;<EOL>                this.expand = TestBed.get(Expand);<EOL>            });<EOL>            afterEach(function () {<EOL>                this.fixture. destroy();<EOL>            });<EOL>            it( \"<STR_LIT>\", function () {<EOL>                expect(","gt":"this.expand.expandable).toBeGreaterThan(<NUM_LIT>);"}
{"input":"<s> export function ratioTopReady(container, ignore = <NUM_LIT>) {<EOL>","gt":"return (container.scrollTop - ignore) / container.clientHeight;"}
{"input":"<s> function toggleHideExplorerArrowsPresetCommand() {<EOL>    togglePreset(models.PresetNames.","gt":"hideExplorerArrows, '<STR_LIT>', true);"}
{"input":"<s> export function fileFormatToString(extension) {<EOL>    return","gt":"'<STR_LIT>' ? extension.trim() : FileFormat[extension]}`<STR_LIT>;"}
{"input":"<s> <EOL>export function parseJSON(text) {<EOL>    try {<EOL>        return","gt":"JSON.parse(text);"}
{"input":"<s> async function handleActiveEditorChange() {<EOL>    if (configuration.disableExt) {<EOL>        return;<EOL>    }<EOL>    <EOL>    if (Globals.isTesting) {<EOL>        return;<EOL>    }<EOL>    taskQueue.enqueueTask(async () => {<EOL>        if (vscode.window.activeTextEditor !== undefined) {<EOL>            const","gt":"mh = await getAndUpdateModeHandler();"}
{"input":"<s> function handleContentChangedFromDisk(document) {<EOL>    _.filter(ModeHandlerMap.getAll(), (modeHandler) => modeHandler.","gt":"vimState.identity.fileName === document.fileName).forEach((modeHandler) => {"}
{"input":"<s> function searchCurrentWord(position, vimState, direction, isExact) {<EOL>    const currentWord = TextEditor.getWord(position);<EOL>    <EOL>    <EOL>    <EOL>    const searchStartCursorPosition =","gt":"direction === SearchDirection.Backward"}
{"input":"<s> function searchCurrentWord(position, vimState, direction, isExact) {<EOL>    const currentWord = TextEditor.getWord(position);<EOL>    <EOL>    <EOL>    <EOL>    const searchStartCursorPosition =  direction === SearchDirection.Backward<EOL>        ? vimState.cursorPosition.getWordLeft(true)<EOL>        : vimState.cursorPosition;<EOL>    return createSearchStateAndMoveToMatch({<EOL>        needle: currentWord,<EOL>        vimState,<EOL>","gt":"direction,"}
{"input":"<s> export function isIMovement(o) {<EOL>    return o","gt":".start !== undefined && o.stop !== undefined;"}
{"input":"<s> export function parseWriteQuitAllCommandArgs(args) {<EOL>    if (!args) {<EOL>        return new node.WriteQuitAllCommand({});<EOL>    }<EOL>    var scannedArgs = {};<EOL>    var scanner = new Scanner(args);<EOL>    const","gt":"c = scanner.next();"}
{"input":"<s> export function parseWriteQuitAllCommandArgs(args) {<EOL>    if (!args) {<EOL>        return new node.WriteQuitAllCommand({});<EOL>    }<EOL>    var scannedArgs = {};<EOL>    var scanner = new Scanner(args);<EOL>    const  c = scanner.next();<EOL>    if (c === '<STR_LIT>') {<EOL>        scannedArgs.bang = true;<EOL>        scanner.ignore();<EOL>    }<EOL>    else if (c !== '<STR_LIT>') {<EOL>        throw VimError.fromCode(ErrorCode.E488);<EOL>    }<EOL>","gt":"scanner.skipWhiteSpace();"}
{"input":"<s> <EOL>export function flattenAndFilterAst(node, scope = []) {<EOL>    if (!node.__type) {<EOL>        return [];<EOL>    }<EOL>    node['<STR_LIT>'] = scope;<EOL>    let nested = [","gt":"node];"}
{"input":"<s> <EOL>export function flattenAndFilterAst(node, scope = []) {<EOL>    if (!node.__type) {<EOL>        return [];<EOL>    }<EOL>    node['<STR_LIT>'] = scope;<EOL>    let nested = [ node];<EOL>    if (node.nodes) {<EOL>        let i = <NUM_LIT>;<EOL>        for (const child of node.nodes) {<EOL>            const newScope = scope.concat(","gt":"i++);"}
{"input":"<s> <EOL>export function flattenAndFilterAst(node, scope = []) {<EOL>    if (!node.__type) {<EOL>        return [];<EOL>    }<EOL>    node['<STR_LIT>'] = scope;<EOL>    let nested = [ node];<EOL>    if (node.nodes) {<EOL>        let i = <NUM_LIT>;<EOL>        for (const child of node.nodes) {<EOL>            const newScope = scope.concat( i++);<EOL>            nested = nested.concat(flattenAndFilterAst(child, newScope));<EOL>        }<EOL>    }<EOL>    if (","gt":"node.block) {"}
{"input":"<s> <EOL>function processRawSymbols(rawSymbols, text) {<EOL>    return _.compact(rawSymbols.map((symNode) => {<EOL>        if (isVariableNode(symNode)) {<EOL>            return _variableSymbol(symNode, text);<EOL>        }<EOL>        if (isFunctionNode(symNode)) {<EOL>            return","gt":"_functionSymbol(symNode, text);"}
{"input":"<s> function isBeforeOrEqual(pos1, pos2) {<EOL>    return","gt":"pos1.line < pos2.line || (pos1.line === pos2.line && pos1.character <= pos2.character);"}
{"input":"<s> export function doValidation(document, engine) {<EOL>    const rawText = document.getText();<EOL>    <EOL>    if (rawText.replace(/\\s/g, '<STR_LIT>') ===","gt":"'<STR_LIT>') {"}
{"input":"<s> export function getEnabledTagProviders(tagProviderSetting) {<EOL>    return allTagProviders.","gt":"filter((p) => tagProviderSetting[p.getId()] !== false);"}
{"input":"<s> export function hoverDSL(setup) {<EOL>    return function test([value]) {<EOL>        const offset = value.indexOf('<STR_LIT>');<EOL>        value = value.substr(<NUM_LIT>, offset) + value.","gt":"substr(offset + <NUM_LIT>);"}
{"input":"<s> <EOL><EOL><EOL><EOL>export function createDataLoader(obj, method, key) {<EOL>    let repository;<EOL>    try {<EOL>        repository = getCustomRepository(obj);<EOL>    }<EOL>","gt":"catch (errorRepo) {"}
{"input":"<s> <EOL><EOL><EOL><EOL>export function createDataLoader(obj, method, key) {<EOL>    let repository;<EOL>    try {<EOL>        repository = getCustomRepository(obj);<EOL>    }<EOL>     catch (errorRepo) {<EOL>        try {<EOL>            repository =","gt":"getRepository(obj);"}
{"input":"<s> <EOL>export function removeSuffix(value, suffix) {<EOL>    return value.slice(<NUM_LIT>, value.length - suffix.","gt":"length);"}
{"input":"<s> export function isEmptyObject(obj) {<EOL>    return obj &&","gt":"Object.keys(obj).length === <NUM_LIT> && obj.constructor === Object;"}
{"input":"<s> function invokeDeserializeHook(instance, json, type) {<EOL>","gt":"if (type && typeof (type).OnDeserialized === \"<STR_LIT>\") {"}
{"input":"<s> function toEnd(node) {<EOL>    if (node && node.tokenType !== undefined) {<EOL>        return node.endOffset +","gt":"<NUM_LIT>;"}
{"input":"<s> function isNumber(thing) {<EOL>    return typeof","gt":"thing === \"<STR_LIT>\";"}
{"input":"<s> export function printPrefix(prefix) {<EOL>    return prefix.","gt":"map((v) => GlobalInterner.reverse(v));"}
{"input":"<s> export function processUrlDependencies(meta, rootContext, filter = defaultFilter) {<EOL>    const importerDir = dirname(meta.source);<EOL>    const urls = [];<EOL>    const onUrl = (node) => {<EOL>        const { url } =","gt":"node;"}
{"input":"<s> export function processUrlDependencies(meta, rootContext, filter = defaultFilter) {<EOL>    const importerDir = dirname(meta.source);<EOL>    const urls = [];<EOL>    const onUrl = (node) => {<EOL>        const { url } =  node;<EOL>        if (url && isAsset(url) && filter(url, importerDir)) {<EOL>            node.stringType = '<STR_LIT>';<EOL>","gt":"delete node.innerSpacingBefore;"}
{"input":"<s> export function processUrlDependencies(meta, rootContext, filter = defaultFilter) {<EOL>    const importerDir = dirname(meta.source);<EOL>    const urls = [];<EOL>    const onUrl = (node) => {<EOL>        const { url } =  node;<EOL>        if (url && isAsset(url) && filter(url, importerDir)) {<EOL>            node.stringType = '<STR_LIT>';<EOL>             delete node.innerSpacingBefore;<EOL>            delete node.innerSpacingAfter;<EOL>            node.url = `<STR_LIT>`;<EOL>            urls.push(makeAbsolute(url, rootContext, importerDir));<EOL>        }<EOL>    };<EOL>    meta.outputAst.walkDecls((node) => {<EOL>        processDeclarationFunctions(node, (functionNode) => {<EOL>            if (functionNode.type === '<STR_LIT>') {<EOL>                onUrl(","gt":"functionNode);"}
{"input":"<s> function keyframesSymbolMapper([name, as]) {<EOL>    return","gt":"name === as ? `<STR_LIT>` : `<STR_LIT>`;"}
{"input":"<s> function getModuleFormats({ esm, cjs }) {<EOL>    const formats = [];<EOL>    if (esm) {<EOL>        formats.push(","gt":"'<STR_LIT>');"}
{"input":"<s> export function createDefaultOptions() {<EOL>    return {<EOL>        outDir: '<STR_LIT>',<EOL>        srcDir: '<STR_LIT>',<EOL>        cjs: true,<EOL>        esm: false,<EOL>        dts:","gt":"false,"}
{"input":"<s> export function createDefaultOptions() {<EOL>    return {<EOL>        outDir: '<STR_LIT>',<EOL>        srcDir: '<STR_LIT>',<EOL>        cjs: true,<EOL>        esm: false,<EOL>        dts:  false,<EOL>        injectCSSRequest: false,<EOL>        optimize: false,<EOL>        minify: false,<EOL>","gt":"useNamespaceReference: false,"}
{"input":"<s> export function createDefaultOptions() {<EOL>    return {<EOL>        outDir: '<STR_LIT>',<EOL>        srcDir: '<STR_LIT>',<EOL>        cjs: true,<EOL>        esm: false,<EOL>        dts:  false,<EOL>        injectCSSRequest: false,<EOL>        optimize: false,<EOL>        minify: false,<EOL>         useNamespaceReference: false,<EOL>        diagnostics: true,<EOL>        outputCSS: false,<EOL>","gt":"includeCSSInJS: false,"}
{"input":"<s> function createSTCBuilderError(message) {<EOL>    return new Error(","gt":"message}`<STR_LIT>;"}
{"input":"<s> export function unbox(boxed, unboxPrimitives = true, customValues, node) {<EOL>    if (typeof boxed === '<STR_LIT>') {<EOL>        return unboxPrimitives ? boxed : boxString(boxed);<EOL>    }<EOL>    else","gt":"if (typeof boxed === '<STR_LIT>' && boxed) {"}
{"input":"<s> export function matchSelectorTarget(sourceSelector, targetSelector) {<EOL>    const a = separateChunks(parseSelector(sourceSelector));<EOL>    const b = separateChunks(parseSelector(targetSelector));<EOL>    if (a.length > <NUM_LIT>) {<EOL>        throw new","gt":"Error('<STR_LIT>');"}
{"input":"<s> export function matchSelectorTarget(sourceSelector, targetSelector) {<EOL>    const a = separateChunks(parseSelector(sourceSelector));<EOL>    const b = separateChunks(parseSelector(targetSelector));<EOL>    if (a.length > <NUM_LIT>) {<EOL>        throw new  Error('<STR_LIT>');<EOL>    }<EOL>    const lastChunkA = getLastChunk(a[<NUM_LIT>]);<EOL>    const relevantChunksA = groupClassesAndPseudoElements(filterChunkNodesByType(lastChunkA, ['<STR_LIT>', '<STR_LIT>', '<STR_LIT>']));<EOL>    return b.some((compoundSelector) => {<EOL>        const lastChunkB = getLastChunk(compoundSelector);<EOL>        let relevantChunksB = groupClassesAndPseudoElements(","gt":"filterChunkNodesByType(lastChunkB, ['<STR_LIT>', '<STR_LIT>', '<STR_LIT>']));"}
{"input":"<s> function createUniqID(source, varName) {<EOL>    return","gt":"source}: ${varName}`<STR_LIT>;"}
{"input":"<s> function isImportAs(space, as) {<EOL>    return space?.type === '<STR_LIT>' && as?.type === '<STR_LIT>' && as?.value ===","gt":"'<STR_LIT>';"}
{"input":"<s> <EOL>export function scopeNestedSelector(scopeSelectorAst, nestedSelectorAst, rootScopeLevel = false) {<EOL>    const resultSelectors = [];<EOL>","gt":"nestedSelectorAst.forEach((targetAst) => {"}
{"input":"<s> <EOL>export function scopeNestedSelector(scopeSelectorAst, nestedSelectorAst, rootScopeLevel = false) {<EOL>    const resultSelectors = [];<EOL>     nestedSelectorAst.forEach((targetAst) => {<EOL>        scopeSelectorAst.forEach((scopeAst) => {<EOL>            const outputAst = cloneDeep(targetAst);<EOL>            outputAst.before = scopeAst.before || outputAst.","gt":"before;"}
{"input":"<s> <EOL>export function scopeNestedSelector(scopeSelectorAst, nestedSelectorAst, rootScopeLevel = false) {<EOL>    const resultSelectors = [];<EOL>     nestedSelectorAst.forEach((targetAst) => {<EOL>        scopeSelectorAst.forEach((scopeAst) => {<EOL>            const outputAst = cloneDeep(targetAst);<EOL>            outputAst.before = scopeAst.before || outputAst. before;<EOL>            let first = outputAst.nodes[<NUM_LIT>];<EOL>            <EOL>            walkSelector(outputAst, (node) => {<EOL>                first = node;<EOL>                return","gt":"walkSelector.stopAll;"}
{"input":"<s> <EOL>export function scopeNestedSelector(scopeSelectorAst, nestedSelectorAst, rootScopeLevel = false) {<EOL>    const resultSelectors = [];<EOL>     nestedSelectorAst.forEach((targetAst) => {<EOL>        scopeSelectorAst.forEach((scopeAst) => {<EOL>            const outputAst = cloneDeep(targetAst);<EOL>            outputAst.before = scopeAst.before || outputAst. before;<EOL>            let first = outputAst.nodes[<NUM_LIT>];<EOL>            <EOL>            walkSelector(outputAst, (node) => {<EOL>                first = node;<EOL>                return  walkSelector.stopAll;<EOL>            }, { ignoreList: [`<STR_LIT>`] });<EOL>            const parentRef = first.type === `<STR_LIT>`;<EOL>            const globalSelector = first.type === `<STR_LIT>` && first.value === `<STR_LIT>`;<EOL>            const startWithScoping = rootScopeLevel<EOL>                ? scopeAst.nodes.every((node, i) => {<EOL>                    return matchTypeAndValue(","gt":"node, outputAst.nodes[i]);"}
{"input":"<s> <EOL>export function scopeNestedSelector(scopeSelectorAst, nestedSelectorAst, rootScopeLevel = false) {<EOL>    const resultSelectors = [];<EOL>     nestedSelectorAst.forEach((targetAst) => {<EOL>        scopeSelectorAst.forEach((scopeAst) => {<EOL>            const outputAst = cloneDeep(targetAst);<EOL>            outputAst.before = scopeAst.before || outputAst. before;<EOL>            let first = outputAst.nodes[<NUM_LIT>];<EOL>            <EOL>            walkSelector(outputAst, (node) => {<EOL>                first = node;<EOL>                return  walkSelector.stopAll;<EOL>            }, { ignoreList: [`<STR_LIT>`] });<EOL>            const parentRef = first.type === `<STR_LIT>`;<EOL>            const globalSelector = first.type === `<STR_LIT>` && first.value === `<STR_LIT>`;<EOL>            const startWithScoping = rootScopeLevel<EOL>                ? scopeAst.nodes.every((node, i) => {<EOL>                    return matchTypeAndValue( node, outputAst.nodes[i]);<EOL>                })<EOL>                : false;<EOL>            let nestedMixRoot = false;<EOL>            walkSelector(outputAst, (node, i, nodes) => {<EOL>                if (node.type ===","gt":"'<STR_LIT>') {"}
{"input":"<s> <EOL>export function scopeNestedSelector(scopeSelectorAst, nestedSelectorAst, rootScopeLevel = false) {<EOL>    const resultSelectors = [];<EOL>     nestedSelectorAst.forEach((targetAst) => {<EOL>        scopeSelectorAst.forEach((scopeAst) => {<EOL>            const outputAst = cloneDeep(targetAst);<EOL>            outputAst.before = scopeAst.before || outputAst. before;<EOL>            let first = outputAst.nodes[<NUM_LIT>];<EOL>            <EOL>            walkSelector(outputAst, (node) => {<EOL>                first = node;<EOL>                return  walkSelector.stopAll;<EOL>            }, { ignoreList: [`<STR_LIT>`] });<EOL>            const parentRef = first.type === `<STR_LIT>`;<EOL>            const globalSelector = first.type === `<STR_LIT>` && first.value === `<STR_LIT>`;<EOL>            const startWithScoping = rootScopeLevel<EOL>                ? scopeAst.nodes.every((node, i) => {<EOL>                    return matchTypeAndValue( node, outputAst.nodes[i]);<EOL>                })<EOL>                : false;<EOL>            let nestedMixRoot = false;<EOL>            walkSelector(outputAst, (node, i, nodes) => {<EOL>                if (node.type ===  '<STR_LIT>') {<EOL>                    nestedMixRoot = true;<EOL>                    nodes.splice(i, <NUM_LIT>, {<EOL>                        type: `<STR_LIT>`,<EOL>                        nodes: cloneDeep(scopeAst.nodes),<EOL>                        start: node.start,<EOL>                        end: node.end,<EOL>","gt":"after: `<STR_LIT>`,"}
{"input":"<s> <EOL>export function scopeNestedSelector(scopeSelectorAst, nestedSelectorAst, rootScopeLevel = false) {<EOL>    const resultSelectors = [];<EOL>     nestedSelectorAst.forEach((targetAst) => {<EOL>        scopeSelectorAst.forEach((scopeAst) => {<EOL>            const outputAst = cloneDeep(targetAst);<EOL>            outputAst.before = scopeAst.before || outputAst. before;<EOL>            let first = outputAst.nodes[<NUM_LIT>];<EOL>            <EOL>            walkSelector(outputAst, (node) => {<EOL>                first = node;<EOL>                return  walkSelector.stopAll;<EOL>            }, { ignoreList: [`<STR_LIT>`] });<EOL>            const parentRef = first.type === `<STR_LIT>`;<EOL>            const globalSelector = first.type === `<STR_LIT>` && first.value === `<STR_LIT>`;<EOL>            const startWithScoping = rootScopeLevel<EOL>                ? scopeAst.nodes.every((node, i) => {<EOL>                    return matchTypeAndValue( node, outputAst.nodes[i]);<EOL>                })<EOL>                : false;<EOL>            let nestedMixRoot = false;<EOL>            walkSelector(outputAst, (node, i, nodes) => {<EOL>                if (node.type ===  '<STR_LIT>') {<EOL>                    nestedMixRoot = true;<EOL>                    nodes.splice(i, <NUM_LIT>, {<EOL>                        type: `<STR_LIT>`,<EOL>                        nodes: cloneDeep(scopeAst.nodes),<EOL>                        start: node.start,<EOL>                        end: node.end,<EOL>                         after: `<STR_LIT>`,<EOL>                        before: `<STR_LIT>`,<EOL>                    });<EOL>                }<EOL>            });<EOL>            if (first && !parentRef && !startWithScoping && !globalSelector && !nestedMixRoot) {<EOL>                outputAst.nodes.unshift(...cloneDeep(scopeAst.nodes), {<EOL>                    type: `<STR_LIT>`,<EOL>                    combinator: `<STR_LIT>`,<EOL>                    value: `<STR_LIT>`,<EOL>                    before: `<STR_LIT>`,<EOL>                    after: `<STR_LIT>`,<EOL>                    start: first.start,<EOL>                    end: first.start,<EOL>                    invalid: false,<EOL>                });<EOL>            }<EOL>            resultSelectors.","gt":"push(outputAst);"}
{"input":"<s> export function listOptions(node) {<EOL>    return groupValues(node.nodes)<EOL>        .map((nodes) => postcssValueParser.stringify(nodes, (n) => {<EOL>        if (n.type === '<STR_LIT>') {<EOL>","gt":"return null;"}
{"input":"<s> export function listOptions(node) {<EOL>    return groupValues(node.nodes)<EOL>        .map((nodes) => postcssValueParser.stringify(nodes, (n) => {<EOL>        if (n.type === '<STR_LIT>') {<EOL>             return null;<EOL>        }<EOL>        else if (n.type === '<STR_LIT>') {<EOL>            return n.value;<EOL>        }<EOL>        else {<EOL>            return","gt":"undefined;"}
{"input":"<s> export function createStateWithParamClassName(stateName, namespace, param) {<EOL>    const escapedNamespace = cssesc(","gt":"namespace, { isIdentifier: true });"}
{"input":"<s> function resolveParam(meta, resolver, diagnostics, rule, nodeContent) {<EOL>    const defaultStringValue =","gt":"'<STR_LIT>';"}
{"input":"<s> function resolveStateValue(meta, resolver, diagnostics, rule, node, stateDef, name, namespace) {<EOL>    const inputValue = node.nodes && node.nodes.length ? stringifySelector(node.nodes) : `<STR_LIT>`;<EOL>    let actualParam = resolveParam(meta, resolver, diagnostics, rule, inputValue ? inputValue : stateDef.defaultValue);<EOL>    if (rule && !inputValue && !stateDef.defaultValue) {<EOL>        diagnostics.warn(rule, stateErrors.NO_STATE_ARGUMENT_GIVEN(name, stateDef.type), {<EOL>            word:","gt":"name,"}
{"input":"<s> function resolveStateValue(meta, resolver, diagnostics, rule, node, stateDef, name, namespace) {<EOL>    const inputValue = node.nodes && node.nodes.length ? stringifySelector(node.nodes) : `<STR_LIT>`;<EOL>    let actualParam = resolveParam(meta, resolver, diagnostics, rule, inputValue ? inputValue : stateDef.defaultValue);<EOL>    if (rule && !inputValue && !stateDef.defaultValue) {<EOL>        diagnostics.warn(rule, stateErrors.NO_STATE_ARGUMENT_GIVEN(name, stateDef.type), {<EOL>            word:  name,<EOL>        });<EOL>    }<EOL>","gt":"const validator = systemValidators[stateDef.type];"}
{"input":"<s> function resolveStateValue(meta, resolver, diagnostics, rule, node, stateDef, name, namespace) {<EOL>    const inputValue = node.nodes && node.nodes.length ? stringifySelector(node.nodes) : `<STR_LIT>`;<EOL>    let actualParam = resolveParam(meta, resolver, diagnostics, rule, inputValue ? inputValue : stateDef.defaultValue);<EOL>    if (rule && !inputValue && !stateDef.defaultValue) {<EOL>        diagnostics.warn(rule, stateErrors.NO_STATE_ARGUMENT_GIVEN(name, stateDef.type), {<EOL>            word:  name,<EOL>        });<EOL>    }<EOL>     const validator = systemValidators[stateDef.type];<EOL>    let stateParamOutput;<EOL>    try {<EOL>        stateParamOutput = validator.validate(actualParam, stateDef.arguments, resolveParam.","gt":"bind(null, meta, resolver, diagnostics, rule), false, true);"}
{"input":"<s> function resolveStateValue(meta, resolver, diagnostics, rule, node, stateDef, name, namespace) {<EOL>    const inputValue = node.nodes && node.nodes.length ? stringifySelector(node.nodes) : `<STR_LIT>`;<EOL>    let actualParam = resolveParam(meta, resolver, diagnostics, rule, inputValue ? inputValue : stateDef.defaultValue);<EOL>    if (rule && !inputValue && !stateDef.defaultValue) {<EOL>        diagnostics.warn(rule, stateErrors.NO_STATE_ARGUMENT_GIVEN(name, stateDef.type), {<EOL>            word:  name,<EOL>        });<EOL>    }<EOL>     const validator = systemValidators[stateDef.type];<EOL>    let stateParamOutput;<EOL>    try {<EOL>        stateParamOutput = validator.validate(actualParam, stateDef.arguments, resolveParam. bind(null, meta, resolver, diagnostics, rule), false, true);<EOL>    }<EOL>    catch (e) {<EOL>        <EOL>    }<EOL>    if (stateParamOutput !== undefined) {<EOL>        if (stateParamOutput.res !== actualParam) {<EOL>            actualParam = stateParamOutput.res;<EOL>        }<EOL>        if (rule && stateParamOutput.","gt":"errors) {"}
{"input":"<s> function test(desc, src, expected, allowComments = false, expectedWarnings) {<EOL>    it(desc, () => {<EOL>        const actualWarnings = [];<EOL>        const [firstNode] = postcssValueParser(","gt":"src).nodes;"}
{"input":"<s> export function flatMatch(chai, util) {<EOL>    const { flag } = util;<EOL>    chai.Assertion.","gt":"addMethod('<STR_LIT>', function (obj, maxDepth = <NUM_LIT>) {"}
{"input":"<s> export function matchRuleAndDeclaration(parent, selectorIndex, selector, decl, msg) {<EOL>    const rule = parent.nodes[selectorIndex];<EOL>    if (rule.selector !== selector) {<EOL>        throw new Error(","gt":"'<STR_LIT>' : '<STR_LIT>'}selector ${selectorIndex}\\nactual: ${rule.selector}\\nexpected: ${selector}`<STR_LIT>;"}
{"input":"<s> export function configLoadAssets() {<EOL>    return [<EOL>        {<EOL>            test: /\\.(png|jpg|gif)$/,<EOL>","gt":"use: ["}
{"input":"<s> function findMatchingStylableInstance(initialConfig, stylableInstances) {<EOL>    const entries = Object.entries(","gt":"initialConfig);"}
{"input":"<s> function findMatchingStylableInstance(initialConfig, stylableInstances) {<EOL>    const entries = Object.entries( initialConfig);<EOL>    for (const [instance, config] of stylableInstances) {<EOL>        if (entries.every(([key, value]) => config[key] === value)) {<EOL>            return","gt":"instance;"}
{"input":"<s> export function lspFormattingOptionsToJsBeautifyOptions(options) {<EOL>    return {<EOL>        indent_size:","gt":"options.tabSize,"}
{"input":"<s> export function fixAndProcess(src, position, filePath) {<EOL>    let cursorLineIndex = position.character;<EOL>    const lines = src.replace(/\\r\\n/g, '<STR_LIT>').split('<STR_LIT>');<EOL>    let currentLine = lines[position.","gt":"line];"}
{"input":"<s> export function fixAndProcess(src, position, filePath) {<EOL>    let cursorLineIndex = position.character;<EOL>    const lines = src.replace(/\\r\\n/g, '<STR_LIT>').split('<STR_LIT>');<EOL>    let currentLine = lines[position. line];<EOL>    let fixedSrc = src;<EOL>    if (currentLine.match(lineEndsRegexp)) {<EOL>        let currentLocation = <NUM_LIT>;<EOL>        const splitLine = currentLine.split(","gt":"lineEndsRegexp);"}
{"input":"<s> export function fixAndProcess(src, position, filePath) {<EOL>    let cursorLineIndex = position.character;<EOL>    const lines = src.replace(/\\r\\n/g, '<STR_LIT>').split('<STR_LIT>');<EOL>    let currentLine = lines[position. line];<EOL>    let fixedSrc = src;<EOL>    if (currentLine.match(lineEndsRegexp)) {<EOL>        let currentLocation = <NUM_LIT>;<EOL>        const splitLine = currentLine.split( lineEndsRegexp);<EOL>        for (let i = <NUM_LIT>; i < splitLine.length; i += <NUM_LIT>) {<EOL>            currentLocation += splitLine[i].length + <NUM_LIT>;<EOL>            if (currentLocation >= position.character) {<EOL>                currentLine = splitLine[","gt":"i];"}
{"input":"<s> export function fixAndProcess(src, position, filePath) {<EOL>    let cursorLineIndex = position.character;<EOL>    const lines = src.replace(/\\r\\n/g, '<STR_LIT>').split('<STR_LIT>');<EOL>    let currentLine = lines[position. line];<EOL>    let fixedSrc = src;<EOL>    if (currentLine.match(lineEndsRegexp)) {<EOL>        let currentLocation = <NUM_LIT>;<EOL>        const splitLine = currentLine.split( lineEndsRegexp);<EOL>        for (let i = <NUM_LIT>; i < splitLine.length; i += <NUM_LIT>) {<EOL>            currentLocation += splitLine[i].length + <NUM_LIT>;<EOL>            if (currentLocation >= position.character) {<EOL>                currentLine = splitLine[ i];<EOL>                if (","gt":"isIllegalLine(currentLine)) {"}
{"input":"<s> export function fixAndProcess(src, position, filePath) {<EOL>    let cursorLineIndex = position.character;<EOL>    const lines = src.replace(/\\r\\n/g, '<STR_LIT>').split('<STR_LIT>');<EOL>    let currentLine = lines[position. line];<EOL>    let fixedSrc = src;<EOL>    if (currentLine.match(lineEndsRegexp)) {<EOL>        let currentLocation = <NUM_LIT>;<EOL>        const splitLine = currentLine.split( lineEndsRegexp);<EOL>        for (let i = <NUM_LIT>; i < splitLine.length; i += <NUM_LIT>) {<EOL>            currentLocation += splitLine[i].length + <NUM_LIT>;<EOL>            if (currentLocation >= position.character) {<EOL>                currentLine = splitLine[ i];<EOL>                if ( isIllegalLine(currentLine)) {<EOL>                    splitLine[i] = '<STR_LIT>';<EOL>                    lines.splice(position.line, <NUM_LIT>, splitLine.join('<STR_LIT>'));<EOL>","gt":"fixedSrc = lines.join('<STR_LIT>');"}
{"input":"<s> export function fixAndProcess(src, position, filePath) {<EOL>    let cursorLineIndex = position.character;<EOL>    const lines = src.replace(/\\r\\n/g, '<STR_LIT>').split('<STR_LIT>');<EOL>    let currentLine = lines[position. line];<EOL>    let fixedSrc = src;<EOL>    if (currentLine.match(lineEndsRegexp)) {<EOL>        let currentLocation = <NUM_LIT>;<EOL>        const splitLine = currentLine.split( lineEndsRegexp);<EOL>        for (let i = <NUM_LIT>; i < splitLine.length; i += <NUM_LIT>) {<EOL>            currentLocation += splitLine[i].length + <NUM_LIT>;<EOL>            if (currentLocation >= position.character) {<EOL>                currentLine = splitLine[ i];<EOL>                if ( isIllegalLine(currentLine)) {<EOL>                    splitLine[i] = '<STR_LIT>';<EOL>                    lines.splice(position.line, <NUM_LIT>, splitLine.join('<STR_LIT>'));<EOL>                     fixedSrc = lines.join('<STR_LIT>');<EOL>                }<EOL>                break;<EOL>            }<EOL>            else {<EOL>                cursorLineIndex -= splitLine[i].","gt":"length + <NUM_LIT>;"}
{"input":"<s> export function fixAndProcess(src, position, filePath) {<EOL>    let cursorLineIndex = position.character;<EOL>    const lines = src.replace(/\\r\\n/g, '<STR_LIT>').split('<STR_LIT>');<EOL>    let currentLine = lines[position. line];<EOL>    let fixedSrc = src;<EOL>    if (currentLine.match(lineEndsRegexp)) {<EOL>        let currentLocation = <NUM_LIT>;<EOL>        const splitLine = currentLine.split( lineEndsRegexp);<EOL>        for (let i = <NUM_LIT>; i < splitLine.length; i += <NUM_LIT>) {<EOL>            currentLocation += splitLine[i].length + <NUM_LIT>;<EOL>            if (currentLocation >= position.character) {<EOL>                currentLine = splitLine[ i];<EOL>                if ( isIllegalLine(currentLine)) {<EOL>                    splitLine[i] = '<STR_LIT>';<EOL>                    lines.splice(position.line, <NUM_LIT>, splitLine.join('<STR_LIT>'));<EOL>                     fixedSrc = lines.join('<STR_LIT>');<EOL>                }<EOL>                break;<EOL>            }<EOL>            else {<EOL>                cursorLineIndex -= splitLine[i]. length + <NUM_LIT>;<EOL>            }<EOL>        }<EOL>    }<EOL>    else if (isIllegalLine(currentLine)) {<EOL>        lines.splice(position.line, <NUM_LIT>, '<STR_LIT>');<EOL>        fixedSrc = lines.join('<STR_LIT>');<EOL>    }<EOL>","gt":"const processed = createMeta(fixedSrc, filePath);"}
{"input":"<s> export function isSelector(node) {<EOL>    return hasOwnProperty.call(node,","gt":"'<STR_LIT>');"}
{"input":"<s> function getCSSAndPosition(css) {<EOL>    const pos = getCaretPosition(","gt":"css);"}
{"input":"<s> export function getPath(fileName) {<EOL>    const fullPath = path.join(CASES_PATH, fileName);<EOL>","gt":"let src = fs.readFileSync(fullPath).toString();"}
{"input":"<s> export function getReferences(fileName, pos) {<EOL>    const fullPath = path.","gt":"join(CASES_PATH, fileName);"}
{"input":"<s> export function moduleFactoryTestKit(files, options = {}) {<EOL>    const fs = createMemoryFs(files);<EOL>    const factory = stylableModuleFactory({<EOL>        resolveNamespace: (namespace) => namespace,<EOL>        fileSystem:","gt":"fs,"}
{"input":"<s> export function moduleFactoryTestKit(files, options = {}) {<EOL>    const fs = createMemoryFs(files);<EOL>    const factory = stylableModuleFactory({<EOL>        resolveNamespace: (namespace) => namespace,<EOL>        fileSystem:  fs,<EOL>        projectRoot: '<STR_LIT>',<EOL>    }, options);<EOL>    return {<EOL>        fs,<EOL>","gt":"factory,"}
{"input":"<s> export function todoFilterReducer(state = (todo) => todo, action) {<EOL>    switch (action.type) {<EOL>        case VisibilityFilters.SHOW_ALL:<EOL>            return (todo) => todo;<EOL>","gt":"case VisibilityFilters.SHOW_ACTIVE:"}
{"input":"<s> export function todoFilterReducer(state = (todo) => todo, action) {<EOL>    switch (action.type) {<EOL>        case VisibilityFilters.SHOW_ALL:<EOL>            return (todo) => todo;<EOL>         case VisibilityFilters.SHOW_ACTIVE:<EOL>            return (todo) => !todo.completed;<EOL>        case VisibilityFilters.SHOW_COMPLETED:<EOL>            return (todo) => todo.completed;<EOL>","gt":"default:"}
{"input":"<s> export function type(label) {<EOL>    if (typeCache[label]) {<EOL>","gt":"throw new Error(`<STR_LIT>`);"}
{"input":"<s> export function hideBorderAndModify(left_border_to_hide_size, right_border_to_hide_size, changeCharInfo) {<EOL>    return function (info) {<EOL>        info.slice(<NUM_LIT>, left_border_to_hide_size).forEach((char_info) => {<EOL>            char_info.renderOptions.","gt":"classes[hiddenClass] = true;"}
{"input":"<s> <EOL>export function toggleFullScreen(term, fullscreen) {<EOL>    let fn;<EOL>    if (typeof fullscreen === '<STR_LIT>') {<EOL>        fn = (term.element.classList.contains('<STR_LIT>')) ? '<STR_LIT>' : '<STR_LIT>';<EOL>    }<EOL>    else if (!fullscreen) {<EOL>        fn = '<STR_LIT>';<EOL>    }<EOL>    else {<EOL>        fn =","gt":"'<STR_LIT>';"}
{"input":"<s> function configEquals(a, b) {<EOL>    for (let i = <NUM_LIT>; i < a.colors.ansi.length; i++) {<EOL>        if (a.colors.ansi[i] !== b.colors.ansi[i]) {<EOL>            return false;<EOL>        }<EOL>    }<EOL>    return a.fontFamily === b.fontFamily &&<EOL>        a.fontSize === b.fontSize &&<EOL>        a.fontWeight === b.fontWeight &&<EOL>        a.fontWeightBold === b.fontWeightBold &&<EOL>        a.allowTransparency === b.allowTransparency &&<EOL>        a.scaledCharWidth ===","gt":"b.scaledCharWidth &&"}
{"input":"<s> export function classNames(...args) {<EOL>    var classes = [];<EOL>    for (var arg of args) {<EOL>        if (!arg)<EOL>            continue;<EOL>","gt":"var argType = typeof arg;"}
{"input":"<s> export function classNames(...args) {<EOL>    var classes = [];<EOL>    for (var arg of args) {<EOL>        if (!arg)<EOL>            continue;<EOL>         var argType = typeof arg;<EOL>        if (argType === '<STR_LIT>') {<EOL>            classes.push(arg);<EOL>        }<EOL>        else if (","gt":"argType === '<STR_LIT>') {"}
{"input":"<s> function valueEquals(v1, v2) {<EOL>    if (v1 === v2)<EOL>        return true;<EOL>","gt":"if (!v1 !== !v2)"}
{"input":"<s> function filterFromLongForm(longForm) {<EOL>    var { metricColumn, measures } = longForm;<EOL>    var values = [];<EOL>    for (var measure of","gt":"measures) {"}
{"input":"<s> function selectionsEqual(a, b) {<EOL>    if (!Boolean(a) === Boolean(b))<EOL>        return false;<EOL>    if (a === b)<EOL>","gt":"return true;"}
{"input":"<s> function selectionsEqual(a, b) {<EOL>    if (!Boolean(a) === Boolean(b))<EOL>        return false;<EOL>    if (a === b)<EOL>         return true;<EOL>    if (!a !== !b)<EOL>        return false;<EOL>    if (typeof a !== typeof b)<EOL>        return false;<EOL>    if (typeof","gt":"a === '<STR_LIT>' && typeof b === '<STR_LIT>')"}
{"input":"<s> export function getNumberOfWholeDigits(n) {<EOL>    return Math.max(Math.floor(log10(","gt":"Math.abs(n))), <NUM_LIT>) + <NUM_LIT>;"}
{"input":"<s> function yamlPropAdder(lines, withComments, options) {<EOL>    const { object, propName, defaultValue, comment } = options;<EOL>    var value = object[propName];<EOL>    if (value == null) {<EOL>        if (withComments &&","gt":"typeof defaultValue !== \"<STR_LIT>\") {"}
{"input":"<s> function yamlPropAdder(lines, withComments, options) {<EOL>    const { object, propName, defaultValue, comment } = options;<EOL>    var value = object[propName];<EOL>    if (value == null) {<EOL>        if (withComments &&  typeof defaultValue !== \"<STR_LIT>\") {<EOL>            lines.push('<STR_LIT>', `<STR_LIT>`, `<STR_LIT>`);<EOL>        }<EOL>    }<EOL>    else {<EOL>        if (withComments)<EOL>","gt":"lines.push('<STR_LIT>', `<STR_LIT>`);"}
{"input":"<s> function addRoutes(attach, router) {<EOL>    app.use(","gt":"attach, router);"}
{"input":"<s> function exitWithError(message) {<EOL>","gt":"console.error(message);"}
{"input":"<s> function exitWithMessage(message) {<EOL>    console.log(message);<EOL>    <EOL>","gt":"try {"}
{"input":"<s> <EOL>function trackAndReplaceWithResolvedValue(tracking) {<EOL>    <EOL>    return (obj, key) => {<EOL>        <EOL>        var val = obj[key];<EOL>","gt":"if (!val)"}
{"input":"<s> <EOL>function trackAndReplaceWithResolvedValue(tracking) {<EOL>    <EOL>    return (obj, key) => {<EOL>        <EOL>        var val = obj[key];<EOL>         if (!val)<EOL>            return;<EOL>        <EOL>        if (_.isFunction(val))<EOL>            val = thunkToPromise(","gt":"val);"}
{"input":"<s> <EOL>function trackAndReplaceWithResolvedValue(tracking) {<EOL>    <EOL>    return (obj, key) => {<EOL>        <EOL>        var val = obj[key];<EOL>         if (!val)<EOL>            return;<EOL>        <EOL>        if (_.isFunction(val))<EOL>            val = thunkToPromise( val);<EOL>        <EOL>        if (_.isFunction(val.then)) {<EOL>            tracking.","gt":"push(val);"}
{"input":"<s> export function* syncMoreComments({ payload }) {<EOL>    const comments = yield select(commentSelector);<EOL>    const commentsState = comments[payload];<EOL>    if (commentsState && commentsState.more) {<EOL>        yield put({<EOL>            type: '<STR_LIT>'<EOL>        });<EOL>        const offset = commentsState.offset + <NUM_LIT>;<EOL>        const response = yield* ajaxCall(api.getComments, payload, '<STR_LIT>', offset.toString());<EOL>        if (","gt":"response.code === <NUM_LIT>) {"}
{"input":"<s> export function* syncMoreComments({ payload }) {<EOL>    const comments = yield select(commentSelector);<EOL>    const commentsState = comments[payload];<EOL>    if (commentsState && commentsState.more) {<EOL>        yield put({<EOL>            type: '<STR_LIT>'<EOL>        });<EOL>        const offset = commentsState.offset + <NUM_LIT>;<EOL>        const response = yield* ajaxCall(api.getComments, payload, '<STR_LIT>', offset.toString());<EOL>        if ( response.code === <NUM_LIT>) {<EOL>            yield put({<EOL>                type: '<STR_LIT>',<EOL>","gt":"payload: {"}
{"input":"<s> export function* syncMoreComments({ payload }) {<EOL>    const comments = yield select(commentSelector);<EOL>    const commentsState = comments[payload];<EOL>    if (commentsState && commentsState.more) {<EOL>        yield put({<EOL>            type: '<STR_LIT>'<EOL>        });<EOL>        const offset = commentsState.offset + <NUM_LIT>;<EOL>        const response = yield* ajaxCall(api.getComments, payload, '<STR_LIT>', offset.toString());<EOL>        if ( response.code === <NUM_LIT>) {<EOL>            yield put({<EOL>                type: '<STR_LIT>',<EOL>                 payload: {<EOL>                    [payload]: {<EOL>                        ...response,<EOL>                        hotComments:","gt":"commentsState.hotComments,"}
{"input":"<s> export function* syncMoreComments({ payload }) {<EOL>    const comments = yield select(commentSelector);<EOL>    const commentsState = comments[payload];<EOL>    if (commentsState && commentsState.more) {<EOL>        yield put({<EOL>            type: '<STR_LIT>'<EOL>        });<EOL>        const offset = commentsState.offset + <NUM_LIT>;<EOL>        const response = yield* ajaxCall(api.getComments, payload, '<STR_LIT>', offset.toString());<EOL>        if ( response.code === <NUM_LIT>) {<EOL>            yield put({<EOL>                type: '<STR_LIT>',<EOL>                 payload: {<EOL>                    [payload]: {<EOL>                        ...response,<EOL>                        hotComments:  commentsState.hotComments,<EOL>                        comments: commentsState.comments.concat(response.comments),<EOL>                        offset<EOL>                    }<EOL>                }<EOL>            });<EOL>        }<EOL>","gt":"yield put({"}
{"input":"<s> export function refreshResource(action, caller, width = <NUM_LIT>, limit = '<STR_LIT>') {<EOL>    <EOL>    return function* () {<EOL>        yield put({<EOL>            type:","gt":"action}/refresh/start`<STR_LIT>`"}
{"input":"<s> export function refreshResource(action, caller, width = <NUM_LIT>, limit = '<STR_LIT>') {<EOL>    <EOL>    return function* () {<EOL>        yield put({<EOL>            type: `<STR_LIT>`<EOL>        });<EOL>        const response = yield* ajaxCall(caller, limit);<EOL>        if (response.code ===","gt":"<NUM_LIT>) {"}
{"input":"<s> export function refreshResource(action, caller, width = <NUM_LIT>, limit = '<STR_LIT>') {<EOL>    <EOL>    return function* () {<EOL>        yield put({<EOL>            type: `<STR_LIT>`<EOL>        });<EOL>        const response = yield* ajaxCall(caller, limit);<EOL>        if (response.code ===  <NUM_LIT>) {<EOL>            yield put({<EOL>                type: `<STR_LIT>`,<EOL>                payload: changeCoverImgUrl(response[action], width),<EOL>","gt":"meta: {"}
{"input":"<s> function aesEncrypt(text, secKey) {<EOL>    return CryptoJS.AES.encrypt(text, CryptoJS.enc.Utf8.parse(secKey), { iv: CryptoJS.enc.Utf8.parse(","gt":"'<STR_LIT>') }).toString();"}
{"input":"<s> function checkStatusFilter(response) {<EOL>    if (response.ok) {<EOL>        return response;<EOL>    }<EOL>","gt":"else {"}
{"input":"<s> function checkStatusFilter(response) {<EOL>    if (response.ok) {<EOL>        return response;<EOL>    }<EOL>     else {<EOL>        const error = new Error(response.statusText);<EOL>        error.name = '<STR_LIT>';<EOL>        return {<EOL>","gt":"error"}
{"input":"<s> export function getCsrfFromCookies() {<EOL>    const csrfReg = /csrf=(\\w*)/.","gt":"exec(getCookies());"}
{"input":"<s> function post(uri, body) {<EOL>    return fetch(API_BASE_URL + uri, {<EOL>        body: qs.stringify(body),<EOL>        headers: {<EOL>            ...defaultHeaders,<EOL>            '<STR_LIT>':","gt":"getCookies()"}
{"input":"<s> function post(uri, body) {<EOL>    return fetch(API_BASE_URL + uri, {<EOL>        body: qs.stringify(body),<EOL>        headers: {<EOL>            ...defaultHeaders,<EOL>            '<STR_LIT>':  getCookies()<EOL>        },<EOL>        method: '<STR_LIT>'<EOL>    })<EOL>        .then(","gt":"checkStatusFilter)"}
{"input":"<s> function post(uri, body) {<EOL>    return fetch(API_BASE_URL + uri, {<EOL>        body: qs.stringify(body),<EOL>        headers: {<EOL>            ...defaultHeaders,<EOL>            '<STR_LIT>':  getCookies()<EOL>        },<EOL>        method: '<STR_LIT>'<EOL>    })<EOL>        .then( checkStatusFilter)<EOL>        .then(setCookiesFilter)<EOL>        .then(parseJSONFilter)<EOL>        .then(","gt":"addUserIdToCookies)"}
