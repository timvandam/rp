{"input":"<s> <EOL>export function GoDown(num: number): IAction {<EOL>    let m: DownMotion = new DownMotion();<EOL>    let a:","gt":"GoDownAction = new GoDownAction();"}
{"input":"<s> <EOL>export function GotoWordFoword(num: number): IAction {<EOL>    let a: GoAction = new GoAction();<EOL>    let m:","gt":"MoveWordMotion = new MoveWordMotion();"}
{"input":"<s> <EOL>export function GotoRight(num: number): IAction {<EOL>    let m: RightMotion = new RightMotion();<EOL>    m.Count = num > <NUM_LIT> ? num :","gt":"<NUM_LIT>;"}
{"input":"<s> <EOL>export function AddOuterGraveAccentSelection(num: number, action: IAction): void {<EOL>    let m: QuotationSelection = new QuotationSelection();<EOL>    m.","gt":"Quote = \"<STR_LIT>\";"}
{"input":"<s> function tranceVimStyleRange(org: vscode.Range): IRange {<EOL>    let r: Range = new Range();<EOL>    r.","gt":"start = tranceVimStylePosition(org.start);"}
{"input":"<s> function getOrCreateProps(target: any): any {<EOL>    if (!target.hasOwnProperty('<STR_LIT>')) {<EOL>        target.","gt":"__agBeanMetaData = {};"}
{"input":"<s> function writeCanvasTo(context: CanvasRenderingContext2D, color: string): (log: DragDeltaLog) => void {<EOL>    return function (log: DragDeltaLog) {<EOL>        const { prev, curt } = log;<EOL>        const prevX: number = prev.clientX;<EOL>        const prevY: number = prev.clientY;<EOL>        const","gt":"curtX: number = curt.clientX;"}
{"input":"<s> function writeCanvasTo(context: CanvasRenderingContext2D, color: string): (log: DragDeltaLog) => void {<EOL>    return function (log: DragDeltaLog) {<EOL>        const { prev, curt } = log;<EOL>        const prevX: number = prev.clientX;<EOL>        const prevY: number = prev.clientY;<EOL>        const curtX: number = curt.clientX;<EOL>        const curtY: number = curt.clientY;<EOL>        context.strokeStyle = color;<EOL>        context.beginPath();<EOL>        context.moveTo(prevX, prevY);<EOL>        context.lineTo(curtX, curtY);<EOL>        context.","gt":"lineWidth = <NUM_LIT>;"}
{"input":"<s> export function mouseleave(el = document.body): Observable<MouseEvent> {<EOL>    return Observable.","gt":"fromEvent(el, '<STR_LIT>');"}
{"input":"<s> function horizontalRatioOf(width: number): () => number {<EOL>    return","gt":"function () {"}
{"input":"<s> function linkOpenAsTargetBlank(tokens: any[], idx: number, options: any, env: any, self: any): any {<EOL>    const linkOpenToken: any = tokens[idx];<EOL>    const targetAttrIndex: any = linkOpenToken.attrIndex('<STR_LIT>');<EOL>","gt":"if (targetAttrIndex < <NUM_LIT>) {"}
{"input":"<s> export function defaults(orig: any, defaults: any): {<EOL>    [key: string]: any;<EOL>} {<EOL>    const ret: {<EOL>        [key: string]: any;<EOL>    } = clone(orig);<EOL>    Object.keys(","gt":"defaults).forEach((k: string): void => {"}
{"input":"<s> export function defaults(orig: any, defaults: any): {<EOL>    [key: string]: any;<EOL>} {<EOL>    const ret: {<EOL>        [key: string]: any;<EOL>    } = clone(orig);<EOL>    Object.keys(defaults).forEach((k: string): void => {<EOL>        if (k in ret) {<EOL>            return;<EOL>        }<EOL>        ret[k] = defaults[","gt":"k];"}
{"input":"<s> export function buildDateString(datetime: ISimpleDate): string {<EOL>    const { year, month, day, weekday } = datetime;<EOL>    let dateString: string = `<STR_LIT>`;<EOL>    if (","gt":"Utils.getLeftZero()) {"}
{"input":"<s> function padDate(str: string): string {<EOL>    let regex: RegExp = /-(\\d)(-|$)/;<EOL>","gt":"while (regex.exec(str) !== null) {"}
{"input":"<s> <EOL>export function findEndOfContent(document: vscode.TextDocument, pos: vscode.Position, levelSym: string = \"<STR_LIT>\"): any {<EOL>    if (pos.line === document.lineCount - <NUM_LIT>) {<EOL>        return new vscode.Position(pos.line, getLine(document, pos).length);<EOL>        '<STR_LIT>';<EOL>    }<EOL>    let","gt":"sectionRegex: any = getSectionRegex(levelSym);"}
{"input":"<s> <EOL>export function findEndOfContent(document: vscode.TextDocument, pos: vscode.Position, levelSym: string = \"<STR_LIT>\"): any {<EOL>    if (pos.line === document.lineCount - <NUM_LIT>) {<EOL>        return new vscode.Position(pos.line, getLine(document, pos).length);<EOL>        '<STR_LIT>';<EOL>    }<EOL>    let sectionRegex: any = getSectionRegex(levelSym);<EOL>    if (levelSym.startsWith(\"<STR_LIT>\")) { <EOL>        let numStars: number = getStarPrefixCount(levelSym) + <NUM_LIT>;<EOL>        sectionRegex =","gt":"new RegExp(`<STR_LIT>`);"}
{"input":"<s> <EOL>export function findEndOfContent(document: vscode.TextDocument, pos: vscode.Position, levelSym: string = \"<STR_LIT>\"): any {<EOL>    if (pos.line === document.lineCount - <NUM_LIT>) {<EOL>        return new vscode.Position(pos.line, getLine(document, pos).length);<EOL>        '<STR_LIT>';<EOL>    }<EOL>    let sectionRegex: any = getSectionRegex(levelSym);<EOL>    if (levelSym.startsWith(\"<STR_LIT>\")) { <EOL>        let numStars: number = getStarPrefixCount(levelSym) + <NUM_LIT>;<EOL>        sectionRegex = new RegExp(`<STR_LIT>`);<EOL>    }<EOL>    let curLine: any = pos.line;<EOL>    let curPos: any;<EOL>    let curLinePrefix: any;<EOL>","gt":"do {"}
{"input":"<s> <EOL>export function findEndOfContent(document: vscode.TextDocument, pos: vscode.Position, levelSym: string = \"<STR_LIT>\"): any {<EOL>    if (pos.line === document.lineCount - <NUM_LIT>) {<EOL>        return new vscode.Position(pos.line, getLine(document, pos).length);<EOL>        '<STR_LIT>';<EOL>    }<EOL>    let sectionRegex: any = getSectionRegex(levelSym);<EOL>    if (levelSym.startsWith(\"<STR_LIT>\")) { <EOL>        let numStars: number = getStarPrefixCount(levelSym) + <NUM_LIT>;<EOL>        sectionRegex = new RegExp(`<STR_LIT>`);<EOL>    }<EOL>    let curLine: any = pos.line;<EOL>    let curPos: any;<EOL>    let curLinePrefix: any;<EOL>    do {<EOL>        curLine++;<EOL>        curPos = new vscode.Position(curLine, <NUM_LIT>);<EOL>        curLinePrefix = getPrefix(getLine(document, curPos));<EOL>    } while (curLine < document.lineCount - <NUM_LIT> && inSubsection(curLinePrefix, sectionRegex));<EOL>    if (curLine !== document.lineCount - <NUM_LIT>) {<EOL>        curPos =","gt":"new vscode.Position(curPos.line - <NUM_LIT>, getLine(document, new vscode.Position(curPos.line - <NUM_LIT>, <NUM_LIT>)).length + <NUM_LIT>);"}
{"input":"<s> export function hexDiff(hex1: string, hex2: string): number {<EOL>    let","gt":"rgb1: Vec3 = hexToRgb(hex1);"}
{"input":"<s> <EOL>export function isNumber(obj: any): boolean {<EOL>    return","gt":"typeof obj === \"<STR_LIT>\";"}
{"input":"<s> <EOL>export function b64DecodeUnicode(str: any): string {<EOL>    return decodeURIComponent(Array.prototype.","gt":"map.call(b64decode(str), (c: any): string => {"}
{"input":"<s> <EOL>function makeLonghand<T extends {<EOL>    instruction: string;<EOL>    data?: number[];<EOL>}>(item: T, data: number[]): T {<EOL>    switch (item.instruction) {<EOL>        case '<STR_LIT>':<EOL>            item.instruction = '<STR_LIT>';<EOL>","gt":"break;"}
{"input":"<s> function cross(o: number[], a: number[], b: number[]): number {<EOL>    return (a[<NUM_LIT>] -","gt":"o[<NUM_LIT>]) * (b[<NUM_LIT>] - o[<NUM_LIT>]) - (a[<NUM_LIT>] - o[<NUM_LIT>]) * (b[<NUM_LIT>] - o[<NUM_LIT>]);"}
{"input":"<s> function A(aA1: number, aA2: number): number {<EOL>    return <NUM_LIT> - <NUM_LIT> *","gt":"aA2 + <NUM_LIT> * aA1;"}
{"input":"<s> <EOL>export function commandsToString(commands: ReadonlyArray<Command>): string {<EOL>    const tokens: SvgChar[] = [];<EOL>    commands.forEach((cmd: Command): void => {<EOL>        tokens.push(","gt":"cmd.type);"}
{"input":"<s> function newBezierCurve(start: Point, cp1: Point, cp2: Point, end: Point): Command {<EOL>    return new Command('<STR_LIT>', [start, cp1, cp2,","gt":"end]);"}
{"input":"<s> <EOL>export function floorMod(num: number, maxNum: number): number {<EOL>","gt":"return (num % maxNum + maxNum) % maxNum;"}
{"input":"<s> <EOL>export function toSvgString(vectorLayer: VectorLayer, width?: number, height?: number, x?: number, y?: number, withIdsAndNS: boolean = true, frameNumber: string = '<STR_LIT>'): string {<EOL>    const xmlDoc: XMLDocument = document.implementation.createDocument(undefined, '<STR_LIT>', undefined);<EOL>    const rootNode: HTMLElement = xmlDoc.documentElement;<EOL>    vectorLayerToSvgNode(vectorLayer, rootNode, xmlDoc, withIdsAndNS, frameNumber);<EOL>    if (width !== undefined) {<EOL>        rootNode.setAttributeNS(undefined, '<STR_LIT>', width.","gt":"toString() + '<STR_LIT>');"}
{"input":"<s> <EOL>export function toSvgString(vectorLayer: VectorLayer, width?: number, height?: number, x?: number, y?: number, withIdsAndNS: boolean = true, frameNumber: string = '<STR_LIT>'): string {<EOL>    const xmlDoc: XMLDocument = document.implementation.createDocument(undefined, '<STR_LIT>', undefined);<EOL>    const rootNode: HTMLElement = xmlDoc.documentElement;<EOL>    vectorLayerToSvgNode(vectorLayer, rootNode, xmlDoc, withIdsAndNS, frameNumber);<EOL>    if (width !== undefined) {<EOL>        rootNode.setAttributeNS(undefined, '<STR_LIT>', width.toString() + '<STR_LIT>');<EOL>    }<EOL>    if (height !== undefined) {<EOL>        rootNode.setAttributeNS(undefined, '<STR_LIT>', height.toString() + '<STR_LIT>');<EOL>    }<EOL>    if (x !== undefined) {<EOL>        rootNode.setAttributeNS(undefined, '<STR_LIT>', x.toString() + '<STR_LIT>');<EOL>    }<EOL>","gt":"if (y !== undefined) {"}
{"input":"<s> function isSvgNode(node: Element): node is SVGSVGElement {<EOL>","gt":"return node.nodeName === '<STR_LIT>';"}
{"input":"<s> function JS2SVG(config: any): void {<EOL>    if (config) {<EOL>        this.config = Object.assign({}, defaults, config);<EOL>    }<EOL>    else {<EOL>","gt":"this.config = defaults;"}
{"input":"<s> function JS2SVG(config: any): void {<EOL>    if (config) {<EOL>        this.config = Object.assign({}, defaults, config);<EOL>    }<EOL>    else {<EOL>        this.config = defaults;<EOL>    }<EOL>    var indent: any = this.config.indent;<EOL>    if (typeof indent == '<STR_LIT>' && !isNaN(indent)) {<EOL>","gt":"this.config.indent = '<STR_LIT>';"}
{"input":"<s> function JS2SVG(config: any): void {<EOL>    if (config) {<EOL>        this.config = Object.assign({}, defaults, config);<EOL>    }<EOL>    else {<EOL>        this.config = defaults;<EOL>    }<EOL>    var indent: any = this.config.indent;<EOL>    if (typeof indent == '<STR_LIT>' && !isNaN(indent)) {<EOL>        this.config.indent = '<STR_LIT>';<EOL>        for (var i: number = indent; i-- > <NUM_LIT>;)<EOL>            this.config.indent += '<STR_LIT>';<EOL>    }<EOL>    else if (typeof indent != '<STR_LIT>') {<EOL>        this.config.indent = '<STR_LIT>';<EOL>    }<EOL>    if (this.config.pretty) {<EOL>        this.config.doctypeEnd += EOL;<EOL>        this.config.procInstEnd += EOL;<EOL>        this.config.commentEnd += EOL;<EOL>        this.config.cdataEnd += EOL;<EOL>        this.config.","gt":"tagShortEnd += EOL;"}
{"input":"<s> <EOL>function getMatrixData(a: any, b: any): any {<EOL>    return b.name ==","gt":"'<STR_LIT>' ? a.concat(b.data.slice(<NUM_LIT>, <NUM_LIT>)) : a;"}
{"input":"<s> <EOL>function mergePathsFn(item: any, params: any): void {<EOL>    if (!item.isElem() || item.isEmpty())<EOL>        return;<EOL>    var prevContentItem: any = null, prevContentItemKeys: any = null;<EOL>    item.content = item.content.filter(function (contentItem) {<EOL>        if (prevContentItem &&<EOL>            prevContentItem.isElem(","gt":"'<STR_LIT>') &&"}
{"input":"<s> <EOL>function mergePathsFn(item: any, params: any): void {<EOL>    if (!item.isElem() || item.isEmpty())<EOL>        return;<EOL>    var prevContentItem: any = null, prevContentItemKeys: any = null;<EOL>    item.content = item.content.filter(function (contentItem) {<EOL>        if (prevContentItem &&<EOL>            prevContentItem.isElem('<STR_LIT>') &&<EOL>            prevContentItem.isEmpty() &&<EOL>            prevContentItem.hasAttr('<STR_LIT>') &&<EOL>            contentItem.","gt":"isElem('<STR_LIT>') &&"}
{"input":"<s> <EOL>function mergePathsFn(item: any, params: any): void {<EOL>    if (!item.isElem() || item.isEmpty())<EOL>        return;<EOL>    var prevContentItem: any = null, prevContentItemKeys: any = null;<EOL>    item.content = item.content.filter(function (contentItem) {<EOL>        if (prevContentItem &&<EOL>            prevContentItem.isElem('<STR_LIT>') &&<EOL>            prevContentItem.isEmpty() &&<EOL>            prevContentItem.hasAttr('<STR_LIT>') &&<EOL>            contentItem.isElem('<STR_LIT>') &&<EOL>            contentItem.isEmpty() &&<EOL>            contentItem.hasAttr('<STR_LIT>')) {<EOL>","gt":"if (!prevContentItemKeys) {"}
{"input":"<s> <EOL>function mergePathsFn(item: any, params: any): void {<EOL>    if (!item.isElem() || item.isEmpty())<EOL>        return;<EOL>    var prevContentItem: any = null, prevContentItemKeys: any = null;<EOL>    item.content = item.content.filter(function (contentItem) {<EOL>        if (prevContentItem &&<EOL>            prevContentItem.isElem('<STR_LIT>') &&<EOL>            prevContentItem.isEmpty() &&<EOL>            prevContentItem.hasAttr('<STR_LIT>') &&<EOL>            contentItem.isElem('<STR_LIT>') &&<EOL>            contentItem.isEmpty() &&<EOL>            contentItem.hasAttr('<STR_LIT>')) {<EOL>            if (!prevContentItemKeys) {<EOL>                prevContentItemKeys = Object.keys(prevContentItem.attrs);<EOL>            }<EOL>            var contentItemAttrs: string[] = Object.keys(contentItem.attrs), equalData: boolean = prevContentItemKeys.length == contentItemAttrs.length &&<EOL>                contentItemAttrs.every(","gt":"function (key) {"}
{"input":"<s> <EOL>function mergePathsFn(item: any, params: any): void {<EOL>    if (!item.isElem() || item.isEmpty())<EOL>        return;<EOL>    var prevContentItem: any = null, prevContentItemKeys: any = null;<EOL>    item.content = item.content.filter(function (contentItem) {<EOL>        if (prevContentItem &&<EOL>            prevContentItem.isElem('<STR_LIT>') &&<EOL>            prevContentItem.isEmpty() &&<EOL>            prevContentItem.hasAttr('<STR_LIT>') &&<EOL>            contentItem.isElem('<STR_LIT>') &&<EOL>            contentItem.isEmpty() &&<EOL>            contentItem.hasAttr('<STR_LIT>')) {<EOL>            if (!prevContentItemKeys) {<EOL>                prevContentItemKeys = Object.keys(prevContentItem.attrs);<EOL>            }<EOL>            var contentItemAttrs: string[] = Object.keys(contentItem.attrs), equalData: boolean = prevContentItemKeys.length == contentItemAttrs.length &&<EOL>                contentItemAttrs.every(function (key) {<EOL>                    return key == '<STR_LIT>' ||<EOL>                        prevContentItem.hasAttr(key) &&<EOL>                            prevContentItem.attr(key).value == contentItem.attr(key).value;<EOL>                }), prevPathJS: any = path2js(prevContentItem), curPathJS: any = path2js(contentItem);<EOL>            if (equalData && !intersects(prevPathJS, curPathJS)) {<EOL>                js2path(prevContentItem,","gt":"prevPathJS.concat(curPathJS), params);"}
{"input":"<s> <EOL><EOL>function a2c(x1: any, y1: any, rx: any, ry: any, angle: any, large_arc_flag: any, sweep_flag: any, x2: any, y2: any, recursive: any): any[] {<EOL>    <EOL>    <EOL>    var _120: number = Math.PI * <NUM_LIT> / <NUM_LIT>, rad: number = Math.PI / <NUM_LIT> * (+angle || <NUM_LIT>), res: any[] = [], rotateX: (x: any, y: any, rad: any) => number = function (x, y, rad) {<EOL>        return x * Math.cos(rad) - y * Math.sin(rad);<EOL>    }, rotateY: (x: any, y: any, rad: any) => number = function (x, y,","gt":"rad) {"}
{"input":"<s> <EOL><EOL>function a2c(x1: any, y1: any, rx: any, ry: any, angle: any, large_arc_flag: any, sweep_flag: any, x2: any, y2: any, recursive: any): any[] {<EOL>    <EOL>    <EOL>    var _120: number = Math.PI * <NUM_LIT> / <NUM_LIT>, rad: number = Math.PI / <NUM_LIT> * (+angle || <NUM_LIT>), res: any[] = [], rotateX: (x: any, y: any, rad: any) => number = function (x, y, rad) {<EOL>        return x * Math.cos(rad) - y * Math.sin(rad);<EOL>    }, rotateY: (x: any, y: any, rad: any) => number = function (x, y, rad) {<EOL>        return x * Math.sin(rad) + y * Math.cos(rad);<EOL>    };<EOL>","gt":"if (!recursive) {"}
{"input":"<s> <EOL><EOL>function a2c(x1: any, y1: any, rx: any, ry: any, angle: any, large_arc_flag: any, sweep_flag: any, x2: any, y2: any, recursive: any): any[] {<EOL>    <EOL>    <EOL>    var _120: number = Math.PI * <NUM_LIT> / <NUM_LIT>, rad: number = Math.PI / <NUM_LIT> * (+angle || <NUM_LIT>), res: any[] = [], rotateX: (x: any, y: any, rad: any) => number = function (x, y, rad) {<EOL>        return x * Math.cos(rad) - y * Math.sin(rad);<EOL>    }, rotateY: (x: any, y: any, rad: any) => number = function (x, y, rad) {<EOL>        return x * Math.sin(rad) + y * Math.cos(rad);<EOL>    };<EOL>    if (!recursive) {<EOL>        x1 = rotateX(x1, y1, -rad);<EOL>        y1 = rotateY(x1, y1, -rad);<EOL>        x2 = rotateX(x2,","gt":"y2, -rad);"}
{"input":"<s> <EOL><EOL>function a2c(x1: any, y1: any, rx: any, ry: any, angle: any, large_arc_flag: any, sweep_flag: any, x2: any, y2: any, recursive: any): any[] {<EOL>    <EOL>    <EOL>    var _120: number = Math.PI * <NUM_LIT> / <NUM_LIT>, rad: number = Math.PI / <NUM_LIT> * (+angle || <NUM_LIT>), res: any[] = [], rotateX: (x: any, y: any, rad: any) => number = function (x, y, rad) {<EOL>        return x * Math.cos(rad) - y * Math.sin(rad);<EOL>    }, rotateY: (x: any, y: any, rad: any) => number = function (x, y, rad) {<EOL>        return x * Math.sin(rad) + y * Math.cos(rad);<EOL>    };<EOL>    if (!recursive) {<EOL>        x1 = rotateX(x1, y1, -rad);<EOL>        y1 = rotateY(x1, y1, -rad);<EOL>        x2 = rotateX(x2, y2, -rad);<EOL>        y2 =","gt":"rotateY(x2, y2, -rad);"}
{"input":"<s> <EOL><EOL>function a2c(x1: any, y1: any, rx: any, ry: any, angle: any, large_arc_flag: any, sweep_flag: any, x2: any, y2: any, recursive: any): any[] {<EOL>    <EOL>    <EOL>    var _120: number = Math.PI * <NUM_LIT> / <NUM_LIT>, rad: number = Math.PI / <NUM_LIT> * (+angle || <NUM_LIT>), res: any[] = [], rotateX: (x: any, y: any, rad: any) => number = function (x, y, rad) {<EOL>        return x * Math.cos(rad) - y * Math.sin(rad);<EOL>    }, rotateY: (x: any, y: any, rad: any) => number = function (x, y, rad) {<EOL>        return x * Math.sin(rad) + y * Math.cos(rad);<EOL>    };<EOL>    if (!recursive) {<EOL>        x1 = rotateX(x1, y1, -rad);<EOL>        y1 = rotateY(x1, y1, -rad);<EOL>        x2 = rotateX(x2, y2, -rad);<EOL>        y2 = rotateY(x2, y2, -rad);<EOL>        var x: number = (x1 - x2) / <NUM_LIT>, y: number = (y1 - y2) / <NUM_LIT>;<EOL>        var h: number = x * x / (rx * rx) + y * y / (ry * ry);<EOL>        if (h > <NUM_LIT>) {<EOL>            h = Math.sqrt(h);<EOL>            rx = h * rx;<EOL>","gt":"ry = h * ry;"}
{"input":"<s> <EOL><EOL>function a2c(x1: any, y1: any, rx: any, ry: any, angle: any, large_arc_flag: any, sweep_flag: any, x2: any, y2: any, recursive: any): any[] {<EOL>    <EOL>    <EOL>    var _120: number = Math.PI * <NUM_LIT> / <NUM_LIT>, rad: number = Math.PI / <NUM_LIT> * (+angle || <NUM_LIT>), res: any[] = [], rotateX: (x: any, y: any, rad: any) => number = function (x, y, rad) {<EOL>        return x * Math.cos(rad) - y * Math.sin(rad);<EOL>    }, rotateY: (x: any, y: any, rad: any) => number = function (x, y, rad) {<EOL>        return x * Math.sin(rad) + y * Math.cos(rad);<EOL>    };<EOL>    if (!recursive) {<EOL>        x1 = rotateX(x1, y1, -rad);<EOL>        y1 = rotateY(x1, y1, -rad);<EOL>        x2 = rotateX(x2, y2, -rad);<EOL>        y2 = rotateY(x2, y2, -rad);<EOL>        var x: number = (x1 - x2) / <NUM_LIT>, y: number = (y1 - y2) / <NUM_LIT>;<EOL>        var h: number = x * x / (rx * rx) + y * y / (ry * ry);<EOL>        if (h > <NUM_LIT>) {<EOL>            h = Math.sqrt(h);<EOL>            rx = h * rx;<EOL>            ry = h * ry;<EOL>        }<EOL>        var rx2: number = rx * rx, ry2: number = ry * ry, k: number = (large_arc_flag == sweep_flag ? -<NUM_LIT> : <NUM_LIT>) *<EOL>            Math.sqrt(Math.abs((rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x))), cx: number = k * rx * y / ry + (x1 + x2) / <NUM_LIT>, cy: number = k * -ry * x / rx + (y1 + y2) / <NUM_LIT>, f1: number = Math.asin(Number(((y1 - cy) / ry).toFixed(<NUM_LIT>))), f2: number = Math.asin(Number(((y2 - cy) / ry).toFixed(<NUM_LIT>)));<EOL>        f1 = x1 < cx ? Math.PI - f1 : f1;<EOL>        f2 = x2 < cx ? Math.PI - f2 : f2;<EOL>        f1 < <NUM_LIT> && (f1 = Math.PI * <NUM_LIT> + f1);<EOL>        f2 < <NUM_LIT> && (f2 =","gt":"Math.PI * <NUM_LIT> + f2);"}
{"input":"<s> <EOL><EOL>function a2c(x1: any, y1: any, rx: any, ry: any, angle: any, large_arc_flag: any, sweep_flag: any, x2: any, y2: any, recursive: any): any[] {<EOL>    <EOL>    <EOL>    var _120: number = Math.PI * <NUM_LIT> / <NUM_LIT>, rad: number = Math.PI / <NUM_LIT> * (+angle || <NUM_LIT>), res: any[] = [], rotateX: (x: any, y: any, rad: any) => number = function (x, y, rad) {<EOL>        return x * Math.cos(rad) - y * Math.sin(rad);<EOL>    }, rotateY: (x: any, y: any, rad: any) => number = function (x, y, rad) {<EOL>        return x * Math.sin(rad) + y * Math.cos(rad);<EOL>    };<EOL>    if (!recursive) {<EOL>        x1 = rotateX(x1, y1, -rad);<EOL>        y1 = rotateY(x1, y1, -rad);<EOL>        x2 = rotateX(x2, y2, -rad);<EOL>        y2 = rotateY(x2, y2, -rad);<EOL>        var x: number = (x1 - x2) / <NUM_LIT>, y: number = (y1 - y2) / <NUM_LIT>;<EOL>        var h: number = x * x / (rx * rx) + y * y / (ry * ry);<EOL>        if (h > <NUM_LIT>) {<EOL>            h = Math.sqrt(h);<EOL>            rx = h * rx;<EOL>            ry = h * ry;<EOL>        }<EOL>        var rx2: number = rx * rx, ry2: number = ry * ry, k: number = (large_arc_flag == sweep_flag ? -<NUM_LIT> : <NUM_LIT>) *<EOL>            Math.sqrt(Math.abs((rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x))), cx: number = k * rx * y / ry + (x1 + x2) / <NUM_LIT>, cy: number = k * -ry * x / rx + (y1 + y2) / <NUM_LIT>, f1: number = Math.asin(Number(((y1 - cy) / ry).toFixed(<NUM_LIT>))), f2: number = Math.asin(Number(((y2 - cy) / ry).toFixed(<NUM_LIT>)));<EOL>        f1 = x1 < cx ? Math.PI - f1 : f1;<EOL>        f2 = x2 < cx ? Math.PI - f2 : f2;<EOL>        f1 < <NUM_LIT> && (f1 = Math.PI * <NUM_LIT> + f1);<EOL>        f2 < <NUM_LIT> && (f2 = Math.PI * <NUM_LIT> + f2);<EOL>        if (sweep_flag && f1 > f2) {<EOL>            f1 = f1 - Math.PI * <NUM_LIT>;<EOL>        }<EOL>        if (!sweep_flag && f2 > f1) {<EOL>            f2 = f2 - Math.PI *","gt":"<NUM_LIT>;"}
{"input":"<s> <EOL><EOL>function a2c(x1: any, y1: any, rx: any, ry: any, angle: any, large_arc_flag: any, sweep_flag: any, x2: any, y2: any, recursive: any): any[] {<EOL>    <EOL>    <EOL>    var _120: number = Math.PI * <NUM_LIT> / <NUM_LIT>, rad: number = Math.PI / <NUM_LIT> * (+angle || <NUM_LIT>), res: any[] = [], rotateX: (x: any, y: any, rad: any) => number = function (x, y, rad) {<EOL>        return x * Math.cos(rad) - y * Math.sin(rad);<EOL>    }, rotateY: (x: any, y: any, rad: any) => number = function (x, y, rad) {<EOL>        return x * Math.sin(rad) + y * Math.cos(rad);<EOL>    };<EOL>    if (!recursive) {<EOL>        x1 = rotateX(x1, y1, -rad);<EOL>        y1 = rotateY(x1, y1, -rad);<EOL>        x2 = rotateX(x2, y2, -rad);<EOL>        y2 = rotateY(x2, y2, -rad);<EOL>        var x: number = (x1 - x2) / <NUM_LIT>, y: number = (y1 - y2) / <NUM_LIT>;<EOL>        var h: number = x * x / (rx * rx) + y * y / (ry * ry);<EOL>        if (h > <NUM_LIT>) {<EOL>            h = Math.sqrt(h);<EOL>            rx = h * rx;<EOL>            ry = h * ry;<EOL>        }<EOL>        var rx2: number = rx * rx, ry2: number = ry * ry, k: number = (large_arc_flag == sweep_flag ? -<NUM_LIT> : <NUM_LIT>) *<EOL>            Math.sqrt(Math.abs((rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x))), cx: number = k * rx * y / ry + (x1 + x2) / <NUM_LIT>, cy: number = k * -ry * x / rx + (y1 + y2) / <NUM_LIT>, f1: number = Math.asin(Number(((y1 - cy) / ry).toFixed(<NUM_LIT>))), f2: number = Math.asin(Number(((y2 - cy) / ry).toFixed(<NUM_LIT>)));<EOL>        f1 = x1 < cx ? Math.PI - f1 : f1;<EOL>        f2 = x2 < cx ? Math.PI - f2 : f2;<EOL>        f1 < <NUM_LIT> && (f1 = Math.PI * <NUM_LIT> + f1);<EOL>        f2 < <NUM_LIT> && (f2 = Math.PI * <NUM_LIT> + f2);<EOL>        if (sweep_flag && f1 > f2) {<EOL>            f1 = f1 - Math.PI * <NUM_LIT>;<EOL>        }<EOL>        if (!sweep_flag && f2 > f1) {<EOL>            f2 = f2 - Math.PI * <NUM_LIT>;<EOL>        }<EOL>    }<EOL>    else {<EOL>        f1 = recursive[<NUM_LIT>];<EOL>        f2 = recursive[<NUM_LIT>];<EOL>        cx = recursive[<NUM_LIT>];<EOL>        cy = recursive[<NUM_LIT>];<EOL>    }<EOL>    var df: number = f2 - f1;<EOL>    if (Math.abs(df) > _120) {<EOL>        var f2old: number = f2, x2old: any = x2, y2old: any = y2;<EOL>        f2 = f1 + _120 * (sweep_flag && f2 > f1 ? <NUM_LIT> : -<NUM_LIT>);<EOL>        x2 = cx + rx * Math.cos(f2);<EOL>        y2 = cy + ry * Math.sin(f2);<EOL>        res = a2c(x2, y2, rx, ry,","gt":"angle, <NUM_LIT>, sweep_flag, x2old, y2old, [f2, f2old, cx, cy]);"}
{"input":"<s> <EOL><EOL>function a2c(x1: any, y1: any, rx: any, ry: any, angle: any, large_arc_flag: any, sweep_flag: any, x2: any, y2: any, recursive: any): any[] {<EOL>    <EOL>    <EOL>    var _120: number = Math.PI * <NUM_LIT> / <NUM_LIT>, rad: number = Math.PI / <NUM_LIT> * (+angle || <NUM_LIT>), res: any[] = [], rotateX: (x: any, y: any, rad: any) => number = function (x, y, rad) {<EOL>        return x * Math.cos(rad) - y * Math.sin(rad);<EOL>    }, rotateY: (x: any, y: any, rad: any) => number = function (x, y, rad) {<EOL>        return x * Math.sin(rad) + y * Math.cos(rad);<EOL>    };<EOL>    if (!recursive) {<EOL>        x1 = rotateX(x1, y1, -rad);<EOL>        y1 = rotateY(x1, y1, -rad);<EOL>        x2 = rotateX(x2, y2, -rad);<EOL>        y2 = rotateY(x2, y2, -rad);<EOL>        var x: number = (x1 - x2) / <NUM_LIT>, y: number = (y1 - y2) / <NUM_LIT>;<EOL>        var h: number = x * x / (rx * rx) + y * y / (ry * ry);<EOL>        if (h > <NUM_LIT>) {<EOL>            h = Math.sqrt(h);<EOL>            rx = h * rx;<EOL>            ry = h * ry;<EOL>        }<EOL>        var rx2: number = rx * rx, ry2: number = ry * ry, k: number = (large_arc_flag == sweep_flag ? -<NUM_LIT> : <NUM_LIT>) *<EOL>            Math.sqrt(Math.abs((rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x))), cx: number = k * rx * y / ry + (x1 + x2) / <NUM_LIT>, cy: number = k * -ry * x / rx + (y1 + y2) / <NUM_LIT>, f1: number = Math.asin(Number(((y1 - cy) / ry).toFixed(<NUM_LIT>))), f2: number = Math.asin(Number(((y2 - cy) / ry).toFixed(<NUM_LIT>)));<EOL>        f1 = x1 < cx ? Math.PI - f1 : f1;<EOL>        f2 = x2 < cx ? Math.PI - f2 : f2;<EOL>        f1 < <NUM_LIT> && (f1 = Math.PI * <NUM_LIT> + f1);<EOL>        f2 < <NUM_LIT> && (f2 = Math.PI * <NUM_LIT> + f2);<EOL>        if (sweep_flag && f1 > f2) {<EOL>            f1 = f1 - Math.PI * <NUM_LIT>;<EOL>        }<EOL>        if (!sweep_flag && f2 > f1) {<EOL>            f2 = f2 - Math.PI * <NUM_LIT>;<EOL>        }<EOL>    }<EOL>    else {<EOL>        f1 = recursive[<NUM_LIT>];<EOL>        f2 = recursive[<NUM_LIT>];<EOL>        cx = recursive[<NUM_LIT>];<EOL>        cy = recursive[<NUM_LIT>];<EOL>    }<EOL>    var df: number = f2 - f1;<EOL>    if (Math.abs(df) > _120) {<EOL>        var f2old: number = f2, x2old: any = x2, y2old: any = y2;<EOL>        f2 = f1 + _120 * (sweep_flag && f2 > f1 ? <NUM_LIT> : -<NUM_LIT>);<EOL>        x2 = cx + rx * Math.cos(f2);<EOL>        y2 = cy + ry * Math.sin(f2);<EOL>        res = a2c(x2, y2, rx, ry, angle, <NUM_LIT>, sweep_flag, x2old, y2old, [f2, f2old, cx, cy]);<EOL>    }<EOL>    df = f2 - f1;<EOL>    var c1: number = Math.cos(f1), s1: number = Math.sin(f1), c2: number = Math.cos(f2), s2: number = Math.sin(f2), t: number = Math.tan(df / <NUM_LIT>), hx: number = <NUM_LIT> / <NUM_LIT> * rx * t, hy: number = <NUM_LIT> / <NUM_LIT> * ry * t, m: number[] = [-hx * s1, hy * c1, x2 + hx * s2 - x1, y2 - hy * c2 - y1, x2 - x1, y2 - y1];<EOL>","gt":"if (recursive) {"}
{"input":"<s> <EOL><EOL>function a2c(x1: any, y1: any, rx: any, ry: any, angle: any, large_arc_flag: any, sweep_flag: any, x2: any, y2: any, recursive: any): any[] {<EOL>    <EOL>    <EOL>    var _120: number = Math.PI * <NUM_LIT> / <NUM_LIT>, rad: number = Math.PI / <NUM_LIT> * (+angle || <NUM_LIT>), res: any[] = [], rotateX: (x: any, y: any, rad: any) => number = function (x, y, rad) {<EOL>        return x * Math.cos(rad) - y * Math.sin(rad);<EOL>    }, rotateY: (x: any, y: any, rad: any) => number = function (x, y, rad) {<EOL>        return x * Math.sin(rad) + y * Math.cos(rad);<EOL>    };<EOL>    if (!recursive) {<EOL>        x1 = rotateX(x1, y1, -rad);<EOL>        y1 = rotateY(x1, y1, -rad);<EOL>        x2 = rotateX(x2, y2, -rad);<EOL>        y2 = rotateY(x2, y2, -rad);<EOL>        var x: number = (x1 - x2) / <NUM_LIT>, y: number = (y1 - y2) / <NUM_LIT>;<EOL>        var h: number = x * x / (rx * rx) + y * y / (ry * ry);<EOL>        if (h > <NUM_LIT>) {<EOL>            h = Math.sqrt(h);<EOL>            rx = h * rx;<EOL>            ry = h * ry;<EOL>        }<EOL>        var rx2: number = rx * rx, ry2: number = ry * ry, k: number = (large_arc_flag == sweep_flag ? -<NUM_LIT> : <NUM_LIT>) *<EOL>            Math.sqrt(Math.abs((rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x))), cx: number = k * rx * y / ry + (x1 + x2) / <NUM_LIT>, cy: number = k * -ry * x / rx + (y1 + y2) / <NUM_LIT>, f1: number = Math.asin(Number(((y1 - cy) / ry).toFixed(<NUM_LIT>))), f2: number = Math.asin(Number(((y2 - cy) / ry).toFixed(<NUM_LIT>)));<EOL>        f1 = x1 < cx ? Math.PI - f1 : f1;<EOL>        f2 = x2 < cx ? Math.PI - f2 : f2;<EOL>        f1 < <NUM_LIT> && (f1 = Math.PI * <NUM_LIT> + f1);<EOL>        f2 < <NUM_LIT> && (f2 = Math.PI * <NUM_LIT> + f2);<EOL>        if (sweep_flag && f1 > f2) {<EOL>            f1 = f1 - Math.PI * <NUM_LIT>;<EOL>        }<EOL>        if (!sweep_flag && f2 > f1) {<EOL>            f2 = f2 - Math.PI * <NUM_LIT>;<EOL>        }<EOL>    }<EOL>    else {<EOL>        f1 = recursive[<NUM_LIT>];<EOL>        f2 = recursive[<NUM_LIT>];<EOL>        cx = recursive[<NUM_LIT>];<EOL>        cy = recursive[<NUM_LIT>];<EOL>    }<EOL>    var df: number = f2 - f1;<EOL>    if (Math.abs(df) > _120) {<EOL>        var f2old: number = f2, x2old: any = x2, y2old: any = y2;<EOL>        f2 = f1 + _120 * (sweep_flag && f2 > f1 ? <NUM_LIT> : -<NUM_LIT>);<EOL>        x2 = cx + rx * Math.cos(f2);<EOL>        y2 = cy + ry * Math.sin(f2);<EOL>        res = a2c(x2, y2, rx, ry, angle, <NUM_LIT>, sweep_flag, x2old, y2old, [f2, f2old, cx, cy]);<EOL>    }<EOL>    df = f2 - f1;<EOL>    var c1: number = Math.cos(f1), s1: number = Math.sin(f1), c2: number = Math.cos(f2), s2: number = Math.sin(f2), t: number = Math.tan(df / <NUM_LIT>), hx: number = <NUM_LIT> / <NUM_LIT> * rx * t, hy: number = <NUM_LIT> / <NUM_LIT> * ry * t, m: number[] = [-hx * s1, hy * c1, x2 + hx * s2 - x1, y2 - hy * c2 - y1, x2 - x1, y2 - y1];<EOL>    if (recursive) {<EOL>        return m.concat(res);<EOL>    }<EOL>","gt":"else {"}
{"input":"<s> function cross(o: any, a: any, b: any): number {<EOL>    return (a[<NUM_LIT>] - o[<NUM_LIT>]) * (b[<NUM_LIT>] - o[","gt":"<NUM_LIT>]) - (a[<NUM_LIT>] - o[<NUM_LIT>]) * (b[<NUM_LIT>] - o[<NUM_LIT>]);"}
{"input":"<s> <EOL>function removeEditorsNSDataFn(item: any, params: any): boolean {<EOL>    if (Array.isArray(params.additionalNamespaces)) {<EOL>        editorNamespaces = editorNamespaces.concat(params.additionalNamespaces);<EOL>    }<EOL>    if (item.elem) {<EOL>","gt":"if (item.isElem('<STR_LIT>')) {"}
{"input":"<s> <EOL>function removeEditorsNSDataFn(item: any, params: any): boolean {<EOL>    if (Array.isArray(params.additionalNamespaces)) {<EOL>        editorNamespaces = editorNamespaces.concat(params.additionalNamespaces);<EOL>    }<EOL>    if (item.elem) {<EOL>        if (item.isElem('<STR_LIT>')) {<EOL>            item.eachAttr(function (attr) {<EOL>                if (attr.prefix === '<STR_LIT>' && editorNamespaces.indexOf(attr.value) > -<NUM_LIT>) {<EOL>                    prefixes.","gt":"push(attr.local);"}
{"input":"<s> <EOL><EOL><EOL><EOL><EOL><EOL>export function cleanupOutData(data: any, params: any): string {<EOL>    var str: string = '<STR_LIT>', delimiter: any, prev: any;<EOL>    data.forEach(function (item, i) {<EOL>        <EOL>        delimiter = '<STR_LIT>';<EOL>        <EOL>        if (i === <NUM_LIT>) {<EOL>            delimiter = '<STR_LIT>';<EOL>        }<EOL>        <EOL>        <EOL>        <EOL>        if (params.leadingZero) {<EOL>            item = removeLeadingZero(item);<EOL>        }<EOL>        <EOL>        <EOL>        if (params.negativeExtraSpace &&<EOL>            (item < <NUM_LIT> || (String(item).charCodeAt(<NUM_LIT>) == <NUM_LIT> && prev % <NUM_LIT> !== <NUM_LIT>))) {<EOL>","gt":"delimiter = '<STR_LIT>';"}
{"input":"<s> <EOL>export function removeLeadingZero(num: any): any {<EOL>    var strNum: any = num.toString();<EOL>    if (<NUM_LIT> < num && num < <NUM_LIT> && strNum.charCodeAt(<NUM_LIT>) == <NUM_LIT>) {<EOL>        strNum = strNum.slice(","gt":"<NUM_LIT>);"}
{"input":"<s> <EOL>export function transform2js(transformString: any): any[] {<EOL>    <EOL>    var transforms: any[] = [], <EOL>    <EOL>    current: any;<EOL>    <EOL>    transformString.split(regTransformSplit).","gt":"forEach(function (item) {"}
{"input":"<s> <EOL>export function transform2js(transformString: any): any[] {<EOL>    <EOL>    var transforms: any[] = [], <EOL>    <EOL>    current: any;<EOL>    <EOL>    transformString.split(regTransformSplit).forEach(function (item) {<EOL>        <EOL>        var num: any;<EOL>","gt":"if (item) {"}
{"input":"<s> export function optimize(svgText: string, callback: (optimizedSvgText: string) => void): void {<EOL>    svg2js(svgText, (svgJs: any): void => {<EOL>        if (svgJs.error) {<EOL>            console.warn('<STR_LIT>', svgJs.error);<EOL>            callback(","gt":"undefined);"}
{"input":"<s> export function optimize(svgText: string, callback: (optimizedSvgText: string) => void): void {<EOL>    svg2js(svgText, (svgJs: any): void => {<EOL>        if (svgJs.error) {<EOL>            console.warn('<STR_LIT>', svgJs.error);<EOL>            callback(undefined);<EOL>            return;<EOL>        }<EOL>        callback(js2svg(executePlugins(svgJs, batchedSvgoPlugins), {<EOL>            indent: '<STR_LIT>',<EOL>","gt":"pretty: true,"}
{"input":"<s> export function _storeFactory(dispatcher: any, reducer: any, state$: any): Store<unknown> {<EOL>    return new Store(dispatcher,","gt":"reducer, state$);"}
{"input":"<s> export function isFunction(functionToCheck: any): functionToCheck is Function {<EOL>    let","gt":"getType: {} = {};"}
{"input":"<s> function gotoItemInActiveList(index: number): void {<EOL>    let","gt":"member: GotoPosition = activeList.members[index];"}
{"input":"<s> export function getCompletionsAtPosition(model: monaco.editor.IReadOnlyModel, position: monaco.Position): Thenable<CompletionList> {<EOL>    const doc: Parser.JSONDocument = Parser.","gt":"parse(model.getValue());"}
{"input":"<s> export function getClassificationsForLine(filePath: string, lineStart: number, string: string): ClassifiedSpan[] {<EOL>    const offsetForBom: number = hasBom[filePath] ? -<NUM_LIT> : <NUM_LIT>;<EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    let lineLength: number = string.length;<EOL>    let","gt":"encodedClassifications: any = languageService.getEncodedSyntacticClassifications(filePath, { start: lineStart, length: lineLength });"}
{"input":"<s> export function getClassificationsForLine(filePath: string, lineStart: number, string: string): ClassifiedSpan[] {<EOL>    const offsetForBom: number = hasBom[filePath] ? -<NUM_LIT> : <NUM_LIT>;<EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    let lineLength: number = string.length;<EOL>    let encodedClassifications: any = languageService.getEncodedSyntacticClassifications(filePath, { start: lineStart, length: lineLength });<EOL>    let classifications: ClassifiedSpan[] = unencodeClassifications(encodedClassifications);<EOL>    <EOL>    let lastStartSet: boolean = false;<EOL>    let lastStart: number = <NUM_LIT>;<EOL>    <EOL>    classifications = classifications<EOL>        .","gt":"map((c: ClassifiedSpan, i: number): ClassifiedSpan => {"}
{"input":"<s> export function getClassificationsForLine(filePath: string, lineStart: number, string: string): ClassifiedSpan[] {<EOL>    const offsetForBom: number = hasBom[filePath] ? -<NUM_LIT> : <NUM_LIT>;<EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    let lineLength: number = string.length;<EOL>    let encodedClassifications: any = languageService.getEncodedSyntacticClassifications(filePath, { start: lineStart, length: lineLength });<EOL>    let classifications: ClassifiedSpan[] = unencodeClassifications(encodedClassifications);<EOL>    <EOL>    let lastStartSet: boolean = false;<EOL>    let lastStart: number = <NUM_LIT>;<EOL>    <EOL>    classifications = classifications<EOL>        .map((c: ClassifiedSpan, i: number): ClassifiedSpan => {<EOL>        <EOL>        c.textSpan.start += offsetForBom;<EOL>        <EOL>        if ((c.textSpan.start + c.textSpan.length) <= lineStart) {<EOL>            return null;<EOL>        }<EOL>        <EOL>        if (c.textSpan.start > (lineStart +","gt":"lineLength)) {"}
{"input":"<s> export function getClassificationsForLine(filePath: string, lineStart: number, string: string): ClassifiedSpan[] {<EOL>    const offsetForBom: number = hasBom[filePath] ? -<NUM_LIT> : <NUM_LIT>;<EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    let lineLength: number = string.length;<EOL>    let encodedClassifications: any = languageService.getEncodedSyntacticClassifications(filePath, { start: lineStart, length: lineLength });<EOL>    let classifications: ClassifiedSpan[] = unencodeClassifications(encodedClassifications);<EOL>    <EOL>    let lastStartSet: boolean = false;<EOL>    let lastStart: number = <NUM_LIT>;<EOL>    <EOL>    classifications = classifications<EOL>        .map((c: ClassifiedSpan, i: number): ClassifiedSpan => {<EOL>        <EOL>        c.textSpan.start += offsetForBom;<EOL>        <EOL>        if ((c.textSpan.start + c.textSpan.length) <= lineStart) {<EOL>            return null;<EOL>        }<EOL>        <EOL>        if (c.textSpan.start > (lineStart + lineLength)) {<EOL>            return null;<EOL>        }<EOL>        <EOL>        if (c.","gt":"textSpan.start < lineStart) {"}
{"input":"<s> export function getClassificationsForLine(filePath: string, lineStart: number, string: string): ClassifiedSpan[] {<EOL>    const offsetForBom: number = hasBom[filePath] ? -<NUM_LIT> : <NUM_LIT>;<EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    let lineLength: number = string.length;<EOL>    let encodedClassifications: any = languageService.getEncodedSyntacticClassifications(filePath, { start: lineStart, length: lineLength });<EOL>    let classifications: ClassifiedSpan[] = unencodeClassifications(encodedClassifications);<EOL>    <EOL>    let lastStartSet: boolean = false;<EOL>    let lastStart: number = <NUM_LIT>;<EOL>    <EOL>    classifications = classifications<EOL>        .map((c: ClassifiedSpan, i: number): ClassifiedSpan => {<EOL>        <EOL>        c.textSpan.start += offsetForBom;<EOL>        <EOL>        if ((c.textSpan.start + c.textSpan.length) <= lineStart) {<EOL>            return null;<EOL>        }<EOL>        <EOL>        if (c.textSpan.start > (lineStart + lineLength)) {<EOL>            return null;<EOL>        }<EOL>        <EOL>        if (c.textSpan.start < lineStart) {<EOL>            c.textSpan.length = c.textSpan.start + c.textSpan.length - lineStart;<EOL>            c.textSpan.","gt":"start = lineStart;"}
{"input":"<s> export function getClassificationsForLine(filePath: string, lineStart: number, string: string): ClassifiedSpan[] {<EOL>    const offsetForBom: number = hasBom[filePath] ? -<NUM_LIT> : <NUM_LIT>;<EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    let lineLength: number = string.length;<EOL>    let encodedClassifications: any = languageService.getEncodedSyntacticClassifications(filePath, { start: lineStart, length: lineLength });<EOL>    let classifications: ClassifiedSpan[] = unencodeClassifications(encodedClassifications);<EOL>    <EOL>    let lastStartSet: boolean = false;<EOL>    let lastStart: number = <NUM_LIT>;<EOL>    <EOL>    classifications = classifications<EOL>        .map((c: ClassifiedSpan, i: number): ClassifiedSpan => {<EOL>        <EOL>        c.textSpan.start += offsetForBom;<EOL>        <EOL>        if ((c.textSpan.start + c.textSpan.length) <= lineStart) {<EOL>            return null;<EOL>        }<EOL>        <EOL>        if (c.textSpan.start > (lineStart + lineLength)) {<EOL>            return null;<EOL>        }<EOL>        <EOL>        if (c.textSpan.start < lineStart) {<EOL>            c.textSpan.length = c.textSpan.start + c.textSpan.length - lineStart;<EOL>            c.textSpan.start = lineStart;<EOL>        }<EOL>        <EOL>        if ((c.textSpan.start + c.textSpan.length) > (lineStart + lineLength)) {<EOL>            c.textSpan.length = (lineStart + lineLength) - (c.textSpan.start);<EOL>        }<EOL>        <EOL>        if (!lastStartSet) {<EOL>","gt":"lastStartSet = true;"}
{"input":"<s> export function getClassificationsForLine(filePath: string, lineStart: number, string: string): ClassifiedSpan[] {<EOL>    const offsetForBom: number = hasBom[filePath] ? -<NUM_LIT> : <NUM_LIT>;<EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    let lineLength: number = string.length;<EOL>    let encodedClassifications: any = languageService.getEncodedSyntacticClassifications(filePath, { start: lineStart, length: lineLength });<EOL>    let classifications: ClassifiedSpan[] = unencodeClassifications(encodedClassifications);<EOL>    <EOL>    let lastStartSet: boolean = false;<EOL>    let lastStart: number = <NUM_LIT>;<EOL>    <EOL>    classifications = classifications<EOL>        .map((c: ClassifiedSpan, i: number): ClassifiedSpan => {<EOL>        <EOL>        c.textSpan.start += offsetForBom;<EOL>        <EOL>        if ((c.textSpan.start + c.textSpan.length) <= lineStart) {<EOL>            return null;<EOL>        }<EOL>        <EOL>        if (c.textSpan.start > (lineStart + lineLength)) {<EOL>            return null;<EOL>        }<EOL>        <EOL>        if (c.textSpan.start < lineStart) {<EOL>            c.textSpan.length = c.textSpan.start + c.textSpan.length - lineStart;<EOL>            c.textSpan.start = lineStart;<EOL>        }<EOL>        <EOL>        if ((c.textSpan.start + c.textSpan.length) > (lineStart + lineLength)) {<EOL>            c.textSpan.length = (lineStart + lineLength) - (c.textSpan.start);<EOL>        }<EOL>        <EOL>        if (!lastStartSet) {<EOL>            lastStartSet = true;<EOL>            lastStart = c.textSpan.start;<EOL>        }<EOL>        else {<EOL>            if (c.textSpan.start == lastStart) {<EOL>","gt":"return null;"}
{"input":"<s> export function getClassificationsForLine(filePath: string, lineStart: number, string: string): ClassifiedSpan[] {<EOL>    const offsetForBom: number = hasBom[filePath] ? -<NUM_LIT> : <NUM_LIT>;<EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    let lineLength: number = string.length;<EOL>    let encodedClassifications: any = languageService.getEncodedSyntacticClassifications(filePath, { start: lineStart, length: lineLength });<EOL>    let classifications: ClassifiedSpan[] = unencodeClassifications(encodedClassifications);<EOL>    <EOL>    let lastStartSet: boolean = false;<EOL>    let lastStart: number = <NUM_LIT>;<EOL>    <EOL>    classifications = classifications<EOL>        .map((c: ClassifiedSpan, i: number): ClassifiedSpan => {<EOL>        <EOL>        c.textSpan.start += offsetForBom;<EOL>        <EOL>        if ((c.textSpan.start + c.textSpan.length) <= lineStart) {<EOL>            return null;<EOL>        }<EOL>        <EOL>        if (c.textSpan.start > (lineStart + lineLength)) {<EOL>            return null;<EOL>        }<EOL>        <EOL>        if (c.textSpan.start < lineStart) {<EOL>            c.textSpan.length = c.textSpan.start + c.textSpan.length - lineStart;<EOL>            c.textSpan.start = lineStart;<EOL>        }<EOL>        <EOL>        if ((c.textSpan.start + c.textSpan.length) > (lineStart + lineLength)) {<EOL>            c.textSpan.length = (lineStart + lineLength) - (c.textSpan.start);<EOL>        }<EOL>        <EOL>        if (!lastStartSet) {<EOL>            lastStartSet = true;<EOL>            lastStart = c.textSpan.start;<EOL>        }<EOL>        else {<EOL>            if (c.textSpan.start == lastStart) {<EOL>                return null;<EOL>            }<EOL>        }<EOL>","gt":"return c;"}
{"input":"<s> export function getPositionOfLineAndCharacter(filePath: string, line: number, ch: number): number {<EOL>    return languageServiceHost.getPositionOfLineAndCharacter(filePath, line,","gt":"ch);"}
{"input":"<s> <EOL>export function onlyLastCallWithDelay<T>(call: () => Promise<T>, token: monaco.CancellationToken): Promise<T> {<EOL>    let delay: number = <NUM_LIT>;<EOL>    let timeout: any;<EOL>    const p: Promise<T> = new Promise<T>((resolve: (value: T | PromiseLike<T>) => void, reject: (reason?: any) => void): void => {<EOL>        const later: () => void = (): void => {<EOL>","gt":"if (token.isCancellationRequested)"}
{"input":"<s> <EOL>export function onlyLastCallWithDelay<T>(call: () => Promise<T>, token: monaco.CancellationToken): Promise<T> {<EOL>    let delay: number = <NUM_LIT>;<EOL>    let timeout: any;<EOL>    const p: Promise<T> = new Promise<T>((resolve: (value: T | PromiseLike<T>) => void, reject: (reason?: any) => void): void => {<EOL>        const later: () => void = (): void => {<EOL>            if (token.isCancellationRequested)<EOL>                reject('<STR_LIT>');<EOL>","gt":"else {"}
{"input":"<s> <EOL>export function onlyLastCallWithDelay<T>(call: () => Promise<T>, token: monaco.CancellationToken): Promise<T> {<EOL>    let delay: number = <NUM_LIT>;<EOL>    let timeout: any;<EOL>    const p: Promise<T> = new Promise<T>((resolve: (value: T | PromiseLike<T>) => void, reject: (reason?: any) => void): void => {<EOL>        const later: () => void = (): void => {<EOL>            if (token.isCancellationRequested)<EOL>                reject('<STR_LIT>');<EOL>            else {<EOL>                call().then((res: T): void => {<EOL>                    if (token.isCancellationRequested)<EOL>                        reject('<STR_LIT>');<EOL>                    else<EOL>","gt":"resolve(res);"}
{"input":"<s> <EOL>export function onlyLastCallWithDelay<T>(call: () => Promise<T>, token: monaco.CancellationToken): Promise<T> {<EOL>    let delay: number = <NUM_LIT>;<EOL>    let timeout: any;<EOL>    const p: Promise<T> = new Promise<T>((resolve: (value: T | PromiseLike<T>) => void, reject: (reason?: any) => void): void => {<EOL>        const later: () => void = (): void => {<EOL>            if (token.isCancellationRequested)<EOL>                reject('<STR_LIT>');<EOL>            else {<EOL>                call().then((res: T): void => {<EOL>                    if (token.isCancellationRequested)<EOL>                        reject('<STR_LIT>');<EOL>                    else<EOL>                        resolve(res);<EOL>                });<EOL>            }<EOL>        };<EOL>        timeout = setTimeout(later, delay);<EOL>        token.","gt":"onCancellationRequested((): void => {"}
{"input":"<s> export function getUrlFromFilePathAndProtocol(config: {<EOL>    protocol: string;<EOL>    filePath: string;<EOL>}): string {<EOL>    return config.","gt":"protocol + '<STR_LIT>' + config.filePath;"}
{"input":"<s> <EOL>export function selectMany<T>(arr: T[][]): T[] {<EOL>    var result: any[] = [];<EOL>    for (var i: number = <NUM_LIT>; i < arr.length; i++) {<EOL>        for (var j: number = <NUM_LIT>; j < arr[i].","gt":"length; j++) {"}
{"input":"<s> <EOL>export function values<V>(dict: {<EOL>    [key: string]: V;<EOL>    [key: number]: V;<EOL>}): V[] {<EOL>    return Object.keys(dict).map((key: string): V =>","gt":"dict[key]);"}
{"input":"<s> function setErrorsInTsconfig(filePath: string, errors: types.CodeError[]): void {<EOL>    console.log(","gt":"'<STR_LIT>', errors[<NUM_LIT>].message);"}
{"input":"<s> export function getOpenFile(filePath: string): FileModel {<EOL>    if (openFiles.some((f: FileModel): boolean => f.config.filePath ==","gt":"filePath)) {"}
{"input":"<s> <EOL>export function getSetting(config: {<EOL>    sessionId: string;<EOL>    settingId: string;<EOL>}): any {<EOL>    let session: types.SessionOnDisk = getDefaultOrNewSession(","gt":"config.sessionId);"}
{"input":"<s> function writeDiskSessionFile(sessionFileContents: types.SessionsFileContents): void {<EOL>    fsu.writeFile(sessionFile, json.stringify(","gt":"sessionFileContents));"}
{"input":"<s> export function createEditorconfig(data: {}): Promise<{<EOL>    alreadyPresent: string;<EOL>}> {<EOL>    const defaultContents: string = `<STR_LIT>`.trim();<EOL>    const filePath: string = workingDir.makeAbsolute('<STR_LIT>');<EOL>    if (fsu.","gt":"existsSync(filePath)) {"}
{"input":"<s> <EOL>function transformClass(node: ts.ClassDeclaration, sourceFile: ts.SourceFile): types.DocumentedType {<EOL>    const name: any = node.name.text;<EOL>    const comment: string = getParsedComment(node, sourceFile);<EOL>    const subItems: types.DocumentedType[] = [];<EOL>    let icon: types.IconType = types.IconType.Class;<EOL>    if (node.typeParameters) {<EOL>        icon = types.","gt":"IconType.ClassGeneric;"}
{"input":"<s> <EOL>function transformClass(node: ts.ClassDeclaration, sourceFile: ts.SourceFile): types.DocumentedType {<EOL>    const name: any = node.name.text;<EOL>    const comment: string = getParsedComment(node, sourceFile);<EOL>    const subItems: types.DocumentedType[] = [];<EOL>    let icon: types.IconType = types.IconType.Class;<EOL>    if (node.typeParameters) {<EOL>        icon = types.IconType.ClassGeneric;<EOL>    }<EOL>    ts.forEachChild(node, (node: any): void => {<EOL>        if (node.","gt":"kind == ts.SyntaxKind.Constructor) {"}
{"input":"<s> <EOL>function transformClass(node: ts.ClassDeclaration, sourceFile: ts.SourceFile): types.DocumentedType {<EOL>    const name: any = node.name.text;<EOL>    const comment: string = getParsedComment(node, sourceFile);<EOL>    const subItems: types.DocumentedType[] = [];<EOL>    let icon: types.IconType = types.IconType.Class;<EOL>    if (node.typeParameters) {<EOL>        icon = types.IconType.ClassGeneric;<EOL>    }<EOL>    ts.forEachChild(node, (node: any): void => {<EOL>        if (node.kind == ts.SyntaxKind.Constructor) {<EOL>            subItems.push(transformClassConstructor(node as ts.ConstructorDeclaration, sourceFile));<EOL>        }<EOL>        if (node.kind ==","gt":"ts.SyntaxKind.PropertyDeclaration) {"}
{"input":"<s> <EOL>function transformClass(node: ts.ClassDeclaration, sourceFile: ts.SourceFile): types.DocumentedType {<EOL>    const name: any = node.name.text;<EOL>    const comment: string = getParsedComment(node, sourceFile);<EOL>    const subItems: types.DocumentedType[] = [];<EOL>    let icon: types.IconType = types.IconType.Class;<EOL>    if (node.typeParameters) {<EOL>        icon = types.IconType.ClassGeneric;<EOL>    }<EOL>    ts.forEachChild(node, (node: any): void => {<EOL>        if (node.kind == ts.SyntaxKind.Constructor) {<EOL>            subItems.push(transformClassConstructor(node as ts.ConstructorDeclaration, sourceFile));<EOL>        }<EOL>        if (node.kind == ts.SyntaxKind.PropertyDeclaration) {<EOL>            subItems.push(transformClassProperty(node as ts.PropertyDeclaration, sourceFile));<EOL>        }<EOL>","gt":"if (node.kind == ts.SyntaxKind.MethodDeclaration) {"}
{"input":"<s> <EOL>function transformModule(node: ts.ModuleDeclaration, sourceFile: ts.SourceFile): types.DocumentedType {<EOL>    <EOL>    let icon: types.IconType = types.IconType.Namespace;<EOL>    let name: any = ts.unescapeLeadingUnderscores(ts.getPropertyNameForPropertyNameNode(node.name));<EOL>    if (node.body.","gt":"kind === ts.SyntaxKind.ModuleDeclaration) {"}
{"input":"<s> <EOL>function transformModule(node: ts.ModuleDeclaration, sourceFile: ts.SourceFile): types.DocumentedType {<EOL>    <EOL>    let icon: types.IconType = types.IconType.Namespace;<EOL>    let name: any = ts.unescapeLeadingUnderscores(ts.getPropertyNameForPropertyNameNode(node.name));<EOL>    if (node.body.kind === ts.SyntaxKind.ModuleDeclaration) {<EOL>        name = name + '<STR_LIT>';<EOL>        const recurse: types.DocumentedType = transformModule(node.body as ts.ModuleDeclaration, sourceFile);<EOL>","gt":"return {"}
{"input":"<s> <EOL>function transformModule(node: ts.ModuleDeclaration, sourceFile: ts.SourceFile): types.DocumentedType {<EOL>    <EOL>    let icon: types.IconType = types.IconType.Namespace;<EOL>    let name: any = ts.unescapeLeadingUnderscores(ts.getPropertyNameForPropertyNameNode(node.name));<EOL>    if (node.body.kind === ts.SyntaxKind.ModuleDeclaration) {<EOL>        name = name + '<STR_LIT>';<EOL>        const recurse: types.DocumentedType = transformModule(node.body as ts.ModuleDeclaration, sourceFile);<EOL>        return {<EOL>            name: name + recurse.name,<EOL>            icon,<EOL>            comment: recurse.comment,<EOL>            subItems: recurse.subItems,<EOL>            location: getDocumentedTypeLocation(sourceFile, node.","gt":"name.pos),"}
{"input":"<s> <EOL>function transformModule(node: ts.ModuleDeclaration, sourceFile: ts.SourceFile): types.DocumentedType {<EOL>    <EOL>    let icon: types.IconType = types.IconType.Namespace;<EOL>    let name: any = ts.unescapeLeadingUnderscores(ts.getPropertyNameForPropertyNameNode(node.name));<EOL>    if (node.body.kind === ts.SyntaxKind.ModuleDeclaration) {<EOL>        name = name + '<STR_LIT>';<EOL>        const recurse: types.DocumentedType = transformModule(node.body as ts.ModuleDeclaration, sourceFile);<EOL>        return {<EOL>            name: name + recurse.name,<EOL>            icon,<EOL>            comment: recurse.comment,<EOL>            subItems: recurse.subItems,<EOL>            location: getDocumentedTypeLocation(sourceFile, node.name.pos),<EOL>        };<EOL>    }<EOL>    else {<EOL>","gt":"const comment: string = getParsedComment(node, sourceFile);"}
{"input":"<s> <EOL>export function getDocumentedTypeLocation(sourceFile: ts.SourceFile, position: number): types.DocumentedTypeLocation {<EOL>    <EOL>    const pos: any = ts.getLineAndCharacterOfPosition(sourceFile, position + <NUM_LIT>);<EOL>","gt":"return {"}
{"input":"<s> export function applyQuickFix(query: Types.ApplyQuickFixQuery): Promise<Types.ApplyQuickFixResponse> {<EOL>    const info: QuickFixQueryInformation = getInfoForQuickFixAnalysis(query);<EOL>    <EOL>    if (query.key.startsWith(tsCodefixPrefix)) {<EOL>        <EOL>        let project: Project = getProject(","gt":"query.filePath);"}
{"input":"<s> export function applyQuickFix(query: Types.ApplyQuickFixQuery): Promise<Types.ApplyQuickFixResponse> {<EOL>    const info: QuickFixQueryInformation = getInfoForQuickFixAnalysis(query);<EOL>    <EOL>    if (query.key.startsWith(tsCodefixPrefix)) {<EOL>        <EOL>        let project: Project = getProject(query.filePath);<EOL>        const tsCodeFixes: any = project.languageService.getCodeFixesAtPosition(query.filePath, query.position, query.position, info.positionErrors.map((e: ts.Diagnostic): any => e.code), info.formatOptions);<EOL>        const index: number = +query.key.substr(tsCodefixPrefix.length);<EOL>        const tsCodeFix:","gt":"any = tsCodeFixes[index];"}
{"input":"<s> export function applyQuickFix(query: Types.ApplyQuickFixQuery): Promise<Types.ApplyQuickFixResponse> {<EOL>    const info: QuickFixQueryInformation = getInfoForQuickFixAnalysis(query);<EOL>    <EOL>    if (query.key.startsWith(tsCodefixPrefix)) {<EOL>        <EOL>        let project: Project = getProject(query.filePath);<EOL>        const tsCodeFixes: any = project.languageService.getCodeFixesAtPosition(query.filePath, query.position, query.position, info.positionErrors.map((e: ts.Diagnostic): any => e.code), info.formatOptions);<EOL>        const index: number = +query.key.substr(tsCodefixPrefix.length);<EOL>        const tsCodeFix: any = tsCodeFixes[index];<EOL>        <EOL>        const refactorings: types.Refactoring[] = [];<EOL>        tsCodeFix.changes.","gt":"forEach((change: any): void => {"}
{"input":"<s> export function applyQuickFix(query: Types.ApplyQuickFixQuery): Promise<Types.ApplyQuickFixResponse> {<EOL>    const info: QuickFixQueryInformation = getInfoForQuickFixAnalysis(query);<EOL>    <EOL>    if (query.key.startsWith(tsCodefixPrefix)) {<EOL>        <EOL>        let project: Project = getProject(query.filePath);<EOL>        const tsCodeFixes: any = project.languageService.getCodeFixesAtPosition(query.filePath, query.position, query.position, info.positionErrors.map((e: ts.Diagnostic): any => e.code), info.formatOptions);<EOL>        const index: number = +query.key.substr(tsCodefixPrefix.length);<EOL>        const tsCodeFix: any = tsCodeFixes[index];<EOL>        <EOL>        const refactorings: types.Refactoring[] = [];<EOL>        tsCodeFix.changes.forEach((change: any): void => {<EOL>            change.textChanges.forEach((tc: any): void => {<EOL>                const res: types.Refactoring = {<EOL>","gt":"filePath: change.fileName,"}
{"input":"<s> export function getFlowRoots(query: types.TsFlowRootQuery): Promise<types.TsFlowRootResponse> {<EOL>    let project: import(\"<STR_LIT>\").Project = activeProject.GetProject.getCurrentIfAny();<EOL>    var languageService: ts.LanguageService = project.languageService;<EOL>    const filePath: string = query.filePath;<EOL>    const sourceFile: any = project.getSourceFile(query.","gt":"filePath);"}
{"input":"<s> export function getFlowRoots(query: types.TsFlowRootQuery): Promise<types.TsFlowRootResponse> {<EOL>    let project: import(\"<STR_LIT>\").Project = activeProject.GetProject.getCurrentIfAny();<EOL>    var languageService: ts.LanguageService = project.languageService;<EOL>    const filePath: string = query.filePath;<EOL>    const sourceFile: any = project.getSourceFile(query.filePath);<EOL>    const flowPoints: types.TsFlowPoint[] = [];<EOL>    let declarations: any = sourceFile.getNamedDeclarations();<EOL>    for (let","gt":"index: string in declarations) {"}
{"input":"<s> export function getFlowRoots(query: types.TsFlowRootQuery): Promise<types.TsFlowRootResponse> {<EOL>    let project: import(\"<STR_LIT>\").Project = activeProject.GetProject.getCurrentIfAny();<EOL>    var languageService: ts.LanguageService = project.languageService;<EOL>    const filePath: string = query.filePath;<EOL>    const sourceFile: any = project.getSourceFile(query.filePath);<EOL>    const flowPoints: types.TsFlowPoint[] = [];<EOL>    let declarations: any = sourceFile.getNamedDeclarations();<EOL>    for (let index: string in declarations) {<EOL>        for (let declaration: any of declarations[index]) {<EOL>            const flowPoint: types.TsFlowPoint = {<EOL>                filePath,<EOL>","gt":"from: project.languageServiceHost.getLineAndCharacterOfPosition(filePath, declaration.getStart()),"}
{"input":"<s> export function bearishspinningtop(data: StockData): any {<EOL>    return new BearishSpinningTop().hasPattern(","gt":"data);"}
{"input":"<s> export function bullish(data: StockData): any {<EOL>    return new","gt":"BullishPatterns().hasPattern(data);"}
{"input":"<s> export function darkcloudcover(data: StockData): any {<EOL>","gt":"return new DarkCloudCover().hasPattern(data);"}
{"input":"<s> export function dragonflydoji(data: StockData): any {<EOL>    return new DragonFlyDoji().hasPattern(","gt":"data);"}
{"input":"<s> export function morningstar(data: StockData): any {<EOL>    return new MorningStar().hasPattern(","gt":"data);"}
{"input":"<s> export function kst(input: KSTInput): KSTOutput[] {<EOL>    Indicator.reverseInputs(input);<EOL>    var result: KSTOutput[] = new KST(input).result;<EOL>    if (","gt":"input.reversedInput) {"}
{"input":"<s> export function format(v: number): number {<EOL>    let precision: number = getConfig('<STR_LIT>');<EOL>    if (","gt":"precision) {"}
{"input":"<s> export function adl(input: ADLInput): number[] {<EOL>    Indicator.reverseInputs(input);<EOL>    var result: any = new ADL(input).result;<EOL>    if (","gt":"input.reversedInput) {"}
{"input":"<s> export function obv(input: OBVInput): number[] {<EOL>    Indicator.reverseInputs(input);<EOL>    var result: any = new OBV(input).result;<EOL>    if (input.","gt":"reversedInput) {"}
{"input":"<s> <EOL>function processTemplate(template: string, args: any): [<EOL>    string,<EOL>    string<EOL>] {<EOL>    let statements: string = \"<STR_LIT>\";<EOL>    if (template.indexOf(\"<STR_LIT>\") > -<NUM_LIT>) {<EOL>        let statementsStartPos: number = template.indexOf(\"<STR_LIT>\");<EOL>        let statementsBodyStartPos:","gt":"number = statementsStartPos + \"<STR_LIT>\".length;"}
{"input":"<s> <EOL>function processTemplate(template: string, args: any): [<EOL>    string,<EOL>    string<EOL>] {<EOL>    let statements: string = \"<STR_LIT>\";<EOL>    if (template.indexOf(\"<STR_LIT>\") > -<NUM_LIT>) {<EOL>        let statementsStartPos: number = template.indexOf(\"<STR_LIT>\");<EOL>        let statementsBodyStartPos: number = statementsStartPos + \"<STR_LIT>\".length;<EOL>        let statementsBodyEndPos: number = template.indexOf(\"<STR_LIT>\");<EOL>        let statementsEndPos: number = statementsBodyEndPos + \"<STR_LIT>\".length;<EOL>        while (statementsStartPos > <NUM_LIT> && (template[statementsStartPos - <NUM_LIT>] == '<STR_LIT>' || template[statementsStartPos - <NUM_LIT>] == '<STR_LIT>'))<EOL>","gt":"statementsStartPos--;"}
{"input":"<s> <EOL>function processTemplate(template: string, args: any): [<EOL>    string,<EOL>    string<EOL>] {<EOL>    let statements: string = \"<STR_LIT>\";<EOL>    if (template.indexOf(\"<STR_LIT>\") > -<NUM_LIT>) {<EOL>        let statementsStartPos: number = template.indexOf(\"<STR_LIT>\");<EOL>        let statementsBodyStartPos: number = statementsStartPos + \"<STR_LIT>\".length;<EOL>        let statementsBodyEndPos: number = template.indexOf(\"<STR_LIT>\");<EOL>        let statementsEndPos: number = statementsBodyEndPos + \"<STR_LIT>\".length;<EOL>        while (statementsStartPos > <NUM_LIT> && (template[statementsStartPos - <NUM_LIT>] == '<STR_LIT>' || template[statementsStartPos - <NUM_LIT>] == '<STR_LIT>'))<EOL>            statementsStartPos--;<EOL>        if (statementsBodyEndPos > <NUM_LIT> && template[statementsBodyEndPos - <NUM_LIT>] == '<STR_LIT>')<EOL>            statementsBodyEndPos--;<EOL>        let templateText: string = template.slice(statementsBodyStartPos,","gt":"statementsBodyEndPos).replace(/\\n    /g, '<STR_LIT>');"}
{"input":"<s> <EOL>function processTemplate(template: string, args: any): [<EOL>    string,<EOL>    string<EOL>] {<EOL>    let statements: string = \"<STR_LIT>\";<EOL>    if (template.indexOf(\"<STR_LIT>\") > -<NUM_LIT>) {<EOL>        let statementsStartPos: number = template.indexOf(\"<STR_LIT>\");<EOL>        let statementsBodyStartPos: number = statementsStartPos + \"<STR_LIT>\".length;<EOL>        let statementsBodyEndPos: number = template.indexOf(\"<STR_LIT>\");<EOL>        let statementsEndPos: number = statementsBodyEndPos + \"<STR_LIT>\".length;<EOL>        while (statementsStartPos > <NUM_LIT> && (template[statementsStartPos - <NUM_LIT>] == '<STR_LIT>' || template[statementsStartPos - <NUM_LIT>] == '<STR_LIT>'))<EOL>            statementsStartPos--;<EOL>        if (statementsBodyEndPos > <NUM_LIT> && template[statementsBodyEndPos - <NUM_LIT>] == '<STR_LIT>')<EOL>            statementsBodyEndPos--;<EOL>        let templateText: string = template.slice(statementsBodyStartPos, statementsBodyEndPos).replace(/\\n    /g, '<STR_LIT>');<EOL>        let [c, s] = processTemplate(templateText, args);<EOL>        statements += s + c;<EOL>        template = template.slice(<NUM_LIT>, statementsStartPos) + template.slice(statementsEndPos);<EOL>    }<EOL>    if (typeof","gt":"args === \"<STR_LIT>\")"}
{"input":"<s> <EOL>function processTemplate(template: string, args: any): [<EOL>    string,<EOL>    string<EOL>] {<EOL>    let statements: string = \"<STR_LIT>\";<EOL>    if (template.indexOf(\"<STR_LIT>\") > -<NUM_LIT>) {<EOL>        let statementsStartPos: number = template.indexOf(\"<STR_LIT>\");<EOL>        let statementsBodyStartPos: number = statementsStartPos + \"<STR_LIT>\".length;<EOL>        let statementsBodyEndPos: number = template.indexOf(\"<STR_LIT>\");<EOL>        let statementsEndPos: number = statementsBodyEndPos + \"<STR_LIT>\".length;<EOL>        while (statementsStartPos > <NUM_LIT> && (template[statementsStartPos - <NUM_LIT>] == '<STR_LIT>' || template[statementsStartPos - <NUM_LIT>] == '<STR_LIT>'))<EOL>            statementsStartPos--;<EOL>        if (statementsBodyEndPos > <NUM_LIT> && template[statementsBodyEndPos - <NUM_LIT>] == '<STR_LIT>')<EOL>            statementsBodyEndPos--;<EOL>        let templateText: string = template.slice(statementsBodyStartPos, statementsBodyEndPos).replace(/\\n    /g, '<STR_LIT>');<EOL>        let [c, s] = processTemplate(templateText, args);<EOL>        statements += s + c;<EOL>        template = template.slice(<NUM_LIT>, statementsStartPos) + template.slice(statementsEndPos);<EOL>    }<EOL>    if (typeof args === \"<STR_LIT>\")<EOL>        return [template.replace(/{this}/g, (): string => args),","gt":"statements];"}
{"input":"<s> <EOL>function processTemplate(template: string, args: any): [<EOL>    string,<EOL>    string<EOL>] {<EOL>    let statements: string = \"<STR_LIT>\";<EOL>    if (template.indexOf(\"<STR_LIT>\") > -<NUM_LIT>) {<EOL>        let statementsStartPos: number = template.indexOf(\"<STR_LIT>\");<EOL>        let statementsBodyStartPos: number = statementsStartPos + \"<STR_LIT>\".length;<EOL>        let statementsBodyEndPos: number = template.indexOf(\"<STR_LIT>\");<EOL>        let statementsEndPos: number = statementsBodyEndPos + \"<STR_LIT>\".length;<EOL>        while (statementsStartPos > <NUM_LIT> && (template[statementsStartPos - <NUM_LIT>] == '<STR_LIT>' || template[statementsStartPos - <NUM_LIT>] == '<STR_LIT>'))<EOL>            statementsStartPos--;<EOL>        if (statementsBodyEndPos > <NUM_LIT> && template[statementsBodyEndPos - <NUM_LIT>] == '<STR_LIT>')<EOL>            statementsBodyEndPos--;<EOL>        let templateText: string = template.slice(statementsBodyStartPos, statementsBodyEndPos).replace(/\\n    /g, '<STR_LIT>');<EOL>        let [c, s] = processTemplate(templateText, args);<EOL>        statements += s + c;<EOL>        template = template.slice(<NUM_LIT>, statementsStartPos) + template.slice(statementsEndPos);<EOL>    }<EOL>    if (typeof args === \"<STR_LIT>\")<EOL>        return [template.replace(/{this}/g, (): string => args), statements];<EOL>    let ifPos: any;<EOL>    while ((ifPos = template.indexOf(\"<STR_LIT>\")) > -<NUM_LIT>) {<EOL>        let posBeforeIf: any = ifPos;<EOL>        while (posBeforeIf > <NUM_LIT> && (template[posBeforeIf - <NUM_LIT>] == '<STR_LIT>' || template[posBeforeIf - <NUM_LIT>] == '<STR_LIT>'))<EOL>            posBeforeIf--;<EOL>        ifPos += <NUM_LIT>;<EOL>        let conditionStartPos: any = ifPos;<EOL>        while (","gt":"template[ifPos] != \"<STR_LIT>\")"}
{"input":"<s> <EOL>function processTemplate(template: string, args: any): [<EOL>    string,<EOL>    string<EOL>] {<EOL>    let statements: string = \"<STR_LIT>\";<EOL>    if (template.indexOf(\"<STR_LIT>\") > -<NUM_LIT>) {<EOL>        let statementsStartPos: number = template.indexOf(\"<STR_LIT>\");<EOL>        let statementsBodyStartPos: number = statementsStartPos + \"<STR_LIT>\".length;<EOL>        let statementsBodyEndPos: number = template.indexOf(\"<STR_LIT>\");<EOL>        let statementsEndPos: number = statementsBodyEndPos + \"<STR_LIT>\".length;<EOL>        while (statementsStartPos > <NUM_LIT> && (template[statementsStartPos - <NUM_LIT>] == '<STR_LIT>' || template[statementsStartPos - <NUM_LIT>] == '<STR_LIT>'))<EOL>            statementsStartPos--;<EOL>        if (statementsBodyEndPos > <NUM_LIT> && template[statementsBodyEndPos - <NUM_LIT>] == '<STR_LIT>')<EOL>            statementsBodyEndPos--;<EOL>        let templateText: string = template.slice(statementsBodyStartPos, statementsBodyEndPos).replace(/\\n    /g, '<STR_LIT>');<EOL>        let [c, s] = processTemplate(templateText, args);<EOL>        statements += s + c;<EOL>        template = template.slice(<NUM_LIT>, statementsStartPos) + template.slice(statementsEndPos);<EOL>    }<EOL>    if (typeof args === \"<STR_LIT>\")<EOL>        return [template.replace(/{this}/g, (): string => args), statements];<EOL>    let ifPos: any;<EOL>    while ((ifPos = template.indexOf(\"<STR_LIT>\")) > -<NUM_LIT>) {<EOL>        let posBeforeIf: any = ifPos;<EOL>        while (posBeforeIf > <NUM_LIT> && (template[posBeforeIf - <NUM_LIT>] == '<STR_LIT>' || template[posBeforeIf - <NUM_LIT>] == '<STR_LIT>'))<EOL>            posBeforeIf--;<EOL>        ifPos += <NUM_LIT>;<EOL>        let conditionStartPos: any = ifPos;<EOL>        while (template[ifPos] != \"<STR_LIT>\")<EOL>            ifPos++;<EOL>","gt":"let endIfPos: number = template.indexOf(\"<STR_LIT>\", ifPos);"}
{"input":"<s> <EOL>function processTemplate(template: string, args: any): [<EOL>    string,<EOL>    string<EOL>] {<EOL>    let statements: string = \"<STR_LIT>\";<EOL>    if (template.indexOf(\"<STR_LIT>\") > -<NUM_LIT>) {<EOL>        let statementsStartPos: number = template.indexOf(\"<STR_LIT>\");<EOL>        let statementsBodyStartPos: number = statementsStartPos + \"<STR_LIT>\".length;<EOL>        let statementsBodyEndPos: number = template.indexOf(\"<STR_LIT>\");<EOL>        let statementsEndPos: number = statementsBodyEndPos + \"<STR_LIT>\".length;<EOL>        while (statementsStartPos > <NUM_LIT> && (template[statementsStartPos - <NUM_LIT>] == '<STR_LIT>' || template[statementsStartPos - <NUM_LIT>] == '<STR_LIT>'))<EOL>            statementsStartPos--;<EOL>        if (statementsBodyEndPos > <NUM_LIT> && template[statementsBodyEndPos - <NUM_LIT>] == '<STR_LIT>')<EOL>            statementsBodyEndPos--;<EOL>        let templateText: string = template.slice(statementsBodyStartPos, statementsBodyEndPos).replace(/\\n    /g, '<STR_LIT>');<EOL>        let [c, s] = processTemplate(templateText, args);<EOL>        statements += s + c;<EOL>        template = template.slice(<NUM_LIT>, statementsStartPos) + template.slice(statementsEndPos);<EOL>    }<EOL>    if (typeof args === \"<STR_LIT>\")<EOL>        return [template.replace(/{this}/g, (): string => args), statements];<EOL>    let ifPos: any;<EOL>    while ((ifPos = template.indexOf(\"<STR_LIT>\")) > -<NUM_LIT>) {<EOL>        let posBeforeIf: any = ifPos;<EOL>        while (posBeforeIf > <NUM_LIT> && (template[posBeforeIf - <NUM_LIT>] == '<STR_LIT>' || template[posBeforeIf - <NUM_LIT>] == '<STR_LIT>'))<EOL>            posBeforeIf--;<EOL>        ifPos += <NUM_LIT>;<EOL>        let conditionStartPos: any = ifPos;<EOL>        while (template[ifPos] != \"<STR_LIT>\")<EOL>            ifPos++;<EOL>        let endIfPos: number = template.indexOf(\"<STR_LIT>\", ifPos);<EOL>        let elseIfPos: number = template.indexOf(\"<STR_LIT>\", ifPos);<EOL>        let elsePos: number = template.indexOf(\"<STR_LIT>\", ifPos);<EOL>        let endIfBodyPos: number = endIfPos;<EOL>        if (elseIfPos != -<NUM_LIT> && elseIfPos < endIfBodyPos)<EOL>            endIfBodyPos = elseIfPos;<EOL>        if (elsePos != -<NUM_LIT> && elsePos < endIfBodyPos)<EOL>            endIfBodyPos = elsePos;<EOL>        if (endIfBodyPos > <NUM_LIT> && template[endIfBodyPos - <NUM_LIT>] ==","gt":"'<STR_LIT>')"}
{"input":"<s> <EOL>function processTemplate(template: string, args: any): [<EOL>    string,<EOL>    string<EOL>] {<EOL>    let statements: string = \"<STR_LIT>\";<EOL>    if (template.indexOf(\"<STR_LIT>\") > -<NUM_LIT>) {<EOL>        let statementsStartPos: number = template.indexOf(\"<STR_LIT>\");<EOL>        let statementsBodyStartPos: number = statementsStartPos + \"<STR_LIT>\".length;<EOL>        let statementsBodyEndPos: number = template.indexOf(\"<STR_LIT>\");<EOL>        let statementsEndPos: number = statementsBodyEndPos + \"<STR_LIT>\".length;<EOL>        while (statementsStartPos > <NUM_LIT> && (template[statementsStartPos - <NUM_LIT>] == '<STR_LIT>' || template[statementsStartPos - <NUM_LIT>] == '<STR_LIT>'))<EOL>            statementsStartPos--;<EOL>        if (statementsBodyEndPos > <NUM_LIT> && template[statementsBodyEndPos - <NUM_LIT>] == '<STR_LIT>')<EOL>            statementsBodyEndPos--;<EOL>        let templateText: string = template.slice(statementsBodyStartPos, statementsBodyEndPos).replace(/\\n    /g, '<STR_LIT>');<EOL>        let [c, s] = processTemplate(templateText, args);<EOL>        statements += s + c;<EOL>        template = template.slice(<NUM_LIT>, statementsStartPos) + template.slice(statementsEndPos);<EOL>    }<EOL>    if (typeof args === \"<STR_LIT>\")<EOL>        return [template.replace(/{this}/g, (): string => args), statements];<EOL>    let ifPos: any;<EOL>    while ((ifPos = template.indexOf(\"<STR_LIT>\")) > -<NUM_LIT>) {<EOL>        let posBeforeIf: any = ifPos;<EOL>        while (posBeforeIf > <NUM_LIT> && (template[posBeforeIf - <NUM_LIT>] == '<STR_LIT>' || template[posBeforeIf - <NUM_LIT>] == '<STR_LIT>'))<EOL>            posBeforeIf--;<EOL>        ifPos += <NUM_LIT>;<EOL>        let conditionStartPos: any = ifPos;<EOL>        while (template[ifPos] != \"<STR_LIT>\")<EOL>            ifPos++;<EOL>        let endIfPos: number = template.indexOf(\"<STR_LIT>\", ifPos);<EOL>        let elseIfPos: number = template.indexOf(\"<STR_LIT>\", ifPos);<EOL>        let elsePos: number = template.indexOf(\"<STR_LIT>\", ifPos);<EOL>        let endIfBodyPos: number = endIfPos;<EOL>        if (elseIfPos != -<NUM_LIT> && elseIfPos < endIfBodyPos)<EOL>            endIfBodyPos = elseIfPos;<EOL>        if (elsePos != -<NUM_LIT> && elsePos < endIfBodyPos)<EOL>            endIfBodyPos = elsePos;<EOL>        if (endIfBodyPos > <NUM_LIT> && template[endIfBodyPos - <NUM_LIT>] == '<STR_LIT>')<EOL>            endIfBodyPos--;<EOL>        let posAfterIf: number = endIfPos + <NUM_LIT>;<EOL>        if (endIfPos > <NUM_LIT> && template[endIfPos - <NUM_LIT>] == '<STR_LIT>')<EOL>            endIfPos--;<EOL>        let evalText: string = template.slice(conditionStartPos, ifPos);<EOL>        for (let k: string in args)<EOL>            evalText = evalText.replace(new RegExp(\"<STR_LIT>\" + k + \"<STR_LIT>\", \"<STR_LIT>\"), function (m) { return \"<STR_LIT>\" + m; });<EOL>        let evalResult: boolean = eval(evalText);<EOL>        if (evalResult)<EOL>            template = template.slice(<NUM_LIT>, posBeforeIf) + template.slice(ifPos + <NUM_LIT>, endIfBodyPos).replace(/\\n    /g, '<STR_LIT>') + template.slice(posAfterIf);<EOL>        else if (elseIfPos > -<NUM_LIT>)<EOL>            template = template.slice(<NUM_LIT>, posBeforeIf) +","gt":"\"<STR_LIT>\" + template.slice(elseIfPos + <NUM_LIT>);"}
{"input":"<s> <EOL>function processTemplate(template: string, args: any): [<EOL>    string,<EOL>    string<EOL>] {<EOL>    let statements: string = \"<STR_LIT>\";<EOL>    if (template.indexOf(\"<STR_LIT>\") > -<NUM_LIT>) {<EOL>        let statementsStartPos: number = template.indexOf(\"<STR_LIT>\");<EOL>        let statementsBodyStartPos: number = statementsStartPos + \"<STR_LIT>\".length;<EOL>        let statementsBodyEndPos: number = template.indexOf(\"<STR_LIT>\");<EOL>        let statementsEndPos: number = statementsBodyEndPos + \"<STR_LIT>\".length;<EOL>        while (statementsStartPos > <NUM_LIT> && (template[statementsStartPos - <NUM_LIT>] == '<STR_LIT>' || template[statementsStartPos - <NUM_LIT>] == '<STR_LIT>'))<EOL>            statementsStartPos--;<EOL>        if (statementsBodyEndPos > <NUM_LIT> && template[statementsBodyEndPos - <NUM_LIT>] == '<STR_LIT>')<EOL>            statementsBodyEndPos--;<EOL>        let templateText: string = template.slice(statementsBodyStartPos, statementsBodyEndPos).replace(/\\n    /g, '<STR_LIT>');<EOL>        let [c, s] = processTemplate(templateText, args);<EOL>        statements += s + c;<EOL>        template = template.slice(<NUM_LIT>, statementsStartPos) + template.slice(statementsEndPos);<EOL>    }<EOL>    if (typeof args === \"<STR_LIT>\")<EOL>        return [template.replace(/{this}/g, (): string => args), statements];<EOL>    let ifPos: any;<EOL>    while ((ifPos = template.indexOf(\"<STR_LIT>\")) > -<NUM_LIT>) {<EOL>        let posBeforeIf: any = ifPos;<EOL>        while (posBeforeIf > <NUM_LIT> && (template[posBeforeIf - <NUM_LIT>] == '<STR_LIT>' || template[posBeforeIf - <NUM_LIT>] == '<STR_LIT>'))<EOL>            posBeforeIf--;<EOL>        ifPos += <NUM_LIT>;<EOL>        let conditionStartPos: any = ifPos;<EOL>        while (template[ifPos] != \"<STR_LIT>\")<EOL>            ifPos++;<EOL>        let endIfPos: number = template.indexOf(\"<STR_LIT>\", ifPos);<EOL>        let elseIfPos: number = template.indexOf(\"<STR_LIT>\", ifPos);<EOL>        let elsePos: number = template.indexOf(\"<STR_LIT>\", ifPos);<EOL>        let endIfBodyPos: number = endIfPos;<EOL>        if (elseIfPos != -<NUM_LIT> && elseIfPos < endIfBodyPos)<EOL>            endIfBodyPos = elseIfPos;<EOL>        if (elsePos != -<NUM_LIT> && elsePos < endIfBodyPos)<EOL>            endIfBodyPos = elsePos;<EOL>        if (endIfBodyPos > <NUM_LIT> && template[endIfBodyPos - <NUM_LIT>] == '<STR_LIT>')<EOL>            endIfBodyPos--;<EOL>        let posAfterIf: number = endIfPos + <NUM_LIT>;<EOL>        if (endIfPos > <NUM_LIT> && template[endIfPos - <NUM_LIT>] == '<STR_LIT>')<EOL>            endIfPos--;<EOL>        let evalText: string = template.slice(conditionStartPos, ifPos);<EOL>        for (let k: string in args)<EOL>            evalText = evalText.replace(new RegExp(\"<STR_LIT>\" + k + \"<STR_LIT>\", \"<STR_LIT>\"), function (m) { return \"<STR_LIT>\" + m; });<EOL>        let evalResult: boolean = eval(evalText);<EOL>        if (evalResult)<EOL>            template = template.slice(<NUM_LIT>, posBeforeIf) + template.slice(ifPos + <NUM_LIT>, endIfBodyPos).replace(/\\n    /g, '<STR_LIT>') + template.slice(posAfterIf);<EOL>        else if (elseIfPos > -<NUM_LIT>)<EOL>            template = template.slice(<NUM_LIT>, posBeforeIf) + \"<STR_LIT>\" + template.slice(elseIfPos + <NUM_LIT>);<EOL>        else if (elsePos > -<NUM_LIT>)<EOL>            template = template.slice(<NUM_LIT>, posBeforeIf) + template.slice(elsePos + <NUM_LIT>, endIfPos).replace(/\\n    /g, '<STR_LIT>') + template.slice(posAfterIf);<EOL>        else<EOL>            template = template.slice(<NUM_LIT>, posBeforeIf) + template.slice(posAfterIf);<EOL>    }<EOL>    let replaced: boolean = false;<EOL>    for (var k: string in args) {<EOL>","gt":"if (k == \"<STR_LIT>\")"}
{"input":"<s> <EOL>function processTemplate(template: string, args: any): [<EOL>    string,<EOL>    string<EOL>] {<EOL>    let statements: string = \"<STR_LIT>\";<EOL>    if (template.indexOf(\"<STR_LIT>\") > -<NUM_LIT>) {<EOL>        let statementsStartPos: number = template.indexOf(\"<STR_LIT>\");<EOL>        let statementsBodyStartPos: number = statementsStartPos + \"<STR_LIT>\".length;<EOL>        let statementsBodyEndPos: number = template.indexOf(\"<STR_LIT>\");<EOL>        let statementsEndPos: number = statementsBodyEndPos + \"<STR_LIT>\".length;<EOL>        while (statementsStartPos > <NUM_LIT> && (template[statementsStartPos - <NUM_LIT>] == '<STR_LIT>' || template[statementsStartPos - <NUM_LIT>] == '<STR_LIT>'))<EOL>            statementsStartPos--;<EOL>        if (statementsBodyEndPos > <NUM_LIT> && template[statementsBodyEndPos - <NUM_LIT>] == '<STR_LIT>')<EOL>            statementsBodyEndPos--;<EOL>        let templateText: string = template.slice(statementsBodyStartPos, statementsBodyEndPos).replace(/\\n    /g, '<STR_LIT>');<EOL>        let [c, s] = processTemplate(templateText, args);<EOL>        statements += s + c;<EOL>        template = template.slice(<NUM_LIT>, statementsStartPos) + template.slice(statementsEndPos);<EOL>    }<EOL>    if (typeof args === \"<STR_LIT>\")<EOL>        return [template.replace(/{this}/g, (): string => args), statements];<EOL>    let ifPos: any;<EOL>    while ((ifPos = template.indexOf(\"<STR_LIT>\")) > -<NUM_LIT>) {<EOL>        let posBeforeIf: any = ifPos;<EOL>        while (posBeforeIf > <NUM_LIT> && (template[posBeforeIf - <NUM_LIT>] == '<STR_LIT>' || template[posBeforeIf - <NUM_LIT>] == '<STR_LIT>'))<EOL>            posBeforeIf--;<EOL>        ifPos += <NUM_LIT>;<EOL>        let conditionStartPos: any = ifPos;<EOL>        while (template[ifPos] != \"<STR_LIT>\")<EOL>            ifPos++;<EOL>        let endIfPos: number = template.indexOf(\"<STR_LIT>\", ifPos);<EOL>        let elseIfPos: number = template.indexOf(\"<STR_LIT>\", ifPos);<EOL>        let elsePos: number = template.indexOf(\"<STR_LIT>\", ifPos);<EOL>        let endIfBodyPos: number = endIfPos;<EOL>        if (elseIfPos != -<NUM_LIT> && elseIfPos < endIfBodyPos)<EOL>            endIfBodyPos = elseIfPos;<EOL>        if (elsePos != -<NUM_LIT> && elsePos < endIfBodyPos)<EOL>            endIfBodyPos = elsePos;<EOL>        if (endIfBodyPos > <NUM_LIT> && template[endIfBodyPos - <NUM_LIT>] == '<STR_LIT>')<EOL>            endIfBodyPos--;<EOL>        let posAfterIf: number = endIfPos + <NUM_LIT>;<EOL>        if (endIfPos > <NUM_LIT> && template[endIfPos - <NUM_LIT>] == '<STR_LIT>')<EOL>            endIfPos--;<EOL>        let evalText: string = template.slice(conditionStartPos, ifPos);<EOL>        for (let k: string in args)<EOL>            evalText = evalText.replace(new RegExp(\"<STR_LIT>\" + k + \"<STR_LIT>\", \"<STR_LIT>\"), function (m) { return \"<STR_LIT>\" + m; });<EOL>        let evalResult: boolean = eval(evalText);<EOL>        if (evalResult)<EOL>            template = template.slice(<NUM_LIT>, posBeforeIf) + template.slice(ifPos + <NUM_LIT>, endIfBodyPos).replace(/\\n    /g, '<STR_LIT>') + template.slice(posAfterIf);<EOL>        else if (elseIfPos > -<NUM_LIT>)<EOL>            template = template.slice(<NUM_LIT>, posBeforeIf) + \"<STR_LIT>\" + template.slice(elseIfPos + <NUM_LIT>);<EOL>        else if (elsePos > -<NUM_LIT>)<EOL>            template = template.slice(<NUM_LIT>, posBeforeIf) + template.slice(elsePos + <NUM_LIT>, endIfPos).replace(/\\n    /g, '<STR_LIT>') + template.slice(posAfterIf);<EOL>        else<EOL>            template = template.slice(<NUM_LIT>, posBeforeIf) + template.slice(posAfterIf);<EOL>    }<EOL>    let replaced: boolean = false;<EOL>    for (var k: string in args) {<EOL>        if (k == \"<STR_LIT>\")<EOL>            continue;<EOL>        if (args[k] && args[k].push) {<EOL>            let data: {<EOL>                template: string;<EOL>            } = { template };<EOL>            while (replaceArray(data, k, args[k], statements))<EOL>                replaced = true;<EOL>            template = data.template;<EOL>        }<EOL>","gt":"else {"}
{"input":"<s> <EOL>function processTemplate(template: string, args: any): [<EOL>    string,<EOL>    string<EOL>] {<EOL>    let statements: string = \"<STR_LIT>\";<EOL>    if (template.indexOf(\"<STR_LIT>\") > -<NUM_LIT>) {<EOL>        let statementsStartPos: number = template.indexOf(\"<STR_LIT>\");<EOL>        let statementsBodyStartPos: number = statementsStartPos + \"<STR_LIT>\".length;<EOL>        let statementsBodyEndPos: number = template.indexOf(\"<STR_LIT>\");<EOL>        let statementsEndPos: number = statementsBodyEndPos + \"<STR_LIT>\".length;<EOL>        while (statementsStartPos > <NUM_LIT> && (template[statementsStartPos - <NUM_LIT>] == '<STR_LIT>' || template[statementsStartPos - <NUM_LIT>] == '<STR_LIT>'))<EOL>            statementsStartPos--;<EOL>        if (statementsBodyEndPos > <NUM_LIT> && template[statementsBodyEndPos - <NUM_LIT>] == '<STR_LIT>')<EOL>            statementsBodyEndPos--;<EOL>        let templateText: string = template.slice(statementsBodyStartPos, statementsBodyEndPos).replace(/\\n    /g, '<STR_LIT>');<EOL>        let [c, s] = processTemplate(templateText, args);<EOL>        statements += s + c;<EOL>        template = template.slice(<NUM_LIT>, statementsStartPos) + template.slice(statementsEndPos);<EOL>    }<EOL>    if (typeof args === \"<STR_LIT>\")<EOL>        return [template.replace(/{this}/g, (): string => args), statements];<EOL>    let ifPos: any;<EOL>    while ((ifPos = template.indexOf(\"<STR_LIT>\")) > -<NUM_LIT>) {<EOL>        let posBeforeIf: any = ifPos;<EOL>        while (posBeforeIf > <NUM_LIT> && (template[posBeforeIf - <NUM_LIT>] == '<STR_LIT>' || template[posBeforeIf - <NUM_LIT>] == '<STR_LIT>'))<EOL>            posBeforeIf--;<EOL>        ifPos += <NUM_LIT>;<EOL>        let conditionStartPos: any = ifPos;<EOL>        while (template[ifPos] != \"<STR_LIT>\")<EOL>            ifPos++;<EOL>        let endIfPos: number = template.indexOf(\"<STR_LIT>\", ifPos);<EOL>        let elseIfPos: number = template.indexOf(\"<STR_LIT>\", ifPos);<EOL>        let elsePos: number = template.indexOf(\"<STR_LIT>\", ifPos);<EOL>        let endIfBodyPos: number = endIfPos;<EOL>        if (elseIfPos != -<NUM_LIT> && elseIfPos < endIfBodyPos)<EOL>            endIfBodyPos = elseIfPos;<EOL>        if (elsePos != -<NUM_LIT> && elsePos < endIfBodyPos)<EOL>            endIfBodyPos = elsePos;<EOL>        if (endIfBodyPos > <NUM_LIT> && template[endIfBodyPos - <NUM_LIT>] == '<STR_LIT>')<EOL>            endIfBodyPos--;<EOL>        let posAfterIf: number = endIfPos + <NUM_LIT>;<EOL>        if (endIfPos > <NUM_LIT> && template[endIfPos - <NUM_LIT>] == '<STR_LIT>')<EOL>            endIfPos--;<EOL>        let evalText: string = template.slice(conditionStartPos, ifPos);<EOL>        for (let k: string in args)<EOL>            evalText = evalText.replace(new RegExp(\"<STR_LIT>\" + k + \"<STR_LIT>\", \"<STR_LIT>\"), function (m) { return \"<STR_LIT>\" + m; });<EOL>        let evalResult: boolean = eval(evalText);<EOL>        if (evalResult)<EOL>            template = template.slice(<NUM_LIT>, posBeforeIf) + template.slice(ifPos + <NUM_LIT>, endIfBodyPos).replace(/\\n    /g, '<STR_LIT>') + template.slice(posAfterIf);<EOL>        else if (elseIfPos > -<NUM_LIT>)<EOL>            template = template.slice(<NUM_LIT>, posBeforeIf) + \"<STR_LIT>\" + template.slice(elseIfPos + <NUM_LIT>);<EOL>        else if (elsePos > -<NUM_LIT>)<EOL>            template = template.slice(<NUM_LIT>, posBeforeIf) + template.slice(elsePos + <NUM_LIT>, endIfPos).replace(/\\n    /g, '<STR_LIT>') + template.slice(posAfterIf);<EOL>        else<EOL>            template = template.slice(<NUM_LIT>, posBeforeIf) + template.slice(posAfterIf);<EOL>    }<EOL>    let replaced: boolean = false;<EOL>    for (var k: string in args) {<EOL>        if (k == \"<STR_LIT>\")<EOL>            continue;<EOL>        if (args[k] && args[k].push) {<EOL>            let data: {<EOL>                template: string;<EOL>            } = { template };<EOL>            while (replaceArray(data, k, args[k], statements))<EOL>                replaced = true;<EOL>            template = data.template;<EOL>        }<EOL>        else {<EOL>            let index: number = -<NUM_LIT>;<EOL>            while ((index = template.indexOf(\"<STR_LIT>\" + k + \"<STR_LIT>\")) > -<NUM_LIT>) {<EOL>                let spaces: string = '<STR_LIT>';<EOL>                while (template.length > index && template[index - <NUM_LIT>] == '<STR_LIT>') {<EOL>                    index--;<EOL>","gt":"spaces += '<STR_LIT>';"}
{"input":"<s> <EOL>function processTemplate(template: string, args: any): [<EOL>    string,<EOL>    string<EOL>] {<EOL>    let statements: string = \"<STR_LIT>\";<EOL>    if (template.indexOf(\"<STR_LIT>\") > -<NUM_LIT>) {<EOL>        let statementsStartPos: number = template.indexOf(\"<STR_LIT>\");<EOL>        let statementsBodyStartPos: number = statementsStartPos + \"<STR_LIT>\".length;<EOL>        let statementsBodyEndPos: number = template.indexOf(\"<STR_LIT>\");<EOL>        let statementsEndPos: number = statementsBodyEndPos + \"<STR_LIT>\".length;<EOL>        while (statementsStartPos > <NUM_LIT> && (template[statementsStartPos - <NUM_LIT>] == '<STR_LIT>' || template[statementsStartPos - <NUM_LIT>] == '<STR_LIT>'))<EOL>            statementsStartPos--;<EOL>        if (statementsBodyEndPos > <NUM_LIT> && template[statementsBodyEndPos - <NUM_LIT>] == '<STR_LIT>')<EOL>            statementsBodyEndPos--;<EOL>        let templateText: string = template.slice(statementsBodyStartPos, statementsBodyEndPos).replace(/\\n    /g, '<STR_LIT>');<EOL>        let [c, s] = processTemplate(templateText, args);<EOL>        statements += s + c;<EOL>        template = template.slice(<NUM_LIT>, statementsStartPos) + template.slice(statementsEndPos);<EOL>    }<EOL>    if (typeof args === \"<STR_LIT>\")<EOL>        return [template.replace(/{this}/g, (): string => args), statements];<EOL>    let ifPos: any;<EOL>    while ((ifPos = template.indexOf(\"<STR_LIT>\")) > -<NUM_LIT>) {<EOL>        let posBeforeIf: any = ifPos;<EOL>        while (posBeforeIf > <NUM_LIT> && (template[posBeforeIf - <NUM_LIT>] == '<STR_LIT>' || template[posBeforeIf - <NUM_LIT>] == '<STR_LIT>'))<EOL>            posBeforeIf--;<EOL>        ifPos += <NUM_LIT>;<EOL>        let conditionStartPos: any = ifPos;<EOL>        while (template[ifPos] != \"<STR_LIT>\")<EOL>            ifPos++;<EOL>        let endIfPos: number = template.indexOf(\"<STR_LIT>\", ifPos);<EOL>        let elseIfPos: number = template.indexOf(\"<STR_LIT>\", ifPos);<EOL>        let elsePos: number = template.indexOf(\"<STR_LIT>\", ifPos);<EOL>        let endIfBodyPos: number = endIfPos;<EOL>        if (elseIfPos != -<NUM_LIT> && elseIfPos < endIfBodyPos)<EOL>            endIfBodyPos = elseIfPos;<EOL>        if (elsePos != -<NUM_LIT> && elsePos < endIfBodyPos)<EOL>            endIfBodyPos = elsePos;<EOL>        if (endIfBodyPos > <NUM_LIT> && template[endIfBodyPos - <NUM_LIT>] == '<STR_LIT>')<EOL>            endIfBodyPos--;<EOL>        let posAfterIf: number = endIfPos + <NUM_LIT>;<EOL>        if (endIfPos > <NUM_LIT> && template[endIfPos - <NUM_LIT>] == '<STR_LIT>')<EOL>            endIfPos--;<EOL>        let evalText: string = template.slice(conditionStartPos, ifPos);<EOL>        for (let k: string in args)<EOL>            evalText = evalText.replace(new RegExp(\"<STR_LIT>\" + k + \"<STR_LIT>\", \"<STR_LIT>\"), function (m) { return \"<STR_LIT>\" + m; });<EOL>        let evalResult: boolean = eval(evalText);<EOL>        if (evalResult)<EOL>            template = template.slice(<NUM_LIT>, posBeforeIf) + template.slice(ifPos + <NUM_LIT>, endIfBodyPos).replace(/\\n    /g, '<STR_LIT>') + template.slice(posAfterIf);<EOL>        else if (elseIfPos > -<NUM_LIT>)<EOL>            template = template.slice(<NUM_LIT>, posBeforeIf) + \"<STR_LIT>\" + template.slice(elseIfPos + <NUM_LIT>);<EOL>        else if (elsePos > -<NUM_LIT>)<EOL>            template = template.slice(<NUM_LIT>, posBeforeIf) + template.slice(elsePos + <NUM_LIT>, endIfPos).replace(/\\n    /g, '<STR_LIT>') + template.slice(posAfterIf);<EOL>        else<EOL>            template = template.slice(<NUM_LIT>, posBeforeIf) + template.slice(posAfterIf);<EOL>    }<EOL>    let replaced: boolean = false;<EOL>    for (var k: string in args) {<EOL>        if (k == \"<STR_LIT>\")<EOL>            continue;<EOL>        if (args[k] && args[k].push) {<EOL>            let data: {<EOL>                template: string;<EOL>            } = { template };<EOL>            while (replaceArray(data, k, args[k], statements))<EOL>                replaced = true;<EOL>            template = data.template;<EOL>        }<EOL>        else {<EOL>            let index: number = -<NUM_LIT>;<EOL>            while ((index = template.indexOf(\"<STR_LIT>\" + k + \"<STR_LIT>\")) > -<NUM_LIT>) {<EOL>                let spaces: string = '<STR_LIT>';<EOL>                while (template.length > index && template[index - <NUM_LIT>] == '<STR_LIT>') {<EOL>                    index--;<EOL>                    spaces += '<STR_LIT>';<EOL>                }<EOL>                let value: any = args[k];<EOL>                if (value && value.resolve)<EOL>","gt":"value = value.resolve();"}
{"input":"<s> <EOL>function processTemplate(template: string, args: any): [<EOL>    string,<EOL>    string<EOL>] {<EOL>    let statements: string = \"<STR_LIT>\";<EOL>    if (template.indexOf(\"<STR_LIT>\") > -<NUM_LIT>) {<EOL>        let statementsStartPos: number = template.indexOf(\"<STR_LIT>\");<EOL>        let statementsBodyStartPos: number = statementsStartPos + \"<STR_LIT>\".length;<EOL>        let statementsBodyEndPos: number = template.indexOf(\"<STR_LIT>\");<EOL>        let statementsEndPos: number = statementsBodyEndPos + \"<STR_LIT>\".length;<EOL>        while (statementsStartPos > <NUM_LIT> && (template[statementsStartPos - <NUM_LIT>] == '<STR_LIT>' || template[statementsStartPos - <NUM_LIT>] == '<STR_LIT>'))<EOL>            statementsStartPos--;<EOL>        if (statementsBodyEndPos > <NUM_LIT> && template[statementsBodyEndPos - <NUM_LIT>] == '<STR_LIT>')<EOL>            statementsBodyEndPos--;<EOL>        let templateText: string = template.slice(statementsBodyStartPos, statementsBodyEndPos).replace(/\\n    /g, '<STR_LIT>');<EOL>        let [c, s] = processTemplate(templateText, args);<EOL>        statements += s + c;<EOL>        template = template.slice(<NUM_LIT>, statementsStartPos) + template.slice(statementsEndPos);<EOL>    }<EOL>    if (typeof args === \"<STR_LIT>\")<EOL>        return [template.replace(/{this}/g, (): string => args), statements];<EOL>    let ifPos: any;<EOL>    while ((ifPos = template.indexOf(\"<STR_LIT>\")) > -<NUM_LIT>) {<EOL>        let posBeforeIf: any = ifPos;<EOL>        while (posBeforeIf > <NUM_LIT> && (template[posBeforeIf - <NUM_LIT>] == '<STR_LIT>' || template[posBeforeIf - <NUM_LIT>] == '<STR_LIT>'))<EOL>            posBeforeIf--;<EOL>        ifPos += <NUM_LIT>;<EOL>        let conditionStartPos: any = ifPos;<EOL>        while (template[ifPos] != \"<STR_LIT>\")<EOL>            ifPos++;<EOL>        let endIfPos: number = template.indexOf(\"<STR_LIT>\", ifPos);<EOL>        let elseIfPos: number = template.indexOf(\"<STR_LIT>\", ifPos);<EOL>        let elsePos: number = template.indexOf(\"<STR_LIT>\", ifPos);<EOL>        let endIfBodyPos: number = endIfPos;<EOL>        if (elseIfPos != -<NUM_LIT> && elseIfPos < endIfBodyPos)<EOL>            endIfBodyPos = elseIfPos;<EOL>        if (elsePos != -<NUM_LIT> && elsePos < endIfBodyPos)<EOL>            endIfBodyPos = elsePos;<EOL>        if (endIfBodyPos > <NUM_LIT> && template[endIfBodyPos - <NUM_LIT>] == '<STR_LIT>')<EOL>            endIfBodyPos--;<EOL>        let posAfterIf: number = endIfPos + <NUM_LIT>;<EOL>        if (endIfPos > <NUM_LIT> && template[endIfPos - <NUM_LIT>] == '<STR_LIT>')<EOL>            endIfPos--;<EOL>        let evalText: string = template.slice(conditionStartPos, ifPos);<EOL>        for (let k: string in args)<EOL>            evalText = evalText.replace(new RegExp(\"<STR_LIT>\" + k + \"<STR_LIT>\", \"<STR_LIT>\"), function (m) { return \"<STR_LIT>\" + m; });<EOL>        let evalResult: boolean = eval(evalText);<EOL>        if (evalResult)<EOL>            template = template.slice(<NUM_LIT>, posBeforeIf) + template.slice(ifPos + <NUM_LIT>, endIfBodyPos).replace(/\\n    /g, '<STR_LIT>') + template.slice(posAfterIf);<EOL>        else if (elseIfPos > -<NUM_LIT>)<EOL>            template = template.slice(<NUM_LIT>, posBeforeIf) + \"<STR_LIT>\" + template.slice(elseIfPos + <NUM_LIT>);<EOL>        else if (elsePos > -<NUM_LIT>)<EOL>            template = template.slice(<NUM_LIT>, posBeforeIf) + template.slice(elsePos + <NUM_LIT>, endIfPos).replace(/\\n    /g, '<STR_LIT>') + template.slice(posAfterIf);<EOL>        else<EOL>            template = template.slice(<NUM_LIT>, posBeforeIf) + template.slice(posAfterIf);<EOL>    }<EOL>    let replaced: boolean = false;<EOL>    for (var k: string in args) {<EOL>        if (k == \"<STR_LIT>\")<EOL>            continue;<EOL>        if (args[k] && args[k].push) {<EOL>            let data: {<EOL>                template: string;<EOL>            } = { template };<EOL>            while (replaceArray(data, k, args[k], statements))<EOL>                replaced = true;<EOL>            template = data.template;<EOL>        }<EOL>        else {<EOL>            let index: number = -<NUM_LIT>;<EOL>            while ((index = template.indexOf(\"<STR_LIT>\" + k + \"<STR_LIT>\")) > -<NUM_LIT>) {<EOL>                let spaces: string = '<STR_LIT>';<EOL>                while (template.length > index && template[index - <NUM_LIT>] == '<STR_LIT>') {<EOL>                    index--;<EOL>                    spaces += '<STR_LIT>';<EOL>                }<EOL>                let value: any = args[k];<EOL>                if (value && value.resolve)<EOL>                    value = value.resolve();<EOL>                if (value && typeof value === '<STR_LIT>')<EOL>                    value = value.replace(","gt":"/\\n/g, '<STR_LIT>' + spaces);"}
{"input":"<s> <EOL>function processTemplate(template: string, args: any): [<EOL>    string,<EOL>    string<EOL>] {<EOL>    let statements: string = \"<STR_LIT>\";<EOL>    if (template.indexOf(\"<STR_LIT>\") > -<NUM_LIT>) {<EOL>        let statementsStartPos: number = template.indexOf(\"<STR_LIT>\");<EOL>        let statementsBodyStartPos: number = statementsStartPos + \"<STR_LIT>\".length;<EOL>        let statementsBodyEndPos: number = template.indexOf(\"<STR_LIT>\");<EOL>        let statementsEndPos: number = statementsBodyEndPos + \"<STR_LIT>\".length;<EOL>        while (statementsStartPos > <NUM_LIT> && (template[statementsStartPos - <NUM_LIT>] == '<STR_LIT>' || template[statementsStartPos - <NUM_LIT>] == '<STR_LIT>'))<EOL>            statementsStartPos--;<EOL>        if (statementsBodyEndPos > <NUM_LIT> && template[statementsBodyEndPos - <NUM_LIT>] == '<STR_LIT>')<EOL>            statementsBodyEndPos--;<EOL>        let templateText: string = template.slice(statementsBodyStartPos, statementsBodyEndPos).replace(/\\n    /g, '<STR_LIT>');<EOL>        let [c, s] = processTemplate(templateText, args);<EOL>        statements += s + c;<EOL>        template = template.slice(<NUM_LIT>, statementsStartPos) + template.slice(statementsEndPos);<EOL>    }<EOL>    if (typeof args === \"<STR_LIT>\")<EOL>        return [template.replace(/{this}/g, (): string => args), statements];<EOL>    let ifPos: any;<EOL>    while ((ifPos = template.indexOf(\"<STR_LIT>\")) > -<NUM_LIT>) {<EOL>        let posBeforeIf: any = ifPos;<EOL>        while (posBeforeIf > <NUM_LIT> && (template[posBeforeIf - <NUM_LIT>] == '<STR_LIT>' || template[posBeforeIf - <NUM_LIT>] == '<STR_LIT>'))<EOL>            posBeforeIf--;<EOL>        ifPos += <NUM_LIT>;<EOL>        let conditionStartPos: any = ifPos;<EOL>        while (template[ifPos] != \"<STR_LIT>\")<EOL>            ifPos++;<EOL>        let endIfPos: number = template.indexOf(\"<STR_LIT>\", ifPos);<EOL>        let elseIfPos: number = template.indexOf(\"<STR_LIT>\", ifPos);<EOL>        let elsePos: number = template.indexOf(\"<STR_LIT>\", ifPos);<EOL>        let endIfBodyPos: number = endIfPos;<EOL>        if (elseIfPos != -<NUM_LIT> && elseIfPos < endIfBodyPos)<EOL>            endIfBodyPos = elseIfPos;<EOL>        if (elsePos != -<NUM_LIT> && elsePos < endIfBodyPos)<EOL>            endIfBodyPos = elsePos;<EOL>        if (endIfBodyPos > <NUM_LIT> && template[endIfBodyPos - <NUM_LIT>] == '<STR_LIT>')<EOL>            endIfBodyPos--;<EOL>        let posAfterIf: number = endIfPos + <NUM_LIT>;<EOL>        if (endIfPos > <NUM_LIT> && template[endIfPos - <NUM_LIT>] == '<STR_LIT>')<EOL>            endIfPos--;<EOL>        let evalText: string = template.slice(conditionStartPos, ifPos);<EOL>        for (let k: string in args)<EOL>            evalText = evalText.replace(new RegExp(\"<STR_LIT>\" + k + \"<STR_LIT>\", \"<STR_LIT>\"), function (m) { return \"<STR_LIT>\" + m; });<EOL>        let evalResult: boolean = eval(evalText);<EOL>        if (evalResult)<EOL>            template = template.slice(<NUM_LIT>, posBeforeIf) + template.slice(ifPos + <NUM_LIT>, endIfBodyPos).replace(/\\n    /g, '<STR_LIT>') + template.slice(posAfterIf);<EOL>        else if (elseIfPos > -<NUM_LIT>)<EOL>            template = template.slice(<NUM_LIT>, posBeforeIf) + \"<STR_LIT>\" + template.slice(elseIfPos + <NUM_LIT>);<EOL>        else if (elsePos > -<NUM_LIT>)<EOL>            template = template.slice(<NUM_LIT>, posBeforeIf) + template.slice(elsePos + <NUM_LIT>, endIfPos).replace(/\\n    /g, '<STR_LIT>') + template.slice(posAfterIf);<EOL>        else<EOL>            template = template.slice(<NUM_LIT>, posBeforeIf) + template.slice(posAfterIf);<EOL>    }<EOL>    let replaced: boolean = false;<EOL>    for (var k: string in args) {<EOL>        if (k == \"<STR_LIT>\")<EOL>            continue;<EOL>        if (args[k] && args[k].push) {<EOL>            let data: {<EOL>                template: string;<EOL>            } = { template };<EOL>            while (replaceArray(data, k, args[k], statements))<EOL>                replaced = true;<EOL>            template = data.template;<EOL>        }<EOL>        else {<EOL>            let index: number = -<NUM_LIT>;<EOL>            while ((index = template.indexOf(\"<STR_LIT>\" + k + \"<STR_LIT>\")) > -<NUM_LIT>) {<EOL>                let spaces: string = '<STR_LIT>';<EOL>                while (template.length > index && template[index - <NUM_LIT>] == '<STR_LIT>') {<EOL>                    index--;<EOL>                    spaces += '<STR_LIT>';<EOL>                }<EOL>                let value: any = args[k];<EOL>                if (value && value.resolve)<EOL>                    value = value.resolve();<EOL>                if (value && typeof value === '<STR_LIT>')<EOL>                    value = value.replace(/\\n/g, '<STR_LIT>' + spaces);<EOL>                template = template.replace(\"<STR_LIT>\" +","gt":"k + \"<STR_LIT>\", (): any => value);"}
{"input":"<s> <EOL>export function getSelection(element: HTMLTextAreaElement): TextSelection {<EOL>    if (!element)<EOL>        throw Error(","gt":"\"<STR_LIT>\");"}
{"input":"<s> function compareGroups(l: ContributorGroup, r: ContributorGroup): number {<EOL>","gt":"return l.order === r.order ?"}
{"input":"<s> export function getRedirector(): FirebaseRedirector {<EOL>    return new","gt":"FirebaseRedirector(loadRedirects());"}
{"input":"<s> export default function (): Promise<any> {<EOL>    if (!ngVersionMatches('<STR_LIT>')) {<EOL>        return Promise.resolve();<EOL>    }<EOL>    return ng('<STR_LIT>', '<STR_LIT>', '<STR_LIT>',","gt":"'<STR_LIT>', '<STR_LIT>')"}
{"input":"<s> export default function (): Promise<any> {<EOL>    return Promise.resolve()<EOL>        .then((): Promise<void> => createDir('<STR_LIT>'))<EOL>        .","gt":"then((): Promise<void> => writeFile('<STR_LIT>', `<STR_LIT>`"}
{"input":"<s> export default function (): Promise<any> {<EOL>    return Promise.resolve()<EOL>        .then((): Promise<void> => createDir('<STR_LIT>'))<EOL>        .then((): Promise<void> => writeFile('<STR_LIT>', `<STR_LIT>`))<EOL>        .then((): Promise<void> => appendToFile('<STR_LIT>', '<STR_LIT>'))<EOL>        .then((): Promise<import(\"<STR_LIT>\").ProcessOutput> => ng('<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>'))<EOL>        .then((): Promise<void> => expectFileToMatch('<STR_LIT>',","gt":"/Bonjour i18n!/))"}
{"input":"<s> export default function (): Promise<any> {<EOL>    return Promise.resolve()<EOL>        .then((): Promise<void> => createDir('<STR_LIT>'))<EOL>        .then((): Promise<void> => writeFile('<STR_LIT>', `<STR_LIT>`))<EOL>        .then((): Promise<void> => appendToFile('<STR_LIT>', '<STR_LIT>'))<EOL>        .then((): Promise<import(\"<STR_LIT>\").ProcessOutput> => ng('<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>'))<EOL>        .then((): Promise<void> => expectFileToMatch('<STR_LIT>', /Bonjour i18n!/))<EOL>        .then((): Promise<import(\"<STR_LIT>\").ProcessOutput> => ng('<STR_LIT>', '<STR_LIT>'))<EOL>        .then((): Promise<any> => expectToFail((): Promise<void> => expectFileToMatch('<STR_LIT>', /Bonjour i18n!/)))<EOL>        .then((): Promise<void> => expectFileToMatch('<STR_LIT>', /Hello i18n!/))<EOL>        .then((): Promise<void> => appendToFile(","gt":"'<STR_LIT>', '<STR_LIT>'))"}
{"input":"<s> export default function (): Promise<any> {<EOL>    return Promise.resolve()<EOL>        .then((): Promise<void> => createDir('<STR_LIT>'))<EOL>        .then((): Promise<void> => writeFile('<STR_LIT>', `<STR_LIT>`))<EOL>        .then((): Promise<void> => appendToFile('<STR_LIT>', '<STR_LIT>'))<EOL>        .then((): Promise<import(\"<STR_LIT>\").ProcessOutput> => ng('<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>'))<EOL>        .then((): Promise<void> => expectFileToMatch('<STR_LIT>', /Bonjour i18n!/))<EOL>        .then((): Promise<import(\"<STR_LIT>\").ProcessOutput> => ng('<STR_LIT>', '<STR_LIT>'))<EOL>        .then((): Promise<any> => expectToFail((): Promise<void> => expectFileToMatch('<STR_LIT>', /Bonjour i18n!/)))<EOL>        .then((): Promise<void> => expectFileToMatch('<STR_LIT>', /Hello i18n!/))<EOL>        .then((): Promise<void> => appendToFile('<STR_LIT>', '<STR_LIT>'))<EOL>        .then((): Promise<any> => readFile('<STR_LIT>')<EOL>        .then((compilerCliPackage): any => {<EOL>        const version: Version = new Version(JSON.","gt":"parse(compilerCliPackage).version);"}
{"input":"<s> export default function (): Promise<any> {<EOL>    return Promise.resolve()<EOL>        .then((): Promise<void> => createDir('<STR_LIT>'))<EOL>        .then((): Promise<void> => writeFile('<STR_LIT>', `<STR_LIT>`))<EOL>        .then((): Promise<void> => appendToFile('<STR_LIT>', '<STR_LIT>'))<EOL>        .then((): Promise<import(\"<STR_LIT>\").ProcessOutput> => ng('<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>'))<EOL>        .then((): Promise<void> => expectFileToMatch('<STR_LIT>', /Bonjour i18n!/))<EOL>        .then((): Promise<import(\"<STR_LIT>\").ProcessOutput> => ng('<STR_LIT>', '<STR_LIT>'))<EOL>        .then((): Promise<any> => expectToFail((): Promise<void> => expectFileToMatch('<STR_LIT>', /Bonjour i18n!/)))<EOL>        .then((): Promise<void> => expectFileToMatch('<STR_LIT>', /Hello i18n!/))<EOL>        .then((): Promise<void> => appendToFile('<STR_LIT>', '<STR_LIT>'))<EOL>        .then((): Promise<any> => readFile('<STR_LIT>')<EOL>        .then((compilerCliPackage): any => {<EOL>        const version: Version = new Version(JSON.parse(compilerCliPackage).version);<EOL>        if (version.major === <NUM_LIT>) {<EOL>            return expectToFail((): Promise<import(\"<STR_LIT>\").ProcessOutput> => ng('<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>'));<EOL>        }<EOL>        else {<EOL>            return ng('<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>')<EOL>                .then((): Promise<void> => expectFileToMatch('<STR_LIT>', /Other content/));<EOL>        }<EOL>    }))<EOL>        .then((): Promise<any> => readFile('<STR_LIT>')<EOL>        .then((compilerCliPackage): any => {<EOL>        const version:","gt":"Version = new Version(JSON.parse(compilerCliPackage).version);"}
{"input":"<s> function generateFileHashMap(): Map<string, string> {<EOL>    const hashes: Map<string, string> = new Map<string, string>();<EOL>    fs.readdirSync('<STR_LIT>')<EOL>        .forEach((name: any): void => {<EOL>        if (!name.","gt":"match(OUTPUT_RE)) {"}
{"input":"<s> function generateFileHashMap(): Map<string, string> {<EOL>    const hashes: Map<string, string> = new Map<string, string>();<EOL>    fs.readdirSync('<STR_LIT>')<EOL>        .forEach((name: any): void => {<EOL>        if (!name.match(OUTPUT_RE)) {<EOL>            return;<EOL>        }<EOL>        const [module, hash] = name.split('<STR_LIT>');<EOL>","gt":"hashes.set(module, hash);"}
{"input":"<s> export default function (): Promise<void> {<EOL>    return Promise.resolve()<EOL>        .then((): Promise<void[]> => writeMultipleFiles({<EOL>        '<STR_LIT>': '<STR_LIT>',<EOL>","gt":"'<STR_LIT>': '<STR_LIT>',"}
{"input":"<s> export default function (): Promise<void> {<EOL>    return Promise.resolve()<EOL>        .then((): Promise<void[]> => writeMultipleFiles({<EOL>        '<STR_LIT>': '<STR_LIT>',<EOL>        '<STR_LIT>': '<STR_LIT>',<EOL>        '<STR_LIT>': '<STR_LIT>',<EOL>","gt":"'<STR_LIT>': '<STR_LIT>',"}
{"input":"<s> export default function (): Promise<void> {<EOL>    return Promise.resolve()<EOL>        .then((): Promise<void[]> => writeMultipleFiles({<EOL>        '<STR_LIT>': '<STR_LIT>',<EOL>        '<STR_LIT>': '<STR_LIT>',<EOL>        '<STR_LIT>': '<STR_LIT>',<EOL>        '<STR_LIT>': '<STR_LIT>',<EOL>        '<STR_LIT>':","gt":"'<STR_LIT>'"}
{"input":"<s> export default function (): Promise<void> {<EOL>    return Promise.resolve()<EOL>        .then((): Promise<void[]> => writeMultipleFiles({<EOL>        '<STR_LIT>': '<STR_LIT>',<EOL>        '<STR_LIT>': '<STR_LIT>',<EOL>        '<STR_LIT>': '<STR_LIT>',<EOL>        '<STR_LIT>': '<STR_LIT>',<EOL>        '<STR_LIT>': '<STR_LIT>'<EOL>    }))<EOL>        .then((): Promise<void> => updateJsonFile('<STR_LIT>', (configJson: any): void => {<EOL>        const app: any = configJson['<STR_LIT>'][<NUM_LIT>];<EOL>        app['<STR_LIT>'] = [<EOL>            '<STR_LIT>',<EOL>            { input: '<STR_LIT>' },<EOL>            {","gt":"input: '<STR_LIT>', lazy: true },"}
{"input":"<s> export default function (): Promise<void> {<EOL>    return Promise.resolve()<EOL>        .then((): Promise<void[]> => writeMultipleFiles({<EOL>        '<STR_LIT>': '<STR_LIT>',<EOL>        '<STR_LIT>': '<STR_LIT>',<EOL>        '<STR_LIT>': '<STR_LIT>',<EOL>        '<STR_LIT>': '<STR_LIT>',<EOL>        '<STR_LIT>': '<STR_LIT>'<EOL>    }))<EOL>        .then((): Promise<void> => updateJsonFile('<STR_LIT>', (configJson: any): void => {<EOL>        const app: any = configJson['<STR_LIT>'][<NUM_LIT>];<EOL>        app['<STR_LIT>'] = [<EOL>            '<STR_LIT>',<EOL>            { input: '<STR_LIT>' },<EOL>            { input: '<STR_LIT>', lazy: true },<EOL>            { input: '<STR_LIT>', output: '<STR_LIT>' },<EOL>            { input: '<STR_LIT>', output: '<STR_LIT>', lazy: true }<EOL>        ];<EOL>    }))<EOL>        .then((): Promise<import(\"<STR_LIT>\").ProcessOutput> => ng('<STR_LIT>', '<STR_LIT>'))<EOL>        <EOL>        .then((): Promise<void> => expectFileToMatch('<STR_LIT>', '<STR_LIT>'))<EOL>        .then((): Promise<void> => expectFileToMatch('<STR_LIT>', '<STR_LIT>'))<EOL>        .then((): Promise<void> => expectFileToMatch('<STR_LIT>', '<STR_LIT>'))<EOL>        .then((): Promise<void> => expectFileToMatch(","gt":"'<STR_LIT>', '<STR_LIT>'))"}
{"input":"<s> export default function (): Promise<void> {<EOL>    return Promise.resolve()<EOL>        .then((): Promise<void[]> => writeMultipleFiles({<EOL>        '<STR_LIT>': '<STR_LIT>',<EOL>        '<STR_LIT>': '<STR_LIT>',<EOL>        '<STR_LIT>': '<STR_LIT>',<EOL>        '<STR_LIT>': '<STR_LIT>',<EOL>        '<STR_LIT>': '<STR_LIT>'<EOL>    }))<EOL>        .then((): Promise<void> => updateJsonFile('<STR_LIT>', (configJson: any): void => {<EOL>        const app: any = configJson['<STR_LIT>'][<NUM_LIT>];<EOL>        app['<STR_LIT>'] = [<EOL>            '<STR_LIT>',<EOL>            { input: '<STR_LIT>' },<EOL>            { input: '<STR_LIT>', lazy: true },<EOL>            { input: '<STR_LIT>', output: '<STR_LIT>' },<EOL>            { input: '<STR_LIT>', output: '<STR_LIT>', lazy: true }<EOL>        ];<EOL>    }))<EOL>        .then((): Promise<import(\"<STR_LIT>\").ProcessOutput> => ng('<STR_LIT>', '<STR_LIT>'))<EOL>        <EOL>        .then((): Promise<void> => expectFileToMatch('<STR_LIT>', '<STR_LIT>'))<EOL>        .then((): Promise<void> => expectFileToMatch('<STR_LIT>', '<STR_LIT>'))<EOL>        .then((): Promise<void> => expectFileToMatch('<STR_LIT>', '<STR_LIT>'))<EOL>        .then((): Promise<void> => expectFileToMatch('<STR_LIT>', '<STR_LIT>'))<EOL>        .then((): Promise<void> => expectFileToMatch('<STR_LIT>', '<STR_LIT>'))<EOL>        <EOL>        .then((): Promise<any> => expectToFail((): Promise<unknown> => expectFileToExist('<STR_LIT>')))<EOL>        .then((): Promise<any> => expectToFail((): Promise<unknown> => expectFileToExist('<STR_LIT>')))<EOL>        .then((): Promise<any> => expectToFail((): Promise<unknown> => expectFileToExist('<STR_LIT>')))<EOL>        .then((): Promise<any> => expectToFail((): Promise<unknown> => expectFileToExist('<STR_LIT>')))<EOL>        <EOL>        .then((): Promise<void> => expectFileToMatch('<STR_LIT>', new RegExp(oneLineTrim `<STR_LIT>`)))<EOL>        .then((): Promise<void> =>","gt":"expectFileToMatch('<STR_LIT>', oneLineTrim `<STR_LIT>`"}
{"input":"<s> export default function (): Promise<import(\"<STR_LIT>\").ProcessOutput> {<EOL>    return Promise.resolve()<EOL>        .then((): Promise<import(\"<STR_LIT>\").ProcessOutput> => silentNg(","gt":"'<STR_LIT>'))"}
{"input":"<s> export default function (): Promise<import(\"<STR_LIT>\").ProcessOutput> {<EOL>    return Promise.resolve()<EOL>        .then((): Promise<import(\"<STR_LIT>\").ProcessOutput> => createProject(","gt":"'<STR_LIT>', '<STR_LIT>'))"}
{"input":"<s> export default function (): Promise<import(\"<STR_LIT>\").ProcessOutput> {<EOL>    const directiveDir: any = join('<STR_LIT>', '<STR_LIT>');<EOL>    return Promise.resolve()<EOL>        .then((): Promise<void> => updateJsonFile('<STR_LIT>', (configJson: any): void => {<EOL>        const app: any = configJson['<STR_LIT>'][","gt":"<NUM_LIT>];"}
{"input":"<s> export default function (): Promise<import(\"<STR_LIT>\").ProcessOutput> {<EOL>    const directiveDir: any = join('<STR_LIT>', '<STR_LIT>');<EOL>    return Promise.resolve()<EOL>        .then((): Promise<void> => updateJsonFile('<STR_LIT>', (configJson: any): void => {<EOL>        const app: any = configJson['<STR_LIT>'][<NUM_LIT>];<EOL>        app['<STR_LIT>'] = '<STR_LIT>';<EOL>    }))<EOL>        .then((): Promise<import(\"<STR_LIT>\").ProcessOutput> => ng('<STR_LIT>', '<STR_LIT>', '<STR_LIT>'))<EOL>        .then((): Promise<void> => expectFileToMatch(join(","gt":"directiveDir, '<STR_LIT>'), /selector: '\\[pre/))"}
{"input":"<s> export default function (): Promise<import(\"<STR_LIT>\").ProcessOutput> {<EOL>    const root: any = process.cwd();<EOL>    const testPath: any = join(root, '<STR_LIT>', '<STR_LIT>');<EOL>    process.chdir(testPath);<EOL>    fs.","gt":"mkdirSync('<STR_LIT>');"}
{"input":"<s> export default function (): Promise<import(\"<STR_LIT>\").ProcessOutput> {<EOL>    const root: any = process.cwd();<EOL>    const testPath: any = join(root, '<STR_LIT>', '<STR_LIT>');<EOL>    process.chdir(testPath);<EOL>    fs.mkdirSync('<STR_LIT>');<EOL>    return Promise.resolve()<EOL>        .then((): Promise<import(\"<STR_LIT>\").ProcessOutput> => ng('<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>')<EOL>        .then((): Promise<unknown> => expectFileToExist(join(testPath, '<STR_LIT>')))<EOL>        .then((): Promise<unknown> => expectFileToExist(join(testPath, '<STR_LIT>', '<STR_LIT>')))<EOL>        .then((): Promise<unknown> => expectFileToExist(join(testPath, '<STR_LIT>', '<STR_LIT>')))<EOL>        .then((): Promise<any> => expectToFail((): Promise<unknown> => expectFileToExist(join(testPath,","gt":"'<STR_LIT>', '<STR_LIT>'))))"}
{"input":"<s> export function appendToFile(filePath: string, text: string, options?: any): Promise<void> {<EOL>    return","gt":"readFile(filePath)"}
{"input":"<s> export function symlinkFile(from: string, to: string, type?: string): Promise<void> {<EOL>    return new Promise<void>((resolve: (value: void | PromiseLike<void>) => void, reject: (reason?: any) => void): void => {<EOL>        fs.symlink(from, to, type, (err: any): void => {<EOL>            if (err) {<EOL>                reject(","gt":"err);"}
{"input":"<s> export function teardown(path: string): any {<EOL>    process.chdir(root);<EOL>    if (fs.pathExistsSync(path)) {<EOL>","gt":"return fs.remove(path);"}
{"input":"<s> export function initWebWorkerRenderPlatform(): void {<EOL>","gt":"BrowserDomAdapter.makeCurrent();"}
{"input":"<s> export function getStartAtObservable(query: Query): Observable<Primitive> {<EOL>    if (query.startAt instanceof Observable) {<EOL>        return query.startAt;<EOL>    }<EOL>    else if (hasKey(","gt":"query, '<STR_LIT>')) {"}
{"input":"<s> export function getStartAtObservable(query: Query): Observable<Primitive> {<EOL>    if (query.startAt instanceof Observable) {<EOL>        return query.startAt;<EOL>    }<EOL>    else if (hasKey(query, '<STR_LIT>')) {<EOL>        return new Observable<Primitive>((subscriber: any): void => {<EOL>            subscriber.next(query.startAt);<EOL>        });<EOL>    }<EOL>    else {<EOL>        return new","gt":"Observable<Primitive>((subscriber: any): void => {"}
{"input":"<s> export function stripLeadingSlash(value: string): string {<EOL>    <EOL>    if (value.substring(<NUM_LIT>, <NUM_LIT>) === '<STR_LIT>') {<EOL>        return","gt":"value.substring(<NUM_LIT>, value.length);"}
{"input":"<s> export function stripTrailingSlash(value: string): string {<EOL>    <EOL>    if (value.substring(value.length - <NUM_LIT>, value.length) === '<STR_LIT>') {<EOL>        return value.substring(<NUM_LIT>, value.","gt":"length - <NUM_LIT>);"}
{"input":"<s> function positionAfter(changes: SnapshotAction[], prevKey?: string): number {<EOL>    if (isNil(prevKey)) {<EOL>        return <NUM_LIT>;<EOL>    }<EOL>","gt":"else {"}
{"input":"<s> function positionAfter(changes: SnapshotAction[], prevKey?: string): number {<EOL>    if (isNil(prevKey)) {<EOL>        return <NUM_LIT>;<EOL>    }<EOL>    else {<EOL>        const i: number = positionFor(changes, prevKey);<EOL>        if (i === -<NUM_LIT>) {<EOL>            return changes.length;<EOL>        }<EOL>        else {<EOL>            return i +","gt":"<NUM_LIT>;"}
{"input":"<s> <EOL>export function associateQuery(collectionRef: CollectionReference, queryFn = (ref: any): any => ref): AssociatedReference {<EOL>","gt":"const query: any = queryFn(collectionRef);"}
{"input":"<s> export function _getAngularFireStorage(app: FirebaseApp): AngularFireStorage {<EOL>    return new AngularFireStorage(","gt":"app);"}
{"input":"<s> function init(): void {<EOL>    const rootEl: Element = document.querySelector('<STR_LIT>');<EOL>    rootEl.textContent = '<STR_LIT>';<EOL>    table =","gt":"new TableComponent(rootEl);"}
{"input":"<s> function _buildTree(currDepth: number, valueFn: (depth: number) => string): TreeNode {<EOL>","gt":"const children: TreeNode = currDepth < maxDepth ? _buildTree(currDepth + <NUM_LIT>, valueFn) : null;"}
{"input":"<s> function getComponentText(selector: string, innerSelector: string): any {<EOL>    return","gt":"browser.executeScript(`<STR_LIT>`);"}
{"input":"<s> export function main(): void {<EOL>    bootstrapWorkerUi(","gt":"'<STR_LIT>').then(afterBootstrap);"}
{"input":"<s> export function main(): void {<EOL>    platformBrowserDynamic().","gt":"bootstrapModule(ExampleModule);"}
{"input":"<s> function normalizeParams(obj: {<EOL>    [key: string]: any;<EOL>} | any): {<EOL>    [key: string]: any;<EOL>} | null {<EOL>    return obj ? copyObj(","gt":"obj) : null;"}
{"input":"<s> function countChars(value: string, char: string): number {<EOL>    let count: number = <NUM_LIT>;<EOL>    for (let i: number = <NUM_LIT>; i < value.length; i++) {<EOL>        const c: string = value.charAt(","gt":"i);"}
{"input":"<s> export function listenOnPlayer(player: AnimationPlayer, eventName: string, event: AnimationEvent | undefined, callback: (event: any) => any): void {<EOL>    switch (eventName) {<EOL>        case '<STR_LIT>':<EOL>            player.onStart((): any => callback(event && copyAnimationEvent(event, '<STR_LIT>', player)));<EOL>","gt":"break;"}
{"input":"<s> export function listenOnPlayer(player: AnimationPlayer, eventName: string, event: AnimationEvent | undefined, callback: (event: any) => any): void {<EOL>    switch (eventName) {<EOL>        case '<STR_LIT>':<EOL>            player.onStart((): any => callback(event && copyAnimationEvent(event, '<STR_LIT>', player)));<EOL>            break;<EOL>        case '<STR_LIT>':<EOL>            player.onDone((): any => callback(event && copyAnimationEvent(event, '<STR_LIT>', player)));<EOL>            break;<EOL>        case '<STR_LIT>':<EOL>            player.onDestroy((): any => callback(event && copyAnimationEvent(event,","gt":"'<STR_LIT>', player)));"}
{"input":"<s> function _flattenGroupPlayersRecur(players: AnimationPlayer[], finalPlayers: AnimationPlayer[]): void {<EOL>    for (let i: number = <NUM_LIT>; i < players.length; i++) {<EOL>        const player: AnimationPlayer = players[i];<EOL>","gt":"if (player instanceof AnimationGroupPlayer) {"}
{"input":"<s> function listen(element: any, engine: TransitionAnimationEngine, eventName: string, phaseName: string, callback: (event: any) => any, id: string = DEFAULT_NAMESPACE_ID): () => any {<EOL>    return engine.","gt":"listen(id, element, eventName, phaseName, callback);"}
{"input":"<s> function mv(runIndex: number, time: number, values: {<EOL>    [key: string]: number;<EOL>}): MeasureValues {<EOL>    return new MeasureValues(runIndex, new Date(time),","gt":"values);"}
{"input":"<s> function padNumber(num: number, digits: number, minusSign = '<STR_LIT>', trim?: boolean, negWrap?: boolean): string {<EOL>    let neg: string = '<STR_LIT>';<EOL>    if (num < <NUM_LIT> || (negWrap && num <= <NUM_LIT>)) {<EOL>        if (negWrap) {<EOL>            num = -num + <NUM_LIT>;<EOL>        }<EOL>","gt":"else {"}
{"input":"<s> function datePartGetterFactory(ret: Intl.DateTimeFormatOptions): DateFormatterFn {<EOL>    return (date: Date, locale: string): string => intlDateFormat(date, locale,","gt":"ret);"}
{"input":"<s> function formatNumber(pipe: Type<any>, locale: string, value: number | string, style: NumberFormatStyle, digits?: string | null, currency: string | null = null, currencyAsSymbol: boolean = false): string | null {<EOL>    if (value == null)<EOL>        return null;<EOL>    <EOL>    value = typeof value === '<STR_LIT>' && !isNaN(+value -","gt":"parseFloat(value)) ? +value : value;"}
{"input":"<s> function formatNumber(pipe: Type<any>, locale: string, value: number | string, style: NumberFormatStyle, digits?: string | null, currency: string | null = null, currencyAsSymbol: boolean = false): string | null {<EOL>    if (value == null)<EOL>        return null;<EOL>    <EOL>    value = typeof value === '<STR_LIT>' && !isNaN(+value - parseFloat(value)) ? +value : value;<EOL>    if (","gt":"typeof value !== '<STR_LIT>') {"}
{"input":"<s> function formatNumber(pipe: Type<any>, locale: string, value: number | string, style: NumberFormatStyle, digits?: string | null, currency: string | null = null, currencyAsSymbol: boolean = false): string | null {<EOL>    if (value == null)<EOL>        return null;<EOL>    <EOL>    value = typeof value === '<STR_LIT>' && !isNaN(+value - parseFloat(value)) ? +value : value;<EOL>    if (typeof value !== '<STR_LIT>') {<EOL>        throw invalidPipeArgumentError(pipe, value);<EOL>    }<EOL>    let minInt: number | undefined;<EOL>    let minFraction: number | undefined;<EOL>    let maxFraction: number | undefined;<EOL>    if (style !== NumberFormatStyle.Currency) {<EOL>        <EOL>        minInt = <NUM_LIT>;<EOL>        minFraction = <NUM_LIT>;<EOL>        maxFraction = <NUM_LIT>;<EOL>    }<EOL>    if (digits) {<EOL>        const parts: RegExpMatchArray | null = digits.match(NUMBER_FORMAT_REGEXP);<EOL>        if (parts === null) {<EOL>            throw new Error(`<STR_LIT>`);<EOL>        }<EOL>        if (parts[<NUM_LIT>] != null) { <EOL>            minInt = parseIntAutoRadix(parts[<NUM_LIT>]);<EOL>        }<EOL>        if (parts[<NUM_LIT>] != null) { <EOL>            minFraction = parseIntAutoRadix(parts[<NUM_LIT>]);<EOL>        }<EOL>        if (parts[<NUM_LIT>] != null) { <EOL>","gt":"maxFraction = parseIntAutoRadix(parts[<NUM_LIT>]);"}
{"input":"<s> function createTestComponent(template: string): ComponentFixture<TestComponent> {<EOL>    return TestBed.","gt":"overrideComponent(TestComponent, { set: { template: template } })"}
{"input":"<s> export function getExpressionDiagnostics(scope: SymbolTable, ast: AST, query: SymbolQuery, context: ExpressionDiagnosticsContext = {}): TypeDiagnostic[] {<EOL>    const analyzer: AstType = new","gt":"AstType(scope, query, context);"}
{"input":"<s> function expandedMessage(error: any): string {<EOL>    switch (error.message) {<EOL>        case '<STR_LIT>':<EOL>            if (error.context && error.context.className) {<EOL>                return `<STR_LIT>`;<EOL>            }<EOL>            break;<EOL>        case '<STR_LIT>':<EOL>","gt":"return '<STR_LIT>';"}
{"input":"<s> function expandedMessage(error: any): string {<EOL>    switch (error.message) {<EOL>        case '<STR_LIT>':<EOL>            if (error.context && error.context.className) {<EOL>                return `<STR_LIT>`;<EOL>            }<EOL>            break;<EOL>        case '<STR_LIT>':<EOL>            return '<STR_LIT>';<EOL>        case '<STR_LIT>':<EOL>            return '<STR_LIT>';<EOL>        case","gt":"'<STR_LIT>':"}
{"input":"<s> function expandedMessage(error: any): string {<EOL>    switch (error.message) {<EOL>        case '<STR_LIT>':<EOL>            if (error.context && error.context.className) {<EOL>                return `<STR_LIT>`;<EOL>            }<EOL>            break;<EOL>        case '<STR_LIT>':<EOL>            return '<STR_LIT>';<EOL>        case '<STR_LIT>':<EOL>            return '<STR_LIT>';<EOL>        case '<STR_LIT>':<EOL>            if (error.context && error.context.typeName) {<EOL>                return `<STR_LIT>`;<EOL>            }<EOL>            break;<EOL>        case '<STR_LIT>':<EOL>            let prefix: string = error.context && error.context.name ? `<STR_LIT>` : '<STR_LIT>';<EOL>            return prefix +<EOL>","gt":"'<STR_LIT>';"}
{"input":"<s> function populateBuiltins(symbols: Map<string, MetadataValue>): void {<EOL>    <EOL>    ['<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>',<EOL>        '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>',","gt":"'<STR_LIT>',"}
{"input":"<s> function dotRelative(from: string, to: string): string {<EOL>    const rPath:","gt":"string = path.relative(from, to).replace(/\\\\/g, '<STR_LIT>');"}
{"input":"<s> function calcRootPath(): any {<EOL>    const moduleFilename:","gt":"any = module.filename.replace(/\\\\/g, '<STR_LIT>');"}
{"input":"<s> export function isFormattedError(error: Error): error is FormattedError {<EOL>    return !!(error as any)[","gt":"FORMATTED_MESSAGE];"}
{"input":"<s> export function deserializeSummaries(symbolCache: StaticSymbolCache, summaryResolver: SummaryResolver<StaticSymbol>, libraryFileName: string, json: string): {<EOL>    moduleName: string | null;<EOL>    summaries: Summary<StaticSymbol>[];<EOL>    importAs: {<EOL>        symbol: StaticSymbol;<EOL>        importAs: StaticSymbol;<EOL>    }[];<EOL>} {<EOL>    const deserializer:","gt":"FromJsonDeserializer = new FromJsonDeserializer(symbolCache, summaryResolver);"}
{"input":"<s> export function ngfactoryFilePath(filePath: string, forceSourceFile = false): string {<EOL>","gt":"const urlWithSuffix: string[] = splitTypescriptSuffix(filePath, forceSourceFile);"}
{"input":"<s> function invalid<T>(arg: o.Expression | o.Statement): never {<EOL>    throw new Error(","gt":"constructor.name} doesn'<STR_LIT>;"}
{"input":"<s> function byteStringToHexString(str: string): string {<EOL>    let hex: string = '<STR_LIT>';<EOL>    for (let","gt":"i: number = <NUM_LIT>; i < str.length; i++) {"}
{"input":"<s> <EOL>export function fingerprint(str: string): [<EOL>    number,<EOL>    number<EOL>] {<EOL>    const utf8: string = utf8Encode(str);<EOL>    let [hi, lo] = [hash32(utf8, <NUM_LIT>), hash32(utf8, <NUM_LIT>)];<EOL>    if (hi == <NUM_LIT> && (lo ==","gt":"<NUM_LIT> || lo == <NUM_LIT>)) {"}
{"input":"<s> function _isOpeningComment(n: html.Node): boolean {<EOL>    return !!(n instanceof html.Comment && n.value && n.","gt":"value.startsWith('<STR_LIT>'));"}
{"input":"<s> function spanOf(ast: Node): {<EOL>    start: number;<EOL>    end: number;<EOL>} {<EOL>    const start: number = ast.sourceSpan.start.offset;<EOL>    let end: number = ast.sourceSpan.end.offset;<EOL>    if (ast instanceof Element) {<EOL>        if (","gt":"ast.endSourceSpan) {"}
{"input":"<s> function toUpperCaseCharCode(code: number): number {<EOL>    return code >= chars.$a && code <= chars.","gt":"$z ? code - chars.$a + chars.$A : code;"}
{"input":"<s> function _resolveProvidersFromDirectives(directives: CompileDirectiveSummary[], sourceSpan: ParseSourceSpan, targetErrors: ParseError[]): Map<any, ProviderAst> {<EOL>    const providersByToken: Map<any, ProviderAst> = new Map<any, ProviderAst>();<EOL>    directives.forEach((directive: CompileDirectiveSummary): void => {<EOL>        const dirProvider: CompileProviderMetadata = { token: { identifier: directive.type }, useClass: directive.type };<EOL>        _resolveProviders([dirProvider], directive.isComponent ?","gt":"ProviderAstType.Component : ProviderAstType.Directive, true, sourceSpan, targetErrors, providersByToken,  false);"}
{"input":"<s> function _resolveProvidersFromDirectives(directives: CompileDirectiveSummary[], sourceSpan: ParseSourceSpan, targetErrors: ParseError[]): Map<any, ProviderAst> {<EOL>    const providersByToken: Map<any, ProviderAst> = new Map<any, ProviderAst>();<EOL>    directives.forEach((directive: CompileDirectiveSummary): void => {<EOL>        const dirProvider: CompileProviderMetadata = { token: { identifier: directive.type }, useClass: directive.type };<EOL>        _resolveProviders([dirProvider], directive.isComponent ? ProviderAstType.Component : ProviderAstType.Directive, true, sourceSpan, targetErrors, providersByToken, false);<EOL>    });<EOL>    <EOL>    const directivesWithComponentFirst: CompileDirectiveSummary[] = directives.filter((dir: CompileDirectiveSummary): boolean => dir.isComponent).concat(directives.filter((dir: CompileDirectiveSummary): boolean => !dir.isComponent));<EOL>    directivesWithComponentFirst.forEach((directive: CompileDirectiveSummary): void => {<EOL>        _resolveProviders(directive.providers, ProviderAstType.PublicService, false, sourceSpan, targetErrors, providersByToken, false);<EOL>        _resolveProviders(directive.viewProviders, ProviderAstType.PrivateService, false, sourceSpan, targetErrors, providersByToken,","gt":"false);"}
{"input":"<s> export function processRules(input: string, ruleCallback: (rule: CssRule) => CssRule): string {<EOL>    const inputWithEscapedBlocks: StringWithEscapedBlocks = escapeBlocks(input);<EOL>    let nextBlockIndex: number = <NUM_LIT>;<EOL>    return inputWithEscapedBlocks.escapedString.replace(_ruleRe, function (...m: string[]) {<EOL>        const selector: string = m[<NUM_LIT>];<EOL>        let content:","gt":"string = '<STR_LIT>';"}
{"input":"<s> export function processRules(input: string, ruleCallback: (rule: CssRule) => CssRule): string {<EOL>    const inputWithEscapedBlocks: StringWithEscapedBlocks = escapeBlocks(input);<EOL>    let nextBlockIndex: number = <NUM_LIT>;<EOL>    return inputWithEscapedBlocks.escapedString.replace(_ruleRe, function (...m: string[]) {<EOL>        const selector: string = m[<NUM_LIT>];<EOL>        let content: string = '<STR_LIT>';<EOL>        let suffix: string = m[<NUM_LIT>];<EOL>        let contentPrefix: string = '<STR_LIT>';<EOL>        if (suffix && suffix.startsWith('<STR_LIT>' + BLOCK_PLACEHOLDER)) {<EOL>            content = inputWithEscapedBlocks.","gt":"blocks[nextBlockIndex++];"}
{"input":"<s> function _isAnimationLabel(name: string): boolean {<EOL>","gt":"return name[<NUM_LIT>] == '<STR_LIT>';"}
{"input":"<s> <EOL>function splitExportAs(exportAs: string | null): string[] {<EOL>    return exportAs ? exportAs.split(","gt":"'<STR_LIT>').map((e: string): string => e.trim()) : [];"}
{"input":"<s> <EOL>function _joinAndCanonicalizePath(parts: any[]): string {<EOL>    let path: any = parts[_ComponentIndex.Path];<EOL>    path = path == null ? '<STR_LIT>' : _removeDotSegments(","gt":"path);"}
{"input":"<s> function extractProperties(type: Function, instance: any, visited: {<EOL>    [name: string]: boolean;<EOL>}, descMap: Map<string, string[]>, name: string, superName: string): void {<EOL>    if (!type)<EOL>        return;<EOL>    visited[name] = true;<EOL>    const fullName: string = name + (superName ? '<STR_LIT>' + superName : '<STR_LIT>');<EOL>    const props: string[] = descMap.has(fullName) ? descMap.get(","gt":"fullName)! : [];"}
{"input":"<s> function extractProperties(type: Function, instance: any, visited: {<EOL>    [name: string]: boolean;<EOL>}, descMap: Map<string, string[]>, name: string, superName: string): void {<EOL>    if (!type)<EOL>        return;<EOL>    visited[name] = true;<EOL>    const fullName: string = name + (superName ? '<STR_LIT>' + superName : '<STR_LIT>');<EOL>    const props: string[] = descMap.has(fullName) ? descMap.get(fullName)! : [];<EOL>    const prototype: any = type.prototype;<EOL>    const keys: string[] = Object.getOwnPropertyNames(prototype);<EOL>","gt":"keys.sort();"}
{"input":"<s> function extractProperties(type: Function, instance: any, visited: {<EOL>    [name: string]: boolean;<EOL>}, descMap: Map<string, string[]>, name: string, superName: string): void {<EOL>    if (!type)<EOL>        return;<EOL>    visited[name] = true;<EOL>    const fullName: string = name + (superName ? '<STR_LIT>' + superName : '<STR_LIT>');<EOL>    const props: string[] = descMap.has(fullName) ? descMap.get(fullName)! : [];<EOL>    const prototype: any = type.prototype;<EOL>    const keys: string[] = Object.getOwnPropertyNames(prototype);<EOL>    keys.sort();<EOL>    keys.forEach((name: string): void => {<EOL>        if (name.startsWith('<STR_LIT>')) {<EOL>            props.push('<STR_LIT>' + name.substr(<NUM_LIT>));<EOL>        }<EOL>","gt":"else {"}
{"input":"<s> function extractProperties(type: Function, instance: any, visited: {<EOL>    [name: string]: boolean;<EOL>}, descMap: Map<string, string[]>, name: string, superName: string): void {<EOL>    if (!type)<EOL>        return;<EOL>    visited[name] = true;<EOL>    const fullName: string = name + (superName ? '<STR_LIT>' + superName : '<STR_LIT>');<EOL>    const props: string[] = descMap.has(fullName) ? descMap.get(fullName)! : [];<EOL>    const prototype: any = type.prototype;<EOL>    const keys: string[] = Object.getOwnPropertyNames(prototype);<EOL>    keys.sort();<EOL>    keys.forEach((name: string): void => {<EOL>        if (name.startsWith('<STR_LIT>')) {<EOL>            props.push('<STR_LIT>' + name.substr(<NUM_LIT>));<EOL>        }<EOL>        else {<EOL>            const typeCh: string = _TYPE_MNEMONICS[typeof instance[name]];<EOL>            const descriptor: PropertyDescriptor | undefined = Object.getOwnPropertyDescriptor(prototype, name);<EOL>            const isSetter: ((v: any) => void) | undefined = descriptor && descriptor.set;<EOL>            if (typeCh !== void <NUM_LIT> && !name.startsWith('<STR_LIT>') && isSetter) {<EOL>                props.","gt":"push(typeCh + name);"}
{"input":"<s> function humanizeContentProjection(templateAsts: TemplateAst[]): any[] {<EOL>    const humanizer:","gt":"TemplateContentProjectionHumanizer = new TemplateContentProjectionHumanizer();"}
{"input":"<s> <EOL>export function keyframes(steps: AnimationStyleMetadata[]): AnimationKeyframesSequenceMetadata {<EOL>    return","gt":"_keyframes(steps);"}
{"input":"<s> <EOL>export function sequence(steps: AnimationMetadata[]): AnimationSequenceMetadata {<EOL>    return _sequence(","gt":"steps);"}
{"input":"<s> export function isDefaultChangeDetectionStrategy(changeDetectionStrategy: ChangeDetectionStrategy): boolean {<EOL>    return","gt":"changeDetectionStrategy == null ||"}
{"input":"<s> export function removeDebugNodeFromIndex(node: DebugNode): void {<EOL>","gt":"_nativeNodeToDebugNode.delete(node.nativeNode);"}
{"input":"<s> <EOL>export function resolveForwardRef(type: any): any {<EOL>    if (typeof type === '<STR_LIT>' && type.hasOwnProperty('<STR_LIT>') &&<EOL>        type.__forward_ref__ === forwardRef) {<EOL>","gt":"return (<ForwardRefFn>type)();"}
{"input":"<s> function resolveToken(token: any, record: Record | undefined, records: Map<any, Record>, parent: Injector, notFoundValue: any, flags: InjectFlags): any {<EOL>    let value: any;<EOL>    if (record && !(flags & InjectFlags.SkipSelf)) {<EOL>        <EOL>        <EOL>        value = record.","gt":"value;"}
{"input":"<s> function resolveToken(token: any, record: Record | undefined, records: Map<any, Record>, parent: Injector, notFoundValue: any, flags: InjectFlags): any {<EOL>    let value: any;<EOL>    if (record && !(flags & InjectFlags.SkipSelf)) {<EOL>        <EOL>        <EOL>        value = record.value;<EOL>        if (value == CIRCULAR) {<EOL>            throw Error(NO_NEW_LINE + '<STR_LIT>');<EOL>        }<EOL>        else if (value === EMPTY) {<EOL>            record.value = CIRCULAR;<EOL>            let obj: any = undefined;<EOL>            let useNew: boolean = record.useNew;<EOL>            let fn: Function = record.","gt":"fn;"}
{"input":"<s> function resolveToken(token: any, record: Record | undefined, records: Map<any, Record>, parent: Injector, notFoundValue: any, flags: InjectFlags): any {<EOL>    let value: any;<EOL>    if (record && !(flags & InjectFlags.SkipSelf)) {<EOL>        <EOL>        <EOL>        value = record.value;<EOL>        if (value == CIRCULAR) {<EOL>            throw Error(NO_NEW_LINE + '<STR_LIT>');<EOL>        }<EOL>        else if (value === EMPTY) {<EOL>            record.value = CIRCULAR;<EOL>            let obj: any = undefined;<EOL>            let useNew: boolean = record.useNew;<EOL>            let fn: Function = record.fn;<EOL>            let depRecords: DependencyRecord[] = record.deps;<EOL>            let deps: any[] = EMPTY;<EOL>            if (depRecords.length) {<EOL>","gt":"deps = [];"}
{"input":"<s> function resolveToken(token: any, record: Record | undefined, records: Map<any, Record>, parent: Injector, notFoundValue: any, flags: InjectFlags): any {<EOL>    let value: any;<EOL>    if (record && !(flags & InjectFlags.SkipSelf)) {<EOL>        <EOL>        <EOL>        value = record.value;<EOL>        if (value == CIRCULAR) {<EOL>            throw Error(NO_NEW_LINE + '<STR_LIT>');<EOL>        }<EOL>        else if (value === EMPTY) {<EOL>            record.value = CIRCULAR;<EOL>            let obj: any = undefined;<EOL>            let useNew: boolean = record.useNew;<EOL>            let fn: Function = record.fn;<EOL>            let depRecords: DependencyRecord[] = record.deps;<EOL>            let deps: any[] = EMPTY;<EOL>            if (depRecords.length) {<EOL>                deps = [];<EOL>                for (let i: number = <NUM_LIT>; i < depRecords.length; i++) {<EOL>                    const depRecord: DependencyRecord = depRecords[i];<EOL>                    const options: number = depRecord.options;<EOL>                    const childRecord: Record | undefined = options & OptionFlags.CheckSelf ? records.get(depRecord.token) : undefined;<EOL>","gt":"deps.push(tryResolveToken("}
{"input":"<s> <EOL>export function outOfBoundsError(index: number): Error {<EOL>    return","gt":"Error(`<STR_LIT>`);"}
{"input":"<s> function _normalizeProviders(providers: Provider[], res: Provider[]): Provider[] {<EOL>    providers.forEach((b: Provider): void => {<EOL>        if (b instanceof Type) {<EOL>            res.push({ provide: b, useClass: b });<EOL>        }<EOL>        else if (b && typeof b == '<STR_LIT>' && (","gt":"b as any).provide !== undefined) {"}
{"input":"<s> function _normalizeProviders(providers: Provider[], res: Provider[]): Provider[] {<EOL>    providers.forEach((b: Provider): void => {<EOL>        if (b instanceof Type) {<EOL>            res.push({ provide: b, useClass: b });<EOL>        }<EOL>        else if (b && typeof b == '<STR_LIT>' && (b as any).provide !== undefined) {<EOL>            res.push(b as NormalizedProvider);<EOL>        }<EOL>        else if (b instanceof Array) {<EOL>","gt":"_normalizeProviders(b, res);"}
{"input":"<s> function _normalizeProviders(providers: Provider[], res: Provider[]): Provider[] {<EOL>    providers.forEach((b: Provider): void => {<EOL>        if (b instanceof Type) {<EOL>            res.push({ provide: b, useClass: b });<EOL>        }<EOL>        else if (b && typeof b == '<STR_LIT>' && (b as any).provide !== undefined) {<EOL>            res.push(b as NormalizedProvider);<EOL>        }<EOL>        else if (b instanceof Array) {<EOL>            _normalizeProviders(b, res);<EOL>        }<EOL>        else {<EOL>            throw","gt":"invalidProviderError(b);"}
{"input":"<s> export function wrappedError(message: string, originalError: any): Error {<EOL>    const msg: string = `<STR_LIT>`;<EOL>    const","gt":"error: Error = Error(msg);"}
{"input":"<s> <EOL>export function getHostElement<T>(component: T): HTMLElement {<EOL>    return","gt":"_getComponentHostLElementNode(component).native as any;"}
{"input":"<s> function assertDataInRange(index: number, arr?: any[]): void {<EOL>","gt":"if (arr == null)"}
{"input":"<s> function setUpAttributes(native: RElement, attrs: string[]): void {<EOL>    ngDevMode && assertEqual(attrs.length % <NUM_LIT>, <NUM_LIT>, '<STR_LIT>');<EOL>    const isProc:","gt":"boolean = isProceduralRenderer(renderer);"}
{"input":"<s> function setElementClass(view: ViewData, renderNode: any, name: string, value: boolean): void {<EOL>    const renderer: import(\"<STR_LIT>\").Renderer2 = view.renderer;<EOL>    if (value) {<EOL>        renderer.","gt":"addClass(renderNode, name);"}
{"input":"<s> export function expressionChangedAfterItHasBeenCheckedError(context: DebugContext, oldValue: any, currValue: any, isFirstCheck: boolean): Error {<EOL>    let msg: string = `<STR_LIT>`;<EOL>    if (isFirstCheck) {<EOL>","gt":"msg +="}
{"input":"<s> function updateProp(view: ViewData, providerData: ProviderData, def: NodeDef, bindingIdx: number, value: any, changes: SimpleChanges): SimpleChanges {<EOL>    if (def.flags & NodeFlags.Component) {<EOL>        const compView: ViewData = asElementData(view, def.parent!.nodeIndex).componentView;<EOL>        if (compView.def.flags & ViewFlags.OnPush) {<EOL>","gt":"compView.state |= ViewState.ChecksEnabled;"}
{"input":"<s> function updateProp(view: ViewData, providerData: ProviderData, def: NodeDef, bindingIdx: number, value: any, changes: SimpleChanges): SimpleChanges {<EOL>    if (def.flags & NodeFlags.Component) {<EOL>        const compView: ViewData = asElementData(view, def.parent!.nodeIndex).componentView;<EOL>        if (compView.def.flags & ViewFlags.OnPush) {<EOL>            compView.state |= ViewState.ChecksEnabled;<EOL>        }<EOL>    }<EOL>    const binding: BindingDef = def.bindings[","gt":"bindingIdx];"}
{"input":"<s> function updateProp(view: ViewData, providerData: ProviderData, def: NodeDef, bindingIdx: number, value: any, changes: SimpleChanges): SimpleChanges {<EOL>    if (def.flags & NodeFlags.Component) {<EOL>        const compView: ViewData = asElementData(view, def.parent!.nodeIndex).componentView;<EOL>        if (compView.def.flags & ViewFlags.OnPush) {<EOL>            compView.state |= ViewState.ChecksEnabled;<EOL>        }<EOL>    }<EOL>    const binding: BindingDef = def.bindings[bindingIdx];<EOL>    const propName: string = binding.name!;<EOL>    <EOL>    <EOL>    <EOL>    providerData.instance[","gt":"propName] = value;"}
{"input":"<s> function updateProp(view: ViewData, providerData: ProviderData, def: NodeDef, bindingIdx: number, value: any, changes: SimpleChanges): SimpleChanges {<EOL>    if (def.flags & NodeFlags.Component) {<EOL>        const compView: ViewData = asElementData(view, def.parent!.nodeIndex).componentView;<EOL>        if (compView.def.flags & ViewFlags.OnPush) {<EOL>            compView.state |= ViewState.ChecksEnabled;<EOL>        }<EOL>    }<EOL>    const binding: BindingDef = def.bindings[bindingIdx];<EOL>    const propName: string = binding.name!;<EOL>    <EOL>    <EOL>    <EOL>    providerData.instance[propName] = value;<EOL>    if (def.flags & NodeFlags.OnChanges) {<EOL>        changes = changes || {};<EOL>        const oldValue: any = WrappedValue.unwrap(view.oldValues[def.bindingIndex + bindingIdx]);<EOL>","gt":"const binding: BindingDef = def.bindings[bindingIdx];"}
{"input":"<s> export function dirtyParentQueries(view: ViewData): void {<EOL>    const queryIds: number = view.def.nodeMatchedQueries;<EOL>    while (view.parent && isEmbeddedView(view)) {<EOL>        let","gt":"tplDef: NodeDef = view.parentNodeDef!;"}
{"input":"<s> export function dirtyParentQueries(view: ViewData): void {<EOL>    const queryIds: number = view.def.nodeMatchedQueries;<EOL>    while (view.parent && isEmbeddedView(view)) {<EOL>        let tplDef: NodeDef = view.parentNodeDef!;<EOL>        view = view.parent;<EOL>        <EOL>        const end:","gt":"number = tplDef.nodeIndex + tplDef.childCount;"}
{"input":"<s> export function dirtyParentQueries(view: ViewData): void {<EOL>    const queryIds: number = view.def.nodeMatchedQueries;<EOL>    while (view.parent && isEmbeddedView(view)) {<EOL>        let tplDef: NodeDef = view.parentNodeDef!;<EOL>        view = view.parent;<EOL>        <EOL>        const end: number = tplDef.nodeIndex + tplDef.childCount;<EOL>        for (let i: number = <NUM_LIT>; i <= end; i++) {<EOL>            const nodeDef: NodeDef = view.def.nodes[i];<EOL>            if ((nodeDef.flags & NodeFlags.TypeContentQuery) &&<EOL>                (nodeDef.flags & NodeFlags.","gt":"DynamicQuery) &&"}
{"input":"<s> export function dirtyParentQueries(view: ViewData): void {<EOL>    const queryIds: number = view.def.nodeMatchedQueries;<EOL>    while (view.parent && isEmbeddedView(view)) {<EOL>        let tplDef: NodeDef = view.parentNodeDef!;<EOL>        view = view.parent;<EOL>        <EOL>        const end: number = tplDef.nodeIndex + tplDef.childCount;<EOL>        for (let i: number = <NUM_LIT>; i <= end; i++) {<EOL>            const nodeDef: NodeDef = view.def.nodes[i];<EOL>            if ((nodeDef.flags & NodeFlags.TypeContentQuery) &&<EOL>                (nodeDef.flags & NodeFlags.DynamicQuery) &&<EOL>                (nodeDef.query!.filterId & queryIds) === nodeDef.query!.filterId) {<EOL>                asQueryList(view, i).setDirty();<EOL>            }<EOL>            if ((nodeDef.flags & NodeFlags.TypeElement && i + nodeDef.","gt":"childCount < tplDef.nodeIndex) ||"}
{"input":"<s> export function dirtyParentQueries(view: ViewData): void {<EOL>    const queryIds: number = view.def.nodeMatchedQueries;<EOL>    while (view.parent && isEmbeddedView(view)) {<EOL>        let tplDef: NodeDef = view.parentNodeDef!;<EOL>        view = view.parent;<EOL>        <EOL>        const end: number = tplDef.nodeIndex + tplDef.childCount;<EOL>        for (let i: number = <NUM_LIT>; i <= end; i++) {<EOL>            const nodeDef: NodeDef = view.def.nodes[i];<EOL>            if ((nodeDef.flags & NodeFlags.TypeContentQuery) &&<EOL>                (nodeDef.flags & NodeFlags.DynamicQuery) &&<EOL>                (nodeDef.query!.filterId & queryIds) === nodeDef.query!.filterId) {<EOL>                asQueryList(view, i).setDirty();<EOL>            }<EOL>            if ((nodeDef.flags & NodeFlags.TypeElement && i + nodeDef.childCount < tplDef.nodeIndex) ||<EOL>                !(nodeDef.childFlags & NodeFlags.TypeContentQuery) ||<EOL>                !(nodeDef.childFlags & NodeFlags.DynamicQuery)) {<EOL>                <EOL>                i +=","gt":"nodeDef.childCount;"}
{"input":"<s> export function dirtyParentQueries(view: ViewData): void {<EOL>    const queryIds: number = view.def.nodeMatchedQueries;<EOL>    while (view.parent && isEmbeddedView(view)) {<EOL>        let tplDef: NodeDef = view.parentNodeDef!;<EOL>        view = view.parent;<EOL>        <EOL>        const end: number = tplDef.nodeIndex + tplDef.childCount;<EOL>        for (let i: number = <NUM_LIT>; i <= end; i++) {<EOL>            const nodeDef: NodeDef = view.def.nodes[i];<EOL>            if ((nodeDef.flags & NodeFlags.TypeContentQuery) &&<EOL>                (nodeDef.flags & NodeFlags.DynamicQuery) &&<EOL>                (nodeDef.query!.filterId & queryIds) === nodeDef.query!.filterId) {<EOL>                asQueryList(view, i).setDirty();<EOL>            }<EOL>            if ((nodeDef.flags & NodeFlags.TypeElement && i + nodeDef.childCount < tplDef.nodeIndex) ||<EOL>                !(nodeDef.childFlags & NodeFlags.TypeContentQuery) ||<EOL>                !(nodeDef.childFlags & NodeFlags.DynamicQuery)) {<EOL>                <EOL>                i += nodeDef.childCount;<EOL>            }<EOL>        }<EOL>    }<EOL>    <EOL>    if (view.def.nodeFlags & NodeFlags.TypeViewQuery) {<EOL>        for (let i: number = <NUM_LIT>; i < view.def.nodes.length; i++) {<EOL>            const nodeDef:","gt":"NodeDef = view.def.nodes[i];"}
{"input":"<s> function debugDestroyView(view: ViewData): any {<EOL>    return callWithDebugContext(DebugAction.destroy, destroyView, null, [","gt":"view]);"}
{"input":"<s> function _addInterpolationPart(value: any, binding: BindingDef): string {<EOL>    const","gt":"valueStr: any = value != null ? value.toString() : '<STR_LIT>';"}
{"input":"<s> function execRenderNodeAction(view: ViewData, renderNode: any, action: RenderNodeAction, parentNode: any, nextSibling: any, target?: any[]): void {<EOL>    const renderer: import(\"<STR_LIT>\").Renderer2 = view.renderer;<EOL>    switch (action) {<EOL>        case RenderNodeAction.AppendChild:<EOL>            renderer.appendChild(parentNode, renderNode);<EOL>","gt":"break;"}
{"input":"<s> function execRenderNodeAction(view: ViewData, renderNode: any, action: RenderNodeAction, parentNode: any, nextSibling: any, target?: any[]): void {<EOL>    const renderer: import(\"<STR_LIT>\").Renderer2 = view.renderer;<EOL>    switch (action) {<EOL>        case RenderNodeAction.AppendChild:<EOL>            renderer.appendChild(parentNode, renderNode);<EOL>            break;<EOL>        case RenderNodeAction.InsertBefore:<EOL>            renderer.insertBefore(parentNode, renderNode, nextSibling);<EOL>            break;<EOL>        case","gt":"RenderNodeAction.RemoveChild:"}
{"input":"<s> function execRenderNodeAction(view: ViewData, renderNode: any, action: RenderNodeAction, parentNode: any, nextSibling: any, target?: any[]): void {<EOL>    const renderer: import(\"<STR_LIT>\").Renderer2 = view.renderer;<EOL>    switch (action) {<EOL>        case RenderNodeAction.AppendChild:<EOL>            renderer.appendChild(parentNode, renderNode);<EOL>            break;<EOL>        case RenderNodeAction.InsertBefore:<EOL>            renderer.insertBefore(parentNode, renderNode, nextSibling);<EOL>            break;<EOL>        case RenderNodeAction.RemoveChild:<EOL>            renderer.removeChild(parentNode, renderNode);<EOL>            break;<EOL>","gt":"case RenderNodeAction.Collect:"}
{"input":"<s> function _toStringWithNull(v: any): string {<EOL>    return v != null ? v.","gt":"toString() : '<STR_LIT>';"}
{"input":"<s> function approximate(value: number, target: number): number {<EOL>","gt":"return Math.abs(target - value) / value;"}
{"input":"<s> function unimplemented(): any {<EOL>    throw Error(","gt":"'<STR_LIT>');"}
{"input":"<s> function _describe(jsmFn: Function, ...args: any[]): any {<EOL>    const parentRunner: BeforeEachRunner | null = runnerStack.length === <NUM_LIT> ? null : runnerStack[runnerStack.length - <NUM_LIT>];<EOL>    const","gt":"runner: BeforeEachRunner = new BeforeEachRunner(parentRunner!);"}
{"input":"<s> function logOnStable(): void {<EOL>    _zone.","gt":"onStable.subscribe({ next: _log.fn('<STR_LIT>') });"}
{"input":"<s> function waitForElement(selector: string): void {<EOL>    const EC:","gt":"any = ExpectedConditions;"}
{"input":"<s> function _buildValueString(id: string, value: any): string {<EOL>    if (id == null)<EOL>        return `<STR_LIT>`;<EOL>    if (typeof","gt":"value === '<STR_LIT>')"}
{"input":"<s> function _getJsonpConnections(): {<EOL>    [key: string]: any;<EOL>} {<EOL>    const w: {<EOL>        [key: string]: any;<EOL>    } = typeof window == '<STR_LIT>' ?","gt":"window : {};"}
{"input":"<s> export function removeSuffix(value: string, suffix: string): string {<EOL>    if (","gt":"value.endsWith(suffix))"}
{"input":"<s> export function initDomAdapter(): void {<EOL>    BrowserDomAdapter.","gt":"makeCurrent();"}
{"input":"<s> function _ngProbeTokensToMap(tokens: core.NgProbeToken[]): {<EOL>    [name: string]: any;<EOL>} {<EOL>    return tokens.reduce((prev: any, t: any): any => (prev[t.name] =","gt":"t.token, prev), {});"}
{"input":"<s> export function httpFactory(xhrBackend: XHRBackend, options: RequestOptions): Http {<EOL>    const","gt":"macroBackend: ZoneMacroTaskBackend = new ZoneMacroTaskBackend(xhrBackend);"}
{"input":"<s> function notSupported(feature: string): Error {<EOL>","gt":"throw new Error(`<STR_LIT>`);"}
{"input":"<s> export function provideLocationStrategy(platformLocationStrategy: PlatformLocation, baseHref: string, options: ExtraOptions = {}): HashLocationStrategy | PathLocationStrategy {<EOL>    return options.useHash ? new HashLocationStrategy(","gt":"platformLocationStrategy, baseHref) :"}
{"input":"<s> <EOL>export function last<T>(a: T[]): T | null {<EOL>    return a.length > <NUM_LIT> ? a[a.length - <NUM_LIT>] :","gt":"null;"}
{"input":"<s> function advance(fixture: ComponentFixture<any>): void {<EOL>","gt":"tick();"}
{"input":"<s> function createActivatedRoute(cmp: string): any {<EOL>    return new (ActivatedRoute as any)(new BehaviorSubject([new UrlSegment('<STR_LIT>', {})]), new BehaviorSubject({}), <any>null, <any>null, new","gt":"BehaviorSubject({}), <any>null, <any>cmp, <any>null);"}
{"input":"<s> export function directiveNormalize(name: string): string {<EOL>    return name.replace(","gt":"DIRECTIVE_PREFIX_REGEXP, '<STR_LIT>')"}
{"input":"<s> <EOL>function supportsNgModel(component: any): boolean {<EOL>    return","gt":"typeof component.writeValue === '<STR_LIT>' &&"}
{"input":"<s> export function setTempInjectorRef(injector: angular.IInjectorService): void {<EOL>    tempInjectorRef =","gt":"injector;"}
{"input":"<s> <EOL>function identifierIsMetadata(id: ts.Identifier, metadata: ts.Node[], checker: ts.TypeChecker): boolean {<EOL>    const symbol: any = checker.getSymbolAtLocation(id);<EOL>    if (!symbol || !symbol.declarations || !symbol.declarations.length) {<EOL>","gt":"return false;"}
{"input":"<s> export function testWrapEnums(content: string): boolean {<EOL>    const regexes: RegExp[] = [<EOL>        <EOL>","gt":"/var (\\S+) = \\{\\};\\r?\\n(\\1\\.(\\S+) = \\d+;\\r?\\n)+\\1\\[\\1\\.(\\S+)\\] = \"\\4\";\\r?\\n(\\1\\[\\1\\.(\\S+)\\] = \"\\S+\";\\r?\\n*)+/,"}
{"input":"<s> <EOL>export function getTestConfig(wco: WebpackConfigOptions<WebpackTestOptions>): {<EOL>    resolve: {<EOL>        mainFields: string[];<EOL>    };<EOL>    devtool: string;<EOL>    entry: {<EOL>        main: any;<EOL>    };<EOL>    module: {<EOL>        rules: never[];<EOL>    };<EOL>    plugins: any[];<EOL>} {<EOL>    const { projectRoot, buildOptions, appConfig } = wco;<EOL>    const nodeModules: any = path.resolve(projectRoot, '<STR_LIT>');<EOL>    const extraRules: any[] = [];<EOL>    const extraPlugins: any[] = [];<EOL>    <EOL>    if (buildOptions.codeCoverage) {<EOL>        <EOL>        const codeCoverageExclude: string[] = [];<EOL>        let exclude: (string | RegExp)[] = [<EOL>","gt":"/\\.(e2e|spec)\\.ts$/,"}
{"input":"<s> <EOL>export function getTestConfig(wco: WebpackConfigOptions<WebpackTestOptions>): {<EOL>    resolve: {<EOL>        mainFields: string[];<EOL>    };<EOL>    devtool: string;<EOL>    entry: {<EOL>        main: any;<EOL>    };<EOL>    module: {<EOL>        rules: never[];<EOL>    };<EOL>    plugins: any[];<EOL>} {<EOL>    const { projectRoot, buildOptions, appConfig } = wco;<EOL>    const nodeModules: any = path.resolve(projectRoot, '<STR_LIT>');<EOL>    const extraRules: any[] = [];<EOL>    const extraPlugins: any[] = [];<EOL>    <EOL>    if (buildOptions.codeCoverage) {<EOL>        <EOL>        const codeCoverageExclude: string[] = [];<EOL>        let exclude: (string | RegExp)[] = [<EOL>            /\\.(e2e|spec)\\.ts$/,<EOL>","gt":"/node_modules/"}
{"input":"<s> <EOL>export function getTestConfig(wco: WebpackConfigOptions<WebpackTestOptions>): {<EOL>    resolve: {<EOL>        mainFields: string[];<EOL>    };<EOL>    devtool: string;<EOL>    entry: {<EOL>        main: any;<EOL>    };<EOL>    module: {<EOL>        rules: never[];<EOL>    };<EOL>    plugins: any[];<EOL>} {<EOL>    const { projectRoot, buildOptions, appConfig } = wco;<EOL>    const nodeModules: any = path.resolve(projectRoot, '<STR_LIT>');<EOL>    const extraRules: any[] = [];<EOL>    const extraPlugins: any[] = [];<EOL>    <EOL>    if (buildOptions.codeCoverage) {<EOL>        <EOL>        const codeCoverageExclude: string[] = [];<EOL>        let exclude: (string | RegExp)[] = [<EOL>            /\\.(e2e|spec)\\.ts$/,<EOL>            /node_modules/<EOL>        ];<EOL>        if (codeCoverageExclude) {<EOL>            codeCoverageExclude.forEach((excludeGlob: string): void => {<EOL>                const excludeFiles: any = glob<EOL>                    .sync(path.join(projectRoot, excludeGlob), { nodir: true })<EOL>                    .map((file: any): any => path.","gt":"normalize(file));"}
{"input":"<s> <EOL>export function getTestConfig(wco: WebpackConfigOptions<WebpackTestOptions>): {<EOL>    resolve: {<EOL>        mainFields: string[];<EOL>    };<EOL>    devtool: string;<EOL>    entry: {<EOL>        main: any;<EOL>    };<EOL>    module: {<EOL>        rules: never[];<EOL>    };<EOL>    plugins: any[];<EOL>} {<EOL>    const { projectRoot, buildOptions, appConfig } = wco;<EOL>    const nodeModules: any = path.resolve(projectRoot, '<STR_LIT>');<EOL>    const extraRules: any[] = [];<EOL>    const extraPlugins: any[] = [];<EOL>    <EOL>    if (buildOptions.codeCoverage) {<EOL>        <EOL>        const codeCoverageExclude: string[] = [];<EOL>        let exclude: (string | RegExp)[] = [<EOL>            /\\.(e2e|spec)\\.ts$/,<EOL>            /node_modules/<EOL>        ];<EOL>        if (codeCoverageExclude) {<EOL>            codeCoverageExclude.forEach((excludeGlob: string): void => {<EOL>                const excludeFiles: any = glob<EOL>                    .sync(path.join(projectRoot, excludeGlob), { nodir: true })<EOL>                    .map((file: any): any => path.normalize(file));<EOL>                exclude.push(...excludeFiles);<EOL>            });<EOL>        }<EOL>        extraRules.push({<EOL>            test: /\\.(js|ts)$/, loader:","gt":"'<STR_LIT>',"}
{"input":"<s> <EOL>export function getTestConfig(wco: WebpackConfigOptions<WebpackTestOptions>): {<EOL>    resolve: {<EOL>        mainFields: string[];<EOL>    };<EOL>    devtool: string;<EOL>    entry: {<EOL>        main: any;<EOL>    };<EOL>    module: {<EOL>        rules: never[];<EOL>    };<EOL>    plugins: any[];<EOL>} {<EOL>    const { projectRoot, buildOptions, appConfig } = wco;<EOL>    const nodeModules: any = path.resolve(projectRoot, '<STR_LIT>');<EOL>    const extraRules: any[] = [];<EOL>    const extraPlugins: any[] = [];<EOL>    <EOL>    if (buildOptions.codeCoverage) {<EOL>        <EOL>        const codeCoverageExclude: string[] = [];<EOL>        let exclude: (string | RegExp)[] = [<EOL>            /\\.(e2e|spec)\\.ts$/,<EOL>            /node_modules/<EOL>        ];<EOL>        if (codeCoverageExclude) {<EOL>            codeCoverageExclude.forEach((excludeGlob: string): void => {<EOL>                const excludeFiles: any = glob<EOL>                    .sync(path.join(projectRoot, excludeGlob), { nodir: true })<EOL>                    .map((file: any): any => path.normalize(file));<EOL>                exclude.push(...excludeFiles);<EOL>            });<EOL>        }<EOL>        extraRules.push({<EOL>            test: /\\.(js|ts)$/, loader: '<STR_LIT>',<EOL>            options: { esModules: true },<EOL>            enforce: '<STR_LIT>',<EOL>            exclude<EOL>        });<EOL>    }<EOL>    return {<EOL>","gt":"resolve: {"}
{"input":"<s> <EOL>export function getTestConfig(wco: WebpackConfigOptions<WebpackTestOptions>): {<EOL>    resolve: {<EOL>        mainFields: string[];<EOL>    };<EOL>    devtool: string;<EOL>    entry: {<EOL>        main: any;<EOL>    };<EOL>    module: {<EOL>        rules: never[];<EOL>    };<EOL>    plugins: any[];<EOL>} {<EOL>    const { projectRoot, buildOptions, appConfig } = wco;<EOL>    const nodeModules: any = path.resolve(projectRoot, '<STR_LIT>');<EOL>    const extraRules: any[] = [];<EOL>    const extraPlugins: any[] = [];<EOL>    <EOL>    if (buildOptions.codeCoverage) {<EOL>        <EOL>        const codeCoverageExclude: string[] = [];<EOL>        let exclude: (string | RegExp)[] = [<EOL>            /\\.(e2e|spec)\\.ts$/,<EOL>            /node_modules/<EOL>        ];<EOL>        if (codeCoverageExclude) {<EOL>            codeCoverageExclude.forEach((excludeGlob: string): void => {<EOL>                const excludeFiles: any = glob<EOL>                    .sync(path.join(projectRoot, excludeGlob), { nodir: true })<EOL>                    .map((file: any): any => path.normalize(file));<EOL>                exclude.push(...excludeFiles);<EOL>            });<EOL>        }<EOL>        extraRules.push({<EOL>            test: /\\.(js|ts)$/, loader: '<STR_LIT>',<EOL>            options: { esModules: true },<EOL>            enforce: '<STR_LIT>',<EOL>            exclude<EOL>        });<EOL>    }<EOL>    return {<EOL>        resolve: {<EOL>            mainFields: [<EOL>                ...(wco.supportES2015 ? ['<STR_LIT>'] : []),<EOL>                '<STR_LIT>', '<STR_LIT>', '<STR_LIT>'<EOL>            ]<EOL>        },<EOL>        devtool: buildOptions.sourcemaps ? '<STR_LIT>' : '<STR_LIT>',<EOL>        entry: {<EOL>            main: path.resolve(projectRoot, appConfig.root, appConfig.main)<EOL>        },<EOL>        module: {<EOL>","gt":"rules: [].concat(extraRules as any)"}
{"input":"<s> <EOL>export function getTestConfig(wco: WebpackConfigOptions<WebpackTestOptions>): {<EOL>    resolve: {<EOL>        mainFields: string[];<EOL>    };<EOL>    devtool: string;<EOL>    entry: {<EOL>        main: any;<EOL>    };<EOL>    module: {<EOL>        rules: never[];<EOL>    };<EOL>    plugins: any[];<EOL>} {<EOL>    const { projectRoot, buildOptions, appConfig } = wco;<EOL>    const nodeModules: any = path.resolve(projectRoot, '<STR_LIT>');<EOL>    const extraRules: any[] = [];<EOL>    const extraPlugins: any[] = [];<EOL>    <EOL>    if (buildOptions.codeCoverage) {<EOL>        <EOL>        const codeCoverageExclude: string[] = [];<EOL>        let exclude: (string | RegExp)[] = [<EOL>            /\\.(e2e|spec)\\.ts$/,<EOL>            /node_modules/<EOL>        ];<EOL>        if (codeCoverageExclude) {<EOL>            codeCoverageExclude.forEach((excludeGlob: string): void => {<EOL>                const excludeFiles: any = glob<EOL>                    .sync(path.join(projectRoot, excludeGlob), { nodir: true })<EOL>                    .map((file: any): any => path.normalize(file));<EOL>                exclude.push(...excludeFiles);<EOL>            });<EOL>        }<EOL>        extraRules.push({<EOL>            test: /\\.(js|ts)$/, loader: '<STR_LIT>',<EOL>            options: { esModules: true },<EOL>            enforce: '<STR_LIT>',<EOL>            exclude<EOL>        });<EOL>    }<EOL>    return {<EOL>        resolve: {<EOL>            mainFields: [<EOL>                ...(wco.supportES2015 ? ['<STR_LIT>'] : []),<EOL>                '<STR_LIT>', '<STR_LIT>', '<STR_LIT>'<EOL>            ]<EOL>        },<EOL>        devtool: buildOptions.sourcemaps ? '<STR_LIT>' : '<STR_LIT>',<EOL>        entry: {<EOL>            main: path.resolve(projectRoot, appConfig.root, appConfig.main)<EOL>        },<EOL>        module: {<EOL>            rules: [].concat(extraRules as any)<EOL>        },<EOL>        plugins: [<EOL>            new webpack.optimize.CommonsChunkPlugin({<EOL>","gt":"minChunks: Infinity,"}
{"input":"<s> <EOL>export function getTestConfig(wco: WebpackConfigOptions<WebpackTestOptions>): {<EOL>    resolve: {<EOL>        mainFields: string[];<EOL>    };<EOL>    devtool: string;<EOL>    entry: {<EOL>        main: any;<EOL>    };<EOL>    module: {<EOL>        rules: never[];<EOL>    };<EOL>    plugins: any[];<EOL>} {<EOL>    const { projectRoot, buildOptions, appConfig } = wco;<EOL>    const nodeModules: any = path.resolve(projectRoot, '<STR_LIT>');<EOL>    const extraRules: any[] = [];<EOL>    const extraPlugins: any[] = [];<EOL>    <EOL>    if (buildOptions.codeCoverage) {<EOL>        <EOL>        const codeCoverageExclude: string[] = [];<EOL>        let exclude: (string | RegExp)[] = [<EOL>            /\\.(e2e|spec)\\.ts$/,<EOL>            /node_modules/<EOL>        ];<EOL>        if (codeCoverageExclude) {<EOL>            codeCoverageExclude.forEach((excludeGlob: string): void => {<EOL>                const excludeFiles: any = glob<EOL>                    .sync(path.join(projectRoot, excludeGlob), { nodir: true })<EOL>                    .map((file: any): any => path.normalize(file));<EOL>                exclude.push(...excludeFiles);<EOL>            });<EOL>        }<EOL>        extraRules.push({<EOL>            test: /\\.(js|ts)$/, loader: '<STR_LIT>',<EOL>            options: { esModules: true },<EOL>            enforce: '<STR_LIT>',<EOL>            exclude<EOL>        });<EOL>    }<EOL>    return {<EOL>        resolve: {<EOL>            mainFields: [<EOL>                ...(wco.supportES2015 ? ['<STR_LIT>'] : []),<EOL>                '<STR_LIT>', '<STR_LIT>', '<STR_LIT>'<EOL>            ]<EOL>        },<EOL>        devtool: buildOptions.sourcemaps ? '<STR_LIT>' : '<STR_LIT>',<EOL>        entry: {<EOL>            main: path.resolve(projectRoot, appConfig.root, appConfig.main)<EOL>        },<EOL>        module: {<EOL>            rules: [].concat(extraRules as any)<EOL>        },<EOL>        plugins: [<EOL>            new webpack.optimize.CommonsChunkPlugin({<EOL>                minChunks: Infinity,<EOL>                name: '<STR_LIT>'<EOL>            }),<EOL>            new","gt":"webpack.optimize.CommonsChunkPlugin({"}
{"input":"<s> export function getNonAotConfig(wco: WebpackConfigOptions): {<EOL>    module: {<EOL>        rules: {<EOL>            test: RegExp;<EOL>            loader: string;<EOL>        }[];<EOL>    };<EOL>    plugins: any[];<EOL>} {<EOL>    const { appConfig, projectRoot } = wco;<EOL>    const","gt":"tsConfigPath: any = path.resolve(projectRoot, appConfig.root, appConfig.tsConfig);"}
{"input":"<s> export function isFile(filePath: string): boolean {<EOL>    let stat: any;<EOL>    try {<EOL>        stat = fs.statSync(filePath);<EOL>    }<EOL>    catch (e: any) {<EOL>        if (e && (e.code === '<STR_LIT>' || e.code === '<STR_LIT>')) {<EOL>            return false;<EOL>        }<EOL>        throw","gt":"e;"}
{"input":"<s> <EOL>function _readBlanks(context: JsonParserContext): (JsonAstComment | JsonAstMultilineComment)[] {<EOL>    if ((context.mode & JsonParseMode.CommentsAllowed) != <NUM_LIT>) {<EOL>        const comments: (JsonAstComment | JsonAstMultilineComment)[] = [];<EOL>        while (","gt":"true) {"}
{"input":"<s> <EOL>function _readBlanks(context: JsonParserContext): (JsonAstComment | JsonAstMultilineComment)[] {<EOL>    if ((context.mode & JsonParseMode.CommentsAllowed) != <NUM_LIT>) {<EOL>        const comments: (JsonAstComment | JsonAstMultilineComment)[] = [];<EOL>        while (true) {<EOL>            let char: string = context.original[context.position.offset];<EOL>            if (char == '<STR_LIT>' && context.original[context.position.offset + <NUM_LIT>] == '<STR_LIT>') {<EOL>                const","gt":"start: Position = context.position;"}
{"input":"<s> <EOL>function _readBlanks(context: JsonParserContext): (JsonAstComment | JsonAstMultilineComment)[] {<EOL>    if ((context.mode & JsonParseMode.CommentsAllowed) != <NUM_LIT>) {<EOL>        const comments: (JsonAstComment | JsonAstMultilineComment)[] = [];<EOL>        while (true) {<EOL>            let char: string = context.original[context.position.offset];<EOL>            if (char == '<STR_LIT>' && context.original[context.position.offset + <NUM_LIT>] == '<STR_LIT>') {<EOL>                const start: Position = context.position;<EOL>                <EOL>                _next(context);<EOL>","gt":"_next(context);"}
{"input":"<s> <EOL>function _readBlanks(context: JsonParserContext): (JsonAstComment | JsonAstMultilineComment)[] {<EOL>    if ((context.mode & JsonParseMode.CommentsAllowed) != <NUM_LIT>) {<EOL>        const comments: (JsonAstComment | JsonAstMultilineComment)[] = [];<EOL>        while (true) {<EOL>            let char: string = context.original[context.position.offset];<EOL>            if (char == '<STR_LIT>' && context.original[context.position.offset + <NUM_LIT>] == '<STR_LIT>') {<EOL>                const start: Position = context.position;<EOL>                <EOL>                _next(context);<EOL>                _next(context);<EOL>                char = context.original[context.position.offset];<EOL>                while (context.original[context.position.offset] != '<STR_LIT>'<EOL>                    || context.original[context.position.offset + <NUM_LIT>] != '<STR_LIT>') {<EOL>","gt":"_next(context);"}
{"input":"<s> <EOL>function _readBlanks(context: JsonParserContext): (JsonAstComment | JsonAstMultilineComment)[] {<EOL>    if ((context.mode & JsonParseMode.CommentsAllowed) != <NUM_LIT>) {<EOL>        const comments: (JsonAstComment | JsonAstMultilineComment)[] = [];<EOL>        while (true) {<EOL>            let char: string = context.original[context.position.offset];<EOL>            if (char == '<STR_LIT>' && context.original[context.position.offset + <NUM_LIT>] == '<STR_LIT>') {<EOL>                const start: Position = context.position;<EOL>                <EOL>                _next(context);<EOL>                _next(context);<EOL>                char = context.original[context.position.offset];<EOL>                while (context.original[context.position.offset] != '<STR_LIT>'<EOL>                    || context.original[context.position.offset + <NUM_LIT>] != '<STR_LIT>') {<EOL>                    _next(context);<EOL>                    if (context.position.offset >= context.original.","gt":"length) {"}
{"input":"<s> <EOL>function _readBlanks(context: JsonParserContext): (JsonAstComment | JsonAstMultilineComment)[] {<EOL>    if ((context.mode & JsonParseMode.CommentsAllowed) != <NUM_LIT>) {<EOL>        const comments: (JsonAstComment | JsonAstMultilineComment)[] = [];<EOL>        while (true) {<EOL>            let char: string = context.original[context.position.offset];<EOL>            if (char == '<STR_LIT>' && context.original[context.position.offset + <NUM_LIT>] == '<STR_LIT>') {<EOL>                const start: Position = context.position;<EOL>                <EOL>                _next(context);<EOL>                _next(context);<EOL>                char = context.original[context.position.offset];<EOL>                while (context.original[context.position.offset] != '<STR_LIT>'<EOL>                    || context.original[context.position.offset + <NUM_LIT>] != '<STR_LIT>') {<EOL>                    _next(context);<EOL>                    if (context.position.offset >= context.original.length) {<EOL>                        throw new UnexpectedEndOfInputException(context);<EOL>                    }<EOL>                }<EOL>                <EOL>                _next(context);<EOL>                _next(context);<EOL>","gt":"comments."}
{"input":"<s> <EOL>function _readBlanks(context: JsonParserContext): (JsonAstComment | JsonAstMultilineComment)[] {<EOL>    if ((context.mode & JsonParseMode.CommentsAllowed) != <NUM_LIT>) {<EOL>        const comments: (JsonAstComment | JsonAstMultilineComment)[] = [];<EOL>        while (true) {<EOL>            let char: string = context.original[context.position.offset];<EOL>            if (char == '<STR_LIT>' && context.original[context.position.offset + <NUM_LIT>] == '<STR_LIT>') {<EOL>                const start: Position = context.position;<EOL>                <EOL>                _next(context);<EOL>                _next(context);<EOL>                char = context.original[context.position.offset];<EOL>                while (context.original[context.position.offset] != '<STR_LIT>'<EOL>                    || context.original[context.position.offset + <NUM_LIT>] != '<STR_LIT>') {<EOL>                    _next(context);<EOL>                    if (context.position.offset >= context.original.length) {<EOL>                        throw new UnexpectedEndOfInputException(context);<EOL>                    }<EOL>                }<EOL>                <EOL>                _next(context);<EOL>                _next(context);<EOL>                comments.","gt":"push({"}
{"input":"<s> <EOL>function _readBlanks(context: JsonParserContext): (JsonAstComment | JsonAstMultilineComment)[] {<EOL>    if ((context.mode & JsonParseMode.CommentsAllowed) != <NUM_LIT>) {<EOL>        const comments: (JsonAstComment | JsonAstMultilineComment)[] = [];<EOL>        while (true) {<EOL>            let char: string = context.original[context.position.offset];<EOL>            if (char == '<STR_LIT>' && context.original[context.position.offset + <NUM_LIT>] == '<STR_LIT>') {<EOL>                const start: Position = context.position;<EOL>                <EOL>                _next(context);<EOL>                _next(context);<EOL>                char = context.original[context.position.offset];<EOL>                while (context.original[context.position.offset] != '<STR_LIT>'<EOL>                    || context.original[context.position.offset + <NUM_LIT>] != '<STR_LIT>') {<EOL>                    _next(context);<EOL>                    if (context.position.offset >= context.original.length) {<EOL>                        throw new UnexpectedEndOfInputException(context);<EOL>                    }<EOL>                }<EOL>                <EOL>                _next(context);<EOL>                _next(context);<EOL>                comments.push({<EOL>                    kind: '<STR_LIT>',<EOL>                    start,<EOL>                    end: context.position,<EOL>                    text: context.original.substring(start.offset, context.position.offset),<EOL>                    content: context.original.substring(start.offset + <NUM_LIT>, context.position.offset - <NUM_LIT>),<EOL>                });<EOL>            }<EOL>            else if (char == '<STR_LIT>' && context.original[context.","gt":"position.offset + <NUM_LIT>] == '<STR_LIT>') {"}
{"input":"<s> <EOL>function _readBlanks(context: JsonParserContext): (JsonAstComment | JsonAstMultilineComment)[] {<EOL>    if ((context.mode & JsonParseMode.CommentsAllowed) != <NUM_LIT>) {<EOL>        const comments: (JsonAstComment | JsonAstMultilineComment)[] = [];<EOL>        while (true) {<EOL>            let char: string = context.original[context.position.offset];<EOL>            if (char == '<STR_LIT>' && context.original[context.position.offset + <NUM_LIT>] == '<STR_LIT>') {<EOL>                const start: Position = context.position;<EOL>                <EOL>                _next(context);<EOL>                _next(context);<EOL>                char = context.original[context.position.offset];<EOL>                while (context.original[context.position.offset] != '<STR_LIT>'<EOL>                    || context.original[context.position.offset + <NUM_LIT>] != '<STR_LIT>') {<EOL>                    _next(context);<EOL>                    if (context.position.offset >= context.original.length) {<EOL>                        throw new UnexpectedEndOfInputException(context);<EOL>                    }<EOL>                }<EOL>                <EOL>                _next(context);<EOL>                _next(context);<EOL>                comments.push({<EOL>                    kind: '<STR_LIT>',<EOL>                    start,<EOL>                    end: context.position,<EOL>                    text: context.original.substring(start.offset, context.position.offset),<EOL>                    content: context.original.substring(start.offset + <NUM_LIT>, context.position.offset - <NUM_LIT>),<EOL>                });<EOL>            }<EOL>            else if (char == '<STR_LIT>' && context.original[context.position.offset + <NUM_LIT>] == '<STR_LIT>') {<EOL>                const start: Position = context.position;<EOL>                <EOL>                _next(context);<EOL>                _next(context);<EOL>                char = context.original[context.position.offset];<EOL>                while (context.original[context.position.offset] != '<STR_LIT>') {<EOL>                    _next(context);<EOL>                    if (","gt":"context.position.offset >= context.original.length) {"}
{"input":"<s> export function fileBufferToString(fileBuffer: FileBuffer): string {<EOL>    if (typeof TextDecoder !== '<STR_LIT>') {<EOL>        <EOL>        return new TextDecoder('<STR_LIT>').decode(new Uint8Array(","gt":"fileBuffer));"}
{"input":"<s> <EOL>export function isAbsolute(p: Path): boolean {<EOL>    return p.","gt":"startsWith(NormalizedSep);"}
{"input":"<s> export function filter(predicate: FilePredicate<boolean>): Rule {<EOL>    return (tree: Tree): FilteredTree => new FilteredTree(tree,","gt":"predicate);"}
{"input":"<s> export function when(predicate: FilePredicate<boolean>, operator: FileOperator): FileOperator {<EOL>    return (entry: FileEntry): FileEntry | null => {<EOL>        if (predicate(entry.path, entry)) {<EOL>            return operator(","gt":"entry);"}
{"input":"<s> <EOL>export function schematic<OptionT extends object>(schematicName: string, options: OptionT): Rule {<EOL>    return (input: Tree, context: SchematicContext): Observable<Tree> => {<EOL>        const collection: import(\"<STR_LIT>\").Collection<{}, {}> = context.","gt":"schematic.collection;"}
{"input":"<s> function files(tree: Tree): string[] {<EOL>    const treeFiles:","gt":"string[] = [];"}
{"input":"<s> function addAppShellConfig(options: AppShellOptions): Rule {<EOL>    return (host: Tree): import(\"<STR_LIT>\").Tree => {<EOL>        const config: import(\"<STR_LIT>\").CliConfig = getConfig(host);<EOL>        const app: AppConfig | null = getAppFromConfig(config, options.clientApp || '<STR_LIT>');<EOL>        if (!app) {<EOL>            throw new SchematicsException(formatMissingAppMsg('<STR_LIT>',","gt":"options.clientApp));"}
{"input":"<s> <EOL>function validateProject(options: AppShellOptions): Rule {<EOL>    return (host: Tree, context: SchematicContext): void => {<EOL>        const routerOutletCheckRegex: RegExp = /<router\\-outlet.*?>([\\s\\S]*?)<\\/router\\-outlet>/;<EOL>        const config: import(\"<STR_LIT>\").CliConfig = getConfig(host);<EOL>        const app: AppConfig | null = getAppFromConfig(config, options.clientApp || '<STR_LIT>');<EOL>        if (app ===","gt":"null) {"}
{"input":"<s> <EOL>function validateProject(options: AppShellOptions): Rule {<EOL>    return (host: Tree, context: SchematicContext): void => {<EOL>        const routerOutletCheckRegex: RegExp = /<router\\-outlet.*?>([\\s\\S]*?)<\\/router\\-outlet>/;<EOL>        const config: import(\"<STR_LIT>\").CliConfig = getConfig(host);<EOL>        const app: AppConfig | null = getAppFromConfig(config, options.clientApp || '<STR_LIT>');<EOL>        if (app === null) {<EOL>            throw new SchematicsException(formatMissingAppMsg('<STR_LIT>', options.clientApp));<EOL>        }<EOL>        const componentPath: string = getBootstrapComponentPath(host, app);<EOL>        const tmpl:","gt":"TemplateInfo = getComponentTemplateInfo(host, componentPath);"}
{"input":"<s> <EOL>function validateProject(options: AppShellOptions): Rule {<EOL>    return (host: Tree, context: SchematicContext): void => {<EOL>        const routerOutletCheckRegex: RegExp = /<router\\-outlet.*?>([\\s\\S]*?)<\\/router\\-outlet>/;<EOL>        const config: import(\"<STR_LIT>\").CliConfig = getConfig(host);<EOL>        const app: AppConfig | null = getAppFromConfig(config, options.clientApp || '<STR_LIT>');<EOL>        if (app === null) {<EOL>            throw new SchematicsException(formatMissingAppMsg('<STR_LIT>', options.clientApp));<EOL>        }<EOL>        const componentPath: string = getBootstrapComponentPath(host, app);<EOL>        const tmpl: TemplateInfo = getComponentTemplateInfo(host, componentPath);<EOL>        const template: string = getComponentTemplate(host, componentPath, tmpl);<EOL>        if (!routerOutletCheckRegex.test(template)) {<EOL>            const errorMsg: string = `<STR_LIT>`;<EOL>            context.logger.error(","gt":"errorMsg);"}
{"input":"<s> <EOL>export function findModule(host: Tree, generateDir: string): Path {<EOL>    let dir: DirEntry | null = host.getDir('<STR_LIT>' + generateDir);<EOL>    const moduleRe: RegExp = /\\.module\\.ts$/;<EOL>    const routingModuleRe: RegExp = /-routing\\.module\\.ts/;<EOL>    while (dir) {<EOL>        const matches: import(\"<STR_LIT>\").PathFragment[] = dir.subfiles.filter((p: import(\"<STR_LIT>\").PathFragment): boolean =>","gt":"moduleRe.test(p) && !routingModuleRe.test(p));"}
{"input":"<s> <EOL>export function findModule(host: Tree, generateDir: string): Path {<EOL>    let dir: DirEntry | null = host.getDir('<STR_LIT>' + generateDir);<EOL>    const moduleRe: RegExp = /\\.module\\.ts$/;<EOL>    const routingModuleRe: RegExp = /-routing\\.module\\.ts/;<EOL>    while (dir) {<EOL>        const matches: import(\"<STR_LIT>\").PathFragment[] = dir.subfiles.filter((p: import(\"<STR_LIT>\").PathFragment): boolean => moduleRe.test(p) && !routingModuleRe.test(p));<EOL>        if (matches.length == <NUM_LIT>) {<EOL>            return join(dir.path, matches[<NUM_LIT>]);<EOL>        }<EOL>        else if (","gt":"matches.length > <NUM_LIT>) {"}
{"input":"<s> <EOL>export function findModule(host: Tree, generateDir: string): Path {<EOL>    let dir: DirEntry | null = host.getDir('<STR_LIT>' + generateDir);<EOL>    const moduleRe: RegExp = /\\.module\\.ts$/;<EOL>    const routingModuleRe: RegExp = /-routing\\.module\\.ts/;<EOL>    while (dir) {<EOL>        const matches: import(\"<STR_LIT>\").PathFragment[] = dir.subfiles.filter((p: import(\"<STR_LIT>\").PathFragment): boolean => moduleRe.test(p) && !routingModuleRe.test(p));<EOL>        if (matches.length == <NUM_LIT>) {<EOL>            return join(dir.path, matches[<NUM_LIT>]);<EOL>        }<EOL>        else if (matches.length > <NUM_LIT>) {<EOL>            throw new Error('<STR_LIT>'<EOL>                + '<STR_LIT>');<EOL>        }<EOL>        dir =","gt":"dir.parent;"}
{"input":"<s> <EOL>function _getRecursiveVersions(packageJson: JsonObject, packages: {<EOL>    [name: string]: string;<EOL>}, allVersions: {<EOL>    [name: string]: string;<EOL>}, logger: logging.LoggerApi, loose: boolean): Observable<void> {<EOL>    return observableFrom(kPackageJsonDependencyFields).pipe(mergeMap((field: any): any => {<EOL>        const deps: JsonObject = packageJson[field] as JsonObject;<EOL>","gt":"if (deps) {"}
{"input":"<s> <EOL>function _getRecursiveVersions(packageJson: JsonObject, packages: {<EOL>    [name: string]: string;<EOL>}, allVersions: {<EOL>    [name: string]: string;<EOL>}, logger: logging.LoggerApi, loose: boolean): Observable<void> {<EOL>    return observableFrom(kPackageJsonDependencyFields).pipe(mergeMap((field: any): any => {<EOL>        const deps: JsonObject = packageJson[field] as JsonObject;<EOL>        if (deps) {<EOL>            return observableFrom(Object.keys(deps)<EOL>                .map((depName: string): (string | number | boolean | JsonObject | import(\"<STR_LIT>\").JsonArray | null)[] | null => depName in deps ? [depName, deps[","gt":"depName]] : null)"}
{"input":"<s> <EOL>function _getRecursiveVersions(packageJson: JsonObject, packages: {<EOL>    [name: string]: string;<EOL>}, allVersions: {<EOL>    [name: string]: string;<EOL>}, logger: logging.LoggerApi, loose: boolean): Observable<void> {<EOL>    return observableFrom(kPackageJsonDependencyFields).pipe(mergeMap((field: any): any => {<EOL>        const deps: JsonObject = packageJson[field] as JsonObject;<EOL>        if (deps) {<EOL>            return observableFrom(Object.keys(deps)<EOL>                .map((depName: string): (string | number | boolean | JsonObject | import(\"<STR_LIT>\").JsonArray | null)[] | null => depName in deps ? [depName, deps[depName]] : null)<EOL>                .filter((x: (string | number | boolean | JsonObject | import(\"<STR_LIT>\").JsonArray | null)[] | null): boolean => !!x));<EOL>        }<EOL>        else {<EOL>            return empty();<EOL>        }<EOL>    }), mergeMap(([","gt":"depName, depVersion]: ["}
{"input":"<s> <EOL>function _getRecursiveVersions(packageJson: JsonObject, packages: {<EOL>    [name: string]: string;<EOL>}, allVersions: {<EOL>    [name: string]: string;<EOL>}, logger: logging.LoggerApi, loose: boolean): Observable<void> {<EOL>    return observableFrom(kPackageJsonDependencyFields).pipe(mergeMap((field: any): any => {<EOL>        const deps: JsonObject = packageJson[field] as JsonObject;<EOL>        if (deps) {<EOL>            return observableFrom(Object.keys(deps)<EOL>                .map((depName: string): (string | number | boolean | JsonObject | import(\"<STR_LIT>\").JsonArray | null)[] | null => depName in deps ? [depName, deps[depName]] : null)<EOL>                .filter((x: (string | number | boolean | JsonObject | import(\"<STR_LIT>\").JsonArray | null)[] | null): boolean => !!x));<EOL>        }<EOL>        else {<EOL>            return empty();<EOL>        }<EOL>    }), mergeMap(([depName, depVersion]: [<EOL>        string,<EOL>        string<EOL>    ]): any => {<EOL>        if (!packages[depName] || packages[depName] === depVersion) {<EOL>            return empty();<EOL>        }<EOL>        if (allVersions[depName] && semver.intersects(allVersions[depName],","gt":"depVersion)) {"}
{"input":"<s> <EOL>function _getRecursiveVersions(packageJson: JsonObject, packages: {<EOL>    [name: string]: string;<EOL>}, allVersions: {<EOL>    [name: string]: string;<EOL>}, logger: logging.LoggerApi, loose: boolean): Observable<void> {<EOL>    return observableFrom(kPackageJsonDependencyFields).pipe(mergeMap((field: any): any => {<EOL>        const deps: JsonObject = packageJson[field] as JsonObject;<EOL>        if (deps) {<EOL>            return observableFrom(Object.keys(deps)<EOL>                .map((depName: string): (string | number | boolean | JsonObject | import(\"<STR_LIT>\").JsonArray | null)[] | null => depName in deps ? [depName, deps[depName]] : null)<EOL>                .filter((x: (string | number | boolean | JsonObject | import(\"<STR_LIT>\").JsonArray | null)[] | null): boolean => !!x));<EOL>        }<EOL>        else {<EOL>            return empty();<EOL>        }<EOL>    }), mergeMap(([depName, depVersion]: [<EOL>        string,<EOL>        string<EOL>    ]): any => {<EOL>        if (!packages[depName] || packages[depName] === depVersion) {<EOL>            return empty();<EOL>        }<EOL>        if (allVersions[depName] && semver.intersects(allVersions[depName], depVersion)) {<EOL>            allVersions[depName] = semverIntersect.intersect(allVersions[depName], depVersion);<EOL>            return empty();<EOL>        }<EOL>        return _getNpmPackageJson(depName, logger).pipe(map((json: any): any[] => [packages[depName], depName, depVersion, json]));<EOL>    }),","gt":"mergeMap(([version, depName, depVersion, npmPackageJson]) => {"}
{"input":"<s> <EOL>function _getRecursiveVersions(packageJson: JsonObject, packages: {<EOL>    [name: string]: string;<EOL>}, allVersions: {<EOL>    [name: string]: string;<EOL>}, logger: logging.LoggerApi, loose: boolean): Observable<void> {<EOL>    return observableFrom(kPackageJsonDependencyFields).pipe(mergeMap((field: any): any => {<EOL>        const deps: JsonObject = packageJson[field] as JsonObject;<EOL>        if (deps) {<EOL>            return observableFrom(Object.keys(deps)<EOL>                .map((depName: string): (string | number | boolean | JsonObject | import(\"<STR_LIT>\").JsonArray | null)[] | null => depName in deps ? [depName, deps[depName]] : null)<EOL>                .filter((x: (string | number | boolean | JsonObject | import(\"<STR_LIT>\").JsonArray | null)[] | null): boolean => !!x));<EOL>        }<EOL>        else {<EOL>            return empty();<EOL>        }<EOL>    }), mergeMap(([depName, depVersion]: [<EOL>        string,<EOL>        string<EOL>    ]): any => {<EOL>        if (!packages[depName] || packages[depName] === depVersion) {<EOL>            return empty();<EOL>        }<EOL>        if (allVersions[depName] && semver.intersects(allVersions[depName], depVersion)) {<EOL>            allVersions[depName] = semverIntersect.intersect(allVersions[depName], depVersion);<EOL>            return empty();<EOL>        }<EOL>        return _getNpmPackageJson(depName, logger).pipe(map((json: any): any[] => [packages[depName], depName, depVersion, json]));<EOL>    }), mergeMap(([version, depName, depVersion, npmPackageJson]) => {<EOL>        const updateVersion: string = _getVersionFromNpmPackage(npmPackageJson, version, loose);<EOL>        const npmPackageVersions: string[] = Object.keys(npmPackageJson['<STR_LIT>'] as JsonObject);<EOL>        const match: any = semver.maxSatisfying(npmPackageVersions, updateVersion);<EOL>        if (!match) {<EOL>            return empty();<EOL>        }<EOL>        if (semver.lt(semverIntersect.parseRange(updateVersion).version,","gt":"semverIntersect.parseRange(depVersion).version)) {"}
{"input":"<s> <EOL>function _getRecursiveVersions(packageJson: JsonObject, packages: {<EOL>    [name: string]: string;<EOL>}, allVersions: {<EOL>    [name: string]: string;<EOL>}, logger: logging.LoggerApi, loose: boolean): Observable<void> {<EOL>    return observableFrom(kPackageJsonDependencyFields).pipe(mergeMap((field: any): any => {<EOL>        const deps: JsonObject = packageJson[field] as JsonObject;<EOL>        if (deps) {<EOL>            return observableFrom(Object.keys(deps)<EOL>                .map((depName: string): (string | number | boolean | JsonObject | import(\"<STR_LIT>\").JsonArray | null)[] | null => depName in deps ? [depName, deps[depName]] : null)<EOL>                .filter((x: (string | number | boolean | JsonObject | import(\"<STR_LIT>\").JsonArray | null)[] | null): boolean => !!x));<EOL>        }<EOL>        else {<EOL>            return empty();<EOL>        }<EOL>    }), mergeMap(([depName, depVersion]: [<EOL>        string,<EOL>        string<EOL>    ]): any => {<EOL>        if (!packages[depName] || packages[depName] === depVersion) {<EOL>            return empty();<EOL>        }<EOL>        if (allVersions[depName] && semver.intersects(allVersions[depName], depVersion)) {<EOL>            allVersions[depName] = semverIntersect.intersect(allVersions[depName], depVersion);<EOL>            return empty();<EOL>        }<EOL>        return _getNpmPackageJson(depName, logger).pipe(map((json: any): any[] => [packages[depName], depName, depVersion, json]));<EOL>    }), mergeMap(([version, depName, depVersion, npmPackageJson]) => {<EOL>        const updateVersion: string = _getVersionFromNpmPackage(npmPackageJson, version, loose);<EOL>        const npmPackageVersions: string[] = Object.keys(npmPackageJson['<STR_LIT>'] as JsonObject);<EOL>        const match: any = semver.maxSatisfying(npmPackageVersions, updateVersion);<EOL>        if (!match) {<EOL>            return empty();<EOL>        }<EOL>        if (semver.lt(semverIntersect.parseRange(updateVersion).version, semverIntersect.parseRange(depVersion).version)) {<EOL>            throw new SchematicsException(`<STR_LIT>`);<EOL>        }<EOL>        const innerNpmPackageJson: JsonObject = (npmPackageJson['<STR_LIT>'] as JsonObject)[match] as JsonObject;<EOL>        const","gt":"dependencies: {"}
{"input":"<s> <EOL>function _getRecursiveVersions(packageJson: JsonObject, packages: {<EOL>    [name: string]: string;<EOL>}, allVersions: {<EOL>    [name: string]: string;<EOL>}, logger: logging.LoggerApi, loose: boolean): Observable<void> {<EOL>    return observableFrom(kPackageJsonDependencyFields).pipe(mergeMap((field: any): any => {<EOL>        const deps: JsonObject = packageJson[field] as JsonObject;<EOL>        if (deps) {<EOL>            return observableFrom(Object.keys(deps)<EOL>                .map((depName: string): (string | number | boolean | JsonObject | import(\"<STR_LIT>\").JsonArray | null)[] | null => depName in deps ? [depName, deps[depName]] : null)<EOL>                .filter((x: (string | number | boolean | JsonObject | import(\"<STR_LIT>\").JsonArray | null)[] | null): boolean => !!x));<EOL>        }<EOL>        else {<EOL>            return empty();<EOL>        }<EOL>    }), mergeMap(([depName, depVersion]: [<EOL>        string,<EOL>        string<EOL>    ]): any => {<EOL>        if (!packages[depName] || packages[depName] === depVersion) {<EOL>            return empty();<EOL>        }<EOL>        if (allVersions[depName] && semver.intersects(allVersions[depName], depVersion)) {<EOL>            allVersions[depName] = semverIntersect.intersect(allVersions[depName], depVersion);<EOL>            return empty();<EOL>        }<EOL>        return _getNpmPackageJson(depName, logger).pipe(map((json: any): any[] => [packages[depName], depName, depVersion, json]));<EOL>    }), mergeMap(([version, depName, depVersion, npmPackageJson]) => {<EOL>        const updateVersion: string = _getVersionFromNpmPackage(npmPackageJson, version, loose);<EOL>        const npmPackageVersions: string[] = Object.keys(npmPackageJson['<STR_LIT>'] as JsonObject);<EOL>        const match: any = semver.maxSatisfying(npmPackageVersions, updateVersion);<EOL>        if (!match) {<EOL>            return empty();<EOL>        }<EOL>        if (semver.lt(semverIntersect.parseRange(updateVersion).version, semverIntersect.parseRange(depVersion).version)) {<EOL>            throw new SchematicsException(`<STR_LIT>`);<EOL>        }<EOL>        const innerNpmPackageJson: JsonObject = (npmPackageJson['<STR_LIT>'] as JsonObject)[match] as JsonObject;<EOL>        const dependencies: {<EOL>            [name: string]: string;<EOL>        } = {};<EOL>        const deps: JsonObject = innerNpmPackageJson['<STR_LIT>'] as JsonObject;<EOL>        if (deps) {<EOL>            for (const depName: string of Object.keys(deps)) {<EOL>                dependencies[depName] = deps[depName] as string;<EOL>            }<EOL>        }<EOL>        logger.debug(","gt":"JSON.stringify(depName)} to version ${updateVersion}.`<STR_LIT>;"}
{"input":"<s> <EOL>function _getRecursiveVersions(packageJson: JsonObject, packages: {<EOL>    [name: string]: string;<EOL>}, allVersions: {<EOL>    [name: string]: string;<EOL>}, logger: logging.LoggerApi, loose: boolean): Observable<void> {<EOL>    return observableFrom(kPackageJsonDependencyFields).pipe(mergeMap((field: any): any => {<EOL>        const deps: JsonObject = packageJson[field] as JsonObject;<EOL>        if (deps) {<EOL>            return observableFrom(Object.keys(deps)<EOL>                .map((depName: string): (string | number | boolean | JsonObject | import(\"<STR_LIT>\").JsonArray | null)[] | null => depName in deps ? [depName, deps[depName]] : null)<EOL>                .filter((x: (string | number | boolean | JsonObject | import(\"<STR_LIT>\").JsonArray | null)[] | null): boolean => !!x));<EOL>        }<EOL>        else {<EOL>            return empty();<EOL>        }<EOL>    }), mergeMap(([depName, depVersion]: [<EOL>        string,<EOL>        string<EOL>    ]): any => {<EOL>        if (!packages[depName] || packages[depName] === depVersion) {<EOL>            return empty();<EOL>        }<EOL>        if (allVersions[depName] && semver.intersects(allVersions[depName], depVersion)) {<EOL>            allVersions[depName] = semverIntersect.intersect(allVersions[depName], depVersion);<EOL>            return empty();<EOL>        }<EOL>        return _getNpmPackageJson(depName, logger).pipe(map((json: any): any[] => [packages[depName], depName, depVersion, json]));<EOL>    }), mergeMap(([version, depName, depVersion, npmPackageJson]) => {<EOL>        const updateVersion: string = _getVersionFromNpmPackage(npmPackageJson, version, loose);<EOL>        const npmPackageVersions: string[] = Object.keys(npmPackageJson['<STR_LIT>'] as JsonObject);<EOL>        const match: any = semver.maxSatisfying(npmPackageVersions, updateVersion);<EOL>        if (!match) {<EOL>            return empty();<EOL>        }<EOL>        if (semver.lt(semverIntersect.parseRange(updateVersion).version, semverIntersect.parseRange(depVersion).version)) {<EOL>            throw new SchematicsException(`<STR_LIT>`);<EOL>        }<EOL>        const innerNpmPackageJson: JsonObject = (npmPackageJson['<STR_LIT>'] as JsonObject)[match] as JsonObject;<EOL>        const dependencies: {<EOL>            [name: string]: string;<EOL>        } = {};<EOL>        const deps: JsonObject = innerNpmPackageJson['<STR_LIT>'] as JsonObject;<EOL>        if (deps) {<EOL>            for (const depName: string of Object.keys(deps)) {<EOL>                dependencies[depName] = deps[depName] as string;<EOL>            }<EOL>        }<EOL>        logger.debug(`<STR_LIT>`);<EOL>        if (allVersions[depName]) {<EOL>            if (!semver.intersects(allVersions[depName], updateVersion)) {<EOL>                throw new SchematicsException('<STR_LIT>'<EOL>                    +","gt":"} would need to match both versions \"<STR_LIT>\" and `<STR_LIT>`"}
{"input":"<s> export default function (_: {}, logger: logging.Logger): void {<EOL>    logger.info(JSON.stringify(","gt":"packages, null, <NUM_LIT>));"}
{"input":"<s> export default function (): typeof GanttSide {<EOL>","gt":"'<STR_LIT>';"}
{"input":"<s> export default function ($compile: any): {<EOL>    restrict: string;<EOL>    require: string;<EOL>    link: (scope: any, element: any, attrs: any, ganttCtrl: any) => void;<EOL>} {<EOL>    '<STR_LIT>';<EOL>    return {<EOL>        restrict: '<STR_LIT>',<EOL>        require: '<STR_LIT>',<EOL>        link: function (","gt":"scope, element, attrs, ganttCtrl) {"}
{"input":"<s> export default function ($compile: any): {<EOL>    restrict: string;<EOL>    require: string;<EOL>    link: (scope: any, element: any, attrs: any, ganttCtrl: any) => void;<EOL>} {<EOL>    '<STR_LIT>';<EOL>    return {<EOL>        restrict: '<STR_LIT>',<EOL>        require: '<STR_LIT>',<EOL>        link: function (scope, element, attrs, ganttCtrl) {<EOL>            scope.scope = ganttCtrl.gantt.$scope.$parent;<EOL>            scope.$watch(function () {<EOL>                return scope.$eval(attrs.ganttBindCompileHtml);<EOL>            }, function (value) {<EOL>                element.html(value);<EOL>","gt":"$compile(element.contents())(scope);"}
{"input":"<s> function blurAndScreenshot(msg: string): void {<EOL>","gt":"browser.executeScript(`<STR_LIT>`);"}
{"input":"<s> <EOL>function getBodyActiveStates(elements: ElementArrayFinder): Promise<any> {<EOL>","gt":"return getClassStates(elements, '<STR_LIT>');"}
{"input":"<s> <EOL>function addThemeToAppStyles(options: Schema): (host: Tree) => Tree {<EOL>    return (host: Tree): Tree => {<EOL>        const config: CliConfig = getConfig(host);<EOL>        const themeName: string = options && options.theme ? options.theme : '<STR_LIT>';<EOL>        const","gt":"app: AppConfig = getAppFromConfig(config, '<STR_LIT>');"}
{"input":"<s> function getTouches(event: any, type: string): any[] {<EOL>    if (event.touches == undefined || event.touches.length == <NUM_LIT>) {<EOL>        return [[event], [event]];<EOL>    }<EOL>","gt":"else {"}
{"input":"<s> <EOL>export function _mockNgReduxFactory(): MockNgRedux<any> {<EOL>    return","gt":"mockNgRedux;"}
{"input":"<s> export function convertCommonJsToGoogModuleIfNeeded(host: Es5ProcessorHost, modulesManifest: ModulesManifest, fileName: string, content: string): string {<EOL>    if (!host.googmodule || isDtsFileName(fileName)) {<EOL>        return content;<EOL>    }<EOL>    const {","gt":"output, referencedModules } = processES5(host, fileName, content);"}
{"input":"<s> export function convertCommonJsToGoogModuleIfNeeded(host: Es5ProcessorHost, modulesManifest: ModulesManifest, fileName: string, content: string): string {<EOL>    if (!host.googmodule || isDtsFileName(fileName)) {<EOL>        return content;<EOL>    }<EOL>    const { output, referencedModules } = processES5(host, fileName, content);<EOL>    const moduleName: string = host.pathToModuleName('<STR_LIT>', fileName);<EOL>    modulesManifest.addModule(fileName, moduleName);<EOL>    for (const referenced: string of referencedModules) {<EOL>        modulesManifest.","gt":"addReferencedModule(fileName, referenced);"}
{"input":"<s> <EOL>function synthesizeTrailingComments(sourceFile: ts.SourceFile, node: ts.Node): number {<EOL>    const parent: any = node.parent;<EOL>    const sharesEndWithParent: any = parent && parent.kind !== ts.SyntaxKind.Block &&<EOL>        parent.kind !== ts.SyntaxKind.SourceFile && parent.getEnd() === node.getEnd();<EOL>    if (","gt":"sharesEndWithParent) {"}
{"input":"<s> <EOL>function synthesizeTrailingComments(sourceFile: ts.SourceFile, node: ts.Node): number {<EOL>    const parent: any = node.parent;<EOL>    const sharesEndWithParent: any = parent && parent.kind !== ts.SyntaxKind.Block &&<EOL>        parent.kind !== ts.SyntaxKind.SourceFile && parent.getEnd() === node.getEnd();<EOL>    if (sharesEndWithParent) {<EOL>        return -<NUM_LIT>;<EOL>    }<EOL>    const trailingComments: any = ts.getTrailingCommentRanges(sourceFile.text, node.getEnd());<EOL>    if (trailingComments && trailingComments.length) {<EOL>        ts.setSyntheticTrailingComments(node, synthesizeCommentRanges(sourceFile, trailingComments));<EOL>        return trailingComments[trailingComments.","gt":"length - <NUM_LIT>].end;"}
{"input":"<s> export function annotate(typeChecker: ts.TypeChecker, file: ts.SourceFile, host: AnnotatorHost, tsHost: ts.ModuleResolutionHost, tsOpts: ts.CompilerOptions, sourceMapper?: SourceMapper): {<EOL>    output: string;<EOL>    diagnostics: ts.Diagnostic[];<EOL>} {<EOL>    return new Annotator(typeChecker, file, host, tsHost,","gt":"tsOpts, sourceMapper).annotate();"}
{"input":"<s> <EOL>export function getGeneratedExterns(externs: {<EOL>    [fileName: string]: string;<EOL>}): string {<EOL>    let allExterns: string = EXTERNS_HEADER;<EOL>    for (const fileName: string","gt":"of Object.keys(externs)) {"}
{"input":"<s> <EOL>function isAmbient(node: ts.Node): boolean {<EOL>    let current: ts.Node | undefined = node;<EOL>    while (current) {<EOL>        if (hasModifierFlag(","gt":"current, ts.ModifierFlags.Ambient))"}
{"input":"<s> export function findFileContentsByName(filename: string, files: Map<string, string>): string {<EOL>    for (const filepath: string of files.keys()) {<EOL>        if (path.parse(filepath).base === path.parse(filename).base) {<EOL>            return files.get(","gt":"filepath)!;"}
{"input":"<s> <EOL>export function ng1ViewsBuilder(state: StateObject): {<EOL>    [key: string]: Ng1ViewDeclaration;<EOL>} {<EOL>    <EOL>    if (!state.parent)<EOL>        return {};<EOL>    const tplKeys:","gt":"string[] = ['<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>'], ctrlKeys: string[] = ['<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>'], compKeys: string[] = ['<STR_LIT>', '<STR_LIT>', '<STR_LIT>'], nonCompKeys: string[] = tplKeys.concat(ctrlKeys), allViewKeys: string[] = compKeys.concat(nonCompKeys);"}
{"input":"<s> <EOL>export function ng1ViewsBuilder(state: StateObject): {<EOL>    [key: string]: Ng1ViewDeclaration;<EOL>} {<EOL>    <EOL>    if (!state.parent)<EOL>        return {};<EOL>    const tplKeys: string[] = ['<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>'], ctrlKeys: string[] = ['<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>'], compKeys: string[] = ['<STR_LIT>', '<STR_LIT>', '<STR_LIT>'], nonCompKeys: string[] = tplKeys.concat(ctrlKeys), allViewKeys: string[] = compKeys.concat(nonCompKeys);<EOL>    <EOL>    <EOL>    <EOL>    if (isDefined(state.views) && hasAnyKey(allViewKeys, state)) {<EOL>        throw new Error(`<STR_LIT>` +<EOL>            `<STR_LIT>` +<EOL>            `<STR_LIT>` +<EOL>","gt":"key])).join('<STR_LIT>')}`<STR_LIT>;"}
{"input":"<s> <EOL>export function ng1ViewsBuilder(state: StateObject): {<EOL>    [key: string]: Ng1ViewDeclaration;<EOL>} {<EOL>    <EOL>    if (!state.parent)<EOL>        return {};<EOL>    const tplKeys: string[] = ['<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>'], ctrlKeys: string[] = ['<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>'], compKeys: string[] = ['<STR_LIT>', '<STR_LIT>', '<STR_LIT>'], nonCompKeys: string[] = tplKeys.concat(ctrlKeys), allViewKeys: string[] = compKeys.concat(nonCompKeys);<EOL>    <EOL>    <EOL>    <EOL>    if (isDefined(state.views) && hasAnyKey(allViewKeys, state)) {<EOL>        throw new Error(`<STR_LIT>` +<EOL>            `<STR_LIT>` +<EOL>            `<STR_LIT>` +<EOL>            `<STR_LIT>`);<EOL>    }<EOL>    const views: {<EOL>        [key: string]: Ng1ViewDeclaration;<EOL>    } = {}, viewsObject: any = state.views || {","gt":"'<STR_LIT>': pick(state, allViewKeys) };"}
{"input":"<s> <EOL>export function ng1ViewsBuilder(state: StateObject): {<EOL>    [key: string]: Ng1ViewDeclaration;<EOL>} {<EOL>    <EOL>    if (!state.parent)<EOL>        return {};<EOL>    const tplKeys: string[] = ['<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>'], ctrlKeys: string[] = ['<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>'], compKeys: string[] = ['<STR_LIT>', '<STR_LIT>', '<STR_LIT>'], nonCompKeys: string[] = tplKeys.concat(ctrlKeys), allViewKeys: string[] = compKeys.concat(nonCompKeys);<EOL>    <EOL>    <EOL>    <EOL>    if (isDefined(state.views) && hasAnyKey(allViewKeys, state)) {<EOL>        throw new Error(`<STR_LIT>` +<EOL>            `<STR_LIT>` +<EOL>            `<STR_LIT>` +<EOL>            `<STR_LIT>`);<EOL>    }<EOL>    const views: {<EOL>        [key: string]: Ng1ViewDeclaration;<EOL>    } = {}, viewsObject: any = state.views || { '<STR_LIT>': pick(state, allViewKeys) };<EOL>    forEach(viewsObject, function (config: Ng1ViewDeclaration, name: string) {<EOL>        <EOL>        name = name || '<STR_LIT>';<EOL>        <EOL>","gt":"if (isString(config))"}
{"input":"<s> <EOL>export function ng1ViewsBuilder(state: StateObject): {<EOL>    [key: string]: Ng1ViewDeclaration;<EOL>} {<EOL>    <EOL>    if (!state.parent)<EOL>        return {};<EOL>    const tplKeys: string[] = ['<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>'], ctrlKeys: string[] = ['<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>'], compKeys: string[] = ['<STR_LIT>', '<STR_LIT>', '<STR_LIT>'], nonCompKeys: string[] = tplKeys.concat(ctrlKeys), allViewKeys: string[] = compKeys.concat(nonCompKeys);<EOL>    <EOL>    <EOL>    <EOL>    if (isDefined(state.views) && hasAnyKey(allViewKeys, state)) {<EOL>        throw new Error(`<STR_LIT>` +<EOL>            `<STR_LIT>` +<EOL>            `<STR_LIT>` +<EOL>            `<STR_LIT>`);<EOL>    }<EOL>    const views: {<EOL>        [key: string]: Ng1ViewDeclaration;<EOL>    } = {}, viewsObject: any = state.views || { '<STR_LIT>': pick(state, allViewKeys) };<EOL>    forEach(viewsObject, function (config: Ng1ViewDeclaration, name: string) {<EOL>        <EOL>        name = name || '<STR_LIT>';<EOL>        <EOL>        if (isString(config))<EOL>            config = { component: <string>config };<EOL>        <EOL>        config = extend({}, config);<EOL>        <EOL>        if (hasAnyKey(compKeys, config) && hasAnyKey(nonCompKeys, config)) {<EOL>            throw new Error(`<STR_LIT>`);<EOL>        }<EOL>        config.resolveAs = config.","gt":"resolveAs || '<STR_LIT>';"}
{"input":"<s> function filter<T>(array: T[], f: (x: T) => boolean): T[] {<EOL>    if (array) {<EOL>        const len: number = array.length;<EOL>        let i: number = <NUM_LIT>;<EOL>        while (i < len && f(array[i]))<EOL>            i++;<EOL>        if (","gt":"i < len) {"}
{"input":"<s> function filter<T>(array: T[], f: (x: T) => boolean): T[] {<EOL>    if (array) {<EOL>        const len: number = array.length;<EOL>        let i: number = <NUM_LIT>;<EOL>        while (i < len && f(array[i]))<EOL>            i++;<EOL>        if (i < len) {<EOL>            const result: T[] = array.slice(<NUM_LIT>, i);<EOL>            i++;<EOL>            while (i < len) {<EOL>                const item: T = array[i];<EOL>                if (","gt":"f(item)) {"}
{"input":"<s> function help(): void {<EOL>    console.log(","gt":"'<STR_LIT>');"}
{"input":"<s> function detachedRun(options: Options): void {<EOL>    var file: any = path.resolve(__dirname, '<STR_LIT>', '<STR_LIT>');<EOL>    var oldSignal: string = options[Opt.STARTED_SIGNIFIER].getString();<EOL>    var","gt":"oldViaIPC: boolean = options[Opt.SIGNAL_VIA_IPC].getBoolean();"}
{"input":"<s> function detachedRun(options: Options): void {<EOL>    var file: any = path.resolve(__dirname, '<STR_LIT>', '<STR_LIT>');<EOL>    var oldSignal: string = options[Opt.STARTED_SIGNIFIER].getString();<EOL>    var oldViaIPC: boolean = options[Opt.SIGNAL_VIA_IPC].getBoolean();<EOL>    options[Opt.DETACH].value = false;<EOL>    options[Opt.STARTED_SIGNIFIER].value = '<STR_LIT>';<EOL>    options[","gt":"Opt.SIGNAL_VIA_IPC].value = true;"}
{"input":"<s> function detachedRun(options: Options): void {<EOL>    var file: any = path.resolve(__dirname, '<STR_LIT>', '<STR_LIT>');<EOL>    var oldSignal: string = options[Opt.STARTED_SIGNIFIER].getString();<EOL>    var oldViaIPC: boolean = options[Opt.SIGNAL_VIA_IPC].getBoolean();<EOL>    options[Opt.DETACH].value = false;<EOL>    options[Opt.STARTED_SIGNIFIER].value = '<STR_LIT>';<EOL>    options[Opt.SIGNAL_VIA_IPC].value = true;<EOL>    let args: string[] = [file, commandName].concat(unparseOptions(options));<EOL>    var unreffed: boolean = false;<EOL>    let child: child_process.ChildProcess = spawn(process.execPath, args, ['<STR_LIT>', <NUM_LIT>, <NUM_LIT>, '<STR_LIT>']);<EOL>    child.on(","gt":"'<STR_LIT>', (message: string): void => {"}
{"input":"<s> function detachedRun(options: Options): void {<EOL>    var file: any = path.resolve(__dirname, '<STR_LIT>', '<STR_LIT>');<EOL>    var oldSignal: string = options[Opt.STARTED_SIGNIFIER].getString();<EOL>    var oldViaIPC: boolean = options[Opt.SIGNAL_VIA_IPC].getBoolean();<EOL>    options[Opt.DETACH].value = false;<EOL>    options[Opt.STARTED_SIGNIFIER].value = '<STR_LIT>';<EOL>    options[Opt.SIGNAL_VIA_IPC].value = true;<EOL>    let args: string[] = [file, commandName].concat(unparseOptions(options));<EOL>    var unreffed: boolean = false;<EOL>    let child: child_process.ChildProcess = spawn(process.execPath, args, ['<STR_LIT>', <NUM_LIT>, <NUM_LIT>, '<STR_LIT>']);<EOL>    child.on('<STR_LIT>', (message: string): void => {<EOL>        if (message == options[Opt.STARTED_SIGNIFIER].getString()) {<EOL>            if (oldSignal) {<EOL>","gt":"sendStartedSignal(oldSignal, oldViaIPC);"}
{"input":"<s> function detachedRun(options: Options): void {<EOL>    var file: any = path.resolve(__dirname, '<STR_LIT>', '<STR_LIT>');<EOL>    var oldSignal: string = options[Opt.STARTED_SIGNIFIER].getString();<EOL>    var oldViaIPC: boolean = options[Opt.SIGNAL_VIA_IPC].getBoolean();<EOL>    options[Opt.DETACH].value = false;<EOL>    options[Opt.STARTED_SIGNIFIER].value = '<STR_LIT>';<EOL>    options[Opt.SIGNAL_VIA_IPC].value = true;<EOL>    let args: string[] = [file, commandName].concat(unparseOptions(options));<EOL>    var unreffed: boolean = false;<EOL>    let child: child_process.ChildProcess = spawn(process.execPath, args, ['<STR_LIT>', <NUM_LIT>, <NUM_LIT>, '<STR_LIT>']);<EOL>    child.on('<STR_LIT>', (message: string): void => {<EOL>        if (message == options[Opt.STARTED_SIGNIFIER].getString()) {<EOL>            if (oldSignal) {<EOL>                sendStartedSignal(oldSignal, oldViaIPC);<EOL>            }<EOL>            logger.info('<STR_LIT>' + child.pid);<EOL>            child.disconnect();<EOL>","gt":"child.unref();"}
{"input":"<s> function detachedRun(options: Options): void {<EOL>    var file: any = path.resolve(__dirname, '<STR_LIT>', '<STR_LIT>');<EOL>    var oldSignal: string = options[Opt.STARTED_SIGNIFIER].getString();<EOL>    var oldViaIPC: boolean = options[Opt.SIGNAL_VIA_IPC].getBoolean();<EOL>    options[Opt.DETACH].value = false;<EOL>    options[Opt.STARTED_SIGNIFIER].value = '<STR_LIT>';<EOL>    options[Opt.SIGNAL_VIA_IPC].value = true;<EOL>    let args: string[] = [file, commandName].concat(unparseOptions(options));<EOL>    var unreffed: boolean = false;<EOL>    let child: child_process.ChildProcess = spawn(process.execPath, args, ['<STR_LIT>', <NUM_LIT>, <NUM_LIT>, '<STR_LIT>']);<EOL>    child.on('<STR_LIT>', (message: string): void => {<EOL>        if (message == options[Opt.STARTED_SIGNIFIER].getString()) {<EOL>            if (oldSignal) {<EOL>                sendStartedSignal(oldSignal, oldViaIPC);<EOL>            }<EOL>            logger.info('<STR_LIT>' + child.pid);<EOL>            child.disconnect();<EOL>            child.unref();<EOL>            unreffed = true;<EOL>        }<EOL>    });<EOL>    child.on('<STR_LIT>', (code: number): void => {<EOL>        if (!unreffed) {<EOL>            if (code == <NUM_LIT>) {<EOL>                logger.","gt":"warn('<STR_LIT>');"}
{"input":"<s> function canPatchViaPropertyDescriptor(): boolean {<EOL>    if ((isBrowser || isMix) && !ObjectGetOwnPropertyDescriptor(HTMLElement.prototype, '<STR_LIT>') &&<EOL>","gt":"typeof Element !== '<STR_LIT>') {"}
{"input":"<s> function canPatchViaPropertyDescriptor(): boolean {<EOL>    if ((isBrowser || isMix) && !ObjectGetOwnPropertyDescriptor(HTMLElement.prototype, '<STR_LIT>') &&<EOL>        typeof Element !== '<STR_LIT>') {<EOL>        <EOL>        <EOL>        const desc: PropertyDescriptor = ObjectGetOwnPropertyDescriptor(Element.prototype,","gt":"'<STR_LIT>');"}
{"input":"<s> function canPatchViaPropertyDescriptor(): boolean {<EOL>    if ((isBrowser || isMix) && !ObjectGetOwnPropertyDescriptor(HTMLElement.prototype, '<STR_LIT>') &&<EOL>        typeof Element !== '<STR_LIT>') {<EOL>        <EOL>        <EOL>        const desc: PropertyDescriptor = ObjectGetOwnPropertyDescriptor(Element.prototype, '<STR_LIT>');<EOL>        if (desc && !desc.configurable)<EOL>            return","gt":"false;"}
{"input":"<s> function canPatchViaPropertyDescriptor(): boolean {<EOL>    if ((isBrowser || isMix) && !ObjectGetOwnPropertyDescriptor(HTMLElement.prototype, '<STR_LIT>') &&<EOL>        typeof Element !== '<STR_LIT>') {<EOL>        <EOL>        <EOL>        const desc: PropertyDescriptor = ObjectGetOwnPropertyDescriptor(Element.prototype, '<STR_LIT>');<EOL>        if (desc && !desc.configurable)<EOL>            return false;<EOL>    }<EOL>    const ON_READY_STATE_CHANGE: string = '<STR_LIT>';<EOL>","gt":"const XMLHttpRequestPrototype: XMLHttpRequest = XMLHttpRequest.prototype;"}
{"input":"<s> function canPatchViaPropertyDescriptor(): boolean {<EOL>    if ((isBrowser || isMix) && !ObjectGetOwnPropertyDescriptor(HTMLElement.prototype, '<STR_LIT>') &&<EOL>        typeof Element !== '<STR_LIT>') {<EOL>        <EOL>        <EOL>        const desc: PropertyDescriptor = ObjectGetOwnPropertyDescriptor(Element.prototype, '<STR_LIT>');<EOL>        if (desc && !desc.configurable)<EOL>            return false;<EOL>    }<EOL>    const ON_READY_STATE_CHANGE: string = '<STR_LIT>';<EOL>    const XMLHttpRequestPrototype: XMLHttpRequest = XMLHttpRequest.prototype;<EOL>    const xhrDesc: PropertyDescriptor = ObjectGetOwnPropertyDescriptor(XMLHttpRequestPrototype, ON_READY_STATE_CHANGE);<EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    if (xhrDesc) {<EOL>        ObjectDefineProperty(XMLHttpRequestPrototype, ON_READY_STATE_CHANGE, {<EOL>            enumerable:","gt":"true,"}
{"input":"<s> function canPatchViaPropertyDescriptor(): boolean {<EOL>    if ((isBrowser || isMix) && !ObjectGetOwnPropertyDescriptor(HTMLElement.prototype, '<STR_LIT>') &&<EOL>        typeof Element !== '<STR_LIT>') {<EOL>        <EOL>        <EOL>        const desc: PropertyDescriptor = ObjectGetOwnPropertyDescriptor(Element.prototype, '<STR_LIT>');<EOL>        if (desc && !desc.configurable)<EOL>            return false;<EOL>    }<EOL>    const ON_READY_STATE_CHANGE: string = '<STR_LIT>';<EOL>    const XMLHttpRequestPrototype: XMLHttpRequest = XMLHttpRequest.prototype;<EOL>    const xhrDesc: PropertyDescriptor = ObjectGetOwnPropertyDescriptor(XMLHttpRequestPrototype, ON_READY_STATE_CHANGE);<EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    if (xhrDesc) {<EOL>        ObjectDefineProperty(XMLHttpRequestPrototype, ON_READY_STATE_CHANGE, {<EOL>            enumerable: true,<EOL>            configurable: true,<EOL>            get: function () {<EOL>                return true;<EOL>            }<EOL>        });<EOL>        const req: XMLHttpRequest = new","gt":"XMLHttpRequest();"}
{"input":"<s> function canPatchViaPropertyDescriptor(): boolean {<EOL>    if ((isBrowser || isMix) && !ObjectGetOwnPropertyDescriptor(HTMLElement.prototype, '<STR_LIT>') &&<EOL>        typeof Element !== '<STR_LIT>') {<EOL>        <EOL>        <EOL>        const desc: PropertyDescriptor = ObjectGetOwnPropertyDescriptor(Element.prototype, '<STR_LIT>');<EOL>        if (desc && !desc.configurable)<EOL>            return false;<EOL>    }<EOL>    const ON_READY_STATE_CHANGE: string = '<STR_LIT>';<EOL>    const XMLHttpRequestPrototype: XMLHttpRequest = XMLHttpRequest.prototype;<EOL>    const xhrDesc: PropertyDescriptor = ObjectGetOwnPropertyDescriptor(XMLHttpRequestPrototype, ON_READY_STATE_CHANGE);<EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    if (xhrDesc) {<EOL>        ObjectDefineProperty(XMLHttpRequestPrototype, ON_READY_STATE_CHANGE, {<EOL>            enumerable: true,<EOL>            configurable: true,<EOL>            get: function () {<EOL>                return true;<EOL>            }<EOL>        });<EOL>        const req: XMLHttpRequest = new XMLHttpRequest();<EOL>        const result: boolean = !!req.onreadystatechange;<EOL>        <EOL>        ObjectDefineProperty(XMLHttpRequestPrototype, ON_READY_STATE_CHANGE, xhrDesc || {});<EOL>        return result;<EOL>    }<EOL>    else {<EOL>        const SYMBOL_FAKE_ONREADYSTATECHANGE: string = zoneSymbol('<STR_LIT>');<EOL>        ObjectDefineProperty(XMLHttpRequestPrototype, ON_READY_STATE_CHANGE, {<EOL>            enumerable: true,<EOL>            configurable: true,<EOL>            get: function () {<EOL>","gt":"return this[SYMBOL_FAKE_ONREADYSTATECHANGE];"}
{"input":"<s> function canPatchViaPropertyDescriptor(): boolean {<EOL>    if ((isBrowser || isMix) && !ObjectGetOwnPropertyDescriptor(HTMLElement.prototype, '<STR_LIT>') &&<EOL>        typeof Element !== '<STR_LIT>') {<EOL>        <EOL>        <EOL>        const desc: PropertyDescriptor = ObjectGetOwnPropertyDescriptor(Element.prototype, '<STR_LIT>');<EOL>        if (desc && !desc.configurable)<EOL>            return false;<EOL>    }<EOL>    const ON_READY_STATE_CHANGE: string = '<STR_LIT>';<EOL>    const XMLHttpRequestPrototype: XMLHttpRequest = XMLHttpRequest.prototype;<EOL>    const xhrDesc: PropertyDescriptor = ObjectGetOwnPropertyDescriptor(XMLHttpRequestPrototype, ON_READY_STATE_CHANGE);<EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    if (xhrDesc) {<EOL>        ObjectDefineProperty(XMLHttpRequestPrototype, ON_READY_STATE_CHANGE, {<EOL>            enumerable: true,<EOL>            configurable: true,<EOL>            get: function () {<EOL>                return true;<EOL>            }<EOL>        });<EOL>        const req: XMLHttpRequest = new XMLHttpRequest();<EOL>        const result: boolean = !!req.onreadystatechange;<EOL>        <EOL>        ObjectDefineProperty(XMLHttpRequestPrototype, ON_READY_STATE_CHANGE, xhrDesc || {});<EOL>        return result;<EOL>    }<EOL>    else {<EOL>        const SYMBOL_FAKE_ONREADYSTATECHANGE: string = zoneSymbol('<STR_LIT>');<EOL>        ObjectDefineProperty(XMLHttpRequestPrototype, ON_READY_STATE_CHANGE, {<EOL>            enumerable: true,<EOL>            configurable: true,<EOL>            get: function () {<EOL>                return this[SYMBOL_FAKE_ONREADYSTATECHANGE];<EOL>            },<EOL>            set: function (value) {<EOL>                this[SYMBOL_FAKE_ONREADYSTATECHANGE] = value;<EOL>            }<EOL>        });<EOL>","gt":"const req: XMLHttpRequest = new XMLHttpRequest();"}
{"input":"<s> export function bindArguments(args: any[], source: string): any[] {<EOL>    for (let i: number = args.length - <NUM_LIT>; i >= <NUM_LIT>; i--) {<EOL>        if (typeof args[","gt":"i] === '<STR_LIT>') {"}
{"input":"<s> export function wrapWithCurrentZone<T extends Function>(callback: T, source: string): T {<EOL>    return Zone.current.wrap(callback,","gt":"source);"}
{"input":"<s> function ieOrEdge(): boolean {<EOL>","gt":"return isIEOrEdge();"}
{"input":"<s> function supportsImports(): boolean {<EOL>    return '<STR_LIT>'","gt":"in document.createElement('<STR_LIT>');"}
{"input":"<s> function _ifEnvSupports(test: any, block: Function, withDone: boolean = false): (done?: Function) => void {<EOL>    if (withDone) {<EOL>        return function (done?: Function) {<EOL>            _runTest(test, block, done);<EOL>        };<EOL>    }<EOL>    else {<EOL>        return function () {<EOL>            _runTest(","gt":"test, block, undefined);"}
{"input":"<s> function supportNode(): boolean {<EOL>","gt":"return isNode;"}
{"input":"<s> function requestFactory(url: any, headersObj: any): (query: any, variables?: any, operationName?: any, forwardHeaders?: any) => any {<EOL>    return (query: any, variables?: any, operationName?: any, forwardHeaders?: any): any => {<EOL>        return fetch(url, {<EOL>            method: '<STR_LIT>',<EOL>            headers: new","gt":"Headers({"}
{"input":"<s> function requestFactory(url: any, headersObj: any): (query: any, variables?: any, operationName?: any, forwardHeaders?: any) => any {<EOL>    return (query: any, variables?: any, operationName?: any, forwardHeaders?: any): any => {<EOL>        return fetch(url, {<EOL>            method: '<STR_LIT>',<EOL>            headers: new Headers({<EOL>                \"<STR_LIT>\": '<STR_LIT>',<EOL>                ...headersObj,<EOL>                ...","gt":"forwardHeaders,"}
{"input":"<s> function requestFactory(url: any, headersObj: any): (query: any, variables?: any, operationName?: any, forwardHeaders?: any) => any {<EOL>    return (query: any, variables?: any, operationName?: any, forwardHeaders?: any): any => {<EOL>        return fetch(url, {<EOL>            method: '<STR_LIT>',<EOL>            headers: new Headers({<EOL>                \"<STR_LIT>\": '<STR_LIT>',<EOL>                ...headersObj,<EOL>                ...forwardHeaders,<EOL>            }),<EOL>            body: JSON.stringify({<EOL>                operationName,<EOL>                query,<EOL>","gt":"variables,"}
{"input":"<s> function requestFactory(url: any, headersObj: any): (query: any, variables?: any, operationName?: any, forwardHeaders?: any) => any {<EOL>    return (query: any, variables?: any, operationName?: any, forwardHeaders?: any): any => {<EOL>        return fetch(url, {<EOL>            method: '<STR_LIT>',<EOL>            headers: new Headers({<EOL>                \"<STR_LIT>\": '<STR_LIT>',<EOL>                ...headersObj,<EOL>                ...forwardHeaders,<EOL>            }),<EOL>            body: JSON.stringify({<EOL>                operationName,<EOL>                query,<EOL>                variables,<EOL>            })<EOL>        }).then((responce: any): any => {<EOL>            if (responce.ok)<EOL>                return responce.","gt":"json();"}
{"input":"<s> function isLink(elem: Element): boolean {<EOL>    return elem.classList.contains(","gt":"'<STR_LIT>');"}
{"input":"<s> export function configureStore(preloadedState?): Store<any> {<EOL>    let composeEnhancers: any;<EOL>    if (DEBUG) {<EOL>        composeEnhancers = window[","gt":"'<STR_LIT>'] || compose;"}
{"input":"<s> <EOL>export function variablesInOperation(operation: OperationDefinitionNode): Set<string> {<EOL>    const names: Set<string> = new Set<string>();<EOL>    if (operation.variableDefinitions) {<EOL>        for (const definition: any","gt":"of operation.variableDefinitions) {"}
{"input":"<s> function buildWareStack<M>(funcs: WareStack, modifiedObject: M, resolve: any): void {<EOL>    const next: () => void = (): void => {<EOL>        if (funcs.length > <NUM_LIT>) {<EOL>            const f: MiddlewareInterface | BatchMiddlewareInterface | AfterwareInterface = funcs.shift();<EOL>            if (","gt":"f) {"}
{"input":"<s> function addErrorLoggingToSchema(schema: GraphQLSchema, logger: ILogger): void {<EOL>    if (!logger) {<EOL>        throw new Error('<STR_LIT>');<EOL>    }<EOL>","gt":"if (typeof logger.log !== '<STR_LIT>') {"}
{"input":"<s> function addErrorLoggingToSchema(schema: GraphQLSchema, logger: ILogger): void {<EOL>    if (!logger) {<EOL>        throw new Error('<STR_LIT>');<EOL>    }<EOL>    if (typeof logger.log !== '<STR_LIT>') {<EOL>        throw new Error('<STR_LIT>');<EOL>    }<EOL>    forEachField(schema, (field: GraphQLField<any, any>, typeName: string, fieldName: string): void => {<EOL>        const errorHint: string =","gt":"typeName}.${fieldName}`<STR_LIT>;"}
{"input":"<s> function assertResolveFunctionsPresent(schema: GraphQLSchema, resolverValidationOptions: IResolverValidationOptions = {}): void {<EOL>    const { requireResolversForArgs = false, requireResolversForNonScalar = false, requireResolversForAllFields = false, } = resolverValidationOptions;<EOL>    if (requireResolversForAllFields &&<EOL>        (requireResolversForArgs || requireResolversForNonScalar)) {<EOL>        throw new TypeError('<STR_LIT>' +<EOL>","gt":"'<STR_LIT>' +"}
{"input":"<s> export function extractExtensionDefinitions(ast: DocumentNode): any {<EOL>    const extensionDefs: any = ast.definitions.filter((def: DefinitionNode): boolean => def.kind === oldTypeExtensionDefinitionKind ||<EOL>        (def.kind","gt":"as any) === newExtensionDefinitionKind);"}
{"input":"<s> <EOL><EOL>function makePromise<R>(observable: Observable<R>): Promise<R> {<EOL>    let completed: boolean = false;<EOL>    return new Promise<R>((resolve: (value: R | PromiseLike<R>) => void, reject: (reason?: any) => void): void => {<EOL>        observable.subscribe({<EOL>            next: (data: any): void => {<EOL>                if (","gt":"completed) {"}
{"input":"<s> <EOL><EOL>function makePromise<R>(observable: Observable<R>): Promise<R> {<EOL>    let completed: boolean = false;<EOL>    return new Promise<R>((resolve: (value: R | PromiseLike<R>) => void, reject: (reason?: any) => void): void => {<EOL>        observable.subscribe({<EOL>            next: (data: any): void => {<EOL>                if (completed) {<EOL>                    console.warn(`<STR_LIT>`);<EOL>                }<EOL>                else {<EOL>","gt":"completed = true;"}
{"input":"<s> <EOL>export function isIOS(): boolean {<EOL>    if (typeof window !== '<STR_LIT>' && typeof navigator !== '<STR_LIT>') {<EOL>        return /iPad|iPhone|iPod/.test(navigator.userAgent) && !(","gt":"window as any).MSStream;"}
{"input":"<s> <EOL><EOL><EOL><EOL><EOL><EOL>export function decodeTag(token: Token): string | null {<EOL>    if (token.tag === '<STR_LIT>') {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>","gt":"if (token.tag === '<STR_LIT>') {"}
{"input":"<s> <EOL><EOL><EOL><EOL><EOL><EOL>export function decodeTag(token: Token): string | null {<EOL>    if (token.tag === '<STR_LIT>') {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    if (token.tag === '<STR_LIT>') {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    if (token.tag === '<STR_LIT>') {<EOL>","gt":"return null;"}
{"input":"<s> export function mkHtml(title: string, html: HTMLDocument, renderLaTeX: boolean, useGithubStyle: boolean): string {<EOL>    const githubStyle: string = useGithubStyle ? '<STR_LIT>' : '<STR_LIT>';<EOL>    let maybeMathJaxScript: any;<EOL>    if (","gt":"renderLaTeX) {"}
{"input":"<s> <EOL>function getUserMacrosPath(): string {<EOL>    const userMacrosPath: string | undefined | null = CSON.resolve(path.join(atom.getConfigDirPath(), '<STR_LIT>'));<EOL>    return","gt":"userMacrosPath != null"}
{"input":"<s> <EOL>export async function renderPandoc(text: string, filePath: string | undefined, renderMath: boolean): Promise<string> {<EOL>    const { args, opts } = setPandocOptions(filePath, renderMath);<EOL>    return new Promise<string>((resolve: (value: string | PromiseLike<string>) => void, reject: (reason?: any) => void): void => {<EOL>        const cp: any = CP.execFile(atomConfig().pandocPath, getArguments(args), opts, function (error, stdout, stderr) {<EOL>","gt":"if (error) {"}
{"input":"<s> <EOL>export async function renderPandoc(text: string, filePath: string | undefined, renderMath: boolean): Promise<string> {<EOL>    const { args, opts } = setPandocOptions(filePath, renderMath);<EOL>    return new Promise<string>((resolve: (value: string | PromiseLike<string>) => void, reject: (reason?: any) => void): void => {<EOL>        const cp: any = CP.execFile(atomConfig().pandocPath, getArguments(args), opts, function (error, stdout, stderr) {<EOL>            if (error) {<EOL>                atom.notifications.addError(error.toString(), {<EOL>                    stack: error.stack,<EOL>","gt":"dismissable: true,"}
{"input":"<s> <EOL>export async function renderPandoc(text: string, filePath: string | undefined, renderMath: boolean): Promise<string> {<EOL>    const { args, opts } = setPandocOptions(filePath, renderMath);<EOL>    return new Promise<string>((resolve: (value: string | PromiseLike<string>) => void, reject: (reason?: any) => void): void => {<EOL>        const cp: any = CP.execFile(atomConfig().pandocPath, getArguments(args), opts, function (error, stdout, stderr) {<EOL>            if (error) {<EOL>                atom.notifications.addError(error.toString(), {<EOL>                    stack: error.stack,<EOL>                    dismissable: true,<EOL>                });<EOL>                reject(error);<EOL>            }<EOL>            try {<EOL>                const result: string = handleResponse(","gt":"stderr || '<STR_LIT>', stdout || '<STR_LIT>', renderMath);"}
{"input":"<s> <EOL>export async function renderPandoc(text: string, filePath: string | undefined, renderMath: boolean): Promise<string> {<EOL>    const { args, opts } = setPandocOptions(filePath, renderMath);<EOL>    return new Promise<string>((resolve: (value: string | PromiseLike<string>) => void, reject: (reason?: any) => void): void => {<EOL>        const cp: any = CP.execFile(atomConfig().pandocPath, getArguments(args), opts, function (error, stdout, stderr) {<EOL>            if (error) {<EOL>                atom.notifications.addError(error.toString(), {<EOL>                    stack: error.stack,<EOL>                    dismissable: true,<EOL>                });<EOL>                reject(error);<EOL>            }<EOL>            try {<EOL>                const result: string = handleResponse(stderr || '<STR_LIT>', stdout || '<STR_LIT>', renderMath);<EOL>                resolve(result);<EOL>            }<EOL>            catch (e: unknown) {<EOL>                reject(","gt":"e);"}
{"input":"<s> export function stringTo32ByteHex(stringToEncode: string): string {<EOL>    return","gt":"<NUM_LIT>, '<STR_LIT>')}`<STR_LIT>;"}
{"input":"<s> <EOL>export function fetchLineItems(state: CheckoutState): any {<EOL>    const ids:","gt":"any = state.lineItemIds.toJS();"}
{"input":"<s> function fetchSelectedTaxonIds(state: SearchState): any {<EOL>    return","gt":"state.selectedTaxonIds.toJS();"}
{"input":"<s> export function reducer(state = initialState, { type, payload }: any): UserState {<EOL>    switch (type) {<EOL>        case UserActions.","gt":"GET_USER_ORDERS_SUCCESS:"}
{"input":"<s> function shallowMerge(existing: any, more: any): any {<EOL>    if (existing && more) {<EOL>        for (const key: string of Object.getOwnPropertyNames(more)) {<EOL>            const value: any = more[key];<EOL>            if (value !== undefined) {<EOL>                <EOL>                existing[key] = value;<EOL>            }<EOL>        }<EOL>        return existing;<EOL>    }<EOL>    if (","gt":"existing) {"}
{"input":"<s> export function isLegacy(args: string[]): boolean {<EOL>    return args.some((arg: string): boolean => regexLegacyArg.test(","gt":"arg));"}
{"input":"<s> export function matches(jsonQuery: string, jsonPath: JsonPath): boolean {<EOL>    <EOL>    const leafNode: Object = new Object();<EOL>    const obj: any = CreateObject(","gt":"jsonPath, leafNode);"}
{"input":"<s> <EOL>function isAbsolute(path: string): boolean {<EOL>","gt":"return !!path.match(/^([a-zA-Z]:)?(\\/|\\\\)/);"}
{"input":"<s> <EOL>export function IsUri(uri: string): boolean {<EOL>    return /^([a-z0-9+.-]+):(?:\\/\\/(?:((?:[a-z0-9-._~!$&'()*+,;=:]|%[0-9A-F]{2})*)@)?((?:[a-z0-9-._~!$&'()*+,;=]|%[0-9A-F]{2})*)(?::(\\d*))?(\\/(?:[a-z0-9-._~!$&'()*+,;=:@/]|%[0-9A-F]{2})*)?|(\\/?(?:[a-z0-9-._~!$&'()*+,;=:@]|%[0-9A-F]{2})+(?:[a-z0-9-._~!$&'()*+,;=:@/]|%[0-9A-F]{2})*)?)(?:\\?((?:[a-z0-9-._~!$&'()*+,;=:/?@]|%[0-9A-F]{2})*))?(?:#((?:[a-z0-9-._~!$&'()*+,;=:/?@]|%[0-9A-F]{2})*))?$/i.test(","gt":"uri);"}
{"input":"<s> export function CreateAssignmentMapping(assignedObject: any, sourceKey: string, sourcePath: JsonPath, targetPath: JsonPath, subject: string): Mappings {<EOL>    const result: Mappings = [];<EOL>    for (const descendant: import(\"<STR_LIT>\").YAMLNodeWithPath of Descendants(ToAst(assignedObject))) {<EOL>        const path: JsonPath = descendant.path;<EOL>        result.","gt":"push({"}
{"input":"<s> <EOL>export async function toJSON(content: string): Promise<string> {<EOL>    await","gt":"ensureCoreLoaded();"}
{"input":"<s> function checkDellTag(tag: string): boolean {<EOL>    tag = tag.toUpperCase();<EOL>    for (let tagItem: string in DellTag) {<EOL>        if (tag === DellTag[","gt":"tagItem]) {"}
{"input":"<s> <EOL>function checkSuffix(serial: string, tag: DellTag, type: SuffixType): number[] {<EOL>    serial = serial.","gt":"concat(tag);"}
{"input":"<s> function makeMonotonicTime(): () => number {<EOL>    if (typeof performance !== \"<STR_LIT>\" && performance) {<EOL>        let nowFun: () => number = performance.now ||<EOL>            performance.webkitNow ||<EOL>            performance.mozNow ||<EOL>            performance.","gt":"oNow ||"}
{"input":"<s> function printAllChildren(node: ts.Node, depth: number = <NUM_LIT>): void {<EOL>    console.log(new Array(depth + <NUM_LIT>).join('<STR_LIT>'),","gt":"ts.syntaxKindToName(node.kind), node.pos, node.end);"}
{"input":"<s> function myApp(): void {<EOL>    import( \"<STR_LIT>\")<EOL>        .then((moment: any): void => {<EOL>        <EOL>        <EOL>        const time: any = moment().format();<EOL>        console.log(\"<STR_LIT>\");<EOL>        console.log(time);<EOL>    })<EOL>        .","gt":"catch((err: any): void => {"}
{"input":"<s> function doNotRun(test: any, done: Function): boolean {<EOL>    if (awsAccessKeyId === undefined || awsSecretAccessKey === undefined) {<EOL>        console.warn(","gt":"\"<STR_LIT>\");"}
{"input":"<s> export function getConfigPath(): string {<EOL>    return process.env.","gt":"NODE_ENV !== '<STR_LIT>' ? `<STR_LIT>` : `<STR_LIT>`;"}
{"input":"<s> export function create(config: BrokerConfigType): BrokerAdapterImpl {<EOL>    return new","gt":"BrokerAdapterImpl(config);"}
{"input":"<s> export default function form(obj: any): any {<EOL>    const form: any = new FormData();<EOL>    if (obj) {<EOL>        Object.keys(obj).forEach(","gt":"function (name) {"}
{"input":"<s> <EOL>export function createTransport(options: Options): TransportOptions {<EOL>    return {<EOL>        use,<EOL>","gt":"abort,"}
{"input":"<s> function auth(username: string, password: string): (req: express.Request, res: express.Response, next: express.NextFunction) => import(\"<STR_LIT>\").Response {<EOL>    return (req: express.Request, res: express.Response, next: express.NextFunction): import(\"<STR_LIT>\").Response => {<EOL>        const user: Credentials = basicAuth(req);<EOL>        if (!user ||","gt":"user.name !== username || user.pass !== password) {"}
{"input":"<s> export function changeDefaultReducer(newReducer: string): void {<EOL>    DEFAULT_REDUCER =","gt":"newReducer;"}
{"input":"<s> function cloneNodeArray(a: IBobrilChildArray): IBobrilChildArray {<EOL>    a = a.slice(<NUM_LIT>);<EOL>    for (var i: number = <NUM_LIT>; i < a.length; i++) {<EOL>        var n: string | number | boolean | IBobrilChildArray | IBobrilNode<any> | null | undefined = a[i];<EOL>        if (isArray(","gt":"n)) {"}
{"input":"<s> export function nodeOnPoint(x: number, y: number): IBobrilCacheNode | undefined {<EOL>    var target: HTMLElement = <HTMLElement>document.elementFromPoint(x, y);<EOL>    var node: IBobrilCacheNode | undefined = deref(target);<EOL>    if (hasPointerEventsNoneB(node)) {<EOL>","gt":"var fixed: ["}
{"input":"<s> export function nodeOnPoint(x: number, y: number): IBobrilCacheNode | undefined {<EOL>    var target: HTMLElement = <HTMLElement>document.elementFromPoint(x, y);<EOL>    var node: IBobrilCacheNode | undefined = deref(target);<EOL>    if (hasPointerEventsNoneB(node)) {<EOL>        var fixed: [<EOL>            Node,<EOL>            IBobrilCacheNode | undefined<EOL>        ] = pointerEventsNoneFix(x, y, target, node);<EOL>        node = fixed[","gt":"<NUM_LIT>];"}
{"input":"<s> function closeDropdown(): void {<EOL>    if ($dropdown) {<EOL>","gt":"PopUpManager.removePopUp($dropdown);"}
{"input":"<s> function closeNotExistingFiles(oldBranchName: any, newBranchName: any): any {<EOL>    return Git.getDeletedFiles(oldBranchName, newBranchName).then((deletedFiles: any): void => {<EOL>        const gitRoot: any = Preferences.get(\"<STR_LIT>\");<EOL>        const openedFiles: any = MainViewManager.getWorkingSet(MainViewManager.ALL_PANES);<EOL>        <EOL>        deletedFiles.forEach((","gt":"dFile: any): void => {"}
{"input":"<s> function closeNotExistingFiles(oldBranchName: any, newBranchName: any): any {<EOL>    return Git.getDeletedFiles(oldBranchName, newBranchName).then((deletedFiles: any): void => {<EOL>        const gitRoot: any = Preferences.get(\"<STR_LIT>\");<EOL>        const openedFiles: any = MainViewManager.getWorkingSet(MainViewManager.ALL_PANES);<EOL>        <EOL>        deletedFiles.forEach((dFile: any): void => {<EOL>            const oFile: any = _.find(openedFiles, (f: any): boolean => f.fullPath === gitRoot + dFile);<EOL>            if (oFile) {<EOL>                DocumentManager.closeFullEditor(oFile);<EOL>            }<EOL>        });<EOL>        EventEmitter.emit(","gt":"Events.REFRESH_ALL);"}
{"input":"<s> export function show(promise: any, title: any = null, options: ShowOptions = {}): any {<EOL>    if (!promise || !promise.finally || !promise.progressed) {<EOL>        throw new Error(\"<STR_LIT>\");<EOL>    }<EOL>    if (typeof title === \"<STR_LIT>\") {<EOL>","gt":"options = title;"}
{"input":"<s> export function show(promise: any, title: any = null, options: ShowOptions = {}): any {<EOL>    if (!promise || !promise.finally || !promise.progressed) {<EOL>        throw new Error(\"<STR_LIT>\");<EOL>    }<EOL>    if (typeof title === \"<STR_LIT>\") {<EOL>        options = title; <EOL>        title = false; <EOL>    }<EOL>    options = options || {}; <EOL>    return new Promise((resolve: any, reject: any): void => {<EOL>","gt":"lines = [];"}
{"input":"<s> export function show(promise: any, title: any = null, options: ShowOptions = {}): any {<EOL>    if (!promise || !promise.finally || !promise.progressed) {<EOL>        throw new Error(\"<STR_LIT>\");<EOL>    }<EOL>    if (typeof title === \"<STR_LIT>\") {<EOL>        options = title; <EOL>        title = false; <EOL>    }<EOL>    options = options || {}; <EOL>    return new Promise((resolve: any, reject: any): void => {<EOL>        lines = [];<EOL>        $textarea =","gt":"null;"}
{"input":"<s> export function show(promise: any, title: any = null, options: ShowOptions = {}): any {<EOL>    if (!promise || !promise.finally || !promise.progressed) {<EOL>        throw new Error(\"<STR_LIT>\");<EOL>    }<EOL>    if (typeof title === \"<STR_LIT>\") {<EOL>        options = title; <EOL>        title = false; <EOL>    }<EOL>    options = options || {}; <EOL>    return new Promise((resolve: any, reject: any): void => {<EOL>        lines = [];<EOL>        $textarea = null;<EOL>        let dialog: any;<EOL>        let finished: boolean = false;<EOL>        function showDialog(): void {<EOL>            if (finished) {<EOL>","gt":"return;"}
{"input":"<s> export function show(promise: any, title: any = null, options: ShowOptions = {}): any {<EOL>    if (!promise || !promise.finally || !promise.progressed) {<EOL>        throw new Error(\"<STR_LIT>\");<EOL>    }<EOL>    if (typeof title === \"<STR_LIT>\") {<EOL>        options = title; <EOL>        title = false; <EOL>    }<EOL>    options = options || {}; <EOL>    return new Promise((resolve: any, reject: any): void => {<EOL>        lines = [];<EOL>        $textarea = null;<EOL>        let dialog: any;<EOL>        let finished: boolean = false;<EOL>        function showDialog(): void {<EOL>            if (finished) {<EOL>                return;<EOL>            }<EOL>            const templateArgs: {<EOL>                title: any;<EOL>                Strings: any;<EOL>            } = { title: title || Strings.OPERATION_IN_PROGRESS_TITLE, Strings };<EOL>            const compiledTemplate: any = Mustache.render(","gt":"template, templateArgs);"}
{"input":"<s> export function show(promise: any, title: any = null, options: ShowOptions = {}): any {<EOL>    if (!promise || !promise.finally || !promise.progressed) {<EOL>        throw new Error(\"<STR_LIT>\");<EOL>    }<EOL>    if (typeof title === \"<STR_LIT>\") {<EOL>        options = title; <EOL>        title = false; <EOL>    }<EOL>    options = options || {}; <EOL>    return new Promise((resolve: any, reject: any): void => {<EOL>        lines = [];<EOL>        $textarea = null;<EOL>        let dialog: any;<EOL>        let finished: boolean = false;<EOL>        function showDialog(): void {<EOL>            if (finished) {<EOL>                return;<EOL>            }<EOL>            const templateArgs: {<EOL>                title: any;<EOL>                Strings: any;<EOL>            } = { title: title || Strings.OPERATION_IN_PROGRESS_TITLE, Strings };<EOL>            const compiledTemplate: any = Mustache.render(template, templateArgs);<EOL>            dialog = Dialogs.showModalDialogUsingTemplate(compiledTemplate);<EOL>            $textarea = dialog.getElement().find(\"<STR_LIT>\");<EOL>            onProgress();<EOL>        }<EOL>        function finish(): void {<EOL>            finished = true;<EOL>","gt":"if (dialog) {"}
{"input":"<s> export function show(promise: any, title: any = null, options: ShowOptions = {}): any {<EOL>    if (!promise || !promise.finally || !promise.progressed) {<EOL>        throw new Error(\"<STR_LIT>\");<EOL>    }<EOL>    if (typeof title === \"<STR_LIT>\") {<EOL>        options = title; <EOL>        title = false; <EOL>    }<EOL>    options = options || {}; <EOL>    return new Promise((resolve: any, reject: any): void => {<EOL>        lines = [];<EOL>        $textarea = null;<EOL>        let dialog: any;<EOL>        let finished: boolean = false;<EOL>        function showDialog(): void {<EOL>            if (finished) {<EOL>                return;<EOL>            }<EOL>            const templateArgs: {<EOL>                title: any;<EOL>                Strings: any;<EOL>            } = { title: title || Strings.OPERATION_IN_PROGRESS_TITLE, Strings };<EOL>            const compiledTemplate: any = Mustache.render(template, templateArgs);<EOL>            dialog = Dialogs.showModalDialogUsingTemplate(compiledTemplate);<EOL>            $textarea = dialog.getElement().find(\"<STR_LIT>\");<EOL>            onProgress();<EOL>        }<EOL>        function finish(): void {<EOL>            finished = true;<EOL>            if (dialog) {<EOL>                dialog.close();<EOL>            }<EOL>            promise<EOL>                .then((val: any): any => resolve(val))<EOL>                .catch((err: any): any => reject(err));<EOL>        }<EOL>        if (!options.preDelay) {<EOL>            showDialog();<EOL>        }<EOL>        else {<EOL>            setTimeout((): void => showDialog(), options.","gt":"preDelay * <NUM_LIT>);"}
{"input":"<s> export function show(promise: any, title: any = null, options: ShowOptions = {}): any {<EOL>    if (!promise || !promise.finally || !promise.progressed) {<EOL>        throw new Error(\"<STR_LIT>\");<EOL>    }<EOL>    if (typeof title === \"<STR_LIT>\") {<EOL>        options = title; <EOL>        title = false; <EOL>    }<EOL>    options = options || {}; <EOL>    return new Promise((resolve: any, reject: any): void => {<EOL>        lines = [];<EOL>        $textarea = null;<EOL>        let dialog: any;<EOL>        let finished: boolean = false;<EOL>        function showDialog(): void {<EOL>            if (finished) {<EOL>                return;<EOL>            }<EOL>            const templateArgs: {<EOL>                title: any;<EOL>                Strings: any;<EOL>            } = { title: title || Strings.OPERATION_IN_PROGRESS_TITLE, Strings };<EOL>            const compiledTemplate: any = Mustache.render(template, templateArgs);<EOL>            dialog = Dialogs.showModalDialogUsingTemplate(compiledTemplate);<EOL>            $textarea = dialog.getElement().find(\"<STR_LIT>\");<EOL>            onProgress();<EOL>        }<EOL>        function finish(): void {<EOL>            finished = true;<EOL>            if (dialog) {<EOL>                dialog.close();<EOL>            }<EOL>            promise<EOL>                .then((val: any): any => resolve(val))<EOL>                .catch((err: any): any => reject(err));<EOL>        }<EOL>        if (!options.preDelay) {<EOL>            showDialog();<EOL>        }<EOL>        else {<EOL>            setTimeout((): void => showDialog(), options.preDelay * <NUM_LIT>);<EOL>        }<EOL>        promise<EOL>            .progressed((string: any): void => onProgress(string))<EOL>            .","gt":"finally((): void => {"}
{"input":"<s> export function show(promise: any, title: any = null, options: ShowOptions = {}): any {<EOL>    if (!promise || !promise.finally || !promise.progressed) {<EOL>        throw new Error(\"<STR_LIT>\");<EOL>    }<EOL>    if (typeof title === \"<STR_LIT>\") {<EOL>        options = title; <EOL>        title = false; <EOL>    }<EOL>    options = options || {}; <EOL>    return new Promise((resolve: any, reject: any): void => {<EOL>        lines = [];<EOL>        $textarea = null;<EOL>        let dialog: any;<EOL>        let finished: boolean = false;<EOL>        function showDialog(): void {<EOL>            if (finished) {<EOL>                return;<EOL>            }<EOL>            const templateArgs: {<EOL>                title: any;<EOL>                Strings: any;<EOL>            } = { title: title || Strings.OPERATION_IN_PROGRESS_TITLE, Strings };<EOL>            const compiledTemplate: any = Mustache.render(template, templateArgs);<EOL>            dialog = Dialogs.showModalDialogUsingTemplate(compiledTemplate);<EOL>            $textarea = dialog.getElement().find(\"<STR_LIT>\");<EOL>            onProgress();<EOL>        }<EOL>        function finish(): void {<EOL>            finished = true;<EOL>            if (dialog) {<EOL>                dialog.close();<EOL>            }<EOL>            promise<EOL>                .then((val: any): any => resolve(val))<EOL>                .catch((err: any): any => reject(err));<EOL>        }<EOL>        if (!options.preDelay) {<EOL>            showDialog();<EOL>        }<EOL>        else {<EOL>            setTimeout((): void => showDialog(), options.preDelay * <NUM_LIT>);<EOL>        }<EOL>        promise<EOL>            .progressed((string: any): void => onProgress(string))<EOL>            .finally((): void => {<EOL>            onProgress(\"<STR_LIT>\");<EOL>            if (!options.postDelay || !dialog) {<EOL>","gt":"finish();"}
{"input":"<s> export function isTimeout(err: any): boolean {<EOL>    return err instanceof Error && (err.","gt":"message.indexOf(\"<STR_LIT>\") === <NUM_LIT> ||"}
{"input":"<s> <EOL>function loadRegistryInfo(): any {<EOL>    const registryInfo: any = ExtensionManager.extensions[packageJson.name].registryInfo;<EOL>","gt":"if (!registryInfo) {"}
{"input":"<s> export function difftool(file: any): any {<EOL>    return _isFileStaged(file).then((staged: any): Promise<string> => {<EOL>        const args: string[] = [\"<STR_LIT>\"];<EOL>        if (staged) {<EOL>","gt":"args.push(\"<STR_LIT>\");"}
{"input":"<s> export function difftool(file: any): any {<EOL>    return _isFileStaged(file).then((staged: any): Promise<string> => {<EOL>        const args: string[] = [\"<STR_LIT>\"];<EOL>        if (staged) {<EOL>            args.push(\"<STR_LIT>\");<EOL>        }<EOL>        args.push(\"<STR_LIT>\", file);<EOL>        return git(args, {<EOL>            timeout: false,<EOL>            nonblocking:","gt":"true"}
{"input":"<s> export function mergeBranch(branchName: any, mergeMessage: any, useNoff: any): Promise<string> {<EOL>    const args: string[] = [\"<STR_LIT>\"];<EOL>    if (useNoff) {<EOL>","gt":"args.push(\"<STR_LIT>\");"}
{"input":"<s> <EOL><EOL>export function push(remoteName: any, remoteBranch: any, additionalArgs: any): any {<EOL>    if (!remoteName) {<EOL>        throw new TypeError(\"<STR_LIT>\");<EOL>    }<EOL>    let args: string[] = [\"<STR_LIT>\", \"<STR_LIT>\", \"<STR_LIT>\"];<EOL>    if (Array.","gt":"isArray(additionalArgs)) {"}
{"input":"<s> <EOL><EOL>export function push(remoteName: any, remoteBranch: any, additionalArgs: any): any {<EOL>    if (!remoteName) {<EOL>        throw new TypeError(\"<STR_LIT>\");<EOL>    }<EOL>    let args: string[] = [\"<STR_LIT>\", \"<STR_LIT>\", \"<STR_LIT>\"];<EOL>    if (Array.isArray(additionalArgs)) {<EOL>        args = args.concat(additionalArgs);<EOL>    }<EOL>","gt":"args.push(remoteName);"}
{"input":"<s> export function getAllBranches(): any {<EOL>    return GitCli.getAllBranches().then((branches: any): any =>","gt":"sortBranches(branches));"}
{"input":"<s> export function isVisible(): boolean {<EOL>    return","gt":"isShown;"}
{"input":"<s> <EOL>function initUi(): void {<EOL>    <EOL>    Panel.","gt":"init();"}
{"input":"<s> function spawnIfExists(directory: string, command: string, args: string[], opts: {}, callback: (stderr: string | null, stdout: string | null) => void): any {<EOL>    return doIfExists(spawn, directory, command, args,","gt":"opts, callback);"}
{"input":"<s> function _getCurrentFilePath(editor?: any): any {<EOL>    const gitRoot: any = Preferences.get(\"<STR_LIT>\");<EOL>    const document: any = editor ? editor.document : DocumentManager.getCurrentDocument();<EOL>","gt":"let filePath: any = document.file.fullPath;"}
{"input":"<s> export function consoleDebug(msg: any): void {<EOL>","gt":"if (debugOn) {"}
{"input":"<s> function chmodTerminalScript(allowExec: any): Promise<string> {<EOL>    const files: string[] = platform === \"<STR_LIT>\" ? [<EOL>        <EOL>        \"<STR_LIT>\",<EOL>","gt":"\"<STR_LIT>\""}
{"input":"<s> function chmodTerminalScript(allowExec: any): Promise<string> {<EOL>    const files: string[] = platform === \"<STR_LIT>\" ? [<EOL>        <EOL>        \"<STR_LIT>\",<EOL>        \"<STR_LIT>\"<EOL>    ] : [<EOL>        <EOL>        \"<STR_LIT>\"<EOL>    ];<EOL>    const args: string[] = [allowExec ? \"<STR_LIT>\" : \"<STR_LIT>\"].concat(files.map((file: string): string => {<EOL>        return Cli.escapeShellArg(Utils.getExtensionDirectory() +","gt":"\"<STR_LIT>\" + file);"}
{"input":"<s> function getFailedResultStatistics(): StressResFailedStatistics {<EOL>    const statistics: StressResFailedStatistics = { m500: {}, noRes: {}, testFailed: {} };<EOL>    const build: (type: string) => any = (type: string): any => _.keys(stressFailedResult[type]).","gt":"forEach((k: any): any => statistics[type][k] = stressFailedResult[type][k].length);"}
{"input":"<s> function workerStarted(addr: string): void {<EOL>","gt":"workers[addr].status = WorkerStatus.working;"}
{"input":"<s> function formatUsage(usage: string): string {<EOL>    return","gt":"usage.replace(/~~~/g, '<STR_LIT>').replace(/(^[ \\t]*\\n)/gm, '<STR_LIT>').replace(/^    /mg, '<STR_LIT>');"}
{"input":"<s> function updateRuleFiles(cb: Function): void {<EOL>    const ruleDir: string = '<STR_LIT>';<EOL>    const allFiles: any = fs.readdirSync(ruleDir).filter((file: any): any => fs.lstatSync(path.join(ruleDir, file)).isFile());<EOL>    const ruleNames: any = allFiles<EOL>        .filter((name: any): boolean => /\\.ts$/.test(name))<EOL>        .map((name: any): any => name.substr(<NUM_LIT>, name.","gt":"length - <NUM_LIT>));"}
{"input":"<s> function updateRuleFiles(cb: Function): void {<EOL>    const ruleDir: string = '<STR_LIT>';<EOL>    const allFiles: any = fs.readdirSync(ruleDir).filter((file: any): any => fs.lstatSync(path.join(ruleDir, file)).isFile());<EOL>    const ruleNames: any = allFiles<EOL>        .filter((name: any): boolean => /\\.ts$/.test(name))<EOL>        .map((name: any): any => name.substr(<NUM_LIT>, name.length - <NUM_LIT>));<EOL>    const allPromises: Promise<void>[] = [];<EOL>    ruleNames.forEach((name: any): void => {<EOL>        allPromises.push(updateRuleFile(name, ruleTSMap[name]));<EOL>    });<EOL>    <EOL>    Promise.all(allPromises).","gt":"then((): void => {"}
{"input":"<s> function walk(ctx: Lint.WalkContext<void>): void {<EOL>    const TAB_REGEX: RegExp = /\\t/;<EOL>    const lines: any = ctx.sourceFile.text.split(/\\n/g);<EOL>","gt":"lines.forEach((line: any, i: any): void => {"}
{"input":"<s> <EOL>function compatibleListener<T extends Event>(eventNames: string[], prefixes?: string[]): (element: IEventTargetLike) => Observable<T> {<EOL>    let mem: string | undefined;<EOL>    const prefixedEvents: string[] = eventPrefixed(eventNames, prefixes);<EOL>    return (element: any): any => {<EOL>        <EOL>        <EOL>        if (element instanceof HTMLElement_) {<EOL>            if (typeof mem === \"<STR_LIT>\") {<EOL>                mem =","gt":"findSupportedEvent(element, prefixedEvents);"}
{"input":"<s> <EOL>function compatibleListener<T extends Event>(eventNames: string[], prefixes?: string[]): (element: IEventTargetLike) => Observable<T> {<EOL>    let mem: string | undefined;<EOL>    const prefixedEvents: string[] = eventPrefixed(eventNames, prefixes);<EOL>    return (element: any): any => {<EOL>        <EOL>        <EOL>        if (element instanceof HTMLElement_) {<EOL>            if (typeof mem === \"<STR_LIT>\") {<EOL>                mem = findSupportedEvent(element, prefixedEvents);<EOL>            }<EOL>            if (mem) {<EOL>                return","gt":"Observable.fromEvent(element, mem);"}
{"input":"<s> <EOL>function compatibleListener<T extends Event>(eventNames: string[], prefixes?: string[]): (element: IEventTargetLike) => Observable<T> {<EOL>    let mem: string | undefined;<EOL>    const prefixedEvents: string[] = eventPrefixed(eventNames, prefixes);<EOL>    return (element: any): any => {<EOL>        <EOL>        <EOL>        if (element instanceof HTMLElement_) {<EOL>            if (typeof mem === \"<STR_LIT>\") {<EOL>                mem = findSupportedEvent(element, prefixedEvents);<EOL>            }<EOL>            if (mem) {<EOL>                return Observable.fromEvent(element, mem);<EOL>            }<EOL>            else {<EOL>                if (","gt":"__DEV__) {"}
{"input":"<s> <EOL>function compatibleListener<T extends Event>(eventNames: string[], prefixes?: string[]): (element: IEventTargetLike) => Observable<T> {<EOL>    let mem: string | undefined;<EOL>    const prefixedEvents: string[] = eventPrefixed(eventNames, prefixes);<EOL>    return (element: any): any => {<EOL>        <EOL>        <EOL>        if (element instanceof HTMLElement_) {<EOL>            if (typeof mem === \"<STR_LIT>\") {<EOL>                mem = findSupportedEvent(element, prefixedEvents);<EOL>            }<EOL>            if (mem) {<EOL>                return Observable.fromEvent(element, mem);<EOL>            }<EOL>            else {<EOL>                if (__DEV__) {<EOL>                    <EOL>                    log.warn(`<STR_LIT>`<EOL>                    <EOL>                    );<EOL>                }<EOL>","gt":"return Observable.never();"}
{"input":"<s> <EOL>function findFirstOptimalAudioAdaptation(audioAdaptations: Adaptation[], preferredAudioTracks: IAudioTrackPreference[]): Adaptation | null {<EOL>    if (!audioAdaptations.length) {<EOL>        return null;<EOL>    }<EOL>    for (let i: number = <NUM_LIT>; i < preferredAudioTracks.length; i++) {<EOL>        const preferredAudioTrack:","gt":"IAudioTrackPreference = preferredAudioTracks[i];"}
{"input":"<s> <EOL>function findFirstOptimalAudioAdaptation(audioAdaptations: Adaptation[], preferredAudioTracks: IAudioTrackPreference[]): Adaptation | null {<EOL>    if (!audioAdaptations.length) {<EOL>        return null;<EOL>    }<EOL>    for (let i: number = <NUM_LIT>; i < preferredAudioTracks.length; i++) {<EOL>        const preferredAudioTrack: IAudioTrackPreference = preferredAudioTracks[i];<EOL>        if (preferredAudioTrack === null) {<EOL>            return null;<EOL>        }<EOL>        const foundAdaptation: Adaptation | undefined = arrayFind(audioAdaptations, (audioAdaptation: Adaptation): boolean => (audioAdaptation.normalizedLanguage || \"<STR_LIT>\") === preferredAudioTrack.","gt":"normalized &&"}
{"input":"<s> <EOL>function clearEME(): Observable<never> {<EOL>    return Observable.defer((): any => {<EOL>        const observablesArray: Array<Observable<never>> = [];<EOL>        if (instanceInfos.$videoElement && shouldUnsetMediaKeys()) {<EOL>            const obs$: Observable<never> = disposeMediaKeys(instanceInfos.$videoElement)<EOL>                .ignoreElements()<EOL>                .","gt":"finally((): void => {"}
{"input":"<s> <EOL>function clearEME(): Observable<never> {<EOL>    return Observable.defer((): any => {<EOL>        const observablesArray: Array<Observable<never>> = [];<EOL>        if (instanceInfos.$videoElement && shouldUnsetMediaKeys()) {<EOL>            const obs$: Observable<never> = disposeMediaKeys(instanceInfos.$videoElement)<EOL>                .ignoreElements()<EOL>                .finally((): void => {<EOL>                instanceInfos.$videoElement = null;<EOL>            }) as Observable<never>;<EOL>            observablesArray.push(obs$);<EOL>        }<EOL>        if (instanceInfos.$keySystem && instanceInfos.$keySystem.closeSessionsOnStop) {<EOL>            observablesArray.push($loadedSessions.dispose()<EOL>                .","gt":"ignoreElements() as Observable<never>);"}
{"input":"<s> <EOL>function handleEncryptedEvents(encryptedEvent: MediaEncryptedEvent, keySystemInfo: IKeySystemPackage, video: HTMLMediaElement, errorStream: ErrorStream): Observable<IMockMediaKeys | MediaKeys | ISessionEvent | Event> {<EOL>    const { keySystem, keySystemAccess } = keySystemInfo;<EOL>    if (keySystem.persistentLicense) {<EOL>        if (keySystem.","gt":"licenseStorage) {"}
{"input":"<s> <EOL>function handleEncryptedEvents(encryptedEvent: MediaEncryptedEvent, keySystemInfo: IKeySystemPackage, video: HTMLMediaElement, errorStream: ErrorStream): Observable<IMockMediaKeys | MediaKeys | ISessionEvent | Event> {<EOL>    const { keySystem, keySystemAccess } = keySystemInfo;<EOL>    if (keySystem.persistentLicense) {<EOL>        if (keySystem.licenseStorage) {<EOL>            $storedSessions.setStorage(keySystem.licenseStorage);<EOL>        }<EOL>","gt":"else {"}
{"input":"<s> <EOL>function handleEncryptedEvents(encryptedEvent: MediaEncryptedEvent, keySystemInfo: IKeySystemPackage, video: HTMLMediaElement, errorStream: ErrorStream): Observable<IMockMediaKeys | MediaKeys | ISessionEvent | Event> {<EOL>    const { keySystem, keySystemAccess } = keySystemInfo;<EOL>    if (keySystem.persistentLicense) {<EOL>        if (keySystem.licenseStorage) {<EOL>            $storedSessions.setStorage(keySystem.licenseStorage);<EOL>        }<EOL>        else {<EOL>            const error: Error = new Error(\"<STR_LIT>\");<EOL>            throw new EncryptedMediaError(\"<STR_LIT>\", error, true);<EOL>        }<EOL>    }<EOL>    log.info(\"<STR_LIT>\", encryptedEvent);<EOL>    return createMediaKeysObs(keySystemAccess).mergeMap((mediaKeys: any): any => {<EOL>        <EOL>        const { serverCertificate } = keySystem;<EOL>        const setCertificate$: Observable<never> = (serverCertificate &&<EOL>            typeof mediaKeys.setServerCertificate === \"<STR_LIT>\" ?<EOL>            trySettingServerCertificate(","gt":"mediaKeys, serverCertificate, errorStream) :"}
{"input":"<s> <EOL>function setServerCertificate(mediaKeys: IMockMediaKeys | MediaKeys, serverCertificate: BufferSource): Observable<{} | void> {<EOL>    return Observable.defer((): any => {<EOL>        return castToObservable(mediaKeys.setServerCertificate(serverCertificate))<EOL>            .","gt":"ignoreElements()"}
{"input":"<s> <EOL>function generateClock(videoElement: HTMLMediaElement): Observable<boolean> {<EOL>    const seeking$: Observable<T> = onSeeking$(videoElement);<EOL>    const seeked$: Observable<T> = onSeeked$(videoElement);<EOL>    const ended$: Observable<T> = onEnded$(videoElement);<EOL>    const manualRefresh$: any = Observable.","gt":"merge(seeked$, ended$);"}
{"input":"<s> <EOL>function generateClock(videoElement: HTMLMediaElement): Observable<boolean> {<EOL>    const seeking$: Observable<T> = onSeeking$(videoElement);<EOL>    const seeked$: Observable<T> = onSeeked$(videoElement);<EOL>    const ended$: Observable<T> = onEnded$(videoElement);<EOL>    const manualRefresh$: any = Observable.merge(seeked$, ended$);<EOL>    const autoRefresh$: any = Observable<EOL>        .interval(MAXIMUM_HTML_TEXT_TRACK_UPDATE_INTERVAL)<EOL>        .startWith(null);<EOL>    <EOL>    return manualRefresh$<EOL>        .","gt":"startWith(null)"}
{"input":"<s> function speedChanged(speed: number): ISpeedChangedEvent {<EOL>    return {<EOL>","gt":"type: \"<STR_LIT>\","}
{"input":"<s> <EOL>export default function handleVideoEvents(videoElement: HTMLMediaElement, startTime: number, autoPlay: boolean): {<EOL>    initialSeek$: Observable<void>;<EOL>    loadAndPlay$: Observable<void>;<EOL>} {<EOL>    const initialSeek$: Observable<void> = doInitialSeek(videoElement, startTime);<EOL>    const hasHandledCanPlay$: Observable<void> = handleCanPlay(videoElement, autoPlay);<EOL>    const loadAndPlay$: any = Observable<EOL>        .","gt":"combineLatest(initialSeek$, hasHandledCanPlay$)"}
{"input":"<s> <EOL>export default function handleVideoEvents(videoElement: HTMLMediaElement, startTime: number, autoPlay: boolean): {<EOL>    initialSeek$: Observable<void>;<EOL>    loadAndPlay$: Observable<void>;<EOL>} {<EOL>    const initialSeek$: Observable<void> = doInitialSeek(videoElement, startTime);<EOL>    const hasHandledCanPlay$: Observable<void> = handleCanPlay(videoElement, autoPlay);<EOL>    const loadAndPlay$: any = Observable<EOL>        .combineLatest(initialSeek$, hasHandledCanPlay$)<EOL>        .take(<NUM_LIT>)<EOL>        .mapTo(undefined);<EOL>    return {<EOL>","gt":"initialSeek$,"}
{"input":"<s> <EOL>export default function createManifest(manifestObject: IParsedManifest, externalTextTracks: ISupplementaryTextTrack | ISupplementaryTextTrack[], externalImageTracks: ISupplementaryImageTrack | ISupplementaryImageTrack[], warning$: Subject<Error | CustomError>): Manifest {<EOL>    manifestObject.periods = (manifestObject.periods).map((period: import(\"<STR_LIT>\").IParsedPeriod): import(\"<STR_LIT>\").IParsedPeriod => {<EOL>        period.adaptations = checkAdaptations(period.adaptations, warning$);<EOL>        return","gt":"period;"}
{"input":"<s> <EOL>function itole2(num: number): Uint8Array {<EOL>    return new Uint8Array([<EOL>        (num) &","gt":"<NUM_LIT>,"}
{"input":"<s> <EOL>function keepRangeIntersection(ranges1: IRange[], ranges2: IRange[]): IRange[] {<EOL>    for (let i: number = <NUM_LIT>; i < ranges1.length; i++) {<EOL>        const range: IRange = ranges1[i];<EOL>        const overlappingRange: IRange | null = findOverlappingRange(range, ranges2);<EOL>        if (!overlappingRange) {<EOL>            ranges1.splice(","gt":"i--, <NUM_LIT>);"}
{"input":"<s> <EOL>function keepRangeIntersection(ranges1: IRange[], ranges2: IRange[]): IRange[] {<EOL>    for (let i: number = <NUM_LIT>; i < ranges1.length; i++) {<EOL>        const range: IRange = ranges1[i];<EOL>        const overlappingRange: IRange | null = findOverlappingRange(range, ranges2);<EOL>        if (!overlappingRange) {<EOL>            ranges1.splice(i--, <NUM_LIT>);<EOL>        }<EOL>        else if (overlappingRange.start > range.start) {<EOL>            range.start = overlappingRange.start;<EOL>        }<EOL>        else if (overlappingRange.end < range.end) {<EOL>            range.end = overlappingRange.","gt":"end;"}
{"input":"<s> export function hide<T>(this: Observable<T>): Observable<T> {<EOL>","gt":"return higherOrderHide<T>()(this);"}
{"input":"<s> export function getSnapshotRef(ref: SubscriberRef): SnapshotRef {<EOL>","gt":"return ref[snapshotRefSymbol];"}
{"input":"<s> function stubPlugin(): Plugin {<EOL>    return {<EOL>        afterComplete: sinon.stub(),<EOL>        afterError: sinon.stub(),<EOL>        afterNext: sinon.stub(),<EOL>","gt":"afterSubscribe: sinon.stub(),"}
{"input":"<s> function stubPlugin(): Plugin {<EOL>    return {<EOL>        afterComplete: sinon.stub(),<EOL>        afterError: sinon.stub(),<EOL>        afterNext: sinon.stub(),<EOL>        afterSubscribe: sinon.stub(),<EOL>        afterUnsubscribe: sinon.stub(),<EOL>        beforeComplete: sinon.stub(),<EOL>        beforeError: sinon.stub(),<EOL>        beforeNext: sinon.","gt":"stub(),"}
{"input":"<s> function stubPlugin(): Plugin {<EOL>    return {<EOL>        afterComplete: sinon.stub(),<EOL>        afterError: sinon.stub(),<EOL>        afterNext: sinon.stub(),<EOL>        afterSubscribe: sinon.stub(),<EOL>        afterUnsubscribe: sinon.stub(),<EOL>        beforeComplete: sinon.stub(),<EOL>        beforeError: sinon.stub(),<EOL>        beforeNext: sinon.stub(),<EOL>        beforeSubscribe: sinon.stub(),<EOL>        beforeUnsubscribe: sinon.stub(),<EOL>        flush: sinon.","gt":"stub(),"}
{"input":"<s> function test1(): any {<EOL>    <EOL>    var queue: any = new TaskQueue(Promise, <NUM_LIT>);<EOL>    var running: number = <NUM_LIT>;<EOL>    var maxRunning: number = <NUM_LIT>;<EOL>    <EOL>    function run(","gt":"item: string): any {"}
{"input":"<s> function test1(): any {<EOL>    <EOL>    var queue: any = new TaskQueue(Promise, <NUM_LIT>);<EOL>    var running: number = <NUM_LIT>;<EOL>    var maxRunning: number = <NUM_LIT>;<EOL>    <EOL>    function run(item: string): any {<EOL>        if (++running > maxRunning)<EOL>            maxRunning = running;<EOL>","gt":"return (Promise.delay(<NUM_LIT>, true).then((): string => {"}
{"input":"<s> function test1(): any {<EOL>    <EOL>    var queue: any = new TaskQueue(Promise, <NUM_LIT>);<EOL>    var running: number = <NUM_LIT>;<EOL>    var maxRunning: number = <NUM_LIT>;<EOL>    <EOL>    function run(item: string): any {<EOL>        if (++running > maxRunning)<EOL>            maxRunning = running;<EOL>        return (Promise.delay(<NUM_LIT>, true).then((): string => {<EOL>            --running;<EOL>            return (item);<EOL>        }));<EOL>    }<EOL>    <EOL>    var list:","gt":"string[] = '<STR_LIT>'.split('<STR_LIT>');"}
{"input":"<s> function onError(e: any): void {<EOL>    log.error(","gt":"'<STR_LIT>', '<STR_LIT>', e);"}
{"input":"<s> async function getOutRoom(contact: Contact, room: Room): Promise<void> {<EOL>    log.info('<STR_LIT>', '<STR_LIT>', contact, room);<EOL>    try {<EOL>        await room.say(","gt":"'<STR_LIT>');"}
{"input":"<s> function error(str: any): void {<EOL>    throw","gt":"new Error(str);"}
{"input":"<s> function isInSmallView(): boolean {<EOL>    return windowInnerWidth <","gt":"<NUM_LIT>;"}
{"input":"<s> async function resetUserPassword(req: express.Request, res: express.Response, next: express.NextFunction): Promise<any> {<EOL>    const user: UserModel = res.locals.user as UserModel;<EOL>    user.password = req.body.","gt":"password;"}
{"input":"<s> async function getVideoDescription(req: express.Request, res: express.Response): Promise<any> {<EOL>    const videoInstance: any = res.locals.video;<EOL>    let description: string = '<STR_LIT>';<EOL>    if (","gt":"videoInstance.isOwned()) {"}
{"input":"<s> async function isAccountExist(p: Bluebird<AccountModel>, res: Response): Promise<boolean> {<EOL>    const account: Bluebird<AccountModel> = await p;<EOL>    if (!account) {<EOL>        res.status(","gt":"<NUM_LIT>)"}
{"input":"<s> function isUUIDValid(value: string): any {<EOL>    return exists(","gt":"value) && validator.isUUID('<STR_LIT>' + value, <NUM_LIT>);"}
{"input":"<s> function isUserRoleValid(value: any): boolean {<EOL>    return exists(value) && validator.isInt('<STR_LIT>' +","gt":"value) && UserRole[value] !== undefined;"}
{"input":"<s> function isUserVideoQuotaValid(value: string): any {<EOL>    return","gt":"exists(value) && validator.isInt(value + '<STR_LIT>', USERS_CONSTRAINTS_FIELDS.VIDEO_QUOTA);"}
{"input":"<s> function isVideoTruncatedDescriptionValid(value: string): any {<EOL>    return exists(","gt":"value) && validator.isLength(value, VIDEOS_CONSTRAINTS_FIELDS.TRUNCATED_DESCRIPTION);"}
{"input":"<s> function down(options: any): void {<EOL>    throw new Error(","gt":"'<STR_LIT>');"}
{"input":"<s> function down(options: any): void {<EOL>    throw","gt":"new Error('<STR_LIT>');"}
{"input":"<s> async function getOrCreateActorAndServerAndModel(actorUrl: string, recurseIfNeeded: boolean = true): Promise<unknown> {<EOL>    let actor: any = await ActorModel.loadByUrl(actorUrl);<EOL>    <EOL>    if (!actor) {<EOL>        const result: FetchRemoteActorResult = await fetchRemoteActor(","gt":"actorUrl);"}
{"input":"<s> async function getOrCreateActorAndServerAndModel(actorUrl: string, recurseIfNeeded: boolean = true): Promise<unknown> {<EOL>    let actor: any = await ActorModel.loadByUrl(actorUrl);<EOL>    <EOL>    if (!actor) {<EOL>        const result: FetchRemoteActorResult = await fetchRemoteActor(actorUrl);<EOL>        if (result ===","gt":"undefined)"}
{"input":"<s> async function getOrCreateActorAndServerAndModel(actorUrl: string, recurseIfNeeded: boolean = true): Promise<unknown> {<EOL>    let actor: any = await ActorModel.loadByUrl(actorUrl);<EOL>    <EOL>    if (!actor) {<EOL>        const result: FetchRemoteActorResult = await fetchRemoteActor(actorUrl);<EOL>        if (result === undefined)<EOL>            throw new Error('<STR_LIT>');<EOL>        <EOL>        <EOL>        let ownerActor: ActorModel = undefined;<EOL>        if (recurseIfNeeded === true && result.actor.type === '<STR_LIT>') {<EOL>            const accountAttributedTo: ActivityPubAttributedTo = result.attributedTo.find((a: ActivityPubAttributedTo): boolean => a.type === '<STR_LIT>');<EOL>","gt":"if (!accountAttributedTo)"}
{"input":"<s> async function getOrCreateActorAndServerAndModel(actorUrl: string, recurseIfNeeded: boolean = true): Promise<unknown> {<EOL>    let actor: any = await ActorModel.loadByUrl(actorUrl);<EOL>    <EOL>    if (!actor) {<EOL>        const result: FetchRemoteActorResult = await fetchRemoteActor(actorUrl);<EOL>        if (result === undefined)<EOL>            throw new Error('<STR_LIT>');<EOL>        <EOL>        <EOL>        let ownerActor: ActorModel = undefined;<EOL>        if (recurseIfNeeded === true && result.actor.type === '<STR_LIT>') {<EOL>            const accountAttributedTo: ActivityPubAttributedTo = result.attributedTo.find((a: ActivityPubAttributedTo): boolean => a.type === '<STR_LIT>');<EOL>            if (!accountAttributedTo)<EOL>                throw new Error('<STR_LIT>' + actor.url);<EOL>            try {<EOL>                <EOL>                ownerActor = await getOrCreateActorAndServerAndModel(accountAttributedTo.id, false);<EOL>            }<EOL>            catch (err: any) {<EOL>                logger.error('<STR_LIT>' + actor.url);<EOL>                throw new Error(err);<EOL>            }<EOL>        }<EOL>        const options: {<EOL>            arguments: (FetchRemoteActorResult | ActorModel)[];<EOL>            errorMessage: string;<EOL>        } = {<EOL>            arguments: [result, ownerActor],<EOL>            errorMessage: '<STR_LIT>'<EOL>        };<EOL>        actor = await retryTransactionWrapper(saveActorAndServerAndModelIfNotExist,","gt":"options);"}
{"input":"<s> function getRefreshToken(refreshToken: string): any {<EOL>    logger.debug('<STR_LIT>' + refreshToken +","gt":"'<STR_LIT>');"}
{"input":"<s> async function exitServers(servers: ServerInfo[], flushAtExit: boolean): Promise<void> {<EOL>    killallServers(","gt":"servers);"}
{"input":"<s> function getUsersListPaginationAndSort(url: string, accessToken: string, start: number, count: number, sort: string): any {<EOL>    const path: string = '<STR_LIT>';<EOL>    return request(url)<EOL>        .get(path)<EOL>        .query({","gt":"start })"}
{"input":"<s> function getUsersListPaginationAndSort(url: string, accessToken: string, start: number, count: number, sort: string): any {<EOL>    const path: string = '<STR_LIT>';<EOL>    return request(url)<EOL>        .get(path)<EOL>        .query({ start })<EOL>        .query({ count })<EOL>        .query({ sort })<EOL>        .set('<STR_LIT>', '<STR_LIT>')<EOL>        .set(","gt":"'<STR_LIT>', '<STR_LIT>' + accessToken)"}
{"input":"<s> function normalizeObject(obj: any): any {<EOL>    const newObj: any = {};<EOL>    for (const key: string of Object.keys(obj)) {<EOL>        <EOL>        if (key === '<STR_LIT>')<EOL>","gt":"continue;"}
{"input":"<s> function normalizeObject(obj: any): any {<EOL>    const newObj: any = {};<EOL>    for (const key: string of Object.keys(obj)) {<EOL>        <EOL>        if (key === '<STR_LIT>')<EOL>            continue;<EOL>        const value: any = obj[key];<EOL>        if (typeof value === '<STR_LIT>') {<EOL>            newObj[key] = value.normalize();<EOL>        }<EOL>        else {<EOL>            newObj[","gt":"key] = value;"}
{"input":"<s> function processVideo(info: any, languageCode: number): Promise<unknown> {<EOL>    return new Promise(async (res: (value: unknown) => void): Promise<void> => {<EOL>        if (program['<STR_LIT>'])<EOL>            console.log('<STR_LIT>', info);<EOL>        const videoInfo: any = await fetchObject(info);<EOL>        if (program[","gt":"'<STR_LIT>'])"}
{"input":"<s> function processVideo(info: any, languageCode: number): Promise<unknown> {<EOL>    return new Promise(async (res: (value: unknown) => void): Promise<void> => {<EOL>        if (program['<STR_LIT>'])<EOL>            console.log('<STR_LIT>', info);<EOL>        const videoInfo: any = await fetchObject(info);<EOL>        if (program['<STR_LIT>'])<EOL>            console.log('<STR_LIT>', videoInfo);<EOL>        const result: any = await searchVideo(program['<STR_LIT>'], videoInfo.title);<EOL>        console.","gt":"log('<STR_LIT>');"}
{"input":"<s> function processVideo(info: any, languageCode: number): Promise<unknown> {<EOL>    return new Promise(async (res: (value: unknown) => void): Promise<void> => {<EOL>        if (program['<STR_LIT>'])<EOL>            console.log('<STR_LIT>', info);<EOL>        const videoInfo: any = await fetchObject(info);<EOL>        if (program['<STR_LIT>'])<EOL>            console.log('<STR_LIT>', videoInfo);<EOL>        const result: any = await searchVideo(program['<STR_LIT>'], videoInfo.title);<EOL>        console.log('<STR_LIT>');<EOL>        if (result.body.data.find((v: any): boolean => v.name === videoInfo.title)) {<EOL>            console.log('<STR_LIT>', videoInfo.title);<EOL>            return res();<EOL>        }<EOL>        const path: any = join(__dirname, new Date().","gt":"getTime() + '<STR_LIT>');"}
{"input":"<s> function processVideo(info: any, languageCode: number): Promise<unknown> {<EOL>    return new Promise(async (res: (value: unknown) => void): Promise<void> => {<EOL>        if (program['<STR_LIT>'])<EOL>            console.log('<STR_LIT>', info);<EOL>        const videoInfo: any = await fetchObject(info);<EOL>        if (program['<STR_LIT>'])<EOL>            console.log('<STR_LIT>', videoInfo);<EOL>        const result: any = await searchVideo(program['<STR_LIT>'], videoInfo.title);<EOL>        console.log('<STR_LIT>');<EOL>        if (result.body.data.find((v: any): boolean => v.name === videoInfo.title)) {<EOL>            console.log('<STR_LIT>', videoInfo.title);<EOL>            return res();<EOL>        }<EOL>        const path: any = join(__dirname, new Date().getTime() + '<STR_LIT>');<EOL>        console.log('<STR_LIT>', videoInfo.title);<EOL>        const options: any[] = ['<STR_LIT>', '<STR_LIT>', '<STR_LIT>', path];<EOL>        youtubeDL.exec(videoInfo.url, options, processOptions, async (err: any, output: any): Promise<void> => {<EOL>            if (err)<EOL>                return console.error(","gt":"err);"}
{"input":"<s> <EOL>export function genImageUrl(file: File): string {<EOL>    if (!isSSR && isImage(file)) {<EOL>        return window.","gt":"URL.createObjectURL(file);"}
{"input":"<s> <EOL>export function get(...target: any[]): any {<EOL>    const user: any = getDeepProperty(USERCONFIG, target);<EOL>    const defult: any = getDeepProperty(DEFAULTS, target);<EOL>    <EOL>    if (defult && (!Array.isArray(defult) && typeof defult === \"<STR_LIT>\")) {<EOL>        return Object.assign(","gt":"o({}), defult, user);"}
{"input":"<s> <EOL>export function get(...target: any[]): any {<EOL>    const user: any = getDeepProperty(USERCONFIG, target);<EOL>    const defult: any = getDeepProperty(DEFAULTS, target);<EOL>    <EOL>    if (defult && (!Array.isArray(defult) && typeof defult === \"<STR_LIT>\")) {<EOL>        return Object.assign(o({}), defult, user);<EOL>    }<EOL>    else {<EOL>        if (user !== undefined) {<EOL>            return user;<EOL>        }<EOL>","gt":"else {"}
{"input":"<s> <EOL><EOL>export async function tabclose(...indexes: string[]): Promise<void> {<EOL>    if (indexes.length > <NUM_LIT>) {<EOL>        const idsPromise: Promise<number>[] = indexes.map((index: string): Promise<number> => idFromIndex(Number(index)));<EOL>        browser.tabs.remove(await","gt":"Promise.all(idsPromise));"}
{"input":"<s> <EOL><EOL>export async function ttscontrol(action: string): Promise<void> {<EOL>    let ttsAction: TTS.Action = null;<EOL>    <EOL>    <EOL>    <EOL>    switch (","gt":"action) {"}
{"input":"<s> <EOL>function hintImage(inBackground: any): void {<EOL>    hintPage(hintableImages(), (hint: any): void => {<EOL>        let img_src: any = hint.target.getAttribute(\"<STR_LIT>\");<EOL>","gt":"if (inBackground) {"}
{"input":"<s> <EOL>function hintPageAnchorYank(): void {<EOL>    hintPage(anchors(), (hint: any): void => {<EOL>        let anchorUrl: URL = new","gt":"URL(window.location.href);"}
{"input":"<s> <EOL>export function hintPage(hintableElements: Element[], onSelect: HintSelectedCallback, buildHints: HintBuilder = defaultHintBuilder(), filterHints: HintFilter = defaultHintFilter()): void {<EOL>    state.mode = '<STR_LIT>';<EOL>    modeState = new HintState(filterHints);<EOL>    buildHints(hintableElements, onSelect);<EOL>    if (modeState.","gt":"hints.length) {"}
{"input":"<s> <EOL>export function hintPage(hintableElements: Element[], onSelect: HintSelectedCallback, buildHints: HintBuilder = defaultHintBuilder(), filterHints: HintFilter = defaultHintFilter()): void {<EOL>    state.mode = '<STR_LIT>';<EOL>    modeState = new HintState(filterHints);<EOL>    buildHints(hintableElements, onSelect);<EOL>    if (modeState.hints.length) {<EOL>        logger.debug(\"<STR_LIT>\", modeState.hints);<EOL>        modeState.focusedHint = modeState.hints[<NUM_LIT>];<EOL>        modeState.focusedHint.focused = true;<EOL>        document.documentElement.appendChild(modeState.hintHost);<EOL>    }<EOL>","gt":"else {"}
{"input":"<s> <EOL>export function iterEq(...arrays: any[]): boolean {<EOL>    for (let a: any[] of zip(...arrays)) {<EOL>","gt":"if (!a.reduce((x: any, y: any): boolean => (x === y)))"}
{"input":"<s> export function isSimpleKey(keyEvent: KeyEventLike): boolean {<EOL>    return !(keyEvent.key.length >","gt":"<NUM_LIT> || hasNonShiftModifiers(keyEvent));"}
{"input":"<s> <EOL>export function generic(obj): any {<EOL>    let ret: {} = {};<EOL>    for (let key: string of Object.keys(obj)) {<EOL>        if (messageSafeTypes.has(typeof obj[","gt":"key])) {"}
{"input":"<s> export function Node(node: HTMLElement): MsgSafeNode {<EOL>    return pick(node, <EOL>    <EOL>    '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>', <EOL>    <EOL>    '<STR_LIT>', <EOL>    <EOL>    '<STR_LIT>', <EOL>    <EOL>","gt":"'<STR_LIT>',"}
{"input":"<s> function rejectWithError(msg: string, error: any): Promise<never> {<EOL>    const err: GTTError = new GTTError(","gt":"}: ${msg}`<STR_LIT>;"}
{"input":"<s> export function getSignature(auth: ExchangeAuthConfig, payload: string, algorithm: string = '<STR_LIT>'): string {<EOL>    return crypto<EOL>        .createHmac(","gt":"algorithm, auth.secret)"}
{"input":"<s> export function PriceTreeFactory<T extends PriceComparable>(): any {<EOL>    return","gt":"new RBTree<T>((a: T, b: T): any => a.price.cmp(b.price));"}
{"input":"<s> function logError(err: any): void {<EOL>    console.log(err.message, err.response ?","gt":"message}`<STR_LIT>;"}
{"input":"<s> export function printSeparator(): string {<EOL>","gt":"return '<STR_LIT>';"}
{"input":"<s> export function createMockLivebook(product: string, messages: StreamMessage[]): MockLivebook {<EOL>    const bookConfig: LiveBookConfig = {<EOL>        logger: null,<EOL>        strictMode: false,<EOL>","gt":"product: product"}
{"input":"<s> export function createMockLivebook(product: string, messages: StreamMessage[]): MockLivebook {<EOL>    const bookConfig: LiveBookConfig = {<EOL>        logger: null,<EOL>        strictMode: false,<EOL>        product: product<EOL>    };<EOL>    const liveBook: LiveOrderbook = new LiveOrderbook(bookConfig);<EOL>    const messageStream: StaticCommandSet = new StaticCommandSet(messages);<EOL>    messageStream.pipe(liveBook);<EOL>    return {<EOL>        liveBook:","gt":"liveBook,"}
{"input":"<s> function level3Messages(): StreamMessage[] {<EOL>    return [<EOL>        Object.assign({<EOL>            type: '<STR_LIT>',<EOL>            time: new Date('<STR_LIT>'),<EOL>            productId:","gt":"'<STR_LIT>'"}
{"input":"<s> function level3Messages(): StreamMessage[] {<EOL>    return [<EOL>        Object.assign({<EOL>            type: '<STR_LIT>',<EOL>            time: new Date('<STR_LIT>'),<EOL>            productId: '<STR_LIT>'<EOL>        }, shallowState()) as SnapshotMessage,<EOL>        { type: '<STR_LIT>',<EOL>            sequence: <NUM_LIT>,<EOL>            time: new Date(","gt":"'<STR_LIT>'),"}
{"input":"<s> function level3Messages(): StreamMessage[] {<EOL>    return [<EOL>        Object.assign({<EOL>            type: '<STR_LIT>',<EOL>            time: new Date('<STR_LIT>'),<EOL>            productId: '<STR_LIT>'<EOL>        }, shallowState()) as SnapshotMessage,<EOL>        { type: '<STR_LIT>',<EOL>            sequence: <NUM_LIT>,<EOL>            time: new Date('<STR_LIT>'),<EOL>            productId: '<STR_LIT>',<EOL>            price: '<STR_LIT>',<EOL>            remainingSize:","gt":"'<STR_LIT>',"}
{"input":"<s> export function promiseSequential(promises: any): Promise<unknown> {<EOL>    if (!Array.isArray(promises)) {<EOL>        throw new Error('<STR_LIT>');<EOL>    }<EOL>    return new Promise((resolve: (value: unknown) => void, reject: (reason?: any) => void): void => {<EOL>","gt":"let count: number = <NUM_LIT>;"}
{"input":"<s> export function promiseSequential(promises: any): Promise<unknown> {<EOL>    if (!Array.isArray(promises)) {<EOL>        throw new Error('<STR_LIT>');<EOL>    }<EOL>    return new Promise((resolve: (value: unknown) => void, reject: (reason?: any) => void): void => {<EOL>        let count: number = <NUM_LIT>;<EOL>        let results: any[] = [];<EOL>        const iterateeFunc: (previousPromise: any, currentPromise: any) => any = (previousPromise: any, currentPromise: any): any => {<EOL>","gt":"return previousPromise"}
{"input":"<s> export function promiseSequential(promises: any): Promise<unknown> {<EOL>    if (!Array.isArray(promises)) {<EOL>        throw new Error('<STR_LIT>');<EOL>    }<EOL>    return new Promise((resolve: (value: unknown) => void, reject: (reason?: any) => void): void => {<EOL>        let count: number = <NUM_LIT>;<EOL>        let results: any[] = [];<EOL>        const iterateeFunc: (previousPromise: any, currentPromise: any) => any = (previousPromise: any, currentPromise: any): any => {<EOL>            return previousPromise<EOL>                .then(function (result) {<EOL>                if (count++ !== <NUM_LIT>) {<EOL>","gt":"results = results.concat(result);"}
{"input":"<s> export function promiseSequential(promises: any): Promise<unknown> {<EOL>    if (!Array.isArray(promises)) {<EOL>        throw new Error('<STR_LIT>');<EOL>    }<EOL>    return new Promise((resolve: (value: unknown) => void, reject: (reason?: any) => void): void => {<EOL>        let count: number = <NUM_LIT>;<EOL>        let results: any[] = [];<EOL>        const iterateeFunc: (previousPromise: any, currentPromise: any) => any = (previousPromise: any, currentPromise: any): any => {<EOL>            return previousPromise<EOL>                .then(function (result) {<EOL>                if (count++ !== <NUM_LIT>) {<EOL>                    results = results.concat(result);<EOL>                }<EOL>                return currentPromise(result, results, count);<EOL>            })<EOL>                .catch((err: any): void => {<EOL>                return reject(err);<EOL>            });<EOL>        };<EOL>        promises = promises.","gt":"concat((): Promise<void> => Promise.resolve());"}
{"input":"<s> export function handlePath(files: Array<string>, cwd: string): Array<string> {<EOL>    let _files: string[] = files;<EOL>    let i: number = <NUM_LIT>;<EOL>    let len: number = files.","gt":"length;"}
{"input":"<s> export function hasBom(source: string): boolean {<EOL>","gt":"return (source.charCodeAt(<NUM_LIT>) === <NUM_LIT>);"}
{"input":"<s> export function LogPropertyWithArgs(alias: string): any {<EOL>","gt":"console.log('<STR_LIT>', alias);"}
{"input":"<s> export default function get<T>(object: T, path: string, defaultValue: any = undefined): any {<EOL>    if (path) {<EOL>        const pathSplitted: string[] = path.split(\"<STR_LIT>\");<EOL>        const property: string = pathSplitted[<NUM_LIT>];<EOL>        const","gt":"findProperty: any = object[property];"}
{"input":"<s> export default function get<T>(object: T, path: string, defaultValue: any = undefined): any {<EOL>    if (path) {<EOL>        const pathSplitted: string[] = path.split(\"<STR_LIT>\");<EOL>        const property: string = pathSplitted[<NUM_LIT>];<EOL>        const findProperty: any = object[property];<EOL>        if (findProperty && path.indexOf(\"<STR_LIT>\") === -<NUM_LIT>) {<EOL>            return findProperty;<EOL>        }<EOL>        const newPath: string = pathSplitted.slice(<NUM_LIT>, pathSplitted.length).join(\"<STR_LIT>\");<EOL>        return","gt":"get(findProperty, newPath, defaultValue);"}
{"input":"<s> <EOL>export function write(context: CacheContext, snapshot: GraphSnapshot, raw: RawOperation, payload: JsonObject): EditedSnapshot {<EOL>    let tracerContext: any;<EOL>    if (context.tracer.writeStart) {<EOL>        tracerContext = context.tracer.writeStart(raw, payload);<EOL>    }<EOL>    <EOL>    <EOL>    <EOL>    const editor: SnapshotEditor = new SnapshotEditor(context, snapshot);<EOL>    const { warnings } = editor.mergePayload(raw, payload);<EOL>    const newSnapshot: EditedSnapshot = editor.commit();<EOL>    if (","gt":"context.tracer.writeEnd) {"}
{"input":"<s> function* handleFetchRequests(): {} {<EOL>    let _pending: any = {};<EOL>    while (<NUM_LIT>) {<EOL>        const req: FetchRequest = yield take(FETCH_REQUEST);<EOL>        const {","gt":"info } = req;"}
{"input":"<s> function* handleFetchRequests(): {} {<EOL>    let _pending: any = {};<EOL>    while (<NUM_LIT>) {<EOL>        const req: FetchRequest = yield take(FETCH_REQUEST);<EOL>        const { info } = req;<EOL>        const uri: string = String(info);<EOL>","gt":"yield spawn(function* () {"}
{"input":"<s> function* handleFetchRequests(): {} {<EOL>    let _pending: any = {};<EOL>    while (<NUM_LIT>) {<EOL>        const req: FetchRequest = yield take(FETCH_REQUEST);<EOL>        const { info } = req;<EOL>        const uri: string = String(info);<EOL>        yield spawn(function* () {<EOL>            const state: SyntheticBrowserRootState = yield select();<EOL>            let p: Promise<any>;<EOL>","gt":"let emitChange: boolean;"}
{"input":"<s> function* handleFetchRequests(): {} {<EOL>    let _pending: any = {};<EOL>    while (<NUM_LIT>) {<EOL>        const req: FetchRequest = yield take(FETCH_REQUEST);<EOL>        const { info } = req;<EOL>        const uri: string = String(info);<EOL>        yield spawn(function* () {<EOL>            const state: SyntheticBrowserRootState = yield select();<EOL>            let p: Promise<any>;<EOL>            let emitChange: boolean;<EOL>            if (_pending[uri]) {<EOL>                p = _pending[uri];<EOL>            }<EOL>            else {<EOL>                if (","gt":"state.fileCache && state.fileCache[uri]) {"}
{"input":"<s> function* handleFetchRequests(): {} {<EOL>    let _pending: any = {};<EOL>    while (<NUM_LIT>) {<EOL>        const req: FetchRequest = yield take(FETCH_REQUEST);<EOL>        const { info } = req;<EOL>        const uri: string = String(info);<EOL>        yield spawn(function* () {<EOL>            const state: SyntheticBrowserRootState = yield select();<EOL>            let p: Promise<any>;<EOL>            let emitChange: boolean;<EOL>            if (_pending[uri]) {<EOL>                p = _pending[uri];<EOL>            }<EOL>            else {<EOL>                if (state.fileCache && state.fileCache[uri]) {<EOL>                    p = Promise.resolve(state.fileCache[uri].content);<EOL>                }<EOL>                else {<EOL>                    emitChange = true;<EOL>                    let curl:","gt":"string = uri;"}
{"input":"<s> function* handleFetchRequests(): {} {<EOL>    let _pending: any = {};<EOL>    while (<NUM_LIT>) {<EOL>        const req: FetchRequest = yield take(FETCH_REQUEST);<EOL>        const { info } = req;<EOL>        const uri: string = String(info);<EOL>        yield spawn(function* () {<EOL>            const state: SyntheticBrowserRootState = yield select();<EOL>            let p: Promise<any>;<EOL>            let emitChange: boolean;<EOL>            if (_pending[uri]) {<EOL>                p = _pending[uri];<EOL>            }<EOL>            else {<EOL>                if (state.fileCache && state.fileCache[uri]) {<EOL>                    p = Promise.resolve(state.fileCache[uri].content);<EOL>                }<EOL>                else {<EOL>                    emitChange = true;<EOL>                    let curl: string = uri;<EOL>                    if (curl.charAt(<NUM_LIT>) === \"<STR_LIT>\") {<EOL>                        curl = window.location.protocol + \"<STR_LIT>\" + window.location.host + curl;<EOL>                    }<EOL>                    if (curl.indexOf(window.location.host) === -<NUM_LIT>) {<EOL>                        curl =","gt":"apiHost}/proxy/${encodeURIComponent(String(info))}`<STR_LIT>;"}
{"input":"<s> function* handleFetchRequests(): {} {<EOL>    let _pending: any = {};<EOL>    while (<NUM_LIT>) {<EOL>        const req: FetchRequest = yield take(FETCH_REQUEST);<EOL>        const { info } = req;<EOL>        const uri: string = String(info);<EOL>        yield spawn(function* () {<EOL>            const state: SyntheticBrowserRootState = yield select();<EOL>            let p: Promise<any>;<EOL>            let emitChange: boolean;<EOL>            if (_pending[uri]) {<EOL>                p = _pending[uri];<EOL>            }<EOL>            else {<EOL>                if (state.fileCache && state.fileCache[uri]) {<EOL>                    p = Promise.resolve(state.fileCache[uri].content);<EOL>                }<EOL>                else {<EOL>                    emitChange = true;<EOL>                    let curl: string = uri;<EOL>                    if (curl.charAt(<NUM_LIT>) === \"<STR_LIT>\") {<EOL>                        curl = window.location.protocol + \"<STR_LIT>\" + window.location.host + curl;<EOL>                    }<EOL>                    if (curl.indexOf(window.location.host) === -<NUM_LIT>) {<EOL>                        curl = `<STR_LIT>`;<EOL>                    }<EOL>                    p = _pending[uri] = new Promise(async (resolve: (value: unknown) => void): Promise<void> => {<EOL>                        const response: Response = await fetch(curl);<EOL>                        const blob: Blob = await response.blob();<EOL>                        const fr: FileReader = new FileReader();<EOL>                        fr.onload = (): void => {<EOL>                            resolve(fr.result);<EOL>                        };<EOL>                        fr.readAsArrayBuffer(","gt":"blob);"}
{"input":"<s> function* handleFetchRequests(): {} {<EOL>    let _pending: any = {};<EOL>    while (<NUM_LIT>) {<EOL>        const req: FetchRequest = yield take(FETCH_REQUEST);<EOL>        const { info } = req;<EOL>        const uri: string = String(info);<EOL>        yield spawn(function* () {<EOL>            const state: SyntheticBrowserRootState = yield select();<EOL>            let p: Promise<any>;<EOL>            let emitChange: boolean;<EOL>            if (_pending[uri]) {<EOL>                p = _pending[uri];<EOL>            }<EOL>            else {<EOL>                if (state.fileCache && state.fileCache[uri]) {<EOL>                    p = Promise.resolve(state.fileCache[uri].content);<EOL>                }<EOL>                else {<EOL>                    emitChange = true;<EOL>                    let curl: string = uri;<EOL>                    if (curl.charAt(<NUM_LIT>) === \"<STR_LIT>\") {<EOL>                        curl = window.location.protocol + \"<STR_LIT>\" + window.location.host + curl;<EOL>                    }<EOL>                    if (curl.indexOf(window.location.host) === -<NUM_LIT>) {<EOL>                        curl = `<STR_LIT>`;<EOL>                    }<EOL>                    p = _pending[uri] = new Promise(async (resolve: (value: unknown) => void): Promise<void> => {<EOL>                        const response: Response = await fetch(curl);<EOL>                        const blob: Blob = await response.blob();<EOL>                        const fr: FileReader = new FileReader();<EOL>                        fr.onload = (): void => {<EOL>                            resolve(fr.result);<EOL>                        };<EOL>                        fr.readAsArrayBuffer(blob);<EOL>                    });<EOL>                }<EOL>            }<EOL>            const buffer: any = yield call(p.then.","gt":"bind(p));"}
{"input":"<s> export function* syntheticBrowserSaga(): {} {<EOL>    yield fork(htmlContentEditorSaga);<EOL>    yield fork(fileEditorSaga);<EOL>","gt":"yield fork(handleToggleCSSProperty);"}
{"input":"<s> function* init(): {} {<EOL>    yield","gt":"call(openMainWindow);"}
{"input":"<s> export function* mainSaga(): {} {<EOL>    yield","gt":"fork(init);"}
{"input":"<s> export function* mainSaga(): Generator<any, void, unknown> {<EOL>    yield fork(","gt":"httpService);"}
{"input":"<s> <EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL>function* handleTextEditorEscaped(): Generator<any, void, any> {<EOL>    while (true) {<EOL>        const { sourceEvent, nodeId } = (yield take(STAGE_TOOL_EDIT_TEXT_KEY_DOWN)) as StageToolEditTextKeyDown;<EOL>        if (sourceEvent.key !==","gt":"\"<STR_LIT>\") {"}
{"input":"<s> function* handleComponentsPaneAddClicked(): Generator<any, void, any> {<EOL>    while (true) {<EOL>        yield take(COMPONENTS_PANE_ADD_COMPONENT_CLICKED);<EOL>        const name: string = prompt(\"<STR_LIT>\");<EOL>","gt":"if (!name) {"}
{"input":"<s> function* handleComponentsPaneAddClicked(): Generator<any, void, any> {<EOL>    while (true) {<EOL>        yield take(COMPONENTS_PANE_ADD_COMPONENT_CLICKED);<EOL>        const name: string = prompt(\"<STR_LIT>\");<EOL>        if (!name) {<EOL>            continue;<EOL>        }<EOL>        const state: ApplicationState = yield select();<EOL>        const workspace: any = getWorkspaceById(state, state.selectedWorkspaceId);<EOL>        const { componentId } = yield call(apiCreateComponent, name, state);<EOL>","gt":"console.error(\"<STR_LIT>\");"}
{"input":"<s> function* handleDeleteKeyPressed(): {} {<EOL>    while (true) {<EOL>        const action: any = (yield take(DELETE_SHORCUT_PRESSED)) as DeleteShortcutPressed;<EOL>        const state: any = yield select();<EOL>","gt":"const { sourceEvent } = event as DeleteShortcutPressed;"}
{"input":"<s> function* handleDeleteKeyPressed(): {} {<EOL>    while (true) {<EOL>        const action: any = (yield take(DELETE_SHORCUT_PRESSED)) as DeleteShortcutPressed;<EOL>        const state: any = yield select();<EOL>        const { sourceEvent } = event as DeleteShortcutPressed;<EOL>        const workspace: any = getSelectedWorkspace(state);<EOL>        for (const [type, id] of workspace.selectionRefs) {<EOL>            yield put(workspaceSelectionDeleted(workspace.$id));<EOL>            yield put(removed(id, type as any));<EOL>            if (workspace.stage.fullScreen && workspace.stage.fullScreen.artboardId === id) {<EOL>                yield put(","gt":"fullScreenTargetDeleted());"}
{"input":"<s> <EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL>function* handleDNDEnded(): Generator<any, void, any> {<EOL>    while (true) {<EOL>        const event: any = yield take(DND_ENDED);<EOL>        const state: ApplicationState = yield select();<EOL>        const workspace: any = getSelectedWorkspace(state);<EOL>","gt":"const dropRef: ["}
{"input":"<s> <EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL>function* handleDNDEnded(): Generator<any, void, any> {<EOL>    while (true) {<EOL>        const event: any = yield take(DND_ENDED);<EOL>        const state: ApplicationState = yield select();<EOL>        const workspace: any = getSelectedWorkspace(state);<EOL>        const dropRef: [<EOL>            any,<EOL>            string<EOL>        ] = getStageToolMouseNodeTargetReference(state, event as DNDEvent);<EOL>        if (","gt":"dropRef) {"}
{"input":"<s> <EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL>function* handleDNDEnded(): Generator<any, void, any> {<EOL>    while (true) {<EOL>        const event: any = yield take(DND_ENDED);<EOL>        const state: ApplicationState = yield select();<EOL>        const workspace: any = getSelectedWorkspace(state);<EOL>        const dropRef: [<EOL>            any,<EOL>            string<EOL>        ] = getStageToolMouseNodeTargetReference(state, event as DNDEvent);<EOL>        if (dropRef) {<EOL>            yield call(handleDroppedOnElement, dropRef, event);<EOL>        }<EOL>        else {<EOL>            yield call(","gt":"handleDroppedOnEmptySpace, event);"}
{"input":"<s> function* handleSelectionStoppedMoving(): Generator<any, void, any> {<EOL>    while (true) {<EOL>        const { point, workspaceId } = (yield take(RESIZER_STOPPED_MOVING)) as ResizerMoved;<EOL>        const state: any = (yield select()) as ApplicationState;<EOL>        const workspace: any = getWorkspaceById(","gt":"state, workspaceId);"}
{"input":"<s> function* handleSelectionStoppedMoving(): Generator<any, void, any> {<EOL>    while (true) {<EOL>        const { point, workspaceId } = (yield take(RESIZER_STOPPED_MOVING)) as ResizerMoved;<EOL>        const state: any = (yield select()) as ApplicationState;<EOL>        const workspace: any = getWorkspaceById(state, workspaceId);<EOL>        for (const item: any of getBoundedWorkspaceSelection(workspace)) {<EOL>            <EOL>            if (workspace.stage.fullScreen && workspace.stage.fullScreen.artboardId === item.$id) {<EOL>                continue;<EOL>            }<EOL>            const bounds:","gt":"any = getWorkspaceItemBounds(item, workspace);"}
{"input":"<s> function* addRoutes(server: express.Express): {} {<EOL>    const state: ApplicationState = yield select();<EOL>    server.use(PUBLIC_SRC_DIR_PATH, yield wrapRoute(getFile));<EOL>    server.use(express.static(path.join(path.dirname(require.","gt":"resolve(\"<STR_LIT>\")), \"<STR_LIT>\")));"}
{"input":"<s> function* addRoutes(server: express.Express): {} {<EOL>    const state: ApplicationState = yield select();<EOL>    server.use(PUBLIC_SRC_DIR_PATH, yield wrapRoute(getFile));<EOL>    server.use(express.static(path.join(path.dirname(require.resolve(\"<STR_LIT>\")), \"<STR_LIT>\")));<EOL>    console.log(\"<STR_LIT>\");<EOL>    server.all(/^\\/proxy\\/.*/, yield wrapRoute(proxy));<EOL>    <EOL>    server.get(","gt":"\"<STR_LIT>\", yield wrapRoute(getComponents));"}
{"input":"<s> function* addRoutes(server: express.Express): {} {<EOL>    const state: ApplicationState = yield select();<EOL>    server.use(PUBLIC_SRC_DIR_PATH, yield wrapRoute(getFile));<EOL>    server.use(express.static(path.join(path.dirname(require.resolve(\"<STR_LIT>\")), \"<STR_LIT>\")));<EOL>    console.log(\"<STR_LIT>\");<EOL>    server.all(/^\\/proxy\\/.*/, yield wrapRoute(proxy));<EOL>    <EOL>    server.get(\"<STR_LIT>\", yield wrapRoute(getComponents));<EOL>    <EOL>    server.get(\"<STR_LIT>\", yield wrapRoute(getComponentsScreenshot));<EOL>    <EOL>    <EOL>","gt":"server.get(\"<STR_LIT>\", yield wrapRoute(getAllComponentsPreview));"}
{"input":"<s> function* addRoutes(server: express.Express): {} {<EOL>    const state: ApplicationState = yield select();<EOL>    server.use(PUBLIC_SRC_DIR_PATH, yield wrapRoute(getFile));<EOL>    server.use(express.static(path.join(path.dirname(require.resolve(\"<STR_LIT>\")), \"<STR_LIT>\")));<EOL>    console.log(\"<STR_LIT>\");<EOL>    server.all(/^\\/proxy\\/.*/, yield wrapRoute(proxy));<EOL>    <EOL>    server.get(\"<STR_LIT>\", yield wrapRoute(getComponents));<EOL>    <EOL>    server.get(\"<STR_LIT>\", yield wrapRoute(getComponentsScreenshot));<EOL>    <EOL>    <EOL>    server.get(\"<STR_LIT>\", yield wrapRoute(getAllComponentsPreview));<EOL>    <EOL>    server.get(\"<STR_LIT>\", yield wrapRoute(getComponentHTMLPreview));<EOL>    server.get(\"<STR_LIT>\", yield wrapRoute(","gt":"getComponentJSONPreview));"}
{"input":"<s> function* addRoutes(server: express.Express): {} {<EOL>    const state: ApplicationState = yield select();<EOL>    server.use(PUBLIC_SRC_DIR_PATH, yield wrapRoute(getFile));<EOL>    server.use(express.static(path.join(path.dirname(require.resolve(\"<STR_LIT>\")), \"<STR_LIT>\")));<EOL>    console.log(\"<STR_LIT>\");<EOL>    server.all(/^\\/proxy\\/.*/, yield wrapRoute(proxy));<EOL>    <EOL>    server.get(\"<STR_LIT>\", yield wrapRoute(getComponents));<EOL>    <EOL>    server.get(\"<STR_LIT>\", yield wrapRoute(getComponentsScreenshot));<EOL>    <EOL>    <EOL>    server.get(\"<STR_LIT>\", yield wrapRoute(getAllComponentsPreview));<EOL>    <EOL>    server.get(\"<STR_LIT>\", yield wrapRoute(getComponentHTMLPreview));<EOL>    server.get(\"<STR_LIT>\", yield wrapRoute(getComponentJSONPreview));<EOL>    server.get(\"<STR_LIT>\", yield wrapRoute(getComponentJSONPreview));<EOL>    server.get(\"<STR_LIT>\", yield wrapRoute(getComponentHTMLPreview));<EOL>    server.get(\"<STR_LIT>\", yield wrapRoute(getComponentJSONPreviewDiff));<EOL>    server.get(\"<STR_LIT>\", yield wrapRoute(getComponentJSONPreviewDiff));<EOL>    server.get(\"<STR_LIT>\", yield","gt":"wrapRoute(getVMObjectSoureInfo));"}
{"input":"<s> function* addRoutes(server: express.Express): {} {<EOL>    const state: ApplicationState = yield select();<EOL>    server.use(PUBLIC_SRC_DIR_PATH, yield wrapRoute(getFile));<EOL>    server.use(express.static(path.join(path.dirname(require.resolve(\"<STR_LIT>\")), \"<STR_LIT>\")));<EOL>    console.log(\"<STR_LIT>\");<EOL>    server.all(/^\\/proxy\\/.*/, yield wrapRoute(proxy));<EOL>    <EOL>    server.get(\"<STR_LIT>\", yield wrapRoute(getComponents));<EOL>    <EOL>    server.get(\"<STR_LIT>\", yield wrapRoute(getComponentsScreenshot));<EOL>    <EOL>    <EOL>    server.get(\"<STR_LIT>\", yield wrapRoute(getAllComponentsPreview));<EOL>    <EOL>    server.get(\"<STR_LIT>\", yield wrapRoute(getComponentHTMLPreview));<EOL>    server.get(\"<STR_LIT>\", yield wrapRoute(getComponentJSONPreview));<EOL>    server.get(\"<STR_LIT>\", yield wrapRoute(getComponentJSONPreview));<EOL>    server.get(\"<STR_LIT>\", yield wrapRoute(getComponentHTMLPreview));<EOL>    server.get(\"<STR_LIT>\", yield wrapRoute(getComponentJSONPreviewDiff));<EOL>    server.get(\"<STR_LIT>\", yield wrapRoute(getComponentJSONPreviewDiff));<EOL>    server.get(\"<STR_LIT>\", yield wrapRoute(getVMObjectSoureInfo));<EOL>    server.get(\"<STR_LIT>\", yield wrapRoute(getVMObjectSoureInfo));<EOL>    <EOL>    server.get(\"<STR_LIT>\", yield wrapRoute(getClippedComponentScreenshot));<EOL>    server.get(\"<STR_LIT>\", yield wrapRoute(getClippedComponentScreenshot));<EOL>    <EOL>    server.post(\"<STR_LIT>\", yield wrapRoute(createComponent));<EOL>    <EOL>","gt":"server.delete(\"<STR_LIT>\", yield wrapRoute(deleteComponent));"}
{"input":"<s> function* getPostData(req: any): Generator<any, any, unknown> {<EOL>    const chan: any = eventChannel((emit: any): () => void => {<EOL>        let buffer: any[] = [];<EOL>        req.on(\"<STR_LIT>\", (","gt":"chunk: any): number => buffer.push(chunk));"}
{"input":"<s> export function* mainSaga(): {} {<EOL>    yield fork(frontEndSaga);<EOL>    yield","gt":"fork(vscodeSaga);"}
{"input":"<s> function* handleTextDocumentChange(): {} {<EOL>    const chan: any = eventChannel((emit: any): () => void => {<EOL>        vscode.workspace.onDidChangeTextDocument((e: any): void => {<EOL>            const document: vscode.TextDocument = e.document as vscode.TextDocument;<EOL>            emit(textContentChanged(document.uri.fsPath, document.getText()));<EOL>        });<EOL>","gt":"return (): void => { };"}
{"input":"<s> function* handleTextDocumentChange(): {} {<EOL>    const chan: any = eventChannel((emit: any): () => void => {<EOL>        vscode.workspace.onDidChangeTextDocument((e: any): void => {<EOL>            const document: vscode.TextDocument = e.document as vscode.TextDocument;<EOL>            emit(textContentChanged(document.uri.fsPath, document.getText()));<EOL>        });<EOL>        return (): void => { };<EOL>    });<EOL>    while (true) {<EOL>        const action: any = yield take(chan);<EOL>","gt":"const state: ExtensionState = yield select();"}
{"input":"<s> function* handleTextDocumentChange(): {} {<EOL>    const chan: any = eventChannel((emit: any): () => void => {<EOL>        vscode.workspace.onDidChangeTextDocument((e: any): void => {<EOL>            const document: vscode.TextDocument = e.document as vscode.TextDocument;<EOL>            emit(textContentChanged(document.uri.fsPath, document.getText()));<EOL>        });<EOL>        return (): void => { };<EOL>    });<EOL>    while (true) {<EOL>        const action: any = yield take(chan);<EOL>        const state: ExtensionState = yield select();<EOL>        <EOL>        <EOL>        if (getFileCacheContent(action.filePath, state) && getFileCacheContent(action.filePath, state) === action.","gt":"content) {"}
{"input":"<s> function visitEdge(graph: dagre.graphlib.Graph, idTable: IdTable, inStream: Stream<any>, operator: InternalProducer, outStream: Stream<any>): void {<EOL>    makeSureNodeIsRegistered(graph, idTable, inStream);<EOL>    makeSureNodeIsRegistered(graph, idTable, outStream);<EOL>    graph.setEdge(idTable.","gt":"getId(inStream), idTable.getId(operator), {});"}
{"input":"<s> function totalIsolateSource<S extends DOMSource>(source: S, scope: string): S {<EOL>    return source.select(","gt":"SCOPE_PREFIX + scope) as S;"}
{"input":"<s> function makeDOMReady$(): Stream<null> {<EOL>    return xs.create<null>({<EOL>        start(lis: Listener<null>) {<EOL>            if (document.readyState === '<STR_LIT>') {<EOL>                document.addEventListener('<STR_LIT>', (): void => {<EOL>                    const state: string = document.readyState;<EOL>                    if (","gt":"state === '<STR_LIT>' || state === '<STR_LIT>') {"}
{"input":"<s> function makeDOMReady$(): Stream<null> {<EOL>    return xs.create<null>({<EOL>        start(lis: Listener<null>) {<EOL>            if (document.readyState === '<STR_LIT>') {<EOL>                document.addEventListener('<STR_LIT>', (): void => {<EOL>                    const state: string = document.readyState;<EOL>                    if (state === '<STR_LIT>' || state === '<STR_LIT>') {<EOL>                        lis.next(null);<EOL>                        lis.complete();<EOL>                    }<EOL>                });<EOL>            }<EOL>            else {<EOL>                lis.next(null);<EOL>                lis.","gt":"complete();"}
{"input":"<s> export function thunk(sel: string, key?: any, fn?: any, args?: any): VNode {<EOL>    if (args === undefined) {<EOL>        args = fn;<EOL>        fn = key;<EOL>","gt":"key = undefined;"}
{"input":"<s> export function thunk(sel: string, key?: any, fn?: any, args?: any): VNode {<EOL>    if (args === undefined) {<EOL>        args = fn;<EOL>        fn = key;<EOL>        key = undefined;<EOL>    }<EOL>    return h(sel, {<EOL>        key: key,<EOL>        hook: { init: init, prepatch: prepatch },<EOL>","gt":"fn: fn,"}
{"input":"<s> function createRenderTarget(id: string | null = null): HTMLDivElement {<EOL>    const element: HTMLDivElement = document.createElement('<STR_LIT>');<EOL>    element.className = '<STR_LIT>';<EOL>    if (","gt":"id) {"}
{"input":"<s> function processEvent(args: any): void {<EOL>    const { scheduler, done, currentTime, setTime, timeToRunTo } = args;<EOL>    const nextEvent: any = scheduler.peek();<EOL>    const outOfTime: any = nextEvent && timeToRunTo && nextEvent.time >= timeToRunTo;<EOL>    if (!nextEvent || outOfTime) {<EOL>","gt":"done();"}
{"input":"<s> function processEvent(args: any): void {<EOL>    const { scheduler, done, currentTime, setTime, timeToRunTo } = args;<EOL>    const nextEvent: any = scheduler.peek();<EOL>    const outOfTime: any = nextEvent && timeToRunTo && nextEvent.time >= timeToRunTo;<EOL>    if (!nextEvent || outOfTime) {<EOL>        done();<EOL>        return;<EOL>    }<EOL>    const eventToProcess: any = scheduler.shiftNextEntry();<EOL>    if (","gt":"eventToProcess.cancelled) {"}
{"input":"<s> function processEvent(args: any): void {<EOL>    const { scheduler, done, currentTime, setTime, timeToRunTo } = args;<EOL>    const nextEvent: any = scheduler.peek();<EOL>    const outOfTime: any = nextEvent && timeToRunTo && nextEvent.time >= timeToRunTo;<EOL>    if (!nextEvent || outOfTime) {<EOL>        done();<EOL>        return;<EOL>    }<EOL>    const eventToProcess: any = scheduler.shiftNextEntry();<EOL>    if (eventToProcess.cancelled) {<EOL>        setImmediate(processEvent, args);<EOL>        return;<EOL>    }<EOL>    const time: any = eventToProcess.time;<EOL>    setTime(time);<EOL>    if (eventToProcess.","gt":"f) {"}
{"input":"<s> function processEvent(args: any): void {<EOL>    const { scheduler, done, currentTime, setTime, timeToRunTo } = args;<EOL>    const nextEvent: any = scheduler.peek();<EOL>    const outOfTime: any = nextEvent && timeToRunTo && nextEvent.time >= timeToRunTo;<EOL>    if (!nextEvent || outOfTime) {<EOL>        done();<EOL>        return;<EOL>    }<EOL>    const eventToProcess: any = scheduler.shiftNextEntry();<EOL>    if (eventToProcess.cancelled) {<EOL>        setImmediate(processEvent, args);<EOL>        return;<EOL>    }<EOL>    const time: any = eventToProcess.time;<EOL>    setTime(time);<EOL>    if (eventToProcess.f) {<EOL>        eventToProcess.f(eventToProcess, time, scheduler.add, currentTime);<EOL>    }<EOL>    if (eventToProcess.type === '<STR_LIT>') {<EOL>        eventToProcess.stream.shamefullySendNext(eventToProcess.value);<EOL>    }<EOL>    if (","gt":"eventToProcess.type === '<STR_LIT>') {"}
{"input":"<s> export function reducer(state: Entities<ClaimRebuttal> = initialEntities<ClaimRebuttal>(slices.CLAIM_REBUTTAL, initialClaimRebuttal), action: EntityAction<ClaimRebuttal>): Entities<ClaimRebuttal> {<EOL>    const entities: {} = {};<EOL>    switch (action.type) {<EOL>        case typeFor(slices.CLAIM_REBUTTAL, actions.ADD_SUCCESS):<EOL>        case typeFor(slices.CLAIM_REBUTTAL, actions.ADD_TEMP):<EOL>            return entityFunctions.addEntityToStore<ClaimRebuttal>(state, <any>action);<EOL>        case typeFor(slices.","gt":"CLAIM_REBUTTAL, actions.ASYNC_SUCCESS):"}
{"input":"<s> export function reducer(state: Entities<ClaimRebuttal> = initialEntities<ClaimRebuttal>(slices.CLAIM_REBUTTAL, initialClaimRebuttal), action: EntityAction<ClaimRebuttal>): Entities<ClaimRebuttal> {<EOL>    const entities: {} = {};<EOL>    switch (action.type) {<EOL>        case typeFor(slices.CLAIM_REBUTTAL, actions.ADD_SUCCESS):<EOL>        case typeFor(slices.CLAIM_REBUTTAL, actions.ADD_TEMP):<EOL>            return entityFunctions.addEntityToStore<ClaimRebuttal>(state, <any>action);<EOL>        case typeFor(slices.CLAIM_REBUTTAL, actions.ASYNC_SUCCESS):<EOL>            return entityFunctions.addEntitiesToStore(state, <any>action);<EOL>        case typeFor(slices.CLAIM_REBUTTAL, actions.DELETE):<EOL>            return entityFunctions.deleteEntity<ClaimRebuttal>(state, <any>action);<EOL>        case typeFor(slices.CLAIM_REBUTTAL,","gt":"actions.DELETE_TEMP):"}
{"input":"<s> export function reducer(state: Entities<ClaimRebuttal> = initialEntities<ClaimRebuttal>(slices.CLAIM_REBUTTAL, initialClaimRebuttal), action: EntityAction<ClaimRebuttal>): Entities<ClaimRebuttal> {<EOL>    const entities: {} = {};<EOL>    switch (action.type) {<EOL>        case typeFor(slices.CLAIM_REBUTTAL, actions.ADD_SUCCESS):<EOL>        case typeFor(slices.CLAIM_REBUTTAL, actions.ADD_TEMP):<EOL>            return entityFunctions.addEntityToStore<ClaimRebuttal>(state, <any>action);<EOL>        case typeFor(slices.CLAIM_REBUTTAL, actions.ASYNC_SUCCESS):<EOL>            return entityFunctions.addEntitiesToStore(state, <any>action);<EOL>        case typeFor(slices.CLAIM_REBUTTAL, actions.DELETE):<EOL>            return entityFunctions.deleteEntity<ClaimRebuttal>(state, <any>action);<EOL>        case typeFor(slices.CLAIM_REBUTTAL, actions.DELETE_TEMP):<EOL>            return entityFunctions.deleteTemp<ClaimRebuttal>(state, <any>action);<EOL>        case typeFor(slices.CLAIM_REBUTTAL, actions.UPDATE):<EOL>","gt":"return sliceFunctions.patch(state, <any>action);"}
{"input":"<s> export function selectNext<T extends Entity>(state: Entities<T>, action: EntityActions.SelectNext<T>): Entities<T> {<EOL>    let ix: number = <NUM_LIT> + state.ids.indexOf(state.selectedEntityId);<EOL>    if (ix >= state.","gt":"ids.length) {"}
{"input":"<s> export function initialIDs(slice: string, vals: any = {}): IDs {<EOL>    return Object.assign({},","gt":"initialSlice(slice), {"}
{"input":"<s> export function reducer(state = initialIDs(slices.SEARCH), action: SliceAction): IDs {<EOL>    switch (action.type) {<EOL>        case typeFor(slices.SEARCH, actions.ASYNC_SUCCESS):<EOL>            return idFunctions.updateIDs(","gt":"state, action);"}
{"input":"<s> export function loadFail(state, action: SliceAction): any {<EOL>    const newState: any = merge({}, state, {<EOL>        hasError:","gt":"true,"}
{"input":"<s> export function patch(state: any, action: SliceAction): any {<EOL>    return patchOrUpdate(state, action,","gt":"false);"}
{"input":"<s> <EOL>function patchOrUpdate(state: any, action: SliceAction, update: boolean): any {<EOL>    let obj: any[] = [state];<EOL>    let patch: boolean = !update;<EOL>    const path: any = action.payload.path;<EOL>    const hasPath:","gt":"any = path && path.length;"}
{"input":"<s> <EOL>function patchOrUpdate(state: any, action: SliceAction, update: boolean): any {<EOL>    let obj: any[] = [state];<EOL>    let patch: boolean = !update;<EOL>    const path: any = action.payload.path;<EOL>    const hasPath: any = path && path.length;<EOL>    const pathLength:","gt":"any = hasPath ? path.length : <NUM_LIT>;"}
{"input":"<s> <EOL>function patchOrUpdate(state: any, action: SliceAction, update: boolean): any {<EOL>    let obj: any[] = [state];<EOL>    let patch: boolean = !update;<EOL>    const path: any = action.payload.path;<EOL>    const hasPath: any = path && path.length;<EOL>    const pathLength: any = hasPath ? path.length : <NUM_LIT>;<EOL>    const key: any = path[path.length - <NUM_LIT>];<EOL>    let val: {} = {};<EOL>    let","gt":"pos: any = pathLength;"}
{"input":"<s> <EOL>function patchOrUpdate(state: any, action: SliceAction, update: boolean): any {<EOL>    let obj: any[] = [state];<EOL>    let patch: boolean = !update;<EOL>    const path: any = action.payload.path;<EOL>    const hasPath: any = path && path.length;<EOL>    const pathLength: any = hasPath ? path.length : <NUM_LIT>;<EOL>    const key: any = path[path.length - <NUM_LIT>];<EOL>    let val: {} = {};<EOL>    let pos: any = pathLength;<EOL>    <EOL>    if (typeof action.payload.val === '<STR_LIT>') {<EOL>        <EOL>        val =","gt":"action.payload.val;"}
{"input":"<s> <EOL>function patchOrUpdate(state: any, action: SliceAction, update: boolean): any {<EOL>    let obj: any[] = [state];<EOL>    let patch: boolean = !update;<EOL>    const path: any = action.payload.path;<EOL>    const hasPath: any = path && path.length;<EOL>    const pathLength: any = hasPath ? path.length : <NUM_LIT>;<EOL>    const key: any = path[path.length - <NUM_LIT>];<EOL>    let val: {} = {};<EOL>    let pos: any = pathLength;<EOL>    <EOL>    if (typeof action.payload.val === '<STR_LIT>') {<EOL>        <EOL>        val = action.payload.val;<EOL>    }<EOL>    else if (typeof action.payload.val === '<STR_LIT>') {<EOL>        <EOL>        val[key] = action.payload.val(state);<EOL>","gt":"pos--;"}
{"input":"<s> <EOL>function patchOrUpdate(state: any, action: SliceAction, update: boolean): any {<EOL>    let obj: any[] = [state];<EOL>    let patch: boolean = !update;<EOL>    const path: any = action.payload.path;<EOL>    const hasPath: any = path && path.length;<EOL>    const pathLength: any = hasPath ? path.length : <NUM_LIT>;<EOL>    const key: any = path[path.length - <NUM_LIT>];<EOL>    let val: {} = {};<EOL>    let pos: any = pathLength;<EOL>    <EOL>    if (typeof action.payload.val === '<STR_LIT>') {<EOL>        <EOL>        val = action.payload.val;<EOL>    }<EOL>    else if (typeof action.payload.val === '<STR_LIT>') {<EOL>        <EOL>        val[key] = action.payload.val(state);<EOL>        pos--;<EOL>        patch = true;<EOL>    }<EOL>","gt":"else {"}
{"input":"<s> <EOL>function patchOrUpdate(state: any, action: SliceAction, update: boolean): any {<EOL>    let obj: any[] = [state];<EOL>    let patch: boolean = !update;<EOL>    const path: any = action.payload.path;<EOL>    const hasPath: any = path && path.length;<EOL>    const pathLength: any = hasPath ? path.length : <NUM_LIT>;<EOL>    const key: any = path[path.length - <NUM_LIT>];<EOL>    let val: {} = {};<EOL>    let pos: any = pathLength;<EOL>    <EOL>    if (typeof action.payload.val === '<STR_LIT>') {<EOL>        <EOL>        val = action.payload.val;<EOL>    }<EOL>    else if (typeof action.payload.val === '<STR_LIT>') {<EOL>        <EOL>        val[key] = action.payload.val(state);<EOL>        pos--;<EOL>        patch = true;<EOL>    }<EOL>    else {<EOL>        <EOL>        val[key] = action.payload.val;<EOL>        pos--;<EOL>        patch = true;<EOL>    }<EOL>    let i: number = <NUM_LIT>;<EOL>    for (i = <NUM_LIT>; i < pos; i++) {<EOL>        obj[i + <NUM_LIT>] = obj[i][path[i]];<EOL>    }<EOL>","gt":"if (patch) {"}
{"input":"<s> <EOL>function githubCommitToGitCommit(ghCommit: GitHubCommit): GitCommit {<EOL>    return {<EOL>        sha: ghCommit.sha,<EOL>        parents: ghCommit.parents.map((p: any): any =>","gt":"p.sha),"}
{"input":"<s> <EOL><EOL><EOL><EOL><EOL>export async function createDangerfileRuntimeEnvironment(dangerfileContext: DangerContext): Promise<NodeVMOptions> {<EOL>    <EOL>    <EOL>    <EOL>    Object.keys(dangerfileContext).forEach((key: string): void => {<EOL>        global[key] =","gt":"dangerfileContext[key];"}
{"input":"<s> <EOL><EOL><EOL><EOL><EOL>export async function createDangerfileRuntimeEnvironment(dangerfileContext: DangerContext): Promise<NodeVMOptions> {<EOL>    <EOL>    <EOL>    <EOL>    Object.keys(dangerfileContext).forEach((key: string): void => {<EOL>        global[key] = dangerfileContext[key];<EOL>    });<EOL>    return {<EOL>        require: {<EOL>            external:","gt":"true,"}
{"input":"<s> export function deactivate(): PromiseLike<void> {<EOL>    setCommandVisiblity(false,","gt":"null);"}
{"input":"<s> export function getDartWorkspaceFolders(): WorkspaceFolder[] {<EOL>    if (!workspace.","gt":"workspaceFolders)"}
{"input":"<s> export function isAnalyzableAndInWorkspace(document: TextDocument): boolean {<EOL>    if (document.","gt":"isUntitled || !document.fileName)"}
{"input":"<s> export function log(message: any): void {<EOL>    console.","gt":"log(message);"}
{"input":"<s> export function Machine(config: MachineConfig | ParallelMachineConfig): StandardMachine | ParallelMachine {<EOL>    return new StateNode(config)","gt":"as StandardMachine | ParallelMachine;"}
{"input":"<s> export default function getCompareOperator(operator: string, negated: boolean): string {<EOL>    switch (operator) {<EOL>        case '<STR_LIT>':<EOL>        case '<STR_LIT>':<EOL>            return negated ? '<STR_LIT>' : '<STR_LIT>';<EOL>        case '<STR_LIT>':<EOL>        case","gt":"'<STR_LIT>':"}
{"input":"<s> export default function getCompareOperator(operator: string, negated: boolean): string {<EOL>    switch (operator) {<EOL>        case '<STR_LIT>':<EOL>        case '<STR_LIT>':<EOL>            return negated ? '<STR_LIT>' : '<STR_LIT>';<EOL>        case '<STR_LIT>':<EOL>        case '<STR_LIT>':<EOL>            return negated ? '<STR_LIT>' : '<STR_LIT>';<EOL>        case '<STR_LIT>':<EOL>            return negated ? '<STR_LIT>' : '<STR_LIT>';<EOL>","gt":"case '<STR_LIT>':"}
{"input":"<s> export default function getCompareOperator(operator: string, negated: boolean): string {<EOL>    switch (operator) {<EOL>        case '<STR_LIT>':<EOL>        case '<STR_LIT>':<EOL>            return negated ? '<STR_LIT>' : '<STR_LIT>';<EOL>        case '<STR_LIT>':<EOL>        case '<STR_LIT>':<EOL>            return negated ? '<STR_LIT>' : '<STR_LIT>';<EOL>        case '<STR_LIT>':<EOL>            return negated ? '<STR_LIT>' : '<STR_LIT>';<EOL>        case '<STR_LIT>':<EOL>            return negated ? '<STR_LIT>' : '<STR_LIT>';<EOL>        case '<STR_LIT>':<EOL>            return negated ? '<STR_LIT>' : '<STR_LIT>';<EOL>","gt":"case '<STR_LIT>':"}
{"input":"<s> function trimRight(string: string): string {<EOL>","gt":"return string.replace(/\\s+$/, '<STR_LIT>');"}
{"input":"<s> function checkSoak(input: string, expectedOutput: string, expectedOptionalChainingOutput: string): void {<EOL>    check(","gt":"input, expectedOutput);"}
{"input":"<s> <EOL>export function get(data: any, path: string | null, deepCopy: boolean): any {<EOL>    const tokens: (string | number)[] = tokenize(path);<EOL>    let value: any = data;<EOL>    for (let i: number = <NUM_LIT>; i < tokens.length; i++) {<EOL>","gt":"if (value === undefined) {"}
{"input":"<s> <EOL>export function get(data: any, path: string | null, deepCopy: boolean): any {<EOL>    const tokens: (string | number)[] = tokenize(path);<EOL>    let value: any = data;<EOL>    for (let i: number = <NUM_LIT>; i < tokens.length; i++) {<EOL>        if (value === undefined) {<EOL>            return undefined;<EOL>        }<EOL>        if (typeof value !== '<STR_LIT>') {<EOL>            throw new Error('<STR_LIT>');<EOL>        }<EOL>        value =","gt":"value[tokens[i]];"}
{"input":"<s> <EOL>function handleUUIDProperty(config: InternalDeepstreamConfig): void {<EOL>","gt":"if (config.serverName === '<STR_LIT>') {"}
{"input":"<s> <EOL>function tokenize(path: string): Array<string | number> {<EOL>    const tokens: Array<string | number> = [];<EOL>    const parts: string[] = path.split('<STR_LIT>');<EOL>    for (let i: number = <NUM_LIT>; i < parts.length; i++) {<EOL>","gt":"const part: string = parts[i].trim();"}
{"input":"<s> <EOL>function tokenize(path: string): Array<string | number> {<EOL>    const tokens: Array<string | number> = [];<EOL>    const parts: string[] = path.split('<STR_LIT>');<EOL>    for (let i: number = <NUM_LIT>; i < parts.length; i++) {<EOL>        const part: string = parts[i].trim();<EOL>        if (part.length === <NUM_LIT>) {<EOL>            continue;<EOL>        }<EOL>        const arrayIndexes: Array<string> = part.split(SPLIT_REG_EXP);<EOL>        if (arrayIndexes.length === <NUM_LIT>) {<EOL>            <EOL>            continue;<EOL>        }<EOL>        tokens.push(arrayIndexes[<NUM_LIT>]);<EOL>        for (let j: number = <NUM_LIT>; j < arrayIndexes.length; j++) {<EOL>            if (arrayIndexes[j].length === <NUM_LIT>) {<EOL>","gt":"continue;"}
{"input":"<s> <EOL>export function recordRequest(recordName: string, config: InternalDeepstreamConfig, services: DeepstreamServices, socketWrapper: SocketWrapper | null, onComplete: onCompleteCallback, onError: onErrorCallback, context: any, metaData?: any, message?: Message): void {<EOL>    let cacheTimedOut: boolean = false;<EOL>    const cacheTimeout: number = setTimeout((): void => {<EOL>        cacheTimedOut = true;<EOL>        sendError(RECORD_ACTIONS.CACHE_RETRIEVAL_TIMEOUT,","gt":"recordName, recordName, socketWrapper, onError, services, context, metaData, message);"}
{"input":"<s> <EOL>export function recordRequest(recordName: string, config: InternalDeepstreamConfig, services: DeepstreamServices, socketWrapper: SocketWrapper | null, onComplete: onCompleteCallback, onError: onErrorCallback, context: any, metaData?: any, message?: Message): void {<EOL>    let cacheTimedOut: boolean = false;<EOL>    const cacheTimeout: number = setTimeout((): void => {<EOL>        cacheTimedOut = true;<EOL>        sendError(RECORD_ACTIONS.CACHE_RETRIEVAL_TIMEOUT, recordName, recordName, socketWrapper, onError, services, context, metaData, message);<EOL>    }, config.cacheRetrievalTimeout);<EOL>    services.cache.get(recordName, (error: string | null, version: number, data: any): void => {<EOL>        if (!cacheTimedOut) {<EOL>            clearTimeout(cacheTimeout);<EOL>            onCacheResponse(error, recordName,","gt":"version, data, socketWrapper, onComplete, onError, config, services, context, metaData, message);"}
{"input":"<s> function printInstructions(nextVersion: string, entries: Array<string>): void {<EOL>    const object: any = {};<EOL>    object[`<STR_LIT>`] = entries.sort();<EOL>    const steps: string[] = [<EOL>","gt":"nextVersion}'<STR_LIT>,"}
{"input":"<s> function printInstructions(nextVersion: string, entries: Array<string>): void {<EOL>    const object: any = {};<EOL>    object[`<STR_LIT>`] = entries.sort();<EOL>    const steps: string[] = [<EOL>        `<STR_LIT>`,<EOL>        `<STR_LIT>`,<EOL>        '<STR_LIT>',<EOL>        '<STR_LIT>',<EOL>","gt":"'<STR_LIT>',"}
{"input":"<s> function packageOSX(): void {<EOL>    const dest: string = getOSXZipPath();<EOL>    fs.removeSync(","gt":"dest);"}
{"input":"<s> function parseProjectPath(parsed: string): string {<EOL>    return","gt":"parsed || DEFAULT_PROJECT_PATH;"}
{"input":"<s> <EOL>export async function remapSourceMap(sourceFile: string): Promise<void> {<EOL>    log.debug(`<STR_LIT>`);<EOL>    const opts: any = {<EOL>        inline: false,<EOL>        includeContent:","gt":"true"}
{"input":"<s> <EOL>export async function remapSourceMap(sourceFile: string): Promise<void> {<EOL>    log.debug(`<STR_LIT>`);<EOL>    const opts: any = {<EOL>        inline: false,<EOL>        includeContent: true<EOL>    };<EOL>    <EOL>    const chain: any = await sorcery.load(sourceFile);<EOL>    if (!chain) {<EOL>","gt":"throw new Error('<STR_LIT>' + sourceFile);"}
{"input":"<s> <EOL>export function writeSourceFile(sourceFile: ts.SourceFile | SynthesizedSourceFile): ts.SourceFile {<EOL>    if (isSynthesizedSourceFile(sourceFile)) {<EOL>        const sourceText: string = writeSourceText(sourceFile);<EOL>        return ts.createSourceFile(sourceFile.fileName, sourceText, sourceFile.languageVersion, true,","gt":"ts.ScriptKind.TS);"}
{"input":"<s> <EOL>export function writeSourceText(sourceFile: ts.SourceFile | SynthesizedSourceFile): string {<EOL>    const originalSource: any = sourceFile.getFullText();<EOL>    if (isSynthesizedSourceFile(sourceFile)) {<EOL>        let newSource: string = '<STR_LIT>';<EOL>        let position: number = <NUM_LIT>;<EOL>        for (let replacement: Replacement of sourceFile.","gt":"__replacements) {"}
{"input":"<s> export function createSourceFile(sourceText: TemplateStringsArray | string, fileName: string = '<STR_LIT>'): ts.SourceFile {<EOL>    if (typeof sourceText !== '<STR_LIT>') {<EOL>        sourceText = tags.stripIndent(","gt":"sourceText);"}
{"input":"<s> <EOL>function toObservable<T extends object>(obj: T): T {<EOL>    if (Object.getOwnPropertySymbols(obj).indexOf(globalState.ignoreDynamicSymbol) > -<NUM_LIT>) {<EOL>        <EOL>","gt":"return obj;"}
{"input":"<s> <EOL>function toObservable<T extends object>(obj: T): T {<EOL>    if (Object.getOwnPropertySymbols(obj).indexOf(globalState.ignoreDynamicSymbol) > -<NUM_LIT>) {<EOL>        <EOL>        return obj;<EOL>    }<EOL>","gt":"let dynamicObject: T;"}
{"input":"<s> <EOL>function toObservable<T extends object>(obj: T): T {<EOL>    if (Object.getOwnPropertySymbols(obj).indexOf(globalState.ignoreDynamicSymbol) > -<NUM_LIT>) {<EOL>        <EOL>        return obj;<EOL>    }<EOL>    let dynamicObject: T;<EOL>    const builtIn: any = builtIns.get(obj.constructor);<EOL>    if (typeof builtIn === \"<STR_LIT>\" || typeof builtIn ===","gt":"\"<STR_LIT>\") {"}
{"input":"<s> <EOL>function toObservable<T extends object>(obj: T): T {<EOL>    if (Object.getOwnPropertySymbols(obj).indexOf(globalState.ignoreDynamicSymbol) > -<NUM_LIT>) {<EOL>        <EOL>        return obj;<EOL>    }<EOL>    let dynamicObject: T;<EOL>    const builtIn: any = builtIns.get(obj.constructor);<EOL>    if (typeof builtIn === \"<STR_LIT>\" || typeof builtIn === \"<STR_LIT>\") {<EOL>        <EOL>        dynamicObject = builtIn(obj, bindCurrentReaction, queueRunReactions, getProxyValue);<EOL>    }<EOL>","gt":"else if (!builtIn) {"}
{"input":"<s> <EOL>function toObservable<T extends object>(obj: T): T {<EOL>    if (Object.getOwnPropertySymbols(obj).indexOf(globalState.ignoreDynamicSymbol) > -<NUM_LIT>) {<EOL>        <EOL>        return obj;<EOL>    }<EOL>    let dynamicObject: T;<EOL>    const builtIn: any = builtIns.get(obj.constructor);<EOL>    if (typeof builtIn === \"<STR_LIT>\" || typeof builtIn === \"<STR_LIT>\") {<EOL>        <EOL>        dynamicObject = builtIn(obj, bindCurrentReaction, queueRunReactions, getProxyValue);<EOL>    }<EOL>    else if (!builtIn) {<EOL>        dynamicObject = new Proxy(","gt":"obj, {"}
{"input":"<s> <EOL>function toObservable<T extends object>(obj: T): T {<EOL>    if (Object.getOwnPropertySymbols(obj).indexOf(globalState.ignoreDynamicSymbol) > -<NUM_LIT>) {<EOL>        <EOL>        return obj;<EOL>    }<EOL>    let dynamicObject: T;<EOL>    const builtIn: any = builtIns.get(obj.constructor);<EOL>    if (typeof builtIn === \"<STR_LIT>\" || typeof builtIn === \"<STR_LIT>\") {<EOL>        <EOL>        dynamicObject = builtIn(obj, bindCurrentReaction, queueRunReactions, getProxyValue);<EOL>    }<EOL>    else if (!builtIn) {<EOL>        dynamicObject = new Proxy(obj, {<EOL>            get(target, key, receiver) {<EOL>                let value: any = Reflect.get(target, key, receiver);<EOL>                <EOL>                if (key === \"<STR_LIT>\") {<EOL>","gt":"return target;"}
{"input":"<s> <EOL>function toObservable<T extends object>(obj: T): T {<EOL>    if (Object.getOwnPropertySymbols(obj).indexOf(globalState.ignoreDynamicSymbol) > -<NUM_LIT>) {<EOL>        <EOL>        return obj;<EOL>    }<EOL>    let dynamicObject: T;<EOL>    const builtIn: any = builtIns.get(obj.constructor);<EOL>    if (typeof builtIn === \"<STR_LIT>\" || typeof builtIn === \"<STR_LIT>\") {<EOL>        <EOL>        dynamicObject = builtIn(obj, bindCurrentReaction, queueRunReactions, getProxyValue);<EOL>    }<EOL>    else if (!builtIn) {<EOL>        dynamicObject = new Proxy(obj, {<EOL>            get(target, key, receiver) {<EOL>                let value: any = Reflect.get(target, key, receiver);<EOL>                <EOL>                if (key === \"<STR_LIT>\") {<EOL>                    return target;<EOL>                }<EOL>                <EOL>                globalState.event.emit(\"<STR_LIT>\", { target, key, value });<EOL>                bindCurrentReaction(target, key);<EOL>                value = getProxyValue(target, key, value);<EOL>                return","gt":"value;"}
{"input":"<s> <EOL>function toObservable<T extends object>(obj: T): T {<EOL>    if (Object.getOwnPropertySymbols(obj).indexOf(globalState.ignoreDynamicSymbol) > -<NUM_LIT>) {<EOL>        <EOL>        return obj;<EOL>    }<EOL>    let dynamicObject: T;<EOL>    const builtIn: any = builtIns.get(obj.constructor);<EOL>    if (typeof builtIn === \"<STR_LIT>\" || typeof builtIn === \"<STR_LIT>\") {<EOL>        <EOL>        dynamicObject = builtIn(obj, bindCurrentReaction, queueRunReactions, getProxyValue);<EOL>    }<EOL>    else if (!builtIn) {<EOL>        dynamicObject = new Proxy(obj, {<EOL>            get(target, key, receiver) {<EOL>                let value: any = Reflect.get(target, key, receiver);<EOL>                <EOL>                if (key === \"<STR_LIT>\") {<EOL>                    return target;<EOL>                }<EOL>                <EOL>                globalState.event.emit(\"<STR_LIT>\", { target, key, value });<EOL>                bindCurrentReaction(target, key);<EOL>                value = getProxyValue(target, key, value);<EOL>                return value;<EOL>            },<EOL>            set(target, key, value, receiver) {<EOL>                const oldValue: any = Reflect.get(target, key, receiver);<EOL>                <EOL>                if (typeof value === \"<STR_LIT>\" && value) {<EOL>                    value = value.$raw || value;<EOL>                }<EOL>                globalState.event.emit(\"<STR_LIT>\", { target, key, value,","gt":"oldValue });"}
{"input":"<s> <EOL>function toObservable<T extends object>(obj: T): T {<EOL>    if (Object.getOwnPropertySymbols(obj).indexOf(globalState.ignoreDynamicSymbol) > -<NUM_LIT>) {<EOL>        <EOL>        return obj;<EOL>    }<EOL>    let dynamicObject: T;<EOL>    const builtIn: any = builtIns.get(obj.constructor);<EOL>    if (typeof builtIn === \"<STR_LIT>\" || typeof builtIn === \"<STR_LIT>\") {<EOL>        <EOL>        dynamicObject = builtIn(obj, bindCurrentReaction, queueRunReactions, getProxyValue);<EOL>    }<EOL>    else if (!builtIn) {<EOL>        dynamicObject = new Proxy(obj, {<EOL>            get(target, key, receiver) {<EOL>                let value: any = Reflect.get(target, key, receiver);<EOL>                <EOL>                if (key === \"<STR_LIT>\") {<EOL>                    return target;<EOL>                }<EOL>                <EOL>                globalState.event.emit(\"<STR_LIT>\", { target, key, value });<EOL>                bindCurrentReaction(target, key);<EOL>                value = getProxyValue(target, key, value);<EOL>                return value;<EOL>            },<EOL>            set(target, key, value, receiver) {<EOL>                const oldValue: any = Reflect.get(target, key, receiver);<EOL>                <EOL>                if (typeof value === \"<STR_LIT>\" && value) {<EOL>                    value = value.$raw || value;<EOL>                }<EOL>                globalState.event.emit(\"<STR_LIT>\", { target, key, value, oldValue });<EOL>                const result: boolean = Reflect.set(target, key, value, receiver);<EOL>                <EOL>                <EOL>                if (key === \"<STR_LIT>\" || value !== oldValue) {<EOL>                    queueRunReactions<T>(target, key);<EOL>                }<EOL>                return result;<EOL>            },<EOL>            deleteProperty(target, key) {<EOL>                const hasKey: boolean = Reflect.has(target, key);<EOL>                globalState.event.emit(\"<STR_LIT>\", { target, key });<EOL>                const result: boolean = Reflect.deleteProperty(","gt":"target, key);"}
{"input":"<s> <EOL>function toObservable<T extends object>(obj: T): T {<EOL>    if (Object.getOwnPropertySymbols(obj).indexOf(globalState.ignoreDynamicSymbol) > -<NUM_LIT>) {<EOL>        <EOL>        return obj;<EOL>    }<EOL>    let dynamicObject: T;<EOL>    const builtIn: any = builtIns.get(obj.constructor);<EOL>    if (typeof builtIn === \"<STR_LIT>\" || typeof builtIn === \"<STR_LIT>\") {<EOL>        <EOL>        dynamicObject = builtIn(obj, bindCurrentReaction, queueRunReactions, getProxyValue);<EOL>    }<EOL>    else if (!builtIn) {<EOL>        dynamicObject = new Proxy(obj, {<EOL>            get(target, key, receiver) {<EOL>                let value: any = Reflect.get(target, key, receiver);<EOL>                <EOL>                if (key === \"<STR_LIT>\") {<EOL>                    return target;<EOL>                }<EOL>                <EOL>                globalState.event.emit(\"<STR_LIT>\", { target, key, value });<EOL>                bindCurrentReaction(target, key);<EOL>                value = getProxyValue(target, key, value);<EOL>                return value;<EOL>            },<EOL>            set(target, key, value, receiver) {<EOL>                const oldValue: any = Reflect.get(target, key, receiver);<EOL>                <EOL>                if (typeof value === \"<STR_LIT>\" && value) {<EOL>                    value = value.$raw || value;<EOL>                }<EOL>                globalState.event.emit(\"<STR_LIT>\", { target, key, value, oldValue });<EOL>                const result: boolean = Reflect.set(target, key, value, receiver);<EOL>                <EOL>                <EOL>                if (key === \"<STR_LIT>\" || value !== oldValue) {<EOL>                    queueRunReactions<T>(target, key);<EOL>                }<EOL>                return result;<EOL>            },<EOL>            deleteProperty(target, key) {<EOL>                const hasKey: boolean = Reflect.has(target, key);<EOL>                globalState.event.emit(\"<STR_LIT>\", { target, key });<EOL>                const result: boolean = Reflect.deleteProperty(target, key);<EOL>                if (hasKey) {<EOL>                    queueRunReactions(target, key);<EOL>                }<EOL>                return result;<EOL>            }<EOL>        });<EOL>    }<EOL>","gt":"else {"}
{"input":"<s> <EOL>export function createUniqueId(): number {<EOL>","gt":"return globalState.uniqueIdCounter++;"}
{"input":"<s> <EOL>export function delay<T>(milliseconds: number): Identity<T> {<EOL>    return function (value?: IdentityValue<T>): Promise<T> {<EOL>        return new Promise(function (resolve) {<EOL>            setTimeout(","gt":"function () {"}
{"input":"<s> <EOL>export function diff(a: any, b: any, options: DiffOptions = {}): (ConstructRecord | PatchRecord | SpliceRecord)[] {<EOL>    if (typeof a !== '<STR_LIT>' || typeof b !== '<STR_LIT>') {<EOL>        throw new TypeError('<STR_LIT>');<EOL>    }<EOL>    if (isArray(","gt":"a)) {"}
{"input":"<s> <EOL>export function diff(a: any, b: any, options: DiffOptions = {}): (ConstructRecord | PatchRecord | SpliceRecord)[] {<EOL>    if (typeof a !== '<STR_LIT>' || typeof b !== '<STR_LIT>') {<EOL>        throw new TypeError('<STR_LIT>');<EOL>    }<EOL>    if (isArray(a)) {<EOL>        return diffArray(a, b, options);<EOL>    }<EOL>    if (isArray(b)) {<EOL>        b = objectCreate(null);<EOL>    }<EOL>    if (!isPlainObject(","gt":"a) || !isPlainObject(b)) {"}
{"input":"<s> <EOL>export function isIdentical(a: any, b: any): boolean {<EOL>","gt":"return (a === b ||"}
{"input":"<s> export function isAmdRequire(object: any): object is AmdRequire {<EOL>","gt":"return typeof object.toUrl === '<STR_LIT>';"}
{"input":"<s> export function emit(target: any, event: EventObject<any>): boolean {<EOL>    if (target.dispatchEvent &&<EOL>        ((target.ownerDocument && target.ownerDocument.createEvent) ||<EOL>            (target.document && target.document.createEvent) ||<EOL>            target.createEvent) ) {<EOL>        const nativeEvent: any = (target.ownerDocument || target.","gt":"document || target).createEvent('<STR_LIT>');"}
{"input":"<s> export function emit(target: any, event: EventObject<any>): boolean {<EOL>    if (target.dispatchEvent &&<EOL>        ((target.ownerDocument && target.ownerDocument.createEvent) ||<EOL>            (target.document && target.document.createEvent) ||<EOL>            target.createEvent) ) {<EOL>        const nativeEvent: any = (target.ownerDocument || target.document || target).createEvent('<STR_LIT>');<EOL>        nativeEvent.initEvent(event.type, Boolean((<DOMEventObject>event).bubbles), Boolean((<DOMEventObject>event).cancelable));<EOL>        for (let key: string in event) {<EOL>            if (!(key in","gt":"nativeEvent)) {"}
{"input":"<s> export function emit(target: any, event: EventObject<any>): boolean {<EOL>    if (target.dispatchEvent &&<EOL>        ((target.ownerDocument && target.ownerDocument.createEvent) ||<EOL>            (target.document && target.document.createEvent) ||<EOL>            target.createEvent) ) {<EOL>        const nativeEvent: any = (target.ownerDocument || target.document || target).createEvent('<STR_LIT>');<EOL>        nativeEvent.initEvent(event.type, Boolean((<DOMEventObject>event).bubbles), Boolean((<DOMEventObject>event).cancelable));<EOL>        for (let key: string in event) {<EOL>            if (!(key in nativeEvent)) {<EOL>                nativeEvent[key] = (<any>event)[key];<EOL>            }<EOL>        }<EOL>        return target.dispatchEvent(nativeEvent);<EOL>    }<EOL>    if (","gt":"target.emit) {"}
{"input":"<s> export function emit(target: any, event: EventObject<any>): boolean {<EOL>    if (target.dispatchEvent &&<EOL>        ((target.ownerDocument && target.ownerDocument.createEvent) ||<EOL>            (target.document && target.document.createEvent) ||<EOL>            target.createEvent) ) {<EOL>        const nativeEvent: any = (target.ownerDocument || target.document || target).createEvent('<STR_LIT>');<EOL>        nativeEvent.initEvent(event.type, Boolean((<DOMEventObject>event).bubbles), Boolean((<DOMEventObject>event).cancelable));<EOL>        for (let key: string in event) {<EOL>            if (!(key in nativeEvent)) {<EOL>                nativeEvent[key] = (<any>event)[key];<EOL>            }<EOL>        }<EOL>        return target.dispatchEvent(nativeEvent);<EOL>    }<EOL>    if (target.emit) {<EOL>        if (target.removeListener) {<EOL>            <EOL>            target.emit(event.type, event);<EOL>            return false;<EOL>        }<EOL>        else","gt":"if (target.on) {"}
{"input":"<s> function setOnError(request: XMLHttpRequest, reject: Function): void {<EOL>    request.","gt":"addEventListener('<STR_LIT>', function (event) {"}
{"input":"<s> <EOL>export function throttleAfter<T extends (this: any, ...args: any[]) => void>(callback: T, delay: number): T {<EOL>    let ran: boolean | null;<EOL>    return <T>function () {<EOL>        if (ran) {<EOL>","gt":"return;"}
{"input":"<s> <EOL>export function throttleAfter<T extends (this: any, ...args: any[]) => void>(callback: T, delay: number): T {<EOL>    let ran: boolean | null;<EOL>    return <T>function () {<EOL>        if (ran) {<EOL>            return;<EOL>        }<EOL>        ran = true;<EOL>        let context: any = this;<EOL>        let args: IArguments | null = arguments;<EOL>        guaranteeMinimumTimeout(function () {<EOL>            callback.apply(context,","gt":"args);"}
{"input":"<s> function helloWorldTest(value: any): boolean {<EOL>    return","gt":"value === '<STR_LIT>' || value === '<STR_LIT>';"}
{"input":"<s> export function isRemoteHead(ref: string): boolean {<EOL>    return typeof ref === '<STR_LIT>' &&","gt":"REMOTE_REF_PREFIXES.filter((item: string): boolean => ref.startsWith(item)).length > <NUM_LIT>;"}
{"input":"<s> export function registerTypes(serviceManager: IServiceManager): void {<EOL>    serviceManager.addSingleton<IPlatformService>(IPlatformService, PlatformService);<EOL>    serviceManager.addSingleton<IFileSystem>(","gt":"IFileSystem, FileSystem);"}
{"input":"<s> <EOL>export function isString(str: any): str is string {<EOL>    if (typeof (str) === _typeof.string || str instanceof String) {<EOL>","gt":"return true;"}
{"input":"<s> export function getFirstNonEmptyLineFromMultilineString(stdout: string): string {<EOL>    if (!stdout) {<EOL>","gt":"return '<STR_LIT>';"}
{"input":"<s> export function isBinary(ch: number): boolean {<EOL>","gt":"return ch === Char._0 || ch === Char._1;"}
{"input":"<s> export function isDecimal(ch: number): boolean {<EOL>    return ch >= Char.","gt":"_0 && ch <= Char._9;"}
{"input":"<s> function getExecutablePath(testProvider: TestProvider, settings: IPythonSettings): string | undefined {<EOL>    let testRunnerExecutablePath: string | undefined;<EOL>    switch (testProvider) {<EOL>        case NOSETEST_PROVIDER: {<EOL>            testRunnerExecutablePath = settings.unitTest.nosetestPath;<EOL>","gt":"break;"}
{"input":"<s> function getExecutablePath(testProvider: TestProvider, settings: IPythonSettings): string | undefined {<EOL>    let testRunnerExecutablePath: string | undefined;<EOL>    switch (testProvider) {<EOL>        case NOSETEST_PROVIDER: {<EOL>            testRunnerExecutablePath = settings.unitTest.nosetestPath;<EOL>            break;<EOL>        }<EOL>        case PYTEST_PROVIDER: {<EOL>            testRunnerExecutablePath = settings.unitTest.pyTestPath;<EOL>","gt":"break;"}
{"input":"<s> function getExecutablePath(testProvider: TestProvider, settings: IPythonSettings): string | undefined {<EOL>    let testRunnerExecutablePath: string | undefined;<EOL>    switch (testProvider) {<EOL>        case NOSETEST_PROVIDER: {<EOL>            testRunnerExecutablePath = settings.unitTest.nosetestPath;<EOL>            break;<EOL>        }<EOL>        case PYTEST_PROVIDER: {<EOL>            testRunnerExecutablePath = settings.unitTest.pyTestPath;<EOL>            break;<EOL>        }<EOL>        default: {<EOL>            return","gt":"undefined;"}
{"input":"<s> function dispose(): void {<EOL>","gt":"workspaceTestManagerService.dispose();"}
{"input":"<s> async function getTestManager(displayTestNotConfiguredMessage: boolean, resource?: Uri): Promise<ITestManager | undefined | void> {<EOL>    let wkspace: Uri | undefined;<EOL>    if (resource) {<EOL>        const wkspaceFolder: any = workspace.getWorkspaceFolder(resource);<EOL>        wkspace = wkspaceFolder ? wkspaceFolder.uri : undefined;<EOL>    }<EOL>","gt":"else {"}
{"input":"<s> async function getTestManager(displayTestNotConfiguredMessage: boolean, resource?: Uri): Promise<ITestManager | undefined | void> {<EOL>    let wkspace: Uri | undefined;<EOL>    if (resource) {<EOL>        const wkspaceFolder: any = workspace.getWorkspaceFolder(resource);<EOL>        wkspace = wkspaceFolder ? wkspaceFolder.uri : undefined;<EOL>    }<EOL>    else {<EOL>        wkspace = await selectTestWorkspace();<EOL>    }<EOL>    if (!wkspace) {<EOL>","gt":"return;"}
{"input":"<s> async function getTestManager(displayTestNotConfiguredMessage: boolean, resource?: Uri): Promise<ITestManager | undefined | void> {<EOL>    let wkspace: Uri | undefined;<EOL>    if (resource) {<EOL>        const wkspaceFolder: any = workspace.getWorkspaceFolder(resource);<EOL>        wkspace = wkspaceFolder ? wkspaceFolder.uri : undefined;<EOL>    }<EOL>    else {<EOL>        wkspace = await selectTestWorkspace();<EOL>    }<EOL>    if (!wkspace) {<EOL>        return;<EOL>    }<EOL>    const testManager: ITestManager = workspaceTestManagerService.getTestManager(wkspace);<EOL>    if (testManager) {<EOL>        return","gt":"testManager;"}
{"input":"<s> function getPythonPath(): string {<EOL>    <EOL>","gt":"if (process.env.TRAVIS_PYTHON_PATH && fs.existsSync(process.env.TRAVIS_PYTHON_PATH)) {"}
{"input":"<s> export async function enableDisableWorkspaceSymbols(resource: Uri, enabled: boolean, configTarget: ConfigurationTarget): Promise<void> {<EOL>    const settings:","gt":"any = workspace.getConfiguration('<STR_LIT>', resource);"}
{"input":"<s> function handleResponse(file: string, includeErrorAsResponse: boolean, error: Error, stdout: string, stderr: string, token?: CancellationToken): Promise<string> {<EOL>    return new Promise<string>((resolve: (value: string | PromiseLike<string>) => void, reject: (reason?: any) => void): void => {<EOL>        if (token && token.isCancellationRequested) {<EOL>            return;<EOL>        }<EOL>","gt":"if (isNotInstalledError(error)) {"}
{"input":"<s> function handleResponse(file: string, includeErrorAsResponse: boolean, error: Error, stdout: string, stderr: string, token?: CancellationToken): Promise<string> {<EOL>    return new Promise<string>((resolve: (value: string | PromiseLike<string>) => void, reject: (reason?: any) => void): void => {<EOL>        if (token && token.isCancellationRequested) {<EOL>            return;<EOL>        }<EOL>        if (isNotInstalledError(error)) {<EOL>            return reject(error);<EOL>        }<EOL>        <EOL>        <EOL>        <EOL>        if (includeErrorAsResponse && (stdout.length > <NUM_LIT> || stderr.length > <NUM_LIT>)) {<EOL>            return resolve(stdout +","gt":"'<STR_LIT>' + stderr);"}
{"input":"<s> function handleResponse(file: string, includeErrorAsResponse: boolean, error: Error, stdout: string, stderr: string, token?: CancellationToken): Promise<string> {<EOL>    return new Promise<string>((resolve: (value: string | PromiseLike<string>) => void, reject: (reason?: any) => void): void => {<EOL>        if (token && token.isCancellationRequested) {<EOL>            return;<EOL>        }<EOL>        if (isNotInstalledError(error)) {<EOL>            return reject(error);<EOL>        }<EOL>        <EOL>        <EOL>        <EOL>        if (includeErrorAsResponse && (stdout.length > <NUM_LIT> || stderr.length > <NUM_LIT>)) {<EOL>            return resolve(stdout + '<STR_LIT>' + stderr);<EOL>        }<EOL>        let hasErrors: boolean = (error && error.message.length > <NUM_LIT>) || (stderr && stderr.length > <NUM_LIT>);<EOL>        if (hasErrors && (typeof stdout !== '<STR_LIT>' || stdout.length ===","gt":"<NUM_LIT>)) {"}
{"input":"<s> function handleResponse(file: string, includeErrorAsResponse: boolean, error: Error, stdout: string, stderr: string, token?: CancellationToken): Promise<string> {<EOL>    return new Promise<string>((resolve: (value: string | PromiseLike<string>) => void, reject: (reason?: any) => void): void => {<EOL>        if (token && token.isCancellationRequested) {<EOL>            return;<EOL>        }<EOL>        if (isNotInstalledError(error)) {<EOL>            return reject(error);<EOL>        }<EOL>        <EOL>        <EOL>        <EOL>        if (includeErrorAsResponse && (stdout.length > <NUM_LIT> || stderr.length > <NUM_LIT>)) {<EOL>            return resolve(stdout + '<STR_LIT>' + stderr);<EOL>        }<EOL>        let hasErrors: boolean = (error && error.message.length > <NUM_LIT>) || (stderr && stderr.length > <NUM_LIT>);<EOL>        if (hasErrors && (typeof stdout !== '<STR_LIT>' || stdout.length === <NUM_LIT>)) {<EOL>            let errorMsg: string = (error && error.message) ? error.message : (stderr && stderr.length > <NUM_LIT> ? stderr + '<STR_LIT>' : '<STR_LIT>');<EOL>            console.error('<STR_LIT>');<EOL>            console.error(stdout);<EOL>            console.error('<STR_LIT>');<EOL>            console.error(stderr);<EOL>","gt":"console.error('<STR_LIT>');"}
{"input":"<s> function normalize(message: string): string {<EOL>    return message<EOL>        .replace(/\\./g, \"<STR_LIT>\")<EOL>        .replace(/,/g,","gt":"\"<STR_LIT>\")"}
{"input":"<s> export function compileTemplate(config: GeneratorConfig, templateContext: SchemaTemplateContext, documents: Document[] = [], settings: Settings = DEFAULT_SETTINGS): FileOutput[] {<EOL>    if (!config) {<EOL>        throw new Error(`<STR_LIT>`);<EOL>    }<EOL>    debugLog(","gt":"inputType}`<STR_LIT>;"}
{"input":"<s> export function compileTemplate(config: GeneratorConfig, templateContext: SchemaTemplateContext, documents: Document[] = [], settings: Settings = DEFAULT_SETTINGS): FileOutput[] {<EOL>    if (!config) {<EOL>        throw new Error(`<STR_LIT>`);<EOL>    }<EOL>    debugLog(`<STR_LIT>`);<EOL>    debugLog(`<STR_LIT>`, settings);<EOL>    initHelpers(config, templateContext);<EOL>    const executionSettings: Settings = Object.assign(","gt":"DEFAULT_SETTINGS, settings);"}
{"input":"<s> export function compileTemplate(config: GeneratorConfig, templateContext: SchemaTemplateContext, documents: Document[] = [], settings: Settings = DEFAULT_SETTINGS): FileOutput[] {<EOL>    if (!config) {<EOL>        throw new Error(`<STR_LIT>`);<EOL>    }<EOL>    debugLog(`<STR_LIT>`);<EOL>    debugLog(`<STR_LIT>`, settings);<EOL>    initHelpers(config, templateContext);<EOL>    const executionSettings: Settings = Object.assign(DEFAULT_SETTINGS, settings);<EOL>    const templates: any = config.templates;<EOL>    Object.keys(templates).forEach((templateName: string): void => {<EOL>        debugLog(`<STR_LIT>`);<EOL>        registerPartial(templateName,","gt":"templates[templateName]);"}
{"input":"<s> export function compileTemplate(config: GeneratorConfig, templateContext: SchemaTemplateContext, documents: Document[] = [], settings: Settings = DEFAULT_SETTINGS): FileOutput[] {<EOL>    if (!config) {<EOL>        throw new Error(`<STR_LIT>`);<EOL>    }<EOL>    debugLog(`<STR_LIT>`);<EOL>    debugLog(`<STR_LIT>`, settings);<EOL>    initHelpers(config, templateContext);<EOL>    const executionSettings: Settings = Object.assign(DEFAULT_SETTINGS, settings);<EOL>    const templates: any = config.templates;<EOL>    Object.keys(templates).forEach((templateName: string): void => {<EOL>        debugLog(`<STR_LIT>`);<EOL>        registerPartial(templateName, templates[templateName]);<EOL>    });<EOL>    let mergedDocuments: Document;<EOL>    if (!executionSettings.generateDocuments) {<EOL>        debugLog(`<STR_LIT>`);<EOL>","gt":"mergedDocuments = {"}
{"input":"<s> export function compileTemplate(config: GeneratorConfig, templateContext: SchemaTemplateContext, documents: Document[] = [], settings: Settings = DEFAULT_SETTINGS): FileOutput[] {<EOL>    if (!config) {<EOL>        throw new Error(`<STR_LIT>`);<EOL>    }<EOL>    debugLog(`<STR_LIT>`);<EOL>    debugLog(`<STR_LIT>`, settings);<EOL>    initHelpers(config, templateContext);<EOL>    const executionSettings: Settings = Object.assign(DEFAULT_SETTINGS, settings);<EOL>    const templates: any = config.templates;<EOL>    Object.keys(templates).forEach((templateName: string): void => {<EOL>        debugLog(`<STR_LIT>`);<EOL>        registerPartial(templateName, templates[templateName]);<EOL>    });<EOL>    let mergedDocuments: Document;<EOL>    if (!executionSettings.generateDocuments) {<EOL>        debugLog(`<STR_LIT>`);<EOL>        mergedDocuments = {<EOL>","gt":"fragments: [],"}
{"input":"<s> export function compileTemplate(config: GeneratorConfig, templateContext: SchemaTemplateContext, documents: Document[] = [], settings: Settings = DEFAULT_SETTINGS): FileOutput[] {<EOL>    if (!config) {<EOL>        throw new Error(`<STR_LIT>`);<EOL>    }<EOL>    debugLog(`<STR_LIT>`);<EOL>    debugLog(`<STR_LIT>`, settings);<EOL>    initHelpers(config, templateContext);<EOL>    const executionSettings: Settings = Object.assign(DEFAULT_SETTINGS, settings);<EOL>    const templates: any = config.templates;<EOL>    Object.keys(templates).forEach((templateName: string): void => {<EOL>        debugLog(`<STR_LIT>`);<EOL>        registerPartial(templateName, templates[templateName]);<EOL>    });<EOL>    let mergedDocuments: Document;<EOL>    if (!executionSettings.generateDocuments) {<EOL>        debugLog(`<STR_LIT>`);<EOL>        mergedDocuments = {<EOL>            fragments: [],<EOL>            operations: [],<EOL>            hasFragments: false,<EOL>            hasOperations: false,<EOL>        };<EOL>    }<EOL>    else {<EOL>        mergedDocuments = documents.reduce((previousValue: Document, item: Document): Document => {<EOL>            const opArr: Operation[] = [...previousValue.operations, ...item.operations] as Operation[];<EOL>            const frArr: Fragment[] = [...previousValue.","gt":"fragments, ...item.fragments] as Fragment[];"}
{"input":"<s> export function compileTemplate(config: GeneratorConfig, templateContext: SchemaTemplateContext, documents: Document[] = [], settings: Settings = DEFAULT_SETTINGS): FileOutput[] {<EOL>    if (!config) {<EOL>        throw new Error(`<STR_LIT>`);<EOL>    }<EOL>    debugLog(`<STR_LIT>`);<EOL>    debugLog(`<STR_LIT>`, settings);<EOL>    initHelpers(config, templateContext);<EOL>    const executionSettings: Settings = Object.assign(DEFAULT_SETTINGS, settings);<EOL>    const templates: any = config.templates;<EOL>    Object.keys(templates).forEach((templateName: string): void => {<EOL>        debugLog(`<STR_LIT>`);<EOL>        registerPartial(templateName, templates[templateName]);<EOL>    });<EOL>    let mergedDocuments: Document;<EOL>    if (!executionSettings.generateDocuments) {<EOL>        debugLog(`<STR_LIT>`);<EOL>        mergedDocuments = {<EOL>            fragments: [],<EOL>            operations: [],<EOL>            hasFragments: false,<EOL>            hasOperations: false,<EOL>        };<EOL>    }<EOL>    else {<EOL>        mergedDocuments = documents.reduce((previousValue: Document, item: Document): Document => {<EOL>            const opArr: Operation[] = [...previousValue.operations, ...item.operations] as Operation[];<EOL>            const frArr: Fragment[] = [...previousValue.fragments, ...item.fragments] as Fragment[];<EOL>            return {<EOL>                operations: opArr,<EOL>                fragments: frArr,<EOL>                hasFragments: frArr.length > <NUM_LIT>,<EOL>                hasOperations: opArr.length > <NUM_LIT>,<EOL>            };<EOL>        }, { hasFragments: false, hasOperations: false, operations: [], fragments: [] } as Document);<EOL>        debugLog(`<STR_LIT>`);<EOL>        if (","gt":"config.flattenTypes) {"}
{"input":"<s> export function compileTemplate(config: GeneratorConfig, templateContext: SchemaTemplateContext, documents: Document[] = [], settings: Settings = DEFAULT_SETTINGS): FileOutput[] {<EOL>    if (!config) {<EOL>        throw new Error(`<STR_LIT>`);<EOL>    }<EOL>    debugLog(`<STR_LIT>`);<EOL>    debugLog(`<STR_LIT>`, settings);<EOL>    initHelpers(config, templateContext);<EOL>    const executionSettings: Settings = Object.assign(DEFAULT_SETTINGS, settings);<EOL>    const templates: any = config.templates;<EOL>    Object.keys(templates).forEach((templateName: string): void => {<EOL>        debugLog(`<STR_LIT>`);<EOL>        registerPartial(templateName, templates[templateName]);<EOL>    });<EOL>    let mergedDocuments: Document;<EOL>    if (!executionSettings.generateDocuments) {<EOL>        debugLog(`<STR_LIT>`);<EOL>        mergedDocuments = {<EOL>            fragments: [],<EOL>            operations: [],<EOL>            hasFragments: false,<EOL>            hasOperations: false,<EOL>        };<EOL>    }<EOL>    else {<EOL>        mergedDocuments = documents.reduce((previousValue: Document, item: Document): Document => {<EOL>            const opArr: Operation[] = [...previousValue.operations, ...item.operations] as Operation[];<EOL>            const frArr: Fragment[] = [...previousValue.fragments, ...item.fragments] as Fragment[];<EOL>            return {<EOL>                operations: opArr,<EOL>                fragments: frArr,<EOL>                hasFragments: frArr.length > <NUM_LIT>,<EOL>                hasOperations: opArr.length > <NUM_LIT>,<EOL>            };<EOL>        }, { hasFragments: false, hasOperations: false, operations: [], fragments: [] } as Document);<EOL>        debugLog(`<STR_LIT>`);<EOL>        if (config.flattenTypes) {<EOL>            debugLog(`<STR_LIT>`);<EOL>            mergedDocuments = flattenTypes(mergedDocuments);<EOL>        }<EOL>    }<EOL>    if (config.inputType === EInputType.SINGLE_FILE) {<EOL>        if (!templates['<STR_LIT>']) {<EOL>            throw new Error(`<STR_LIT>`);<EOL>        }<EOL>        if (!config.outFile) {<EOL>            throw","gt":"new Error('<STR_LIT>');"}
{"input":"<s> export function compileTemplate(config: GeneratorConfig, templateContext: SchemaTemplateContext, documents: Document[] = [], settings: Settings = DEFAULT_SETTINGS): FileOutput[] {<EOL>    if (!config) {<EOL>        throw new Error(`<STR_LIT>`);<EOL>    }<EOL>    debugLog(`<STR_LIT>`);<EOL>    debugLog(`<STR_LIT>`, settings);<EOL>    initHelpers(config, templateContext);<EOL>    const executionSettings: Settings = Object.assign(DEFAULT_SETTINGS, settings);<EOL>    const templates: any = config.templates;<EOL>    Object.keys(templates).forEach((templateName: string): void => {<EOL>        debugLog(`<STR_LIT>`);<EOL>        registerPartial(templateName, templates[templateName]);<EOL>    });<EOL>    let mergedDocuments: Document;<EOL>    if (!executionSettings.generateDocuments) {<EOL>        debugLog(`<STR_LIT>`);<EOL>        mergedDocuments = {<EOL>            fragments: [],<EOL>            operations: [],<EOL>            hasFragments: false,<EOL>            hasOperations: false,<EOL>        };<EOL>    }<EOL>    else {<EOL>        mergedDocuments = documents.reduce((previousValue: Document, item: Document): Document => {<EOL>            const opArr: Operation[] = [...previousValue.operations, ...item.operations] as Operation[];<EOL>            const frArr: Fragment[] = [...previousValue.fragments, ...item.fragments] as Fragment[];<EOL>            return {<EOL>                operations: opArr,<EOL>                fragments: frArr,<EOL>                hasFragments: frArr.length > <NUM_LIT>,<EOL>                hasOperations: opArr.length > <NUM_LIT>,<EOL>            };<EOL>        }, { hasFragments: false, hasOperations: false, operations: [], fragments: [] } as Document);<EOL>        debugLog(`<STR_LIT>`);<EOL>        if (config.flattenTypes) {<EOL>            debugLog(`<STR_LIT>`);<EOL>            mergedDocuments = flattenTypes(mergedDocuments);<EOL>        }<EOL>    }<EOL>    if (config.inputType === EInputType.SINGLE_FILE) {<EOL>        if (!templates['<STR_LIT>']) {<EOL>            throw new Error(`<STR_LIT>`);<EOL>        }<EOL>        if (!config.outFile) {<EOL>            throw new Error('<STR_LIT>');<EOL>        }<EOL>        debugLog(`<STR_LIT>`);<EOL>        return generateSingleFile(compile(cleanTemplateComments(templates['<STR_LIT>'])), executionSettings, config, templateContext, mergedDocuments);<EOL>    }<EOL>    else if (config.inputType === EInputType.MULTIPLE_FILES ||","gt":"config.inputType === EInputType.PROJECT) {"}
{"input":"<s> export function compileTemplate(config: GeneratorConfig, templateContext: SchemaTemplateContext, documents: Document[] = [], settings: Settings = DEFAULT_SETTINGS): FileOutput[] {<EOL>    if (!config) {<EOL>        throw new Error(`<STR_LIT>`);<EOL>    }<EOL>    debugLog(`<STR_LIT>`);<EOL>    debugLog(`<STR_LIT>`, settings);<EOL>    initHelpers(config, templateContext);<EOL>    const executionSettings: Settings = Object.assign(DEFAULT_SETTINGS, settings);<EOL>    const templates: any = config.templates;<EOL>    Object.keys(templates).forEach((templateName: string): void => {<EOL>        debugLog(`<STR_LIT>`);<EOL>        registerPartial(templateName, templates[templateName]);<EOL>    });<EOL>    let mergedDocuments: Document;<EOL>    if (!executionSettings.generateDocuments) {<EOL>        debugLog(`<STR_LIT>`);<EOL>        mergedDocuments = {<EOL>            fragments: [],<EOL>            operations: [],<EOL>            hasFragments: false,<EOL>            hasOperations: false,<EOL>        };<EOL>    }<EOL>    else {<EOL>        mergedDocuments = documents.reduce((previousValue: Document, item: Document): Document => {<EOL>            const opArr: Operation[] = [...previousValue.operations, ...item.operations] as Operation[];<EOL>            const frArr: Fragment[] = [...previousValue.fragments, ...item.fragments] as Fragment[];<EOL>            return {<EOL>                operations: opArr,<EOL>                fragments: frArr,<EOL>                hasFragments: frArr.length > <NUM_LIT>,<EOL>                hasOperations: opArr.length > <NUM_LIT>,<EOL>            };<EOL>        }, { hasFragments: false, hasOperations: false, operations: [], fragments: [] } as Document);<EOL>        debugLog(`<STR_LIT>`);<EOL>        if (config.flattenTypes) {<EOL>            debugLog(`<STR_LIT>`);<EOL>            mergedDocuments = flattenTypes(mergedDocuments);<EOL>        }<EOL>    }<EOL>    if (config.inputType === EInputType.SINGLE_FILE) {<EOL>        if (!templates['<STR_LIT>']) {<EOL>            throw new Error(`<STR_LIT>`);<EOL>        }<EOL>        if (!config.outFile) {<EOL>            throw new Error('<STR_LIT>');<EOL>        }<EOL>        debugLog(`<STR_LIT>`);<EOL>        return generateSingleFile(compile(cleanTemplateComments(templates['<STR_LIT>'])), executionSettings, config, templateContext, mergedDocuments);<EOL>    }<EOL>    else if (config.inputType === EInputType.MULTIPLE_FILES || config.inputType === EInputType.PROJECT) {<EOL>        if (config.inputType === EInputType.MULTIPLE_FILES) {<EOL>            if (!config.","gt":"filesExtension) {"}
{"input":"<s> export function compileTemplate(config: GeneratorConfig, templateContext: SchemaTemplateContext, documents: Document[] = [], settings: Settings = DEFAULT_SETTINGS): FileOutput[] {<EOL>    if (!config) {<EOL>        throw new Error(`<STR_LIT>`);<EOL>    }<EOL>    debugLog(`<STR_LIT>`);<EOL>    debugLog(`<STR_LIT>`, settings);<EOL>    initHelpers(config, templateContext);<EOL>    const executionSettings: Settings = Object.assign(DEFAULT_SETTINGS, settings);<EOL>    const templates: any = config.templates;<EOL>    Object.keys(templates).forEach((templateName: string): void => {<EOL>        debugLog(`<STR_LIT>`);<EOL>        registerPartial(templateName, templates[templateName]);<EOL>    });<EOL>    let mergedDocuments: Document;<EOL>    if (!executionSettings.generateDocuments) {<EOL>        debugLog(`<STR_LIT>`);<EOL>        mergedDocuments = {<EOL>            fragments: [],<EOL>            operations: [],<EOL>            hasFragments: false,<EOL>            hasOperations: false,<EOL>        };<EOL>    }<EOL>    else {<EOL>        mergedDocuments = documents.reduce((previousValue: Document, item: Document): Document => {<EOL>            const opArr: Operation[] = [...previousValue.operations, ...item.operations] as Operation[];<EOL>            const frArr: Fragment[] = [...previousValue.fragments, ...item.fragments] as Fragment[];<EOL>            return {<EOL>                operations: opArr,<EOL>                fragments: frArr,<EOL>                hasFragments: frArr.length > <NUM_LIT>,<EOL>                hasOperations: opArr.length > <NUM_LIT>,<EOL>            };<EOL>        }, { hasFragments: false, hasOperations: false, operations: [], fragments: [] } as Document);<EOL>        debugLog(`<STR_LIT>`);<EOL>        if (config.flattenTypes) {<EOL>            debugLog(`<STR_LIT>`);<EOL>            mergedDocuments = flattenTypes(mergedDocuments);<EOL>        }<EOL>    }<EOL>    if (config.inputType === EInputType.SINGLE_FILE) {<EOL>        if (!templates['<STR_LIT>']) {<EOL>            throw new Error(`<STR_LIT>`);<EOL>        }<EOL>        if (!config.outFile) {<EOL>            throw new Error('<STR_LIT>');<EOL>        }<EOL>        debugLog(`<STR_LIT>`);<EOL>        return generateSingleFile(compile(cleanTemplateComments(templates['<STR_LIT>'])), executionSettings, config, templateContext, mergedDocuments);<EOL>    }<EOL>    else if (config.inputType === EInputType.MULTIPLE_FILES || config.inputType === EInputType.PROJECT) {<EOL>        if (config.inputType === EInputType.MULTIPLE_FILES) {<EOL>            if (!config.filesExtension) {<EOL>                throw new Error('<STR_LIT>');<EOL>            }<EOL>        }<EOL>        debugLog(`<STR_LIT>`);<EOL>        const compiledTemplates: {<EOL>            [name: string]: Function[];<EOL>        } = Object.keys(templates).map((templateName: string): {<EOL>            key: string;<EOL>            value: any;<EOL>        } => {<EOL>            debugLog(`<STR_LIT>`);<EOL>            const compiledTemplate: any = compile(cleanTemplateComments(templates[templateName], templateName));<EOL>            return {<EOL>                key: templateName,<EOL>                value: compiledTemplate,<EOL>            };<EOL>        }).reduce((","gt":"prev: {}, item: {"}
{"input":"<s> export function compileTemplate(config: GeneratorConfig, templateContext: SchemaTemplateContext, documents: Document[] = [], settings: Settings = DEFAULT_SETTINGS): FileOutput[] {<EOL>    if (!config) {<EOL>        throw new Error(`<STR_LIT>`);<EOL>    }<EOL>    debugLog(`<STR_LIT>`);<EOL>    debugLog(`<STR_LIT>`, settings);<EOL>    initHelpers(config, templateContext);<EOL>    const executionSettings: Settings = Object.assign(DEFAULT_SETTINGS, settings);<EOL>    const templates: any = config.templates;<EOL>    Object.keys(templates).forEach((templateName: string): void => {<EOL>        debugLog(`<STR_LIT>`);<EOL>        registerPartial(templateName, templates[templateName]);<EOL>    });<EOL>    let mergedDocuments: Document;<EOL>    if (!executionSettings.generateDocuments) {<EOL>        debugLog(`<STR_LIT>`);<EOL>        mergedDocuments = {<EOL>            fragments: [],<EOL>            operations: [],<EOL>            hasFragments: false,<EOL>            hasOperations: false,<EOL>        };<EOL>    }<EOL>    else {<EOL>        mergedDocuments = documents.reduce((previousValue: Document, item: Document): Document => {<EOL>            const opArr: Operation[] = [...previousValue.operations, ...item.operations] as Operation[];<EOL>            const frArr: Fragment[] = [...previousValue.fragments, ...item.fragments] as Fragment[];<EOL>            return {<EOL>                operations: opArr,<EOL>                fragments: frArr,<EOL>                hasFragments: frArr.length > <NUM_LIT>,<EOL>                hasOperations: opArr.length > <NUM_LIT>,<EOL>            };<EOL>        }, { hasFragments: false, hasOperations: false, operations: [], fragments: [] } as Document);<EOL>        debugLog(`<STR_LIT>`);<EOL>        if (config.flattenTypes) {<EOL>            debugLog(`<STR_LIT>`);<EOL>            mergedDocuments = flattenTypes(mergedDocuments);<EOL>        }<EOL>    }<EOL>    if (config.inputType === EInputType.SINGLE_FILE) {<EOL>        if (!templates['<STR_LIT>']) {<EOL>            throw new Error(`<STR_LIT>`);<EOL>        }<EOL>        if (!config.outFile) {<EOL>            throw new Error('<STR_LIT>');<EOL>        }<EOL>        debugLog(`<STR_LIT>`);<EOL>        return generateSingleFile(compile(cleanTemplateComments(templates['<STR_LIT>'])), executionSettings, config, templateContext, mergedDocuments);<EOL>    }<EOL>    else if (config.inputType === EInputType.MULTIPLE_FILES || config.inputType === EInputType.PROJECT) {<EOL>        if (config.inputType === EInputType.MULTIPLE_FILES) {<EOL>            if (!config.filesExtension) {<EOL>                throw new Error('<STR_LIT>');<EOL>            }<EOL>        }<EOL>        debugLog(`<STR_LIT>`);<EOL>        const compiledTemplates: {<EOL>            [name: string]: Function[];<EOL>        } = Object.keys(templates).map((templateName: string): {<EOL>            key: string;<EOL>            value: any;<EOL>        } => {<EOL>            debugLog(`<STR_LIT>`);<EOL>            const compiledTemplate: any = compile(cleanTemplateComments(templates[templateName], templateName));<EOL>            return {<EOL>                key: templateName,<EOL>                value: compiledTemplate,<EOL>            };<EOL>        }).reduce((prev: {}, item: {<EOL>            key: string;<EOL>            value: any;<EOL>        }): {} => {<EOL>            prev[","gt":"item.key] = item.value;"}
{"input":"<s> export function compileTemplate(config: GeneratorConfig, templateContext: SchemaTemplateContext, documents: Document[] = [], settings: Settings = DEFAULT_SETTINGS): FileOutput[] {<EOL>    if (!config) {<EOL>        throw new Error(`<STR_LIT>`);<EOL>    }<EOL>    debugLog(`<STR_LIT>`);<EOL>    debugLog(`<STR_LIT>`, settings);<EOL>    initHelpers(config, templateContext);<EOL>    const executionSettings: Settings = Object.assign(DEFAULT_SETTINGS, settings);<EOL>    const templates: any = config.templates;<EOL>    Object.keys(templates).forEach((templateName: string): void => {<EOL>        debugLog(`<STR_LIT>`);<EOL>        registerPartial(templateName, templates[templateName]);<EOL>    });<EOL>    let mergedDocuments: Document;<EOL>    if (!executionSettings.generateDocuments) {<EOL>        debugLog(`<STR_LIT>`);<EOL>        mergedDocuments = {<EOL>            fragments: [],<EOL>            operations: [],<EOL>            hasFragments: false,<EOL>            hasOperations: false,<EOL>        };<EOL>    }<EOL>    else {<EOL>        mergedDocuments = documents.reduce((previousValue: Document, item: Document): Document => {<EOL>            const opArr: Operation[] = [...previousValue.operations, ...item.operations] as Operation[];<EOL>            const frArr: Fragment[] = [...previousValue.fragments, ...item.fragments] as Fragment[];<EOL>            return {<EOL>                operations: opArr,<EOL>                fragments: frArr,<EOL>                hasFragments: frArr.length > <NUM_LIT>,<EOL>                hasOperations: opArr.length > <NUM_LIT>,<EOL>            };<EOL>        }, { hasFragments: false, hasOperations: false, operations: [], fragments: [] } as Document);<EOL>        debugLog(`<STR_LIT>`);<EOL>        if (config.flattenTypes) {<EOL>            debugLog(`<STR_LIT>`);<EOL>            mergedDocuments = flattenTypes(mergedDocuments);<EOL>        }<EOL>    }<EOL>    if (config.inputType === EInputType.SINGLE_FILE) {<EOL>        if (!templates['<STR_LIT>']) {<EOL>            throw new Error(`<STR_LIT>`);<EOL>        }<EOL>        if (!config.outFile) {<EOL>            throw new Error('<STR_LIT>');<EOL>        }<EOL>        debugLog(`<STR_LIT>`);<EOL>        return generateSingleFile(compile(cleanTemplateComments(templates['<STR_LIT>'])), executionSettings, config, templateContext, mergedDocuments);<EOL>    }<EOL>    else if (config.inputType === EInputType.MULTIPLE_FILES || config.inputType === EInputType.PROJECT) {<EOL>        if (config.inputType === EInputType.MULTIPLE_FILES) {<EOL>            if (!config.filesExtension) {<EOL>                throw new Error('<STR_LIT>');<EOL>            }<EOL>        }<EOL>        debugLog(`<STR_LIT>`);<EOL>        const compiledTemplates: {<EOL>            [name: string]: Function[];<EOL>        } = Object.keys(templates).map((templateName: string): {<EOL>            key: string;<EOL>            value: any;<EOL>        } => {<EOL>            debugLog(`<STR_LIT>`);<EOL>            const compiledTemplate: any = compile(cleanTemplateComments(templates[templateName], templateName));<EOL>            return {<EOL>                key: templateName,<EOL>                value: compiledTemplate,<EOL>            };<EOL>        }).reduce((prev: {}, item: {<EOL>            key: string;<EOL>            value: any;<EOL>        }): {} => {<EOL>            prev[item.key] = item.value;<EOL>            return prev;<EOL>        }, {})","gt":"as {"}
{"input":"<s> export function separateSelectionSet(selectionSet: SelectionSetItem[]): any {<EOL>    const fields: SelectionSetItem[] = selectionSet.filter((n: SelectionSetItem): boolean => isFieldNode(n));<EOL>    const fragmentsSpread: SelectionSetItem[] = selectionSet.filter((n: SelectionSetItem): boolean => isFragmentSpreadNode(n));<EOL>    const inlineFragments: SelectionSetItem[] = selectionSet.filter((n: SelectionSetItem): boolean => isInlineFragmentNode(n));<EOL>","gt":"return {"}
{"input":"<s> export function separateSelectionSet(selectionSet: SelectionSetItem[]): any {<EOL>    const fields: SelectionSetItem[] = selectionSet.filter((n: SelectionSetItem): boolean => isFieldNode(n));<EOL>    const fragmentsSpread: SelectionSetItem[] = selectionSet.filter((n: SelectionSetItem): boolean => isFragmentSpreadNode(n));<EOL>    const inlineFragments: SelectionSetItem[] = selectionSet.filter((n: SelectionSetItem): boolean => isInlineFragmentNode(n));<EOL>    return {<EOL>        fragmentsSpread,<EOL>        fields,<EOL>        inlineFragments,<EOL>        hasFragmentsSpread: fragmentsSpread.length > <NUM_LIT>,<EOL>        hasFields: fields.","gt":"length > <NUM_LIT>,"}
{"input":"<s> export function isFragmentSpreadNode(node: SelectionSetItem): node is SelectionSetFragmentSpread {<EOL>    return","gt":"node['<STR_LIT>'] !== undefined;"}
{"input":"<s> export default function getAppRootPath(): string {<EOL>    let cwd: string = process.cwd();<EOL>","gt":"while (!fs.existsSync(path.join(cwd, \"<STR_LIT>\"))) {"}
{"input":"<s> export function getAst(): TsSimpleAst {<EOL>    const ast: TsSimpleAst = new TsSimpleAst({<EOL>        tsConfigFilePath: path.join(rootFolder, \"<STR_LIT>\"),<EOL>        addFilesFromTsConfig: false,<EOL>","gt":"manipulationSettings: {"}
{"input":"<s> export function getAst(): TsSimpleAst {<EOL>    const ast: TsSimpleAst = new TsSimpleAst({<EOL>        tsConfigFilePath: path.join(rootFolder, \"<STR_LIT>\"),<EOL>        addFilesFromTsConfig: false,<EOL>        manipulationSettings: {<EOL>            newLineKind: NewLineKind.CarriageReturnLineFeed<EOL>        }<EOL>    });<EOL>    ast.addExistingSourceFiles(path.","gt":"join(rootFolder, \"<STR_LIT>\"));"}
{"input":"<s> <EOL>function isPropertyToIgnore(prop: TsNodeProperty): boolean {<EOL>","gt":"return prop.getName() === \"<STR_LIT>\" ||"}
{"input":"<s> export function LiteralLikeNode<T extends Constructor<LiteralLikeNodeExtensionType>>(Base: T): Constructor<LiteralLikeNode> & T {<EOL>    return class extends Base implements LiteralLikeNode {<EOL>        getLiteralText() {<EOL>            return this.compilerNode.text;<EOL>        }<EOL>        isTerminated() {<EOL>            <EOL>            return !(this.compilerNode.isUnterminated || false);<EOL>        }<EOL>        hasExtendedUnicodeEscape() {<EOL>            return this.","gt":"compilerNode.hasExtendedUnicodeEscape || false;"}
{"input":"<s> export function NamedNode<T extends Constructor<NamedNodeExtensionType>>(Base: T): Constructor<NamedNode> & T {<EOL>    return class extends Base implements NamedNode {<EOL>        getNameNode() {<EOL>            return this.getNodeFromCompilerNode<Identifier>(this.compilerNode.name);<EOL>        }<EOL>        getName() {<EOL>            return this.getNameNode().getText();<EOL>        }<EOL>        rename(newName: string) {<EOL>            if (newName === this.getName())<EOL>                return this;<EOL>            errors.throwIfNotStringOrWhitespace(newName, nameof(newName));<EOL>            this.","gt":"getNameNode().rename(newName);"}
{"input":"<s> export function NamedNode<T extends Constructor<NamedNodeExtensionType>>(Base: T): Constructor<NamedNode> & T {<EOL>    return class extends Base implements NamedNode {<EOL>        getNameNode() {<EOL>            return this.getNodeFromCompilerNode<Identifier>(this.compilerNode.name);<EOL>        }<EOL>        getName() {<EOL>            return this.getNameNode().getText();<EOL>        }<EOL>        rename(newName: string) {<EOL>            if (newName === this.getName())<EOL>                return this;<EOL>            errors.throwIfNotStringOrWhitespace(newName, nameof(newName));<EOL>            this.getNameNode().rename(newName);<EOL>            return this;<EOL>        }<EOL>        fill(structure: Partial<NamedNodeStructure>) {<EOL>","gt":"callBaseFill(Base.prototype, this, structure);"}
{"input":"<s> function getOverloadsAndImplementation(node: OverloadableNodeExtensionType & OverloadableNode): (Node<ts.Node> & BodyableNode & OverloadableNode)[] {<EOL>    const parentSyntaxList: Node<ts.Node> = node.getParentSyntaxListOrThrow();<EOL>    const name: string | undefined = getNameIfNamedNode(node);<EOL>    const kind:","gt":"SyntaxKind = node.getKind();"}
{"input":"<s> <EOL>export function throwIfRangeOutOfRange(actualRange: [<EOL>    number,<EOL>    number<EOL>], range: [<EOL>    number,<EOL>    number<EOL>], argName: string): void {<EOL>    if (actualRange[<NUM_LIT>] > actualRange[<NUM_LIT>])<EOL>        throw new","gt":"ArgumentError(argName, `<STR_LIT>`);"}
{"input":"<s> export function fillAndGetChildren<TNode extends Node, TStructure>(opts: FillAndGetChildrenOptions<TNode, TStructure>): TNode[] {<EOL>    const children: TNode[] = getRangeFromArray<TNode>(opts.allChildren, opts.index, opts.structures.length, opts.expectedKind);<EOL>    if (opts.fillFunction != null) {<EOL>        for (let i: number = <NUM_LIT>;","gt":"i < children.length; i++) {"}
{"input":"<s> export function fromExportableNode(node: compiler.ExportableNode): MakeRequired<structures.ExportableNodeStructure> {<EOL>    return {<EOL>","gt":"isDefaultExport: node.hasDefaultKeyword(),"}
{"input":"<s> export function insertIntoCreatableSyntaxList(opts: InsertIntoCreatableSyntaxListOptions): void {<EOL>    const { insertPos, newText, parent, syntaxList, childIndex, insertItemsCount } = opts;<EOL>    if (syntaxList == null)<EOL>        insertSyntaxList({<EOL>            parent,<EOL>","gt":"insertPos,"}
{"input":"<s> export function insertIntoCreatableSyntaxList(opts: InsertIntoCreatableSyntaxListOptions): void {<EOL>    const { insertPos, newText, parent, syntaxList, childIndex, insertItemsCount } = opts;<EOL>    if (syntaxList == null)<EOL>        insertSyntaxList({<EOL>            parent,<EOL>            insertPos,<EOL>            newText<EOL>        });<EOL>    else<EOL>","gt":"insertIntoParent({"}
{"input":"<s> export function insertIntoCreatableSyntaxList(opts: InsertIntoCreatableSyntaxListOptions): void {<EOL>    const { insertPos, newText, parent, syntaxList, childIndex, insertItemsCount } = opts;<EOL>    if (syntaxList == null)<EOL>        insertSyntaxList({<EOL>            parent,<EOL>            insertPos,<EOL>            newText<EOL>        });<EOL>    else<EOL>        insertIntoParent({<EOL>            insertPos,<EOL>            newText,<EOL>","gt":"parent: syntaxList,"}
{"input":"<s> <EOL>export function replaceSourceFileTextForRename(opts: {<EOL>    sourceFile: SourceFile;<EOL>    renameLocations: RenameLocation[];<EOL>    newName: string;<EOL>}): void {<EOL>    const { sourceFile, renameLocations,","gt":"newName } = opts;"}
{"input":"<s> function getInfo(text: string): {<EOL>    descendant: JsxClosingElement;<EOL>    tsSimpleAst: import(\"<STR_LIT>\").TsSimpleAst;<EOL>    sourceFile: import(\"<STR_LIT>\").SourceFile;<EOL>} {<EOL>    return getInfoFromTextWithDescendant<JsxClosingElement>(","gt":"text, SyntaxKind.JsxClosingElement, { isJsx: true });"}
{"input":"<s> function getInfo(text: string): {<EOL>    descendant: JsxExpression;<EOL>    tsSimpleAst: import(\"<STR_LIT>\").TsSimpleAst;<EOL>    sourceFile: import(\"<STR_LIT>\").SourceFile;<EOL>} {<EOL>    return getInfoFromTextWithDescendant<JsxExpression>(text,","gt":"SyntaxKind.JsxExpression, { isJsx: true });"}
{"input":"<s> function getStringLiteral(text: string): StringLiteral {<EOL>    return getInfoFromTextWithDescendant<StringLiteral>(text,","gt":"SyntaxKind.StringLiteral).descendant;"}
{"input":"<s> function getStatement(text: string): DoStatement {<EOL>    return","gt":"getInfoFromTextWithDescendant<DoStatement>(text, SyntaxKind.DoStatement).descendant;"}
{"input":"<s> function getStatement(text: string): WithStatement {<EOL>    return getInfoFromTextWithDescendant<WithStatement>(text,","gt":"SyntaxKind.WithStatement).descendant;"}
{"input":"<s> <EOL>export function isStringKind(kind: SyntaxKind): boolean {<EOL>    switch (kind) {<EOL>        case SyntaxKind.StringLiteral:<EOL>        case SyntaxKind.FirstTemplateToken:<EOL>        case","gt":"SyntaxKind.TemplateHead:"}
{"input":"<s> <EOL>export function isStringKind(kind: SyntaxKind): boolean {<EOL>    switch (kind) {<EOL>        case SyntaxKind.StringLiteral:<EOL>        case SyntaxKind.FirstTemplateToken:<EOL>        case SyntaxKind.TemplateHead:<EOL>        case SyntaxKind.TemplateMiddle:<EOL>        case SyntaxKind.LastTemplateToken:<EOL>            return true;<EOL>","gt":"default:"}
{"input":"<s> function getFileSystemEntries(path: string, fileSystemWrapper: FileSystemWrapper): FileSystemEntries {<EOL>    const files: string[] = [];<EOL>    const directories: string[] = [];<EOL>    try {<EOL>        const entries: string[] = fileSystemWrapper.readDirSync(path);<EOL>        for (const entry: string","gt":"of entries) {"}
{"input":"<s> function getFileSystemEntries(path: string, fileSystemWrapper: FileSystemWrapper): FileSystemEntries {<EOL>    const files: string[] = [];<EOL>    const directories: string[] = [];<EOL>    try {<EOL>        const entries: string[] = fileSystemWrapper.readDirSync(path);<EOL>        for (const entry: string of entries) {<EOL>            if (fileSystemWrapper.fileExistsSync(entry))<EOL>                files.push(entry);<EOL>            else<EOL>                directories.","gt":"push(entry);"}
{"input":"<s> function getFileSystemEntries(path: string, fileSystemWrapper: FileSystemWrapper): FileSystemEntries {<EOL>    const files: string[] = [];<EOL>    const directories: string[] = [];<EOL>    try {<EOL>        const entries: string[] = fileSystemWrapper.readDirSync(path);<EOL>        for (const entry: string of entries) {<EOL>            if (fileSystemWrapper.fileExistsSync(entry))<EOL>                files.push(entry);<EOL>            else<EOL>                directories.push(entry);<EOL>        }<EOL>    }<EOL>    catch (err: unknown) {<EOL>","gt":"if (!FileUtils.isNotExistsError(err))"}
{"input":"<s> export async function makeHot(id: string, componentLoader: () => Promise<Component>, acceptFunc: void): Promise<void> {<EOL>    if (module.hot) {<EOL>        api.install(Vue);<EOL>","gt":"if (!api.compatible) {"}
{"input":"<s> async function submitCertification(cert: any, to: any, logger: any = null): Promise<void> {<EOL>    try {<EOL>        await to.postCert(cert);<EOL>","gt":"logger && logger.trace('<STR_LIT>', cert.from.substr(<NUM_LIT>, <NUM_LIT>), cert.idty_uid);"}
{"input":"<s> export function isCommandViewContextWithRemote(context: CommandContext): context is CommandViewContext & {<EOL>    node: (ExplorerNode & {<EOL>        remote: GitRemote;<EOL>    });<EOL>} {<EOL>","gt":"return context.type === '<STR_LIT>' && (context.node as any).remote && (context.node as any).remote instanceof GitRemote;"}
{"input":"<s> export function runCommand(command: string, args: any[], options: CommandOptions = {}): Promise<string> {<EOL>    const { stdin, stdinEncoding, ...opts } = { maxBuffer: <NUM_LIT> * <NUM_LIT> * <NUM_LIT>, ...options } as CommandOptions;<EOL>    return new Promise<string>((resolve: (value: string | PromiseLike<string>) => void, reject: (reason?: any) => void): void => {<EOL>        const proc: any = execFile(command, args, opts, (err: Error & {<EOL>            code?: string | number;<EOL>        } | null, stdout: any,","gt":"stderr: any): void => {"}
{"input":"<s> export function runCommand(command: string, args: any[], options: CommandOptions = {}): Promise<string> {<EOL>    const { stdin, stdinEncoding, ...opts } = { maxBuffer: <NUM_LIT> * <NUM_LIT> * <NUM_LIT>, ...options } as CommandOptions;<EOL>    return new Promise<string>((resolve: (value: string | PromiseLike<string>) => void, reject: (reason?: any) => void): void => {<EOL>        const proc: any = execFile(command, args, opts, (err: Error & {<EOL>            code?: string | number;<EOL>        } | null, stdout: any, stderr: any): void => {<EOL>            if (!err) {<EOL>                if (","gt":"stderr) {"}
{"input":"<s> export function runCommand(command: string, args: any[], options: CommandOptions = {}): Promise<string> {<EOL>    const { stdin, stdinEncoding, ...opts } = { maxBuffer: <NUM_LIT> * <NUM_LIT> * <NUM_LIT>, ...options } as CommandOptions;<EOL>    return new Promise<string>((resolve: (value: string | PromiseLike<string>) => void, reject: (reason?: any) => void): void => {<EOL>        const proc: any = execFile(command, args, opts, (err: Error & {<EOL>            code?: string | number;<EOL>        } | null, stdout: any, stderr: any): void => {<EOL>            if (!err) {<EOL>                if (stderr) {<EOL>                    Logger.warn(`<STR_LIT>`);<EOL>                }<EOL>                resolve(stdout);<EOL>                return;<EOL>            }<EOL>            if (err.message === '<STR_LIT>') {<EOL>                reject(new Error(`<STR_LIT>`));<EOL>            }<EOL>            Logger.warn(`<STR_LIT>`);<EOL>","gt":"reject(err);"}
{"input":"<s> function _getInfiniteCancellablePromise(cancellation: CancellationTokenSource): Promise<QuickPickItem[]> {<EOL>    return new Promise<QuickPickItem[]>((resolve: (value: QuickPickItem[] | PromiseLike<QuickPickItem[]>) => void, reject: (reason?: any) => void): void => {<EOL>        const disposable: any = cancellation.token.","gt":"onCancellationRequested((): void => {"}
{"input":"<s> function buildParseFn(patterns: IDateFnsLocaleValues, defaultType: string): DateFnsHelper<RegExpMatchArray, number> {<EOL>    return ([, result], { type } = { type: defaultType }) => (patterns[","gt":"type] || patterns[defaultType])"}
{"input":"<s> function getStorageRef(reject: any, arg: any): any {<EOL>    if (typeof (FIRStorage) === \"<STR_LIT>\") {<EOL>        reject(\"<STR_LIT>\");<EOL>","gt":"return;"}
{"input":"<s> export function max(source: ArrayLike<number>, ignoreNaN: boolean = false): number {<EOL>    return ifSet(source, -Infinity,","gt":"ignoreNaN, (n: number, result: number): boolean => n > result);"}
{"input":"<s> export function min(source: ArrayLike<number>, ignoreNaN: boolean = false): number {<EOL>    return ifSet(source, +Infinity, ignoreNaN, (n: number, result: number): boolean => n <","gt":"result);"}
{"input":"<s> <EOL>export function mergeSort<T extends Primitive, TArray extends ArrayLikeWritable<T>>(target: TArray): TArray {<EOL>    if (!target)<EOL>        throw new","gt":"ArgumentNullException(\"<STR_LIT>\");"}
{"input":"<s> function sort<T extends Primitive, TArray extends ArrayLikeWritable<T>>(target: TArray, start: number, end: number, temp: ArrayLikeWritable<T>): TArray {<EOL>    if (end - start > <NUM_LIT>) {<EOL>        <EOL>        const middle: number = Math.floor((start + end) / <NUM_LIT>);<EOL>        sort(target, start, middle, temp);<EOL>        sort(target,","gt":"middle, end, temp);"}
{"input":"<s> function sort<T extends Primitive, TArray extends ArrayLikeWritable<T>>(target: TArray, start: number, end: number, temp: ArrayLikeWritable<T>): TArray {<EOL>    if (end - start > <NUM_LIT>) {<EOL>        <EOL>        const middle: number = Math.floor((start + end) / <NUM_LIT>);<EOL>        sort(target, start, middle, temp);<EOL>        sort(target, middle, end, temp);<EOL>        <EOL>        for (let i: number = <NUM_LIT>, len: number = target.length; i < len; i++) {<EOL>","gt":"temp[i] = target[i];"}
{"input":"<s> function sort<T extends Primitive, TArray extends ArrayLikeWritable<T>>(target: TArray, start: number, end: number, temp: ArrayLikeWritable<T>): TArray {<EOL>    if (end - start > <NUM_LIT>) {<EOL>        <EOL>        const middle: number = Math.floor((start + end) / <NUM_LIT>);<EOL>        sort(target, start, middle, temp);<EOL>        sort(target, middle, end, temp);<EOL>        <EOL>        for (let i: number = <NUM_LIT>, len: number = target.length; i < len; i++) {<EOL>            temp[i] = target[i];<EOL>        }<EOL>        <EOL>        let k: number = start, i: number = start, j: number = middle;<EOL>        <EOL>        while (i < middle && j <","gt":"end) {"}
{"input":"<s> function ensureExternal<T>(node: InternalNode<T> | null | undefined, list: LinkedList<T>): ILinkedListNode<T> | null {<EOL>    if (!node)<EOL>        return null;<EOL>","gt":"if (!list)"}
{"input":"<s> export function Integer(n: number): number {<EOL>    return Math.floor(","gt":"n);"}
{"input":"<s> export function assertKey<TKey>(key: TKey, name: string = ITEM): TKey | never {<EOL>    assertNotUndefined(key, name + DOT + KEY);<EOL>    if (","gt":"key === null)"}
{"input":"<s> function canMatch(source: string, match: string): boolean | null | void {<EOL>    if (!Type.isString(source) || !match)<EOL>        return","gt":"false;"}
{"input":"<s> function areInvalid(v: any, d: any): boolean {<EOL>    if (!areEqual(v, d)) {<EOL>","gt":"let memberType: TypeInfoHelper = new TypeInfoHelper(v);"}
{"input":"<s> function comparer(): void {<EOL>","gt":"test(comparerResults, comparerSort);"}
{"input":"<s> function report(name: string, fn: Function): void {<EOL>    if (","gt":"count > <NUM_LIT>)"}
{"input":"<s> function s3Url(options: S3Options): string {<EOL>    let url: string;<EOL>    if (options.endpoint != null) {<EOL>        url = `<STR_LIT>`;<EOL>    }<EOL>","gt":"else {"}
{"input":"<s> function s3Url(options: S3Options): string {<EOL>    let url: string;<EOL>    if (options.endpoint != null) {<EOL>        url = `<STR_LIT>`;<EOL>    }<EOL>    else {<EOL>        if (!options.bucket.includes(\"<STR_LIT>\")) {<EOL>            if (options.region === \"<STR_LIT>\") {<EOL>                url = `<STR_LIT>`;<EOL>            }<EOL>            else {<EOL>                url = `<STR_LIT>`;<EOL>            }<EOL>        }<EOL>        else {<EOL>            if (options.region ==","gt":"null) {"}
{"input":"<s> function s3Url(options: S3Options): string {<EOL>    let url: string;<EOL>    if (options.endpoint != null) {<EOL>        url = `<STR_LIT>`;<EOL>    }<EOL>    else {<EOL>        if (!options.bucket.includes(\"<STR_LIT>\")) {<EOL>            if (options.region === \"<STR_LIT>\") {<EOL>                url = `<STR_LIT>`;<EOL>            }<EOL>            else {<EOL>                url = `<STR_LIT>`;<EOL>            }<EOL>        }<EOL>        else {<EOL>            if (options.region == null) {<EOL>                throw new Error(`<STR_LIT>`);<EOL>            }<EOL>            <EOL>            url = options.region === \"<STR_LIT>\"<EOL>                ? `<STR_LIT>`<EOL>                :","gt":"region}.amazonaws.com/${options.bucket}`<STR_LIT>;"}
{"input":"<s> function stringify(buffer: Buffer): string {<EOL>    return byte2hex[buffer[<NUM_LIT>]] + byte2hex[buffer[<NUM_LIT>]] +<EOL>        byte2hex[buffer[<NUM_LIT>]] + byte2hex[buffer[<NUM_LIT>]] + \"<STR_LIT>\" +<EOL>        byte2hex[buffer[<NUM_LIT>]] + byte2hex[buffer[","gt":"<NUM_LIT>]] + \"<STR_LIT>\" +"}
{"input":"<s> export function orIfFileNotExist<T>(promise: Promise<T>, fallbackValue: T): Promise<T> {<EOL>    return promise<EOL>        .catch((e: any): T => {<EOL>        if (","gt":"e.code === \"<STR_LIT>\" || e.code === \"<STR_LIT>\") {"}
{"input":"<s> <EOL>export function execWine(file: string, args: Array<string>, options: ExecFileOptions = EXEC_TIMEOUT): Promise<string> {<EOL>    if (process.platform === \"<STR_LIT>\") {<EOL>        return exec(file, args, options);<EOL>    }<EOL>    else {<EOL>        return wineExecutable.","gt":"value"}
{"input":"<s> <EOL>export function execWine(file: string, args: Array<string>, options: ExecFileOptions = EXEC_TIMEOUT): Promise<string> {<EOL>    if (process.platform === \"<STR_LIT>\") {<EOL>        return exec(file, args, options);<EOL>    }<EOL>    else {<EOL>        return wineExecutable.value<EOL>            .then((wine: any): Promise<string> => {<EOL>            const effectiveOptions: any = wine.env == null ? options : { ...options };<EOL>            if (wine.env != null) {<EOL>                effectiveOptions.env = options.env ==","gt":"null ? wine.env : {"}
{"input":"<s> export async function readAsar(archive: string): Promise<AsarFilesystem> {<EOL>    const fd: any = await open(archive, \"<STR_LIT>\");<EOL>    let size: any;<EOL>    let headerBuf: any;<EOL>","gt":"try {"}
{"input":"<s> export async function readAsar(archive: string): Promise<AsarFilesystem> {<EOL>    const fd: any = await open(archive, \"<STR_LIT>\");<EOL>    let size: any;<EOL>    let headerBuf: any;<EOL>    try {<EOL>        const sizeBuf: any = Buffer.allocUnsafe(<NUM_LIT>);<EOL>        if (await read(fd, sizeBuf, <NUM_LIT>, <NUM_LIT>, null as any) !== <NUM_LIT>) {<EOL>            throw","gt":"new Error(\"<STR_LIT>\");"}
{"input":"<s> export async function readAsar(archive: string): Promise<AsarFilesystem> {<EOL>    const fd: any = await open(archive, \"<STR_LIT>\");<EOL>    let size: any;<EOL>    let headerBuf: any;<EOL>    try {<EOL>        const sizeBuf: any = Buffer.allocUnsafe(<NUM_LIT>);<EOL>        if (await read(fd, sizeBuf, <NUM_LIT>, <NUM_LIT>, null as any) !== <NUM_LIT>) {<EOL>            throw new Error(\"<STR_LIT>\");<EOL>        }<EOL>        const sizePickle: any = createFromBuffer(sizeBuf);<EOL>        size = sizePickle.createIterator().readUInt32();<EOL>        headerBuf = Buffer.allocUnsafe(size);<EOL>        if (await read(fd, headerBuf, <NUM_LIT>, size, null as any) !==","gt":"size) {"}
{"input":"<s> export async function readAsar(archive: string): Promise<AsarFilesystem> {<EOL>    const fd: any = await open(archive, \"<STR_LIT>\");<EOL>    let size: any;<EOL>    let headerBuf: any;<EOL>    try {<EOL>        const sizeBuf: any = Buffer.allocUnsafe(<NUM_LIT>);<EOL>        if (await read(fd, sizeBuf, <NUM_LIT>, <NUM_LIT>, null as any) !== <NUM_LIT>) {<EOL>            throw new Error(\"<STR_LIT>\");<EOL>        }<EOL>        const sizePickle: any = createFromBuffer(sizeBuf);<EOL>        size = sizePickle.createIterator().readUInt32();<EOL>        headerBuf = Buffer.allocUnsafe(size);<EOL>        if (await read(fd, headerBuf, <NUM_LIT>, size, null as any) !== size) {<EOL>            throw new Error(\"<STR_LIT>\");<EOL>        }<EOL>    }<EOL>","gt":"finally {"}
{"input":"<s> export function chooseNotNull(v1: string | null | undefined, v2: string | null | undefined): string | null | undefined {<EOL>    return v1 == null ?","gt":"v2 : v1;"}
{"input":"<s> export async function writeUpdateInfoFiles(updateInfoFileTasks: Array<UpdateInfoFileTask>, packager: Packager): Promise<void> {<EOL>    <EOL>    updateInfoFileTasks.sort((a: UpdateInfoFileTask, b: UpdateInfoFileTask): number => (a.info.files[<NUM_LIT>].url.endsWith(\"<STR_LIT>\") ? <NUM_LIT> : <NUM_LIT>) - (b.info.files[<NUM_LIT>].url.endsWith(\"<STR_LIT>\") ? <NUM_LIT> : <NUM_LIT>));<EOL>    const updateChannelFileToInfo: any = new Map<string, UpdateInfoFileTask>();<EOL>    for (const task: UpdateInfoFileTask of updateInfoFileTasks) {<EOL>        const key: string =","gt":"safeStringifyJson(task.publishConfiguration)}`<STR_LIT>;"}
{"input":"<s> export async function writeUpdateInfoFiles(updateInfoFileTasks: Array<UpdateInfoFileTask>, packager: Packager): Promise<void> {<EOL>    <EOL>    updateInfoFileTasks.sort((a: UpdateInfoFileTask, b: UpdateInfoFileTask): number => (a.info.files[<NUM_LIT>].url.endsWith(\"<STR_LIT>\") ? <NUM_LIT> : <NUM_LIT>) - (b.info.files[<NUM_LIT>].url.endsWith(\"<STR_LIT>\") ? <NUM_LIT> : <NUM_LIT>));<EOL>    const updateChannelFileToInfo: any = new Map<string, UpdateInfoFileTask>();<EOL>    for (const task: UpdateInfoFileTask of updateInfoFileTasks) {<EOL>        const key: string = `<STR_LIT>`;<EOL>        const existingTask: any = updateChannelFileToInfo.get(key);<EOL>        if (existingTask == null) {<EOL>            updateChannelFileToInfo.set(key,","gt":"task);"}
{"input":"<s> export async function writeUpdateInfoFiles(updateInfoFileTasks: Array<UpdateInfoFileTask>, packager: Packager): Promise<void> {<EOL>    <EOL>    updateInfoFileTasks.sort((a: UpdateInfoFileTask, b: UpdateInfoFileTask): number => (a.info.files[<NUM_LIT>].url.endsWith(\"<STR_LIT>\") ? <NUM_LIT> : <NUM_LIT>) - (b.info.files[<NUM_LIT>].url.endsWith(\"<STR_LIT>\") ? <NUM_LIT> : <NUM_LIT>));<EOL>    const updateChannelFileToInfo: any = new Map<string, UpdateInfoFileTask>();<EOL>    for (const task: UpdateInfoFileTask of updateInfoFileTasks) {<EOL>        const key: string = `<STR_LIT>`;<EOL>        const existingTask: any = updateChannelFileToInfo.get(key);<EOL>        if (existingTask == null) {<EOL>            updateChannelFileToInfo.set(key, task);<EOL>            continue;<EOL>        }<EOL>","gt":"existingTask.info.files.push(...task.info.files);"}
{"input":"<s> export async function writeUpdateInfoFiles(updateInfoFileTasks: Array<UpdateInfoFileTask>, packager: Packager): Promise<void> {<EOL>    <EOL>    updateInfoFileTasks.sort((a: UpdateInfoFileTask, b: UpdateInfoFileTask): number => (a.info.files[<NUM_LIT>].url.endsWith(\"<STR_LIT>\") ? <NUM_LIT> : <NUM_LIT>) - (b.info.files[<NUM_LIT>].url.endsWith(\"<STR_LIT>\") ? <NUM_LIT> : <NUM_LIT>));<EOL>    const updateChannelFileToInfo: any = new Map<string, UpdateInfoFileTask>();<EOL>    for (const task: UpdateInfoFileTask of updateInfoFileTasks) {<EOL>        const key: string = `<STR_LIT>`;<EOL>        const existingTask: any = updateChannelFileToInfo.get(key);<EOL>        if (existingTask == null) {<EOL>            updateChannelFileToInfo.set(key, task);<EOL>            continue;<EOL>        }<EOL>        existingTask.info.files.push(...task.info.files);<EOL>    }<EOL>    const releaseDate: string = new Date().toISOString();<EOL>","gt":"await BluebirdPromise.map(updateChannelFileToInfo.values(), async (task: any): Promise<void> => {"}
{"input":"<s> export async function writeUpdateInfoFiles(updateInfoFileTasks: Array<UpdateInfoFileTask>, packager: Packager): Promise<void> {<EOL>    <EOL>    updateInfoFileTasks.sort((a: UpdateInfoFileTask, b: UpdateInfoFileTask): number => (a.info.files[<NUM_LIT>].url.endsWith(\"<STR_LIT>\") ? <NUM_LIT> : <NUM_LIT>) - (b.info.files[<NUM_LIT>].url.endsWith(\"<STR_LIT>\") ? <NUM_LIT> : <NUM_LIT>));<EOL>    const updateChannelFileToInfo: any = new Map<string, UpdateInfoFileTask>();<EOL>    for (const task: UpdateInfoFileTask of updateInfoFileTasks) {<EOL>        const key: string = `<STR_LIT>`;<EOL>        const existingTask: any = updateChannelFileToInfo.get(key);<EOL>        if (existingTask == null) {<EOL>            updateChannelFileToInfo.set(key, task);<EOL>            continue;<EOL>        }<EOL>        existingTask.info.files.push(...task.info.files);<EOL>    }<EOL>    const releaseDate: string = new Date().toISOString();<EOL>    await BluebirdPromise.map(updateChannelFileToInfo.values(), async (task: any): Promise<void> => {<EOL>        task.info.releaseDate = releaseDate;<EOL>        const fileContent: any = Buffer.from(serializeToYaml(task.info));<EOL>        await outputFile(task.file, fileContent);<EOL>        packager.dispatchArtifactCreated({<EOL>            file: task.","gt":"file,"}
{"input":"<s> function getZstdCompressionLevel(endpoint: string): string {<EOL>    const result: any = process.env.ELECTRON_BUILD_SERVICE_ZSTD_COMPRESSION;<EOL>    if (result != null) {<EOL>        return","gt":"result;"}
{"input":"<s> export function getDestinationPath(file: string, fileSet: ResolvedFileSet): string {<EOL>    if (file === fileSet.src) {<EOL>        return fileSet.destination;<EOL>    }<EOL>    else {<EOL>        const src: string = ensureEndSlash(fileSet.src);<EOL>","gt":"const dest: string = ensureEndSlash(fileSet.destination);"}
{"input":"<s> export function getDestinationPath(file: string, fileSet: ResolvedFileSet): string {<EOL>    if (file === fileSet.src) {<EOL>        return fileSet.destination;<EOL>    }<EOL>    else {<EOL>        const src: string = ensureEndSlash(fileSet.src);<EOL>        const dest: string = ensureEndSlash(fileSet.destination);<EOL>        if (file.startsWith(src)) {<EOL>            return dest + file.substring(src.length);<EOL>        }<EOL>","gt":"else {"}
{"input":"<s> export function getDestinationPath(file: string, fileSet: ResolvedFileSet): string {<EOL>    if (file === fileSet.src) {<EOL>        return fileSet.destination;<EOL>    }<EOL>    else {<EOL>        const src: string = ensureEndSlash(fileSet.src);<EOL>        const dest: string = ensureEndSlash(fileSet.destination);<EOL>        if (file.startsWith(src)) {<EOL>            return dest + file.substring(src.length);<EOL>        }<EOL>        else {<EOL>            <EOL>            const index: number = file.lastIndexOf(NODE_MODULES_PATTERN);<EOL>            if (index < <NUM_LIT>) {<EOL>                throw new Error(","gt":"file}\"<STR_LIT>\"${fileSet.src}\"<STR_LIT>;"}
{"input":"<s> function getPackageToolPath(): string {<EOL>    if (process.env.FORCE_YARN === \"<STR_LIT>\") {<EOL>        return process.","gt":"platform === \"<STR_LIT>\" ? \"<STR_LIT>\" : \"<STR_LIT>\";"}
{"input":"<s> export async function getWindowsVm(debugLogger: DebugLogger): Promise<VmManager> {<EOL>    const vmList: import(\"<STR_LIT>\").ParallelsVm[] = (await parseVmList(debugLogger)).filter((it: import(\"<STR_LIT>\").ParallelsVm): boolean => it.os === \"<STR_LIT>\");<EOL>    if (","gt":"vmList.length === <NUM_LIT>) {"}
{"input":"<s> function quoteString(s: string): string {<EOL>    if (!s.includes(\"<STR_LIT>\") && !s.includes('<STR_LIT>')) {<EOL>        return","gt":"s;"}
{"input":"<s> function buildEntryMap(list: Array<BlockMapFile>): any {<EOL>    const result: any = new Map<string, BlockMapFile>();<EOL>    for (","gt":"const item: BlockMapFile of list) {"}
{"input":"<s> export async function checkHelpers(resourceDir: string, packElevateHelper: boolean): Promise<void> {<EOL>    const elevateHelperExecutable: any = path.join(resourceDir, \"<STR_LIT>\");<EOL>    if (packElevateHelper) {<EOL>","gt":"await assertThat(elevateHelperExecutable).isFile();"}
{"input":"<s> export function logProcess(label: \"<STR_LIT>\" | \"<STR_LIT>\" | \"<STR_LIT>\", data: string | Buffer, labelColor: any, lineFilter: LineFilter | null = null): void {<EOL>    const log: string | null = filterText(data.toString(), lineFilter);<EOL>    if (log == null || log.length === <NUM_LIT>) {<EOL>","gt":"return;"}
{"input":"<s> function configureDevelopmentPlugins(configurator: WebpackConfigurator): void {<EOL>    const plugins: Plugin[] = configurator.plugins;<EOL>    plugins.push(new NamedModulesPlugin());<EOL>    plugins.push(new DefinePlugin({<EOL>        __static: `<STR_LIT>`<EOL>    }));<EOL>    plugins.push(new","gt":"HotModuleReplacementPlugin());"}
{"input":"<s> function configureDevelopmentPlugins(configurator: WebpackConfigurator): void {<EOL>    const plugins: Plugin[] = configurator.plugins;<EOL>    plugins.push(new NamedModulesPlugin());<EOL>    plugins.push(new DefinePlugin({<EOL>        __static: `<STR_LIT>`<EOL>    }));<EOL>    plugins.push(new HotModuleReplacementPlugin());<EOL>    if (configurator.hasDevDependency(\"<STR_LIT>\")) {<EOL>        const WebpackNotifierPlugin: any = require(\"<STR_LIT>\");<EOL>        plugins.","gt":"push(new WebpackNotifierPlugin({"}
{"input":"<s> function configureDevelopmentPlugins(configurator: WebpackConfigurator): void {<EOL>    const plugins: Plugin[] = configurator.plugins;<EOL>    plugins.push(new NamedModulesPlugin());<EOL>    plugins.push(new DefinePlugin({<EOL>        __static: `<STR_LIT>`<EOL>    }));<EOL>    plugins.push(new HotModuleReplacementPlugin());<EOL>    if (configurator.hasDevDependency(\"<STR_LIT>\")) {<EOL>        const WebpackNotifierPlugin: any = require(\"<STR_LIT>\");<EOL>        plugins.push(new WebpackNotifierPlugin({<EOL>            title: `<STR_LIT>`,<EOL>            suppressSuccess: \"<STR_LIT>\",<EOL>","gt":"sound: false,"}
{"input":"<s> function configureDevelopmentPlugins(configurator: WebpackConfigurator): void {<EOL>    const plugins: Plugin[] = configurator.plugins;<EOL>    plugins.push(new NamedModulesPlugin());<EOL>    plugins.push(new DefinePlugin({<EOL>        __static: `<STR_LIT>`<EOL>    }));<EOL>    plugins.push(new HotModuleReplacementPlugin());<EOL>    if (configurator.hasDevDependency(\"<STR_LIT>\")) {<EOL>        const WebpackNotifierPlugin: any = require(\"<STR_LIT>\");<EOL>        plugins.push(new WebpackNotifierPlugin({<EOL>            title: `<STR_LIT>`,<EOL>            suppressSuccess: \"<STR_LIT>\",<EOL>            sound: false,<EOL>        }));<EOL>    }<EOL>    if (","gt":"configurator.hasDevDependency(\"<STR_LIT>\")) {"}
{"input":"<s> function addCustomResolver(configuration: Configuration): void {<EOL>    expect(configuration.resolveLoader).toBeUndefined();<EOL>","gt":"configuration.resolveLoader = {"}
{"input":"<s> export async function doTest(configurationFile: string, electronWebpackConfiguration?: ElectronWebpackConfiguration): Promise<void> {<EOL>    const projectDir: any = await getMutableProjectDir();<EOL>","gt":"const finalConfiguration: any = { projectDir, ...electronWebpackConfiguration };"}
{"input":"<s> export function getBaseUrl(): string {<EOL>    return","gt":"document.getElementsByTagName('<STR_LIT>')[<NUM_LIT>].href;"}
{"input":"<s> <EOL><EOL>export function line(ctx: CanvasRenderingContext2D, color: Color = Color.Red.clone(), x1: number, y1: number, x2: number, y2: number, thickness: number = <NUM_LIT>, cap: LineCapStyle = '<STR_LIT>'): void {<EOL>    ctx.beginPath();<EOL>    ctx.lineWidth = thickness;<EOL>    ctx.lineCap =","gt":"cap;"}
{"input":"<s> export default function (data: AppState): any {<EOL>","gt":"var store: any = createStore<AppState>(reducer, data, composeEnhancers(applyMiddleware(promiseMiddleware)));"}
{"input":"<s> export function fileWriteRequest(request: Request, plugins: List.List<AlgebraicType.Plugin>): Either.Either<Error.Error[], FileWriter.FileWriteRequest> {<EOL>    const pluginsToRun: List.List<AlgebraicType.Plugin> = pluginsToRunForAlgebraicType(plugins, request.typeInformation);<EOL>    const wrappedPlugins: List.List<AlgebraicTypeObjCPlugIn> = List.map(objcPluginForAlgebraicTypePlugin, pluginsToRun);<EOL>    const typeInfoProvider:","gt":"PluggableObjCFileCreation.ObjCGenerationTypeInfoProvider<AlgebraicType.Type> = {"}
{"input":"<s> function readFileForFoundObjectSpec(path: File.AbsoluteFilePath): Promise.Future<Logging.Context<Either.Either<Error.Error[], UnparsedObjectCreationRequest>>> {<EOL>    return FileReader.read(path).map(function (either: Either.Either<Error.Error[], File.Contents>) {<EOL>        return Logging.munit(Either.map(function (","gt":"contents: File.Contents) {"}
{"input":"<s> function loggerForParsedArgs(parsedArgs: CommandLine.Arguments): Logging.Logger {<EOL>    return {<EOL>        interestedLoggingTypes: parsedArgs.interestedLoggingTypes,<EOL>","gt":"minimalLevel: parsedArgs.minimalLevel,"}
{"input":"<s> function propagateGenerationSuccessError(errors: Error.Error[]): Promise.Future<Logging.Context<Either.Either<Error.Error[], ObjectGenerationSuccess>>> {<EOL>    return Promise.munit(","gt":"Logging.munit(Either.Left<Error.Error[], ObjectGenerationSuccess>(errors)));"}
{"input":"<s> export function mapLoggedSequence3<T, U, V>(seq: LazySequence.Sequence<Promise.Future<Logging.Context<T>>>, f: (t: T) => Promise.Future<Logging.Context<U>>, g: (u: U) => Promise.Future<Logging.Context<V>>): LazySequence.Sequence<Promise.Future<Logging.Context<V>>> {<EOL>    return seq.map(","gt":"toAsyncLoggingPipelineForm(f))"}
{"input":"<s> export function mapLoggedSequence<T, U>(seq: LazySequence.Sequence<Promise.Future<Logging.Context<T>>>, f: (t: T) => Promise.Future<Logging.Context<U>>): LazySequence.Sequence<Promise.Future<Logging.Context<U>>> {<EOL>","gt":"return seq.map(toAsyncLoggingPipelineForm(f));"}
{"input":"<s> export function generate(directoryRunFrom: string, extension: string, configFileName: string, optionalConfigPath: string, configurationContext: Configuration.ConfigurationContext, parsedArgs: CommandLine.Arguments): Promise.Future<WriteFileUtils.ConsoleOutputResults> {<EOL>    const requestedPath: File.AbsoluteFilePath = PathUtils.getAbsolutePathFromDirectoryAndAbsoluteOrRelativePath(File.getAbsoluteFilePath(directoryRunFrom), parsedArgs.givenPath);<EOL>    const outputPath: Maybe.Maybe<File.AbsoluteFilePath> = outputDirectory(directoryRunFrom, parsedArgs.outputPath);<EOL>    const valueObjectCreationContextFuture:","gt":"Promise.Future<Either.Either<Error.Error[], ObjectSpecCreationContext>> = getObjectSpecCreationContext(valueObjectConfigPathFuture(configFileName, requestedPath, optionalConfigPath), configurationContext, parsedArgs);"}
{"input":"<s> function verify(xhr: XMLHttpRequest): Either<Error, XMLHttpRequest> {<EOL>    return Right<Error, XMLHttpRequest>(xhr)<EOL>        .bind((xhr: any): any => /2..|304/.test(`<STR_LIT>`)<EOL>        ? Right(","gt":"xhr)"}
{"input":"<s> export function blur(document: Document): void {<EOL>    if (document !== window.document || document.activeElement === document.body)<EOL>","gt":"return;"}
{"input":"<s> function remove(el: HTMLElement): undefined {<EOL>","gt":"return void el.remove();"}
{"input":"<s> <EOL>export function overwrite(tr: TaggedResource, changeset: typeof tr.body, specialStatus = SpecialStatus.DIRTY): ReduxAction<EditResourceParams> {<EOL>    return {<EOL>        type: Actions.","gt":"OVERWRITE_RESOURCE,"}
{"input":"<s> function update(uuid: string, statusBeforeError: SpecialStatus): (dispatch: Function, getState: GetState) => any {<EOL>    return function (dispatch: Function, getState: GetState) {<EOL>","gt":"const { index } = getState().resources;"}
{"input":"<s> export function onMalformed(): void {<EOL>    bothUp();<EOL>    if (!HACKY_FLAGS.","gt":"alreadyToldUserAboutMalformedMsg) {"}
{"input":"<s> export function storeUUID(uuid: string): void {<EOL>    outstandingRequests.last = cleanUUID(","gt":"uuid);"}
{"input":"<s> <EOL>export function maybeNegateStatus(x: OverrideHints): SyncStatus | undefined {<EOL>    const { consistent, <EOL>    <EOL>    syncStatus, fbosVersion, autoSync } = x;<EOL>    <EOL>    if (","gt":"consistent) {"}
{"input":"<s> <EOL>export function maybeNegateStatus(x: OverrideHints): SyncStatus | undefined {<EOL>    const { consistent, <EOL>    <EOL>    syncStatus, fbosVersion, autoSync } = x;<EOL>    <EOL>    if (consistent) {<EOL>        return syncStatus;<EOL>    }<EOL>    switch (determineStrategy({ autoSync, fbosVersion })) {<EOL>        case SyncStrat.","gt":"AUTO:"}
{"input":"<s> <EOL>export function maybeNegateStatus(x: OverrideHints): SyncStatus | undefined {<EOL>    const { consistent, <EOL>    <EOL>    syncStatus, fbosVersion, autoSync } = x;<EOL>    <EOL>    if (consistent) {<EOL>        return syncStatus;<EOL>    }<EOL>    switch (determineStrategy({ autoSync, fbosVersion })) {<EOL>        case SyncStrat.AUTO:<EOL>            return \"<STR_LIT>\";<EOL>        case SyncStrat.LEGACY:<EOL>        case SyncStrat.MANUAL:<EOL>","gt":"return \"<STR_LIT>\";"}
{"input":"<s> export function execSequence(sequence: Sequence): any {<EOL>    const noun: string = \"<STR_LIT>\";<EOL>    if (sequence.id) {<EOL>","gt":"commandOK(noun)();"}
{"input":"<s> export function factoryReset(): void {<EOL>    if (!confirm(t(Content.FACTORY_RESET_ALERT))) {<EOL>","gt":"return;"}
{"input":"<s> export function homeAll(speed: number): void {<EOL>    const noun: string = \"<STR_LIT>\";<EOL>","gt":"getDevice()"}
{"input":"<s> function initLocalStorage(): {} {<EOL>    localStorage[STORAGE_KEY] =","gt":"\"<STR_LIT>\";"}
{"input":"<s> function dev(): Store {<EOL>    store = createStore(rootReducer, maybeFetchOldState(), getMiddleware(","gt":"\"<STR_LIT>\"));"}
{"input":"<s> <EOL>function maybeRecalculateLocalSequenceVariables(next: TaggedResource): void {<EOL>    (next.","gt":"kind === \"<STR_LIT>\") && doRecalculateLocalSequenceVariables(next);"}
{"input":"<s> function whoops(origin: string, kind: string): void {<EOL>    const","gt":"msg: string = `<STR_LIT>`;"}
{"input":"<s> export function hasId(ri: ResourceIndex, k: ResourceName, id: number): boolean {<EOL>    return !!ri.byKindAndId[joinKindAndId(","gt":"k, id)];"}
{"input":"<s> export function safeBooleanSettting(name: string): BooleanConfigKey {<EOL>    if (isBooleanSetting(name)) {<EOL>","gt":"return name;"}
{"input":"<s> function safelyFetchErrors(err: AxiosErrorResponse): Dictionary<string> {<EOL>    <EOL>    if (err && err.response && err.response.data) {<EOL>        return err.response.data;<EOL>    }<EOL>    else {<EOL>        return {<EOL>            error: t(\"<STR_LIT>\" +<EOL>","gt":"\"<STR_LIT>\")"}
{"input":"<s> <EOL>export function stopIE(): void {<EOL>    function flunk(): void {<EOL>        <EOL>        <EOL>        const READ_THE_COMMENT_ABOVE: string = \"<STR_LIT>\";<EOL>        alert(READ_THE_COMMENT_ABOVE);<EOL>","gt":"window.location.href = \"<STR_LIT>\";"}
{"input":"<s> <EOL>export function stopIE(): void {<EOL>    function flunk(): void {<EOL>        <EOL>        <EOL>        const READ_THE_COMMENT_ABOVE: string = \"<STR_LIT>\";<EOL>        alert(READ_THE_COMMENT_ABOVE);<EOL>        window.location.href = \"<STR_LIT>\";<EOL>    }<EOL>    try {<EOL>        const REQUIRED_GLOBALS: string[] = [","gt":"\"<STR_LIT>\", \"<STR_LIT>\", \"<STR_LIT>\", \"<STR_LIT>\"];"}
{"input":"<s> <EOL>export function stopIE(): void {<EOL>    function flunk(): void {<EOL>        <EOL>        <EOL>        const READ_THE_COMMENT_ABOVE: string = \"<STR_LIT>\";<EOL>        alert(READ_THE_COMMENT_ABOVE);<EOL>        window.location.href = \"<STR_LIT>\";<EOL>    }<EOL>    try {<EOL>        const REQUIRED_GLOBALS: string[] = [\"<STR_LIT>\", \"<STR_LIT>\", \"<STR_LIT>\", \"<STR_LIT>\"];<EOL>        <EOL>        <EOL>        for (let i: number = <NUM_LIT>; i < REQUIRED_GLOBALS.","gt":"length; i++) {"}
{"input":"<s> export function reference(base: Exp, prop: Exp): ExpReference {<EOL>    return {<EOL>","gt":"type: '<STR_LIT>',"}
{"input":"<s> export function snapshotVariable(name: string): ExpVariable {<EOL>    return <ExpVariable>cast(variable(name),","gt":"'<STR_LIT>');"}
{"input":"<s> <EOL><EOL>export function generate(symbols: string | ast.Symbols): Validator {<EOL>    if (typeof symbols === '<STR_LIT>') {<EOL>","gt":"symbols = parser.parse(symbols);"}
{"input":"<s> <EOL>export function isURL(urlStr: any): boolean {<EOL>    if (typeof urlStr !== '<STR_LIT>') {<EOL>        return false;<EOL>    }<EOL>    <EOL>","gt":"const re: RegExp = /[^a-z0-9\\:\\/\\?\\#\\[\\]\\@\\!\\$\\&\\'\\(\\)\\*\\+\\,\\;\\=\\.\\-\\_\\~\\%]/i;"}
{"input":"<s> <EOL>export function isURL(urlStr: any): boolean {<EOL>    if (typeof urlStr !== '<STR_LIT>') {<EOL>        return false;<EOL>    }<EOL>    <EOL>    const re: RegExp = /[^a-z0-9\\:\\/\\?\\#\\[\\]\\@\\!\\$\\&\\'\\(\\)\\*\\+\\,\\;\\=\\.\\-\\_\\~\\%]/i;<EOL>    if (re.test(urlStr)) {<EOL>        return","gt":"false;"}
{"input":"<s> <EOL>export function isURL(urlStr: any): boolean {<EOL>    if (typeof urlStr !== '<STR_LIT>') {<EOL>        return false;<EOL>    }<EOL>    <EOL>    const re: RegExp = /[^a-z0-9\\:\\/\\?\\#\\[\\]\\@\\!\\$\\&\\'\\(\\)\\*\\+\\,\\;\\=\\.\\-\\_\\~\\%]/i;<EOL>    if (re.test(urlStr)) {<EOL>        return false;<EOL>    }<EOL>    try {<EOL>        const uri: any = url.parse(urlStr);<EOL>        const scheme: any = uri.protocol;<EOL>","gt":"const slashes: any = uri.slashes;"}
{"input":"<s> <EOL>export function isURL(urlStr: any): boolean {<EOL>    if (typeof urlStr !== '<STR_LIT>') {<EOL>        return false;<EOL>    }<EOL>    <EOL>    const re: RegExp = /[^a-z0-9\\:\\/\\?\\#\\[\\]\\@\\!\\$\\&\\'\\(\\)\\*\\+\\,\\;\\=\\.\\-\\_\\~\\%]/i;<EOL>    if (re.test(urlStr)) {<EOL>        return false;<EOL>    }<EOL>    try {<EOL>        const uri: any = url.parse(urlStr);<EOL>        const scheme: any = uri.protocol;<EOL>        const slashes: any = uri.slashes;<EOL>        const hostname: any = uri.hostname;<EOL>        const pathname: any = uri.pathname;<EOL>        if ((scheme !== '<STR_LIT>' && scheme !== '<STR_LIT>') || !slashes) {<EOL>            return","gt":"false;"}
{"input":"<s> <EOL>export function isURL(urlStr: any): boolean {<EOL>    if (typeof urlStr !== '<STR_LIT>') {<EOL>        return false;<EOL>    }<EOL>    <EOL>    const re: RegExp = /[^a-z0-9\\:\\/\\?\\#\\[\\]\\@\\!\\$\\&\\'\\(\\)\\*\\+\\,\\;\\=\\.\\-\\_\\~\\%]/i;<EOL>    if (re.test(urlStr)) {<EOL>        return false;<EOL>    }<EOL>    try {<EOL>        const uri: any = url.parse(urlStr);<EOL>        const scheme: any = uri.protocol;<EOL>        const slashes: any = uri.slashes;<EOL>        const hostname: any = uri.hostname;<EOL>        const pathname: any = uri.pathname;<EOL>        if ((scheme !== '<STR_LIT>' && scheme !== '<STR_LIT>') || !slashes) {<EOL>            return false;<EOL>        }<EOL>        <EOL>        <EOL>        if (!/^[a-zA-Z0-9]+[\\w\\-]*([\\.]?[a-zA-Z0-9]+[\\w\\-]*)*$/.test(","gt":"hostname)) {"}
{"input":"<s> <EOL>export function isURL(urlStr: any): boolean {<EOL>    if (typeof urlStr !== '<STR_LIT>') {<EOL>        return false;<EOL>    }<EOL>    <EOL>    const re: RegExp = /[^a-z0-9\\:\\/\\?\\#\\[\\]\\@\\!\\$\\&\\'\\(\\)\\*\\+\\,\\;\\=\\.\\-\\_\\~\\%]/i;<EOL>    if (re.test(urlStr)) {<EOL>        return false;<EOL>    }<EOL>    try {<EOL>        const uri: any = url.parse(urlStr);<EOL>        const scheme: any = uri.protocol;<EOL>        const slashes: any = uri.slashes;<EOL>        const hostname: any = uri.hostname;<EOL>        const pathname: any = uri.pathname;<EOL>        if ((scheme !== '<STR_LIT>' && scheme !== '<STR_LIT>') || !slashes) {<EOL>            return false;<EOL>        }<EOL>        <EOL>        <EOL>        if (!/^[a-zA-Z0-9]+[\\w\\-]*([\\.]?[a-zA-Z0-9]+[\\w\\-]*)*$/.test(hostname)) {<EOL>            return false;<EOL>        }<EOL>        <EOL>        <EOL>        const pathnameRe: RegExp = /^(\\/[\\w\\-\\.\\~\\!\\$\\'\\(\\)\\*\\+\\,\\;\\=\\:\\@\\%]+)*$/;<EOL>        <EOL>        if (pathname &&<EOL>","gt":"pathname !== '<STR_LIT>' &&"}
{"input":"<s> <EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL>export function dateToTimestampProto(timeString: any): {<EOL>    seconds: number;<EOL>    nanos: number;<EOL>} {<EOL>    if (typeof timeString === '<STR_LIT>') {<EOL>        return;<EOL>    }<EOL>    let","gt":"date: Date = new Date(timeString);"}
{"input":"<s> <EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL><EOL>export function dateToTimestampProto(timeString: any): {<EOL>    seconds: number;<EOL>    nanos: number;<EOL>} {<EOL>    if (typeof timeString === '<STR_LIT>') {<EOL>        return;<EOL>    }<EOL>    let date: Date = new Date(timeString);<EOL>    let seconds: number = Math.floor(date.getTime() / <NUM_LIT>);<EOL>    let nanos: number = <NUM_LIT>;<EOL>    if (timeString.length > <NUM_LIT>) {<EOL>        const nanoString: any = timeString.substring(<NUM_LIT>, timeString.length - <NUM_LIT>);<EOL>        const trailingZeroes: number = <NUM_LIT> - nanoString.length;<EOL>        nanos = parseInt(","gt":"nanoString, <NUM_LIT>) * Math.pow(<NUM_LIT>, trailingZeroes);"}
{"input":"<s> function copyFields<T, K extends keyof T>(from: any, to: T, fields: K[]): void {<EOL>    for (","gt":"let field: K of fields) {"}
{"input":"<s> <EOL>export function instance(instance: string): InstanceBuilder {<EOL>    return","gt":"new InstanceBuilder(instance);"}
{"input":"<s> export function setMaxNode(val: Node): void {<EOL>","gt":"MAX_NODE = val;"}
{"input":"<s> <EOL>function mutationsStore(txn: PersistenceTransaction): SimpleDbStore<DbMutationBatchKey, DbMutationBatch> {<EOL>    return getStore<DbMutationBatchKey, DbMutationBatch>(txn, DbMutationBatch.","gt":"store);"}
{"input":"<s> <EOL>export function validateNamedArrayAtLeastNumberOfElements<T>(functionName: string, value: T[], name: string, minNumberOfElements: number): void {<EOL>    if (!(value instanceof Array) || value.length < minNumberOfElements) {<EOL>","gt":"throw new FirestoreError(Code.INVALID_ARGUMENT, `<STR_LIT>` +"}
{"input":"<s> <EOL>export function valueDescription(input: AnyJs): string {<EOL>    if (input === undefined) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    else if (input === null) {<EOL>","gt":"return '<STR_LIT>';"}
{"input":"<s> <EOL>export function valueDescription(input: AnyJs): string {<EOL>    if (input === undefined) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    else if (input === null) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    else if (","gt":"typeof input === '<STR_LIT>') {"}
{"input":"<s> <EOL>export function valueDescription(input: AnyJs): string {<EOL>    if (input === undefined) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    else if (input === null) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    else if (typeof input === '<STR_LIT>') {<EOL>        if (input.length > <NUM_LIT>) {<EOL>            input = `<STR_LIT>`;<EOL>        }<EOL>        return","gt":"JSON.stringify(input);"}
{"input":"<s> export function debug(tag: string, msg: string, ...obj: AnyJs[]): void {<EOL>    if (logClient.logLevel <= FirebaseLogLevel.DEBUG) {<EOL>        const","gt":"args: AnyJs[] = obj.map(argToString);"}
{"input":"<s> export function shallowCopy<V>(obj: Dict<V>): Dict<V> {<EOL>    assert(obj && typeof obj === '<STR_LIT>', '<STR_LIT>');<EOL>    const result: Dict<V> = {};<EOL>    for (const key: string in","gt":"obj) {"}
{"input":"<s> <EOL><EOL><EOL><EOL>function validationIt(persistence: boolean, message: string, testFunction: (db: firestore.FirebaseFirestore) => void | Promise<any>): void {<EOL>    it(message, (): Promise<void> => {<EOL>        return withTestDb(persistence, async (db: firestore.FirebaseFirestore): Promise<any> => {<EOL>            const maybePromise:","gt":"void | Promise<any> = testFunction(db);"}
{"input":"<s> function isIeOrEdge(): boolean {<EOL>    const ua: string = window.navigator.userAgent;<EOL>    return (ua.indexOf(","gt":"'<STR_LIT>') > <NUM_LIT> ||"}
{"input":"<s> <EOL>export function toDataArray(docSet: firestore.QuerySnapshot): firestore.DocumentData[] {<EOL>    return docSet.docs.map((","gt":"d: any): any => d.data());"}
{"input":"<s> <EOL>export function withAlternateTestDb(persistence: boolean, fn: (db: firestore.FirebaseFirestore) => Promise<void>): Promise<void> {<EOL>    return","gt":"withTestDbsSettings(persistence, ALT_PROJECT_ID, DEFAULT_SETTINGS, <NUM_LIT>, ([db]) => {"}
{"input":"<s> function aggregator(version: number, targets: TargetMap, outstanding: PendingTargetResponses, ...changes: WatchChange[]): WatchChangeAggregator {<EOL>    const aggregator: WatchChangeAggregator = new WatchChangeAggregator(SnapshotVersion.fromMicroseconds(","gt":"version), targets, outstanding);"}
{"input":"<s> export function documentSet(...args: AnyJs[]): DocumentSet {<EOL>    let docSet: DocumentSet | null = null;<EOL>    if (args[<NUM_LIT>] instanceof Function) {<EOL>        docSet = new DocumentSet(args[<NUM_LIT>] as DocumentComparator);<EOL>        args =","gt":"args.slice(<NUM_LIT>);"}
{"input":"<s> export function documentSet(...args: AnyJs[]): DocumentSet {<EOL>    let docSet: DocumentSet | null = null;<EOL>    if (args[<NUM_LIT>] instanceof Function) {<EOL>        docSet = new DocumentSet(args[<NUM_LIT>] as DocumentComparator);<EOL>        args = args.slice(<NUM_LIT>);<EOL>    }<EOL>    else {<EOL>        docSet = new DocumentSet();<EOL>    }<EOL>    for (const doc: string | number | boolean | object of args) {<EOL>        assert(doc instanceof Document,","gt":"'<STR_LIT>' + doc);"}
{"input":"<s> export function patchMutation(keyStr: string, json: JsonObject<AnyJs>, precondition?: Precondition): PatchMutation {<EOL>    if (precondition === undefined) {<EOL>","gt":"precondition = Precondition.exists(true);"}
{"input":"<s> <EOL>export function size(obj: JsonObject<AnyJs>): number {<EOL>    let c:","gt":"number = <NUM_LIT>;"}
{"input":"<s> export function fromResourceString(authWrapper: AuthWrapper, resourceString: string, mappings: Mappings): Metadata | null {<EOL>    let obj: {<EOL>        [name: string]: any;<EOL>    } = json.","gt":"jsonObjectOrNull(resourceString);"}
{"input":"<s> export function forEach<T>(obj: {<EOL>    [key: string]: T;<EOL>}, f: (p1: string, p2: T) => void): void {<EOL>    for (let key: string in obj) {<EOL>        if (","gt":"contains(obj, key)) {"}
{"input":"<s> export function reject<T>(error: Error): Promise<T> {<EOL>","gt":"return Promise.reject(error) as Promise<T>;"}
{"input":"<s> <EOL>export function handlerCheck(cndn: boolean): void {<EOL>","gt":"if (!cndn) {"}
{"input":"<s> export function objectErrorHandler(location: Location): (p1: XhrIo, p2: FirebaseStorageError) => FirebaseStorageError {<EOL>    let shared: (p1: XhrIo, p2: errorsExports.FirebaseStorageError) => errorsExports.FirebaseStorageError = sharedErrorHandler(location);<EOL>    function errorHandler(xhr: XhrIo, err: FirebaseStorageError): FirebaseStorageError {<EOL>        let newErr: errorsExports.FirebaseStorageError = shared(xhr, err);<EOL>        if (xhr.","gt":"getStatus() === <NUM_LIT>) {"}
{"input":"<s> export function objectErrorHandler(location: Location): (p1: XhrIo, p2: FirebaseStorageError) => FirebaseStorageError {<EOL>    let shared: (p1: XhrIo, p2: errorsExports.FirebaseStorageError) => errorsExports.FirebaseStorageError = sharedErrorHandler(location);<EOL>    function errorHandler(xhr: XhrIo, err: FirebaseStorageError): FirebaseStorageError {<EOL>        let newErr: errorsExports.FirebaseStorageError = shared(xhr, err);<EOL>        if (xhr.getStatus() === <NUM_LIT>) {<EOL>            newErr = errorsExports.objectNotFound(location.path);<EOL>        }<EOL>        newErr.setServerResponseProp(err.serverResponseProp());<EOL>        return","gt":"newErr;"}
{"input":"<s> function authWrapperWithHandler(handler: RequestHandler): AuthWrapper {<EOL>    function newSend(xhrio: TestingXhrIo, url: string, method: string, body?: ArrayBufferView | Blob | string, headers?: Headers): void {<EOL>        const response: Response = handler(url, method, body, headers);<EOL>        xhrio.simulateResponse(response.","gt":"status, response.body, response.headers);"}
{"input":"<s> <EOL><EOL>export function deepCopy<T>(value: T): T {<EOL>    return deepExtend(undefined,","gt":"value);"}
{"input":"<s> export function pad(str: string, len: number = <NUM_LIT>, ch: any = '<STR_LIT>'): string {<EOL>    str = String(str);<EOL>    ch = toString(ch);<EOL>    let i: number = -<NUM_LIT>;<EOL>    const length: number = len - str.length;<EOL>    let","gt":"left: boolean = true;"}
{"input":"<s> export function pad(str: string, len: number = <NUM_LIT>, ch: any = '<STR_LIT>'): string {<EOL>    str = String(str);<EOL>    ch = toString(ch);<EOL>    let i: number = -<NUM_LIT>;<EOL>    const length: number = len - str.length;<EOL>    let left: boolean = true;<EOL>    while (++i < length) {<EOL>        const l: any = (str.length + ch.length <= len) ? (str.length + ch.length) : (str.length + <NUM_LIT>);<EOL>        if (left) {<EOL>            str = leftPad(str,","gt":"l, ch);"}
{"input":"<s> export function IpValidatorMessage(err: any, field: FormlyFieldConfig): string {<EOL>    return","gt":"field.formControl.value}\"<STR_LIT>;"}
{"input":"<s> <EOL>export function reducer(state: State = initialState, action: apiAction.Actions | wallAction.Actions | wallPaginationAction.Actions): State {<EOL>    switch (action.type) {<EOL>        case wallAction.ActionTypes.WALL_SEARCH: {<EOL>            return Object.assign({}, state, {<EOL>                loading: true<EOL>            });<EOL>        }<EOL>        case apiAction.ActionTypes.WALL_SEARCH_COMPLETE_SUCCESS:<EOL>        case apiAction.ActionTypes.WALL_SEARCH_COMPLETE_FAIL: {<EOL>            return Object.assign({},","gt":"state, {"}
{"input":"<s> <EOL>export function reducer(state: State = initialState, action: apiAction.Actions | wallAction.Actions | wallPaginationAction.Actions): State {<EOL>    switch (action.type) {<EOL>        case wallAction.ActionTypes.WALL_SEARCH: {<EOL>            return Object.assign({}, state, {<EOL>                loading: true<EOL>            });<EOL>        }<EOL>        case apiAction.ActionTypes.WALL_SEARCH_COMPLETE_SUCCESS:<EOL>        case apiAction.ActionTypes.WALL_SEARCH_COMPLETE_FAIL: {<EOL>            return Object.assign({}, state, {<EOL>                loading: false<EOL>            });<EOL>        }<EOL>","gt":"default: {"}
{"input":"<s> <EOL>export function instantiate(load: Module, origInstantiate: any): any {<EOL>    logger.","gt":"debug(`<STR_LIT>`);"}
{"input":"<s> function incrementPos<T>(pos: Position<T>, nodes: Slot<T>[]): void {<EOL>    if (pos.upperIndex === <NUM_LIT> && pos.lowerIndex === pos.upper.slots.length - <NUM_LIT>) {<EOL>        return;<EOL>    }<EOL>    if (pos.upperIndex === <NUM_LIT> && pos.lowerIndex >= pos.lastLowerIndex) {<EOL>        pos.lowerIndex = <NUM_LIT>;<EOL>","gt":"pos.upperIndex++;"}
{"input":"<s> function incrementPos<T>(pos: Position<T>, nodes: Slot<T>[]): void {<EOL>    if (pos.upperIndex === <NUM_LIT> && pos.lowerIndex === pos.upper.slots.length - <NUM_LIT>) {<EOL>        return;<EOL>    }<EOL>    if (pos.upperIndex === <NUM_LIT> && pos.lowerIndex >= pos.lastLowerIndex) {<EOL>        pos.lowerIndex = <NUM_LIT>;<EOL>        pos.upperIndex++;<EOL>        pos.upper = nodes[pos.upperIndex];<EOL>    }<EOL>    else {<EOL>        pos.","gt":"lowerIndex++;"}
{"input":"<s> function incrementPos<T>(pos: Position<T>, nodes: Slot<T>[]): void {<EOL>    if (pos.upperIndex === <NUM_LIT> && pos.lowerIndex === pos.upper.slots.length - <NUM_LIT>) {<EOL>        return;<EOL>    }<EOL>    if (pos.upperIndex === <NUM_LIT> && pos.lowerIndex >= pos.lastLowerIndex) {<EOL>        pos.lowerIndex = <NUM_LIT>;<EOL>        pos.upperIndex++;<EOL>        pos.upper = nodes[pos.upperIndex];<EOL>    }<EOL>    else {<EOL>        pos.lowerIndex++;<EOL>    }<EOL>    pos.absoluteIndex++;<EOL>    var lower: T | Slot<T> = pos.upper.slots[","gt":"pos.lowerIndex];"}
{"input":"<s> <EOL>function isAncestor<T>(upperView: View<T>, lowerView: View<T>, listSize: number): boolean {<EOL>    if (upperView.isRoot())<EOL>","gt":"return true;"}
{"input":"<s> export function gatherLeafValues(arg: AnyListType<any>, flatten = true): any[] {<EOL>    var slot: Slot<any> = arg instanceof Slot ? arg : rootSlot(arg);<EOL>","gt":"return flatten"}
{"input":"<s> export function fromIterable<K, V>(iterable: Iterable<[<EOL>    K,<EOL>    V<EOL>]>): HashMapStructure<K, V> {<EOL>    let map: HashMapStructure<K, V> = <HashMapStructure<K, V>>empty<K, V>(true);<EOL>    let current: IteratorResult<[<EOL>        K,<EOL>        V<EOL>    ]>;<EOL>","gt":"let it: Iterator<["}
{"input":"<s> export function fromIterable<K, V>(iterable: Iterable<[<EOL>    K,<EOL>    V<EOL>]>): HashMapStructure<K, V> {<EOL>    let map: HashMapStructure<K, V> = <HashMapStructure<K, V>>empty<K, V>(true);<EOL>    let current: IteratorResult<[<EOL>        K,<EOL>        V<EOL>    ]>;<EOL>    let it: Iterator<[<EOL>        K,<EOL>        V<EOL>    ], any, undefined> = iterable[Symbol.iterator]();<EOL>    while (!(current = it.next()).done) {<EOL>","gt":"var entry: ["}
{"input":"<s> export function fromIterable<K, V>(iterable: Iterable<[<EOL>    K,<EOL>    V<EOL>]>): HashMapStructure<K, V> {<EOL>    let map: HashMapStructure<K, V> = <HashMapStructure<K, V>>empty<K, V>(true);<EOL>    let current: IteratorResult<[<EOL>        K,<EOL>        V<EOL>    ]>;<EOL>    let it: Iterator<[<EOL>        K,<EOL>        V<EOL>    ], any, undefined> = iterable[Symbol.iterator]();<EOL>    while (!(current = it.next()).done) {<EOL>        var entry: [<EOL>            K,<EOL>            V<EOL>        ] = current.value;<EOL>        const change:","gt":"any = ChangeFlag.get();"}
{"input":"<s> export function bitmapToIndex(shift: number, bitmap: number): number {<EOL>    return hammingWeight(shift & (","gt":"bitmap - <NUM_LIT>));"}
{"input":"<s> export function fromPairsWithStringKeys<V>(pairs: [<EOL>    string,<EOL>    V<EOL>][] | Iterable<[<EOL>    string,<EOL>    V<EOL>]>, mutability?: C.PreferredContext): RedBlackTreeStructure<string, V> {<EOL>","gt":"return fromPairs<string, V>(stringCompare, pairs, mutability);"}
{"input":"<s> export function assignValue<K, V>(value: V, node: Node<K, V>): boolean {<EOL>    const v: V = node.value;<EOL>    <EOL>    if (v === value || (v !== null &&","gt":"typeof v === '<STR_LIT>' && v == value)) {"}
{"input":"<s> export function isNone<K, V>(node: Node<K, V>): boolean {<EOL>    return node ===","gt":"NONE;"}
{"input":"<s> export function fromIterable<T>(values: Iterable<T>): HashSetStructure<T> {<EOL>","gt":"return createSet(values);"}
{"input":"<s> export function intersect<T>(other: HashSetStructure<T> | T[] | Iterable<T>, main: HashSetStructure<T>): HashSetStructure<T> {<EOL>    var immutable: any = isImmutable(main);<EOL>    var outputSet: any = immutable ? emptySet<T>(true) : modify(main);<EOL>    var outputMap: any = immutable ? outputSet._map : HashMap.empty<T, null>(outputSet);<EOL>    if (isHashSet<T>(other)) {<EOL>        intersectHashSet(main._map, other._map, outputMap);<EOL>    }<EOL>    else if (Array.isArray(other)) {<EOL>        intersectArray(main._map, other, outputMap);<EOL>    }<EOL>    else if (other && typeof other === '<STR_LIT>') {<EOL>        if (","gt":"isIterable<T>(other)) {"}
{"input":"<s> export function intersect<T>(other: HashSetStructure<T> | T[] | Iterable<T>, main: HashSetStructure<T>): HashSetStructure<T> {<EOL>    var immutable: any = isImmutable(main);<EOL>    var outputSet: any = immutable ? emptySet<T>(true) : modify(main);<EOL>    var outputMap: any = immutable ? outputSet._map : HashMap.empty<T, null>(outputSet);<EOL>    if (isHashSet<T>(other)) {<EOL>        intersectHashSet(main._map, other._map, outputMap);<EOL>    }<EOL>    else if (Array.isArray(other)) {<EOL>        intersectArray(main._map, other, outputMap);<EOL>    }<EOL>    else if (other && typeof other === '<STR_LIT>') {<EOL>        if (isIterable<T>(other)) {<EOL>            intersectIterable<T>(main._map, other[Symbol.iterator](), outputMap);<EOL>        }<EOL>    }<EOL>    if (HashMap.size(outputMap) ===","gt":"HashMap.size(main._map)) {"}
{"input":"<s> export function set<K, V, U>(key: K, value: V, map: SortedMapStructure<K, V, U>): SortedMapStructure<K, V, U> {<EOL>    var nextSet: any = modify(map);<EOL>    const modified: boolean = setItem(key,","gt":"value, nextSet._indexed, nextSet._sorted, nextSet._select);"}
{"input":"<s> function createComparatorFn<K, V, U>(compare: ComparatorFn<Entry<K, V, U>>): ComparatorFn<Entry<K, V, U>> {<EOL>    var fn: any = COMPARATOR_CACHE.get(compare);<EOL>    return isDefined(fn) ?","gt":"fn : (fn = function (a: Entry<K, V, U>, b: Entry<K, V, U>): number {"}
{"input":"<s> export function isEmpty<T>(set: SortedSetStructure<T>): boolean {<EOL>    return _size(","gt":"set._tree) === <NUM_LIT>;"}
{"input":"<s> export function isEqual<T>(set: SortedSetStructure<T>, other: SortedSetStructure<T>): boolean {<EOL>    if (set === other)<EOL>        return true;<EOL>    if (size(set) !== size(other) ||<EOL>        set._select !== other._select ||<EOL>        set._compare !==","gt":"other._compare)"}
{"input":"<s> export function isEqual<T>(set: SortedSetStructure<T>, other: SortedSetStructure<T>): boolean {<EOL>    if (set === other)<EOL>        return true;<EOL>    if (size(set) !== size(other) ||<EOL>        set._select !== other._select ||<EOL>        set._compare !== other._compare)<EOL>        return false;<EOL>    var a: RedBlackTreeStructure<import(\"<STR_LIT>\").SortedSetItem<T>, null> = set._tree, b: RedBlackTreeStructure<import(\"<STR_LIT>\").SortedSetItem<T>, null> = other._tree;<EOL>    var ita: any = iterateFromFirst(a), itb: any = iterateFromFirst(b);<EOL>","gt":"do {"}
{"input":"<s> export function isEqual<T>(set: SortedSetStructure<T>, other: SortedSetStructure<T>): boolean {<EOL>    if (set === other)<EOL>        return true;<EOL>    if (size(set) !== size(other) ||<EOL>        set._select !== other._select ||<EOL>        set._compare !== other._compare)<EOL>        return false;<EOL>    var a: RedBlackTreeStructure<import(\"<STR_LIT>\").SortedSetItem<T>, null> = set._tree, b: RedBlackTreeStructure<import(\"<STR_LIT>\").SortedSetItem<T>, null> = other._tree;<EOL>    var ita: any = iterateFromFirst(a), itb: any = iterateFromFirst(b);<EOL>    do {<EOL>        var ca: any = ita.next();<EOL>        var cb: any = itb.next();<EOL>        if (!equals(ca.value.value, cb.value.","gt":"value))"}
{"input":"<s> <EOL>function $import(name: string, o: any = {}): any {<EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    if (name.","gt":"charCodeAt(<NUM_LIT>) === <NUM_LIT> || name.charCodeAt(<NUM_LIT>) === <NUM_LIT>) {"}
{"input":"<s> <EOL>function $import(name: string, o: any = {}): any {<EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    if (name.charCodeAt(<NUM_LIT>) === <NUM_LIT> || name.charCodeAt(<NUM_LIT>) === <NUM_LIT>) {<EOL>        return $loadURL(name);<EOL>    }<EOL>    let ref: IReference = $getRef(name, o);<EOL>    if (ref.server) {<EOL>        return ref.","gt":"server;"}
{"input":"<s> <EOL>function $import(name: string, o: any = {}): any {<EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    if (name.charCodeAt(<NUM_LIT>) === <NUM_LIT> || name.charCodeAt(<NUM_LIT>) === <NUM_LIT>) {<EOL>        return $loadURL(name);<EOL>    }<EOL>    let ref: IReference = $getRef(name, o);<EOL>    if (ref.server) {<EOL>        return ref.server;<EOL>    }<EOL>    let file: any = ref.file;<EOL>    <EOL>    if (ref.wildcard) {<EOL>        <EOL>        let safeRegEx: RegExp = new RegExp(ref.wildcard<EOL>            .replace(/\\*/g, \"<STR_LIT>\")<EOL>            .replace(/[.?*+^$[\\]\\\\(){}|-]/g, \"<STR_LIT>\")<EOL>            .replace(","gt":"/@@/g, \"<STR_LIT>\")"}
{"input":"<s> <EOL>function $import(name: string, o: any = {}): any {<EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    if (name.charCodeAt(<NUM_LIT>) === <NUM_LIT> || name.charCodeAt(<NUM_LIT>) === <NUM_LIT>) {<EOL>        return $loadURL(name);<EOL>    }<EOL>    let ref: IReference = $getRef(name, o);<EOL>    if (ref.server) {<EOL>        return ref.server;<EOL>    }<EOL>    let file: any = ref.file;<EOL>    <EOL>    if (ref.wildcard) {<EOL>        <EOL>        let safeRegEx: RegExp = new RegExp(ref.wildcard<EOL>            .replace(/\\*/g, \"<STR_LIT>\")<EOL>            .replace(/[.?*+^$[\\]\\\\(){}|-]/g, \"<STR_LIT>\")<EOL>            .replace(/@@/g, \"<STR_LIT>\")<EOL>            .replace(/@/g, \"<STR_LIT>\"), \"<STR_LIT>\");<EOL>        let pkg: PackageDetails = $packages[ref.pkgName];<EOL>        if (pkg) {<EOL>            let batch: {} = {};<EOL>            for (let n: string in pkg.f) {<EOL>                if (safeRegEx.test(n)) {<EOL>                    batch[n] = $import(`<STR_LIT>`);<EOL>                }<EOL>            }<EOL>            return batch;<EOL>        }<EOL>    }<EOL>    if (!file) {<EOL>        let asyncMode: boolean = typeof o === \"<STR_LIT>\";<EOL>        let processStopped: boolean = $trigger(\"<STR_LIT>\", [name, o]);<EOL>        if (processStopped === false) {<EOL>            return;<EOL>        }<EOL>        return $async(name, (result: any): any => asyncMode ? o(result) : null, o);<EOL>        <EOL>    }<EOL>    <EOL>    let pkg: string = ref.pkgName;<EOL>    if (file.locals && file.locals.module)<EOL>        return file.","gt":"locals.module.exports;"}
{"input":"<s> <EOL>function $import(name: string, o: any = {}): any {<EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    if (name.charCodeAt(<NUM_LIT>) === <NUM_LIT> || name.charCodeAt(<NUM_LIT>) === <NUM_LIT>) {<EOL>        return $loadURL(name);<EOL>    }<EOL>    let ref: IReference = $getRef(name, o);<EOL>    if (ref.server) {<EOL>        return ref.server;<EOL>    }<EOL>    let file: any = ref.file;<EOL>    <EOL>    if (ref.wildcard) {<EOL>        <EOL>        let safeRegEx: RegExp = new RegExp(ref.wildcard<EOL>            .replace(/\\*/g, \"<STR_LIT>\")<EOL>            .replace(/[.?*+^$[\\]\\\\(){}|-]/g, \"<STR_LIT>\")<EOL>            .replace(/@@/g, \"<STR_LIT>\")<EOL>            .replace(/@/g, \"<STR_LIT>\"), \"<STR_LIT>\");<EOL>        let pkg: PackageDetails = $packages[ref.pkgName];<EOL>        if (pkg) {<EOL>            let batch: {} = {};<EOL>            for (let n: string in pkg.f) {<EOL>                if (safeRegEx.test(n)) {<EOL>                    batch[n] = $import(`<STR_LIT>`);<EOL>                }<EOL>            }<EOL>            return batch;<EOL>        }<EOL>    }<EOL>    if (!file) {<EOL>        let asyncMode: boolean = typeof o === \"<STR_LIT>\";<EOL>        let processStopped: boolean = $trigger(\"<STR_LIT>\", [name, o]);<EOL>        if (processStopped === false) {<EOL>            return;<EOL>        }<EOL>        return $async(name, (result: any): any => asyncMode ? o(result) : null, o);<EOL>        <EOL>    }<EOL>    <EOL>    let pkg: string = ref.pkgName;<EOL>    if (file.locals && file.locals.module)<EOL>        return file.locals.module.exports;<EOL>    let locals: any = file.locals = {};<EOL>    <EOL>    const path: string = $getDir(ref.validPath);<EOL>    locals.exports = {};<EOL>    locals.module = { exports: locals.exports };<EOL>    locals.require = (name: string, optionalCallback: any): any => {<EOL>        const result: any = $import(name, {<EOL>","gt":"pkg,"}
{"input":"<s> <EOL>function $import(name: string, o: any = {}): any {<EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    if (name.charCodeAt(<NUM_LIT>) === <NUM_LIT> || name.charCodeAt(<NUM_LIT>) === <NUM_LIT>) {<EOL>        return $loadURL(name);<EOL>    }<EOL>    let ref: IReference = $getRef(name, o);<EOL>    if (ref.server) {<EOL>        return ref.server;<EOL>    }<EOL>    let file: any = ref.file;<EOL>    <EOL>    if (ref.wildcard) {<EOL>        <EOL>        let safeRegEx: RegExp = new RegExp(ref.wildcard<EOL>            .replace(/\\*/g, \"<STR_LIT>\")<EOL>            .replace(/[.?*+^$[\\]\\\\(){}|-]/g, \"<STR_LIT>\")<EOL>            .replace(/@@/g, \"<STR_LIT>\")<EOL>            .replace(/@/g, \"<STR_LIT>\"), \"<STR_LIT>\");<EOL>        let pkg: PackageDetails = $packages[ref.pkgName];<EOL>        if (pkg) {<EOL>            let batch: {} = {};<EOL>            for (let n: string in pkg.f) {<EOL>                if (safeRegEx.test(n)) {<EOL>                    batch[n] = $import(`<STR_LIT>`);<EOL>                }<EOL>            }<EOL>            return batch;<EOL>        }<EOL>    }<EOL>    if (!file) {<EOL>        let asyncMode: boolean = typeof o === \"<STR_LIT>\";<EOL>        let processStopped: boolean = $trigger(\"<STR_LIT>\", [name, o]);<EOL>        if (processStopped === false) {<EOL>            return;<EOL>        }<EOL>        return $async(name, (result: any): any => asyncMode ? o(result) : null, o);<EOL>        <EOL>    }<EOL>    <EOL>    let pkg: string = ref.pkgName;<EOL>    if (file.locals && file.locals.module)<EOL>        return file.locals.module.exports;<EOL>    let locals: any = file.locals = {};<EOL>    <EOL>    const path: string = $getDir(ref.validPath);<EOL>    locals.exports = {};<EOL>    locals.module = { exports: locals.exports };<EOL>    locals.require = (name: string, optionalCallback: any): any => {<EOL>        const result: any = $import(name, {<EOL>            pkg,<EOL>            path,<EOL>            v: ref.versions,<EOL>        });<EOL>        if (FuseBox[\"<STR_LIT>\"]) {<EOL>            syntheticDefaultExportPolyfill(result);<EOL>        }<EOL>","gt":"return result;"}
{"input":"<s> <EOL>function $import(name: string, o: any = {}): any {<EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    if (name.charCodeAt(<NUM_LIT>) === <NUM_LIT> || name.charCodeAt(<NUM_LIT>) === <NUM_LIT>) {<EOL>        return $loadURL(name);<EOL>    }<EOL>    let ref: IReference = $getRef(name, o);<EOL>    if (ref.server) {<EOL>        return ref.server;<EOL>    }<EOL>    let file: any = ref.file;<EOL>    <EOL>    if (ref.wildcard) {<EOL>        <EOL>        let safeRegEx: RegExp = new RegExp(ref.wildcard<EOL>            .replace(/\\*/g, \"<STR_LIT>\")<EOL>            .replace(/[.?*+^$[\\]\\\\(){}|-]/g, \"<STR_LIT>\")<EOL>            .replace(/@@/g, \"<STR_LIT>\")<EOL>            .replace(/@/g, \"<STR_LIT>\"), \"<STR_LIT>\");<EOL>        let pkg: PackageDetails = $packages[ref.pkgName];<EOL>        if (pkg) {<EOL>            let batch: {} = {};<EOL>            for (let n: string in pkg.f) {<EOL>                if (safeRegEx.test(n)) {<EOL>                    batch[n] = $import(`<STR_LIT>`);<EOL>                }<EOL>            }<EOL>            return batch;<EOL>        }<EOL>    }<EOL>    if (!file) {<EOL>        let asyncMode: boolean = typeof o === \"<STR_LIT>\";<EOL>        let processStopped: boolean = $trigger(\"<STR_LIT>\", [name, o]);<EOL>        if (processStopped === false) {<EOL>            return;<EOL>        }<EOL>        return $async(name, (result: any): any => asyncMode ? o(result) : null, o);<EOL>        <EOL>    }<EOL>    <EOL>    let pkg: string = ref.pkgName;<EOL>    if (file.locals && file.locals.module)<EOL>        return file.locals.module.exports;<EOL>    let locals: any = file.locals = {};<EOL>    <EOL>    const path: string = $getDir(ref.validPath);<EOL>    locals.exports = {};<EOL>    locals.module = { exports: locals.exports };<EOL>    locals.require = (name: string, optionalCallback: any): any => {<EOL>        const result: any = $import(name, {<EOL>            pkg,<EOL>            path,<EOL>            v: ref.versions,<EOL>        });<EOL>        if (FuseBox[\"<STR_LIT>\"]) {<EOL>            syntheticDefaultExportPolyfill(result);<EOL>        }<EOL>        return result;<EOL>    };<EOL>    if ($isBrowser || !g[\"<STR_LIT>\"].main) {<EOL>        locals.require.main = { filename:","gt":"\"<STR_LIT>\", paths: [] };"}
{"input":"<s> <EOL>function $import(name: string, o: any = {}): any {<EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    if (name.charCodeAt(<NUM_LIT>) === <NUM_LIT> || name.charCodeAt(<NUM_LIT>) === <NUM_LIT>) {<EOL>        return $loadURL(name);<EOL>    }<EOL>    let ref: IReference = $getRef(name, o);<EOL>    if (ref.server) {<EOL>        return ref.server;<EOL>    }<EOL>    let file: any = ref.file;<EOL>    <EOL>    if (ref.wildcard) {<EOL>        <EOL>        let safeRegEx: RegExp = new RegExp(ref.wildcard<EOL>            .replace(/\\*/g, \"<STR_LIT>\")<EOL>            .replace(/[.?*+^$[\\]\\\\(){}|-]/g, \"<STR_LIT>\")<EOL>            .replace(/@@/g, \"<STR_LIT>\")<EOL>            .replace(/@/g, \"<STR_LIT>\"), \"<STR_LIT>\");<EOL>        let pkg: PackageDetails = $packages[ref.pkgName];<EOL>        if (pkg) {<EOL>            let batch: {} = {};<EOL>            for (let n: string in pkg.f) {<EOL>                if (safeRegEx.test(n)) {<EOL>                    batch[n] = $import(`<STR_LIT>`);<EOL>                }<EOL>            }<EOL>            return batch;<EOL>        }<EOL>    }<EOL>    if (!file) {<EOL>        let asyncMode: boolean = typeof o === \"<STR_LIT>\";<EOL>        let processStopped: boolean = $trigger(\"<STR_LIT>\", [name, o]);<EOL>        if (processStopped === false) {<EOL>            return;<EOL>        }<EOL>        return $async(name, (result: any): any => asyncMode ? o(result) : null, o);<EOL>        <EOL>    }<EOL>    <EOL>    let pkg: string = ref.pkgName;<EOL>    if (file.locals && file.locals.module)<EOL>        return file.locals.module.exports;<EOL>    let locals: any = file.locals = {};<EOL>    <EOL>    const path: string = $getDir(ref.validPath);<EOL>    locals.exports = {};<EOL>    locals.module = { exports: locals.exports };<EOL>    locals.require = (name: string, optionalCallback: any): any => {<EOL>        const result: any = $import(name, {<EOL>            pkg,<EOL>            path,<EOL>            v: ref.versions,<EOL>        });<EOL>        if (FuseBox[\"<STR_LIT>\"]) {<EOL>            syntheticDefaultExportPolyfill(result);<EOL>        }<EOL>        return result;<EOL>    };<EOL>    if ($isBrowser || !g[\"<STR_LIT>\"].main) {<EOL>        locals.require.main = { filename: \"<STR_LIT>\", paths: [] };<EOL>    }<EOL>","gt":"else {"}
{"input":"<s> export function matchesDefinedIfExpression(node, expressions: {<EOL>    [key: string]: boolean | string | number;<EOL>}): string {<EOL>    if (node.type && node.type === \"<STR_LIT>\") {<EOL>        <EOL>        if (node.$parent && node.$parent.type === \"<STR_LIT>\") {<EOL>            return;<EOL>        }<EOL>        if (node.test && node.test.type === \"<STR_LIT>\") {<EOL>            if (node.test.left) {<EOL>                for (const key: string in expressions) {<EOL>","gt":"if (matchesPath(node.test.left, key)) {"}
{"input":"<s> export async function tsc(root: string, opts?: TscOptions): Promise<unknown> {<EOL>    let tscOptions: any = [];<EOL>    root = ensureAbsolutePath(root);<EOL>    opts.project = root;<EOL>    for (const key: string in opts) {<EOL>","gt":"if (opts[key] !== undefined) {"}
{"input":"<s> export async function tsc(root: string, opts?: TscOptions): Promise<unknown> {<EOL>    let tscOptions: any = [];<EOL>    root = ensureAbsolutePath(root);<EOL>    opts.project = root;<EOL>    for (const key: string in opts) {<EOL>        if (opts[key] !== undefined) {<EOL>            if (key === '<STR_LIT>') {<EOL>                tscOptions.push(`<STR_LIT>`);<EOL>            }<EOL>            else {<EOL>                tscOptions.push(`<STR_LIT>`, String(opts[key]));<EOL>            }<EOL>        }<EOL>    }<EOL>    return new Promise((resolve: (value: unknown) => void, reject: (reason?: any) => void): void => {<EOL>        const proc: any = spawn(\"<STR_LIT>\" + (/^win/.test(process.platform) ? \"<STR_LIT>\" : \"<STR_LIT>\"), tscOptions, {<EOL>            stdio: \"<STR_LIT>\"<EOL>        });<EOL>        proc.on(\"<STR_LIT>\", function (code) {<EOL>","gt":"if (code === <NUM_LIT>) {"}
{"input":"<s> function setup({ plugins, styleContent = style }) {<EOL>    return createEnv({<EOL>        project: {<EOL>            files: {<EOL>","gt":"\"<STR_LIT>\": `<STR_LIT>`,"}
{"input":"<s> function setup({ plugins, styleContent = style }) {<EOL>    return createEnv({<EOL>        project: {<EOL>            files: {<EOL>                \"<STR_LIT>\": `<STR_LIT>`,<EOL>                \"<STR_LIT>\": styleContent<EOL>            },<EOL>            plugins: plugins,<EOL>            instructions:","gt":"\"<STR_LIT>\","}
{"input":"<s> <EOL>export function loadContentComponent(): void {<EOL>","gt":"console.log(\"<STR_LIT>\");"}
{"input":"<s> export function deepAssign(target: any, ...args: any[]): any {<EOL>    target = toObject(target);<EOL>    for (var","gt":"s: number = <NUM_LIT>; s < args.length; s++) {"}
{"input":"<s> export function renderModule(name: string, renderTest: Constructor<RenderTest>): void {<EOL>    QUnit.module(name);<EOL>    for (let prop: string in renderTest.prototype) {<EOL>        const test: any = renderTest.prototype[prop];<EOL>        if (isTestFunction(test) && shouldRun(","gt":"test)) {"}
{"input":"<s> function setTestingDescriptor(descriptor: PropertyDescriptor): void {<EOL>","gt":"let testFunction: Function = descriptor.value as Function;"}
{"input":"<s> <EOL>export function getImportStatements(modules: ModuleLocator[]): {<EOL>    imports: string[];<EOL>    identifiers: string[];<EOL>} {<EOL>    let identifiers: string[] = new Array<string>(modules.length).fill('<STR_LIT>');<EOL>    let imports: string[] = modules.map((locator: ModuleLocator, handle: number): string => {<EOL>        <EOL>        <EOL>        <EOL>        <EOL>        if (!locator) {<EOL>            identifiers[handle] = `<STR_LIT>`;<EOL>","gt":"return '<STR_LIT>';"}
{"input":"<s> <EOL>export function getImportStatements(modules: ModuleLocator[]): {<EOL>    imports: string[];<EOL>    identifiers: string[];<EOL>} {<EOL>    let identifiers: string[] = new Array<string>(modules.length).fill('<STR_LIT>');<EOL>    let imports: string[] = modules.map((locator: ModuleLocator, handle: number): string => {<EOL>        <EOL>        <EOL>        <EOL>        <EOL>        if (!locator) {<EOL>            identifiers[handle] = `<STR_LIT>`;<EOL>            return '<STR_LIT>';<EOL>        }<EOL>        let id: string = getIdentifier(locator, handle);<EOL>","gt":"identifiers[handle] = id;"}
{"input":"<s> export function precompile(string: string, options: PrecompileOptions = defaultOptions): TemplateJavascript {<EOL>    let ast: import(\"<STR_LIT>\").Program = preprocess(string, options);<EOL>    let { meta } = options;<EOL>    let { block } = TemplateCompiler.compile(options, ast);<EOL>    let idFn: TemplateIdFn = options.","gt":"id || defaultId;"}
{"input":"<s> function isHelperInvocation(mustache: AST.MustacheStatement): mustache is AST.MustacheStatement & {<EOL>    path: AST.PathExpression;<EOL>} {<EOL>    return (mustache.params && mustache.params.length >","gt":"<NUM_LIT>) ||"}
{"input":"<s> export function test(...args: any[]): any {<EOL>    if (args.length === <NUM_LIT>) {<EOL>        let meta: Dict<Opaque> = args[<NUM_LIT>];<EOL>        return (_target: Object, _name: string, descriptor: PropertyDescriptor): void => {<EOL>            let","gt":"testFunction: Function & Dict<Opaque> = descriptor.value as Function & Dict<Opaque>;"}
{"input":"<s> export function test(...args: any[]): any {<EOL>    if (args.length === <NUM_LIT>) {<EOL>        let meta: Dict<Opaque> = args[<NUM_LIT>];<EOL>        return (_target: Object, _name: string, descriptor: PropertyDescriptor): void => {<EOL>            let testFunction: Function & Dict<Opaque> = descriptor.value as Function & Dict<Opaque>;<EOL>            Object.keys(meta).forEach((key: string): Opaque => (testFunction[key] = meta[key]));<EOL>            setTestingDescriptor(descriptor);<EOL>        };<EOL>    }<EOL>    let","gt":"descriptor: any = args[<NUM_LIT>];"}
{"input":"<s> function decodeSmi(smi: number): number {<EOL>    switch (smi & <NUM_LIT>) {<EOL>        case PrimitiveType.NUMBER:<EOL>            return","gt":"smi >> <NUM_LIT>;"}
{"input":"<s> function allDirty<T>(refs: Reference<T>[], newValue: T): void {<EOL>    refs.","gt":"forEach(function (ref) { isDirty(ref, newValue); });"}
{"input":"<s> function root<T>(obj: T): UpdatableReference<T> {<EOL>","gt":"return metaFor(obj).root() as UpdatableReference<T>;"}
{"input":"<s> export function logOpcode(type: string, params: Option<Object>): string | void {<EOL>    let out: string = type;<EOL>    if (","gt":"params) {"}
{"input":"<s> export function clear(bounds: Bounds): Option<Simple.Node> {<EOL>    let parent: Simple.Element = bounds.parentElement();<EOL>    let first: Option<Simple.Node> = bounds.firstNode();<EOL>    let last: Option<Simple.Node> = bounds.lastNode();<EOL>","gt":"let node: Option<Simple.Node> = first;"}
{"input":"<s> export function clear(bounds: Bounds): Option<Simple.Node> {<EOL>    let parent: Simple.Element = bounds.parentElement();<EOL>    let first: Option<Simple.Node> = bounds.firstNode();<EOL>    let last: Option<Simple.Node> = bounds.lastNode();<EOL>    let node: Option<Simple.Node> = first;<EOL>    while (node) {<EOL>        let next: import(\"<STR_LIT>\").Option<Simple.Node> = node.nextSibling;<EOL>        parent.removeChild(node);<EOL>        if (node === last)<EOL>            return next;<EOL>        node =","gt":"next;"}
{"input":"<s> <EOL>export function setDebuggerCallback(cb: DebugCallback): void {<EOL>    callback =","gt":"cb;"}
{"input":"<s> function isTextNode(node: Simple.Node): node is Simple.Text {<EOL>    return node.nodeType ===","gt":"<NUM_LIT>;"}
{"input":"<s> export function rehydrationBuilder(env: Environment, cursor: Cursor): ElementBuilder {<EOL>    return","gt":"RehydrateBuilder.forInitialRender(env, cursor);"}
{"input":"<s> export function assertAppended(content: string): void {<EOL>    equalTokens((","gt":"document.querySelector('<STR_LIT>') as HTMLElement), content);"}
{"input":"<s> function compile(template: string): Template<unknown> {<EOL>","gt":"return env.compile(template);"}
{"input":"<s> export function module(name: string, second?: any, third?: any): any {<EOL>    let nested: any, setup: any;<EOL>    if (arguments.length === <NUM_LIT>) {<EOL>        setup = second;<EOL>        nested = third;<EOL>    }<EOL>    else if (arguments.length === <NUM_LIT>) {<EOL>        if (typeof second === '<STR_LIT>') {<EOL>            setup = second;<EOL>        }<EOL>        else {<EOL>","gt":"nested = second;"}
{"input":"<s> export function todo(name: string, callback: (assert: Assert) => void): any {<EOL>    return (","gt":"QUnit as any).todo(name, callback);"}
{"input":"<s> function buildMustacheComment(value: string, loc?: AST.SourceLocation): AST.MustacheCommentStatement {<EOL>    return {<EOL>        type:","gt":"\"<STR_LIT>\","}
{"input":"<s> function buildPosition(line: number, column: number): {<EOL>    line: number;<EOL>    column: number;<EOL>} {<EOL>    return {<EOL>","gt":"line,"}
{"input":"<s> export function appendChild(parent: AST.Program | AST.ElementNode, node: AST.Statement): void {<EOL>    childrenFor(parent).","gt":"push(node);"}
{"input":"<s> export function isLiteral(path: AST.PathExpression | AST.Literal): path is AST.Literal {<EOL>    return path.type === '<STR_LIT>'<EOL>        || path.","gt":"type === '<STR_LIT>'"}
{"input":"<s> <EOL>function isProblematicAttribute(attr: any): boolean {<EOL>    var isLabel: dom5.Predicate = p.hasTagName(\"<STR_LIT>\");<EOL>    switch (attr.name.toLowerCase()) {<EOL>        case \"<STR_LIT>\":<EOL>            return isLabel(attr.","gt":"node);"}
{"input":"<s> <EOL>function isProblematicAttribute(attr: any): boolean {<EOL>    var isLabel: dom5.Predicate = p.hasTagName(\"<STR_LIT>\");<EOL>    switch (attr.name.toLowerCase()) {<EOL>        case \"<STR_LIT>\":<EOL>            return isLabel(attr.node);<EOL>    }<EOL>    if (isNativeAttribute(attr.name.toLowerCase())) {<EOL>        return true;<EOL>    }<EOL>    if (attr.name.indexOf(\"<STR_LIT>\") === <NUM_LIT> &&<EOL>        attr.name[attr.","gt":"name.length - <NUM_LIT>] != \"<STR_LIT>\") {"}
{"input":"<s> function makeWin32TmpDir(): any {<EOL>    const winTmpPath: any = process.env.TEMP || process.env.TMP ||<EOL>        (process.env.SystemRoot ||","gt":"process.env.windir) + '<STR_LIT>';"}
{"input":"<s> function patchHttp2Session(session: http2.Http2Session, authority: string | URL, api: TraceAgent): void {<EOL>","gt":"api.wrapEmitter(session);"}
{"input":"<s> async function runTest(testConfig: TestConfig): Promise<void> {<EOL>    const appView: MockView = new MockView([]);<EOL>    const files: Map<string, string> = await generateFiles(appView, testConfig.config, BASE_IMAGE);<EOL>    assert.ok(files);<EOL>    <EOL>    <EOL>    assert.strictEqual(files.size, <NUM_LIT>);<EOL>    assert.strictEqual(appView.pathsWritten.length, <NUM_LIT>);<EOL>    assert.strictEqual(files.has(","gt":"DOCKERFILE_NAME), true);"}
{"input":"<s> async function runTest(testConfig: TestConfig): Promise<void> {<EOL>    const appView: MockView = new MockView([]);<EOL>    const files: Map<string, string> = await generateFiles(appView, testConfig.config, BASE_IMAGE);<EOL>    assert.ok(files);<EOL>    <EOL>    <EOL>    assert.strictEqual(files.size, <NUM_LIT>);<EOL>    assert.strictEqual(appView.pathsWritten.length, <NUM_LIT>);<EOL>    assert.strictEqual(files.has(DOCKERFILE_NAME), true);<EOL>    assert.strictEqual(files.has(DOCKERIGNORE_NAME), true);<EOL>    if (testConfig.expectedDockerfile) {<EOL>        testConfig.expectedDockerfile(files.get(","gt":"DOCKERFILE_NAME));"}
{"input":"<s> async function runTest(testConfig: TestConfig): Promise<void> {<EOL>    const appView: MockView = new MockView([]);<EOL>    const files: Map<string, string> = await generateFiles(appView, testConfig.config, BASE_IMAGE);<EOL>    assert.ok(files);<EOL>    <EOL>    <EOL>    assert.strictEqual(files.size, <NUM_LIT>);<EOL>    assert.strictEqual(appView.pathsWritten.length, <NUM_LIT>);<EOL>    assert.strictEqual(files.has(DOCKERFILE_NAME), true);<EOL>    assert.strictEqual(files.has(DOCKERIGNORE_NAME), true);<EOL>    if (testConfig.expectedDockerfile) {<EOL>        testConfig.expectedDockerfile(files.get(DOCKERFILE_NAME));<EOL>        assert(hasLocation(appView.pathsWritten, {<EOL>            path: '<STR_LIT>',<EOL>            exists:","gt":"true,"}
{"input":"<s> async function runTest(testConfig: TestConfig): Promise<void> {<EOL>    const appView: MockView = new MockView([]);<EOL>    const files: Map<string, string> = await generateFiles(appView, testConfig.config, BASE_IMAGE);<EOL>    assert.ok(files);<EOL>    <EOL>    <EOL>    assert.strictEqual(files.size, <NUM_LIT>);<EOL>    assert.strictEqual(appView.pathsWritten.length, <NUM_LIT>);<EOL>    assert.strictEqual(files.has(DOCKERFILE_NAME), true);<EOL>    assert.strictEqual(files.has(DOCKERIGNORE_NAME), true);<EOL>    if (testConfig.expectedDockerfile) {<EOL>        testConfig.expectedDockerfile(files.get(DOCKERFILE_NAME));<EOL>        assert(hasLocation(appView.pathsWritten, {<EOL>            path: '<STR_LIT>',<EOL>            exists: true,<EOL>            contents: testConfig.expectedDockerfile<EOL>        }));<EOL>    }<EOL>    if (testConfig.expectedDockerignore) {<EOL>        testConfig.expectedDockerignore(files.","gt":"get(DOCKERIGNORE_NAME));"}
{"input":"<s> function buildGenDockerfile(cb: RunCallback): void {<EOL>    const options: {<EOL>        cwd: any;<EOL>    } = {","gt":"cwd: GEN_DOCKERFILE_DIR };"}
{"input":"<s> async function testMediaBody(drive: APIEndpoint): Promise<void> {<EOL>    const resource: {<EOL>        title: string;<EOL>    } = { title: '<STR_LIT>' };<EOL>","gt":"const media: {"}
{"input":"<s> async function testMediaBody(drive: APIEndpoint): Promise<void> {<EOL>    const resource: {<EOL>        title: string;<EOL>    } = { title: '<STR_LIT>' };<EOL>    const media: {<EOL>        body: string;<EOL>    } = { body: '<STR_LIT>' };<EOL>","gt":"let expectedResp: any = fs.readFileSync(path.join(__dirname, '<STR_LIT>'), { encoding: '<STR_LIT>' });"}
{"input":"<s> async function testMediaBody(drive: APIEndpoint): Promise<void> {<EOL>    const resource: {<EOL>        title: string;<EOL>    } = { title: '<STR_LIT>' };<EOL>    const media: {<EOL>        body: string;<EOL>    } = { body: '<STR_LIT>' };<EOL>    let expectedResp: any = fs.readFileSync(path.join(__dirname, '<STR_LIT>'), { encoding: '<STR_LIT>' });<EOL>    const res: any = await pify(drive.files.insert)({ resource, media });<EOL>    assert.equal(res.config.method.toLowerCase(), '<STR_LIT>');<EOL>    assert.equal(res.config.maxContentLength, Math.pow(<NUM_LIT>, <NUM_LIT>));<EOL>    assert.equal(res.request.","gt":"path, '<STR_LIT>');"}
{"input":"<s> async function testMediaBody(drive: APIEndpoint): Promise<void> {<EOL>    const resource: {<EOL>        title: string;<EOL>    } = { title: '<STR_LIT>' };<EOL>    const media: {<EOL>        body: string;<EOL>    } = { body: '<STR_LIT>' };<EOL>    let expectedResp: any = fs.readFileSync(path.join(__dirname, '<STR_LIT>'), { encoding: '<STR_LIT>' });<EOL>    const res: any = await pify(drive.files.insert)({ resource, media });<EOL>    assert.equal(res.config.method.toLowerCase(), '<STR_LIT>');<EOL>    assert.equal(res.config.maxContentLength, Math.pow(<NUM_LIT>, <NUM_LIT>));<EOL>    assert.equal(res.request.path, '<STR_LIT>');<EOL>    assert.equal(res.request.headers['<STR_LIT>'].indexOf('<STR_LIT>'), <NUM_LIT>);<EOL>    const boundary: any = res.request.headers['<STR_LIT>'].replace(boundaryPrefix, '<STR_LIT>');<EOL>    expectedResp = expectedResp.replace(/\\n/g, '<STR_LIT>')<EOL>        .replace(/\\$boundary/g, boundary)<EOL>        .replace('<STR_LIT>',","gt":"media.body)"}
{"input":"<s> function createNock(path?: string): void {<EOL>    const p:","gt":"string = path ? path : '<STR_LIT>';"}
{"input":"<s> function testResponseError(drive: APIEndpoint, cb: (err?: Error) => void): void {<EOL>    drive.files.list({ q: '<STR_LIT>' }, (err: NodeJS.ErrnoException): void => {<EOL>        assert(err instanceof","gt":"Error);"}
{"input":"<s> async function isComputeEngine(): Promise<any> {<EOL>    return","gt":"gcpMetadata.isAvailable();"}
{"input":"<s> <EOL>function insertWellKnownFilePathIntoAuth(auth: GoogleAuth, filePath: string, mockFilePath: string): void {<EOL>    const originalMockWellKnownFilePathFunction: (filePath: string) => string = auth._mockWellKnownFilePath;<EOL>    auth._mockWellKnownFilePath = (kfpath: string): string => {<EOL>","gt":"if (kfpath === filePath) {"}
{"input":"<s> <EOL>function mockEnvVar(name: string, value: string = '<STR_LIT>'): any {<EOL>    if (!sandbox) {<EOL>        sandbox = sinon.","gt":"createSandbox();"}
{"input":"<s> function nock404GCE(): any {<EOL>    return nock(host).get(instancePath).","gt":"reply(<NUM_LIT>);"}
{"input":"<s> <EOL>function pathJoin(item1: string, item2: string): string {<EOL>    return item1 + '<STR_LIT>' +","gt":"item2;"}
{"input":"<s> export function validateLayoutName(obj: any): string {<EOL>","gt":"getLayoutByName(obj);"}
{"input":"<s> export function decodeManifestChunk(chunk: ManifestChunk, response: any): void {<EOL>    return decodeJsonManifestChunk(chunk, response,","gt":"'<STR_LIT>');"}
{"input":"<s> export function decodeFragmentChunk(chunk: FragmentChunk, response: ArrayBuffer): void {<EOL>    let dv: DataView = new","gt":"DataView(response);"}
{"input":"<s> function getPointMatches(chunk: VectorGraphicsChunk, sectionIds: string[], parameters: PointMatchChunkSourceParameters, cancellationToken: CancellationToken): Promise<void> {<EOL>    let path: string;<EOL>    if (sectionIds.length === <NUM_LIT>) {<EOL>        path = `<STR_LIT>` +<EOL>            `<STR_LIT>`;<EOL>    }<EOL>    else if (sectionIds.length === <NUM_LIT>) {<EOL>        path = `<STR_LIT>` +<EOL>            `<STR_LIT>`;<EOL>    }<EOL>    else {<EOL>        throw new Error(`<STR_LIT>`);<EOL>    }<EOL>","gt":"return sendHttpRequest(openShardedHttpRequest(parameters.baseUrls, path), '<STR_LIT>', cancellationToken)"}
{"input":"<s> export function makeRenderedPanelVisibleLayerTracker<RenderLayerType extends VisibilityTrackedRenderLayer>(layerManager: LayerManager, renderLayerType: {<EOL>    new (...args: any[]): RenderLayerType;<EOL>}, panel: RenderedPanel): VisibleRenderLayerTracker<RenderLayerType> {<EOL>    return panel.registerDisposer(new VisibleRenderLayerTracker(layerManager, renderLayerType, (layer: RenderLayerType): () => void => {<EOL>        const disposer: () => boolean = layer.redrawNeeded.add((): void => panel.scheduleRedraw());<EOL>","gt":"panel.scheduleRedraw();"}
{"input":"<s> <EOL>function parseSwc(swcStr: string): PointObj[] {<EOL>    <EOL>    let swcInputAr: string[] = swcStr.split('<STR_LIT>');<EOL>    let swcObjectsAr: Array<PointObj> = new Array();<EOL>    let float: string = '<STR_LIT>';<EOL>    let pattern: RegExp = new RegExp('<STR_LIT>' + [<EOL>","gt":"'<STR_LIT>',"}
{"input":"<s> <EOL>function parseSwc(swcStr: string): PointObj[] {<EOL>    <EOL>    let swcInputAr: string[] = swcStr.split('<STR_LIT>');<EOL>    let swcObjectsAr: Array<PointObj> = new Array();<EOL>    let float: string = '<STR_LIT>';<EOL>    let pattern: RegExp = new RegExp('<STR_LIT>' + [<EOL>        '<STR_LIT>',<EOL>        '<STR_LIT>',<EOL>        float,<EOL>","gt":"float,"}
{"input":"<s> <EOL>function parseSwc(swcStr: string): PointObj[] {<EOL>    <EOL>    let swcInputAr: string[] = swcStr.split('<STR_LIT>');<EOL>    let swcObjectsAr: Array<PointObj> = new Array();<EOL>    let float: string = '<STR_LIT>';<EOL>    let pattern: RegExp = new RegExp('<STR_LIT>' + [<EOL>        '<STR_LIT>',<EOL>        '<STR_LIT>',<EOL>        float,<EOL>        float,<EOL>        float,<EOL>        float,<EOL>","gt":"'<STR_LIT>'"}
{"input":"<s> <EOL>function parseSwc(swcStr: string): PointObj[] {<EOL>    <EOL>    let swcInputAr: string[] = swcStr.split('<STR_LIT>');<EOL>    let swcObjectsAr: Array<PointObj> = new Array();<EOL>    let float: string = '<STR_LIT>';<EOL>    let pattern: RegExp = new RegExp('<STR_LIT>' + [<EOL>        '<STR_LIT>',<EOL>        '<STR_LIT>',<EOL>        float,<EOL>        float,<EOL>        float,<EOL>        float,<EOL>        '<STR_LIT>' <EOL>    ].join('<STR_LIT>') + '<STR_LIT>');<EOL>    swcInputAr.forEach(function (e) {<EOL>        <EOL>        <EOL>        let match: RegExpMatchArray | null = e.match(pattern);<EOL>        if (match) {<EOL>            let point: PointObj = swcObjectsAr[parseInt(match[<NUM_LIT>], <NUM_LIT>) - <NUM_LIT>] = new PointObj();<EOL>            point.type = parseInt(match[<NUM_LIT>], <NUM_LIT>);<EOL>            point.x = parseFloat(match[<NUM_LIT>]);<EOL>","gt":"point.y = parseFloat(match[<NUM_LIT>]);"}
{"input":"<s> export function updateLayerDropEffect(event: DragEvent, manager: Borrowed<LayerListSpecification>, newTarget = false): '<STR_LIT>' | '<STR_LIT>' | '<STR_LIT>' {<EOL>    return setDropEffect(event, getLayerDropEffect(event, manager,","gt":"newTarget));"}
{"input":"<s> <EOL>export function maybePadArray<T extends TypedArray>(array: T, newSize: number): T {<EOL>    if (array.length === newSize) {<EOL>","gt":"return array;"}
{"input":"<s> export function verifyFloat01(obj: any): number {<EOL>    if (typeof obj !== '<STR_LIT>' || !Number.isFinite(obj) || obj < <NUM_LIT> || obj > <NUM_LIT>) {<EOL>        throw new Error(","gt":"stringify(obj)}.`<STR_LIT>;"}
{"input":"<s> export function verifyObjectProperty<T>(obj: any, propertyName: string, validator: (value: any) => T): T {<EOL>    let value: any = obj.hasOwnProperty(propertyName) ? obj[propertyName] : undefined;<EOL>    try {<EOL>","gt":"return validator(value);"}
{"input":"<s> export function setVec4FromUint32(out: Float32Array, x: number): Float32Array {<EOL>    for (let j: number = <NUM_LIT>; j < <NUM_LIT>; ++j) {<EOL>        out[j] = ((x >> (j *","gt":"<NUM_LIT>)) & <NUM_LIT>) / <NUM_LIT>;"}
{"input":"<s> export function manageDashboardsDirective(): {<EOL>    restrict: string;<EOL>    templateUrl: string;<EOL>    controller: typeof ManageDashboardsCtrl;<EOL>    bindToController: boolean;<EOL>    controllerAs: string;<EOL>    scope: {<EOL>        folderId: string;<EOL>        folderUid: string;<EOL>    };<EOL>} {<EOL>    return {<EOL>        restrict: '<STR_LIT>',<EOL>        templateUrl: '<STR_LIT>',<EOL>        controller:","gt":"ManageDashboardsCtrl,"}
{"input":"<s> export function manageDashboardsDirective(): {<EOL>    restrict: string;<EOL>    templateUrl: string;<EOL>    controller: typeof ManageDashboardsCtrl;<EOL>    bindToController: boolean;<EOL>    controllerAs: string;<EOL>    scope: {<EOL>        folderId: string;<EOL>        folderUid: string;<EOL>    };<EOL>} {<EOL>    return {<EOL>        restrict: '<STR_LIT>',<EOL>        templateUrl: '<STR_LIT>',<EOL>        controller: ManageDashboardsCtrl,<EOL>        bindToController: true,<EOL>        controllerAs: '<STR_LIT>',<EOL>        scope: {<EOL>            folderId: '<STR_LIT>',<EOL>            folderUid:","gt":"'<STR_LIT>',"}
{"input":"<s> <EOL>function applied(fn: any, scope: any): any {<EOL>    if (fn.wrappedInApply) {<EOL>        return fn;<EOL>    }<EOL>    var wrapped: any = function () {<EOL>        var args: IArguments = arguments;<EOL>        var phase:","gt":"any = scope.$root.$$phase;"}
{"input":"<s> <EOL>function applied(fn: any, scope: any): any {<EOL>    if (fn.wrappedInApply) {<EOL>        return fn;<EOL>    }<EOL>    var wrapped: any = function () {<EOL>        var args: IArguments = arguments;<EOL>        var phase: any = scope.$root.$$phase;<EOL>        if (phase === '<STR_LIT>' || phase === '<STR_LIT>') {<EOL>            return fn.apply(null, args);<EOL>        }<EOL>","gt":"else {"}
{"input":"<s> <EOL>function watchProps(watchDepth: any, scope: any, watchExpressions: any, listener: any): void {<EOL>    var supportsWatchCollection: any = angular.isFunction(scope.$watchCollection);<EOL>    var supportsWatchGroup: any = angular.isFunction(scope.$watchGroup);<EOL>    var watchGroupExpressions: any[] = [];<EOL>    watchExpressions.forEach(function (expr) {<EOL>        var","gt":"actualExpr: any = getPropExpression(expr);"}
{"input":"<s> <EOL>function watchProps(watchDepth: any, scope: any, watchExpressions: any, listener: any): void {<EOL>    var supportsWatchCollection: any = angular.isFunction(scope.$watchCollection);<EOL>    var supportsWatchGroup: any = angular.isFunction(scope.$watchGroup);<EOL>    var watchGroupExpressions: any[] = [];<EOL>    watchExpressions.forEach(function (expr) {<EOL>        var actualExpr: any = getPropExpression(expr);<EOL>        var exprWatchDepth: any = getPropWatchDepth(watchDepth, expr);<EOL>        if (exprWatchDepth === '<STR_LIT>' && supportsWatchCollection) {<EOL>            scope.$watchCollection(actualExpr,","gt":"listener);"}
{"input":"<s> <EOL>function watchProps(watchDepth: any, scope: any, watchExpressions: any, listener: any): void {<EOL>    var supportsWatchCollection: any = angular.isFunction(scope.$watchCollection);<EOL>    var supportsWatchGroup: any = angular.isFunction(scope.$watchGroup);<EOL>    var watchGroupExpressions: any[] = [];<EOL>    watchExpressions.forEach(function (expr) {<EOL>        var actualExpr: any = getPropExpression(expr);<EOL>        var exprWatchDepth: any = getPropWatchDepth(watchDepth, expr);<EOL>        if (exprWatchDepth === '<STR_LIT>' && supportsWatchCollection) {<EOL>            scope.$watchCollection(actualExpr, listener);<EOL>        }<EOL>        else if (exprWatchDepth === '<STR_LIT>' && supportsWatchGroup) {<EOL>            watchGroupExpressions.push(","gt":"actualExpr);"}
{"input":"<s> function describeValueFormat(desc: any, value: any, tickSize: any, tickDecimals: any, result: any): void {<EOL>    describe('<STR_LIT>' + desc, function () {<EOL>        it('<STR_LIT>' + value + '<STR_LIT>' + result, function () {<EOL>            var scaledDecimals: number = tickDecimals - Math.floor(Math.","gt":"log(tickSize) / Math.LN10);"}
{"input":"<s> export function getScaledDecimals(decimals: any, tick_size: any): number {<EOL>    return decimals - Math.","gt":"floor(Math.log(tick_size) / Math.LN10);"}
{"input":"<s> export function rowOptionsDirective(): {<EOL>    restrict: string;<EOL>    templateUrl: string;<EOL>    controller: typeof RowOptionsCtrl;<EOL>    bindToController: boolean;<EOL>    controllerAs: string;<EOL>    scope: {<EOL>        row: string;<EOL>        dismiss: string;<EOL>        onUpdated: string;<EOL>    };<EOL>} {<EOL>    return {<EOL>        restrict: '<STR_LIT>',<EOL>        templateUrl: '<STR_LIT>',<EOL>","gt":"controller: RowOptionsCtrl,"}
{"input":"<s> export function rowOptionsDirective(): {<EOL>    restrict: string;<EOL>    templateUrl: string;<EOL>    controller: typeof RowOptionsCtrl;<EOL>    bindToController: boolean;<EOL>    controllerAs: string;<EOL>    scope: {<EOL>        row: string;<EOL>        dismiss: string;<EOL>        onUpdated: string;<EOL>    };<EOL>} {<EOL>    return {<EOL>        restrict: '<STR_LIT>',<EOL>        templateUrl: '<STR_LIT>',<EOL>        controller: RowOptionsCtrl,<EOL>        bindToController: true,<EOL>        controllerAs: '<STR_LIT>',<EOL>        scope: {<EOL>            row: '<STR_LIT>',<EOL>            dismiss: '<STR_LIT>',<EOL>            onUpdated:","gt":"'<STR_LIT>',"}
{"input":"<s> function panelLinksEditor(): {<EOL>    scope: {<EOL>        panel: string;<EOL>    };<EOL>    restrict: string;<EOL>    controller: string;<EOL>    templateUrl: string;<EOL>    link: () => void;<EOL>} {<EOL>    return {<EOL>        scope: {<EOL>            panel:","gt":"'<STR_LIT>',"}
{"input":"<s> function getNoneOption(): {<EOL>    text: string;<EOL>    value: string;<EOL>    isNone: boolean;<EOL>} {<EOL>    return { text: '<STR_LIT>', value: '<STR_LIT>',","gt":"isNone: true };"}
{"input":"<s> function supportsTags(version: string): boolean {<EOL>    return","gt":"isVersionGtOrEq(version, '<STR_LIT>');"}
{"input":"<s> function addTransformationStrategy(selectParts: any, partModel: any): void {<EOL>    var i: any;<EOL>    <EOL>    for (i =","gt":"<NUM_LIT>; i < selectParts.length; i++) {"}
{"input":"<s> function convertToLogScaleValueBuckets(xBucket: any, yBucketSplitFactor: any, logBase: any): {} {<EOL>    let values: any = xBucket.values;<EOL>    let points: any = xBucket.points;<EOL>    let buckets: {} = {};<EOL>    _.forEach(values, (","gt":"val: any, index: any): void => {"}
{"input":"<s> function convertToLogScaleValueBuckets(xBucket: any, yBucketSplitFactor: any, logBase: any): {} {<EOL>    let values: any = xBucket.values;<EOL>    let points: any = xBucket.points;<EOL>    let buckets: {} = {};<EOL>    _.forEach(values, (val: any, index: any): void => {<EOL>        let bounds: {<EOL>            bottom: any;<EOL>            top: any;<EOL>        } = getLogScaleBucketBounds(val, yBucketSplitFactor, logBase);<EOL>        let bucketNum: any = bounds.bottom;<EOL>        pushToYBuckets(buckets,","gt":"bucketNum, val, points[index], bounds);"}
{"input":"<s> function formatTime(timeStr: any): any {<EOL>    let format:","gt":"string = '<STR_LIT>';"}
{"input":"<s> export function indexImpl<TItem>(i: number): Prism<TItem[], TItem> {<EOL>    if (i < <NUM_LIT>)<EOL>        throw new TypeError(`<STR_LIT>`);<EOL>    return Prism.create((xs: TItem[]): Option<TItem> => xs[i] as Option<TItem>, (v: TItem, xs: TItem[]): TItem[] => {<EOL>        if (xs.","gt":"length <= i) {"}
{"input":"<s> export function indexImpl<TItem>(i: number): Prism<TItem[], TItem> {<EOL>    if (i < <NUM_LIT>)<EOL>        throw new TypeError(`<STR_LIT>`);<EOL>    return Prism.create((xs: TItem[]): Option<TItem> => xs[i] as Option<TItem>, (v: TItem, xs: TItem[]): TItem[] => {<EOL>        if (xs.length <= i) {<EOL>            return xs.concat(Array(i - xs.length), [v]);<EOL>        }<EOL>        else if (structEq(v, xs[i])) {<EOL>            return xs;<EOL>        }<EOL>","gt":"else {"}
{"input":"<s> <EOL>function combineTemplate(template: {<EOL>    [key: string]: ObservableInput<any>;<EOL>}): Observable<{<EOL>    [key: string]: any;<EOL>}> {<EOL>    const keys: string[] = [];<EOL>    const values: ObservableInput<any>[] = [];<EOL>    for (const k: string in template) {<EOL>        keys.push(k);<EOL>        values.push(template[k]);<EOL>    }<EOL>    return Observable.combineLatest(values, (...vs: any[]): {<EOL>        [key: string]: any;<EOL>    } => {<EOL>","gt":"const r: {"}
{"input":"<s> <EOL>function combineTemplate(template: {<EOL>    [key: string]: ObservableInput<any>;<EOL>}): Observable<{<EOL>    [key: string]: any;<EOL>}> {<EOL>    const keys: string[] = [];<EOL>    const values: ObservableInput<any>[] = [];<EOL>    for (const k: string in template) {<EOL>        keys.push(k);<EOL>        values.push(template[k]);<EOL>    }<EOL>    return Observable.combineLatest(values, (...vs: any[]): {<EOL>        [key: string]: any;<EOL>    } => {<EOL>        const r: {<EOL>            [key: string]: any;<EOL>        } = {};<EOL>        for (let","gt":"i: number = <NUM_LIT>; i < keys.length; i++) {"}
{"input":"<s> export async function getAllCookies(client: Client): Promise<any> {<EOL>    const {","gt":"Network } = client;"}
{"input":"<s> export async function nodeExists(client: Client, selector: string): Promise<boolean> {<EOL>    const { Runtime } = client;<EOL>    const exists: string = `<STR_LIT>`;<EOL>","gt":"const expression: string = `<STR_LIT>`;"}
{"input":"<s> <EOL>export function getSourceFiles(rootFileNames: string[], options: ts.CompilerOptions): string[] {<EOL>    const program: any = ts.createProgram(rootFileNames, options);<EOL>    const programmFiles: any = program.getSourceFiles()<EOL>        .map((file: any): any =>","gt":"file.fileName)"}
{"input":"<s> export function getZipInfo(boilerplate: string): ZipInfo {<EOL>    let baseUrl: string = boilerplate;<EOL>    let branch: string = '<STR_LIT>';<EOL>    let subDir: string = '<STR_LIT>';<EOL>    const branchMatches: RegExpMatchArray | null = boilerplate.match(/^(.*)\\/tree\\/([a-zA-Z-_0-9]*)\\/?(.*)$/);<EOL>","gt":"if (branchMatches) {"}
{"input":"<s> export function getZipInfo(boilerplate: string): ZipInfo {<EOL>    let baseUrl: string = boilerplate;<EOL>    let branch: string = '<STR_LIT>';<EOL>    let subDir: string = '<STR_LIT>';<EOL>    const branchMatches: RegExpMatchArray | null = boilerplate.match(/^(.*)\\/tree\\/([a-zA-Z-_0-9]*)\\/?(.*)$/);<EOL>    if (branchMatches) {<EOL>        baseUrl = branchMatches[<NUM_LIT>];<EOL>        branch = branchMatches[<NUM_LIT>];<EOL>","gt":"subDir = branchMatches[<NUM_LIT>];"}
{"input":"<s> export function getZipInfo(boilerplate: string): ZipInfo {<EOL>    let baseUrl: string = boilerplate;<EOL>    let branch: string = '<STR_LIT>';<EOL>    let subDir: string = '<STR_LIT>';<EOL>    const branchMatches: RegExpMatchArray | null = boilerplate.match(/^(.*)\\/tree\\/([a-zA-Z-_0-9]*)\\/?(.*)$/);<EOL>    if (branchMatches) {<EOL>        baseUrl = branchMatches[<NUM_LIT>];<EOL>        branch = branchMatches[<NUM_LIT>];<EOL>        subDir = branchMatches[<NUM_LIT>];<EOL>    }<EOL>    if (subDir === undefined) {<EOL>        subDir = '<STR_LIT>';<EOL>    }<EOL>    if (!subDir.startsWith(","gt":"'<STR_LIT>')) {"}
{"input":"<s> <EOL>export function main(): Promise<any> {<EOL>    return platformBrowserDynamic()<EOL>        .","gt":"bootstrapModule(AppModule)"}
{"input":"<s> export function applyDefaultsToBaseOptions(options: IBaseOptions): void {<EOL>    if (!options.hasOwnProperty(\"<STR_LIT>\")) {<EOL>","gt":"options.autoOrient = true;"}
{"input":"<s> <EOL><EOL><EOL>export default function HaikuDOMAdapter(bytecode: any, config: any, safeWindow: any): {<EOL>    (mount: any, haikuConfigFromFactory: any): any;<EOL>    PLAYER_VERSION: any;<EOL>    CORE_VERSION: any;<EOL>} {<EOL>    if (!config) {<EOL>        <EOL>        config = {};<EOL>    }<EOL>    if (!config.options) {<EOL>        config.options = {};<EOL>    }<EOL>    if (!safeWindow) {<EOL>        if (typeof window !== '<STR_LIT>') {<EOL>            <EOL>            safeWindow = window;<EOL>        }<EOL>    }<EOL>    if (config.options.useWebkitPrefix === undefined) {<EOL>        <EOL>        if (safeWindow && safeWindow.","gt":"document) {"}
{"input":"<s> function bindEventHandler(component: any, eventHandlerDescriptor: any, selector: any, eventName: any): void {<EOL>    <EOL>    <EOL>    if (eventHandlerDescriptor.original) {<EOL>        eventHandlerDescriptor.handler = eventHandlerDescriptor.original;<EOL>    }<EOL>    eventHandlerDescriptor.original = eventHandlerDescriptor.handler;<EOL>    eventHandlerDescriptor.handler = function _wrappedEventHandler(event, ...args) {<EOL>        <EOL>        <EOL>        if (isPreviewMode(component.config.options.interactionMode)) {<EOL>            component.","gt":"_anyEventChange = true;"}
{"input":"<s> <EOL>export default function clone(thing: any): any {<EOL>    if (Array.isArray(thing)) {<EOL>        const arr: any[] = [];<EOL>        for (let i: number = <NUM_LIT>; i < thing.length; i++) {<EOL>            arr[i] = clone(thing[i]);<EOL>        }<EOL>        return arr;<EOL>    }<EOL>    if (thing && typeof thing === '<STR_LIT>') {<EOL>","gt":"const obj: {} = {};"}
{"input":"<s> function pointsToPath(pointsArray: any): any {<EOL>    return","gt":"svgPoints.toPath(pointsArray);"}
{"input":"<s> <EOL>export default function computeOrientationFlexibly(xIn: any, yIn: any, zIn: any, w: any, quat: any): {<EOL>    x: number;<EOL>    y: number;<EOL>    z: number;<EOL>    w: number;<EOL>} {<EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    if (!quat ||<EOL>        (","gt":"quat.x == null || quat.y == null || quat.z == null || quat.w == null)) {"}
{"input":"<s> <EOL>export default function computeOrientationFlexibly(xIn: any, yIn: any, zIn: any, w: any, quat: any): {<EOL>    x: number;<EOL>    y: number;<EOL>    z: number;<EOL>    w: number;<EOL>} {<EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    if (!quat ||<EOL>        (quat.x == null || quat.y == null || quat.z == null || quat.w == null)) {<EOL>        throw new Error(","gt":"'<STR_LIT>');"}
{"input":"<s> <EOL>export default function computeOrientationFlexibly(xIn: any, yIn: any, zIn: any, w: any, quat: any): {<EOL>    x: number;<EOL>    y: number;<EOL>    z: number;<EOL>    w: number;<EOL>} {<EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    if (!quat ||<EOL>        (quat.x == null || quat.y == null || quat.z == null || quat.w == null)) {<EOL>        throw new Error('<STR_LIT>');<EOL>    }<EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    let x: any = xIn;<EOL>    let y: any = yIn;<EOL>    let z: any = zIn;<EOL>    if (x == null || y == null || z == null) {<EOL>        const sp: number = -<NUM_LIT> * (quat.y * quat.z - quat.w * quat.x);<EOL>        if (","gt":"Math.abs(sp) > <NUM_LIT>) {"}
{"input":"<s> <EOL>export default function computeOrientationFlexibly(xIn: any, yIn: any, zIn: any, w: any, quat: any): {<EOL>    x: number;<EOL>    y: number;<EOL>    z: number;<EOL>    w: number;<EOL>} {<EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    if (!quat ||<EOL>        (quat.x == null || quat.y == null || quat.z == null || quat.w == null)) {<EOL>        throw new Error('<STR_LIT>');<EOL>    }<EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    let x: any = xIn;<EOL>    let y: any = yIn;<EOL>    let z: any = zIn;<EOL>    if (x == null || y == null || z == null) {<EOL>        const sp: number = -<NUM_LIT> * (quat.y * quat.z - quat.w * quat.x);<EOL>        if (Math.abs(sp) > <NUM_LIT>) {<EOL>            y = y == null ? Math.PI * <NUM_LIT> * sp : y;<EOL>            x = x == null<EOL>                ? Math.atan2(-quat.x * quat.z + quat.w * quat.y, <NUM_LIT> - quat.y * quat.y - quat.z * quat.z)<EOL>                : x;<EOL>            z = z == null ? <NUM_LIT> : z;<EOL>        }<EOL>        else {<EOL>            y = y == null ? Math.asin(","gt":"sp) : y;"}
{"input":"<s> <EOL>export default function computeOrientationFlexibly(xIn: any, yIn: any, zIn: any, w: any, quat: any): {<EOL>    x: number;<EOL>    y: number;<EOL>    z: number;<EOL>    w: number;<EOL>} {<EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    if (!quat ||<EOL>        (quat.x == null || quat.y == null || quat.z == null || quat.w == null)) {<EOL>        throw new Error('<STR_LIT>');<EOL>    }<EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    let x: any = xIn;<EOL>    let y: any = yIn;<EOL>    let z: any = zIn;<EOL>    if (x == null || y == null || z == null) {<EOL>        const sp: number = -<NUM_LIT> * (quat.y * quat.z - quat.w * quat.x);<EOL>        if (Math.abs(sp) > <NUM_LIT>) {<EOL>            y = y == null ? Math.PI * <NUM_LIT> * sp : y;<EOL>            x = x == null<EOL>                ? Math.atan2(-quat.x * quat.z + quat.w * quat.y, <NUM_LIT> - quat.y * quat.y - quat.z * quat.z)<EOL>                : x;<EOL>            z = z == null ? <NUM_LIT> : z;<EOL>        }<EOL>        else {<EOL>            y = y == null ? Math.asin(sp) : y;<EOL>            x = x == null<EOL>                ? Math.atan2(quat.x * quat.z + quat.w * quat.y, <NUM_LIT> - quat.x * quat.x - quat.y * quat.y)<EOL>                : x;<EOL>            z = z == null<EOL>                ? Math.atan2(quat.x * quat.y + quat.w * quat.z, <NUM_LIT> - quat.x * quat.x - quat.z * quat.z)<EOL>                : z;<EOL>        }<EOL>    }<EOL>    const hx: number = x * <NUM_LIT>;<EOL>    const hy: number = y * <NUM_LIT>;<EOL>    const hz: number = z * <NUM_LIT>;<EOL>    const","gt":"sx: number = Math.sin(hx);"}
{"input":"<s> <EOL>export default function computeOrientationFlexibly(xIn: any, yIn: any, zIn: any, w: any, quat: any): {<EOL>    x: number;<EOL>    y: number;<EOL>    z: number;<EOL>    w: number;<EOL>} {<EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    if (!quat ||<EOL>        (quat.x == null || quat.y == null || quat.z == null || quat.w == null)) {<EOL>        throw new Error('<STR_LIT>');<EOL>    }<EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    let x: any = xIn;<EOL>    let y: any = yIn;<EOL>    let z: any = zIn;<EOL>    if (x == null || y == null || z == null) {<EOL>        const sp: number = -<NUM_LIT> * (quat.y * quat.z - quat.w * quat.x);<EOL>        if (Math.abs(sp) > <NUM_LIT>) {<EOL>            y = y == null ? Math.PI * <NUM_LIT> * sp : y;<EOL>            x = x == null<EOL>                ? Math.atan2(-quat.x * quat.z + quat.w * quat.y, <NUM_LIT> - quat.y * quat.y - quat.z * quat.z)<EOL>                : x;<EOL>            z = z == null ? <NUM_LIT> : z;<EOL>        }<EOL>        else {<EOL>            y = y == null ? Math.asin(sp) : y;<EOL>            x = x == null<EOL>                ? Math.atan2(quat.x * quat.z + quat.w * quat.y, <NUM_LIT> - quat.x * quat.x - quat.y * quat.y)<EOL>                : x;<EOL>            z = z == null<EOL>                ? Math.atan2(quat.x * quat.y + quat.w * quat.z, <NUM_LIT> - quat.x * quat.x - quat.z * quat.z)<EOL>                : z;<EOL>        }<EOL>    }<EOL>    const hx: number = x * <NUM_LIT>;<EOL>    const hy: number = y * <NUM_LIT>;<EOL>    const hz: number = z * <NUM_LIT>;<EOL>    const sx: number = Math.sin(hx);<EOL>    const sy: number = Math.sin(hy);<EOL>    const sz: number = Math.sin(hz);<EOL>    const cx: number = Math.cos(hx);<EOL>    const cy: number = Math.cos(","gt":"hy);"}
{"input":"<s> <EOL>export default function computeOrientationFlexibly(xIn: any, yIn: any, zIn: any, w: any, quat: any): {<EOL>    x: number;<EOL>    y: number;<EOL>    z: number;<EOL>    w: number;<EOL>} {<EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    if (!quat ||<EOL>        (quat.x == null || quat.y == null || quat.z == null || quat.w == null)) {<EOL>        throw new Error('<STR_LIT>');<EOL>    }<EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    let x: any = xIn;<EOL>    let y: any = yIn;<EOL>    let z: any = zIn;<EOL>    if (x == null || y == null || z == null) {<EOL>        const sp: number = -<NUM_LIT> * (quat.y * quat.z - quat.w * quat.x);<EOL>        if (Math.abs(sp) > <NUM_LIT>) {<EOL>            y = y == null ? Math.PI * <NUM_LIT> * sp : y;<EOL>            x = x == null<EOL>                ? Math.atan2(-quat.x * quat.z + quat.w * quat.y, <NUM_LIT> - quat.y * quat.y - quat.z * quat.z)<EOL>                : x;<EOL>            z = z == null ? <NUM_LIT> : z;<EOL>        }<EOL>        else {<EOL>            y = y == null ? Math.asin(sp) : y;<EOL>            x = x == null<EOL>                ? Math.atan2(quat.x * quat.z + quat.w * quat.y, <NUM_LIT> - quat.x * quat.x - quat.y * quat.y)<EOL>                : x;<EOL>            z = z == null<EOL>                ? Math.atan2(quat.x * quat.y + quat.w * quat.z, <NUM_LIT> - quat.x * quat.x - quat.z * quat.z)<EOL>                : z;<EOL>        }<EOL>    }<EOL>    const hx: number = x * <NUM_LIT>;<EOL>    const hy: number = y * <NUM_LIT>;<EOL>    const hz: number = z * <NUM_LIT>;<EOL>    const sx: number = Math.sin(hx);<EOL>    const sy: number = Math.sin(hy);<EOL>    const sz: number = Math.sin(hz);<EOL>    const cx: number = Math.cos(hx);<EOL>    const cy: number = Math.cos(hy);<EOL>    const cz: number = Math.cos(hz);<EOL>    const sysz: number = sy * sz;<EOL>","gt":"const cysz: number = cy * sz;"}
{"input":"<s> export default function setStyleMatrix(styleObject: any, format: any, matrix: any, usePrefix: any, devicePixelRatio: any): any {<EOL>    const matrixString: any = formatTransform(matrix, format, devicePixelRatio);<EOL>    if (usePrefix) {<EOL>        if (!isEqualTransformString(styleObject.webkitTransform, matrixString)) {<EOL>            styleObject.webkitTransform =","gt":"matrixString;"}
{"input":"<s> function warnOnce(warning: any): any {<EOL>    if (warnings[warning]) {<EOL>        return","gt":"void <NUM_LIT>;"}
{"input":"<s> <EOL>export default function assignClass(domElement: any, className: any): any {<EOL>    if (domElement.className !== className) {<EOL>        domElement.setAttribute(","gt":"'<STR_LIT>', className);"}
{"input":"<s> export default function replaceElement(domElement: any, virtualElement: any, parentDomNode: any, parentVirtualElement: any, component: any): any {<EOL>    const flexId: any = getFlexId(virtualElement);<EOL>    if (component.cache[flexId]) {<EOL>        component.cache[flexId] = {};<EOL>    }<EOL>    const newElement: any = isTextNode(virtualElement)<EOL>        ? createTextNode(domElement, virtualElement)<EOL>        : createTagNode(domElement, virtualElement, parentVirtualElement, component);<EOL>    applyLayout(newElement, virtualElement, parentDomNode,","gt":"parentVirtualElement, component, null);"}
{"input":"<s> <EOL>export default function scale(out: any, a: any, v: any): any {<EOL>    const x: any = v[<NUM_LIT>];<EOL>    const y: any = v[<NUM_LIT>];<EOL>    const z: any = v[<NUM_LIT>];<EOL>","gt":"out[<NUM_LIT>] = a[<NUM_LIT>] * x;"}
{"input":"<s> <EOL>export default function scale(out: any, a: any, v: any): any {<EOL>    const x: any = v[<NUM_LIT>];<EOL>    const y: any = v[<NUM_LIT>];<EOL>    const z: any = v[<NUM_LIT>];<EOL>    out[<NUM_LIT>] = a[<NUM_LIT>] * x;<EOL>    out[<NUM_LIT>] = a[<NUM_LIT>] * x;<EOL>    out[<NUM_LIT>] = a[<NUM_LIT>] * x;<EOL>    out[","gt":"<NUM_LIT>] = a[<NUM_LIT>] * x;"}
{"input":"<s> <EOL>export default function scale(out: any, a: any, v: any): any {<EOL>    const x: any = v[<NUM_LIT>];<EOL>    const y: any = v[<NUM_LIT>];<EOL>    const z: any = v[<NUM_LIT>];<EOL>    out[<NUM_LIT>] = a[<NUM_LIT>] * x;<EOL>    out[<NUM_LIT>] = a[<NUM_LIT>] * x;<EOL>    out[<NUM_LIT>] = a[<NUM_LIT>] * x;<EOL>    out[<NUM_LIT>] = a[<NUM_LIT>] * x;<EOL>    out[<NUM_LIT>] = a[<NUM_LIT>] * y;<EOL>    out[<NUM_LIT>] = a[<NUM_LIT>] * y;<EOL>    out[<NUM_LIT>] = a[<NUM_LIT>] * y;<EOL>    out[<NUM_LIT>] = a[<NUM_LIT>] *","gt":"y;"}
{"input":"<s> <EOL>export default function scale(out: any, a: any, v: any): any {<EOL>    const x: any = v[<NUM_LIT>];<EOL>    const y: any = v[<NUM_LIT>];<EOL>    const z: any = v[<NUM_LIT>];<EOL>    out[<NUM_LIT>] = a[<NUM_LIT>] * x;<EOL>    out[<NUM_LIT>] = a[<NUM_LIT>] * x;<EOL>    out[<NUM_LIT>] = a[<NUM_LIT>] * x;<EOL>    out[<NUM_LIT>] = a[<NUM_LIT>] * x;<EOL>    out[<NUM_LIT>] = a[<NUM_LIT>] * y;<EOL>    out[<NUM_LIT>] = a[<NUM_LIT>] * y;<EOL>    out[<NUM_LIT>] = a[<NUM_LIT>] * y;<EOL>    out[<NUM_LIT>] = a[<NUM_LIT>] * y;<EOL>    out[<NUM_LIT>] = a[<NUM_LIT>] * z;<EOL>    out[<NUM_LIT>] = a[<NUM_LIT>] * z;<EOL>    out[<NUM_LIT>] = a[<NUM_LIT>] * z;<EOL>    out[<NUM_LIT>] = a[<NUM_LIT>] * z;<EOL>    out[","gt":"<NUM_LIT>] = a[<NUM_LIT>];"}
{"input":"<s> <EOL>export function addFilter(accountId: number, area: string, filter: string | number): {<EOL>    type: string;<EOL>    accountId: number;<EOL>    area: string;<EOL>    filter: string | number;<EOL>} {<EOL>    return {<EOL>        type: ActionConstants.","gt":"notificationFilter.ADD_FILTER,"}
{"input":"<s> export function setReasonFilter(accountId: number, repoId: string, filterName: string, enabled: boolean): {<EOL>    type: string;<EOL>    accountId: number;<EOL>    repoId: string;<EOL>    filterName: string;<EOL>    enabled: boolean;<EOL>} {<EOL>    return {<EOL>        type: ActionConstants.repositoryMuteFilters.SET_REASON_FILTER,<EOL>","gt":"accountId,"}
{"input":"<s> export default function createMenu(accountId: number): Electron.Menu {<EOL>    let menu: Electron.Menu = getNewRemoteElectronMenu();<EOL>    <EOL>    menu.append(getNewRemoteElectronMenuItem({<EOL>        label: '<STR_LIT>',<EOL>        click: (): any => dispatch(updateAccount(accountId.","gt":"toString(), true))"}
{"input":"<s> export default function createMenu(accountId: number): Electron.Menu {<EOL>    let menu: Electron.Menu = getNewRemoteElectronMenu();<EOL>    <EOL>    menu.append(getNewRemoteElectronMenuItem({<EOL>        label: '<STR_LIT>',<EOL>        click: (): any => dispatch(updateAccount(accountId.toString(), true))<EOL>    }));<EOL>    <EOL>    menu.append(getNewRemoteElectronMenuItem({<EOL>","gt":"type: '<STR_LIT>'"}
{"input":"<s> export default function createMenu(accountId: number): Electron.Menu {<EOL>    let menu: Electron.Menu = getNewRemoteElectronMenu();<EOL>    <EOL>    menu.append(getNewRemoteElectronMenuItem({<EOL>        label: '<STR_LIT>',<EOL>        click: (): any => dispatch(updateAccount(accountId.toString(), true))<EOL>    }));<EOL>    <EOL>    menu.append(getNewRemoteElectronMenuItem({<EOL>        type: '<STR_LIT>'<EOL>    }));<EOL>    <EOL>    menu.append(getNewRemoteElectronMenuItem({<EOL>","gt":"label: '<STR_LIT>',"}
{"input":"<s> <EOL>export default function filter(input: IGitHubNotification[], ruleSet: INotificationFilterSet): IGitHubNotification[] {<EOL>    if (ruleSet.subjectType.length === <NUM_LIT>) {<EOL>","gt":"return input;"}
{"input":"<s> <EOL>export function getAccountToken(accountId: string): string {<EOL>    let account: IStateAccountsAccount = getAccount(accountId);<EOL>    if (account ===","gt":"null) {"}
{"input":"<s> <EOL>export function dispatch(action: any): any {<EOL>    return getStore().dispatch(","gt":"action);"}
{"input":"<s> <EOL>export function getScheduledJobs(): {<EOL>    [jobName: string]: nodeSchedule.Job;<EOL>} {<EOL>    return getNodeSchedule().","gt":"scheduledJobs;"}
{"input":"<s> export async function ls(dir: string): Promise<{<EOL>    path: string;<EOL>    stat: FS.Stats;<EOL>}[]> {<EOL>    let files: any = await deps.fs.readdir(dir);<EOL>    let paths:","gt":"any = files.map((f: any): any => path.join(dir, f));"}
{"input":"<s> export async function readJSON(file: string): Promise<any> {<EOL>","gt":"debug('<STR_LIT>', file);"}
{"input":"<s> async function read(): Promise<CountFile> {<EOL>    try {<EOL>        let b: any = await fs.readJSON(info);<EOL>","gt":"return b;"}
{"input":"<s> export function p<T>(confOrType: any): T {<EOL>    if (!Component.inDefinition) {<EOL>        return undefined as any;<EOL>    }<EOL>    if (typeof confOrType === '<STR_LIT>') {<EOL>        let","gt":"tpe: any = confOrType;"}
{"input":"<s> export function createMap<T>(): Map<T> {<EOL>    const ret: any = Object.create(null);<EOL>","gt":"ret[\"<STR_LIT>\"] = undefined;"}
{"input":"<s> function onDidChangeTextDocument(event: vscode.TextDocumentChangeEvent): void {<EOL>    combo++;<EOL>    <EOL>    if (progressBarTimer) {<EOL>","gt":"if (!progressBarTimer.active) {"}
{"input":"<s> function getClassNodeFromTree(className: string): ClassNode {<EOL>    var toReturn: any = null;<EOL>    for (var i: number = <NUM_LIT>, l: number = workspaceTree.length; i < l; i++) {<EOL>        var fileNode: FileNode = workspaceTree[i];<EOL>        for (var","gt":"j: number = <NUM_LIT>, sl: number = fileNode.classes.length; j < sl; j++) {"}
{"input":"<s> export function weekDay(year: number, month: number, day: number): number {<EOL>    return","gt":"new Date(year, month, day).getDay();"}
{"input":"<s> export function getValueInProperRange(value: number, max: number, min = <NUM_LIT>): number {<EOL>    return Math.max(Math.min(","gt":"value, max), min);"}
{"input":"<s> export function main(): void {<EOL>    describe('<STR_LIT>', (): void => {<EOL>        beforeEach((): void => {<EOL>            TestBed.configureTestingModule({<EOL>                declarations: [Infragistics.IgSparklineComponent, TestComponent]<EOL>            });<EOL>        });<EOL>","gt":"it('<STR_LIT>', (done: any): void => {"}
{"input":"<s> export function main(): void {<EOL>    describe('<STR_LIT>', (): void => {<EOL>        beforeEach((): void => {<EOL>            TestBed.configureTestingModule({<EOL>                declarations: [Infragistics.IgSparklineComponent, TestComponent]<EOL>            });<EOL>        });<EOL>        it('<STR_LIT>', (done: any): void => {<EOL>            var template: string = '<STR_LIT>';<EOL>            TestBed.overrideComponent(TestComponent, {<EOL>                set: {<EOL>                    template: template<EOL>                }<EOL>            });<EOL>            TestBed.compileComponents().then((): void => {<EOL>                let fixture: any = TestBed.createComponent(TestComponent);<EOL>                fixture.detectChanges();<EOL>                expect(","gt":"fixture.debugElement.componentInstance.viewChild instanceof Infragistics.IgSparklineComponent)"}
{"input":"<s> export function localStorageSyncReducer(_reducer: ActionReducer<any>): ActionReducer<any> {<EOL>    return localStorageSync({ keys: ['<STR_LIT>', '<STR_LIT>', '<STR_LIT>'], rehydrate: true,","gt":"storageKeySerializer: keySerializer })(_reducer);"}
{"input":"<s> export function matchRulesFor(world: World, actorOne: Actor, actorTwo: Actor | undefined, action?: Event): boolean | Rule[] {<EOL>    const matchedRules: Rule[] = [];<EOL>    const localRules: Rule[] = getLocalRules(world, actorOne);<EOL>    for (let i: number = <NUM_LIT>; i < localRules.length; i++) {<EOL>","gt":"const currentRule: Rule = localRules[i];"}
{"input":"<s> export function matchRulesFor(world: World, actorOne: Actor, actorTwo: Actor | undefined, action?: Event): boolean | Rule[] {<EOL>    const matchedRules: Rule[] = [];<EOL>    const localRules: Rule[] = getLocalRules(world, actorOne);<EOL>    for (let i: number = <NUM_LIT>; i < localRules.length; i++) {<EOL>        const currentRule: Rule = localRules[i];<EOL>        const isMatch: boolean = checkMatch(currentRule, actorOne, actorTwo, action);<EOL>        if (isMatch) {<EOL>            matchedRules.push(currentRule);<EOL>        }<EOL>    }<EOL>    if (!matchedRules.","gt":"length) {"}
{"input":"<s> function requestCompileMir(): CompileMirRequestAction {<EOL>    return { type: ActionType.","gt":"CompileMirRequest };"}
{"input":"<s> export function toggleConfiguration(): ToggleConfigurationAction {<EOL>","gt":"return { type: ActionType.ToggleConfiguration };"}
{"input":"<s> function _decorate(decorators: any[], target: any): void {<EOL>    Reflect.decorate(","gt":"decorators, target);"}
{"input":"<s> function optional(): (target: any, targetKey: string, index?: number | undefined) => void {<EOL>    return function (target: any, targetKey: string, index?: number) {<EOL>        const metadata: Metadata = new Metadata(METADATA_KEY.OPTIONAL_TAG, true);<EOL>        if (typeof index ===","gt":"\"<STR_LIT>\") {"}
{"input":"<s> function getDependencies(metadataReader: interfaces.MetadataReader, func: Function): interfaces.Target[] {<EOL>","gt":"const constructorName: string = getFunctionName(func);"}
{"input":"<s> function listMetadataForTarget(serviceIdentifierString: string, target: interfaces.Target): string {<EOL>    if (target.isTagged() || target.isNamed()) {<EOL>        let m: string = \"<STR_LIT>\";<EOL>        const namedTag: interfaces.Metadata | null = target.getNamedTag();<EOL>        const otherTags: interfaces.Metadata[] | null = target.getCustomTags();<EOL>        if (namedTag !== null) {<EOL>            m += namedTag.toString() +","gt":"\"<STR_LIT>\";"}
{"input":"<s> function listMetadataForTarget(serviceIdentifierString: string, target: interfaces.Target): string {<EOL>    if (target.isTagged() || target.isNamed()) {<EOL>        let m: string = \"<STR_LIT>\";<EOL>        const namedTag: interfaces.Metadata | null = target.getNamedTag();<EOL>        const otherTags: interfaces.Metadata[] | null = target.getCustomTags();<EOL>        if (namedTag !== null) {<EOL>            m += namedTag.toString() + \"<STR_LIT>\";<EOL>        }<EOL>        if (otherTags !== null) {<EOL>            otherTags.forEach((tag: interfaces.Metadata): void => {<EOL>","gt":"m += tag.toString() + \"<STR_LIT>\";"}
{"input":"<s> function listMetadataForTarget(serviceIdentifierString: string, target: interfaces.Target): string {<EOL>    if (target.isTagged() || target.isNamed()) {<EOL>        let m: string = \"<STR_LIT>\";<EOL>        const namedTag: interfaces.Metadata | null = target.getNamedTag();<EOL>        const otherTags: interfaces.Metadata[] | null = target.getCustomTags();<EOL>        if (namedTag !== null) {<EOL>            m += namedTag.toString() + \"<STR_LIT>\";<EOL>        }<EOL>        if (otherTags !== null) {<EOL>            otherTags.forEach((tag: interfaces.Metadata): void => {<EOL>                m += tag.toString() + \"<STR_LIT>\";<EOL>            });<EOL>        }<EOL>        return","gt":"serviceIdentifierString} - ${m}`<STR_LIT>;"}
{"input":"<s> export async function installGradlePlugins(config: Config, plugins: Plugin[]): Promise<void> {<EOL>    log(`<STR_LIT>`);<EOL>    const settingsLines: string =","gt":"return `<STR_LIT>`"}
{"input":"<s> export async function check(config: Config, checks: CheckFunction[]): Promise<void> {<EOL>    const results: (string | null)[] = await Promise.all(checks.map((f: CheckFunction): Promise<string | null> => f(config)));<EOL>    const errors: string[] = results.filter((r: string | null): boolean => r !=","gt":"null) as string[];"}
{"input":"<s> export async function checkAppConfig(config: Config): Promise<string | null> {<EOL>    if (!config.app.appId) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    if (!config.app.appName) {<EOL>        return","gt":"'<STR_LIT>';"}
{"input":"<s> export async function checkAppConfig(config: Config): Promise<string | null> {<EOL>    if (!config.app.appId) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    if (!config.app.appName) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    const appIdError: string | null = await checkAppId(config, config.app.appId);<EOL>    if (appIdError) {<EOL>","gt":"return appIdError;"}
{"input":"<s> export async function checkAppConfig(config: Config): Promise<string | null> {<EOL>    if (!config.app.appId) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    if (!config.app.appName) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    const appIdError: string | null = await checkAppId(config, config.app.appId);<EOL>    if (appIdError) {<EOL>        return appIdError;<EOL>    }<EOL>    const appNameError: string | null = await checkAppName(config, config.app.appName);<EOL>    if (","gt":"appNameError) {"}
{"input":"<s> export function removePluginFiles(config: Config, platform: string): void {<EOL>    const webDir: string = getWebDir(config, platform);<EOL>    const","gt":"pluginsDir: any = join(webDir, '<STR_LIT>');"}
{"input":"<s> async function promptNewProject(config: Config): Promise<boolean> {<EOL>    const inquirer: any = await import('<STR_LIT>');<EOL>    const answers: any = await inquirer.prompt([{<EOL>            type:","gt":"'<STR_LIT>',"}
{"input":"<s> export async function update(config: Config, platformName: string, needsUpdate: boolean): Promise<void> {<EOL>    runTask(chalk `<STR_LIT>`, async (): Promise<void> => {<EOL>        if (platformName === config.ios.name) {<EOL>","gt":"await updateIOS(config, needsUpdate);"}
{"input":"<s> export async function copyWeb(config: Config): Promise<unknown> {<EOL>    const chalk: any = require('<STR_LIT>');<EOL>    console.log('<STR_LIT>');<EOL>    if (config.","gt":"app.bundledWebRuntime) {"}
{"input":"<s> export function bundleUpdate(changedFiles: ChangedFile[], context: BuildContext): Promise<void> {<EOL>    return webpackUpdate(changedFiles, context)<EOL>        .catch((err: any): never => {<EOL>        if (err instanceof","gt":"IgnorableError) {"}
{"input":"<s> export function isDeepLinkingFile(filePath: string): boolean {<EOL>    const deepLinksDir: string = getStringPropertyValue(Constants.ENV_VAR_DEEPLINKS_DIR) + sep;<EOL>    const moduleSuffix: string = getStringPropertyValue(","gt":"Constants.ENV_NG_MODULE_FILE_NAME_SUFFIX);"}
{"input":"<s> function isUserAgentIOS(ua: string): boolean {<EOL>","gt":"ua = ua.toLowerCase();"}
{"input":"<s> <EOL>function serveIndex(req: express.Request, res: express.Response): void {<EOL>    const config: ServeConfig = req.app.get('<STR_LIT>');<EOL>    <EOL>    const indexFileName: any = path.join(config.wwwDir, process.env[Constants.ENV_VAR_HTML_TO_SERVE]);<EOL>    fs.readFile(indexFileName, (err: any, indexHtml: any): void => {<EOL>        if (!indexHtml) {<EOL>            Logger.","gt":"error(`<STR_LIT>`);"}
{"input":"<s> <EOL>function serveIndex(req: express.Request, res: express.Response): void {<EOL>    const config: ServeConfig = req.app.get('<STR_LIT>');<EOL>    <EOL>    const indexFileName: any = path.join(config.wwwDir, process.env[Constants.ENV_VAR_HTML_TO_SERVE]);<EOL>    fs.readFile(indexFileName, (err: any, indexHtml: any): void => {<EOL>        if (!indexHtml) {<EOL>            Logger.error(`<STR_LIT>`);<EOL>            res.send('<STR_LIT>');<EOL>            return;<EOL>        }<EOL>","gt":"if (config.useLiveReload) {"}
{"input":"<s> function getSuffixFromGeneratorType(context: BuildContext, type: string): string {<EOL>    if (type === Constants.COMPONENT) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    else if (type === Constants.DIRECTIVE) {<EOL>        return","gt":"'<STR_LIT>';"}
{"input":"<s> function getSuffixFromGeneratorType(context: BuildContext, type: string): string {<EOL>    if (type === Constants.COMPONENT) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    else if (type === Constants.DIRECTIVE) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    else if (type === Constants.PAGE || type === Constants.TABS) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    else if (type === Constants.PIPE) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    else","gt":"if (type === Constants.PROVIDER) {"}
{"input":"<s> <EOL>export function createLinter(context: BuildContext, program: Program): Linter {<EOL>","gt":"return new Linter({"}
{"input":"<s> <EOL>export function lint(linter: Linter, config: LinterConfig, filePath: string, fileContents: string): void {<EOL>","gt":"linter.lint(filePath, fileContents, config as any);"}
{"input":"<s> export function lintUpdateWorker(context: BuildContext, { tsConfig, tsLintConfig, filePaths, typeCheck }: LintWorkerConfig): Promise<void> {<EOL>    const program: Program = createProgram(context, tsConfig);<EOL>    return getLintConfig(context,","gt":"tsLintConfig)"}
{"input":"<s> <EOL>export function processLintResult(context: BuildContext, result: LintResult): void {<EOL>    const files: string[] = [];<EOL>    <EOL>    if (result.errorCount !== <NUM_LIT> || result.warningCount !== <NUM_LIT>) {<EOL>","gt":"const diagnostics: import(\"<STR_LIT>\").Diagnostic[] = runTsLintDiagnostics(context, result.failures);"}
{"input":"<s> <EOL>export function processLintResult(context: BuildContext, result: LintResult): void {<EOL>    const files: string[] = [];<EOL>    <EOL>    if (result.errorCount !== <NUM_LIT> || result.warningCount !== <NUM_LIT>) {<EOL>        const diagnostics: import(\"<STR_LIT>\").Diagnostic[] = runTsLintDiagnostics(context, result.failures);<EOL>        printDiagnostics(context, DiagnosticsType.TsLint, diagnostics, true, false);<EOL>        files.push(...getFileNames(context, result.failures));<EOL>    }<EOL>    if (files.length > <NUM_LIT>) {<EOL>        const errorMessage:","gt":"string = generateErrorMessageForFiles(files);"}
{"input":"<s> function getMockFontDirData(): string[] {<EOL>    return [<EOL>        '<STR_LIT>',<EOL>","gt":"'<STR_LIT>',"}
{"input":"<s> function getMockFontDirData(): string[] {<EOL>    return [<EOL>        '<STR_LIT>',<EOL>        '<STR_LIT>',<EOL>        '<STR_LIT>',<EOL>        '<STR_LIT>',<EOL>","gt":"'<STR_LIT>',"}
{"input":"<s> function getMockFontDirData(): string[] {<EOL>    return [<EOL>        '<STR_LIT>',<EOL>        '<STR_LIT>',<EOL>        '<STR_LIT>',<EOL>        '<STR_LIT>',<EOL>        '<STR_LIT>',<EOL>        '<STR_LIT>',<EOL>        '<STR_LIT>',<EOL>        '<STR_LIT>',<EOL>        '<STR_LIT>',<EOL>        '<STR_LIT>',<EOL>        '<STR_LIT>',<EOL>        '<STR_LIT>',<EOL>","gt":"'<STR_LIT>',"}
{"input":"<s> function getMockFontDirData(): string[] {<EOL>    return [<EOL>        '<STR_LIT>',<EOL>        '<STR_LIT>',<EOL>        '<STR_LIT>',<EOL>        '<STR_LIT>',<EOL>        '<STR_LIT>',<EOL>        '<STR_LIT>',<EOL>        '<STR_LIT>',<EOL>        '<STR_LIT>',<EOL>        '<STR_LIT>',<EOL>        '<STR_LIT>',<EOL>        '<STR_LIT>',<EOL>        '<STR_LIT>',<EOL>        '<STR_LIT>',<EOL>        '<STR_LIT>',<EOL>        '<STR_LIT>',<EOL>","gt":"'<STR_LIT>',"}
{"input":"<s> function getMockFontDirData(): string[] {<EOL>    return [<EOL>        '<STR_LIT>',<EOL>        '<STR_LIT>',<EOL>        '<STR_LIT>',<EOL>        '<STR_LIT>',<EOL>        '<STR_LIT>',<EOL>        '<STR_LIT>',<EOL>        '<STR_LIT>',<EOL>        '<STR_LIT>',<EOL>        '<STR_LIT>',<EOL>        '<STR_LIT>',<EOL>        '<STR_LIT>',<EOL>        '<STR_LIT>',<EOL>        '<STR_LIT>',<EOL>        '<STR_LIT>',<EOL>        '<STR_LIT>',<EOL>        '<STR_LIT>',<EOL>        '<STR_LIT>',<EOL>        '<STR_LIT>',<EOL>        '<STR_LIT>',<EOL>        '<STR_LIT>',<EOL>        '<STR_LIT>',<EOL>        '<STR_LIT>',<EOL>","gt":"'<STR_LIT>',"}
{"input":"<s> export function writeFilesToDisk(context: BuildContext): Promise<void> {<EOL>    emptyDirSync(context.tmpDir);<EOL>    const files: import(\"<STR_LIT>\").File[] = context.fileCache.getAll();<EOL>    files.forEach((file: import(\"<STR_LIT>\").File): void => {<EOL>        const dirName: any = dirname(","gt":"file.path);"}
{"input":"<s> export function writeFilesToDisk(context: BuildContext): Promise<void> {<EOL>    emptyDirSync(context.tmpDir);<EOL>    const files: import(\"<STR_LIT>\").File[] = context.fileCache.getAll();<EOL>    files.forEach((file: import(\"<STR_LIT>\").File): void => {<EOL>        const dirName: any = dirname(file.path);<EOL>        const relativePath: any = relative(process.cwd(), dirName);<EOL>        const tmpPath: any = join(context.tmpDir, relativePath);<EOL>        const fileName: any = basename(file.path);<EOL>        const fileToWrite: any = join(tmpPath, fileName);<EOL>        mkdirpSync(tmpPath);<EOL>        writeFileSync(fileToWrite,","gt":"file.content);"}
{"input":"<s> function preprocessWorker(context: BuildContext): Promise<[<EOL>    void<EOL>]> {<EOL>","gt":"const bundlePromise: Promise<void> = bundleCoreComponents(context);"}
{"input":"<s> function getTemplatePrefix(htmlFilePath: string): string {<EOL>    return","gt":"resolve(htmlFilePath)}\"<STR_LIT>;"}
{"input":"<s> function getTemplateSuffix(htmlFilePath: string): string {<EOL>    return","gt":"resolve(htmlFilePath)}\"<STR_LIT>;"}
{"input":"<s> export function bundlerStrategy(context: BuildContext): string {<EOL>    return","gt":"Constants.BUNDLER_WEBPACK;"}
{"input":"<s> export function paramCase(input: string): string {<EOL>    return removeCaseFromString(","gt":"input, '<STR_LIT>');"}
{"input":"<s> export function getProjectJson(): Promise<IonicProject> {<EOL>    const projectFile: any = path.join(process.cwd(), '<STR_LIT>');<EOL>    return","gt":"readFilePromise(projectFile).then(function (textString) {"}
{"input":"<s> <EOL>export function separateArgv(pargv: string[]): [<EOL>    string[],<EOL>    string[]<EOL>] {<EOL>    const ownArgs: string[] = [...pargv];<EOL>    const otherArgs: string[] = [];<EOL>    const sepIndex: number = pargv.","gt":"indexOf('<STR_LIT>');"}
{"input":"<s> function formatCommandHeader(cmd: HydratedCommandMetadata, fullName: string): string {<EOL>    return","gt":"}"}
{"input":"<s> export function getWarning(): string {<EOL>","gt":"return `<STR_LIT>`"}
{"input":"<s> export function isApp(d: object): d is App {<EOL>    const details: App = <App>d;<EOL>","gt":"return details"}
{"input":"<s> export function isAppResponse(r: APIResponse): r is Response<App> {<EOL>","gt":"return isAPIResponseSuccess(r)"}
{"input":"<s> export function isSnapshot(s: object): s is Snapshot {<EOL>    const snapshot: Snapshot = <Snapshot>s;<EOL>    return snapshot<EOL>        && typeof snapshot.id ===","gt":"'<STR_LIT>'"}
{"input":"<s> export function isUser(u: object): u is User {<EOL>    const user: User = <User>u;<EOL>    return","gt":"user"}
{"input":"<s> export function isUserResponse(r: APIResponse): r is Response<User> {<EOL>    return","gt":"isAPIResponseSuccess(r)"}
{"input":"<s> export async function isRepoInitialized(dir: string): Promise<boolean> {<EOL>    return pathExists(","gt":"path.join(dir, '<STR_LIT>'));"}
{"input":"<s> export async function loadFromPath(p: string): Promise<SSHConfigModule.SSHConfig> {<EOL>    const","gt":"s: any = await fileToString(p);"}
{"input":"<s> export async function validatePrivateKey(keyPath: string): Promise<void> {<EOL>    try {<EOL>        await fsStat(keyPath);<EOL>    }<EOL>    catch (e: unknown) {<EOL>        if (e.code ===","gt":"'<STR_LIT>') {"}
{"input":"<s> export async function validatePrivateKey(keyPath: string): Promise<void> {<EOL>    try {<EOL>        await fsStat(keyPath);<EOL>    }<EOL>    catch (e: unknown) {<EOL>        if (e.code === '<STR_LIT>') {<EOL>            throw ERROR_SSH_MISSING_PRIVKEY;<EOL>        }<EOL>        throw e;<EOL>    }<EOL>    const f: any = await fsReadFile(keyPath, { encoding: '<STR_LIT>' });<EOL>    const lines: any = f.","gt":"split('<STR_LIT>');"}
{"input":"<s> export function buildIonicAngularEsm(stripDebug: boolean, done: Function): void {<EOL>    const stream: any = copySourceToDest(DIST_BUILD_ROOT, true, true, stripDebug);<EOL>    stream.on('<STR_LIT>', (): void => {<EOL>        <EOL>        createTempTsConfig([join('<STR_LIT>', '<STR_LIT>', '<STR_LIT>')], ES5, ES_2015, join(PROJECT_ROOT, '<STR_LIT>'), join(DIST_BUILD_ROOT, '<STR_LIT>'));<EOL>        runNgc(","gt":"join(DIST_BUILD_ROOT, '<STR_LIT>'), (err: any): void => {"}
{"input":"<s> export function buildIonicAngularEsm(stripDebug: boolean, done: Function): void {<EOL>    const stream: any = copySourceToDest(DIST_BUILD_ROOT, true, true, stripDebug);<EOL>    stream.on('<STR_LIT>', (): void => {<EOL>        <EOL>        createTempTsConfig([join('<STR_LIT>', '<STR_LIT>', '<STR_LIT>')], ES5, ES_2015, join(PROJECT_ROOT, '<STR_LIT>'), join(DIST_BUILD_ROOT, '<STR_LIT>'));<EOL>        runNgc(join(DIST_BUILD_ROOT, '<STR_LIT>'), (err: any): void => {<EOL>            if (err) {<EOL>                done(err);<EOL>                return;<EOL>            }<EOL>            <EOL>            deleteFiles([`<STR_LIT>`,<EOL>                `<STR_LIT>`,<EOL>","gt":"DIST_BUILD_ROOT}/tsconfig.json`,"}
{"input":"<s> <EOL>function ifUndefined(val1: any, val2: any): any {<EOL>    return (val1 === undefined) ?","gt":"val2 : val1;"}
{"input":"<s> <EOL>function inherit(child: any, base: any, properties: any): void {<EOL>    var baseP: any = base.prototype, childP: any;<EOL>    childP = child.prototype = Object.create(baseP);<EOL>    childP.","gt":"constructor = child;"}
{"input":"<s> <EOL>function triggerDomEvent(event: any, data: any): void {<EOL>    var gestureEvent: any = doc.createEvent('<STR_LIT>');<EOL>    gestureEvent.initEvent(event, true,","gt":"true);"}
{"input":"<s> function testValues(): any {<EOL>    let parent: HTMLDivElement = document.createElement('<STR_LIT>');<EOL>    let ele: HTMLAnchorElement = document.createElement('<STR_LIT>');<EOL>","gt":"parent.appendChild(ele);"}
{"input":"<s> export function updateDate(existingData: DateTimeData, newData: any): boolean {<EOL>    if (isPresent(newData) && newData !== '<STR_LIT>') {<EOL>        if (isString(newData)) {<EOL>            <EOL>            <EOL>            newData = parseDate(","gt":"newData);"}
{"input":"<s> export function updateDate(existingData: DateTimeData, newData: any): boolean {<EOL>    if (isPresent(newData) && newData !== '<STR_LIT>') {<EOL>        if (isString(newData)) {<EOL>            <EOL>            <EOL>            newData = parseDate(newData);<EOL>            if (newData) {<EOL>                <EOL>","gt":"Object.assign(existingData, newData);"}
{"input":"<s> export function updateDate(existingData: DateTimeData, newData: any): boolean {<EOL>    if (isPresent(newData) && newData !== '<STR_LIT>') {<EOL>        if (isString(newData)) {<EOL>            <EOL>            <EOL>            newData = parseDate(newData);<EOL>            if (newData) {<EOL>                <EOL>                Object.assign(existingData, newData);<EOL>                return true;<EOL>            }<EOL>        }<EOL>        else if ((isPresent(newData.year) || isPresent(newData.hour) || isPresent(newData.month) || isPresent(newData.day) || isPresent(newData.minute) || isPresent(newData.second))) {<EOL>            <EOL>            <EOL>            <EOL>            if (isPresent(newData.ampm) && isPresent(newData.hour)) {<EOL>                if (","gt":"newData.ampm.value === '<STR_LIT>') {"}
{"input":"<s> export function updateDate(existingData: DateTimeData, newData: any): boolean {<EOL>    if (isPresent(newData) && newData !== '<STR_LIT>') {<EOL>        if (isString(newData)) {<EOL>            <EOL>            <EOL>            newData = parseDate(newData);<EOL>            if (newData) {<EOL>                <EOL>                Object.assign(existingData, newData);<EOL>                return true;<EOL>            }<EOL>        }<EOL>        else if ((isPresent(newData.year) || isPresent(newData.hour) || isPresent(newData.month) || isPresent(newData.day) || isPresent(newData.minute) || isPresent(newData.second))) {<EOL>            <EOL>            <EOL>            <EOL>            if (isPresent(newData.ampm) && isPresent(newData.hour)) {<EOL>                if (newData.ampm.value === '<STR_LIT>') {<EOL>                    newData.hour.value = (newData.hour.value === <NUM_LIT> ? <NUM_LIT> : newData.hour.value + <NUM_LIT>);<EOL>                }<EOL>                else {<EOL>                    newData.hour.value = (newData.hour.value === <NUM_LIT> ? <NUM_LIT> : newData.hour.value);<EOL>                }<EOL>            }<EOL>            <EOL>            <EOL>            for (const k: string in newData) {<EOL>                (<any>existingData)[k] = newData[k].value;<EOL>            }<EOL>            return true;<EOL>        }<EOL>        <EOL>        console.warn(`<STR_LIT>`);<EOL>    }<EOL>","gt":"else {"}
{"input":"<s> <EOL>export function requestIonicCallback(functionToLazy: any): any {<EOL>    if ('<STR_LIT>' in window) {<EOL>","gt":"return (window as any).requestIdleCallback(functionToLazy);"}
{"input":"<s> <EOL>function parseCss(node: StyleNode, text: string): StyleNode {<EOL>    let t: string = text.substring(node.start, node.end - <NUM_LIT>);<EOL>    node.parsedCssText = node.cssText = t.trim();<EOL>","gt":"if (node.parent) {"}
{"input":"<s> <EOL>function parseCss(node: StyleNode, text: string): StyleNode {<EOL>    let t: string = text.substring(node.start, node.end - <NUM_LIT>);<EOL>    node.parsedCssText = node.cssText = t.trim();<EOL>    if (node.parent) {<EOL>        let ss: number = node.previous ? node.previous.end : node.parent.start;<EOL>        t = text.substring(ss, node.start - <NUM_LIT>);<EOL>        t = _expandUnicodeEscapes(t);<EOL>        t = t.replace(MULTI_SPACES_RX,","gt":"'<STR_LIT>');"}
{"input":"<s> <EOL>function parseCss(node: StyleNode, text: string): StyleNode {<EOL>    let t: string = text.substring(node.start, node.end - <NUM_LIT>);<EOL>    node.parsedCssText = node.cssText = t.trim();<EOL>    if (node.parent) {<EOL>        let ss: number = node.previous ? node.previous.end : node.parent.start;<EOL>        t = text.substring(ss, node.start - <NUM_LIT>);<EOL>        t = _expandUnicodeEscapes(t);<EOL>        t = t.replace(MULTI_SPACES_RX, '<STR_LIT>');<EOL>        t = t.substring(t.lastIndexOf('<STR_LIT>') + <NUM_LIT>);<EOL>        let s: string = node.parsedSelector = node.selector = t.trim();<EOL>        node.atRule = (s.indexOf(AT_START) === <NUM_LIT>);<EOL>        <EOL>        if (","gt":"node.atRule) {"}
{"input":"<s> export function createDom(): {<EOL>    parse(opts: HydrateOptions): any;<EOL>    serialize(): any;<EOL>    destroy(): void;<EOL>} {<EOL>    let dom: any = null;<EOL>    return {<EOL>        parse(opts: HydrateOptions) {<EOL>            if (dom) {<EOL>                dom.window.close();<EOL>            }<EOL>            const jsdom: any = require('<STR_LIT>');<EOL>            const jsdomOptions: any = {<EOL>","gt":"url: opts.url,"}
{"input":"<s> export function createDom(): {<EOL>    parse(opts: HydrateOptions): any;<EOL>    serialize(): any;<EOL>    destroy(): void;<EOL>} {<EOL>    let dom: any = null;<EOL>    return {<EOL>        parse(opts: HydrateOptions) {<EOL>            if (dom) {<EOL>                dom.window.close();<EOL>            }<EOL>            const jsdom: any = require('<STR_LIT>');<EOL>            const jsdomOptions: any = {<EOL>                url: opts.url,<EOL>                referrer: opts.referrer,<EOL>                userAgent: opts.userAgent<EOL>            };<EOL>            if (opts.console) {<EOL>                jsdomOptions.virtualConsole = new jsdom.VirtualConsole();<EOL>                jsdomOptions.","gt":"virtualConsole.sendTo(opts.console);"}
{"input":"<s> export function createDom(): {<EOL>    parse(opts: HydrateOptions): any;<EOL>    serialize(): any;<EOL>    destroy(): void;<EOL>} {<EOL>    let dom: any = null;<EOL>    return {<EOL>        parse(opts: HydrateOptions) {<EOL>            if (dom) {<EOL>                dom.window.close();<EOL>            }<EOL>            const jsdom: any = require('<STR_LIT>');<EOL>            const jsdomOptions: any = {<EOL>                url: opts.url,<EOL>                referrer: opts.referrer,<EOL>                userAgent: opts.userAgent<EOL>            };<EOL>            if (opts.console) {<EOL>                jsdomOptions.virtualConsole = new jsdom.VirtualConsole();<EOL>                jsdomOptions.virtualConsole.sendTo(opts.console);<EOL>            }<EOL>            dom = new jsdom.JSDOM(opts.html, jsdomOptions);<EOL>            polyfillJsDom(dom.window);<EOL>            return dom.window;<EOL>        },<EOL>        serialize() {<EOL>","gt":"return dom.serialize();"}
{"input":"<s> export function mockRenderer(plt?: MockedPlatform, domApi?: DomApi): RendererApi {<EOL>","gt":"plt = plt || mockPlatform();"}
{"input":"<s> function getTestBuildConfig(): Config {<EOL>    const sys: import(\"<STR_LIT>\").StencilSystem = mockStencilSystem();<EOL>    const config: Config = {<EOL>        sys: sys,<EOL>        logger: mockLogger(),<EOL>        rootDir: '<STR_LIT>',<EOL>","gt":"suppressTypeScriptErrors: true,"}
{"input":"<s> function getTestBuildConfig(): Config {<EOL>    const sys: import(\"<STR_LIT>\").StencilSystem = mockStencilSystem();<EOL>    const config: Config = {<EOL>        sys: sys,<EOL>        logger: mockLogger(),<EOL>        rootDir: '<STR_LIT>',<EOL>        suppressTypeScriptErrors: true,<EOL>        devMode: true<EOL>    };<EOL>    config.prerender = false;<EOL>","gt":"config.devMode = true;"}
{"input":"<s> function getTestBuildConfig(): Config {<EOL>    const sys: import(\"<STR_LIT>\").StencilSystem = mockStencilSystem();<EOL>    const config: Config = {<EOL>        sys: sys,<EOL>        logger: mockLogger(),<EOL>        rootDir: '<STR_LIT>',<EOL>        suppressTypeScriptErrors: true,<EOL>        devMode: true<EOL>    };<EOL>    config.prerender = false;<EOL>    config.devMode = true;<EOL>    config._isTesting = true;<EOL>    config.serviceWorker = false;<EOL>    config.emptyDist =","gt":"false;"}
{"input":"<s> export function HttpLoaderFactory(http: HttpClient): any {<EOL>","gt":"return new TranslateHttpLoader(http);"}
{"input":"<s> <EOL>export function ensureArray(v: any): any[] {<EOL>    if (!v || !v.length) {<EOL>","gt":"return [];"}
{"input":"<s> export function updateQuery(model: Model, primaryValue: any, newFields: any): string {<EOL>    let query: string = `<STR_LIT>`;<EOL>","gt":"for (const key: string of Object.keys(newFields)) {"}
{"input":"<s> export function ensureExtends<A extends B, B>(): void {<EOL>","gt":"let _: B;"}
{"input":"<s> export default function getGameStatus(rs: IRootState, game: Game, cave?: ICaveSummary): IGameStatus {<EOL>    const { commons, session, tasks, downloads } = rs;<EOL>    const { credentials } = session;<EOL>    let downloadKeys: IDownloadKeySummary[] = getByIds(commons.downloadKeys, commons.downloadKeyIdsByGameId[game.id]);<EOL>    if (!cave) {<EOL>        let caves: ICaveSummary[] = getByIds(commons.caves, commons.","gt":"caveIdsByGameId[game.id]);"}
{"input":"<s> export default function getGameStatus(rs: IRootState, game: Game, cave?: ICaveSummary): IGameStatus {<EOL>    const { commons, session, tasks, downloads } = rs;<EOL>    const { credentials } = session;<EOL>    let downloadKeys: IDownloadKeySummary[] = getByIds(commons.downloadKeys, commons.downloadKeyIdsByGameId[game.id]);<EOL>    if (!cave) {<EOL>        let caves: ICaveSummary[] = getByIds(commons.caves, commons.caveIdsByGameId[game.id]);<EOL>        cave = first(caves);<EOL>    }<EOL>    const","gt":"downloadKey: IDownloadKeySummary = first(downloadKeys);"}
{"input":"<s> export default function getGameStatus(rs: IRootState, game: Game, cave?: ICaveSummary): IGameStatus {<EOL>    const { commons, session, tasks, downloads } = rs;<EOL>    const { credentials } = session;<EOL>    let downloadKeys: IDownloadKeySummary[] = getByIds(commons.downloadKeys, commons.downloadKeyIdsByGameId[game.id]);<EOL>    if (!cave) {<EOL>        let caves: ICaveSummary[] = getByIds(commons.caves, commons.caveIdsByGameId[game.id]);<EOL>        cave = first(caves);<EOL>    }<EOL>    const downloadKey: IDownloadKeySummary = first(downloadKeys);<EOL>    const pressUser: boolean = credentials.me.pressUser;<EOL>    const task: ITask = first(tasks.tasksByGameId[game.id]);<EOL>    const download: IDownloadItem = first(getPendingForGame(downloads, game.id));<EOL>    let isActiveDownload: boolean = false;<EOL>","gt":"let areDownloadsPaused: boolean = false;"}
{"input":"<s> function rawGetGameStatus(game: Game, cave: ICaveSummary, downloadKey: IDownloadKeySummary, pressUser: boolean, task: ITask, download: IDownloadItem, update: GameUpdate, isDownloadActive, areDownloadsPaused): IGameStatus {<EOL>    let access: Access = Access.None;<EOL>    if (!(game.minPrice > <NUM_LIT>)) {<EOL>","gt":"if (game.canBeBought) {"}
{"input":"<s> function rawGetGameStatus(game: Game, cave: ICaveSummary, downloadKey: IDownloadKeySummary, pressUser: boolean, task: ITask, download: IDownloadItem, update: GameUpdate, isDownloadActive, areDownloadsPaused): IGameStatus {<EOL>    let access: Access = Access.None;<EOL>    if (!(game.minPrice > <NUM_LIT>)) {<EOL>        if (game.canBeBought) {<EOL>            access = Access.Pwyw;<EOL>        }<EOL>        else {<EOL>            access =","gt":"Access.Free;"}
{"input":"<s> function rawGetGameStatus(game: Game, cave: ICaveSummary, downloadKey: IDownloadKeySummary, pressUser: boolean, task: ITask, download: IDownloadItem, update: GameUpdate, isDownloadActive, areDownloadsPaused): IGameStatus {<EOL>    let access: Access = Access.None;<EOL>    if (!(game.minPrice > <NUM_LIT>)) {<EOL>        if (game.canBeBought) {<EOL>            access = Access.Pwyw;<EOL>        }<EOL>        else {<EOL>            access = Access.Free;<EOL>        }<EOL>    }<EOL>    else {<EOL>        <EOL>","gt":"if (downloadKey) {"}
{"input":"<s> function rawGetGameStatus(game: Game, cave: ICaveSummary, downloadKey: IDownloadKeySummary, pressUser: boolean, task: ITask, download: IDownloadItem, update: GameUpdate, isDownloadActive, areDownloadsPaused): IGameStatus {<EOL>    let access: Access = Access.None;<EOL>    if (!(game.minPrice > <NUM_LIT>)) {<EOL>        if (game.canBeBought) {<EOL>            access = Access.Pwyw;<EOL>        }<EOL>        else {<EOL>            access = Access.Free;<EOL>        }<EOL>    }<EOL>    else {<EOL>        <EOL>        if (downloadKey) {<EOL>            <EOL>            access = Access.Key;<EOL>        }<EOL>        else {<EOL>            <EOL>","gt":"if (game.inPressSystem && pressUser) {"}
{"input":"<s> function rawGetGameStatus(game: Game, cave: ICaveSummary, downloadKey: IDownloadKeySummary, pressUser: boolean, task: ITask, download: IDownloadItem, update: GameUpdate, isDownloadActive, areDownloadsPaused): IGameStatus {<EOL>    let access: Access = Access.None;<EOL>    if (!(game.minPrice > <NUM_LIT>)) {<EOL>        if (game.canBeBought) {<EOL>            access = Access.Pwyw;<EOL>        }<EOL>        else {<EOL>            access = Access.Free;<EOL>        }<EOL>    }<EOL>    else {<EOL>        <EOL>        if (downloadKey) {<EOL>            <EOL>            access = Access.Key;<EOL>        }<EOL>        else {<EOL>            <EOL>            if (game.inPressSystem && pressUser) {<EOL>                access = Access.Press;<EOL>            }<EOL>            else {<EOL>                <EOL>            }<EOL>        }<EOL>    }<EOL>    let operation: IOperation = null;<EOL>    if (task) {<EOL>        operation = {<EOL>            type: OperationType.Task,<EOL>            name: task.name,<EOL>            active: true,<EOL>","gt":"paused: false,"}
{"input":"<s> function rawGetGameStatus(game: Game, cave: ICaveSummary, downloadKey: IDownloadKeySummary, pressUser: boolean, task: ITask, download: IDownloadItem, update: GameUpdate, isDownloadActive, areDownloadsPaused): IGameStatus {<EOL>    let access: Access = Access.None;<EOL>    if (!(game.minPrice > <NUM_LIT>)) {<EOL>        if (game.canBeBought) {<EOL>            access = Access.Pwyw;<EOL>        }<EOL>        else {<EOL>            access = Access.Free;<EOL>        }<EOL>    }<EOL>    else {<EOL>        <EOL>        if (downloadKey) {<EOL>            <EOL>            access = Access.Key;<EOL>        }<EOL>        else {<EOL>            <EOL>            if (game.inPressSystem && pressUser) {<EOL>                access = Access.Press;<EOL>            }<EOL>            else {<EOL>                <EOL>            }<EOL>        }<EOL>    }<EOL>    let operation: IOperation = null;<EOL>    if (task) {<EOL>        operation = {<EOL>            type: OperationType.Task,<EOL>            name: task.name,<EOL>            active: true,<EOL>            paused: false,<EOL>            progress: task.progress,<EOL>            eta: task.eta,<EOL>            bps: task.bps,<EOL>        };<EOL>    }<EOL>    else if (download) {<EOL>        operation = {<EOL>            type: OperationType.Download,<EOL>            id: download.id,<EOL>            reason: download.reason,<EOL>            active:","gt":"isDownloadActive,"}
{"input":"<s> function rawGetGameStatus(game: Game, cave: ICaveSummary, downloadKey: IDownloadKeySummary, pressUser: boolean, task: ITask, download: IDownloadItem, update: GameUpdate, isDownloadActive, areDownloadsPaused): IGameStatus {<EOL>    let access: Access = Access.None;<EOL>    if (!(game.minPrice > <NUM_LIT>)) {<EOL>        if (game.canBeBought) {<EOL>            access = Access.Pwyw;<EOL>        }<EOL>        else {<EOL>            access = Access.Free;<EOL>        }<EOL>    }<EOL>    else {<EOL>        <EOL>        if (downloadKey) {<EOL>            <EOL>            access = Access.Key;<EOL>        }<EOL>        else {<EOL>            <EOL>            if (game.inPressSystem && pressUser) {<EOL>                access = Access.Press;<EOL>            }<EOL>            else {<EOL>                <EOL>            }<EOL>        }<EOL>    }<EOL>    let operation: IOperation = null;<EOL>    if (task) {<EOL>        operation = {<EOL>            type: OperationType.Task,<EOL>            name: task.name,<EOL>            active: true,<EOL>            paused: false,<EOL>            progress: task.progress,<EOL>            eta: task.eta,<EOL>            bps: task.bps,<EOL>        };<EOL>    }<EOL>    else if (download) {<EOL>        operation = {<EOL>            type: OperationType.Download,<EOL>            id: download.id,<EOL>            reason: download.reason,<EOL>            active: isDownloadActive,<EOL>            paused: areDownloadsPaused,<EOL>            progress: download.progress,<EOL>            eta: download.eta,<EOL>            bps: download.bps,<EOL>        };<EOL>    }<EOL>    const compatible: boolean = isPlatformCompatible(game);<EOL>","gt":"return {"}
{"input":"<s> <EOL>export function isLinux64(): boolean {<EOL>    if (!hasDeterminedLinux64) {<EOL>        cachedIsLinux64 =","gt":"determineLinux64();"}
{"input":"<s> export function preferencesPath(): string {<EOL>    return join(app.getPath(\"<STR_LIT>\"),","gt":"\"<STR_LIT>\");"}
{"input":"<s> export async function regAddDefault(ctx: MinimalContext, key: string, value: string): Promise<void> {<EOL>    await spawn.assert({<EOL>","gt":"command: regPath,"}
{"input":"<s> function computeMenuTemplate(appVersion: string, credentials: ISessionCredentialsState, runtime: IRuntime): IMenuTemplate {<EOL>    const menus: IAllTemplates = {<EOL>        mainMac: {<EOL>            <EOL>","gt":"submenu: ["}
{"input":"<s> function computeMenuTemplate(appVersion: string, credentials: ISessionCredentialsState, runtime: IRuntime): IMenuTemplate {<EOL>    const menus: IAllTemplates = {<EOL>        mainMac: {<EOL>            <EOL>            submenu: [<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                    submenu: [],<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>","gt":"localizedLabel: [\"<STR_LIT>\"],"}
{"input":"<s> function computeMenuTemplate(appVersion: string, credentials: ISessionCredentialsState, runtime: IRuntime): IMenuTemplate {<EOL>    const menus: IAllTemplates = {<EOL>        mainMac: {<EOL>            <EOL>            submenu: [<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                    submenu: [],<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>            ],<EOL>        },<EOL>        file: {<EOL>            localizedLabel: [\"<STR_LIT>\"],<EOL>            submenu: [<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>","gt":"type: \"<STR_LIT>\","}
{"input":"<s> function computeMenuTemplate(appVersion: string, credentials: ISessionCredentialsState, runtime: IRuntime): IMenuTemplate {<EOL>    const menus: IAllTemplates = {<EOL>        mainMac: {<EOL>            <EOL>            submenu: [<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                    submenu: [],<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>            ],<EOL>        },<EOL>        file: {<EOL>            localizedLabel: [\"<STR_LIT>\"],<EOL>            submenu: [<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>","gt":"type: \"<STR_LIT>\","}
{"input":"<s> function computeMenuTemplate(appVersion: string, credentials: ISessionCredentialsState, runtime: IRuntime): IMenuTemplate {<EOL>    const menus: IAllTemplates = {<EOL>        mainMac: {<EOL>            <EOL>            submenu: [<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                    submenu: [],<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>            ],<EOL>        },<EOL>        file: {<EOL>            localizedLabel: [\"<STR_LIT>\"],<EOL>            submenu: [<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [","gt":"\"<STR_LIT>\"],"}
{"input":"<s> function computeMenuTemplate(appVersion: string, credentials: ISessionCredentialsState, runtime: IRuntime): IMenuTemplate {<EOL>    const menus: IAllTemplates = {<EOL>        mainMac: {<EOL>            <EOL>            submenu: [<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                    submenu: [],<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>            ],<EOL>        },<EOL>        file: {<EOL>            localizedLabel: [\"<STR_LIT>\"],<EOL>            submenu: [<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator:","gt":"\"<STR_LIT>\","}
{"input":"<s> function computeMenuTemplate(appVersion: string, credentials: ISessionCredentialsState, runtime: IRuntime): IMenuTemplate {<EOL>    const menus: IAllTemplates = {<EOL>        mainMac: {<EOL>            <EOL>            submenu: [<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                    submenu: [],<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>            ],<EOL>        },<EOL>        file: {<EOL>            localizedLabel: [\"<STR_LIT>\"],<EOL>            submenu: [<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: runtime.platform === \"<STR_LIT>\" ? \"<STR_LIT>\" : \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [","gt":"\"<STR_LIT>\"],"}
{"input":"<s> function computeMenuTemplate(appVersion: string, credentials: ISessionCredentialsState, runtime: IRuntime): IMenuTemplate {<EOL>    const menus: IAllTemplates = {<EOL>        mainMac: {<EOL>            <EOL>            submenu: [<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                    submenu: [],<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>            ],<EOL>        },<EOL>        file: {<EOL>            localizedLabel: [\"<STR_LIT>\"],<EOL>            submenu: [<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: runtime.platform === \"<STR_LIT>\" ? \"<STR_LIT>\" : \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>            ],<EOL>        },<EOL>        fileMac: {<EOL>            localizedLabel: [\"<STR_LIT>\"],<EOL>            submenu: [<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [","gt":"\"<STR_LIT>\"],"}
{"input":"<s> function computeMenuTemplate(appVersion: string, credentials: ISessionCredentialsState, runtime: IRuntime): IMenuTemplate {<EOL>    const menus: IAllTemplates = {<EOL>        mainMac: {<EOL>            <EOL>            submenu: [<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                    submenu: [],<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>            ],<EOL>        },<EOL>        file: {<EOL>            localizedLabel: [\"<STR_LIT>\"],<EOL>            submenu: [<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: runtime.platform === \"<STR_LIT>\" ? \"<STR_LIT>\" : \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>            ],<EOL>        },<EOL>        fileMac: {<EOL>            localizedLabel: [\"<STR_LIT>\"],<EOL>            submenu: [<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>","gt":"localizedLabel: [\"<STR_LIT>\"],"}
{"input":"<s> function computeMenuTemplate(appVersion: string, credentials: ISessionCredentialsState, runtime: IRuntime): IMenuTemplate {<EOL>    const menus: IAllTemplates = {<EOL>        mainMac: {<EOL>            <EOL>            submenu: [<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                    submenu: [],<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>            ],<EOL>        },<EOL>        file: {<EOL>            localizedLabel: [\"<STR_LIT>\"],<EOL>            submenu: [<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: runtime.platform === \"<STR_LIT>\" ? \"<STR_LIT>\" : \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>            ],<EOL>        },<EOL>        fileMac: {<EOL>            localizedLabel: [\"<STR_LIT>\"],<EOL>            submenu: [<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: runtime.platform === \"<STR_LIT>\" ? \"<STR_LIT>\" : \"<STR_LIT>\",<EOL>                },<EOL>            ],<EOL>        },<EOL>","gt":"edit: {"}
{"input":"<s> function computeMenuTemplate(appVersion: string, credentials: ISessionCredentialsState, runtime: IRuntime): IMenuTemplate {<EOL>    const menus: IAllTemplates = {<EOL>        mainMac: {<EOL>            <EOL>            submenu: [<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                    submenu: [],<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>            ],<EOL>        },<EOL>        file: {<EOL>            localizedLabel: [\"<STR_LIT>\"],<EOL>            submenu: [<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: runtime.platform === \"<STR_LIT>\" ? \"<STR_LIT>\" : \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>            ],<EOL>        },<EOL>        fileMac: {<EOL>            localizedLabel: [\"<STR_LIT>\"],<EOL>            submenu: [<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: runtime.platform === \"<STR_LIT>\" ? \"<STR_LIT>\" : \"<STR_LIT>\",<EOL>                },<EOL>            ],<EOL>        },<EOL>        edit: {<EOL>            localizedLabel: [\"<STR_LIT>\"],<EOL>            visible: false,<EOL>            submenu: [<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>","gt":"role: \"<STR_LIT>\","}
{"input":"<s> function computeMenuTemplate(appVersion: string, credentials: ISessionCredentialsState, runtime: IRuntime): IMenuTemplate {<EOL>    const menus: IAllTemplates = {<EOL>        mainMac: {<EOL>            <EOL>            submenu: [<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                    submenu: [],<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>            ],<EOL>        },<EOL>        file: {<EOL>            localizedLabel: [\"<STR_LIT>\"],<EOL>            submenu: [<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: runtime.platform === \"<STR_LIT>\" ? \"<STR_LIT>\" : \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>            ],<EOL>        },<EOL>        fileMac: {<EOL>            localizedLabel: [\"<STR_LIT>\"],<EOL>            submenu: [<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: runtime.platform === \"<STR_LIT>\" ? \"<STR_LIT>\" : \"<STR_LIT>\",<EOL>                },<EOL>            ],<EOL>        },<EOL>        edit: {<EOL>            localizedLabel: [\"<STR_LIT>\"],<EOL>            visible: false,<EOL>            submenu: [<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>","gt":"localizedLabel: [\"<STR_LIT>\"],"}
{"input":"<s> function computeMenuTemplate(appVersion: string, credentials: ISessionCredentialsState, runtime: IRuntime): IMenuTemplate {<EOL>    const menus: IAllTemplates = {<EOL>        mainMac: {<EOL>            <EOL>            submenu: [<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                    submenu: [],<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>            ],<EOL>        },<EOL>        file: {<EOL>            localizedLabel: [\"<STR_LIT>\"],<EOL>            submenu: [<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: runtime.platform === \"<STR_LIT>\" ? \"<STR_LIT>\" : \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>            ],<EOL>        },<EOL>        fileMac: {<EOL>            localizedLabel: [\"<STR_LIT>\"],<EOL>            submenu: [<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: runtime.platform === \"<STR_LIT>\" ? \"<STR_LIT>\" : \"<STR_LIT>\",<EOL>                },<EOL>            ],<EOL>        },<EOL>        edit: {<EOL>            localizedLabel: [\"<STR_LIT>\"],<EOL>            visible: false,<EOL>            submenu: [<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>","gt":"accelerator: \"<STR_LIT>\","}
{"input":"<s> function computeMenuTemplate(appVersion: string, credentials: ISessionCredentialsState, runtime: IRuntime): IMenuTemplate {<EOL>    const menus: IAllTemplates = {<EOL>        mainMac: {<EOL>            <EOL>            submenu: [<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                    submenu: [],<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>            ],<EOL>        },<EOL>        file: {<EOL>            localizedLabel: [\"<STR_LIT>\"],<EOL>            submenu: [<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: runtime.platform === \"<STR_LIT>\" ? \"<STR_LIT>\" : \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>            ],<EOL>        },<EOL>        fileMac: {<EOL>            localizedLabel: [\"<STR_LIT>\"],<EOL>            submenu: [<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: runtime.platform === \"<STR_LIT>\" ? \"<STR_LIT>\" : \"<STR_LIT>\",<EOL>                },<EOL>            ],<EOL>        },<EOL>        edit: {<EOL>            localizedLabel: [\"<STR_LIT>\"],<EOL>            visible: false,<EOL>            submenu: [<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator:","gt":"\"<STR_LIT>\","}
{"input":"<s> function computeMenuTemplate(appVersion: string, credentials: ISessionCredentialsState, runtime: IRuntime): IMenuTemplate {<EOL>    const menus: IAllTemplates = {<EOL>        mainMac: {<EOL>            <EOL>            submenu: [<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                    submenu: [],<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>            ],<EOL>        },<EOL>        file: {<EOL>            localizedLabel: [\"<STR_LIT>\"],<EOL>            submenu: [<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: runtime.platform === \"<STR_LIT>\" ? \"<STR_LIT>\" : \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>            ],<EOL>        },<EOL>        fileMac: {<EOL>            localizedLabel: [\"<STR_LIT>\"],<EOL>            submenu: [<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: runtime.platform === \"<STR_LIT>\" ? \"<STR_LIT>\" : \"<STR_LIT>\",<EOL>                },<EOL>            ],<EOL>        },<EOL>        edit: {<EOL>            localizedLabel: [\"<STR_LIT>\"],<EOL>            visible: false,<EOL>            submenu: [<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                    role:","gt":"\"<STR_LIT>\","}
{"input":"<s> function computeMenuTemplate(appVersion: string, credentials: ISessionCredentialsState, runtime: IRuntime): IMenuTemplate {<EOL>    const menus: IAllTemplates = {<EOL>        mainMac: {<EOL>            <EOL>            submenu: [<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                    submenu: [],<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>            ],<EOL>        },<EOL>        file: {<EOL>            localizedLabel: [\"<STR_LIT>\"],<EOL>            submenu: [<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: runtime.platform === \"<STR_LIT>\" ? \"<STR_LIT>\" : \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>            ],<EOL>        },<EOL>        fileMac: {<EOL>            localizedLabel: [\"<STR_LIT>\"],<EOL>            submenu: [<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: runtime.platform === \"<STR_LIT>\" ? \"<STR_LIT>\" : \"<STR_LIT>\",<EOL>                },<EOL>            ],<EOL>        },<EOL>        edit: {<EOL>            localizedLabel: [\"<STR_LIT>\"],<EOL>            visible: false,<EOL>            submenu: [<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>","gt":"role: \"<STR_LIT>\","}
{"input":"<s> function computeMenuTemplate(appVersion: string, credentials: ISessionCredentialsState, runtime: IRuntime): IMenuTemplate {<EOL>    const menus: IAllTemplates = {<EOL>        mainMac: {<EOL>            <EOL>            submenu: [<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                    submenu: [],<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>            ],<EOL>        },<EOL>        file: {<EOL>            localizedLabel: [\"<STR_LIT>\"],<EOL>            submenu: [<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: runtime.platform === \"<STR_LIT>\" ? \"<STR_LIT>\" : \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>            ],<EOL>        },<EOL>        fileMac: {<EOL>            localizedLabel: [\"<STR_LIT>\"],<EOL>            submenu: [<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: runtime.platform === \"<STR_LIT>\" ? \"<STR_LIT>\" : \"<STR_LIT>\",<EOL>                },<EOL>            ],<EOL>        },<EOL>        edit: {<EOL>            localizedLabel: [\"<STR_LIT>\"],<EOL>            visible: false,<EOL>            submenu: [<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>            ],<EOL>        },<EOL>","gt":"view: {"}
{"input":"<s> function computeMenuTemplate(appVersion: string, credentials: ISessionCredentialsState, runtime: IRuntime): IMenuTemplate {<EOL>    const menus: IAllTemplates = {<EOL>        mainMac: {<EOL>            <EOL>            submenu: [<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                    submenu: [],<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>            ],<EOL>        },<EOL>        file: {<EOL>            localizedLabel: [\"<STR_LIT>\"],<EOL>            submenu: [<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: runtime.platform === \"<STR_LIT>\" ? \"<STR_LIT>\" : \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>            ],<EOL>        },<EOL>        fileMac: {<EOL>            localizedLabel: [\"<STR_LIT>\"],<EOL>            submenu: [<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: runtime.platform === \"<STR_LIT>\" ? \"<STR_LIT>\" : \"<STR_LIT>\",<EOL>                },<EOL>            ],<EOL>        },<EOL>        edit: {<EOL>            localizedLabel: [\"<STR_LIT>\"],<EOL>            visible: false,<EOL>            submenu: [<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>            ],<EOL>        },<EOL>        view: {<EOL>            localizedLabel: [\"<STR_LIT>\"],<EOL>            submenu: [<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>            ],<EOL>        },<EOL>        accountLoggedOut: {<EOL>            localizedLabel: [\"<STR_LIT>\"],<EOL>            submenu: [<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    enabled: false,<EOL>                },<EOL>            ],<EOL>        },<EOL>        account: {<EOL>            localizedLabel: [\"<STR_LIT>\"],<EOL>            submenu: [<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                },<EOL>            ],<EOL>        },<EOL>        help: {<EOL>","gt":"localizedLabel: [\"<STR_LIT>\"],"}
{"input":"<s> function computeMenuTemplate(appVersion: string, credentials: ISessionCredentialsState, runtime: IRuntime): IMenuTemplate {<EOL>    const menus: IAllTemplates = {<EOL>        mainMac: {<EOL>            <EOL>            submenu: [<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                    submenu: [],<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>            ],<EOL>        },<EOL>        file: {<EOL>            localizedLabel: [\"<STR_LIT>\"],<EOL>            submenu: [<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: runtime.platform === \"<STR_LIT>\" ? \"<STR_LIT>\" : \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>            ],<EOL>        },<EOL>        fileMac: {<EOL>            localizedLabel: [\"<STR_LIT>\"],<EOL>            submenu: [<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: runtime.platform === \"<STR_LIT>\" ? \"<STR_LIT>\" : \"<STR_LIT>\",<EOL>                },<EOL>            ],<EOL>        },<EOL>        edit: {<EOL>            localizedLabel: [\"<STR_LIT>\"],<EOL>            visible: false,<EOL>            submenu: [<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>            ],<EOL>        },<EOL>        view: {<EOL>            localizedLabel: [\"<STR_LIT>\"],<EOL>            submenu: [<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>            ],<EOL>        },<EOL>        accountLoggedOut: {<EOL>            localizedLabel: [\"<STR_LIT>\"],<EOL>            submenu: [<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    enabled: false,<EOL>                },<EOL>            ],<EOL>        },<EOL>        account: {<EOL>            localizedLabel: [\"<STR_LIT>\"],<EOL>            submenu: [<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                },<EOL>            ],<EOL>        },<EOL>        help: {<EOL>            localizedLabel: [\"<STR_LIT>\"],<EOL>            role: \"<STR_LIT>\",<EOL>            submenu: [<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                },<EOL>                {<EOL>                    label:","gt":"appVersion}`<STR_LIT>,"}
{"input":"<s> function computeMenuTemplate(appVersion: string, credentials: ISessionCredentialsState, runtime: IRuntime): IMenuTemplate {<EOL>    const menus: IAllTemplates = {<EOL>        mainMac: {<EOL>            <EOL>            submenu: [<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                    submenu: [],<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>            ],<EOL>        },<EOL>        file: {<EOL>            localizedLabel: [\"<STR_LIT>\"],<EOL>            submenu: [<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: runtime.platform === \"<STR_LIT>\" ? \"<STR_LIT>\" : \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>            ],<EOL>        },<EOL>        fileMac: {<EOL>            localizedLabel: [\"<STR_LIT>\"],<EOL>            submenu: [<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: runtime.platform === \"<STR_LIT>\" ? \"<STR_LIT>\" : \"<STR_LIT>\",<EOL>                },<EOL>            ],<EOL>        },<EOL>        edit: {<EOL>            localizedLabel: [\"<STR_LIT>\"],<EOL>            visible: false,<EOL>            submenu: [<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>            ],<EOL>        },<EOL>        view: {<EOL>            localizedLabel: [\"<STR_LIT>\"],<EOL>            submenu: [<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>            ],<EOL>        },<EOL>        accountLoggedOut: {<EOL>            localizedLabel: [\"<STR_LIT>\"],<EOL>            submenu: [<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    enabled: false,<EOL>                },<EOL>            ],<EOL>        },<EOL>        account: {<EOL>            localizedLabel: [\"<STR_LIT>\"],<EOL>            submenu: [<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                },<EOL>            ],<EOL>        },<EOL>        help: {<EOL>            localizedLabel: [\"<STR_LIT>\"],<EOL>            role: \"<STR_LIT>\",<EOL>            submenu: [<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                },<EOL>                {<EOL>                    label: `<STR_LIT>`,<EOL>                    enabled: false,<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [","gt":"\"<STR_LIT>\"],"}
{"input":"<s> function computeMenuTemplate(appVersion: string, credentials: ISessionCredentialsState, runtime: IRuntime): IMenuTemplate {<EOL>    const menus: IAllTemplates = {<EOL>        mainMac: {<EOL>            <EOL>            submenu: [<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                    submenu: [],<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>            ],<EOL>        },<EOL>        file: {<EOL>            localizedLabel: [\"<STR_LIT>\"],<EOL>            submenu: [<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: runtime.platform === \"<STR_LIT>\" ? \"<STR_LIT>\" : \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>            ],<EOL>        },<EOL>        fileMac: {<EOL>            localizedLabel: [\"<STR_LIT>\"],<EOL>            submenu: [<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: runtime.platform === \"<STR_LIT>\" ? \"<STR_LIT>\" : \"<STR_LIT>\",<EOL>                },<EOL>            ],<EOL>        },<EOL>        edit: {<EOL>            localizedLabel: [\"<STR_LIT>\"],<EOL>            visible: false,<EOL>            submenu: [<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>            ],<EOL>        },<EOL>        view: {<EOL>            localizedLabel: [\"<STR_LIT>\"],<EOL>            submenu: [<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>            ],<EOL>        },<EOL>        accountLoggedOut: {<EOL>            localizedLabel: [\"<STR_LIT>\"],<EOL>            submenu: [<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    enabled: false,<EOL>                },<EOL>            ],<EOL>        },<EOL>        account: {<EOL>            localizedLabel: [\"<STR_LIT>\"],<EOL>            submenu: [<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                },<EOL>            ],<EOL>        },<EOL>        help: {<EOL>            localizedLabel: [\"<STR_LIT>\"],<EOL>            role: \"<STR_LIT>\",<EOL>            submenu: [<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                },<EOL>                {<EOL>                    label: `<STR_LIT>`,<EOL>                    enabled: false,<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                },<EOL>                {<EOL>","gt":"localizedLabel: [\"<STR_LIT>\"],"}
{"input":"<s> function computeMenuTemplate(appVersion: string, credentials: ISessionCredentialsState, runtime: IRuntime): IMenuTemplate {<EOL>    const menus: IAllTemplates = {<EOL>        mainMac: {<EOL>            <EOL>            submenu: [<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                    submenu: [],<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>            ],<EOL>        },<EOL>        file: {<EOL>            localizedLabel: [\"<STR_LIT>\"],<EOL>            submenu: [<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: runtime.platform === \"<STR_LIT>\" ? \"<STR_LIT>\" : \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>            ],<EOL>        },<EOL>        fileMac: {<EOL>            localizedLabel: [\"<STR_LIT>\"],<EOL>            submenu: [<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: runtime.platform === \"<STR_LIT>\" ? \"<STR_LIT>\" : \"<STR_LIT>\",<EOL>                },<EOL>            ],<EOL>        },<EOL>        edit: {<EOL>            localizedLabel: [\"<STR_LIT>\"],<EOL>            visible: false,<EOL>            submenu: [<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>            ],<EOL>        },<EOL>        view: {<EOL>            localizedLabel: [\"<STR_LIT>\"],<EOL>            submenu: [<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>            ],<EOL>        },<EOL>        accountLoggedOut: {<EOL>            localizedLabel: [\"<STR_LIT>\"],<EOL>            submenu: [<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    enabled: false,<EOL>                },<EOL>            ],<EOL>        },<EOL>        account: {<EOL>            localizedLabel: [\"<STR_LIT>\"],<EOL>            submenu: [<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                },<EOL>            ],<EOL>        },<EOL>        help: {<EOL>            localizedLabel: [\"<STR_LIT>\"],<EOL>            role: \"<STR_LIT>\",<EOL>            submenu: [<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                },<EOL>                {<EOL>                    label: `<STR_LIT>`,<EOL>                    enabled: false,<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                },<EOL>                {<EOL>","gt":"type: \"<STR_LIT>\","}
{"input":"<s> function computeMenuTemplate(appVersion: string, credentials: ISessionCredentialsState, runtime: IRuntime): IMenuTemplate {<EOL>    const menus: IAllTemplates = {<EOL>        mainMac: {<EOL>            <EOL>            submenu: [<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                    submenu: [],<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>            ],<EOL>        },<EOL>        file: {<EOL>            localizedLabel: [\"<STR_LIT>\"],<EOL>            submenu: [<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: runtime.platform === \"<STR_LIT>\" ? \"<STR_LIT>\" : \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>            ],<EOL>        },<EOL>        fileMac: {<EOL>            localizedLabel: [\"<STR_LIT>\"],<EOL>            submenu: [<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: runtime.platform === \"<STR_LIT>\" ? \"<STR_LIT>\" : \"<STR_LIT>\",<EOL>                },<EOL>            ],<EOL>        },<EOL>        edit: {<EOL>            localizedLabel: [\"<STR_LIT>\"],<EOL>            visible: false,<EOL>            submenu: [<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                    role: \"<STR_LIT>\",<EOL>                },<EOL>            ],<EOL>        },<EOL>        view: {<EOL>            localizedLabel: [\"<STR_LIT>\"],<EOL>            submenu: [<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    accelerator: \"<STR_LIT>\",<EOL>                },<EOL>            ],<EOL>        },<EOL>        accountLoggedOut: {<EOL>            localizedLabel: [\"<STR_LIT>\"],<EOL>            submenu: [<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                    enabled: false,<EOL>                },<EOL>            ],<EOL>        },<EOL>        account: {<EOL>            localizedLabel: [\"<STR_LIT>\"],<EOL>            submenu: [<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                },<EOL>            ],<EOL>        },<EOL>        help: {<EOL>            localizedLabel: [\"<STR_LIT>\"],<EOL>            role: \"<STR_LIT>\",<EOL>            submenu: [<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                },<EOL>                {<EOL>                    label: `<STR_LIT>`,<EOL>                    enabled: false,<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                },<EOL>                {<EOL>                    type: \"<STR_LIT>\",<EOL>                },<EOL>                {<EOL>                    localizedLabel: [\"<STR_LIT>\"],<EOL>                },<EOL>            ],<EOL>        },<EOL>    };<EOL>    const","gt":"template: IMenuTemplate = [];"}
{"input":"<s> <EOL><EOL>export async function promisedModal<Params, Response>(store: IStore, payload: ITypedModal<Params, Response>): Promise<Response> {<EOL>    const modalAction: import(\"<STR_LIT>\").IAction<ITypedModal<any, any>> = actions.openModal(payload);<EOL>    const { id } = modalAction.payload;<EOL>","gt":"const p: Promise<any> = new Promise<any>((resolve: (value: any) => void): void => {"}
{"input":"<s> function err(e: Error, action: IAction<any>): void {<EOL>    if (isCancelled(e)) {<EOL>        console.","gt":"warn(`<STR_LIT>`);"}
{"input":"<s> async function setup(store: IStore, db: DB): Promise<void> {<EOL>    const ctx: Context = new Context(store, db);<EOL>","gt":"logger.info(\"<STR_LIT>\");"}
{"input":"<s> export default function (watcher: Watcher): void {<EOL>    watcher.on(actions.commandMain, async (store: import(\"<STR_LIT>\").IStore, action: import(\"<STR_LIT>\").IAction<{}>): Promise<void> => {<EOL>        const { tab } = store.getState().session.navigation;<EOL>        const sp: Space = Space.fromStore(store, tab);<EOL>        if (","gt":"sp.prefix === \"<STR_LIT>\") {"}
{"input":"<s> export default function (watcher: Watcher): void {<EOL>    watcher.on(actions.commandMain, async (store: import(\"<STR_LIT>\").IStore, action: import(\"<STR_LIT>\").IAction<{}>): Promise<void> => {<EOL>        const { tab } = store.getState().session.navigation;<EOL>        const sp: Space = Space.fromStore(store, tab);<EOL>        if (sp.prefix === \"<STR_LIT>\") {<EOL>","gt":"const game: import(\"<STR_LIT>\").Game = sp.game();"}
{"input":"<s> export default function (watcher: Watcher): void {<EOL>    watcher.on(actions.commandMain, async (store: import(\"<STR_LIT>\").IStore, action: import(\"<STR_LIT>\").IAction<{}>): Promise<void> => {<EOL>        const { tab } = store.getState().session.navigation;<EOL>        const sp: Space = Space.fromStore(store, tab);<EOL>        if (sp.prefix === \"<STR_LIT>\") {<EOL>            const game: import(\"<STR_LIT>\").Game = sp.game();<EOL>            if (game) {<EOL>                <EOL>                <EOL>                <EOL>                store.dispatch(actions.queueGame({ game }));<EOL>            }<EOL>        }<EOL>    });<EOL>    watcher.on(actions.commandMain, async (store: import(\"<STR_LIT>\").IStore, action: import(\"<STR_LIT>\").IAction<{}>): Promise<void> => {<EOL>        const modals: import(\"<STR_LIT>\").IModalsState = store.getState().modals;<EOL>        const modal:","gt":"import(\"<STR_LIT>\").IModal = modals[<NUM_LIT>];"}
{"input":"<s> export default function (watcher: Watcher): void {<EOL>    watcher.on(actions.commandMain, async (store: import(\"<STR_LIT>\").IStore, action: import(\"<STR_LIT>\").IAction<{}>): Promise<void> => {<EOL>        const { tab } = store.getState().session.navigation;<EOL>        const sp: Space = Space.fromStore(store, tab);<EOL>        if (sp.prefix === \"<STR_LIT>\") {<EOL>            const game: import(\"<STR_LIT>\").Game = sp.game();<EOL>            if (game) {<EOL>                <EOL>                <EOL>                <EOL>                store.dispatch(actions.queueGame({ game }));<EOL>            }<EOL>        }<EOL>    });<EOL>    watcher.on(actions.commandMain, async (store: import(\"<STR_LIT>\").IStore, action: import(\"<STR_LIT>\").IAction<{}>): Promise<void> => {<EOL>        const modals: import(\"<STR_LIT>\").IModalsState = store.getState().modals;<EOL>        const modal: import(\"<STR_LIT>\").IModal = modals[<NUM_LIT>];<EOL>        if (modal) {<EOL>            return;<EOL>        }<EOL>        const page: string = store.getState().session.navigation.page;<EOL>        const picking: boolean = store.getState().session.","gt":"login.picking;"}
{"input":"<s> function withWebContents<T>(store: IStore, tab: string, cb: WebContentsCallback<T>): T {<EOL>    const sp: Space = Space.fromStore(store, tab);<EOL>    const { webContentsId } = sp.web();<EOL>    if (!webContentsId) {<EOL>","gt":"return;"}
{"input":"<s> function withWebContents<T>(store: IStore, tab: string, cb: WebContentsCallback<T>): T {<EOL>    const sp: Space = Space.fromStore(store, tab);<EOL>    const { webContentsId } = sp.web();<EOL>    if (!webContentsId) {<EOL>        return;<EOL>    }<EOL>    const wc: Electron.WebContents = webContents.fromId(webContentsId);<EOL>    if (!wc || wc.isDestroyed()) {<EOL>","gt":"return;"}
{"input":"<s> <EOL>async function cp(opts: ICpOpts): Promise<unknown> {<EOL>    const { src, dest } = opts;<EOL>    const args:","gt":"string[] = [src, dest];"}
{"input":"<s> function getArchiveName(name: string): string {<EOL>    let formula: IFormulaSpec = formulas[name];<EOL>    if (formula.format === \"<STR_LIT>\") {<EOL>","gt":"return `<STR_LIT>`;"}
{"input":"<s> <EOL>export function NOOP_FALSE(): boolean {<EOL>    return","gt":"false;"}
{"input":"<s> <EOL>export function getEventCharCode(ev: KeyboardEvent): number {<EOL>    const keyCode: number = ev.keyCode;<EOL>    let charCode: number = ev.charCode;<EOL>    if (","gt":"charCode === <NUM_LIT> && keyCode === <NUM_LIT>) {"}
{"input":"<s> export function onAbort(handler: (ev: SyntheticUIEvent<UIEvent>) => void, capture = false): EventHandler<SyntheticUIEvent<UIEvent>> {<EOL>    return createEventHandler<SyntheticUIEvent<UIEvent>>(EventSourceAbort.","gt":"eventSource, handler, capture);"}
{"input":"<s> export function onDragEnd(handler: (ev: SyntheticDragEvent) => void, capture = false): EventHandler<SyntheticDragEvent> {<EOL>    return createEventHandler<SyntheticDragEvent>(EventSourceDragEnd.","gt":"eventSource, handler, capture);"}
{"input":"<s> export function onInput(handler: (ev: SyntheticNativeEvent<Event>) => void, capture = false): EventHandler<SyntheticNativeEvent<Event>> {<EOL>    return createEventHandler<SyntheticNativeEvent<Event>>(EventSourceInput.","gt":"eventSource, handler, capture);"}
{"input":"<s> export function onSubmit(handler: (ev: SyntheticNativeEvent<Event>) => void, capture = false): EventHandler<SyntheticNativeEvent<Event>> {<EOL>    return","gt":"createEventHandler<SyntheticNativeEvent<Event>>(EventSourceSubmit.eventSource, handler, capture);"}
{"input":"<s> export function dispatchMoveEventToRecognizers(event: GesturePointerEvent): void {<EOL>    if (arena.winner === null) {<EOL>        for (let i: number = <NUM_LIT>; i < arena.recognizers.length; ++i) {<EOL>            const recognizer: GestureRecognizer | null = arena.recognizers[i];<EOL>            if (recognizer !==","gt":"null) {"}
{"input":"<s> export function dispatchMoveEventToRecognizers(event: GesturePointerEvent): void {<EOL>    if (arena.winner === null) {<EOL>        for (let i: number = <NUM_LIT>; i < arena.recognizers.length; ++i) {<EOL>            const recognizer: GestureRecognizer | null = arena.recognizers[i];<EOL>            if (recognizer !== null) {<EOL>                recognizer.pointerMoved(event);<EOL>            }<EOL>        }<EOL>    }<EOL>","gt":"else {"}
{"input":"<s> export function pointerMapGet<T>(map: PointerMap<T>, id: number): T | undefined {<EOL>    for (let i: number = <NUM_LIT>; i < map.length; ++i) {<EOL>        const item: PointerMapEntry<T> = map[i];<EOL>        if (item.id ===","gt":"id) {"}
{"input":"<s> export function pointerMapListPush<T>(map: PointerMapList<T>, id: number, value: T): void {<EOL>    for (let i: number = <NUM_LIT>; i < map.length; ++i) {<EOL>        const item: PointerMapEntry<T[]> = map[i];<EOL>        if (item.id === id) {<EOL>            item.","gt":"value.push(value);"}
{"input":"<s> export function pointerMapListPush<T>(map: PointerMapList<T>, id: number, value: T): void {<EOL>    for (let i: number = <NUM_LIT>; i < map.length; ++i) {<EOL>        const item: PointerMapEntry<T[]> = map[i];<EOL>        if (item.id === id) {<EOL>            item.value.push(value);<EOL>            return;<EOL>        }<EOL>    }<EOL>    map.push({<EOL>","gt":"id,"}
{"input":"<s> export function createVelocityTracker(): VelocityTracker {<EOL>    return {<EOL>        samples: new Array<PointAtTime | null>(HISTORY_SIZE).fill(","gt":"null),"}
{"input":"<s> <EOL>export function circle(className?: string): VNode<SVGCircleElementProps | null, SVGCircleElement> {<EOL>    return new VNode(","gt":"VNodeFlags.Element | VNodeFlags.SvgElement, \"<STR_LIT>\", null, className === undefined ? null : className, null);"}
{"input":"<s> export function colgroup(className?: string): VNode<HTMLTableColElementProps | null, HTMLTableColElement> {<EOL>    return new VNode(VNodeFlags.Element, \"<STR_LIT>\", null, className === undefined ? null : className,","gt":"null);"}
{"input":"<s> export function fepointlight(className?: string): VNode<SVGFEPointLightElementProps | null, SVGFEPointLightElement> {<EOL>","gt":"return new VNode(VNodeFlags.Element | VNodeFlags.SvgElement, \"<STR_LIT>\", null, className === undefined ? null : className, null);"}
{"input":"<s> export function font(className?: string): VNode<HTMLFontElementProps | null, HTMLFontElement> {<EOL>    return new VNode(VNodeFlags.Element, \"<STR_LIT>\", null, className ===","gt":"undefined ? null : className, null);"}
{"input":"<s> export function hr(className?: string): VNode<HTMLHRElementProps | null, HTMLHRElement> {<EOL>    return new VNode(VNodeFlags.Element |","gt":"VNodeFlags.VoidElement, \"<STR_LIT>\", null, className === undefined ? null : className, null);"}
{"input":"<s> export function inputHidden(className?: string): VNode<HTMLInputElementProps | null, HTMLInputElement> {<EOL>    return","gt":"new VNode(VNodeFlags.Element | VNodeFlags.InputElement | VNodeFlags.VoidElement, \"<STR_LIT>\", null, className === undefined ? null : className, null);"}
{"input":"<s> export function inputWeek(className?: string): VNode<HTMLInputElementProps | null, HTMLInputElement> {<EOL>    return new VNode(VNodeFlags.Element | VNodeFlags.InputElement | VNodeFlags.VoidElement,","gt":"\"<STR_LIT>\", null, className === undefined ? null : className, null);"}
{"input":"<s> export function ins(className?: string): VNode<HTMLModElementProps | null, HTMLModElement> {<EOL>    return new VNode(VNodeFlags.","gt":"Element, \"<STR_LIT>\", null, className === undefined ? null : className, null);"}
{"input":"<s> export function kbd(className?: string): VNode<HTMLElementProps | null, HTMLElement> {<EOL>    return new VNode(VNodeFlags.Element, \"<STR_LIT>\", null, className === undefined ?","gt":"null : className, null);"}
{"input":"<s> export function noscript(className?: string): VNode<HTMLElementProps | null, HTMLElement> {<EOL>    return new VNode(VNodeFlags.","gt":"Element, \"<STR_LIT>\", null, className === undefined ? null : className, null);"}
{"input":"<s> export function option(className?: string): VNode<HTMLOptionElementProps | null, HTMLOptionElement> {<EOL>","gt":"return new VNode(VNodeFlags.Element, \"<STR_LIT>\", null, className === undefined ? null : className, null);"}
{"input":"<s> export function stop(className?: string): VNode<SVGStopElementProps | null, SVGStopElement> {<EOL>    return new VNode(","gt":"VNodeFlags.Element | VNodeFlags.SvgElement, \"<STR_LIT>\", null, className === undefined ? null : className, null);"}
{"input":"<s> export function table(className?: string): VNode<HTMLTableElementProps | null, HTMLTableElement> {<EOL>    return new VNode(","gt":"VNodeFlags.Element, \"<STR_LIT>\", null, className === undefined ? null : className, null);"}
{"input":"<s> export function td(className?: string): VNode<HTMLTableDataCellElementProps | null, HTMLTableDataCellElement> {<EOL>    return new VNode(VNodeFlags.","gt":"Element, \"<STR_LIT>\", null, className === undefined ? null : className, null);"}
{"input":"<s> export function use(className?: string): VNode<SVGUseElementProps | null, SVGUseElement> {<EOL>","gt":"return new VNode(VNodeFlags.Element | VNodeFlags.SvgElement, \"<STR_LIT>\", null, className === undefined ? null : className, null);"}
{"input":"<s> export function vec2Negate(v: Vec2): Vec2 {<EOL>    return vec2(-v.x, -v.","gt":"y);"}
{"input":"<s> <EOL>export function addAnimation(animation: () => boolean | undefined): void {<EOL>","gt":"_animations.add(animation);"}
{"input":"<s> <EOL>export function clock(): number {<EOL>","gt":"return _clock;"}
{"input":"<s> function createFrameTasksGroup(): FrameTasksGroup {<EOL>    return {<EOL>        flags:","gt":"<NUM_LIT>,"}
{"input":"<s> function _findVNode(match: (vnode: VNode) => boolean, vnode: VNode): VNode | null {<EOL>    if (match(vnode) === true) {<EOL>        return vnode;<EOL>    }<EOL>    if ((vnode._flags & (VNodeFlags.Element | VNodeFlags.Text)) !== <NUM_LIT>) {<EOL>        if ((vnode.","gt":"_flags & VNodeFlags.Element) !== <NUM_LIT>) {"}
{"input":"<s> function _findVNode(match: (vnode: VNode) => boolean, vnode: VNode): VNode | null {<EOL>    if (match(vnode) === true) {<EOL>        return vnode;<EOL>    }<EOL>    if ((vnode._flags & (VNodeFlags.Element | VNodeFlags.Text)) !== <NUM_LIT>) {<EOL>        if ((vnode._flags & VNodeFlags.Element) !== <NUM_LIT>) {<EOL>            if (vnode._children !== null) {<EOL>                if ((vnode._flags & VNodeFlags.ChildrenArray) !==","gt":"<NUM_LIT>) {"}
{"input":"<s> <EOL>export function setDevModeFlags(flags: DevModeFlags): void {<EOL>","gt":"if (DEV) {"}
{"input":"<s> <EOL>function setHTMLInputValue(input: HTMLInputElement, value: string | boolean | null): void {<EOL>    if (typeof value === \"<STR_LIT>\") {<EOL>        input.","gt":"value = value;"}
{"input":"<s> <EOL>export function createBlueprint(node: VNode, context: Context = {}, blueprint?: BlueprintNode): BlueprintNode {<EOL>","gt":"throw new Error(\"<STR_LIT>\");"}
{"input":"<s> <EOL>export function a(className?: string): VNode<HTMLAnchorElementProps | null> {<EOL>    return new VNode(VNodeFlags.Element, \"<STR_LIT>\", null,","gt":"className === undefined ? null : className, null, \"<STR_LIT>\");"}
{"input":"<s> export function b(className?: string): VNode<HTMLElementProps | null> {<EOL>    return new","gt":"VNode(VNodeFlags.Element, \"<STR_LIT>\", null, className === undefined ? null : className, null, \"<STR_LIT>\");"}
{"input":"<s> export function dd(className?: string): VNode<HTMLElementProps | null> {<EOL>    return new VNode(VNodeFlags.Element, \"<STR_LIT>\", null, className === undefined ?","gt":"null : className, null, \"<STR_LIT>\");"}
{"input":"<s> export function h3(className?: string): VNode<HTMLHeadingElementProps | null> {<EOL>    return new VNode(VNodeFlags.Element, \"<STR_LIT>\", null, className === undefined ? null : className,","gt":"null, \"<STR_LIT>\");"}
{"input":"<s> export function inputPassword(className?: string): VNode<HTMLInputElementProps | null> {<EOL>    return new","gt":"VNode(VNodeFlags.Element | VNodeFlags.InputElement | VNodeFlags.VoidElement, `<STR_LIT>`, null, className === undefined ? null : className, null, null);"}
{"input":"<s> export function inputRadio(className?: string): VNode<HTMLInputElementProps | null> {<EOL>    return new VNode(VNodeFlags.Element | VNodeFlags.InputElement | VNodeFlags.VoidElement, `<STR_LIT>`, null, className === undefined ? null : className,","gt":"null, null);"}
{"input":"<s> export function sub(className?: string): VNode<HTMLElementProps | null> {<EOL>    return new VNode(VNodeFlags.Element, \"<STR_LIT>\", null, className === undefined ? null : className,","gt":"null, \"<STR_LIT>\");"}
{"input":"<s> <EOL>export function getElementClassNameFromVNode(node: VNode<any>): string | null {<EOL>    return node.","gt":"_className;"}
{"input":"<s> <EOL>export function isComponentVNode(node: VNode<any>): boolean {<EOL>    return (node._flags &","gt":"VNodeFlags.Component) !== <NUM_LIT>;"}
{"input":"<s> export function discard(className?: string): VNode<SVGElementProps | null> {<EOL>    return new VNode(VNodeFlags.Element | VNodeFlags.SvgElement, \"<STR_LIT>\", null, className === undefined ?","gt":"null : className, null, \"<STR_LIT>\");"}
{"input":"<s> export function feDiffuseLighting(className?: string): VNode<SVGFEDiffuseLightingElementProps | null> {<EOL>    return new VNode(VNodeFlags.Element | VNodeFlags.SvgElement, \"<STR_LIT>\",","gt":"null, className === undefined ? null : className, null, \"<STR_LIT>\");"}
{"input":"<s> export function feMorphology(className?: string): VNode<SVGFEMorphologyElementProps | null> {<EOL>    return new VNode(","gt":"VNodeFlags.Element | VNodeFlags.SvgElement, \"<STR_LIT>\", null, className === undefined ? null : className, null, \"<STR_LIT>\");"}
{"input":"<s> export function mask(className?: string): VNode<SVGMaskElementProps | null> {<EOL>","gt":"return new VNode(VNodeFlags.Element | VNodeFlags.SvgElement, \"<STR_LIT>\", null, className === undefined ? null : className, null, \"<STR_LIT>\");"}
{"input":"<s> export function mesh(className?: string): VNode<SVGElementProps | null> {<EOL>    return new VNode(VNodeFlags.Element |","gt":"VNodeFlags.SvgElement, \"<STR_LIT>\", null, className === undefined ? null : className, null, \"<STR_LIT>\");"}
{"input":"<s> export function svg(className?: string): VNode<SVGSVGElementProps | null> {<EOL>    return new VNode(VNodeFlags.Element | VNodeFlags.","gt":"SvgElement, \"<STR_LIT>\", null, className === undefined ? null : className, null, \"<STR_LIT>\");"}
{"input":"<s> export function title(className?: string): VNode<SVGElementProps | null> {<EOL>    return new VNode(VNodeFlags.Element | VNodeFlags.SvgElement, \"<STR_LIT>\", null, className === undefined ? null : className,","gt":"null, \"<STR_LIT>\");"}
{"input":"<s> export function circle(className?: string): VNode<SVGCircleElementProps | null> {<EOL>    return new VNode(VNodeFlags.Element | VNodeFlags.SvgElement, \"<STR_LIT>\", null, className === undefined ?","gt":"null : className, null, \"<STR_LIT>\");"}
{"input":"<s> export function colorProfile(className?: string): VNode<SVGElementProps | null, SVGElement> {<EOL>    return new VNode(VNodeFlags.Element | VNodeFlags.SvgElement, \"<STR_LIT>\", null, className === undefined ? null :","gt":"className, null);"}
{"input":"<s> export function currentFrameRead(task: () => void): void {<EOL>    if ((_flags & SchedulerFlags.CurrentFrameReady) !== <NUM_LIT>) {<EOL>        addFrameTaskRead(_currentFrame,","gt":"task);"}
{"input":"<s> export function nextFrameAfter(task: () => void): void {<EOL>","gt":"requestNextFrame();"}
{"input":"<s> <EOL>export function requestNextFrame(): void {<EOL>    if ((_flags & SchedulerFlags.","gt":"NextFramePending) === <NUM_LIT>) {"}
{"input":"<s> export function hasPrevSibling(wrapper: VNodeWrapper, predicate: Predicate<VNodeWrapper>): boolean {<EOL>    const parent: VNodeWrapper | null = wrapper.parent;<EOL>    if (parent !== null && (parent.vnode._flags & VNodeFlags.ChildrenArray) !== <NUM_LIT>) {<EOL>        const children: VNode[] = parent.vnode._children as VNode[];<EOL>        let","gt":"prev: VNode | null = null;"}
{"input":"<s> export function hasPrevSibling(wrapper: VNodeWrapper, predicate: Predicate<VNodeWrapper>): boolean {<EOL>    const parent: VNodeWrapper | null = wrapper.parent;<EOL>    if (parent !== null && (parent.vnode._flags & VNodeFlags.ChildrenArray) !== <NUM_LIT>) {<EOL>        const children: VNode[] = parent.vnode._children as VNode[];<EOL>        let prev: VNode | null = null;<EOL>        for (let i: number = <NUM_LIT>; i < children.length; i++) {<EOL>            const c: VNode = children[i];<EOL>            if (wrapper.vnode === c) {<EOL>                return (prev !== null && predicate(new VNodeWrapper(prev, parent, wrapper.context)) === true);<EOL>            }<EOL>            prev =","gt":"c;"}
{"input":"<s> export function clippath(className?: string): VNode<SVGClipPathElementProps | null, SVGClipPathElement> {<EOL>    return new VNode(VNodeFlags.Element | VNodeFlags.SvgElement, \"<STR_LIT>\", null,","gt":"className === undefined ? null : className, null);"}
{"input":"<s> export function ellipse(className?: string): VNode<SVGEllipseElementProps | null, SVGEllipseElement> {<EOL>    return new VNode(VNodeFlags.Element |","gt":"VNodeFlags.SvgElement, \"<STR_LIT>\", null, className === undefined ? null : className, null);"}
{"input":"<s> export function embed(className?: string): VNode<HTMLEmbedElementProps | null, HTMLEmbedElement> {<EOL>    return new VNode(","gt":"VNodeFlags.Element | VNodeFlags.VoidElement, \"<STR_LIT>\", null, className === undefined ? null : className, null);"}
{"input":"<s> export function fefunca(className?: string): VNode<SVGFEFuncAElementProps | null, SVGFEFuncAElement> {<EOL>    return new VNode(VNodeFlags.","gt":"Element | VNodeFlags.SvgElement, \"<STR_LIT>\", null, className === undefined ? null : className, null);"}
{"input":"<s> export function h5(className?: string): VNode<HTMLHeadingElementProps | null, HTMLHeadingElement> {<EOL>    return new VNode(VNodeFlags.Element, \"<STR_LIT>\",","gt":"null, className === undefined ? null : className, null);"}
{"input":"<s> export function head(className?: string): VNode<HTMLHeadElementProps | null, HTMLHeadElement> {<EOL>    return new VNode(VNodeFlags.Element, \"<STR_LIT>\", null,","gt":"className === undefined ? null : className, null);"}
{"input":"<s> export function inputNumber(className?: string): VNode<HTMLInputElementProps | null, HTMLInputElement> {<EOL>    return","gt":"new VNode(VNodeFlags.Element | VNodeFlags.InputElement | VNodeFlags.VoidElement, \"<STR_LIT>\", null, className === undefined ? null : className, null);"}
{"input":"<s> export function inputSubmit(className?: string): VNode<HTMLInputElementProps | null, HTMLInputElement> {<EOL>    return new VNode(VNodeFlags.Element | VNodeFlags.InputElement | VNodeFlags.VoidElement, \"<STR_LIT>\", null, className === undefined ? null :","gt":"className, null);"}
{"input":"<s> export function label(className?: string): VNode<HTMLLabelElementProps | null, HTMLLabelElement> {<EOL>    return new VNode(VNodeFlags.Element, \"<STR_LIT>\", null,","gt":"className === undefined ? null : className, null);"}
{"input":"<s> export function isContractParameterHash(type: Hash): type is ContractParameterHash {<EOL>    return","gt":"isContractParameterType(type.inputType);"}
{"input":"<s> export function operationsToString(ops: Operation[]): string {<EOL>    return ops.map(operationToString).join(","gt":"\"<STR_LIT>\");"}
{"input":"<s> function pushResult(stack: Stack): void {<EOL>","gt":"stack.push(\"<STR_LIT>\");"}
{"input":"<s> function createAnnouncerDiv(): any {<EOL>    if (announcerDiv) {<EOL>        return announcerDiv;<EOL>    }<EOL>    announcerDiv = document.createElement('<STR_LIT>');<EOL>","gt":"announcerDiv.id = announcerId;"}
{"input":"<s> function createAnnouncerDiv(): any {<EOL>    if (announcerDiv) {<EOL>        return announcerDiv;<EOL>    }<EOL>    announcerDiv = document.createElement('<STR_LIT>');<EOL>    announcerDiv.id = announcerId;<EOL>    announcerDiv.setAttribute('<STR_LIT>', '<STR_LIT>');<EOL>    let style: any = announcerDiv.style;<EOL>    style.position = '<STR_LIT>';<EOL>    style.left = '<STR_LIT>';<EOL>    style.top = '<STR_LIT>';<EOL>    style.","gt":"width = '<STR_LIT>';"}
{"input":"<s> function compareStrings(a: any, b: any): number {<EOL>    return (a < b ? -<NUM_LIT> : (a >","gt":"b ? <NUM_LIT> : <NUM_LIT>));"}
{"input":"<s> <EOL><EOL>function escapeRegExp(value: any): any {<EOL>    return value.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g,","gt":"\"<STR_LIT>\");"}
{"input":"<s> <EOL>export function removeChildren(node: Node): void {<EOL>    while (node.","gt":"lastChild) {"}
{"input":"<s> <EOL>export function ConsoleOutputDisableExpressionTemplate(): string {<EOL>","gt":"return `<STR_LIT>`"}
{"input":"<s> <EOL>export function DebugProtectionFunctionCallTemplate(): string {<EOL>","gt":"return `<STR_LIT>`"}
{"input":"<s> <EOL>export function Rc4Template(): string {<EOL>","gt":"return `<STR_LIT>`"}
{"input":"<s> function fix(_settings: eclint.ISettings, document: doc.IDocument): doc.IDocument {<EOL>    return","gt":"document;"}
{"input":"<s> export function fakeTypeDefSource(): ITypeDefinitionSource {<EOL>    return {<EOL>        fetch: (): Promise<ITypeDefinition[]> => delay(<NUM_LIT>).","gt":"then((): ITypeDefinition[] => typedefs),"}
{"input":"<s> export default function (indent: number): string {<EOL>    return Array(indent * <NUM_LIT> + <NUM_LIT>).","gt":"join(\"<STR_LIT>\");"}
{"input":"<s> export function failingItName(): any {<EOL>    return window.createTextEditorDecorationType({<EOL>        overviewRulerColor: '<STR_LIT>',<EOL>        overviewRulerLane: OverviewRulerLane.Left,<EOL>        light: {<EOL>            before: {<EOL>                color:","gt":"'<STR_LIT>',"}
{"input":"<s> export function failingItName(): any {<EOL>    return window.createTextEditorDecorationType({<EOL>        overviewRulerColor: '<STR_LIT>',<EOL>        overviewRulerLane: OverviewRulerLane.Left,<EOL>        light: {<EOL>            before: {<EOL>                color: '<STR_LIT>',<EOL>                contentText: '<STR_LIT>',<EOL>            },<EOL>        },<EOL>","gt":"dark: {"}
{"input":"<s> export function failingItName(): any {<EOL>    return window.createTextEditorDecorationType({<EOL>        overviewRulerColor: '<STR_LIT>',<EOL>        overviewRulerLane: OverviewRulerLane.Left,<EOL>        light: {<EOL>            before: {<EOL>                color: '<STR_LIT>',<EOL>                contentText: '<STR_LIT>',<EOL>            },<EOL>        },<EOL>        dark: {<EOL>            before: {<EOL>                color: '<STR_LIT>',<EOL>","gt":"contentText: '<STR_LIT>',"}
{"input":"<s> export function parseTest(filePath: string): IParseResults {<EOL>    const","gt":"parser: Function = getParser(filePath);"}
{"input":"<s> <EOL>export function search(node: Node, key: number): Node {<EOL>    if (!node)<EOL>        return null;<EOL>","gt":"if (node.key === key)"}
{"input":"<s> function isInHeap(index: number, heapSize: number): boolean {<EOL>","gt":"return index < heapSize;"}
{"input":"<s> <EOL>export function mergeSort(input: number[], start = <NUM_LIT>, end = input.length): number[] {<EOL>    if (end - start <= <NUM_LIT>)<EOL>","gt":"return [];"}
{"input":"<s> function isSPMProject(): boolean {<EOL>    return fs.","gt":"existsSync(swiftPackageManifestPath);"}
{"input":"<s> <EOL>export function extractThreadInfo(data: any): IThreadInfo {<EOL>    return {<EOL>        id: parseInt(data.id, <NUM_LIT>),<EOL>        targetId:","gt":"data['<STR_LIT>'],"}
{"input":"<s> export function trace(prefix: string, msg?: string): void {<EOL>    if (isTracingOn) {<EOL>        if (msg) {<EOL>            connection.console.","gt":"log(prefix + msg);"}
{"input":"<s> <EOL>export function demangle(...demangledNames: string[]): Promise<any> {<EOL>    const names:","gt":"string = JSON.stringify(demangledNames.join(\"<STR_LIT>\"));"}
{"input":"<s> function jsonify(s: string): string {<EOL>    return","gt":"s"}
{"input":"<s> function swLog(eventName: any, event?: any): void {<EOL>    console.log('<STR_LIT>' + eventName);<EOL>","gt":"if (event) {"}
{"input":"<s> export function cancelEditing(): QUOTE_EDIT {<EOL>    return {<EOL>        type:","gt":"\"<STR_LIT>\","}
{"input":"<s> export function resetHiddenQuotes(): {<EOL>    type: ActionTypes;<EOL>} {<EOL>","gt":"return {"}
{"input":"<s> function showUpdateSuccessNotification(): void {<EOL>    if (configManager.current.notifyWhenEntryUpdated) {<EOL>        const button: Button = {<EOL>            label: $STR(\"<STR_LIT>\"),<EOL>","gt":"action: \"<STR_LIT>\""}
{"input":"<s> function showUpdateSuccessNotification(): void {<EOL>    if (configManager.current.notifyWhenEntryUpdated) {<EOL>        const button: Button = {<EOL>            label: $STR(\"<STR_LIT>\"),<EOL>            action: \"<STR_LIT>\"<EOL>        };<EOL>        const messages: string[] = [$STR(\"<STR_LIT>\"),<EOL>            $STR(\"<STR_LIT>\"),<EOL>            $STR(\"<STR_LIT>\"),<EOL>            $STR(\"<STR_LIT>\"),<EOL>            $STR(","gt":"\"<STR_LIT>\")];"}
{"input":"<s> function matchFinder(uri: string): void {<EOL>    myPort.postMessage({ findMatches: {","gt":"uri } });"}
{"input":"<s> export function activateCodeActions(): vscode.Disposable[] {<EOL>    return [<EOL>        vscode.commands.registerCommand('<STR_LIT>', (msg: any): void => annotateFunction(msg)),<EOL>","gt":"vscode.commands.registerCommand('<STR_LIT>', (msg: any): void => replaceSuggestedVariable(msg)),"}
{"input":"<s> <EOL>function getFunctionComments(lines: string[]): string {<EOL>    try {<EOL>        let documentation: string = '<STR_LIT>';<EOL>        if (config['<STR_LIT>'] !== true) {<EOL>            return documentation;<EOL>        }<EOL>        let","gt":"inComment: boolean = false;"}
{"input":"<s> <EOL>function getFunctionComments(lines: string[]): string {<EOL>    try {<EOL>        let documentation: string = '<STR_LIT>';<EOL>        if (config['<STR_LIT>'] !== true) {<EOL>            return documentation;<EOL>        }<EOL>        let inComment: boolean = false;<EOL>        for (let j: number = lines.length - <NUM_LIT>; j >= <NUM_LIT>; j--) {<EOL>            if (lines[j].trim() === '<STR_LIT>' && !inComment) {<EOL>","gt":"break;"}
{"input":"<s> <EOL>function getFunctionComments(lines: string[]): string {<EOL>    try {<EOL>        let documentation: string = '<STR_LIT>';<EOL>        if (config['<STR_LIT>'] !== true) {<EOL>            return documentation;<EOL>        }<EOL>        let inComment: boolean = false;<EOL>        for (let j: number = lines.length - <NUM_LIT>; j >= <NUM_LIT>; j--) {<EOL>            if (lines[j].trim() === '<STR_LIT>' && !inComment) {<EOL>                break;<EOL>            }<EOL>            if (lines[j].includes('<STR_LIT>')) {<EOL>","gt":"inComment = true;"}
{"input":"<s> <EOL>function getFunctionComments(lines: string[]): string {<EOL>    try {<EOL>        let documentation: string = '<STR_LIT>';<EOL>        if (config['<STR_LIT>'] !== true) {<EOL>            return documentation;<EOL>        }<EOL>        let inComment: boolean = false;<EOL>        for (let j: number = lines.length - <NUM_LIT>; j >= <NUM_LIT>; j--) {<EOL>            if (lines[j].trim() === '<STR_LIT>' && !inComment) {<EOL>                break;<EOL>            }<EOL>            if (lines[j].includes('<STR_LIT>')) {<EOL>                inComment = true;<EOL>            }<EOL>            if (inComment) {<EOL>                documentation = lines[j].trim() + '<STR_LIT>' + documentation;<EOL>            }<EOL>            if (lines[j].includes('<STR_LIT>')) {<EOL>                inComment = false;<EOL>            }<EOL>        }<EOL>        if (documentation !== '<STR_LIT>') {<EOL>            documentation =","gt":"'<STR_LIT>' + documentation;"}
{"input":"<s> function inject(root: HeadingNode, title: string, level: number): HeadingNode {<EOL>    if (level === <NUM_LIT>) {<EOL>        root.title = title;<EOL>    }<EOL>    else {<EOL>        if (level === <NUM_LIT> ||","gt":"root.children.length === <NUM_LIT>) {"}
{"input":"<s> function inject(root: HeadingNode, title: string, level: number): HeadingNode {<EOL>    if (level === <NUM_LIT>) {<EOL>        root.title = title;<EOL>    }<EOL>    else {<EOL>        if (level === <NUM_LIT> || root.children.length === <NUM_LIT>) {<EOL>            root.children.push({<EOL>                title: null,<EOL>                children: [],<EOL>            });<EOL>        }<EOL>        const lastChild: HeadingNode = root.children[","gt":"root.children.length - <NUM_LIT>];"}
{"input":"<s> <EOL>export function mountComponent<P, S>(descriptor: ComponentDescriptor<P, S>, element: Element, props?: P, sync?: boolean): Component<P, S> {<EOL>    const c: Component<P, S> = descriptor.mountComponent(element, undefined, props);<EOL>    if (sync) {<EOL>        startMounting();<EOL>        componentAttached(c);<EOL>","gt":"updateComponent(c);"}
{"input":"<s> <EOL>export function mountComponent<P, S>(descriptor: ComponentDescriptor<P, S>, element: Element, props?: P, sync?: boolean): Component<P, S> {<EOL>    const c: Component<P, S> = descriptor.mountComponent(element, undefined, props);<EOL>    if (sync) {<EOL>        startMounting();<EOL>        componentAttached(c);<EOL>        updateComponent(c);<EOL>        finishMounting();<EOL>    }<EOL>    else {<EOL>","gt":"nextFrame().write(function () {"}
{"input":"<s> <EOL>export function mountComponent<P, S>(descriptor: ComponentDescriptor<P, S>, element: Element, props?: P, sync?: boolean): Component<P, S> {<EOL>    const c: Component<P, S> = descriptor.mountComponent(element, undefined, props);<EOL>    if (sync) {<EOL>        startMounting();<EOL>        componentAttached(c);<EOL>        updateComponent(c);<EOL>        finishMounting();<EOL>    }<EOL>    else {<EOL>        nextFrame().write(function () {<EOL>            startMounting();<EOL>            componentAttached(c);<EOL>            updateComponent(c);<EOL>","gt":"finishMounting();"}
{"input":"<s> <EOL>export function matchesWithAncestors(element: Element, selector: string, sentinel: Element | null = null): Element | null {<EOL>    while (element !== sentinel) {<EOL>        if (element.matches(selector)) {<EOL>            return","gt":"element;"}
{"input":"<s> <EOL>export function clock(): number {<EOL>","gt":"return scheduler.clock;"}
{"input":"<s> function vNodeRemoveAllChildren(parent: VNode, nodes: VNode[]): void {<EOL>    parent.ref!.textContent = \"<STR_LIT>\";<EOL>    for (let","gt":"i: number = <NUM_LIT>; i < nodes.length; i++) {"}
{"input":"<s> export function Put(value?: string): any {<EOL>    return (): void => {","gt":"return; };"}
{"input":"<s> <EOL>export function BodyProp(name?: string): any {<EOL>    return (): void => {","gt":"return; };"}
{"input":"<s> <EOL>export function Security(name: string, scopes?: string[]): any {<EOL>","gt":"return (): void => { return; };"}
{"input":"<s> <EOL>function getStateLookingForSetStateCalls(classDeclaration: ts.ClassDeclaration, typeChecker: ts.TypeChecker): ts.TypeNode[] {<EOL>    const typeNodes: ts.TypeNode[] = [];<EOL>    for (const member: any of classDeclaration.members) {<EOL>        if (member && ts.isMethodDeclaration(member) && member.body) {<EOL>            lookForSetState(member.body);<EOL>        }<EOL>    }<EOL>    return typeNodes;<EOL>    function lookForSetState(node: ts.Node): void {<EOL>        ts.forEachChild(node,","gt":"lookForSetState);"}
{"input":"<s> <EOL>function getStateLookingForSetStateCalls(classDeclaration: ts.ClassDeclaration, typeChecker: ts.TypeChecker): ts.TypeNode[] {<EOL>    const typeNodes: ts.TypeNode[] = [];<EOL>    for (const member: any of classDeclaration.members) {<EOL>        if (member && ts.isMethodDeclaration(member) && member.body) {<EOL>            lookForSetState(member.body);<EOL>        }<EOL>    }<EOL>    return typeNodes;<EOL>    function lookForSetState(node: ts.Node): void {<EOL>        ts.forEachChild(node, lookForSetState);<EOL>        if (ts.isExpressionStatement(node) &&<EOL>            ts.isCallExpression(node.expression) &&<EOL>            node.expression.expression.getText().match(/setState/)) {<EOL>            const type: any = typeChecker.getTypeAtLocation(","gt":"node.expression.arguments[<NUM_LIT>]);"}
{"input":"<s> export function SessionStorage(key?: string): (target: Object, propertyName: string) => void {<EOL>    return","gt":"WebStorage(sessionStorage, key);"}
{"input":"<s> export function getSize(filePath: string): any {<EOL>    return","gt":"fs.stat(filePath).then((stats: any): any => stats.size);"}
{"input":"<s> export function getDockerodeImageDataMock(): any {<EOL>","gt":"return {};"}
{"input":"<s> export function getSettingsMock(): any {<EOL>    return {<EOL>        locale: LOCALE.DE_DE,<EOL>        connectionSettings: {<EOL>            configType: CONFIG_TYPE.","gt":"SOCKET,"}
{"input":"<s> export function getSettingsMock(): any {<EOL>    return {<EOL>        locale: LOCALE.DE_DE,<EOL>        connectionSettings: {<EOL>            configType: CONFIG_TYPE.SOCKET,<EOL>            host: '<STR_LIT>',<EOL>            port: <NUM_LIT>,<EOL>            protocol: PROTOCOL.HTTP,<EOL>            caFile: '<STR_LIT>',<EOL>            certFile: '<STR_LIT>',<EOL>","gt":"keyFile: '<STR_LIT>',"}
{"input":"<s> export function main(): void {<EOL>    describe('<STR_LIT>', (): void => {<EOL>        beforeEach((): void => {<EOL>            TestBed.","gt":"configureTestingModule({"}
{"input":"<s> export function main(): void {<EOL>    describe('<STR_LIT>', (): void => {<EOL>        beforeEach((): void => {<EOL>            TestBed.configureTestingModule({<EOL>                imports: [FormsModule],<EOL>                declarations: [HomeComponent],<EOL>","gt":"providers: ["}
{"input":"<s> export function main(): void {<EOL>    describe('<STR_LIT>', (): void => {<EOL>        beforeEach((): void => {<EOL>            TestBed.configureTestingModule({<EOL>                imports: [FormsModule],<EOL>                declarations: [HomeComponent],<EOL>                providers: [<EOL>                    { provide: NameListService, useValue: new MockNameListService() }<EOL>                ]<EOL>            });<EOL>        });<EOL>        it('<STR_LIT>', async((): void => {<EOL>            TestBed<EOL>                .compileComponents()<EOL>                .","gt":"then((): void => {"}
{"input":"<s> export function main(): void {<EOL>    describe('<STR_LIT>', (): void => {<EOL>        beforeEach((): void => {<EOL>            TestBed.configureTestingModule({<EOL>                imports: [FormsModule],<EOL>                declarations: [HomeComponent],<EOL>                providers: [<EOL>                    { provide: NameListService, useValue: new MockNameListService() }<EOL>                ]<EOL>            });<EOL>        });<EOL>        it('<STR_LIT>', async((): void => {<EOL>            TestBed<EOL>                .compileComponents()<EOL>                .then((): void => {<EOL>                const fixture: any = TestBed.createComponent(HomeComponent);<EOL>                const homeInstance: any = fixture.debugElement.componentInstance;<EOL>                const homeDOMEl: any = fixture.debugElement.nativeElement;<EOL>                const mockNameListService:","gt":"MockNameListService = fixture.debugElement.injector.get<any>(NameListService) as MockNameListService;"}
{"input":"<s> export function main(): void {<EOL>    describe('<STR_LIT>', (): void => {<EOL>        beforeEach((): void => {<EOL>            TestBed.configureTestingModule({<EOL>                imports: [FormsModule],<EOL>                declarations: [HomeComponent],<EOL>                providers: [<EOL>                    { provide: NameListService, useValue: new MockNameListService() }<EOL>                ]<EOL>            });<EOL>        });<EOL>        it('<STR_LIT>', async((): void => {<EOL>            TestBed<EOL>                .compileComponents()<EOL>                .then((): void => {<EOL>                const fixture: any = TestBed.createComponent(HomeComponent);<EOL>                const homeInstance: any = fixture.debugElement.componentInstance;<EOL>                const homeDOMEl: any = fixture.debugElement.nativeElement;<EOL>                const mockNameListService: MockNameListService = fixture.debugElement.injector.get<any>(NameListService) as MockNameListService;<EOL>                const nameListServiceSpy: any = spyOn(mockNameListService, '<STR_LIT>').and.callThrough();<EOL>                mockNameListService.returnValue = ['<STR_LIT>', '<STR_LIT>', '<STR_LIT>'];<EOL>                fixture.detectChanges();<EOL>                expect(homeInstance.nameListService).toEqual(jasmine.any(MockNameListService));<EOL>                expect(homeDOMEl.querySelectorAll('<STR_LIT>').length).toEqual(<NUM_LIT>);<EOL>                expect(nameListServiceSpy.calls.count()).toBe(<NUM_LIT>);<EOL>","gt":"homeInstance.newName = '<STR_LIT>';"}
{"input":"<s> export function getRawMessage(error: Error): string {<EOL>    return (","gt":"error as any)[ERROR_RAW_MESSAGE];"}
{"input":"<s> function isCommentEnd(code: number, next: number): boolean {<EOL>","gt":"return code == chars.$STAR && next == chars.$SLASH;"}
{"input":"<s> function _pseudoSelectorSupportsInnerSelectors(name: string): boolean {<EOL>    return ['<STR_LIT>', '<STR_LIT>', '<STR_LIT>'].indexOf(name) >=","gt":"<NUM_LIT>;"}
{"input":"<s> function findFirstClosedCycle(keys: any[]): any[] {<EOL>    const res: any[] = [];<EOL>    for (let i: number = <NUM_LIT>; i < keys.length; ++i) {<EOL>        if (res.indexOf(","gt":"keys[i]) > -<NUM_LIT>) {"}
{"input":"<s> function applyParams(fnOrArray: Function | any[] | undefined, key: string): Function {<EOL>    if (fnOrArray === Object || fnOrArray === String || fnOrArray === Function ||<EOL>        fnOrArray === Number || fnOrArray === Array) {<EOL>        throw new Error(`<STR_LIT>`);<EOL>    }<EOL>    if (typeof fnOrArray ===","gt":"'<STR_LIT>') {"}
{"input":"<s> function applyParams(fnOrArray: Function | any[] | undefined, key: string): Function {<EOL>    if (fnOrArray === Object || fnOrArray === String || fnOrArray === Function ||<EOL>        fnOrArray === Number || fnOrArray === Array) {<EOL>        throw new Error(`<STR_LIT>`);<EOL>    }<EOL>    if (typeof fnOrArray === '<STR_LIT>') {<EOL>        return fnOrArray;<EOL>    }<EOL>    if (Array.isArray(fnOrArray)) {<EOL>        const annotations: any[] = fnOrArray as any[];<EOL>        const annoLength: number = annotations.length - <NUM_LIT>;<EOL>        const fn: Function = fnOrArray[annoLength];<EOL>","gt":"if (typeof fn !== '<STR_LIT>') {"}
{"input":"<s> function applyParams(fnOrArray: Function | any[] | undefined, key: string): Function {<EOL>    if (fnOrArray === Object || fnOrArray === String || fnOrArray === Function ||<EOL>        fnOrArray === Number || fnOrArray === Array) {<EOL>        throw new Error(`<STR_LIT>`);<EOL>    }<EOL>    if (typeof fnOrArray === '<STR_LIT>') {<EOL>        return fnOrArray;<EOL>    }<EOL>    if (Array.isArray(fnOrArray)) {<EOL>        const annotations: any[] = fnOrArray as any[];<EOL>        const annoLength: number = annotations.length - <NUM_LIT>;<EOL>        const fn: Function = fnOrArray[annoLength];<EOL>        if (typeof fn !== '<STR_LIT>') {<EOL>            throw new Error(`<STR_LIT>`);<EOL>        }<EOL>        if (annoLength != fn.length) {<EOL>            throw new Error(","gt":"}) in the function: ${stringify(fn)}`<STR_LIT>;"}
{"input":"<s> function applyParams(fnOrArray: Function | any[] | undefined, key: string): Function {<EOL>    if (fnOrArray === Object || fnOrArray === String || fnOrArray === Function ||<EOL>        fnOrArray === Number || fnOrArray === Array) {<EOL>        throw new Error(`<STR_LIT>`);<EOL>    }<EOL>    if (typeof fnOrArray === '<STR_LIT>') {<EOL>        return fnOrArray;<EOL>    }<EOL>    if (Array.isArray(fnOrArray)) {<EOL>        const annotations: any[] = fnOrArray as any[];<EOL>        const annoLength: number = annotations.length - <NUM_LIT>;<EOL>        const fn: Function = fnOrArray[annoLength];<EOL>        if (typeof fn !== '<STR_LIT>') {<EOL>            throw new Error(`<STR_LIT>`);<EOL>        }<EOL>        if (annoLength != fn.length) {<EOL>            throw new Error(`<STR_LIT>`);<EOL>        }<EOL>        const paramsAnnotations: any[][] = [];<EOL>        for (let i: number = <NUM_LIT>, ii: number = annotations.length - <NUM_LIT>; i < ii; i++) {<EOL>            const paramAnnotations: any[] = [];<EOL>            paramsAnnotations.push(","gt":"paramAnnotations);"}
{"input":"<s> function applyParams(fnOrArray: Function | any[] | undefined, key: string): Function {<EOL>    if (fnOrArray === Object || fnOrArray === String || fnOrArray === Function ||<EOL>        fnOrArray === Number || fnOrArray === Array) {<EOL>        throw new Error(`<STR_LIT>`);<EOL>    }<EOL>    if (typeof fnOrArray === '<STR_LIT>') {<EOL>        return fnOrArray;<EOL>    }<EOL>    if (Array.isArray(fnOrArray)) {<EOL>        const annotations: any[] = fnOrArray as any[];<EOL>        const annoLength: number = annotations.length - <NUM_LIT>;<EOL>        const fn: Function = fnOrArray[annoLength];<EOL>        if (typeof fn !== '<STR_LIT>') {<EOL>            throw new Error(`<STR_LIT>`);<EOL>        }<EOL>        if (annoLength != fn.length) {<EOL>            throw new Error(`<STR_LIT>`);<EOL>        }<EOL>        const paramsAnnotations: any[][] = [];<EOL>        for (let i: number = <NUM_LIT>, ii: number = annotations.length - <NUM_LIT>; i < ii; i++) {<EOL>            const paramAnnotations: any[] = [];<EOL>            paramsAnnotations.push(paramAnnotations);<EOL>            const annotation: any = annotations[i];<EOL>            if (Array.isArray(annotation)) {<EOL>                for (let j: number = <NUM_LIT>; j < annotation.length; j++) {<EOL>                    paramAnnotations.push(extractAnnotation(annotation[j]));<EOL>                }<EOL>            }<EOL>            else if (typeof annotation === '<STR_LIT>') {<EOL>                paramAnnotations.push(","gt":"extractAnnotation(annotation));"}
{"input":"<s> <EOL>function prepareTemplates(): any {<EOL>    return gulp.src(join(Config.APP_SRC,","gt":"'<STR_LIT>', '<STR_LIT>'))"}
{"input":"<s> <EOL>function processExternalCss(): any {<EOL>    return getExternalCssStream()<EOL>        .pipe(","gt":"plugins.postcss(processors))"}
{"input":"<s> <EOL>function transformPath(): (filepath: string) => string {<EOL>    return function (filepath: string) {<EOL>        if (filepath.startsWith(`<STR_LIT>`)) {<EOL>            filepath = filepath.replace(`<STR_LIT>`,","gt":"'<STR_LIT>');"}
{"input":"<s> export function serveDocs(): void {<EOL>    let","gt":"server: any = express();"}
{"input":"<s> export function delay(ms: number): Promise<{}> {<EOL>    return new Promise(","gt":"function (resolve, reject) {"}
{"input":"<s> function computeTopJoinQuote(input: StyleHelpers.QuoteInput): StyleHelpers.GeneratedQuote {<EOL>    var genQt: StyleHelpers.GeneratedQuote = getQuoteAtTopOfMarket(input);<EOL>    if (input.params.mode === Models.QuotingMode.Top && genQt.bidSz > <NUM_LIT>) {<EOL>        genQt.bidPx += input.minTickIncrement;<EOL>    }<EOL>    var minBid: number = input.fv.","gt":"price - input.params.width / <NUM_LIT>;"}
{"input":"<s> function computeTopJoinQuote(input: StyleHelpers.QuoteInput): StyleHelpers.GeneratedQuote {<EOL>    var genQt: StyleHelpers.GeneratedQuote = getQuoteAtTopOfMarket(input);<EOL>    if (input.params.mode === Models.QuotingMode.Top && genQt.bidSz > <NUM_LIT>) {<EOL>        genQt.bidPx += input.minTickIncrement;<EOL>    }<EOL>    var minBid: number = input.fv.price - input.params.width / <NUM_LIT>;<EOL>    genQt.bidPx = Math.min(minBid, genQt.bidPx);<EOL>    if (input.params.mode === Models.QuotingMode.Top && genQt.askSz > <NUM_LIT>) {<EOL>        genQt.askPx -= input.minTickIncrement;<EOL>    }<EOL>    var minAsk: number = input.fv.price + input.params.width / <NUM_LIT>;<EOL>","gt":"genQt.askPx = Math.max(minAsk, genQt.askPx);"}
{"input":"<s> <EOL>async function updateNoteResources(meta: any, content: any, noteGuid: any, resources: any): Promise<any> {<EOL>    try {<EOL>        let tagNames: any = meta[\"<STR_LIT>\"];<EOL>        let title: any = meta[\"<STR_LIT>\"];<EOL>        let notebook:","gt":"any = meta[\"<STR_LIT>\"];"}
{"input":"<s> <EOL>async function updateNoteResources(meta: any, content: any, noteGuid: any, resources: any): Promise<any> {<EOL>    try {<EOL>        let tagNames: any = meta[\"<STR_LIT>\"];<EOL>        let title: any = meta[\"<STR_LIT>\"];<EOL>        let notebook: any = meta[\"<STR_LIT>\"];<EOL>        const notebookGuid: any = await getNotebookGuid(notebook);<EOL>        return client.updateNoteResources(noteGuid, title, content, tagNames, notebookGuid, resources || void <NUM_LIT>);<EOL>    }<EOL>","gt":"catch (err: any) {"}
{"input":"<s> async function arrayFromLiteral(): Promise<number[]> {<EOL>","gt":"\"<STR_LIT>\";"}
{"input":"<s> async function addEqualsInts(x: int, y: int): Promise<int> {<EOL>","gt":"\"<STR_LIT>\";"}
{"input":"<s> async function binOrInts(x: int, y: int): Promise<number> {<EOL>","gt":"\"<STR_LIT>\";"}
{"input":"<s> async function divideNumbers(x: number, y: number): Promise<number> {<EOL>","gt":"\"<STR_LIT>\";"}
{"input":"<s> async function intLessThan(x: int, y: int): Promise<boolean> {<EOL>","gt":"\"<STR_LIT>\";"}
{"input":"<s> async function powInts(base: int, exponent: int): Promise<number> {<EOL>","gt":"\"<STR_LIT>\";"}
{"input":"<s> async function numberCondition(condition: number, trueValue: int, falseValue: int): Promise<any> {<EOL>","gt":"\"<STR_LIT>\";"}
{"input":"<s> <EOL>export function isCodeGenerationDiagnostic(error: any): error is CodeGenerationDiagnostic {<EOL>    return typeof (error.node) !== \"<STR_LIT>\" && typeof (error.","gt":"code) === \"<STR_LIT>\" && error instanceof Error;"}
{"input":"<s> <EOL>export function isMaybeObjectType(type: ts.Type): type is ts.UnionType {<EOL>    if (type.flags & ts.TypeFlags.Union) {<EOL>        const unionType: ts.UnionType = type as ts.UnionType;<EOL>        return","gt":"unionType.types.length === <NUM_LIT> &&"}
{"input":"<s> export async function asBoolean(): Promise<void> {<EOL>","gt":"\"<STR_LIT>\";"}
{"input":"<s> async function minusImplicitCast(): Promise<void> {<EOL>","gt":"\"<STR_LIT>\";"}
{"input":"<s> async function argumentsEvaluationOrder(points: number[], index: int): Promise<number> {<EOL>","gt":"\"<STR_LIT>\";"}
{"input":"<s> async function plusPlus(): Promise<void> {<EOL>    \"<STR_LIT>\";<EOL>    let","gt":"intResult: number = +<NUM_LIT>;"}
{"input":"<s> function tspSync(points: Point[]): number {<EOL>    \"<STR_LIT>\";<EOL>    let current: Point = points.shift()!;<EOL>    const solution: Point[] = [current];<EOL>    while (points.length) {<EOL>        let shortestDistance: number = <NUM_LIT> ** <NUM_LIT> - <NUM_LIT>;<EOL>","gt":"let nearestIndex: number = <NUM_LIT>;"}
{"input":"<s> function tspSync(points: Point[]): number {<EOL>    \"<STR_LIT>\";<EOL>    let current: Point = points.shift()!;<EOL>    const solution: Point[] = [current];<EOL>    while (points.length) {<EOL>        let shortestDistance: number = <NUM_LIT> ** <NUM_LIT> - <NUM_LIT>;<EOL>        let nearestIndex: number = <NUM_LIT>;<EOL>        for (let i: number = <NUM_LIT>; i < points.length; ++i) {<EOL>            const distance: number = current.distanceTo(points[i]);<EOL>            if (distance < shortestDistance) {<EOL>","gt":"shortestDistance = distance;"}
{"input":"<s> function tspSync(points: Point[]): number {<EOL>    \"<STR_LIT>\";<EOL>    let current: Point = points.shift()!;<EOL>    const solution: Point[] = [current];<EOL>    while (points.length) {<EOL>        let shortestDistance: number = <NUM_LIT> ** <NUM_LIT> - <NUM_LIT>;<EOL>        let nearestIndex: number = <NUM_LIT>;<EOL>        for (let i: number = <NUM_LIT>; i < points.length; ++i) {<EOL>            const distance: number = current.distanceTo(points[i]);<EOL>            if (distance < shortestDistance) {<EOL>                shortestDistance = distance;<EOL>                nearestIndex = i;<EOL>            }<EOL>        }<EOL>        current = points[","gt":"nearestIndex];"}
{"input":"<s> async function simpleWhile(arg: int): Promise<void> {<EOL>    \"<STR_LIT>\";<EOL>","gt":"while (arg) {"}
{"input":"<s> export function flash(x: number, y: number, title: string, scale: number = <NUM_LIT>): SVGElement {<EOL>    if (flashIconLazy === undefined) {<EOL>","gt":"const d: string = `<STR_LIT>7"}
{"input":"<s> <EOL>export function isTabUp(evt: KeyboardEvent): boolean {<EOL>    return","gt":"evt.which === <NUM_LIT> && evt.shiftKey;"}
{"input":"<s> <EOL>export function pluralize(word: string, count: number): string {<EOL>","gt":"return word + (count > <NUM_LIT> ? \"<STR_LIT>\" : \"<STR_LIT>\");"}
{"input":"<s> export function formatBytes(bytes: number): string {<EOL>    const raw: string = `<STR_LIT>`;<EOL>    if (bytes >= bytesPerMB) {<EOL>        return","gt":"bytesPerMB, <NUM_LIT>)} MB)`<STR_LIT>;"}
{"input":"<s> <EOL>export function createRequestLabelFull(x: number, y: number, name: string, height: number): SVGGElement {<EOL>    const blockLabel: SVGTextElement = createRequestLabel(x, y, name, height);<EOL>    const labelHolder: SVGGElement = svg.newG(\"<STR_LIT>\", {}, {<EOL>        clipPath: `<STR_LIT>`,<EOL>    });<EOL>    labelHolder.appendChild(","gt":"svg.newRect({"}
{"input":"<s> <EOL>export function createRequestLabelFull(x: number, y: number, name: string, height: number): SVGGElement {<EOL>    const blockLabel: SVGTextElement = createRequestLabel(x, y, name, height);<EOL>    const labelHolder: SVGGElement = svg.newG(\"<STR_LIT>\", {}, {<EOL>        clipPath: `<STR_LIT>`,<EOL>    });<EOL>    labelHolder.appendChild(svg.newRect({<EOL>        height: height - <NUM_LIT>,<EOL>        rx: <NUM_LIT>,<EOL>        ry: <NUM_LIT>,<EOL>        <EOL>        <EOL>        width: <NUM_LIT>,<EOL>        x: x - <NUM_LIT>,<EOL>        y:","gt":"y + <NUM_LIT>,"}
{"input":"<s> <EOL><EOL><EOL>function mapLocale(locale: string): string {<EOL>    locale = locale && locale.toLowerCase();<EOL>    if (locale in localizedStrings) {<EOL>","gt":"return locale;"}
{"input":"<s> <EOL><EOL><EOL>function mapLocale(locale: string): string {<EOL>    locale = locale && locale.toLowerCase();<EOL>    if (locale in localizedStrings) {<EOL>        return locale;<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>        return","gt":"'<STR_LIT>';"}
{"input":"<s> <EOL><EOL><EOL>function mapLocale(locale: string): string {<EOL>    locale = locale && locale.toLowerCase();<EOL>    if (locale in localizedStrings) {<EOL>        return locale;<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>","gt":"return '<STR_LIT>';"}
{"input":"<s> <EOL><EOL><EOL>function mapLocale(locale: string): string {<EOL>    locale = locale && locale.toLowerCase();<EOL>    if (locale in localizedStrings) {<EOL>        return locale;<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>","gt":"else if (locale.startsWith('<STR_LIT>')) {"}
{"input":"<s> <EOL><EOL><EOL>function mapLocale(locale: string): string {<EOL>    locale = locale && locale.toLowerCase();<EOL>    if (locale in localizedStrings) {<EOL>        return locale;<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>","gt":"return '<STR_LIT>';"}
{"input":"<s> <EOL><EOL><EOL>function mapLocale(locale: string): string {<EOL>    locale = locale && locale.toLowerCase();<EOL>    if (locale in localizedStrings) {<EOL>        return locale;<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>        return","gt":"'<STR_LIT>';"}
{"input":"<s> <EOL><EOL><EOL>function mapLocale(locale: string): string {<EOL>    locale = locale && locale.toLowerCase();<EOL>    if (locale in localizedStrings) {<EOL>        return locale;<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    else if (","gt":"locale.startsWith('<STR_LIT>')) {"}
{"input":"<s> <EOL><EOL><EOL>function mapLocale(locale: string): string {<EOL>    locale = locale && locale.toLowerCase();<EOL>    if (locale in localizedStrings) {<EOL>        return locale;<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>') || locale.startsWith('<STR_LIT>') || locale.startsWith(","gt":"'<STR_LIT>')) {"}
{"input":"<s> <EOL><EOL><EOL>function mapLocale(locale: string): string {<EOL>    locale = locale && locale.toLowerCase();<EOL>    if (locale in localizedStrings) {<EOL>        return locale;<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>') || locale.startsWith('<STR_LIT>') || locale.startsWith('<STR_LIT>')) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>        return","gt":"'<STR_LIT>';"}
{"input":"<s> <EOL><EOL><EOL>function mapLocale(locale: string): string {<EOL>    locale = locale && locale.toLowerCase();<EOL>    if (locale in localizedStrings) {<EOL>        return locale;<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>') || locale.startsWith('<STR_LIT>') || locale.startsWith('<STR_LIT>')) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>        if (locale === '<STR_LIT>') {<EOL>            return '<STR_LIT>';<EOL>        }<EOL>        else {<EOL>            return '<STR_LIT>';<EOL>        }<EOL>    }<EOL>    else if (","gt":"locale.startsWith('<STR_LIT>')) {"}
{"input":"<s> <EOL><EOL><EOL>function mapLocale(locale: string): string {<EOL>    locale = locale && locale.toLowerCase();<EOL>    if (locale in localizedStrings) {<EOL>        return locale;<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>') || locale.startsWith('<STR_LIT>') || locale.startsWith('<STR_LIT>')) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>        if (locale === '<STR_LIT>') {<EOL>            return '<STR_LIT>';<EOL>        }<EOL>        else {<EOL>            return '<STR_LIT>';<EOL>        }<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>        return","gt":"'<STR_LIT>';"}
{"input":"<s> <EOL><EOL><EOL>function mapLocale(locale: string): string {<EOL>    locale = locale && locale.toLowerCase();<EOL>    if (locale in localizedStrings) {<EOL>        return locale;<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>') || locale.startsWith('<STR_LIT>') || locale.startsWith('<STR_LIT>')) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>        if (locale === '<STR_LIT>') {<EOL>            return '<STR_LIT>';<EOL>        }<EOL>        else {<EOL>            return '<STR_LIT>';<EOL>        }<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>        return '<STR_LIT>';<EOL>    }<EOL>    else if (locale.startsWith('<STR_LIT>')) {<EOL>        return","gt":"'<STR_LIT>';"}
{"input":"<s> function getPackageString(packageObject: Package): string {<EOL>    if (!packageObject) {<EOL>        return chalk.magenta(\"<STR_LIT>\").toString();<EOL>    }<EOL>","gt":"var packageString: string = chalk.green(\"<STR_LIT>\") + packageObject.label + \"<STR_LIT>\" +"}
{"input":"<s> function getPackageString(packageObject: Package): string {<EOL>    if (!packageObject) {<EOL>        return chalk.magenta(\"<STR_LIT>\").toString();<EOL>    }<EOL>    var packageString: string = chalk.green(\"<STR_LIT>\") + packageObject.label + \"<STR_LIT>\" +<EOL>        chalk.green(\"<STR_LIT>\") + packageObject.appVersion + \"<STR_LIT>\" +<EOL>        chalk.green(\"<STR_LIT>\") + (packageObject.isMandatory ? \"<STR_LIT>\" : \"<STR_LIT>\") + \"<STR_LIT>\" +<EOL>        chalk.green(\"<STR_LIT>\") + formatDate(packageObject.uploadTime) + \"<STR_LIT>\" +<EOL>        chalk.green(\"<STR_LIT>\") + (packageObject.releasedBy ? packageObject.releasedBy : \"<STR_LIT>\") +<EOL>        (packageObject.description ? wordwrap(<NUM_LIT>)(\"<STR_LIT>\" + chalk.green(\"<STR_LIT>\") + packageObject.description) : \"<STR_LIT>\");<EOL>","gt":"if (packageObject.isDisabled) {"}
{"input":"<s> function throwForInvalidSemverRange(semverRange: string): void {<EOL>","gt":"if (semver.validRange(semverRange) === null) {"}
{"input":"<s> function accessKeyAdd(commandName: string, yargs: yargs.Argv): void {<EOL>    isValidCommand = true;<EOL>    yargs.usage(USAGE_PREFIX + \"<STR_LIT>\" + commandName + \"<STR_LIT>\")<EOL>        .demand( <NUM_LIT>,","gt":"<NUM_LIT>)"}
{"input":"<s> <EOL>function mockReturn(bodyText: string, statusCode: number, header = {}): void {<EOL>    require(\"<STR_LIT>\")(request, [{<EOL>            pattern: \"<STR_LIT>\",<EOL>            fixtures: function (match: any, params: any): any {<EOL>                var isOk: boolean = statusCode >= <NUM_LIT> && statusCode <","gt":"<NUM_LIT>;"}
{"input":"<s> <EOL>function mockReturn(bodyText: string, statusCode: number, header = {}): void {<EOL>    require(\"<STR_LIT>\")(request, [{<EOL>            pattern: \"<STR_LIT>\",<EOL>            fixtures: function (match: any, params: any): any {<EOL>                var isOk: boolean = statusCode >= <NUM_LIT> && statusCode < <NUM_LIT>;<EOL>                if (!isOk) {<EOL>                    var err: any = new Error(bodyText);<EOL>                    err.status = statusCode;<EOL>                    throw err;<EOL>                }<EOL>                return { text: bodyText, status: statusCode,","gt":"ok: isOk, header: header, headers: {} };"}
{"input":"<s> function getTemplate(templateName: string): string {<EOL>    try {<EOL>        return fs.","gt":"readFileSync(path.join(templatesDirectory, templateName + \"<STR_LIT>\"), \"<STR_LIT>\");"}
{"input":"<s> function getCSharpCommand(): string {<EOL>    return process.platform == \"<STR_LIT>\" ?","gt":"\"<STR_LIT>\" : \"<STR_LIT>\";"}
{"input":"<s> function runBuildCmdAsync(cmd: string, ...args: string[]): any {<EOL>    return nodeutil.spawnAsync({<EOL>","gt":"cmd,"}
{"input":"<s> export function augmnetDocsAsync(parsed: commandParser.ParsedCommand): any {<EOL>    let f0: any = fs.readFileSync(parsed.arguments[<NUM_LIT>], \"<STR_LIT>\");<EOL>    let f1: any = fs.","gt":"readFileSync(parsed.arguments[<NUM_LIT>], \"<STR_LIT>\");"}
{"input":"<s> function buildFolderAndBrowserifyAsync(p: string, optional?: boolean, outputName?: string): Promise<void> {<EOL>    if (!fs.existsSync(path.join(p, \"<STR_LIT>\"))) {<EOL>        if (!optional)<EOL>            U.userError(`<STR_LIT>`);<EOL>","gt":"return Promise.resolve();"}
{"input":"<s> function buildFolderAndBrowserifyAsync(p: string, optional?: boolean, outputName?: string): Promise<void> {<EOL>    if (!fs.existsSync(path.join(p, \"<STR_LIT>\"))) {<EOL>        if (!optional)<EOL>            U.userError(`<STR_LIT>`);<EOL>        return Promise.resolve();<EOL>    }<EOL>    const tsConfig: any = JSON.parse(fs.readFileSync(path.join(p, \"<STR_LIT>\"), \"<STR_LIT>\"));<EOL>    if (","gt":"outputName && tsConfig.compilerOptions.outDir !== `<STR_LIT>`) {"}
{"input":"<s> function buildFolderAndBrowserifyAsync(p: string, optional?: boolean, outputName?: string): Promise<void> {<EOL>    if (!fs.existsSync(path.join(p, \"<STR_LIT>\"))) {<EOL>        if (!optional)<EOL>            U.userError(`<STR_LIT>`);<EOL>        return Promise.resolve();<EOL>    }<EOL>    const tsConfig: any = JSON.parse(fs.readFileSync(path.join(p, \"<STR_LIT>\"), \"<STR_LIT>\"));<EOL>    if (outputName && tsConfig.compilerOptions.outDir !== `<STR_LIT>`) {<EOL>        U.userError(`<STR_LIT>`);<EOL>    }<EOL>    if (!fs.existsSync(\"<STR_LIT>\")) {<EOL>        U.userError(\"<STR_LIT>\");<EOL>    }<EOL>    pxt.log(`<STR_LIT>`);<EOL>    dirsToWatch.push(p);<EOL>    return nodeutil.spawnAsync({<EOL>","gt":"cmd: \"<STR_LIT>\","}
{"input":"<s> function buildFolderAndBrowserifyAsync(p: string, optional?: boolean, outputName?: string): Promise<void> {<EOL>    if (!fs.existsSync(path.join(p, \"<STR_LIT>\"))) {<EOL>        if (!optional)<EOL>            U.userError(`<STR_LIT>`);<EOL>        return Promise.resolve();<EOL>    }<EOL>    const tsConfig: any = JSON.parse(fs.readFileSync(path.join(p, \"<STR_LIT>\"), \"<STR_LIT>\"));<EOL>    if (outputName && tsConfig.compilerOptions.outDir !== `<STR_LIT>`) {<EOL>        U.userError(`<STR_LIT>`);<EOL>    }<EOL>    if (!fs.existsSync(\"<STR_LIT>\")) {<EOL>        U.userError(\"<STR_LIT>\");<EOL>    }<EOL>    pxt.log(`<STR_LIT>`);<EOL>    dirsToWatch.push(p);<EOL>    return nodeutil.spawnAsync({<EOL>        cmd: \"<STR_LIT>\",<EOL>        args: [\"<STR_LIT>\"],<EOL>        cwd: p<EOL>    }).then((): any => {<EOL>","gt":"const browserify: any = require('<STR_LIT>');"}
{"input":"<s> function buildFolderAndBrowserifyAsync(p: string, optional?: boolean, outputName?: string): Promise<void> {<EOL>    if (!fs.existsSync(path.join(p, \"<STR_LIT>\"))) {<EOL>        if (!optional)<EOL>            U.userError(`<STR_LIT>`);<EOL>        return Promise.resolve();<EOL>    }<EOL>    const tsConfig: any = JSON.parse(fs.readFileSync(path.join(p, \"<STR_LIT>\"), \"<STR_LIT>\"));<EOL>    if (outputName && tsConfig.compilerOptions.outDir !== `<STR_LIT>`) {<EOL>        U.userError(`<STR_LIT>`);<EOL>    }<EOL>    if (!fs.existsSync(\"<STR_LIT>\")) {<EOL>        U.userError(\"<STR_LIT>\");<EOL>    }<EOL>    pxt.log(`<STR_LIT>`);<EOL>    dirsToWatch.push(p);<EOL>    return nodeutil.spawnAsync({<EOL>        cmd: \"<STR_LIT>\",<EOL>        args: [\"<STR_LIT>\"],<EOL>        cwd: p<EOL>    }).then((): any => {<EOL>        const browserify: any = require('<STR_LIT>');<EOL>        let b: any = browserify();<EOL>        nodeutil.allFiles(`<STR_LIT>`).forEach((f: string): void => {<EOL>            if (f.match(/\\.js$/)) {<EOL>                b.add(f);<EOL>            }<EOL>        });<EOL>        let outFile: any = fs.createWriteStream(`<STR_LIT>`, { encoding: '<STR_LIT>' });<EOL>        b.","gt":"bundle().pipe(outFile);"}
{"input":"<s> function prepBuildOptionsAsync(mode: BuildOption, quick: boolean = false): any {<EOL>    ensurePkgDir();<EOL>    return mainPkg.loadAsync()<EOL>        .then((): any => {<EOL>        if (!quick) {<EOL>            build.buildDalConst(build.thisBuild, mainPkg);<EOL>","gt":"copyCommonFiles();"}
{"input":"<s> function prepBuildOptionsAsync(mode: BuildOption, quick: boolean = false): any {<EOL>    ensurePkgDir();<EOL>    return mainPkg.loadAsync()<EOL>        .then((): any => {<EOL>        if (!quick) {<EOL>            build.buildDalConst(build.thisBuild, mainPkg);<EOL>            copyCommonFiles();<EOL>        }<EOL>        <EOL>","gt":"let target: any = mainPkg.getTargetOptions();"}
{"input":"<s> function prepBuildOptionsAsync(mode: BuildOption, quick: boolean = false): any {<EOL>    ensurePkgDir();<EOL>    return mainPkg.loadAsync()<EOL>        .then((): any => {<EOL>        if (!quick) {<EOL>            build.buildDalConst(build.thisBuild, mainPkg);<EOL>            copyCommonFiles();<EOL>        }<EOL>        <EOL>        let target: any = mainPkg.getTargetOptions();<EOL>        if (target.hasHex)<EOL>            target.isNative = true;<EOL>","gt":"switch (mode) {"}
{"input":"<s> function prepBuildOptionsAsync(mode: BuildOption, quick: boolean = false): any {<EOL>    ensurePkgDir();<EOL>    return mainPkg.loadAsync()<EOL>        .then((): any => {<EOL>        if (!quick) {<EOL>            build.buildDalConst(build.thisBuild, mainPkg);<EOL>            copyCommonFiles();<EOL>        }<EOL>        <EOL>        let target: any = mainPkg.getTargetOptions();<EOL>        if (target.hasHex)<EOL>            target.isNative = true;<EOL>        switch (mode) {<EOL>            case BuildOption.Run:<EOL>            case BuildOption.DebugSim:<EOL>            case BuildOption.GenDocs:<EOL>                target.","gt":"isNative = false;"}
{"input":"<s> export function serialAsync(parsed: commandParser.ParsedCommand): Promise<void> {<EOL>    let buf: string = \"<STR_LIT>\";<EOL>    serial.monitorSerial((","gt":"info: serial.SerialPortInfo, buffer: Buffer): void => {"}
{"input":"<s> export function fileExistsSync(p: string): boolean {<EOL>    try {<EOL>        let stats: any = fs.lstatSync(p);<EOL>        return","gt":"stats && stats.isFile();"}
{"input":"<s> export function gitInfoAsync(args: string[], cwd?: string, silent: boolean = false): any {<EOL>    return Promise.resolve()<EOL>        .then((): any => spawnWithPipeAsync({<EOL>","gt":"cmd: \"<STR_LIT>\","}
{"input":"<s> function getName(e: py.Expr): string {<EOL>    if (e == null)<EOL>        return null;<EOL>    if (e.kind == \"<STR_LIT>\") {<EOL>        let s: string = (e as py.Name).id;<EOL>","gt":"let v: any = lookupVar(s);"}
{"input":"<s> function getName(e: py.Expr): string {<EOL>    if (e == null)<EOL>        return null;<EOL>    if (e.kind == \"<STR_LIT>\") {<EOL>        let s: string = (e as py.Name).id;<EOL>        let v: any = lookupVar(s);<EOL>        if (v && v.expandsTo)<EOL>            return v.expandsTo;<EOL>        else<EOL>","gt":"return s;"}
{"input":"<s> function getName(e: py.Expr): string {<EOL>    if (e == null)<EOL>        return null;<EOL>    if (e.kind == \"<STR_LIT>\") {<EOL>        let s: string = (e as py.Name).id;<EOL>        let v: any = lookupVar(s);<EOL>        if (v && v.expandsTo)<EOL>            return v.expandsTo;<EOL>        else<EOL>            return s;<EOL>    }<EOL>    if (e.kind == \"<STR_LIT>\") {<EOL>        let pref: string = getName((e as py.Attribute).value);<EOL>        if (","gt":"pref)"}
{"input":"<s> <EOL>function toTS(mod: py.Module): any[] {<EOL>    U.assert(mod.kind == \"<STR_LIT>\");<EOL>    resetCtx(mod);<EOL>    if (!mod.vars)<EOL>        mod.","gt":"vars = {};"}
{"input":"<s> <EOL>function toTS(mod: py.Module): any[] {<EOL>    U.assert(mod.kind == \"<STR_LIT>\");<EOL>    resetCtx(mod);<EOL>    if (!mod.vars)<EOL>        mod.vars = {};<EOL>    let res: B.JsNode[] = mod.body.map(stmt);<EOL>    if (res.every(isEmpty))<EOL>        return null;<EOL>    return [<EOL>        B.","gt":"mkText(\"<STR_LIT>\" + mod.name + \"<STR_LIT>\"),"}
{"input":"<s> function i(parts: TemplateStringsArray): pxtc.BlockLabel {<EOL>    return lbl(parts[","gt":"<NUM_LIT>], [\"<STR_LIT>\"]);"}
{"input":"<s> function initGlobals(): void {<EOL>    Promise = require(\"<STR_LIT>\");<EOL>    let g: any = global as any;<EOL>    g.","gt":"pxt = pxt;"}
{"input":"<s> function decompileTestAsync(filename: string): any {<EOL>    return new Promise((resolve: any, reject: any): any => {<EOL>        const basename: any = path.basename(filename);<EOL>        const baselineFile: any = path.join(baselineDir, replaceFileExtension(basename, \"<STR_LIT>\"));<EOL>        let baselineExists: boolean;<EOL>","gt":"try {"}
{"input":"<s> function decompileTestAsync(filename: string): any {<EOL>    return new Promise((resolve: any, reject: any): any => {<EOL>        const basename: any = path.basename(filename);<EOL>        const baselineFile: any = path.join(baselineDir, replaceFileExtension(basename, \"<STR_LIT>\"));<EOL>        let baselineExists: boolean;<EOL>        try {<EOL>            const stats: any = fs.statSync(baselineFile);<EOL>            baselineExists = stats.isFile();<EOL>        }<EOL>        catch (e: any) {<EOL>            baselineExists = false;<EOL>        }<EOL>        if (!baselineExists) {<EOL>            return reject(\"<STR_LIT>\" + basename);<EOL>        }<EOL>        return decompileAsyncWorker(filename, testBlocksDir)<EOL>            .then((decompiled: string): void => {<EOL>            const baseline: any = fs.readFileSync(baselineFile, \"<STR_LIT>\");<EOL>            if (!compareBaselines(decompiled, baseline)) {<EOL>                const outFile: any = path.join(replaceFileExtension(filename,","gt":"\"<STR_LIT>\"));"}
{"input":"<s> export function workerOpAsync(op: string, arg: pxtc.service.OpArg): any {<EOL>    return pxt.worker.getWorker(pxt.","gt":"webConfig.workerjs).opAsync(op, arg);"}
{"input":"<s> export function resetFocus(): void {<EOL>    let content: HTMLElement = document.getElementById('<STR_LIT>');<EOL>    content.","gt":"tabIndex = <NUM_LIT>;"}
{"input":"<s> export function showLoading(id: string, msg: string): void {<EOL>    pxt.debug(\"<STR_LIT>\" + id);<EOL>    if (loadingQueueMsg[id])<EOL>","gt":"return;"}
{"input":"<s> export function clearCache(): void {<EOL>","gt":"cachedData = {};"}
{"input":"<s> function memoryDb(): Promise<any> {<EOL>    pxt.debug('<STR_LIT>');<EOL>","gt":"inMemory = true;"}
{"input":"<s> function installAsync(h0: InstallHeader, text: ScriptText): any {<EOL>    const h: pxt.workspace.Header = <Header>h0;<EOL>    let path: any = h.name.replace(/[^a-zA-Z0-9]+/g, \"<STR_LIT>\").trim().replace(/ /g, \"<STR_LIT>\");<EOL>    if (lookup(path)) {<EOL>        let n: number = <NUM_LIT>;<EOL>","gt":"while (lookup(path + \"<STR_LIT>\" + n))"}
{"input":"<s> function installAsync(h0: InstallHeader, text: ScriptText): any {<EOL>    const h: pxt.workspace.Header = <Header>h0;<EOL>    let path: any = h.name.replace(/[^a-zA-Z0-9]+/g, \"<STR_LIT>\").trim().replace(/ /g, \"<STR_LIT>\");<EOL>    if (lookup(path)) {<EOL>        let n: number = <NUM_LIT>;<EOL>        while (lookup(path + \"<STR_LIT>\" + n))<EOL>            n++;<EOL>","gt":"path += \"<STR_LIT>\" + n;"}
{"input":"<s> function installAsync(h0: InstallHeader, text: ScriptText): any {<EOL>    const h: pxt.workspace.Header = <Header>h0;<EOL>    let path: any = h.name.replace(/[^a-zA-Z0-9]+/g, \"<STR_LIT>\").trim().replace(/ /g, \"<STR_LIT>\");<EOL>    if (lookup(path)) {<EOL>        let n: number = <NUM_LIT>;<EOL>        while (lookup(path + \"<STR_LIT>\" + n))<EOL>            n++;<EOL>        path += \"<STR_LIT>\" + n;<EOL>        h.name += \"<STR_LIT>\" + n;<EOL>    }<EOL>    h.id = path;<EOL>    h.recentUse = U.nowSeconds();<EOL>    h.modificationTime =","gt":"h.recentUse;"}
{"input":"<s> function installAsync(h0: InstallHeader, text: ScriptText): any {<EOL>    const h: pxt.workspace.Header = <Header>h0;<EOL>    let path: any = h.name.replace(/[^a-zA-Z0-9]+/g, \"<STR_LIT>\").trim().replace(/ /g, \"<STR_LIT>\");<EOL>    if (lookup(path)) {<EOL>        let n: number = <NUM_LIT>;<EOL>        while (lookup(path + \"<STR_LIT>\" + n))<EOL>            n++;<EOL>        path += \"<STR_LIT>\" + n;<EOL>        h.name += \"<STR_LIT>\" + n;<EOL>    }<EOL>    h.id = path;<EOL>    h.recentUse = U.nowSeconds();<EOL>    h.modificationTime = h.recentUse;<EOL>    h.target = currentTarget;<EOL>    const e: HeaderWithScript = {<EOL>        id: h.id,<EOL>        header: h,<EOL>","gt":"text: text,"}
{"input":"<s> function saveToCloudAsync(h: Header): Promise<void> {<EOL>    return Promise.","gt":"resolve();"}
{"input":"<s> function loadMakeFrameAsync(container: HTMLElement): Promise<HTMLIFrameElement> {<EOL>    return new Promise((resolve: (value: HTMLIFrameElement | PromiseLike<HTMLIFrameElement>) => void, reject: (reason?: any) => void): void => {<EOL>        function waitForReady(ev: MessageEvent): void {<EOL>            const data: pxsim.SimulatorReadyMessage = ev.data as pxsim.SimulatorReadyMessage;<EOL>            if (data.type == \"<STR_LIT>\" && data.","gt":"frameid == FRAME_ID) {"}
{"input":"<s> function loadMakeFrameAsync(container: HTMLElement): Promise<HTMLIFrameElement> {<EOL>    return new Promise((resolve: (value: HTMLIFrameElement | PromiseLike<HTMLIFrameElement>) => void, reject: (reason?: any) => void): void => {<EOL>        function waitForReady(ev: MessageEvent): void {<EOL>            const data: pxsim.SimulatorReadyMessage = ev.data as pxsim.SimulatorReadyMessage;<EOL>            if (data.type == \"<STR_LIT>\" && data.frameid == FRAME_ID) {<EOL>                window.removeEventListener('<STR_LIT>', waitForReady);<EOL>                resolve(iframe);<EOL>            }<EOL>        }<EOL>        <EOL>        window.addEventListener('<STR_LIT>', waitForReady);<EOL>        <EOL>        <EOL>        const iframe: HTMLIFrameElement = document.createElement(\"<STR_LIT>\");<EOL>        iframe.frameBorder = \"<STR_LIT>\";<EOL>        iframe.setAttribute(\"<STR_LIT>\", \"<STR_LIT>\");<EOL>","gt":"iframe.setAttribute(\"<STR_LIT>\", \"<STR_LIT>\");"}
{"input":"<s> function saveToCloudAsync(h: Header): Promise<void> {<EOL>    return Promise.","gt":"resolve();"}
{"input":"<s> export function overrideToolbox(def: pxt.editor.MonacoToolboxDefinition): void {<EOL>    overrideCategory(loops.nameid, def.loops);<EOL>    overrideCategory(logic.nameid, def.logic);<EOL>    overrideCategory(variables.nameid, def.","gt":"variables);"}
{"input":"<s> export function installAsync(h0: InstallHeader, text: ScriptText): any {<EOL>","gt":"checkSession();"}
{"input":"<s> function decorateClassMethod<T extends RawAction>(target: any, propertyKey: string, descriptor: TypedPropertyDescriptor<T>, actionType: string, actionContext: ActionContext): void {<EOL>    if (descriptor && typeof descriptor.value == '<STR_LIT>') {<EOL>","gt":"descriptor.value = wrapFunctionInAction(descriptor.value, actionType, actionContext);"}
{"input":"<s> function wrapFunctionInAction<T extends RawAction>(target: T, actionType: string, actionContext: ActionContext): T {<EOL>    let decoratedTarget: T = <T>function () {<EOL>        let returnValue: any;<EOL>        let passedArguments: IArguments = arguments;<EOL>","gt":"dispatch((): any => {"}
{"input":"<s> function wrapFunctionInAction<T extends RawAction>(target: T, actionType: string, actionContext: ActionContext): T {<EOL>    let decoratedTarget: T = <T>function () {<EOL>        let returnValue: any;<EOL>        let passedArguments: IArguments = arguments;<EOL>        dispatch((): any => {<EOL>            returnValue = target.apply(this, passedArguments);<EOL>            return returnValue;<EOL>        }, actionType, arguments, actionContext);<EOL>        return returnValue;<EOL>    };<EOL>","gt":"setOriginalTarget(decoratedTarget, target);"}
{"input":"<s> export function setActionType(decoratedTarget: any, actionType: string): void {<EOL>    decoratedTarget.__SATCHELJS_ACTION_TYPE =","gt":"actionType;"}
{"input":"<s> export function raise<T extends ActionHandler>(actionType: string, callback?: (actionToExecute: T) => void): void {<EOL>    console.error(\"<STR_LIT>\");<EOL>    <EOL>    let actionToExecute: () => void = action(actionType)((): void => { });<EOL>    if (","gt":"callback) {"}
{"input":"<s> function resetState(): void {<EOL>    _.","gt":"resetGlobalState();"}
{"input":"<s> function reloadTypeScriptNodeModule(): NodeJS.ReadWriteStream {<EOL>    var util: any = require('<STR_LIT>');<EOL>    function log(message: any, ...rest: any[]): void {<EOL>        util.log(util.colors.","gt":"cyan('<STR_LIT>'), message, ...rest);"}
{"input":"<s> function reloadTypeScriptNodeModule(): NodeJS.ReadWriteStream {<EOL>    var util: any = require('<STR_LIT>');<EOL>    function log(message: any, ...rest: any[]): void {<EOL>        util.log(util.colors.cyan('<STR_LIT>'), message, ...rest);<EOL>    }<EOL>    function heapUsed(): string {<EOL>        return (process.memoryUsage().heapUsed / <NUM_LIT> / <NUM_LIT>).toFixed(<NUM_LIT>) + '<STR_LIT>';<EOL>    }<EOL>    return es.through(function (data) {<EOL>        this.emit('<STR_LIT>', data);<EOL>    }, function () {<EOL>        log(","gt":"'<STR_LIT>' + heapUsed());"}
{"input":"<s> function reloadTypeScriptNodeModule(): NodeJS.ReadWriteStream {<EOL>    var util: any = require('<STR_LIT>');<EOL>    function log(message: any, ...rest: any[]): void {<EOL>        util.log(util.colors.cyan('<STR_LIT>'), message, ...rest);<EOL>    }<EOL>    function heapUsed(): string {<EOL>        return (process.memoryUsage().heapUsed / <NUM_LIT> / <NUM_LIT>).toFixed(<NUM_LIT>) + '<STR_LIT>';<EOL>    }<EOL>    return es.through(function (data) {<EOL>        this.emit('<STR_LIT>', data);<EOL>    }, function () {<EOL>        log('<STR_LIT>' + heapUsed());<EOL>        <EOL>        <EOL>        <EOL>        <EOL>        <EOL>        <EOL>        <EOL>        <EOL>        <EOL>        log('<STR_LIT>');<EOL>        var resolvedName: any = require.resolve('<STR_LIT>');<EOL>        var originalModule: any = require.cache[resolvedName];<EOL>        delete require.cache[resolvedName];<EOL>        var newExports: any = require('<STR_LIT>');<EOL>        require.","gt":"cache[resolvedName] = originalModule;"}
{"input":"<s> export function fromGitUri(uri: Uri): {<EOL>    path: string;<EOL>    ref: string;<EOL>} {<EOL>","gt":"return JSON.parse(uri.query);"}
{"input":"<s> function tryLoadMarkdownItPlugins(contributes: any, extension: vscode.Extension<any>, engine: MarkdownEngine): void {<EOL>    if (contributes['<STR_LIT>']) {<EOL>        extension.activate().then((): void => {<EOL>            if (extension.","gt":"exports && extension.exports.extendMarkdownIt) {"}
{"input":"<s> export function getCommand(args: string[]): TfCommand<CoreArguments, version.SemanticVersion> {<EOL>    return","gt":"new Version(args);"}
{"input":"<s> <EOL>export function read(name: string, message: string, silent: boolean = false): Promise<string> {<EOL>    let promise: Promise<string> = new Promise<string>((resolve: (value: string | PromiseLike<string>) => void, reject: (reason?: any) => void): void => {<EOL>        let schema: prompt.PromptSchema = {<EOL>            properties: {}<EOL>        };<EOL>","gt":"schema.properties[name] = {"}
{"input":"<s> <EOL>export function read(name: string, message: string, silent: boolean = false): Promise<string> {<EOL>    let promise: Promise<string> = new Promise<string>((resolve: (value: string | PromiseLike<string>) => void, reject: (reason?: any) => void): void => {<EOL>        let schema: prompt.PromptSchema = {<EOL>            properties: {}<EOL>        };<EOL>        schema.properties[name] = {<EOL>            required: true,<EOL>            description: message + \"<STR_LIT>\",<EOL>","gt":"hidden: silent"}
{"input":"<s> <EOL>export function read(name: string, message: string, silent: boolean = false): Promise<string> {<EOL>    let promise: Promise<string> = new Promise<string>((resolve: (value: string | PromiseLike<string>) => void, reject: (reason?: any) => void): void => {<EOL>        let schema: prompt.PromptSchema = {<EOL>            properties: {}<EOL>        };<EOL>        schema.properties[name] = {<EOL>            required: true,<EOL>            description: message + \"<STR_LIT>\",<EOL>            hidden: silent<EOL>        };<EOL>        Promise.all(queue.filter((x: any): boolean => x !== promise)).then((): void => {<EOL>            prompt.start();<EOL>            prompt.get(schema, (err: Error, result: string): void => {<EOL>","gt":"if (err) {"}
{"input":"<s> <EOL>export function read(name: string, message: string, silent: boolean = false): Promise<string> {<EOL>    let promise: Promise<string> = new Promise<string>((resolve: (value: string | PromiseLike<string>) => void, reject: (reason?: any) => void): void => {<EOL>        let schema: prompt.PromptSchema = {<EOL>            properties: {}<EOL>        };<EOL>        schema.properties[name] = {<EOL>            required: true,<EOL>            description: message + \"<STR_LIT>\",<EOL>            hidden: silent<EOL>        };<EOL>        Promise.all(queue.filter((x: any): boolean => x !== promise)).then((): void => {<EOL>            prompt.start();<EOL>            prompt.get(schema, (err: Error, result: string): void => {<EOL>                if (err) {<EOL>                    reject(err);<EOL>                }<EOL>                else {<EOL>                    resolve(result[name]);<EOL>                }<EOL>                queue.","gt":"shift();"}
{"input":"<s> export function getFailureStringEmptyAltAndNotPresentationRole(tagName: string): string {<EOL>    return","gt":"tagName}> tag is empty and role value is not presentation. \\"}
{"input":"<s> <EOL>function getImplicitRoleForDd(): string {<EOL>","gt":"return '<STR_LIT>';"}
{"input":"<s> <EOL>function getImplicitRoleForH3(): string {<EOL>    return","gt":"'<STR_LIT>';"}
{"input":"<s> <EOL>function getImplicitRoleForOption(): string {<EOL>    return","gt":"'<STR_LIT>';"}
{"input":"<s> <EOL>export function getAllAttributesFromJsxElement(node: ts.Node): ts.NodeArray<ts.JsxAttributeLike> {<EOL>    let attributes: ts.NodeArray<ts.JsxAttributeLike> = null;<EOL>    if (node == null) {<EOL>        return attributes;<EOL>    }<EOL>    else if (isJsxElement(node)) {<EOL>        attributes = node.openingElement.","gt":"attributes.properties;"}
{"input":"<s> <EOL>export function getBooleanLiteral(node: ts.JsxAttribute): boolean {<EOL>    if (!isJsxAttribute(node)) {<EOL>        throw new Error('<STR_LIT>');<EOL>    }<EOL>    const initializer: ts.Expression = node == null ? null : node.initializer;<EOL>    const getBooleanFromString: (value: string) => boolean = (value: string): boolean => {<EOL>        if (value.toLowerCase() === '<STR_LIT>') {<EOL>","gt":"return true;"}
{"input":"<s> <EOL>export function getBooleanLiteral(node: ts.JsxAttribute): boolean {<EOL>    if (!isJsxAttribute(node)) {<EOL>        throw new Error('<STR_LIT>');<EOL>    }<EOL>    const initializer: ts.Expression = node == null ? null : node.initializer;<EOL>    const getBooleanFromString: (value: string) => boolean = (value: string): boolean => {<EOL>        if (value.toLowerCase() === '<STR_LIT>') {<EOL>            return true;<EOL>        }<EOL>        else if (value.toLowerCase() === '<STR_LIT>') {<EOL>            return false;<EOL>        }<EOL>","gt":"else {"}
{"input":"<s> <EOL>export function getBooleanLiteral(node: ts.JsxAttribute): boolean {<EOL>    if (!isJsxAttribute(node)) {<EOL>        throw new Error('<STR_LIT>');<EOL>    }<EOL>    const initializer: ts.Expression = node == null ? null : node.initializer;<EOL>    const getBooleanFromString: (value: string) => boolean = (value: string): boolean => {<EOL>        if (value.toLowerCase() === '<STR_LIT>') {<EOL>            return true;<EOL>        }<EOL>        else if (value.toLowerCase() === '<STR_LIT>') {<EOL>            return false;<EOL>        }<EOL>        else {<EOL>            return undefined;<EOL>        }<EOL>    };<EOL>    if (isStringLiteral(initializer)) {<EOL>        return getBooleanFromString(initializer.text);<EOL>    }<EOL>    else if (isJsxExpression(initializer)) {<EOL>        const","gt":"expression: ts.Expression = initializer.expression;"}
{"input":"<s> <EOL>export function getBooleanLiteral(node: ts.JsxAttribute): boolean {<EOL>    if (!isJsxAttribute(node)) {<EOL>        throw new Error('<STR_LIT>');<EOL>    }<EOL>    const initializer: ts.Expression = node == null ? null : node.initializer;<EOL>    const getBooleanFromString: (value: string) => boolean = (value: string): boolean => {<EOL>        if (value.toLowerCase() === '<STR_LIT>') {<EOL>            return true;<EOL>        }<EOL>        else if (value.toLowerCase() === '<STR_LIT>') {<EOL>            return false;<EOL>        }<EOL>        else {<EOL>            return undefined;<EOL>        }<EOL>    };<EOL>    if (isStringLiteral(initializer)) {<EOL>        return getBooleanFromString(initializer.text);<EOL>    }<EOL>    else if (isJsxExpression(initializer)) {<EOL>        const expression: ts.Expression = initializer.expression;<EOL>        if (isStringLiteral(expression)) {<EOL>            return getBooleanFromString(expression.text);<EOL>        }<EOL>        else {<EOL>            if (isTrueKeyword(expression)) {<EOL>                return true;<EOL>            }<EOL>            else if (","gt":"isFalseKeyword(expression)) {"}
{"input":"<s> export function isTrueKeyword(node: ts.Node): node is ts.LiteralExpression {<EOL>    return node && node.","gt":"kind === ts.SyntaxKind.TrueKeyword;"}
{"input":"<s> export function index(req: express.Request, res: express.Response): void {<EOL>    db.getUsers(function (users) {<EOL>        console.","gt":"dir(users);"}
{"input":"<s> function max<T>(array: ReadonlyArray<T> | undefined, selector: (elem: T) => number): number {<EOL>    if (!array) {<EOL>        return <NUM_LIT>;<EOL>    }<EOL>    let","gt":"max: number = <NUM_LIT>;"}
{"input":"<s> <EOL>function getWXConfig(cb: any): void {<EOL>    request.get('<STR_LIT>' + appId + '<STR_LIT>' + appsecret, (err: any, res: any, body: any): void => {<EOL>        request.get('<STR_LIT>' + JSON.parse(body).access_token + '<STR_LIT>', (err: any, res: any, body: any): void => {<EOL>            let ticket: any = JSON.parse(body).ticket;<EOL>            let o:","gt":"configObj = {"}
{"input":"<s> <EOL>function getWXConfig(cb: any): void {<EOL>    request.get('<STR_LIT>' + appId + '<STR_LIT>' + appsecret, (err: any, res: any, body: any): void => {<EOL>        request.get('<STR_LIT>' + JSON.parse(body).access_token + '<STR_LIT>', (err: any, res: any, body: any): void => {<EOL>            let ticket: any = JSON.parse(body).ticket;<EOL>            let o: configObj = {<EOL>                appId: appId,<EOL>                nonceStr: nonceStr,<EOL>                timestamp: new Date().getTime() / <NUM_LIT> + '<STR_LIT>',<EOL>                signature: '<STR_LIT>'<EOL>            };<EOL>            o.signature = sha1('<STR_LIT>' + ticket + '<STR_LIT>' + o.nonceStr + '<STR_LIT>' + o.","gt":"timestamp + '<STR_LIT>' + url).toString();"}
{"input":"<s> function hasTypes(info: NpmInfoVersion): boolean {<EOL>    return","gt":"\"<STR_LIT>\" in info || \"<STR_LIT>\" in info;"}
{"input":"<s> function promisifyErrorOrResult<A>(callsBack: (x: ErrorOrResult<A>) => void): Promise<A> {<EOL>    return new Promise<A>((resolve: (value: A | PromiseLike<A>) => void, reject: (reason?: any) => void): void => {<EOL>        callsBack((err: any, result: any): void => {<EOL>            if (err) {<EOL>                reject(","gt":"err);"}
{"input":"<s> async function uploadDirectory(container: BlobWriter, uploadedDirPath: string, dirPath: string, log: Logger, filter?: (fileName: string) => boolean): Promise<string[]> {<EOL>    let files: any = await readdir(dirPath);<EOL>    if (filter) {<EOL>","gt":"files = files.filter(filter);"}
{"input":"<s> export async function readFileAndThrowOnBOM(directory: string, fileName: string): Promise<string> {<EOL>    const full: string = joinPaths(directory, fileName);<EOL>    const text: string = await readFile(full);<EOL>    if (text.charCodeAt(<NUM_LIT>) === <NUM_LIT>) {<EOL>","gt":"const commands: string[] = ["}
{"input":"<s> export async function readFileAndThrowOnBOM(directory: string, fileName: string): Promise<string> {<EOL>    const full: string = joinPaths(directory, fileName);<EOL>    const text: string = await readFile(full);<EOL>    if (text.charCodeAt(<NUM_LIT>) === <NUM_LIT>) {<EOL>        const commands: string[] = [<EOL>            \"<STR_LIT>\",<EOL>            `<STR_LIT>`,<EOL>            `<STR_LIT>`<EOL>        ];<EOL>        throw","gt":"new Error(`<STR_LIT>`);"}
{"input":"<s> function packageUrl(packageName: string): string {<EOL>    return","gt":"url.resolve(npmRegistry, packageName);"}
{"input":"<s> function* flattenData(data: ReadonlyMap<string, TypingsVersions>): Iterable<TypingsData> {<EOL>    for (","gt":"const versions: TypingsVersions of data.values()) {"}
{"input":"<s> <EOL>export async function fetchAndProcessNpmInfo(escapedPackageName: string, fetcher: Fetcher): Promise<ProcessedNpmInfo> {<EOL>    const info: NpmInfo = await fetchNpmInfo(escapedPackageName, fetcher);<EOL>    const version: Semver = getVersionSemver(info, false);<EOL>","gt":"const { \"<STR_LIT>\": distTags, versions } = info;"}
{"input":"<s> function getLatestVersion(versions: NpmInfoVersions): Semver {<EOL>    return best(Object.keys(versions).map(parseAnySemver), (a: Semver, b: Semver): boolean => {<EOL>        if (a.isPrerelease && !b.isPrerelease) {<EOL>","gt":"return false;"}
{"input":"<s> export async function isDirectory(path: string): Promise<boolean> {<EOL>    return (","gt":"await stat(path)).isDirectory();"}
{"input":"<s> export function done(promise: Promise<void>): void {<EOL>    promise.catch((error: any): void => {<EOL>        console.","gt":"error(error);"}
{"input":"<s> export function hasWindowsSlashes(path: string): boolean {<EOL>    return path.includes(","gt":"\"<STR_LIT>\");"}
{"input":"<s> async function writePackage(packageDirectory: string, packageName: string): Promise<void> {<EOL>    <EOL>    await writeJson(joinPaths(packageDirectory, \"<STR_LIT>\"), {<EOL>        name: `<STR_LIT>`,<EOL>        version: \"<STR_LIT>\",<EOL>","gt":"description: \"<STR_LIT>\","}
{"input":"<s> async function writePackage(packageDirectory: string, packageName: string): Promise<void> {<EOL>    <EOL>    await writeJson(joinPaths(packageDirectory, \"<STR_LIT>\"), {<EOL>        name: `<STR_LIT>`,<EOL>        version: \"<STR_LIT>\",<EOL>        description: \"<STR_LIT>\",<EOL>        author: \"<STR_LIT>\",<EOL>        license: \"<STR_LIT>\",<EOL>        repository:","gt":"\"<STR_LIT>\","}
{"input":"<s> async function writePackage(packageDirectory: string, packageName: string): Promise<void> {<EOL>    <EOL>    await writeJson(joinPaths(packageDirectory, \"<STR_LIT>\"), {<EOL>        name: `<STR_LIT>`,<EOL>        version: \"<STR_LIT>\",<EOL>        description: \"<STR_LIT>\",<EOL>        author: \"<STR_LIT>\",<EOL>        license: \"<STR_LIT>\",<EOL>        repository: \"<STR_LIT>\",<EOL>        dependencies: { [fullNpmName(packageName)]: \"<STR_LIT>\" }<EOL>    });<EOL>    <EOL>    await writeJson(joinPaths(packageDirectory, \"<STR_LIT>\"), {<EOL>","gt":"compilerOptions: {"}
{"input":"<s> async function writePackage(packageDirectory: string, packageName: string): Promise<void> {<EOL>    <EOL>    await writeJson(joinPaths(packageDirectory, \"<STR_LIT>\"), {<EOL>        name: `<STR_LIT>`,<EOL>        version: \"<STR_LIT>\",<EOL>        description: \"<STR_LIT>\",<EOL>        author: \"<STR_LIT>\",<EOL>        license: \"<STR_LIT>\",<EOL>        repository: \"<STR_LIT>\",<EOL>        dependencies: { [fullNpmName(packageName)]: \"<STR_LIT>\" }<EOL>    });<EOL>    <EOL>    await writeJson(joinPaths(packageDirectory, \"<STR_LIT>\"), {<EOL>        compilerOptions: {<EOL>            module: \"<STR_LIT>\",<EOL>            target: \"<STR_LIT>\",<EOL>            noImplicitAny: false,<EOL>            strictNullChecks: false,<EOL>","gt":"noEmit: true,"}
{"input":"<s> <EOL>export function cp(src: any, dest: any): void {<EOL>    if (fileExistsSync(src)) {<EOL>        let targetFile: any = dest;<EOL>        if (directoryExistsSync(dest)) {<EOL>            targetFile = path.join(dest, path.basename(src));<EOL>        }<EOL>        if (path.","gt":"relative(src, targetFile)) {"}
{"input":"<s> <EOL>export function cp(src: any, dest: any): void {<EOL>    if (fileExistsSync(src)) {<EOL>        let targetFile: any = dest;<EOL>        if (directoryExistsSync(dest)) {<EOL>            targetFile = path.join(dest, path.basename(src));<EOL>        }<EOL>        if (path.relative(src, targetFile)) {<EOL>            <EOL>            return;<EOL>        }<EOL>","gt":"copyFileSync(src, targetFile);"}
{"input":"<s> <EOL>export function cp(src: any, dest: any): void {<EOL>    if (fileExistsSync(src)) {<EOL>        let targetFile: any = dest;<EOL>        if (directoryExistsSync(dest)) {<EOL>            targetFile = path.join(dest, path.basename(src));<EOL>        }<EOL>        if (path.relative(src, targetFile)) {<EOL>            <EOL>            return;<EOL>        }<EOL>        copyFileSync(src, targetFile);<EOL>    }<EOL>    else if (directoryExistsSync(src)) {<EOL>        copyFolderRecursivelySync(src,","gt":"dest);"}
{"input":"<s> <EOL>export function fileExistsSync(filePath: string): boolean {<EOL>    try {<EOL>        return fs.statSync(","gt":"filePath).isFile();"}
{"input":"<s> <EOL>export function isArduinoFile(filePath): boolean {<EOL>    return fileExistsSync(filePath) && (","gt":"path.extname(filePath) === \"<STR_LIT>\" || path.extname(filePath) === \"<STR_LIT>\");"}
{"input":"<s> export function openSettings(): Promise<any> {<EOL>    return postHTTP(\"<STR_LIT>\", {}).","gt":"then((response: Response): Promise<any> => response.json());"}
{"input":"<s> <EOL>function positionToOffset(str: string, desiredLine: number, desiredCol: number): number {<EOL>    if (desiredLine === <NUM_LIT>) {<EOL>        return desiredCol - <NUM_LIT>;<EOL>    }<EOL>    let","gt":"line: number = <NUM_LIT>, lastNewLineOffset: number = -<NUM_LIT>;"}
{"input":"<s> <EOL>function positionToOffset(str: string, desiredLine: number, desiredCol: number): number {<EOL>    if (desiredLine === <NUM_LIT>) {<EOL>        return desiredCol - <NUM_LIT>;<EOL>    }<EOL>    let line: number = <NUM_LIT>, lastNewLineOffset: number = -<NUM_LIT>;<EOL>    do {<EOL>        if (desiredLine === line) {<EOL>            return lastNewLineOffset + <NUM_LIT> + desiredCol - <NUM_LIT>;<EOL>        }<EOL>        lastNewLineOffset = str.indexOf('<STR_LIT>', lastNewLineOffset + <NUM_LIT>);<EOL>","gt":"line++;"}
{"input":"<s> export function createXlfFilesForCoreBundle(): ThroughStream {<EOL>    return through(function (this: ThroughStream, file: File) {<EOL>        const basename: any = path.basename(file.path);<EOL>        if (basename === '<STR_LIT>') {<EOL>            if (file.","gt":"isBuffer()) {"}
{"input":"<s> export function createXlfFilesForCoreBundle(): ThroughStream {<EOL>    return through(function (this: ThroughStream, file: File) {<EOL>        const basename: any = path.basename(file.path);<EOL>        if (basename === '<STR_LIT>') {<EOL>            if (file.isBuffer()) {<EOL>                const xlfs: Map<XLF> = Object.create(null);<EOL>                const json: BundledFormat = JSON.parse((file.","gt":"contents as Buffer).toString('<STR_LIT>'));"}
{"input":"<s> export function createXlfFilesForCoreBundle(): ThroughStream {<EOL>    return through(function (this: ThroughStream, file: File) {<EOL>        const basename: any = path.basename(file.path);<EOL>        if (basename === '<STR_LIT>') {<EOL>            if (file.isBuffer()) {<EOL>                const xlfs: Map<XLF> = Object.create(null);<EOL>                const json: BundledFormat = JSON.parse((file.contents as Buffer).toString('<STR_LIT>'));<EOL>                for (let coreModule: string in json.keys) {<EOL>                    const projectResource: Resource = getResource(coreModule);<EOL>","gt":"const resource: string = projectResource.name;"}
{"input":"<s> export function createXlfFilesForCoreBundle(): ThroughStream {<EOL>    return through(function (this: ThroughStream, file: File) {<EOL>        const basename: any = path.basename(file.path);<EOL>        if (basename === '<STR_LIT>') {<EOL>            if (file.isBuffer()) {<EOL>                const xlfs: Map<XLF> = Object.create(null);<EOL>                const json: BundledFormat = JSON.parse((file.contents as Buffer).toString('<STR_LIT>'));<EOL>                for (let coreModule: string in json.keys) {<EOL>                    const projectResource: Resource = getResource(coreModule);<EOL>                    const resource: string = projectResource.name;<EOL>                    const project: string = projectResource.project;<EOL>                    const keys: (string | LocalizeInfo)[] = json.keys[coreModule];<EOL>                    const messages: string[] = json.messages[coreModule];<EOL>                    if (keys.length !== messages.length) {<EOL>                        this.emit('<STR_LIT>',","gt":"file.relative} for module ${coreModule}`<STR_LIT>;"}
{"input":"<s> export function createXlfFilesForCoreBundle(): ThroughStream {<EOL>    return through(function (this: ThroughStream, file: File) {<EOL>        const basename: any = path.basename(file.path);<EOL>        if (basename === '<STR_LIT>') {<EOL>            if (file.isBuffer()) {<EOL>                const xlfs: Map<XLF> = Object.create(null);<EOL>                const json: BundledFormat = JSON.parse((file.contents as Buffer).toString('<STR_LIT>'));<EOL>                for (let coreModule: string in json.keys) {<EOL>                    const projectResource: Resource = getResource(coreModule);<EOL>                    const resource: string = projectResource.name;<EOL>                    const project: string = projectResource.project;<EOL>                    const keys: (string | LocalizeInfo)[] = json.keys[coreModule];<EOL>                    const messages: string[] = json.messages[coreModule];<EOL>                    if (keys.length !== messages.length) {<EOL>                        this.emit('<STR_LIT>', `<STR_LIT>`);<EOL>                        return;<EOL>                    }<EOL>                    else {<EOL>                        let xlf: XLF = xlfs[resource];<EOL>","gt":"if (!xlf) {"}
{"input":"<s> export function createXlfFilesForCoreBundle(): ThroughStream {<EOL>    return through(function (this: ThroughStream, file: File) {<EOL>        const basename: any = path.basename(file.path);<EOL>        if (basename === '<STR_LIT>') {<EOL>            if (file.isBuffer()) {<EOL>                const xlfs: Map<XLF> = Object.create(null);<EOL>                const json: BundledFormat = JSON.parse((file.contents as Buffer).toString('<STR_LIT>'));<EOL>                for (let coreModule: string in json.keys) {<EOL>                    const projectResource: Resource = getResource(coreModule);<EOL>                    const resource: string = projectResource.name;<EOL>                    const project: string = projectResource.project;<EOL>                    const keys: (string | LocalizeInfo)[] = json.keys[coreModule];<EOL>                    const messages: string[] = json.messages[coreModule];<EOL>                    if (keys.length !== messages.length) {<EOL>                        this.emit('<STR_LIT>', `<STR_LIT>`);<EOL>                        return;<EOL>                    }<EOL>                    else {<EOL>                        let xlf: XLF = xlfs[resource];<EOL>                        if (!xlf) {<EOL>                            xlf = new XLF(project);<EOL>                            xlfs[resource] = xlf;<EOL>                        }<EOL>                        xlf.addFile(`<STR_LIT>`, keys, messages);<EOL>                    }<EOL>                }<EOL>                for (let resource: string in xlfs) {<EOL>                    const xlf: XLF = xlfs[resource];<EOL>                    const filePath: string = `<STR_LIT>`;<EOL>                    const xlfFile: File = new File({<EOL>                        path: filePath,<EOL>                        contents: Buffer.from(xlf.toString(), '<STR_LIT>')<EOL>                    });<EOL>                    this.queue(","gt":"xlfFile);"}
{"input":"<s> export function createXlfFilesForCoreBundle(): ThroughStream {<EOL>    return through(function (this: ThroughStream, file: File) {<EOL>        const basename: any = path.basename(file.path);<EOL>        if (basename === '<STR_LIT>') {<EOL>            if (file.isBuffer()) {<EOL>                const xlfs: Map<XLF> = Object.create(null);<EOL>                const json: BundledFormat = JSON.parse((file.contents as Buffer).toString('<STR_LIT>'));<EOL>                for (let coreModule: string in json.keys) {<EOL>                    const projectResource: Resource = getResource(coreModule);<EOL>                    const resource: string = projectResource.name;<EOL>                    const project: string = projectResource.project;<EOL>                    const keys: (string | LocalizeInfo)[] = json.keys[coreModule];<EOL>                    const messages: string[] = json.messages[coreModule];<EOL>                    if (keys.length !== messages.length) {<EOL>                        this.emit('<STR_LIT>', `<STR_LIT>`);<EOL>                        return;<EOL>                    }<EOL>                    else {<EOL>                        let xlf: XLF = xlfs[resource];<EOL>                        if (!xlf) {<EOL>                            xlf = new XLF(project);<EOL>                            xlfs[resource] = xlf;<EOL>                        }<EOL>                        xlf.addFile(`<STR_LIT>`, keys, messages);<EOL>                    }<EOL>                }<EOL>                for (let resource: string in xlfs) {<EOL>                    const xlf: XLF = xlfs[resource];<EOL>                    const filePath: string = `<STR_LIT>`;<EOL>                    const xlfFile: File = new File({<EOL>                        path: filePath,<EOL>                        contents: Buffer.from(xlf.toString(), '<STR_LIT>')<EOL>                    });<EOL>                    this.queue(xlfFile);<EOL>                }<EOL>            }<EOL>            else {<EOL>                this.emit('<STR_LIT>', new Error(`<STR_LIT>`));<EOL>","gt":"return;"}
{"input":"<s> export function processNlsFiles(opts: {<EOL>    fileHeader: string;<EOL>    languages: Language[];<EOL>}): ThroughStream {<EOL>    return through(function (this: ThroughStream, file: File) {<EOL>        let fileName: any = path.basename(file.path);<EOL>        if (fileName === '<STR_LIT>') {<EOL>            let json: any = null;<EOL>            if (file.isBuffer()) {<EOL>                json = JSON.parse((<Buffer>file.","gt":"contents).toString('<STR_LIT>'));"}
{"input":"<s> export function processNlsFiles(opts: {<EOL>    fileHeader: string;<EOL>    languages: Language[];<EOL>}): ThroughStream {<EOL>    return through(function (this: ThroughStream, file: File) {<EOL>        let fileName: any = path.basename(file.path);<EOL>        if (fileName === '<STR_LIT>') {<EOL>            let json: any = null;<EOL>            if (file.isBuffer()) {<EOL>                json = JSON.parse((<Buffer>file.contents).toString('<STR_LIT>'));<EOL>            }<EOL>            else {<EOL>                this.emit('<STR_LIT>', `<STR_LIT>`);<EOL>","gt":"return;"}
{"input":"<s> export function processNlsFiles(opts: {<EOL>    fileHeader: string;<EOL>    languages: Language[];<EOL>}): ThroughStream {<EOL>    return through(function (this: ThroughStream, file: File) {<EOL>        let fileName: any = path.basename(file.path);<EOL>        if (fileName === '<STR_LIT>') {<EOL>            let json: any = null;<EOL>            if (file.isBuffer()) {<EOL>                json = JSON.parse((<Buffer>file.contents).toString('<STR_LIT>'));<EOL>            }<EOL>            else {<EOL>                this.emit('<STR_LIT>', `<STR_LIT>`);<EOL>                return;<EOL>            }<EOL>            if (BundledFormat.is(json)) {<EOL>                processCoreBundleFormat(opts.","gt":"fileHeader, opts.languages, json, this);"}
{"input":"<s> function clone<T>(object: T): T {<EOL>    var result: T = <T>{};<EOL>","gt":"for (var id: Extract<keyof T, string> in object) {"}
{"input":"<s> function visitTopLevelDeclarations(sourceFile: ts.SourceFile, visitor: (node: TSTopLevelDeclare) => boolean): void {<EOL>    let stop: boolean = false;<EOL>    let visit: (node: ts.Node) => void = (node: ts.Node): void => {<EOL>        if (stop) {<EOL>            return;<EOL>        }<EOL>        switch (node.kind) {<EOL>            case ts.SyntaxKind.InterfaceDeclaration:<EOL>            case ts.SyntaxKind.EnumDeclaration:<EOL>            case ts.SyntaxKind.","gt":"ClassDeclaration:"}
{"input":"<s> function visitTopLevelDeclarations(sourceFile: ts.SourceFile, visitor: (node: TSTopLevelDeclare) => boolean): void {<EOL>    let stop: boolean = false;<EOL>    let visit: (node: ts.Node) => void = (node: ts.Node): void => {<EOL>        if (stop) {<EOL>            return;<EOL>        }<EOL>        switch (node.kind) {<EOL>            case ts.SyntaxKind.InterfaceDeclaration:<EOL>            case ts.SyntaxKind.EnumDeclaration:<EOL>            case ts.SyntaxKind.ClassDeclaration:<EOL>            case ts.SyntaxKind.VariableStatement:<EOL>            case ts.SyntaxKind.TypeAliasDeclaration:<EOL>","gt":"case ts.SyntaxKind.FunctionDeclaration:"}
{"input":"<s> function callbackCaller2(cb: Function): void {<EOL>","gt":"cb();"}
{"input":"<s> function makeCompletionItem(rawSnippet: TMSnippet): CompletionItem {<EOL>    const item: any = new CompletionItem(rawSnippet.prefix);<EOL>    item.documentation = rawSnippet.","gt":"description;"}
{"input":"<s> export function enumerateListOfTypeDefinitions(projectRoot: string): string[] {<EOL>    let typeDefsFolder: any = CordovaProjectHelper.getCordovaPluginTypeDefsPath(projectRoot);<EOL>    <EOL>","gt":"if (!CordovaProjectHelper.existsSync(typeDefsFolder)) {"}
{"input":"<s> export function asFolder(uri: vscode.Uri): string {<EOL>    let result: string = uri.toString();<EOL>","gt":"if (result.charAt(result.length - <NUM_LIT>) !== '<STR_LIT>') {"}
{"input":"<s> <EOL>export function checkInstallLockFile(): Promise<boolean> {<EOL>    return","gt":"checkFileExists(getInstallLockPath());"}
{"input":"<s> export function resolveVariables(input: string): string {<EOL>    if (input === null) {<EOL>        return \"<STR_LIT>\";<EOL>    }<EOL>    <EOL>","gt":"let regexp: RegExp = /\\$\\{((env|config)(.|:))?(.*?)\\}/g;"}
{"input":"<s> export function resolveVariables(input: string): string {<EOL>    if (input === null) {<EOL>        return \"<STR_LIT>\";<EOL>    }<EOL>    <EOL>    let regexp: RegExp = /\\$\\{((env|config)(.|:))?(.*?)\\}/g;<EOL>    let ret: string = input.replace(regexp, (match: string, ignored1: string, varType: string, ignored2: string, name: string): string => {<EOL>        <EOL>        <EOL>        if (varType === undefined) {<EOL>            varType = \"<STR_LIT>\";<EOL>        }<EOL>        let","gt":"newValue: string = undefined;"}
{"input":"<s> export function resolveVariables(input: string): string {<EOL>    if (input === null) {<EOL>        return \"<STR_LIT>\";<EOL>    }<EOL>    <EOL>    let regexp: RegExp = /\\$\\{((env|config)(.|:))?(.*?)\\}/g;<EOL>    let ret: string = input.replace(regexp, (match: string, ignored1: string, varType: string, ignored2: string, name: string): string => {<EOL>        <EOL>        <EOL>        if (varType === undefined) {<EOL>            varType = \"<STR_LIT>\";<EOL>        }<EOL>        let newValue: string = undefined;<EOL>        switch (varType) {<EOL>            case \"<STR_LIT>\": {<EOL>                newValue = process.env[name];<EOL>","gt":"break;"}
{"input":"<s> export function resolveVariables(input: string): string {<EOL>    if (input === null) {<EOL>        return \"<STR_LIT>\";<EOL>    }<EOL>    <EOL>    let regexp: RegExp = /\\$\\{((env|config)(.|:))?(.*?)\\}/g;<EOL>    let ret: string = input.replace(regexp, (match: string, ignored1: string, varType: string, ignored2: string, name: string): string => {<EOL>        <EOL>        <EOL>        if (varType === undefined) {<EOL>            varType = \"<STR_LIT>\";<EOL>        }<EOL>        let newValue: string = undefined;<EOL>        switch (varType) {<EOL>            case \"<STR_LIT>\": {<EOL>                newValue = process.env[name];<EOL>                break;<EOL>            }<EOL>            case \"<STR_LIT>\": {<EOL>                let config: vscode.WorkspaceConfiguration = vscode.workspace.getConfiguration();<EOL>                let keys:","gt":"string[] = name.split('<STR_LIT>');"}
{"input":"<s> export function spawnChildProcess(process: string, args: string[], workingDirectory: string, dataCallback: (stdout: string) => void, errorCallback: (stderr: string) => void): Promise<void> {<EOL>    return new Promise<void>(function (resolve, reject): void {<EOL>        const child: child_process.ChildProcess = child_process.spawn(process, args, { cwd: workingDirectory });<EOL>        child.stdout.on('<STR_LIT>', (data: any): void => {<EOL>            dataCallback(`<STR_LIT>`);<EOL>        });<EOL>        child.stderr.on(","gt":"'<STR_LIT>', (data: any): void => {"}
{"input":"<s> export function spawnChildProcess(process: string, args: string[], workingDirectory: string, dataCallback: (stdout: string) => void, errorCallback: (stderr: string) => void): Promise<void> {<EOL>    return new Promise<void>(function (resolve, reject): void {<EOL>        const child: child_process.ChildProcess = child_process.spawn(process, args, { cwd: workingDirectory });<EOL>        child.stdout.on('<STR_LIT>', (data: any): void => {<EOL>            dataCallback(`<STR_LIT>`);<EOL>        });<EOL>        child.stderr.on('<STR_LIT>', (data: any): void => {<EOL>            errorCallback(`<STR_LIT>`);<EOL>        });<EOL>        child.on('<STR_LIT>', (code: number): void => {<EOL>            if (code !==","gt":"<NUM_LIT>) {"}
{"input":"<s> export function spawnChildProcess(process: string, args: string[], workingDirectory: string, dataCallback: (stdout: string) => void, errorCallback: (stderr: string) => void): Promise<void> {<EOL>    return new Promise<void>(function (resolve, reject): void {<EOL>        const child: child_process.ChildProcess = child_process.spawn(process, args, { cwd: workingDirectory });<EOL>        child.stdout.on('<STR_LIT>', (data: any): void => {<EOL>            dataCallback(`<STR_LIT>`);<EOL>        });<EOL>        child.stderr.on('<STR_LIT>', (data: any): void => {<EOL>            errorCallback(`<STR_LIT>`);<EOL>        });<EOL>        child.on('<STR_LIT>', (code: number): void => {<EOL>            if (code !== <NUM_LIT>) {<EOL>                reject(new Error(`<STR_LIT>`));<EOL>            }<EOL>","gt":"else {"}
{"input":"<s> function CreateRemoteAttachString(name: string, type: string, executable: string): string {<EOL>    return","gt":"executable}\"<STR_LIT>,"}
{"input":"<s> function getMessage(err: any, document: TextDocument): string {<EOL>    let result: string = null;<EOL>    if (typeof err.message === '<STR_LIT>' || err.message instanceof String) {<EOL>        result = <string>err.message;<EOL>        result = result.replace(/\\r?\\n/g,","gt":"'<STR_LIT>');"}
{"input":"<s> function getMessage(err: any, document: TextDocument): string {<EOL>    let result: string = null;<EOL>    if (typeof err.message === '<STR_LIT>' || err.message instanceof String) {<EOL>        result = <string>err.message;<EOL>        result = result.replace(/\\r?\\n/g, '<STR_LIT>');<EOL>        if (/^CLI: /.test(result)) {<EOL>            result = result.substr(<NUM_LIT>);<EOL>        }<EOL>    }<EOL>    else {<EOL>","gt":"result = `<STR_LIT>`;"}
{"input":"<s> export function activate(context: ExtensionContext): void {<EOL>    <EOL>    const status: any = window.createStatusBarItem(StatusBarAlignment.Left, <NUM_LIT>);<EOL>    context.subscriptions.push(status);<EOL>    <EOL>    context.subscriptions.push(workspace.onDidChangeWorkspaceFolders((e: any): void => updateStatus(status)));<EOL>    <EOL>    context.subscriptions.push(workspace.onDidChangeConfiguration((e: any): any => this.updateStatus(status)));<EOL>    <EOL>    context.subscriptions.push(window.onDidChangeActiveTextEditor((e: any): void => updateStatus(status)));<EOL>    context.subscriptions.push(","gt":"window.onDidChangeTextEditorViewColumn((e: any): void => updateStatus(status)));"}
{"input":"<s> export function deactivate(): Thenable<void> {<EOL>    if (!client) {<EOL>","gt":"return undefined;"}
{"input":"<s> export function activate(context: vscode.ExtensionContext): void {<EOL>    const registration: vscode.Disposable = vscode.languages.registerDocumentLinkProvider({ language: '<STR_LIT>', pattern: '<STR_LIT>' }, _linkProvider);<EOL>","gt":"context.subscriptions.push(registration);"}
{"input":"<s> function _memoize(fn: Function, key: string): Function {<EOL>    const memoizeKey: string = `<STR_LIT>`;<EOL>    return function (this: any, ...args: any[]) {<EOL>        if (!this.hasOwnProperty(memoizeKey)) {<EOL>","gt":"Object.defineProperty(this, memoizeKey, {"}
{"input":"<s> function findGitWin32(onLookup: (path: string) => void): Promise<IGit> {<EOL>    return findSystemGitWin32(process.env['<STR_LIT>'] as string, onLookup)<EOL>        .","gt":"then(void <NUM_LIT>, (): Promise<IGit> => findSystemGitWin32(process.env['<STR_LIT>'] as string, onLookup))"}
{"input":"<s> export function assign<T>(destination: T, ...sources: any[]): T {<EOL>    for (const source: any of sources) {<EOL>        Object.keys(source).","gt":"forEach((key: string): any => (destination as any)[key] = source[key]);"}
{"input":"<s> export function detectUnicodeEncoding(buffer: Buffer): Encoding | null {<EOL>    if (buffer.length < <NUM_LIT>) {<EOL>        return null;<EOL>    }<EOL>    const b0: any = buffer.readUInt8(<NUM_LIT>);<EOL>    const b1: any = buffer.readUInt8(<NUM_LIT>);<EOL>","gt":"if (b0 === <NUM_LIT> && b1 === <NUM_LIT>) {"}
{"input":"<s> export function detectUnicodeEncoding(buffer: Buffer): Encoding | null {<EOL>    if (buffer.length < <NUM_LIT>) {<EOL>        return null;<EOL>    }<EOL>    const b0: any = buffer.readUInt8(<NUM_LIT>);<EOL>    const b1: any = buffer.readUInt8(<NUM_LIT>);<EOL>    if (b0 === <NUM_LIT> && b1 === <NUM_LIT>) {<EOL>        return Encoding.UTF16be;<EOL>    }<EOL>    if (b0 === <NUM_LIT> && b1 === <NUM_LIT>) {<EOL>        return Encoding.UTF16le;<EOL>    }<EOL>    if (buffer.length < <NUM_LIT>) {<EOL>        return null;<EOL>    }<EOL>    const b2: any = buffer.readUInt8(","gt":"<NUM_LIT>);"}
{"input":"<s> export function find<T>(array: T[], fn: (t: T) => boolean): T | undefined {<EOL>    let result: T | undefined = undefined;<EOL>    array.some((e: T): boolean => {<EOL>        if (","gt":"fn(e)) {"}
{"input":"<s> function cleanPendingValidation(textDocument: TextDocument): void {<EOL>    let request: NodeJS.Timer = pendingValidationRequests[textDocument.uri];<EOL>","gt":"if (request) {"}
{"input":"<s> function getPackageInfo(context: ExtensionContext): IPackageInfo | undefined {<EOL>    let extensionPackage: any = require(context.asAbsolutePath('<STR_LIT>'));<EOL>    if (extensionPackage) {<EOL>","gt":"return {"}
{"input":"<s> function cleanPendingValidation(textDocument: TextDocument): void {<EOL>    let request: NodeJS.Timer = pendingValidationRequests[textDocument.uri];<EOL>    if (","gt":"request) {"}
{"input":"<s> function isBuildTask(name: string): boolean {<EOL>    for (let buildName: string of buildNames) {<EOL>        if (","gt":"name.indexOf(buildName) !== -<NUM_LIT>) {"}
{"input":"<s> export function fork(modulePath: string, args: string[], options: IForkOptions, logger: Logger, callback: (error: any, cp: cp.ChildProcess | null) => void): void {<EOL>    let callbackCalled: boolean = false;<EOL>    const resolve: (result: cp.ChildProcess) => void = (result: cp.ChildProcess): void => {<EOL>        if (","gt":"callbackCalled) {"}
{"input":"<s> export function fork(modulePath: string, args: string[], options: IForkOptions, logger: Logger, callback: (error: any, cp: cp.ChildProcess | null) => void): void {<EOL>    let callbackCalled: boolean = false;<EOL>    const resolve: (result: cp.ChildProcess) => void = (result: cp.ChildProcess): void => {<EOL>        if (callbackCalled) {<EOL>            return;<EOL>        }<EOL>        callbackCalled =","gt":"true;"}
{"input":"<s> export function fork(modulePath: string, args: string[], options: IForkOptions, logger: Logger, callback: (error: any, cp: cp.ChildProcess | null) => void): void {<EOL>    let callbackCalled: boolean = false;<EOL>    const resolve: (result: cp.ChildProcess) => void = (result: cp.ChildProcess): void => {<EOL>        if (callbackCalled) {<EOL>            return;<EOL>        }<EOL>        callbackCalled = true;<EOL>        callback(null, result);<EOL>    };<EOL>    const reject: (err: any) => void = (err: any): void => {<EOL>        if (callbackCalled) {<EOL>            return;<EOL>        }<EOL>","gt":"callbackCalled = true;"}
{"input":"<s> export function fork(modulePath: string, args: string[], options: IForkOptions, logger: Logger, callback: (error: any, cp: cp.ChildProcess | null) => void): void {<EOL>    let callbackCalled: boolean = false;<EOL>    const resolve: (result: cp.ChildProcess) => void = (result: cp.ChildProcess): void => {<EOL>        if (callbackCalled) {<EOL>            return;<EOL>        }<EOL>        callbackCalled = true;<EOL>        callback(null, result);<EOL>    };<EOL>    const reject: (err: any) => void = (err: any): void => {<EOL>        if (callbackCalled) {<EOL>            return;<EOL>        }<EOL>        callbackCalled = true;<EOL>        callback(err, null);<EOL>    };<EOL>    <EOL>    const stdInPipeName: string = generatePipeName();<EOL>    const stdOutPipeName: string = generatePipeName();<EOL>    const stdErrPipeName: string = generatePipeName();<EOL>    const newEnv: any = generatePatchedEnv(process.env, stdInPipeName, stdOutPipeName, stdErrPipeName);<EOL>    newEnv['<STR_LIT>'] =","gt":"path.join(modulePath, '<STR_LIT>', '<STR_LIT>', '<STR_LIT>');"}
{"input":"<s> export function fork(modulePath: string, args: string[], options: IForkOptions, logger: Logger, callback: (error: any, cp: cp.ChildProcess | null) => void): void {<EOL>    let callbackCalled: boolean = false;<EOL>    const resolve: (result: cp.ChildProcess) => void = (result: cp.ChildProcess): void => {<EOL>        if (callbackCalled) {<EOL>            return;<EOL>        }<EOL>        callbackCalled = true;<EOL>        callback(null, result);<EOL>    };<EOL>    const reject: (err: any) => void = (err: any): void => {<EOL>        if (callbackCalled) {<EOL>            return;<EOL>        }<EOL>        callbackCalled = true;<EOL>        callback(err, null);<EOL>    };<EOL>    <EOL>    const stdInPipeName: string = generatePipeName();<EOL>    const stdOutPipeName: string = generatePipeName();<EOL>    const stdErrPipeName: string = generatePipeName();<EOL>    const newEnv: any = generatePatchedEnv(process.env, stdInPipeName, stdOutPipeName, stdErrPipeName);<EOL>    newEnv['<STR_LIT>'] = path.join(modulePath, '<STR_LIT>', '<STR_LIT>', '<STR_LIT>');<EOL>    let childProcess: cp.ChildProcess;<EOL>    <EOL>    let stdErrServer: any = net.createServer((stdErrStream: any): void => {<EOL>        <EOL>        childProcess.stderr = stdErrStream;<EOL>    });<EOL>    stdErrServer.listen(","gt":"stdErrPipeName);"}
{"input":"<s> export function fork(modulePath: string, args: string[], options: IForkOptions, logger: Logger, callback: (error: any, cp: cp.ChildProcess | null) => void): void {<EOL>    let callbackCalled: boolean = false;<EOL>    const resolve: (result: cp.ChildProcess) => void = (result: cp.ChildProcess): void => {<EOL>        if (callbackCalled) {<EOL>            return;<EOL>        }<EOL>        callbackCalled = true;<EOL>        callback(null, result);<EOL>    };<EOL>    const reject: (err: any) => void = (err: any): void => {<EOL>        if (callbackCalled) {<EOL>            return;<EOL>        }<EOL>        callbackCalled = true;<EOL>        callback(err, null);<EOL>    };<EOL>    <EOL>    const stdInPipeName: string = generatePipeName();<EOL>    const stdOutPipeName: string = generatePipeName();<EOL>    const stdErrPipeName: string = generatePipeName();<EOL>    const newEnv: any = generatePatchedEnv(process.env, stdInPipeName, stdOutPipeName, stdErrPipeName);<EOL>    newEnv['<STR_LIT>'] = path.join(modulePath, '<STR_LIT>', '<STR_LIT>', '<STR_LIT>');<EOL>    let childProcess: cp.ChildProcess;<EOL>    <EOL>    let stdErrServer: any = net.createServer((stdErrStream: any): void => {<EOL>        <EOL>        childProcess.stderr = stdErrStream;<EOL>    });<EOL>    stdErrServer.listen(stdErrPipeName);<EOL>    <EOL>    let stdOutServer: any = net.createServer((stdOutStream: any): void => {<EOL>        <EOL>        stdOutStream.once('<STR_LIT>', (_chunk: Buffer): void => {<EOL>            <EOL>            childProcess.stdin = <any>net.connect(stdInPipeName);<EOL>            <EOL>","gt":"childProcess.stdout = stdOutStream;"}
{"input":"<s> export function fork(modulePath: string, args: string[], options: IForkOptions, logger: Logger, callback: (error: any, cp: cp.ChildProcess | null) => void): void {<EOL>    let callbackCalled: boolean = false;<EOL>    const resolve: (result: cp.ChildProcess) => void = (result: cp.ChildProcess): void => {<EOL>        if (callbackCalled) {<EOL>            return;<EOL>        }<EOL>        callbackCalled = true;<EOL>        callback(null, result);<EOL>    };<EOL>    const reject: (err: any) => void = (err: any): void => {<EOL>        if (callbackCalled) {<EOL>            return;<EOL>        }<EOL>        callbackCalled = true;<EOL>        callback(err, null);<EOL>    };<EOL>    <EOL>    const stdInPipeName: string = generatePipeName();<EOL>    const stdOutPipeName: string = generatePipeName();<EOL>    const stdErrPipeName: string = generatePipeName();<EOL>    const newEnv: any = generatePatchedEnv(process.env, stdInPipeName, stdOutPipeName, stdErrPipeName);<EOL>    newEnv['<STR_LIT>'] = path.join(modulePath, '<STR_LIT>', '<STR_LIT>', '<STR_LIT>');<EOL>    let childProcess: cp.ChildProcess;<EOL>    <EOL>    let stdErrServer: any = net.createServer((stdErrStream: any): void => {<EOL>        <EOL>        childProcess.stderr = stdErrStream;<EOL>    });<EOL>    stdErrServer.listen(stdErrPipeName);<EOL>    <EOL>    let stdOutServer: any = net.createServer((stdOutStream: any): void => {<EOL>        <EOL>        stdOutStream.once('<STR_LIT>', (_chunk: Buffer): void => {<EOL>            <EOL>            childProcess.stdin = <any>net.connect(stdInPipeName);<EOL>            <EOL>            childProcess.stdout = stdOutStream;<EOL>            resolve(childProcess);<EOL>        });<EOL>    });<EOL>    stdOutServer.","gt":"listen(stdOutPipeName);"}
{"input":"<s> export function fork(modulePath: string, args: string[], options: IForkOptions, logger: Logger, callback: (error: any, cp: cp.ChildProcess | null) => void): void {<EOL>    let callbackCalled: boolean = false;<EOL>    const resolve: (result: cp.ChildProcess) => void = (result: cp.ChildProcess): void => {<EOL>        if (callbackCalled) {<EOL>            return;<EOL>        }<EOL>        callbackCalled = true;<EOL>        callback(null, result);<EOL>    };<EOL>    const reject: (err: any) => void = (err: any): void => {<EOL>        if (callbackCalled) {<EOL>            return;<EOL>        }<EOL>        callbackCalled = true;<EOL>        callback(err, null);<EOL>    };<EOL>    <EOL>    const stdInPipeName: string = generatePipeName();<EOL>    const stdOutPipeName: string = generatePipeName();<EOL>    const stdErrPipeName: string = generatePipeName();<EOL>    const newEnv: any = generatePatchedEnv(process.env, stdInPipeName, stdOutPipeName, stdErrPipeName);<EOL>    newEnv['<STR_LIT>'] = path.join(modulePath, '<STR_LIT>', '<STR_LIT>', '<STR_LIT>');<EOL>    let childProcess: cp.ChildProcess;<EOL>    <EOL>    let stdErrServer: any = net.createServer((stdErrStream: any): void => {<EOL>        <EOL>        childProcess.stderr = stdErrStream;<EOL>    });<EOL>    stdErrServer.listen(stdErrPipeName);<EOL>    <EOL>    let stdOutServer: any = net.createServer((stdOutStream: any): void => {<EOL>        <EOL>        stdOutStream.once('<STR_LIT>', (_chunk: Buffer): void => {<EOL>            <EOL>            childProcess.stdin = <any>net.connect(stdInPipeName);<EOL>            <EOL>            childProcess.stdout = stdOutStream;<EOL>            resolve(childProcess);<EOL>        });<EOL>    });<EOL>    stdOutServer.listen(stdOutPipeName);<EOL>    let serverClosed: boolean = false;<EOL>    const","gt":"closeServer: () => void = (): void => {"}
{"input":"<s> export function fork(modulePath: string, args: string[], options: IForkOptions, logger: Logger, callback: (error: any, cp: cp.ChildProcess | null) => void): void {<EOL>    let callbackCalled: boolean = false;<EOL>    const resolve: (result: cp.ChildProcess) => void = (result: cp.ChildProcess): void => {<EOL>        if (callbackCalled) {<EOL>            return;<EOL>        }<EOL>        callbackCalled = true;<EOL>        callback(null, result);<EOL>    };<EOL>    const reject: (err: any) => void = (err: any): void => {<EOL>        if (callbackCalled) {<EOL>            return;<EOL>        }<EOL>        callbackCalled = true;<EOL>        callback(err, null);<EOL>    };<EOL>    <EOL>    const stdInPipeName: string = generatePipeName();<EOL>    const stdOutPipeName: string = generatePipeName();<EOL>    const stdErrPipeName: string = generatePipeName();<EOL>    const newEnv: any = generatePatchedEnv(process.env, stdInPipeName, stdOutPipeName, stdErrPipeName);<EOL>    newEnv['<STR_LIT>'] = path.join(modulePath, '<STR_LIT>', '<STR_LIT>', '<STR_LIT>');<EOL>    let childProcess: cp.ChildProcess;<EOL>    <EOL>    let stdErrServer: any = net.createServer((stdErrStream: any): void => {<EOL>        <EOL>        childProcess.stderr = stdErrStream;<EOL>    });<EOL>    stdErrServer.listen(stdErrPipeName);<EOL>    <EOL>    let stdOutServer: any = net.createServer((stdOutStream: any): void => {<EOL>        <EOL>        stdOutStream.once('<STR_LIT>', (_chunk: Buffer): void => {<EOL>            <EOL>            childProcess.stdin = <any>net.connect(stdInPipeName);<EOL>            <EOL>            childProcess.stdout = stdOutStream;<EOL>            resolve(childProcess);<EOL>        });<EOL>    });<EOL>    stdOutServer.listen(stdOutPipeName);<EOL>    let serverClosed: boolean = false;<EOL>    const closeServer: () => void = (): void => {<EOL>        if (serverClosed) {<EOL>            return;<EOL>        }<EOL>        serverClosed = true;<EOL>        stdOutServer.close();<EOL>        stdErrServer.close();<EOL>    };<EOL>    <EOL>    logger.info('<STR_LIT>', `<STR_LIT>`);<EOL>    const bootstrapperPath: any = require.resolve('<STR_LIT>');<EOL>    childProcess = cp.fork(bootstrapperPath, [modulePath].concat(args), {<EOL>        silent: true,<EOL>","gt":"cwd: options.cwd,"}
{"input":"<s> export function fork(modulePath: string, args: string[], options: IForkOptions, logger: Logger, callback: (error: any, cp: cp.ChildProcess | null) => void): void {<EOL>    let callbackCalled: boolean = false;<EOL>    const resolve: (result: cp.ChildProcess) => void = (result: cp.ChildProcess): void => {<EOL>        if (callbackCalled) {<EOL>            return;<EOL>        }<EOL>        callbackCalled = true;<EOL>        callback(null, result);<EOL>    };<EOL>    const reject: (err: any) => void = (err: any): void => {<EOL>        if (callbackCalled) {<EOL>            return;<EOL>        }<EOL>        callbackCalled = true;<EOL>        callback(err, null);<EOL>    };<EOL>    <EOL>    const stdInPipeName: string = generatePipeName();<EOL>    const stdOutPipeName: string = generatePipeName();<EOL>    const stdErrPipeName: string = generatePipeName();<EOL>    const newEnv: any = generatePatchedEnv(process.env, stdInPipeName, stdOutPipeName, stdErrPipeName);<EOL>    newEnv['<STR_LIT>'] = path.join(modulePath, '<STR_LIT>', '<STR_LIT>', '<STR_LIT>');<EOL>    let childProcess: cp.ChildProcess;<EOL>    <EOL>    let stdErrServer: any = net.createServer((stdErrStream: any): void => {<EOL>        <EOL>        childProcess.stderr = stdErrStream;<EOL>    });<EOL>    stdErrServer.listen(stdErrPipeName);<EOL>    <EOL>    let stdOutServer: any = net.createServer((stdOutStream: any): void => {<EOL>        <EOL>        stdOutStream.once('<STR_LIT>', (_chunk: Buffer): void => {<EOL>            <EOL>            childProcess.stdin = <any>net.connect(stdInPipeName);<EOL>            <EOL>            childProcess.stdout = stdOutStream;<EOL>            resolve(childProcess);<EOL>        });<EOL>    });<EOL>    stdOutServer.listen(stdOutPipeName);<EOL>    let serverClosed: boolean = false;<EOL>    const closeServer: () => void = (): void => {<EOL>        if (serverClosed) {<EOL>            return;<EOL>        }<EOL>        serverClosed = true;<EOL>        stdOutServer.close();<EOL>        stdErrServer.close();<EOL>    };<EOL>    <EOL>    logger.info('<STR_LIT>', `<STR_LIT>`);<EOL>    const bootstrapperPath: any = require.resolve('<STR_LIT>');<EOL>    childProcess = cp.fork(bootstrapperPath, [modulePath].concat(args), {<EOL>        silent: true,<EOL>        cwd: options.cwd,<EOL>        env: newEnv,<EOL>        execArgv:","gt":"options."}
{"input":"<s> export function fork(modulePath: string, args: string[], options: IForkOptions, logger: Logger, callback: (error: any, cp: cp.ChildProcess | null) => void): void {<EOL>    let callbackCalled: boolean = false;<EOL>    const resolve: (result: cp.ChildProcess) => void = (result: cp.ChildProcess): void => {<EOL>        if (callbackCalled) {<EOL>            return;<EOL>        }<EOL>        callbackCalled = true;<EOL>        callback(null, result);<EOL>    };<EOL>    const reject: (err: any) => void = (err: any): void => {<EOL>        if (callbackCalled) {<EOL>            return;<EOL>        }<EOL>        callbackCalled = true;<EOL>        callback(err, null);<EOL>    };<EOL>    <EOL>    const stdInPipeName: string = generatePipeName();<EOL>    const stdOutPipeName: string = generatePipeName();<EOL>    const stdErrPipeName: string = generatePipeName();<EOL>    const newEnv: any = generatePatchedEnv(process.env, stdInPipeName, stdOutPipeName, stdErrPipeName);<EOL>    newEnv['<STR_LIT>'] = path.join(modulePath, '<STR_LIT>', '<STR_LIT>', '<STR_LIT>');<EOL>    let childProcess: cp.ChildProcess;<EOL>    <EOL>    let stdErrServer: any = net.createServer((stdErrStream: any): void => {<EOL>        <EOL>        childProcess.stderr = stdErrStream;<EOL>    });<EOL>    stdErrServer.listen(stdErrPipeName);<EOL>    <EOL>    let stdOutServer: any = net.createServer((stdOutStream: any): void => {<EOL>        <EOL>        stdOutStream.once('<STR_LIT>', (_chunk: Buffer): void => {<EOL>            <EOL>            childProcess.stdin = <any>net.connect(stdInPipeName);<EOL>            <EOL>            childProcess.stdout = stdOutStream;<EOL>            resolve(childProcess);<EOL>        });<EOL>    });<EOL>    stdOutServer.listen(stdOutPipeName);<EOL>    let serverClosed: boolean = false;<EOL>    const closeServer: () => void = (): void => {<EOL>        if (serverClosed) {<EOL>            return;<EOL>        }<EOL>        serverClosed = true;<EOL>        stdOutServer.close();<EOL>        stdErrServer.close();<EOL>    };<EOL>    <EOL>    logger.info('<STR_LIT>', `<STR_LIT>`);<EOL>    const bootstrapperPath: any = require.resolve('<STR_LIT>');<EOL>    childProcess = cp.fork(bootstrapperPath, [modulePath].concat(args), {<EOL>        silent: true,<EOL>        cwd: options.cwd,<EOL>        env: newEnv,<EOL>        execArgv: options.","gt":"execArgv"}
{"input":"<s> <EOL>export function toggleTestFile(): void {<EOL>    let editor: any = vscode.window.activeTextEditor;<EOL>    if (!editor) {<EOL>        vscode.window.showInformationMessage('<STR_LIT>');<EOL>        return;<EOL>    }<EOL>    let currentFilePath: any = editor.document.fileName;<EOL>    if (!currentFilePath.endsWith('<STR_LIT>')) {<EOL>        vscode.","gt":"window.showInformationMessage('<STR_LIT>');"}
{"input":"<s> <EOL>export function toggleTestFile(): void {<EOL>    let editor: any = vscode.window.activeTextEditor;<EOL>    if (!editor) {<EOL>        vscode.window.showInformationMessage('<STR_LIT>');<EOL>        return;<EOL>    }<EOL>    let currentFilePath: any = editor.document.fileName;<EOL>    if (!currentFilePath.endsWith('<STR_LIT>')) {<EOL>        vscode.window.showInformationMessage('<STR_LIT>');<EOL>        return;<EOL>    }<EOL>    let targetFilePath: string = '<STR_LIT>';<EOL>    if (currentFilePath.endsWith('<STR_LIT>')) {<EOL>        targetFilePath = currentFilePath.substr(<NUM_LIT>, currentFilePath.lastIndexOf('<STR_LIT>')) +","gt":"'<STR_LIT>';"}
{"input":"<s> <EOL>export function toggleTestFile(): void {<EOL>    let editor: any = vscode.window.activeTextEditor;<EOL>    if (!editor) {<EOL>        vscode.window.showInformationMessage('<STR_LIT>');<EOL>        return;<EOL>    }<EOL>    let currentFilePath: any = editor.document.fileName;<EOL>    if (!currentFilePath.endsWith('<STR_LIT>')) {<EOL>        vscode.window.showInformationMessage('<STR_LIT>');<EOL>        return;<EOL>    }<EOL>    let targetFilePath: string = '<STR_LIT>';<EOL>    if (currentFilePath.endsWith('<STR_LIT>')) {<EOL>        targetFilePath = currentFilePath.substr(<NUM_LIT>, currentFilePath.lastIndexOf('<STR_LIT>')) + '<STR_LIT>';<EOL>    }<EOL>    else {<EOL>        targetFilePath = currentFilePath.substr(<NUM_LIT>, currentFilePath.lastIndexOf('<STR_LIT>')) + '<STR_LIT>';<EOL>    }<EOL>    for (let doc: any of vscode.window.visibleTextEditors) {<EOL>        if (","gt":"doc.document.fileName === targetFilePath) {"}
{"input":"<s> function expandFilePathInOutput(output: string, cwd: string): string {<EOL>    let lines: string[] = output.split('<STR_LIT>');<EOL>    for (let i: number = <NUM_LIT>; i < lines.length; i++) {<EOL>        let matches:","gt":"RegExpMatchArray = lines[i].match(/^\\s+(\\S+_test.go):(\\d+):/);"}
{"input":"<s> export function getBinPath(tool: string): string {<EOL>    return getBinPathWithPreferredGopath(tool, getToolsGopath(),","gt":"getCurrentGoPath());"}
{"input":"<s> <EOL>export function isVendorSupported(): Promise<boolean> {<EOL>    if (vendorSupport != null) {<EOL>        return Promise.resolve(vendorSupport);<EOL>    }<EOL>    return getGoVersion().","gt":"then((version: SemVersion): boolean => {"}
{"input":"<s> <EOL>export function isVendorSupported(): Promise<boolean> {<EOL>    if (vendorSupport != null) {<EOL>        return Promise.resolve(vendorSupport);<EOL>    }<EOL>    return getGoVersion().then((version: SemVersion): boolean => {<EOL>        if (!version) {<EOL>            return process.env['<STR_LIT>'] === '<STR_LIT>' ? false : true;<EOL>        }<EOL>        switch (version.major) {<EOL>            case <NUM_LIT>:<EOL>                vendorSupport = false;<EOL>","gt":"break;"}
{"input":"<s> <EOL>export function isVendorSupported(): Promise<boolean> {<EOL>    if (vendorSupport != null) {<EOL>        return Promise.resolve(vendorSupport);<EOL>    }<EOL>    return getGoVersion().then((version: SemVersion): boolean => {<EOL>        if (!version) {<EOL>            return process.env['<STR_LIT>'] === '<STR_LIT>' ? false : true;<EOL>        }<EOL>        switch (version.major) {<EOL>            case <NUM_LIT>:<EOL>                vendorSupport = false;<EOL>                break;<EOL>            case <NUM_LIT>:<EOL>                vendorSupport = (version.minor > <NUM_LIT> || ((version.minor === <NUM_LIT> || version.minor === <NUM_LIT>) && process.env['<STR_LIT>'] === '<STR_LIT>')) ? true : false;<EOL>                break;<EOL>            default:<EOL>","gt":"vendorSupport = true;"}
{"input":"<s> export function isUUID(value: string): boolean {<EOL>","gt":"return _UUIDPattern.test(value);"}
{"input":"<s> export function v4(): UUID {<EOL>    return","gt":"new V4UUID();"}
{"input":"<s> function setupExitTimer(): void {<EOL>    const argName: string = '<STR_LIT>';<EOL>    function runTimer(value: string): void {<EOL>","gt":"try {"}
{"input":"<s> function setupExitTimer(): void {<EOL>    const argName: string = '<STR_LIT>';<EOL>    function runTimer(value: string): void {<EOL>        try {<EOL>            let processId: number = parseInt(value);<EOL>            if (!isNaN(processId)) {<EOL>                exitTimer = setInterval((): void => {<EOL>","gt":"try {"}
{"input":"<s> function setupExitTimer(): void {<EOL>    const argName: string = '<STR_LIT>';<EOL>    function runTimer(value: string): void {<EOL>        try {<EOL>            let processId: number = parseInt(value);<EOL>            if (!isNaN(processId)) {<EOL>                exitTimer = setInterval((): void => {<EOL>                    try {<EOL>                        process.kill(processId, <any><NUM_LIT>);<EOL>                    }<EOL>                    catch (ex: any) {<EOL>                        <EOL>                        process.exit(shutdownReceived ? <NUM_LIT> : <NUM_LIT>);<EOL>                    }<EOL>                },","gt":"<NUM_LIT>);"}
{"input":"<s> export function isUUID(value: string): boolean {<EOL>    return","gt":"_UUIDPattern.test(value);"}
{"input":"<s> function _readCoverOptions(testsRoot: string): ITestRunnerOptions {<EOL>    let coverConfigPath: string = paths.join(testsRoot, testOptions.coverConfig);<EOL>    let coverConfig: ITestRunnerOptions = undefined;<EOL>    if (fs.","gt":"existsSync(coverConfigPath)) {"}
{"input":"<s> <EOL>function setupStandardQueryRequestServiceMock(testSqlToolsServerClient: TypeMoq.IMock<SqlToolsServerClient>, returnCallback: (...x: any[]) => Thenable<QueryDisposeContracts.QueryDisposeResult>): void {<EOL>    testSqlToolsServerClient.setup((x: any): any => x.sendRequest(TypeMoq.It.isValue(QueryExecuteContracts.QueryExecuteRequest.type), TypeMoq.It.isAny()))<EOL>        .callback((type: any, details: QueryExecuteParams): void => {<EOL>        assert.","gt":"equal(details.ownerUri, standardUri);"}
{"input":"<s> export function addDisposableNonBubblingMouseOutListener(node: Element, handler: (event: MouseEvent) => void): IDisposable {<EOL>    return addDisposableListener(node, '<STR_LIT>', (e: MouseEvent): void => {<EOL>        <EOL>        let toElement: Node = <Node>(e.relatedTarget || e.toElement);<EOL>        while (","gt":"toElement && toElement !== node) {"}
{"input":"<s> <EOL>export function getDomNodePagePosition(domNode: HTMLElement): IDomNodePagePosition {<EOL>    let bb: DOMRect = domNode.getBoundingClientRect();<EOL>    return {<EOL>        left:","gt":"bb.left + StandardWindow.scrollX,"}
{"input":"<s> function _renderFormattedText(element: Node, treeNode: IFormatParseTree, actionHandler?: IContentActionHandler): void {<EOL>    let child: Node;<EOL>    if (treeNode.type === FormatType.Text) {<EOL>        child =","gt":"document.createTextNode(treeNode.content);"}
{"input":"<s> function _renderFormattedText(element: Node, treeNode: IFormatParseTree, actionHandler?: IContentActionHandler): void {<EOL>    let child: Node;<EOL>    if (treeNode.type === FormatType.Text) {<EOL>        child = document.createTextNode(treeNode.content);<EOL>    }<EOL>    else if (treeNode.type === FormatType.Bold) {<EOL>","gt":"child = document.createElement('<STR_LIT>');"}
{"input":"<s> function _renderFormattedText(element: Node, treeNode: IFormatParseTree, actionHandler?: IContentActionHandler): void {<EOL>    let child: Node;<EOL>    if (treeNode.type === FormatType.Text) {<EOL>        child = document.createTextNode(treeNode.content);<EOL>    }<EOL>    else if (treeNode.type === FormatType.Bold) {<EOL>        child = document.createElement('<STR_LIT>');<EOL>    }<EOL>    else if (treeNode.type === FormatType.Italics) {<EOL>        child = document.createElement('<STR_LIT>');<EOL>    }<EOL>    else if (treeNode.type === FormatType.Action && actionHandler) {<EOL>        const a: HTMLAnchorElement = document.createElement('<STR_LIT>');<EOL>        a.href = '<STR_LIT>';<EOL>        actionHandler.disposeables.push(DOM.addStandardDisposableListener(a, '<STR_LIT>', (","gt":"event: IMouseEvent): void => {"}
{"input":"<s> function _renderFormattedText(element: Node, treeNode: IFormatParseTree, actionHandler?: IContentActionHandler): void {<EOL>    let child: Node;<EOL>    if (treeNode.type === FormatType.Text) {<EOL>        child = document.createTextNode(treeNode.content);<EOL>    }<EOL>    else if (treeNode.type === FormatType.Bold) {<EOL>        child = document.createElement('<STR_LIT>');<EOL>    }<EOL>    else if (treeNode.type === FormatType.Italics) {<EOL>        child = document.createElement('<STR_LIT>');<EOL>    }<EOL>    else if (treeNode.type === FormatType.Action && actionHandler) {<EOL>        const a: HTMLAnchorElement = document.createElement('<STR_LIT>');<EOL>        a.href = '<STR_LIT>';<EOL>        actionHandler.disposeables.push(DOM.addStandardDisposableListener(a, '<STR_LIT>', (event: IMouseEvent): void => {<EOL>            actionHandler.callback(String(treeNode.index), event);<EOL>        }));<EOL>        child =","gt":"a;"}
{"input":"<s> function _renderFormattedText(element: Node, treeNode: IFormatParseTree, actionHandler?: IContentActionHandler): void {<EOL>    let child: Node;<EOL>    if (treeNode.type === FormatType.Text) {<EOL>        child = document.createTextNode(treeNode.content);<EOL>    }<EOL>    else if (treeNode.type === FormatType.Bold) {<EOL>        child = document.createElement('<STR_LIT>');<EOL>    }<EOL>    else if (treeNode.type === FormatType.Italics) {<EOL>        child = document.createElement('<STR_LIT>');<EOL>    }<EOL>    else if (treeNode.type === FormatType.Action && actionHandler) {<EOL>        const a: HTMLAnchorElement = document.createElement('<STR_LIT>');<EOL>        a.href = '<STR_LIT>';<EOL>        actionHandler.disposeables.push(DOM.addStandardDisposableListener(a, '<STR_LIT>', (event: IMouseEvent): void => {<EOL>            actionHandler.callback(String(treeNode.index), event);<EOL>        }));<EOL>        child = a;<EOL>    }<EOL>    else if (treeNode.type === FormatType.NewLine) {<EOL>        child = document.createElement('<STR_LIT>');<EOL>    }<EOL>    else if (treeNode.type === FormatType.Root) {<EOL>        child = element;<EOL>    }<EOL>","gt":"if (element !== child) {"}
{"input":"<s> export function setARIAContainer(parent: HTMLElement): void {<EOL>    ariaContainer = document.createElement('<STR_LIT>');<EOL>    ariaContainer.className = '<STR_LIT>';<EOL>    alertContainer = document.createElement('<STR_LIT>');<EOL>    alertContainer.","gt":"className = '<STR_LIT>';"}
{"input":"<s> export function setARIAContainer(parent: HTMLElement): void {<EOL>    ariaContainer = document.createElement('<STR_LIT>');<EOL>    ariaContainer.className = '<STR_LIT>';<EOL>    alertContainer = document.createElement('<STR_LIT>');<EOL>    alertContainer.className = '<STR_LIT>';<EOL>    alertContainer.setAttribute('<STR_LIT>', '<STR_LIT>');<EOL>    alertContainer.setAttribute('<STR_LIT>', '<STR_LIT>');<EOL>    ariaContainer.appendChild(alertContainer);<EOL>    statusContainer = document.createElement('<STR_LIT>');<EOL>    statusContainer.className = '<STR_LIT>';<EOL>    statusContainer.","gt":"setAttribute('<STR_LIT>', '<STR_LIT>');"}
{"input":"<s> function isInputElement(e: HTMLElement): boolean {<EOL>    return e.","gt":"tagName === '<STR_LIT>' || e.tagName === '<STR_LIT>';"}
{"input":"<s> <EOL>export function consolidate(groups: IRangedGroup[]): IRangedGroup[] {<EOL>    const result: IRangedGroup[] = [];<EOL>    let previousGroup: IRangedGroup = null;<EOL>    for (let group: IRangedGroup of groups) {<EOL>        const start: number = group.range.start;<EOL>","gt":"const end: number = group.range.end;"}
{"input":"<s> <EOL>export function consolidate(groups: IRangedGroup[]): IRangedGroup[] {<EOL>    const result: IRangedGroup[] = [];<EOL>    let previousGroup: IRangedGroup = null;<EOL>    for (let group: IRangedGroup of groups) {<EOL>        const start: number = group.range.start;<EOL>        const end: number = group.range.end;<EOL>        const size: number = group.size;<EOL>        if (previousGroup && size === previousGroup.size) {<EOL>            previousGroup.range.end = end;<EOL>            continue;<EOL>        }<EOL>","gt":"previousGroup = { range: { start, end }, size };"}
{"input":"<s> export function toThenable<T>(arg: T | Thenable<T>): Thenable<T> {<EOL>    if (isThenable(arg)) {<EOL>","gt":"return arg;"}
{"input":"<s> function fifo(array: any[], size: number): void {<EOL>","gt":"while (array.length > size) {"}
{"input":"<s> export function illegalState(name?: string): Error {<EOL>    if (name) {<EOL>        return new","gt":"Error(`<STR_LIT>`);"}
{"input":"<s> function isNumber(code: number): boolean {<EOL>    return CharCode.Digit0 <=","gt":"code && code <= CharCode.Digit9;"}
{"input":"<s> export function once<T extends Function>(this: any, fn: T): T {<EOL>    const _this: any = this;<EOL>    let didCall: boolean = false;<EOL>    let result: any;<EOL>    return","gt":"function () {"}
{"input":"<s> export function once<T extends Function>(this: any, fn: T): T {<EOL>    const _this: any = this;<EOL>    let didCall: boolean = false;<EOL>    let result: any;<EOL>    return function () {<EOL>        if (didCall) {<EOL>            return result;<EOL>        }<EOL>        didCall = true;<EOL>        result = fn.apply(","gt":"_this, arguments);"}
{"input":"<s> function parseExpressionPattern(pattern: string, value: any, options: IGlobOptions): (ParsedStringPattern | ParsedExpressionPattern) {<EOL>    if (value === false) {<EOL>        return NULL; <EOL>    }<EOL>","gt":"const parsedPattern: ParsedStringPattern = parsePattern(pattern, options);"}
{"input":"<s> function parseExpressionPattern(pattern: string, value: any, options: IGlobOptions): (ParsedStringPattern | ParsedExpressionPattern) {<EOL>    if (value === false) {<EOL>        return NULL; <EOL>    }<EOL>    const parsedPattern: ParsedStringPattern = parsePattern(pattern, options);<EOL>    if (parsedPattern === NULL) {<EOL>        return","gt":"NULL;"}
{"input":"<s> function parseExpressionPattern(pattern: string, value: any, options: IGlobOptions): (ParsedStringPattern | ParsedExpressionPattern) {<EOL>    if (value === false) {<EOL>        return NULL; <EOL>    }<EOL>    const parsedPattern: ParsedStringPattern = parsePattern(pattern, options);<EOL>    if (parsedPattern === NULL) {<EOL>        return NULL;<EOL>    }<EOL>    <EOL>    if (typeof value === '<STR_LIT>') {<EOL>        return parsedPattern;<EOL>    }<EOL>    <EOL>    if (","gt":"value) {"}
{"input":"<s> function parseExpressionPattern(pattern: string, value: any, options: IGlobOptions): (ParsedStringPattern | ParsedExpressionPattern) {<EOL>    if (value === false) {<EOL>        return NULL; <EOL>    }<EOL>    const parsedPattern: ParsedStringPattern = parsePattern(pattern, options);<EOL>    if (parsedPattern === NULL) {<EOL>        return NULL;<EOL>    }<EOL>    <EOL>    if (typeof value === '<STR_LIT>') {<EOL>        return parsedPattern;<EOL>    }<EOL>    <EOL>    if (value) {<EOL>        const when: string = (<SiblingClause>value).when;<EOL>        if (typeof when === '<STR_LIT>') {<EOL>            const siblingsPatternToMatchingPattern: (siblingsPattern: SiblingsPattern) => string = (siblingsPattern: SiblingsPattern): string => {<EOL>                let clausePattern: string = when.replace('<STR_LIT>', siblingsPattern.name);<EOL>","gt":"if (siblingsPattern.siblings.indexOf(clausePattern) !== -<NUM_LIT>) {"}
{"input":"<s> function parseExpressionPattern(pattern: string, value: any, options: IGlobOptions): (ParsedStringPattern | ParsedExpressionPattern) {<EOL>    if (value === false) {<EOL>        return NULL; <EOL>    }<EOL>    const parsedPattern: ParsedStringPattern = parsePattern(pattern, options);<EOL>    if (parsedPattern === NULL) {<EOL>        return NULL;<EOL>    }<EOL>    <EOL>    if (typeof value === '<STR_LIT>') {<EOL>        return parsedPattern;<EOL>    }<EOL>    <EOL>    if (value) {<EOL>        const when: string = (<SiblingClause>value).when;<EOL>        if (typeof when === '<STR_LIT>') {<EOL>            const siblingsPatternToMatchingPattern: (siblingsPattern: SiblingsPattern) => string = (siblingsPattern: SiblingsPattern): string => {<EOL>                let clausePattern: string = when.replace('<STR_LIT>', siblingsPattern.name);<EOL>                if (siblingsPattern.siblings.indexOf(clausePattern) !== -<NUM_LIT>) {<EOL>                    return pattern;<EOL>                }<EOL>                else {<EOL>                    return null; <EOL>                }<EOL>            };<EOL>            const result: ParsedExpressionPattern = (path: string, basename: string, siblingsPatternFn: () => SiblingsPattern | TPromise<SiblingsPattern>): string | TPromise<string, any> => {<EOL>                if (!parsedPattern(path, basename)) {<EOL>                    return null;<EOL>                }<EOL>                const siblingsPattern: SiblingsPattern | TPromise<SiblingsPattern, any> = siblingsPatternFn();<EOL>                if (!siblingsPattern) {<EOL>                    return null; <EOL>                }<EOL>                return TPromise.is(siblingsPattern) ?<EOL>                    siblingsPattern.then(siblingsPatternToMatchingPattern) :<EOL>                    siblingsPatternToMatchingPattern(","gt":"siblingsPattern);"}
{"input":"<s> function starsToRegExp(starCount: number): string {<EOL>    switch (starCount) {<EOL>        case <NUM_LIT>:<EOL>            return '<STR_LIT>';<EOL>","gt":"case <NUM_LIT>:"}
{"input":"<s> <EOL>export function clearTextMimes(onlyUserConfigured?: boolean): void {<EOL>    if (!onlyUserConfigured) {<EOL>        registeredAssociations = [];<EOL>","gt":"nonUserRegisteredAssociations = [];"}
{"input":"<s> export function suggestFilename(langId: string, prefix: string): string {<EOL>    for (let i: number = <NUM_LIT>; i < registeredAssociations.length; i++) {<EOL>        const association: ITextMimeAssociationItem = registeredAssociations[i];<EOL>        if (association.userConfigured) {<EOL>","gt":"continue;"}
{"input":"<s> export function matchesFuzzyOcticonAware(query: string, target: IParsedOcticons, enableSeparateSubstringMatching = false): IMatch[] {<EOL>    const { text, octiconOffsets } = target;<EOL>    <EOL>    if (!octiconOffsets || octiconOffsets.length === <NUM_LIT>) {<EOL>        return","gt":"matchesFuzzy(query, text, enableSeparateSubstringMatching);"}
{"input":"<s> export function matchesFuzzyOcticonAware(query: string, target: IParsedOcticons, enableSeparateSubstringMatching = false): IMatch[] {<EOL>    const { text, octiconOffsets } = target;<EOL>    <EOL>    if (!octiconOffsets || octiconOffsets.length === <NUM_LIT>) {<EOL>        return matchesFuzzy(query, text, enableSeparateSubstringMatching);<EOL>    }<EOL>    <EOL>    <EOL>    const wordToMatchAgainstWithoutOcticonsTrimmed: string = ltrim(text, '<STR_LIT>');<EOL>    const leadingWhitespaceOffset: number = text.length - wordToMatchAgainstWithoutOcticonsTrimmed.length;<EOL>    <EOL>    const matches: IMatch[] = matchesFuzzy(query,","gt":"wordToMatchAgainstWithoutOcticonsTrimmed, enableSeparateSubstringMatching);"}
{"input":"<s> export function matchesFuzzyOcticonAware(query: string, target: IParsedOcticons, enableSeparateSubstringMatching = false): IMatch[] {<EOL>    const { text, octiconOffsets } = target;<EOL>    <EOL>    if (!octiconOffsets || octiconOffsets.length === <NUM_LIT>) {<EOL>        return matchesFuzzy(query, text, enableSeparateSubstringMatching);<EOL>    }<EOL>    <EOL>    <EOL>    const wordToMatchAgainstWithoutOcticonsTrimmed: string = ltrim(text, '<STR_LIT>');<EOL>    const leadingWhitespaceOffset: number = text.length - wordToMatchAgainstWithoutOcticonsTrimmed.length;<EOL>    <EOL>    const matches: IMatch[] = matchesFuzzy(query, wordToMatchAgainstWithoutOcticonsTrimmed, enableSeparateSubstringMatching);<EOL>    <EOL>    if (matches) {<EOL>        for (let i: number = <NUM_LIT>; i < matches.length; i++) {<EOL>            const octiconOffset: number = octiconOffsets[matches[i].start] + leadingWhitespaceOffset ;<EOL>","gt":"matches[i].start += octiconOffset;"}
{"input":"<s> export function parseOcticons(text: string): IParsedOcticons {<EOL>    const firstOcticonIndex: number = text.indexOf(octiconStartMarker);<EOL>","gt":"if (firstOcticonIndex === -<NUM_LIT>) {"}
{"input":"<s> export function isAbsolute_win32(path: string): boolean {<EOL>    if (!path) {<EOL>        return false;<EOL>    }<EOL>    const char0: number = path.charCodeAt(<NUM_LIT>);<EOL>    if (char0 === CharCode.Slash ||","gt":"char0 === CharCode.Backslash) {"}
{"input":"<s> export function isAbsolute_win32(path: string): boolean {<EOL>    if (!path) {<EOL>        return false;<EOL>    }<EOL>    const char0: number = path.charCodeAt(<NUM_LIT>);<EOL>    if (char0 === CharCode.Slash || char0 === CharCode.Backslash) {<EOL>        return true;<EOL>    }<EOL>    else if ((char0 >= CharCode.A && char0 <= CharCode.Z) || (char0 >= CharCode.a && char0 <= CharCode.z)) {<EOL>        if (path.length > <NUM_LIT> && path.charCodeAt(","gt":"<NUM_LIT>) === CharCode.Colon) {"}
{"input":"<s> function _isNormal(path: string, win: boolean): boolean {<EOL>    return","gt":"win"}
{"input":"<s> <EOL>export function pad(n: number, l: number, char: string = '<STR_LIT>'): string {<EOL>    let str: string = '<STR_LIT>' + n;<EOL>","gt":"let r: string[] = [str];"}
{"input":"<s> export function stripUTF8BOM(str: string): string {<EOL>","gt":"return startsWithUTF8BOM(str) ? str.substr(<NUM_LIT>) : str;"}
{"input":"<s> <EOL>export function isFunction(obj: any): obj is Function {<EOL>    return typeof obj ===","gt":"_typeof.function;"}
{"input":"<s> function _encode(ch: string): string {<EOL>    return","gt":"'<STR_LIT>' + ch.charCodeAt(<NUM_LIT>).toString(<NUM_LIT>).toUpperCase();"}
{"input":"<s> export function parse(entry: IRemoteConsoleLog): {<EOL>    args: any[];<EOL>    stack?: string;<EOL>} {<EOL>    const args: any[] = [];<EOL>    let stack: string;<EOL>    <EOL>    try {<EOL>        const parsedArguments: any[] = JSON.parse(entry.arguments);<EOL>        <EOL>        const stackArgument: IStackArgument = parsedArguments[parsedArguments.length - <NUM_LIT>] as IStackArgument;<EOL>        if (stackArgument && stackArgument.__$stack) {<EOL>            parsedArguments.pop(); <EOL>            stack =","gt":"stackArgument.__$stack;"}
{"input":"<s> export function encode(content: string | NodeBuffer, encoding: string, options?: {<EOL>    addBOM?: boolean;<EOL>}): NodeBuffer {<EOL>    return iconv.encode(content, toNodeEncoding(","gt":"encoding), options);"}
{"input":"<s> export function writeFileAndFlushSync(path: string, data: string | NodeBuffer, options?: IWriteFileOptions): void {<EOL>    options = ensureOptions(options);<EOL>    if (options.encoding) {<EOL>        data = encode(data, options.encoding.charset, { addBOM: options.encoding.addBOM });<EOL>    }<EOL>","gt":"if (!canFlush) {"}
{"input":"<s> export function writeFileAndFlushSync(path: string, data: string | NodeBuffer, options?: IWriteFileOptions): void {<EOL>    options = ensureOptions(options);<EOL>    if (options.encoding) {<EOL>        data = encode(data, options.encoding.charset, { addBOM: options.encoding.addBOM });<EOL>    }<EOL>    if (!canFlush) {<EOL>        return fs.writeFileSync(path, data, { mode: options.mode, flag: options.flag });<EOL>    }<EOL>    <EOL>    const fd: number = fs.openSync(path, options.flag, options.mode);<EOL>    try {<EOL>        <EOL>        fs.writeFileSync(fd, data);<EOL>        <EOL>        try {<EOL>            fs.fdatasyncSync(fd);<EOL>        }<EOL>        catch (syncError: any) {<EOL>            console.warn('<STR_LIT>', syncError);<EOL>","gt":"canFlush = false;"}
{"input":"<s> export function sequence(sequences: any): void {<EOL>    Sequence((Array.isArray(sequences)) ?","gt":"sequences : Array.prototype.slice.call(arguments));"}
{"input":"<s> <EOL>export function dirExists(path: string): TPromise<boolean> {<EOL>    return stat(path).then((","gt":"stat: fs.Stats): boolean => stat.isDirectory(), (): boolean => false);"}
{"input":"<s> export function getWindowsShell(): string {<EOL>    return","gt":"process.env['<STR_LIT>'] || '<STR_LIT>';"}
{"input":"<s> function filterNotOk(filter: IFilter, word: string, suggestion: string): void {<EOL>    assert(!filter(","gt":"word, suggestion));"}
{"input":"<s> function assertScanError(text: string, expectedKind: SyntaxKind, scanError: ScanError): void {<EOL>    var scanner: import(\"<STR_LIT>\").JSONScanner = createScanner(text);<EOL>    scanner.","gt":"scan();"}
{"input":"<s> function assertUrl(raw: string, scheme: string, domain: string, port: string, path: string, queryString: string, fragmentId: string): void {<EOL>    <EOL>    const uri: URI = URI.parse(raw);<EOL>    assert.equal(","gt":"uri.scheme, scheme);"}
{"input":"<s> export function toResource(this: any, path: string): URI {<EOL>    return URI.file(paths.","gt":"join('<STR_LIT>', Buffer.from(this.test.fullTitle()).toString('<STR_LIT>'), path));"}
{"input":"<s> <EOL>function hide(el: any): void {<EOL>    el.","gt":"classList.add('<STR_LIT>');"}
{"input":"<s> export function startup(configuration: ISharedProcessConfiguration): void {<EOL>    handshake(","gt":"configuration);"}
{"input":"<s> export function getLastActiveWindow<W extends ISimpleWindow>(windows: W[]): W {<EOL>    const lastFocusedDate: any = Math.max.apply(Math, windows.map((window: W): number =>","gt":"window.lastFocusTime));"}
{"input":"<s> export function createEditorPagePosition(editorViewDomNode: HTMLElement): EditorPagePosition {<EOL>    let editorPos:","gt":"dom.IDomNodePagePosition = dom.getDomNodePagePosition(editorViewDomNode);"}
{"input":"<s> function _cursorStyleFromString(cursorStyle: string, defaultValue: TextEditorCursorStyle): TextEditorCursorStyle {<EOL>    if (typeof cursorStyle !== '<STR_LIT>') {<EOL>        return defaultValue;<EOL>    }<EOL>    if (cursorStyle === '<STR_LIT>') {<EOL>","gt":"return TextEditorCursorStyle.Line;"}
{"input":"<s> function _cursorStyleFromString(cursorStyle: string, defaultValue: TextEditorCursorStyle): TextEditorCursorStyle {<EOL>    if (typeof cursorStyle !== '<STR_LIT>') {<EOL>        return defaultValue;<EOL>    }<EOL>    if (cursorStyle === '<STR_LIT>') {<EOL>        return TextEditorCursorStyle.Line;<EOL>    }<EOL>","gt":"else if (cursorStyle === '<STR_LIT>') {"}
{"input":"<s> function _cursorStyleFromString(cursorStyle: string, defaultValue: TextEditorCursorStyle): TextEditorCursorStyle {<EOL>    if (typeof cursorStyle !== '<STR_LIT>') {<EOL>        return defaultValue;<EOL>    }<EOL>    if (cursorStyle === '<STR_LIT>') {<EOL>        return TextEditorCursorStyle.Line;<EOL>    }<EOL>    else if (cursorStyle === '<STR_LIT>') {<EOL>        return TextEditorCursorStyle.Block;<EOL>    }<EOL>    else if (cursorStyle === '<STR_LIT>') {<EOL>        return TextEditorCursorStyle.Underline;<EOL>    }<EOL>    else if (cursorStyle === '<STR_LIT>') {<EOL>        return TextEditorCursorStyle.LineThin;<EOL>    }<EOL>    else if (cursorStyle === '<STR_LIT>') {<EOL>        return TextEditorCursorStyle.","gt":"BlockOutline;"}
{"input":"<s> function adjustMarkerBeforeColumn(markerOffset: number, markerStickToPreviousCharacter: boolean, checkOffset: number, moveSemantics: MarkerMoveSemantics): boolean {<EOL>    if (markerOffset < checkOffset) {<EOL>        return true;<EOL>    }<EOL>","gt":"if (markerOffset > checkOffset) {"}
{"input":"<s> function adjustMarkerBeforeColumn(markerOffset: number, markerStickToPreviousCharacter: boolean, checkOffset: number, moveSemantics: MarkerMoveSemantics): boolean {<EOL>    if (markerOffset < checkOffset) {<EOL>        return true;<EOL>    }<EOL>    if (markerOffset > checkOffset) {<EOL>        return false;<EOL>    }<EOL>    if (moveSemantics === MarkerMoveSemantics.ForceMove) {<EOL>        return false;<EOL>    }<EOL>    if (moveSemantics === MarkerMoveSemantics.","gt":"ForceStay) {"}
{"input":"<s> function intervalSearch(T: IntervalTree, intervalStart: number, intervalEnd: number, filterOwnerId: number, filterOutValidation: boolean, cachedVersionId: number): IntervalNode[] {<EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    let node: IntervalNode = T.root;<EOL>    let delta: number = <NUM_LIT>;<EOL>    let","gt":"nodeMaxEnd: number = <NUM_LIT>;"}
{"input":"<s> function intervalSearch(T: IntervalTree, intervalStart: number, intervalEnd: number, filterOwnerId: number, filterOutValidation: boolean, cachedVersionId: number): IntervalNode[] {<EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    let node: IntervalNode = T.root;<EOL>    let delta: number = <NUM_LIT>;<EOL>    let nodeMaxEnd: number = <NUM_LIT>;<EOL>    let nodeStart: number = <NUM_LIT>;<EOL>    let nodeEnd: number = <NUM_LIT>;<EOL>    let result: IntervalNode[] = [];<EOL>    let resultLen: number = <NUM_LIT>;<EOL>    while (node !==","gt":"SENTINEL) {"}
{"input":"<s> function intervalSearch(T: IntervalTree, intervalStart: number, intervalEnd: number, filterOwnerId: number, filterOutValidation: boolean, cachedVersionId: number): IntervalNode[] {<EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    let node: IntervalNode = T.root;<EOL>    let delta: number = <NUM_LIT>;<EOL>    let nodeMaxEnd: number = <NUM_LIT>;<EOL>    let nodeStart: number = <NUM_LIT>;<EOL>    let nodeEnd: number = <NUM_LIT>;<EOL>    let result: IntervalNode[] = [];<EOL>    let resultLen: number = <NUM_LIT>;<EOL>    while (node !== SENTINEL) {<EOL>","gt":"if (getNodeIsVisited(node)) {"}
{"input":"<s> function intervalSearch(T: IntervalTree, intervalStart: number, intervalEnd: number, filterOwnerId: number, filterOutValidation: boolean, cachedVersionId: number): IntervalNode[] {<EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    let node: IntervalNode = T.root;<EOL>    let delta: number = <NUM_LIT>;<EOL>    let nodeMaxEnd: number = <NUM_LIT>;<EOL>    let nodeStart: number = <NUM_LIT>;<EOL>    let nodeEnd: number = <NUM_LIT>;<EOL>    let result: IntervalNode[] = [];<EOL>    let resultLen: number = <NUM_LIT>;<EOL>    while (node !== SENTINEL) {<EOL>        if (getNodeIsVisited(node)) {<EOL>            <EOL>            setNodeIsVisited(node.left, false);<EOL>            setNodeIsVisited(node.right, false);<EOL>            if (node === node.parent.right) {<EOL>                delta -= node.parent.delta;<EOL>            }<EOL>","gt":"node = node."}
{"input":"<s> function intervalSearch(T: IntervalTree, intervalStart: number, intervalEnd: number, filterOwnerId: number, filterOutValidation: boolean, cachedVersionId: number): IntervalNode[] {<EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    let node: IntervalNode = T.root;<EOL>    let delta: number = <NUM_LIT>;<EOL>    let nodeMaxEnd: number = <NUM_LIT>;<EOL>    let nodeStart: number = <NUM_LIT>;<EOL>    let nodeEnd: number = <NUM_LIT>;<EOL>    let result: IntervalNode[] = [];<EOL>    let resultLen: number = <NUM_LIT>;<EOL>    while (node !== SENTINEL) {<EOL>        if (getNodeIsVisited(node)) {<EOL>            <EOL>            setNodeIsVisited(node.left, false);<EOL>            setNodeIsVisited(node.right, false);<EOL>            if (node === node.parent.right) {<EOL>                delta -= node.parent.delta;<EOL>            }<EOL>            node = node.","gt":"parent;"}
{"input":"<s> function intervalSearch(T: IntervalTree, intervalStart: number, intervalEnd: number, filterOwnerId: number, filterOutValidation: boolean, cachedVersionId: number): IntervalNode[] {<EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    let node: IntervalNode = T.root;<EOL>    let delta: number = <NUM_LIT>;<EOL>    let nodeMaxEnd: number = <NUM_LIT>;<EOL>    let nodeStart: number = <NUM_LIT>;<EOL>    let nodeEnd: number = <NUM_LIT>;<EOL>    let result: IntervalNode[] = [];<EOL>    let resultLen: number = <NUM_LIT>;<EOL>    while (node !== SENTINEL) {<EOL>        if (getNodeIsVisited(node)) {<EOL>            <EOL>            setNodeIsVisited(node.left, false);<EOL>            setNodeIsVisited(node.right, false);<EOL>            if (node === node.parent.right) {<EOL>                delta -= node.parent.delta;<EOL>            }<EOL>            node = node.parent;<EOL>            continue;<EOL>        }<EOL>        if (!getNodeIsVisited(node.left)) {<EOL>            <EOL>            nodeMaxEnd = delta + node.maxEnd;<EOL>            if (nodeMaxEnd < intervalStart) {<EOL>                <EOL>                <EOL>                setNodeIsVisited(node, true);<EOL>                continue;<EOL>            }<EOL>            if (node.left !== SENTINEL) {<EOL>                <EOL>                node = node.left;<EOL>                continue;<EOL>            }<EOL>        }<EOL>        <EOL>        nodeStart = delta + node.start;<EOL>        if (nodeStart > intervalEnd) {<EOL>            <EOL>            <EOL>            setNodeIsVisited(node,","gt":"true);"}
{"input":"<s> function intervalSearch(T: IntervalTree, intervalStart: number, intervalEnd: number, filterOwnerId: number, filterOutValidation: boolean, cachedVersionId: number): IntervalNode[] {<EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    let node: IntervalNode = T.root;<EOL>    let delta: number = <NUM_LIT>;<EOL>    let nodeMaxEnd: number = <NUM_LIT>;<EOL>    let nodeStart: number = <NUM_LIT>;<EOL>    let nodeEnd: number = <NUM_LIT>;<EOL>    let result: IntervalNode[] = [];<EOL>    let resultLen: number = <NUM_LIT>;<EOL>    while (node !== SENTINEL) {<EOL>        if (getNodeIsVisited(node)) {<EOL>            <EOL>            setNodeIsVisited(node.left, false);<EOL>            setNodeIsVisited(node.right, false);<EOL>            if (node === node.parent.right) {<EOL>                delta -= node.parent.delta;<EOL>            }<EOL>            node = node.parent;<EOL>            continue;<EOL>        }<EOL>        if (!getNodeIsVisited(node.left)) {<EOL>            <EOL>            nodeMaxEnd = delta + node.maxEnd;<EOL>            if (nodeMaxEnd < intervalStart) {<EOL>                <EOL>                <EOL>                setNodeIsVisited(node, true);<EOL>                continue;<EOL>            }<EOL>            if (node.left !== SENTINEL) {<EOL>                <EOL>                node = node.left;<EOL>                continue;<EOL>            }<EOL>        }<EOL>        <EOL>        nodeStart = delta + node.start;<EOL>        if (nodeStart > intervalEnd) {<EOL>            <EOL>            <EOL>            setNodeIsVisited(node, true);<EOL>            continue;<EOL>        }<EOL>        nodeEnd = delta + node.end;<EOL>        if (nodeEnd >= intervalStart) {<EOL>            <EOL>            node.setCachedOffsets(nodeStart, nodeEnd, cachedVersionId);<EOL>            let include: boolean = true;<EOL>            if (filterOwnerId && node.ownerId && node.ownerId !== filterOwnerId) {<EOL>                include = false;<EOL>            }<EOL>            if (filterOutValidation && getNodeIsForValidation(node)) {<EOL>                include = false;<EOL>            }<EOL>            if (include) {<EOL>","gt":"result[resultLen++] = node;"}
{"input":"<s> function intervalSearch(T: IntervalTree, intervalStart: number, intervalEnd: number, filterOwnerId: number, filterOutValidation: boolean, cachedVersionId: number): IntervalNode[] {<EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    let node: IntervalNode = T.root;<EOL>    let delta: number = <NUM_LIT>;<EOL>    let nodeMaxEnd: number = <NUM_LIT>;<EOL>    let nodeStart: number = <NUM_LIT>;<EOL>    let nodeEnd: number = <NUM_LIT>;<EOL>    let result: IntervalNode[] = [];<EOL>    let resultLen: number = <NUM_LIT>;<EOL>    while (node !== SENTINEL) {<EOL>        if (getNodeIsVisited(node)) {<EOL>            <EOL>            setNodeIsVisited(node.left, false);<EOL>            setNodeIsVisited(node.right, false);<EOL>            if (node === node.parent.right) {<EOL>                delta -= node.parent.delta;<EOL>            }<EOL>            node = node.parent;<EOL>            continue;<EOL>        }<EOL>        if (!getNodeIsVisited(node.left)) {<EOL>            <EOL>            nodeMaxEnd = delta + node.maxEnd;<EOL>            if (nodeMaxEnd < intervalStart) {<EOL>                <EOL>                <EOL>                setNodeIsVisited(node, true);<EOL>                continue;<EOL>            }<EOL>            if (node.left !== SENTINEL) {<EOL>                <EOL>                node = node.left;<EOL>                continue;<EOL>            }<EOL>        }<EOL>        <EOL>        nodeStart = delta + node.start;<EOL>        if (nodeStart > intervalEnd) {<EOL>            <EOL>            <EOL>            setNodeIsVisited(node, true);<EOL>            continue;<EOL>        }<EOL>        nodeEnd = delta + node.end;<EOL>        if (nodeEnd >= intervalStart) {<EOL>            <EOL>            node.setCachedOffsets(nodeStart, nodeEnd, cachedVersionId);<EOL>            let include: boolean = true;<EOL>            if (filterOwnerId && node.ownerId && node.ownerId !== filterOwnerId) {<EOL>                include = false;<EOL>            }<EOL>            if (filterOutValidation && getNodeIsForValidation(node)) {<EOL>                include = false;<EOL>            }<EOL>            if (include) {<EOL>                result[resultLen++] = node;<EOL>            }<EOL>        }<EOL>        setNodeIsVisited(node,","gt":"true);"}
{"input":"<s> export function createTextBufferFactoryFromSnapshot(snapshot: ITextSnapshot): model.ITextBufferFactory {<EOL>    let builder: PieceTreeTextBufferBuilder | ChunksTextBufferBuilder | LinesTextBufferBuilder = createTextBufferBuilder();<EOL>    let","gt":"chunk: string;"}
{"input":"<s> function getDefaultMetadata(topLevelLanguageId: LanguageId): number {<EOL>    return ((topLevelLanguageId << MetadataConsts.LANGUAGEID_OFFSET)<EOL>        | (StandardTokenType.","gt":"Other << MetadataConsts.TOKEN_TYPE_OFFSET)"}
{"input":"<s> export function ensureValidWordDefinition(wordDefinition?: RegExp): RegExp {<EOL>    let result: RegExp = DEFAULT_WORD_REGEXP;<EOL>    if (wordDefinition && (wordDefinition instanceof RegExp)) {<EOL>        if (!wordDefinition.global) {<EOL>            let flags: string = '<STR_LIT>';<EOL>            if (wordDefinition.ignoreCase) {<EOL>","gt":"flags += '<STR_LIT>';"}
{"input":"<s> export function ensureValidWordDefinition(wordDefinition?: RegExp): RegExp {<EOL>    let result: RegExp = DEFAULT_WORD_REGEXP;<EOL>    if (wordDefinition && (wordDefinition instanceof RegExp)) {<EOL>        if (!wordDefinition.global) {<EOL>            let flags: string = '<STR_LIT>';<EOL>            if (wordDefinition.ignoreCase) {<EOL>                flags += '<STR_LIT>';<EOL>            }<EOL>            if (wordDefinition.multiline) {<EOL>                flags += '<STR_LIT>';<EOL>            }<EOL>            result = new RegExp(wordDefinition.source, flags);<EOL>        }<EOL>        else {<EOL>","gt":"result = wordDefinition;"}
{"input":"<s> function isInside(line: number, range: IRange): boolean {<EOL>    return line >= range.startLineNumber &&","gt":"line <= range.endLineNumber;"}
{"input":"<s> function testCopyLinesDownCommand(lines: string[], selection: Selection, expectedLines: string[], expectedSelection: Selection): void {<EOL>    testCommand(lines, null, selection, (sel: Selection): CopyLinesCommand => new","gt":"CopyLinesCommand(sel, true), expectedLines, expectedSelection);"}
{"input":"<s> function codeActionsComparator(a: CodeAction, b: CodeAction): number {<EOL>    const aHasDiags: boolean = !isFalsyOrEmpty(a.diagnostics);<EOL>    const bHasDiags: boolean = !isFalsyOrEmpty(b.diagnostics);<EOL>    if (aHasDiags) {<EOL>        if (bHasDiags) {<EOL>            return a.diagnostics[<NUM_LIT>].","gt":"message.localeCompare(b.diagnostics[<NUM_LIT>].message);"}
{"input":"<s> function snippetUpComparator(a: ISuggestionItem, b: ISuggestionItem): number {<EOL>    if (a.suggestion.type !== b.suggestion.type) {<EOL>        if (a.suggestion.type === '<STR_LIT>') {<EOL>","gt":"return -<NUM_LIT>;"}
{"input":"<s> <EOL>export function setTheme(themeName: string): void {<EOL>    StaticServices.standaloneThemeService.get().","gt":"setTheme(themeName);"}
{"input":"<s> <EOL>export function registerDocumentHighlightProvider(languageId: string, provider: modes.DocumentHighlightProvider): IDisposable {<EOL>    return modes.DocumentHighlightProviderRegistry.","gt":"register(languageId, provider);"}
{"input":"<s> <EOL>export function registerLinkProvider(languageId: string, provider: modes.LinkProvider): IDisposable {<EOL>    return modes.LinkProviderRegistry.register(languageId,","gt":"provider);"}
{"input":"<s> <EOL>export function registerSignatureHelpProvider(languageId: string, provider: modes.SignatureHelpProvider): IDisposable {<EOL>    return modes.SignatureHelpProviderRegistry.register(languageId,","gt":"provider);"}
{"input":"<s> <EOL>export function setMonarchTokensProvider(languageId: string, languageDef: IMonarchLanguage): IDisposable {<EOL>    let lexer: import(\"<STR_LIT>\").ILexer = compile(","gt":"languageId, languageDef);"}
{"input":"<s> function getBuiltinRules(builtinTheme: BuiltinTheme): IStandaloneThemeData {<EOL>    switch (builtinTheme) {<EOL>        case VS_THEME_NAME:<EOL>            return","gt":"vs;"}
{"input":"<s> function moveToCenter(cursor: Cursor, select?: boolean): void {<EOL>    move(cursor, {","gt":"to: CursorMove.RawDirection.ViewPortCenter, select: select });"}
{"input":"<s> function moveLeft(cursor: Cursor, inSelectionMode: boolean = false): void {<EOL>    if (inSelectionMode) {<EOL>        CoreNavigationCommands.CursorLeftSelect.runCoreEditorCommand(","gt":"cursor, {});"}
{"input":"<s> function getRandomInt(min: number, max: number): number {<EOL>    return Math.floor(Math.random() * (","gt":"max - min + <NUM_LIT>)) + min;"}
{"input":"<s> function printTree(T: IntervalTree): void {<EOL>    if (T.root === SENTINEL) {<EOL>        console.log(`<STR_LIT>`);<EOL>","gt":"return;"}
{"input":"<s> function modelHasDecoration(model: TextModel, startLineNumber: number, startColumn: number, endLineNumber: number, endColumn: number, className: string): void {<EOL>    modelHasDecorations(model, [{<EOL>            range: new Range(startLineNumber, startColumn, endLineNumber,","gt":"endColumn),"}
{"input":"<s> function createModel(text: string): ISimpleModel {<EOL>    return {<EOL>        getLineTokens: (lineNumber: number): any => {<EOL>            return null;<EOL>        },<EOL>        getLineContent: (lineNumber: number): string => {<EOL>","gt":"return text;"}
{"input":"<s> export function keyFromOverrideIdentifier(overrideIdentifier: string): string {<EOL>    return","gt":"overrideIdentifier}]`<STR_LIT>;"}
{"input":"<s> function getDefaultValue(type: string | string[]): any {<EOL>    const t: string = Array.isArray(type) ? (<string[]>type)[<NUM_LIT>] : <string>type;<EOL>    switch (t) {<EOL>        case '<STR_LIT>':<EOL>            return false;<EOL>        case","gt":"'<STR_LIT>':"}
{"input":"<s> function getDefaultValue(type: string | string[]): any {<EOL>    const t: string = Array.isArray(type) ? (<string[]>type)[<NUM_LIT>] : <string>type;<EOL>    switch (t) {<EOL>        case '<STR_LIT>':<EOL>            return false;<EOL>        case '<STR_LIT>':<EOL>        case '<STR_LIT>':<EOL>            return <NUM_LIT>;<EOL>        case '<STR_LIT>':<EOL>","gt":"return '<STR_LIT>';"}
{"input":"<s> function getDefaultValue(type: string | string[]): any {<EOL>    const t: string = Array.isArray(type) ? (<string[]>type)[<NUM_LIT>] : <string>type;<EOL>    switch (t) {<EOL>        case '<STR_LIT>':<EOL>            return false;<EOL>        case '<STR_LIT>':<EOL>        case '<STR_LIT>':<EOL>            return <NUM_LIT>;<EOL>        case '<STR_LIT>':<EOL>            return '<STR_LIT>';<EOL>        case '<STR_LIT>':<EOL>            return [];<EOL>        case '<STR_LIT>':<EOL>","gt":"return {};"}
{"input":"<s> function cmp(a: ContextKeyExpr, b: ContextKeyExpr): number {<EOL>    let aType: ContextKeyExprType = a.getType();<EOL>    let bType: ContextKeyExprType = b.getType();<EOL>    if (aType !== bType) {<EOL>        return aType - bType;<EOL>    }<EOL>","gt":"switch (aType) {"}
{"input":"<s> function cmp(a: ContextKeyExpr, b: ContextKeyExpr): number {<EOL>    let aType: ContextKeyExprType = a.getType();<EOL>    let bType: ContextKeyExprType = b.getType();<EOL>    if (aType !== bType) {<EOL>        return aType - bType;<EOL>    }<EOL>    switch (aType) {<EOL>        case ContextKeyExprType.Defined:<EOL>            return (<ContextKeyDefinedExpr>a).cmp(<ContextKeyDefinedExpr>b);<EOL>        case ContextKeyExprType.Not:<EOL>            return (<ContextKeyNotExpr>a).cmp(<ContextKeyNotExpr>b);<EOL>        case ContextKeyExprType.","gt":"Equals:"}
{"input":"<s> function cmp(a: ContextKeyExpr, b: ContextKeyExpr): number {<EOL>    let aType: ContextKeyExprType = a.getType();<EOL>    let bType: ContextKeyExprType = b.getType();<EOL>    if (aType !== bType) {<EOL>        return aType - bType;<EOL>    }<EOL>    switch (aType) {<EOL>        case ContextKeyExprType.Defined:<EOL>            return (<ContextKeyDefinedExpr>a).cmp(<ContextKeyDefinedExpr>b);<EOL>        case ContextKeyExprType.Not:<EOL>            return (<ContextKeyNotExpr>a).cmp(<ContextKeyNotExpr>b);<EOL>        case ContextKeyExprType.Equals:<EOL>            return (<ContextKeyEqualsExpr>a).cmp(<ContextKeyEqualsExpr>b);<EOL>        case ContextKeyExprType.NotEquals:<EOL>            return (<ContextKeyNotEqualsExpr>a).cmp(<ContextKeyNotEqualsExpr>b);<EOL>        case","gt":"ContextKeyExprType.Regex:"}
{"input":"<s> export function adoptToGalleryExtensionId(id: string): string {<EOL>    return id.replace(EXTENSION_IDENTIFIER_REGEX, (match: string, publisher: string,","gt":"name: string): string => getGalleryExtensionId(publisher, name));"}
{"input":"<s> export function getMaliciousExtensionsSet(report: IReportedExtension[]): Set<string> {<EOL>    const result: Set<string> = new Set<string>();<EOL>    for (const extension: IReportedExtension of report) {<EOL>        if (","gt":"extension.malicious) {"}
{"input":"<s> export function isValidVersionStr(version: string): boolean {<EOL>","gt":"version = version.trim();"}
{"input":"<s> export function attachBadgeStyler(widget: IThemable, themeService: IThemeService, style?: IBadgeStyleOverrides): IDisposable {<EOL>    return attachStyler(themeService, {<EOL>        badgeBackground: (","gt":"style && style.badgeBackground) || badgeBackground,"}
{"input":"<s> export function registerThemingParticipant(participant: IThemingParticipant): IDisposable {<EOL>    return themingRegistry.onThemeChange(","gt":"participant);"}
{"input":"<s> export function isRawFileWorkspaceFolder(thing: any): thing is IRawFileWorkspaceFolder {<EOL>    return thing<EOL>        &&","gt":"typeof thing === '<STR_LIT>'"}
{"input":"<s> export function isSingleFolderWorkspaceIdentifier(obj: any): obj is ISingleFolderWorkspaceIdentifier {<EOL>    return typeof obj ===","gt":"'<STR_LIT>';"}
{"input":"<s> function defineAPI(factory: IExtensionApiFactory, extensionPaths: TernarySearchTree<IExtensionDescription>): void {<EOL>    <EOL>    const extApiImpl: Map<string, typeof vscode> = new Map<string, typeof vscode>();<EOL>    let defaultApiImpl: typeof vscode;<EOL>    const node_module: any = <any>require.__$__nodeRequire('<STR_LIT>');<EOL>","gt":"const original: any = node_module._load;"}
{"input":"<s> function defineAPI(factory: IExtensionApiFactory, extensionPaths: TernarySearchTree<IExtensionDescription>): void {<EOL>    <EOL>    const extApiImpl: Map<string, typeof vscode> = new Map<string, typeof vscode>();<EOL>    let defaultApiImpl: typeof vscode;<EOL>    const node_module: any = <any>require.__$__nodeRequire('<STR_LIT>');<EOL>    const original: any = node_module._load;<EOL>    node_module._load = function load(request, parent, isMain) {<EOL>        if (request !== '<STR_LIT>') {<EOL>            return","gt":"original.apply(this, arguments);"}
{"input":"<s> function defineAPI(factory: IExtensionApiFactory, extensionPaths: TernarySearchTree<IExtensionDescription>): void {<EOL>    <EOL>    const extApiImpl: Map<string, typeof vscode> = new Map<string, typeof vscode>();<EOL>    let defaultApiImpl: typeof vscode;<EOL>    const node_module: any = <any>require.__$__nodeRequire('<STR_LIT>');<EOL>    const original: any = node_module._load;<EOL>    node_module._load = function load(request, parent, isMain) {<EOL>        if (request !== '<STR_LIT>') {<EOL>            return original.apply(this, arguments);<EOL>        }<EOL>        <EOL>        const ext: IExtensionDescription = extensionPaths.findSubstr(parent.","gt":"filename);"}
{"input":"<s> function defineAPI(factory: IExtensionApiFactory, extensionPaths: TernarySearchTree<IExtensionDescription>): void {<EOL>    <EOL>    const extApiImpl: Map<string, typeof vscode> = new Map<string, typeof vscode>();<EOL>    let defaultApiImpl: typeof vscode;<EOL>    const node_module: any = <any>require.__$__nodeRequire('<STR_LIT>');<EOL>    const original: any = node_module._load;<EOL>    node_module._load = function load(request, parent, isMain) {<EOL>        if (request !== '<STR_LIT>') {<EOL>            return original.apply(this, arguments);<EOL>        }<EOL>        <EOL>        const ext: IExtensionDescription = extensionPaths.findSubstr(parent.filename);<EOL>        if (ext) {<EOL>            let apiImpl: typeof vscode = extApiImpl.get(ext.id);<EOL>","gt":"if (!apiImpl) {"}
{"input":"<s> function defineAPI(factory: IExtensionApiFactory, extensionPaths: TernarySearchTree<IExtensionDescription>): void {<EOL>    <EOL>    const extApiImpl: Map<string, typeof vscode> = new Map<string, typeof vscode>();<EOL>    let defaultApiImpl: typeof vscode;<EOL>    const node_module: any = <any>require.__$__nodeRequire('<STR_LIT>');<EOL>    const original: any = node_module._load;<EOL>    node_module._load = function load(request, parent, isMain) {<EOL>        if (request !== '<STR_LIT>') {<EOL>            return original.apply(this, arguments);<EOL>        }<EOL>        <EOL>        const ext: IExtensionDescription = extensionPaths.findSubstr(parent.filename);<EOL>        if (ext) {<EOL>            let apiImpl: typeof vscode = extApiImpl.get(ext.id);<EOL>            if (!apiImpl) {<EOL>                apiImpl = factory(ext);<EOL>                extApiImpl.set(ext.id, apiImpl);<EOL>            }<EOL>            return","gt":"apiImpl;"}
{"input":"<s> export function initializeExtensionApi(extensionService: ExtHostExtensionService, apiFactory: IExtensionApiFactory): TPromise<void> {<EOL>    return extensionService.getExtensionPathIndex().then((trie: TernarySearchTree<IExtensionDescription>): void => defineAPI(apiFactory,","gt":"trie));"}
{"input":"<s> function getIconPath(decorations: vscode.SourceControlResourceThemableDecorations): string {<EOL>    if (!decorations) {<EOL>        return undefined;<EOL>    }<EOL>","gt":"else if (typeof decorations.iconPath === '<STR_LIT>') {"}
{"input":"<s> function getIconPath(decorations: vscode.SourceControlResourceThemableDecorations): string {<EOL>    if (!decorations) {<EOL>        return undefined;<EOL>    }<EOL>    else if (typeof decorations.iconPath === '<STR_LIT>') {<EOL>        return URI.file(decorations.iconPath).toString();<EOL>    }<EOL>    else if (decorations.iconPath) {<EOL>        return","gt":"decorations.iconPath}`<STR_LIT>;"}
{"input":"<s> export function toHover(info: modes.Hover): types.Hover {<EOL>    return new types.","gt":"Hover(info.contents.map(MarkdownString.to), toRange(info.range));"}
{"input":"<s> <EOL>function patchProcess(allowExit: boolean): void {<EOL>    process.exit = function (code) {<EOL>        if (allowExit) {<EOL>            exit(code);<EOL>        }<EOL>        else {<EOL>            const err: Error = new Error('<STR_LIT>');<EOL>            console.warn(err.stack);<EOL>        }<EOL>    };<EOL>    process.","gt":"crash = function () {"}
{"input":"<s> export function renderVariable(tree: ITree, variable: Variable, data: IVariableTemplateData, showChanged: boolean): void {<EOL>    if (variable.available) {<EOL>        data.name.textContent = replaceWhitespace(variable.name);<EOL>        data.name.title = variable.type ? variable.type : variable.name;<EOL>        dom.toggleClass(data.name, '<STR_LIT>', !!variable.presentationHint && variable.presentationHint.kind === '<STR_LIT>');<EOL>    }<EOL>","gt":"if (variable.value) {"}
{"input":"<s> export function renderVariable(tree: ITree, variable: Variable, data: IVariableTemplateData, showChanged: boolean): void {<EOL>    if (variable.available) {<EOL>        data.name.textContent = replaceWhitespace(variable.name);<EOL>        data.name.title = variable.type ? variable.type : variable.name;<EOL>        dom.toggleClass(data.name, '<STR_LIT>', !!variable.presentationHint && variable.presentationHint.kind === '<STR_LIT>');<EOL>    }<EOL>    if (variable.value) {<EOL>        data.name.textContent += variable.name ? '<STR_LIT>' : '<STR_LIT>';<EOL>        renderExpressionValue(variable, data.value, {<EOL>            showChanged,<EOL>            maxValueLength: MAX_VALUE_RENDER_LENGTH_IN_VIEWLET,<EOL>            preserveWhitespace:","gt":"false,"}
{"input":"<s> function trimLongName(name: string): string {<EOL>    if (name && name.length > <NUM_LIT>) {<EOL>        return","gt":"<NUM_LIT>, <NUM_LIT>)}...`<STR_LIT>;"}
{"input":"<s> function toResource(self: any, path: any): URI {<EOL>    return URI.file(join(","gt":"'<STR_LIT>', Buffer.from(self.test.fullTitle()).toString('<STR_LIT>'), path));"}
{"input":"<s> export function getSettingsTargetName(target: ConfigurationTarget, resource: URI, workspaceContextService: IWorkspaceContextService): string {<EOL>    switch (target) {<EOL>        case ConfigurationTarget.USER:<EOL>            return localize('<STR_LIT>', \"<STR_LIT>\");<EOL>        case ConfigurationTarget.","gt":"WORKSPACE:"}
{"input":"<s> export function getSettingsTargetName(target: ConfigurationTarget, resource: URI, workspaceContextService: IWorkspaceContextService): string {<EOL>    switch (target) {<EOL>        case ConfigurationTarget.USER:<EOL>            return localize('<STR_LIT>', \"<STR_LIT>\");<EOL>        case ConfigurationTarget.WORKSPACE:<EOL>            return localize('<STR_LIT>', \"<STR_LIT>\");<EOL>        case ConfigurationTarget.WORKSPACE_FOLDER:<EOL>            const folder: import(\"<STR_LIT>\").IWorkspaceFolder = workspaceContextService.getWorkspaceFolder(resource);<EOL>            return folder ?","gt":"folder.name : '<STR_LIT>';"}
{"input":"<s> export function appendKeyBindingLabel(label: string, keyBinding: number | ResolvedKeybinding, keyBindingService2: IKeybindingService): string {<EOL>    if (typeof keyBinding === '<STR_LIT>') {<EOL>        const resolvedKeybindings: ResolvedKeybinding[] = keyBindingService2.resolveKeybinding(createKeybinding(keyBinding, OS));<EOL>        return doAppendKeyBindingLabel(label, resolvedKeybindings.length > <NUM_LIT> ? resolvedKeybindings[<NUM_LIT>] :","gt":"null);"}
{"input":"<s> function patternListToIExpression(patterns: string[]): glob.IExpression {<EOL>    return patterns.","gt":"length ?"}
{"input":"<s> async function createLanguageSnippetFile(pick: ISnippetPick): Promise<void> {<EOL>    if (await exists(pick.filepath)) {<EOL>        return;<EOL>    }<EOL>    const","gt":"contents: string = ["}
{"input":"<s> async function createLanguageSnippetFile(pick: ISnippetPick): Promise<void> {<EOL>    if (await exists(pick.filepath)) {<EOL>        return;<EOL>    }<EOL>    const contents: string = [<EOL>        '<STR_LIT>',<EOL>        '<STR_LIT>' + pick.label + '<STR_LIT>',<EOL>","gt":"'<STR_LIT>',"}
{"input":"<s> async function createLanguageSnippetFile(pick: ISnippetPick): Promise<void> {<EOL>    if (await exists(pick.filepath)) {<EOL>        return;<EOL>    }<EOL>    const contents: string = [<EOL>        '<STR_LIT>',<EOL>        '<STR_LIT>' + pick.label + '<STR_LIT>',<EOL>        '<STR_LIT>',<EOL>        '<STR_LIT>',<EOL>        '<STR_LIT>',<EOL>        '<STR_LIT>',<EOL>        '<STR_LIT>',<EOL>","gt":"'<STR_LIT>',"}
{"input":"<s> function assertPresentation(actual: Tasks.PresentationOptions, expected: Tasks.PresentationOptions): void {<EOL>    assert.strictEqual(typeof actual, typeof expected);<EOL>","gt":"if (actual && expected) {"}
{"input":"<s> function sendProcessTitle(): void {<EOL>    process.send({<EOL>","gt":"type: '<STR_LIT>',"}
{"input":"<s> export function getConfirmMessage(start: string, resourcesToConfirm: URI[]): string {<EOL>    const message: string[] = [start];<EOL>    message.push('<STR_LIT>');<EOL>    message.push(...resourcesToConfirm.slice(<NUM_LIT>, MAX_CONFIRM_FILES).map((r: URI): string => basename(r.fsPath)));<EOL>","gt":"if (resourcesToConfirm.length > MAX_CONFIRM_FILES) {"}
{"input":"<s> function toResource(path: string): URI {<EOL>    return URI.from({","gt":"scheme: '<STR_LIT>', path });"}
{"input":"<s> function getSiblings(file: string): TPromise<string[]> {<EOL>    return new TPromise<string[]>((resolve: (value: string[] | PromiseLike<string[]>) => void, reject: (reason: any) => void): void => {<EOL>        extfs.readdir(path.dirname(file), (error: Error, files: string[]): void => {<EOL>","gt":"if (error) {"}
{"input":"<s> export function setup(): void {<EOL>    describe('<STR_LIT>', (): void => {<EOL>        before(function () {<EOL>            this.app.suiteName = '<STR_LIT>';<EOL>        });<EOL>","gt":"it('<STR_LIT>', async function () {"}
{"input":"<s> export function setup(): void {<EOL>    describe('<STR_LIT>', (): void => {<EOL>        before(function () {<EOL>            this.app.suiteName = '<STR_LIT>';<EOL>        });<EOL>        it('<STR_LIT>', async function () {<EOL>            const app: SpectronApplication = this.app as SpectronApplication;<EOL>            await app.workbench.search.openSearchViewlet();<EOL>            await","gt":"app.workbench.search.searchFor('<STR_LIT>');"}
{"input":"<s> export function setup(): void {<EOL>    describe('<STR_LIT>', (): void => {<EOL>        before(function () {<EOL>            this.app.suiteName = '<STR_LIT>';<EOL>        });<EOL>        it('<STR_LIT>', async function () {<EOL>            const app: SpectronApplication = this.app as SpectronApplication;<EOL>            await app.workbench.search.openSearchViewlet();<EOL>            await app.workbench.search.searchFor('<STR_LIT>');<EOL>            await app.workbench.search.waitForResultText('<STR_LIT>');<EOL>        });<EOL>        it('<STR_LIT>', async function () {<EOL>            const app: SpectronApplication = this.app as SpectronApplication;<EOL>            await app.workbench.","gt":"search.searchFor('<STR_LIT>');"}
{"input":"<s> export function setup(): void {<EOL>    describe('<STR_LIT>', (): void => {<EOL>        before(function () {<EOL>            this.app.suiteName = '<STR_LIT>';<EOL>        });<EOL>        it('<STR_LIT>', async function () {<EOL>            const app: SpectronApplication = this.app as SpectronApplication;<EOL>            await app.workbench.search.openSearchViewlet();<EOL>            await app.workbench.search.searchFor('<STR_LIT>');<EOL>            await app.workbench.search.waitForResultText('<STR_LIT>');<EOL>        });<EOL>        it('<STR_LIT>', async function () {<EOL>            const app: SpectronApplication = this.app as SpectronApplication;<EOL>            await app.workbench.search.searchFor('<STR_LIT>');<EOL>            await app.workbench.search.showQueryDetails();<EOL>            await app.workbench.search.setFilesToIncludeText('<STR_LIT>');<EOL>            await app.workbench.search.submitSearch();<EOL>            await app.workbench.search.","gt":"waitForResultText('<STR_LIT>');"}
{"input":"<s> export function setup(): void {<EOL>    describe('<STR_LIT>', (): void => {<EOL>        before(function () {<EOL>            this.app.suiteName = '<STR_LIT>';<EOL>        });<EOL>        it('<STR_LIT>', async function () {<EOL>            const app: SpectronApplication = this.app as SpectronApplication;<EOL>            await app.workbench.search.openSearchViewlet();<EOL>            await app.workbench.search.searchFor('<STR_LIT>');<EOL>            await app.workbench.search.waitForResultText('<STR_LIT>');<EOL>        });<EOL>        it('<STR_LIT>', async function () {<EOL>            const app: SpectronApplication = this.app as SpectronApplication;<EOL>            await app.workbench.search.searchFor('<STR_LIT>');<EOL>            await app.workbench.search.showQueryDetails();<EOL>            await app.workbench.search.setFilesToIncludeText('<STR_LIT>');<EOL>            await app.workbench.search.submitSearch();<EOL>            await app.workbench.search.waitForResultText('<STR_LIT>');<EOL>            await app.workbench.search.setFilesToIncludeText('<STR_LIT>');<EOL>            await app.workbench.search.hideQueryDetails();<EOL>        });<EOL>        it('<STR_LIT>', async function () {<EOL>            const app: SpectronApplication = this.","gt":"app as SpectronApplication;"}
{"input":"<s> export function setup(): void {<EOL>    describe('<STR_LIT>', (): void => {<EOL>        before(function () {<EOL>            this.app.suiteName = '<STR_LIT>';<EOL>        });<EOL>        it('<STR_LIT>', async function () {<EOL>            const app: SpectronApplication = this.app as SpectronApplication;<EOL>            await app.workbench.search.openSearchViewlet();<EOL>            await app.workbench.search.searchFor('<STR_LIT>');<EOL>            await app.workbench.search.waitForResultText('<STR_LIT>');<EOL>        });<EOL>        it('<STR_LIT>', async function () {<EOL>            const app: SpectronApplication = this.app as SpectronApplication;<EOL>            await app.workbench.search.searchFor('<STR_LIT>');<EOL>            await app.workbench.search.showQueryDetails();<EOL>            await app.workbench.search.setFilesToIncludeText('<STR_LIT>');<EOL>            await app.workbench.search.submitSearch();<EOL>            await app.workbench.search.waitForResultText('<STR_LIT>');<EOL>            await app.workbench.search.setFilesToIncludeText('<STR_LIT>');<EOL>            await app.workbench.search.hideQueryDetails();<EOL>        });<EOL>        it('<STR_LIT>', async function () {<EOL>            const app: SpectronApplication = this.app as SpectronApplication;<EOL>            await app.workbench.search.searchFor('<STR_LIT>');<EOL>            await app.workbench.search.removeFileMatch(<NUM_LIT>);<EOL>            await app.workbench.search.waitForResultText('<STR_LIT>');<EOL>        });<EOL>        it('<STR_LIT>', async function () {<EOL>            const app: SpectronApplication = this.app as SpectronApplication;<EOL>            await app.workbench.search.searchFor('<STR_LIT>');<EOL>            await app.workbench.search.expandReplace();<EOL>","gt":"await app.workbench.search.setReplaceText('<STR_LIT>');"}
{"input":"<s> export function setup(): void {<EOL>    describe('<STR_LIT>', (): void => {<EOL>        before(function () {<EOL>            this.app.suiteName = '<STR_LIT>';<EOL>        });<EOL>        it('<STR_LIT>', async function () {<EOL>            const app: SpectronApplication = this.app as SpectronApplication;<EOL>            await app.workbench.search.openSearchViewlet();<EOL>            await app.workbench.search.searchFor('<STR_LIT>');<EOL>            await app.workbench.search.waitForResultText('<STR_LIT>');<EOL>        });<EOL>        it('<STR_LIT>', async function () {<EOL>            const app: SpectronApplication = this.app as SpectronApplication;<EOL>            await app.workbench.search.searchFor('<STR_LIT>');<EOL>            await app.workbench.search.showQueryDetails();<EOL>            await app.workbench.search.setFilesToIncludeText('<STR_LIT>');<EOL>            await app.workbench.search.submitSearch();<EOL>            await app.workbench.search.waitForResultText('<STR_LIT>');<EOL>            await app.workbench.search.setFilesToIncludeText('<STR_LIT>');<EOL>            await app.workbench.search.hideQueryDetails();<EOL>        });<EOL>        it('<STR_LIT>', async function () {<EOL>            const app: SpectronApplication = this.app as SpectronApplication;<EOL>            await app.workbench.search.searchFor('<STR_LIT>');<EOL>            await app.workbench.search.removeFileMatch(<NUM_LIT>);<EOL>            await app.workbench.search.waitForResultText('<STR_LIT>');<EOL>        });<EOL>        it('<STR_LIT>', async function () {<EOL>            const app: SpectronApplication = this.app as SpectronApplication;<EOL>            await app.workbench.search.searchFor('<STR_LIT>');<EOL>            await app.workbench.search.expandReplace();<EOL>            await app.workbench.search.setReplaceText('<STR_LIT>');<EOL>            await app.workbench.search.replaceFileMatch(<NUM_LIT>);<EOL>            await app.workbench.saveOpenedFile();<EOL>","gt":"await app.workbench.search.waitForResultText('<STR_LIT>');"}
{"input":"<s> function isExcludedFromLinterOptions(config: tslint.Configuration.IConfigurationFile | undefined, fileName: string): boolean {<EOL>    if (config === undefined || config.linterOptions === undefined || config.linterOptions.exclude === undefined) {<EOL>        return","gt":"false;"}
{"input":"<s> <EOL>export function areSettingsValid(widgetSettings: AnalyticsWidgetSettings): boolean {<EOL>    return (widgetSettings.projectId != null &&<EOL>        widgetSettings.teamId != null &&<EOL>        widgetSettings.workItemType != null &&<EOL>        widgetSettings.fields != null &&<EOL>","gt":"widgetSettings.fields.every((o: FieldFilterRowSettings): boolean => o.fieldQueryName != null &&"}
{"input":"<s> <EOL>export function areSettingsValid(widgetSettings: AnalyticsWidgetSettings): boolean {<EOL>    return (widgetSettings.projectId != null &&<EOL>        widgetSettings.teamId != null &&<EOL>        widgetSettings.workItemType != null &&<EOL>        widgetSettings.fields != null &&<EOL>        widgetSettings.fields.every((o: FieldFilterRowSettings): boolean => o.fieldQueryName != null &&<EOL>            o.fieldReferenceName != null &&<EOL>            o.fieldType != null &&<EOL>            o.operator != null &&<EOL>            o.","gt":"value != null &&"}
{"input":"<s> <EOL>export function areSettingsValid(widgetSettings: AnalyticsWidgetSettings): boolean {<EOL>    return (widgetSettings.projectId != null &&<EOL>        widgetSettings.teamId != null &&<EOL>        widgetSettings.workItemType != null &&<EOL>        widgetSettings.fields != null &&<EOL>        widgetSettings.fields.every((o: FieldFilterRowSettings): boolean => o.fieldQueryName != null &&<EOL>            o.fieldReferenceName != null &&<EOL>            o.fieldType != null &&<EOL>            o.operator != null &&<EOL>            o.value != null &&<EOL>            (o.value != \"<STR_LIT>\" || o.fieldType == \"<STR_LIT>\")) && <EOL>        (widgetSettings.aggregation.aggregationMode != null &&<EOL>            (widgetSettings.","gt":"aggregation.aggregationMode == AggregationMode.count ||"}
{"input":"<s> function pathExistsAsFile(path: string): any {<EOL>    try {<EOL>        return tl.","gt":"stats(path).isFile();"}
{"input":"<s> function publishTestResults(publishJUnitResults: any, testResultsFiles: string): number {<EOL>    if (publishJUnitResults == '<STR_LIT>') {<EOL>        <EOL>        if (testResultsFiles.indexOf('<STR_LIT>') >= <NUM_LIT> || testResultsFiles.indexOf('<STR_LIT>') >= <NUM_LIT>) {<EOL>            tl.debug('<STR_LIT>');<EOL>            var buildFolder: string = tl.getVariable('<STR_LIT>');<EOL>            var allFiles:","gt":"string[] = tl.find(buildFolder);"}
{"input":"<s> function publishTestResults(publishJUnitResults: any, testResultsFiles: string): number {<EOL>    if (publishJUnitResults == '<STR_LIT>') {<EOL>        <EOL>        if (testResultsFiles.indexOf('<STR_LIT>') >= <NUM_LIT> || testResultsFiles.indexOf('<STR_LIT>') >= <NUM_LIT>) {<EOL>            tl.debug('<STR_LIT>');<EOL>            var buildFolder: string = tl.getVariable('<STR_LIT>');<EOL>            var allFiles: string[] = tl.find(buildFolder);<EOL>            var matchingTestResultsFiles: string[] = tl.match(allFiles, testResultsFiles, { matchBase: true });<EOL>        }<EOL>        else {<EOL>            tl.debug('<STR_LIT>');<EOL>            var","gt":"matchingTestResultsFiles: string[] = [testResultsFiles];"}
{"input":"<s> function publishTestResults(publishJUnitResults: any, testResultsFiles: string): number {<EOL>    if (publishJUnitResults == '<STR_LIT>') {<EOL>        <EOL>        if (testResultsFiles.indexOf('<STR_LIT>') >= <NUM_LIT> || testResultsFiles.indexOf('<STR_LIT>') >= <NUM_LIT>) {<EOL>            tl.debug('<STR_LIT>');<EOL>            var buildFolder: string = tl.getVariable('<STR_LIT>');<EOL>            var allFiles: string[] = tl.find(buildFolder);<EOL>            var matchingTestResultsFiles: string[] = tl.match(allFiles, testResultsFiles, { matchBase: true });<EOL>        }<EOL>        else {<EOL>            tl.debug('<STR_LIT>');<EOL>            var matchingTestResultsFiles: string[] = [testResultsFiles];<EOL>        }<EOL>        if (!matchingTestResultsFiles || matchingTestResultsFiles.length == <NUM_LIT>) {<EOL>            tl.warning('<STR_LIT>' + testResultsFiles + '<STR_LIT>');<EOL>            return","gt":"<NUM_LIT>;"}
{"input":"<s> function getSonarQubeGradlePluginVersion(): string {<EOL>    let pluginVersion: string = '<STR_LIT>';<EOL>","gt":"let userSpecifiedVersion: string = tl.getInput('<STR_LIT>');"}
{"input":"<s> export function getSystemAccessToken(): string {<EOL>    let auth: tl.EndpointAuthorization = tl.getEndpointAuthorization('<STR_LIT>', false);<EOL>    if (auth.scheme === '<STR_LIT>') {<EOL>","gt":"tl.debug(tl.loc('<STR_LIT>'));"}
{"input":"<s> export function getTempPath(): string {<EOL>    let tempNpmrcDir: any = tl.getVariable('<STR_LIT>')<EOL>        || tl.getVariable('<STR_LIT>')<EOL>        || process.","gt":"cwd();"}
{"input":"<s> function pushTags(connection: DockerComposeConnection, imageName: string): any {<EOL>    var baseImageName: any = imageUtils.imageNameWithoutTag(imageName);<EOL>    var builtImageName: string = imageName + (baseImageName === imageName ? \"<STR_LIT>\" : \"<STR_LIT>\");<EOL>    return dockerPush(connection, builtImageName)<EOL>        .then(function pushAdditionalTags() {<EOL>        var","gt":"promise: any;"}
{"input":"<s> function pushTags(connection: DockerComposeConnection, imageName: string): any {<EOL>    var baseImageName: any = imageUtils.imageNameWithoutTag(imageName);<EOL>    var builtImageName: string = imageName + (baseImageName === imageName ? \"<STR_LIT>\" : \"<STR_LIT>\");<EOL>    return dockerPush(connection, builtImageName)<EOL>        .then(function pushAdditionalTags() {<EOL>        var promise: any;<EOL>        tl.getDelimitedInput(\"<STR_LIT>\", \"<STR_LIT>\").forEach((tag: any): void => {<EOL>            promise = pushTag(promise, connection, baseImageName + \"<STR_LIT>\" + tag);<EOL>        });<EOL>        return promise;<EOL>    })<EOL>        .then(","gt":"function pushSourceTags() {"}
{"input":"<s> function pushTags(connection: DockerComposeConnection, imageName: string): any {<EOL>    var baseImageName: any = imageUtils.imageNameWithoutTag(imageName);<EOL>    var builtImageName: string = imageName + (baseImageName === imageName ? \"<STR_LIT>\" : \"<STR_LIT>\");<EOL>    return dockerPush(connection, builtImageName)<EOL>        .then(function pushAdditionalTags() {<EOL>        var promise: any;<EOL>        tl.getDelimitedInput(\"<STR_LIT>\", \"<STR_LIT>\").forEach((tag: any): void => {<EOL>            promise = pushTag(promise, connection, baseImageName + \"<STR_LIT>\" + tag);<EOL>        });<EOL>        return promise;<EOL>    })<EOL>        .then(function pushSourceTags() {<EOL>        var promise: any;<EOL>        var includeSourceTags: any = tl.getBoolInput(\"<STR_LIT>\");<EOL>","gt":"if (includeSourceTags) {"}
{"input":"<s> function pushTags(connection: DockerComposeConnection, imageName: string): any {<EOL>    var baseImageName: any = imageUtils.imageNameWithoutTag(imageName);<EOL>    var builtImageName: string = imageName + (baseImageName === imageName ? \"<STR_LIT>\" : \"<STR_LIT>\");<EOL>    return dockerPush(connection, builtImageName)<EOL>        .then(function pushAdditionalTags() {<EOL>        var promise: any;<EOL>        tl.getDelimitedInput(\"<STR_LIT>\", \"<STR_LIT>\").forEach((tag: any): void => {<EOL>            promise = pushTag(promise, connection, baseImageName + \"<STR_LIT>\" + tag);<EOL>        });<EOL>        return promise;<EOL>    })<EOL>        .then(function pushSourceTags() {<EOL>        var promise: any;<EOL>        var includeSourceTags: any = tl.getBoolInput(\"<STR_LIT>\");<EOL>        if (includeSourceTags) {<EOL>            sourceUtils.getSourceTags().forEach((tag: any): void => {<EOL>                promise = pushTag(promise, connection, baseImageName + \"<STR_LIT>\" + tag);<EOL>            });<EOL>        }<EOL>        return","gt":"promise;"}
{"input":"<s> function getNameSpace(): string[] {<EOL>    var args: string[] = [];<EOL>    var namespace: string = tl.getInput(\"<STR_LIT>\", false);<EOL>    if (","gt":"namespace) {"}
{"input":"<s> export async function run(packerHost: packerHost): Promise<void> {<EOL>    var command: tr.ToolRunner = packerHost.createPackerTool();<EOL>    command.arg(\"<STR_LIT>\");<EOL>    <EOL>    var variableProviders: import(\"<STR_LIT>\").ITemplateVariablesProvider[] = packerHost.getTemplateVariablesProviders();<EOL>    for (var provider: import(\"<STR_LIT>\").ITemplateVariablesProvider","gt":"of variableProviders) {"}
{"input":"<s> export async function run(packerHost: packerHost): Promise<void> {<EOL>    var command: tr.ToolRunner = packerHost.createPackerTool();<EOL>    command.arg(\"<STR_LIT>\");<EOL>    <EOL>    var variableProviders: import(\"<STR_LIT>\").ITemplateVariablesProvider[] = packerHost.getTemplateVariablesProviders();<EOL>    for (var provider: import(\"<STR_LIT>\").ITemplateVariablesProvider of variableProviders) {<EOL>        var variables: Map<string, string> = await provider.getTemplateVariables(packerHost);<EOL>        variables.forEach((value: string, key: string): void => {<EOL>            command.arg([\"<STR_LIT>\", util.format(\"<STR_LIT>\", key, value)]);<EOL>        });<EOL>    }<EOL>    command.arg(packerHost.getTemplateFileProvider().getTemplateFileLocation(packerHost));<EOL>    console.log(tl.loc(\"<STR_LIT>\"));<EOL>","gt":"var result: any = command.execSync();"}
{"input":"<s> function isDtaEngineRequired(): boolean {<EOL>    const batchType: any = tl.getInput('<STR_LIT>');<EOL>    if (batchType && batchType === '<STR_LIT>') {<EOL>        const batchSize: any = tl.getInput('<STR_LIT>');<EOL>        if (batchSize && batchSize === '<STR_LIT>') {<EOL>            return true;<EOL>        }<EOL>    }<EOL>    else if (batchType && batchType === '<STR_LIT>') {<EOL>","gt":"return true;"}
{"input":"<s> function isDtaEngineRequired(): boolean {<EOL>    const batchType: any = tl.getInput('<STR_LIT>');<EOL>    if (batchType && batchType === '<STR_LIT>') {<EOL>        const batchSize: any = tl.getInput('<STR_LIT>');<EOL>        if (batchSize && batchSize === '<STR_LIT>') {<EOL>            return true;<EOL>        }<EOL>    }<EOL>    else if (batchType && batchType === '<STR_LIT>') {<EOL>        return true;<EOL>    }<EOL>    else if (batchType && batchType === '<STR_LIT>') {<EOL>","gt":"return true;"}
{"input":"<s> function isDtaEngineRequired(): boolean {<EOL>    const batchType: any = tl.getInput('<STR_LIT>');<EOL>    if (batchType && batchType === '<STR_LIT>') {<EOL>        const batchSize: any = tl.getInput('<STR_LIT>');<EOL>        if (batchSize && batchSize === '<STR_LIT>') {<EOL>            return true;<EOL>        }<EOL>    }<EOL>    else if (batchType && batchType === '<STR_LIT>') {<EOL>        return true;<EOL>    }<EOL>    else if (batchType && batchType === '<STR_LIT>') {<EOL>        return true;<EOL>    }<EOL>    const testType: any = tl.getInput('<STR_LIT>');<EOL>    tl.","gt":"debug('<STR_LIT>' + testType);"}
{"input":"<s> function isDtaEngineRequired(): boolean {<EOL>    const batchType: any = tl.getInput('<STR_LIT>');<EOL>    if (batchType && batchType === '<STR_LIT>') {<EOL>        const batchSize: any = tl.getInput('<STR_LIT>');<EOL>        if (batchSize && batchSize === '<STR_LIT>') {<EOL>            return true;<EOL>        }<EOL>    }<EOL>    else if (batchType && batchType === '<STR_LIT>') {<EOL>        return true;<EOL>    }<EOL>    else if (batchType && batchType === '<STR_LIT>') {<EOL>        return true;<EOL>    }<EOL>    const testType: any = tl.getInput('<STR_LIT>');<EOL>    tl.debug('<STR_LIT>' + testType);<EOL>    if (testType.toLowerCase() === '<STR_LIT>' || testType.toLowerCase() === '<STR_LIT>') {<EOL>        return true;<EOL>    }<EOL>    const parallelExecution: any = tl.getVariable('<STR_LIT>');<EOL>    tl.debug('<STR_LIT>' + parallelExecution);<EOL>    if (parallelExecution && parallelExecution.toLowerCase() === '<STR_LIT>') {<EOL>        const","gt":"dontDistribute: any = tl.getBoolInput('<STR_LIT>');"}
{"input":"<s> function getTestSelectorBasedInputs(testConfiguration: models.TestConfigurations): void {<EOL>    const testSelection: string = testConfiguration.testSelection.toLowerCase();<EOL>    switch (testSelection) {<EOL>","gt":"case '<STR_LIT>':"}
{"input":"<s> function getTestSelectorBasedInputs(testConfiguration: models.TestConfigurations): void {<EOL>    const testSelection: string = testConfiguration.testSelection.toLowerCase();<EOL>    switch (testSelection) {<EOL>        case '<STR_LIT>':<EOL>            console.log(tl.loc('<STR_LIT>', tl.loc('<STR_LIT>')));<EOL>            testConfiguration.testplan = parseInt(tl.getInput('<STR_LIT>'));<EOL>            console.log(tl.loc('<STR_LIT>', testConfiguration.testplan));<EOL>","gt":"testConfiguration.testPlanConfigId = parseInt(tl.getInput('<STR_LIT>'));"}
{"input":"<s> function getTestSelectorBasedInputs(testConfiguration: models.TestConfigurations): void {<EOL>    const testSelection: string = testConfiguration.testSelection.toLowerCase();<EOL>    switch (testSelection) {<EOL>        case '<STR_LIT>':<EOL>            console.log(tl.loc('<STR_LIT>', tl.loc('<STR_LIT>')));<EOL>            testConfiguration.testplan = parseInt(tl.getInput('<STR_LIT>'));<EOL>            console.log(tl.loc('<STR_LIT>', testConfiguration.testplan));<EOL>            testConfiguration.testPlanConfigId = parseInt(tl.getInput('<STR_LIT>'));<EOL>            console.log(tl.loc('<STR_LIT>', testConfiguration.testPlanConfigId));<EOL>            const testSuiteStrings: any = tl.getDelimitedInput('<STR_LIT>', '<STR_LIT>', true);<EOL>            testConfiguration.testSuites = new Array<number>();<EOL>","gt":"testSuiteStrings.forEach((element: any): void => {"}
{"input":"<s> function getTestSelectorBasedInputs(testConfiguration: models.TestConfigurations): void {<EOL>    const testSelection: string = testConfiguration.testSelection.toLowerCase();<EOL>    switch (testSelection) {<EOL>        case '<STR_LIT>':<EOL>            console.log(tl.loc('<STR_LIT>', tl.loc('<STR_LIT>')));<EOL>            testConfiguration.testplan = parseInt(tl.getInput('<STR_LIT>'));<EOL>            console.log(tl.loc('<STR_LIT>', testConfiguration.testplan));<EOL>            testConfiguration.testPlanConfigId = parseInt(tl.getInput('<STR_LIT>'));<EOL>            console.log(tl.loc('<STR_LIT>', testConfiguration.testPlanConfigId));<EOL>            const testSuiteStrings: any = tl.getDelimitedInput('<STR_LIT>', '<STR_LIT>', true);<EOL>            testConfiguration.testSuites = new Array<number>();<EOL>            testSuiteStrings.forEach((element: any): void => {<EOL>                const","gt":"testSuiteId: number = parseInt(element);"}
{"input":"<s> function getTestSelectorBasedInputs(testConfiguration: models.TestConfigurations): void {<EOL>    const testSelection: string = testConfiguration.testSelection.toLowerCase();<EOL>    switch (testSelection) {<EOL>        case '<STR_LIT>':<EOL>            console.log(tl.loc('<STR_LIT>', tl.loc('<STR_LIT>')));<EOL>            testConfiguration.testplan = parseInt(tl.getInput('<STR_LIT>'));<EOL>            console.log(tl.loc('<STR_LIT>', testConfiguration.testplan));<EOL>            testConfiguration.testPlanConfigId = parseInt(tl.getInput('<STR_LIT>'));<EOL>            console.log(tl.loc('<STR_LIT>', testConfiguration.testPlanConfigId));<EOL>            const testSuiteStrings: any = tl.getDelimitedInput('<STR_LIT>', '<STR_LIT>', true);<EOL>            testConfiguration.testSuites = new Array<number>();<EOL>            testSuiteStrings.forEach((element: any): void => {<EOL>                const testSuiteId: number = parseInt(element);<EOL>                console.log(tl.loc('<STR_LIT>', testSuiteId));<EOL>                testConfiguration.testSuites.push(testSuiteId);<EOL>            });<EOL>            testConfiguration.sourceFilter = ['<STR_LIT>', '<STR_LIT>'];<EOL>            tl.debug('<STR_LIT>' + testConfiguration.sourceFilter);<EOL>            break;<EOL>        case '<STR_LIT>':<EOL>            console.log(tl.loc('<STR_LIT>',","gt":"tl.loc('<STR_LIT>')));"}
{"input":"<s> function getTestSelectorBasedInputs(testConfiguration: models.TestConfigurations): void {<EOL>    const testSelection: string = testConfiguration.testSelection.toLowerCase();<EOL>    switch (testSelection) {<EOL>        case '<STR_LIT>':<EOL>            console.log(tl.loc('<STR_LIT>', tl.loc('<STR_LIT>')));<EOL>            testConfiguration.testplan = parseInt(tl.getInput('<STR_LIT>'));<EOL>            console.log(tl.loc('<STR_LIT>', testConfiguration.testplan));<EOL>            testConfiguration.testPlanConfigId = parseInt(tl.getInput('<STR_LIT>'));<EOL>            console.log(tl.loc('<STR_LIT>', testConfiguration.testPlanConfigId));<EOL>            const testSuiteStrings: any = tl.getDelimitedInput('<STR_LIT>', '<STR_LIT>', true);<EOL>            testConfiguration.testSuites = new Array<number>();<EOL>            testSuiteStrings.forEach((element: any): void => {<EOL>                const testSuiteId: number = parseInt(element);<EOL>                console.log(tl.loc('<STR_LIT>', testSuiteId));<EOL>                testConfiguration.testSuites.push(testSuiteId);<EOL>            });<EOL>            testConfiguration.sourceFilter = ['<STR_LIT>', '<STR_LIT>'];<EOL>            tl.debug('<STR_LIT>' + testConfiguration.sourceFilter);<EOL>            break;<EOL>        case '<STR_LIT>':<EOL>            console.log(tl.loc('<STR_LIT>', tl.loc('<STR_LIT>')));<EOL>            testConfiguration.sourceFilter = tl.getDelimitedInput('<STR_LIT>', '<STR_LIT>', true);<EOL>            console.log(tl.loc('<STR_LIT>', testConfiguration.sourceFilter));<EOL>            testConfiguration.testcaseFilter = tl.getInput('<STR_LIT>');<EOL>            console.log(tl.loc('<STR_LIT>', testConfiguration.testcaseFilter));<EOL>            break;<EOL>        case '<STR_LIT>':<EOL>            console.log(tl.loc('<STR_LIT>', tl.loc('<STR_LIT>')));<EOL>            testConfiguration.","gt":"onDemandTestRunId = tl.getInput('<STR_LIT>');"}
{"input":"<s> function publishTestResults(testResultsDirectory: string): tl.TaskResult {<EOL>    try {<EOL>        if (testResultsDirectory) {<EOL>            const resultFiles: any = tl.findMatch(testResultsDirectory, path.join(testResultsDirectory, '<STR_LIT>'));<EOL>            if (resultFiles && resultFiles.length !== <NUM_LIT>) {<EOL>                const tp: tl.TestPublisher = new","gt":"tl.TestPublisher('<STR_LIT>');"}
{"input":"<s> function publishTestResults(testResultsDirectory: string): tl.TaskResult {<EOL>    try {<EOL>        if (testResultsDirectory) {<EOL>            const resultFiles: any = tl.findMatch(testResultsDirectory, path.join(testResultsDirectory, '<STR_LIT>'));<EOL>            if (resultFiles && resultFiles.length !== <NUM_LIT>) {<EOL>                const tp: tl.TestPublisher = new tl.TestPublisher('<STR_LIT>');<EOL>                tp.publish(resultFiles, '<STR_LIT>', vstestConfig.buildPlatform, vstestConfig.buildConfig, vstestConfig.testRunTitle, vstestConfig.publishRunAttachments);<EOL>            }<EOL>","gt":"else {"}
{"input":"<s> function publishTestResults(testResultsDirectory: string): tl.TaskResult {<EOL>    try {<EOL>        if (testResultsDirectory) {<EOL>            const resultFiles: any = tl.findMatch(testResultsDirectory, path.join(testResultsDirectory, '<STR_LIT>'));<EOL>            if (resultFiles && resultFiles.length !== <NUM_LIT>) {<EOL>                const tp: tl.TestPublisher = new tl.TestPublisher('<STR_LIT>');<EOL>                tp.publish(resultFiles, '<STR_LIT>', vstestConfig.buildPlatform, vstestConfig.buildConfig, vstestConfig.testRunTitle, vstestConfig.publishRunAttachments);<EOL>            }<EOL>            else {<EOL>                console.log('<STR_LIT>');<EOL>                tl.warning(tl.loc('<STR_LIT>'));<EOL>            }<EOL>        }<EOL>","gt":"else {"}
{"input":"<s> export function processResponse(url: any, res: any, contents: any, onResult: any): void {<EOL>    if (res.statusCode > <NUM_LIT>) {<EOL>        <EOL>        var msg: string = httpCodes[res.statusCode] ? \"<STR_LIT>\" + httpCodes[res.statusCode] : \"<STR_LIT>\";<EOL>        msg += '<STR_LIT>' + res.statusCode + '<STR_LIT>';<EOL>        if (contents && contents.length > <NUM_LIT>) {<EOL>            var","gt":"soapObj: any = contents;"}
{"input":"<s> function assertPathProperty(validatedPropertyName: string, absolutePath: string, relativePath: string): void {<EOL>    const resolvedRelativePath: string = path.","gt":"resolve(__dirname, relativePath);"}
{"input":"<s> <EOL>export function clearStyles(option: ClearStyleOptions = ClearStyleOptions.all): void {<EOL>    if (option === ClearStyleOptions.all || option === ClearStyleOptions.onlyNonThemable) {<EOL>        clearStylesInternal(_themeState.registeredStyles);<EOL>","gt":"_themeState.registeredStyles = [];"}
{"input":"<s> function listenerCount(emitter: any, evnt: any): any {<EOL>    if (emitter.listenerCount) {<EOL>","gt":"return emitter.listenerCount(evnt);"}
{"input":"<s> async function appToIntrospection(handler: ApplicationHandler): Promise<ApplicationIntrospectionResult> {<EOL>    const structure: import(\"<STR_LIT>\").ApplicationStructureRepresentation = await handler.getStructure();<EOL>    return {<EOL>        state: handler.state,<EOL>        appName: handler.appName,<EOL>        appDir: handler.","gt":"appDir,"}
{"input":"<s> async function appToIntrospection(handler: ApplicationHandler): Promise<ApplicationIntrospectionResult> {<EOL>    const structure: import(\"<STR_LIT>\").ApplicationStructureRepresentation = await handler.getStructure();<EOL>    return {<EOL>        state: handler.state,<EOL>        appName: handler.appName,<EOL>        appDir: handler.appDir,<EOL>        appId: handler.appId,<EOL>        pids: handler.pids,<EOL>        uptime: handler.uptime,<EOL>        startCount: handler.","gt":"startCount,"}
{"input":"<s> async function appToIntrospection(handler: ApplicationHandler): Promise<ApplicationIntrospectionResult> {<EOL>    const structure: import(\"<STR_LIT>\").ApplicationStructureRepresentation = await handler.getStructure();<EOL>    return {<EOL>        state: handler.state,<EOL>        appName: handler.appName,<EOL>        appDir: handler.appDir,<EOL>        appId: handler.appId,<EOL>        pids: handler.pids,<EOL>        uptime: handler.uptime,<EOL>        startCount: handler.startCount,<EOL>        restartCount: handler.restartCount,<EOL>        representation: handler.appRepresentation,<EOL>","gt":"complex: structure,"}
{"input":"<s> export function calcAppName(dir?: any): any {<EOL>    let ret: any;<EOL>    try {<EOL>        const pkg: any = require(join(process.cwd(), '<STR_LIT>'));<EOL>        pkg.","gt":"name.toString();"}
{"input":"<s> export function calcAppName(dir?: any): any {<EOL>    let ret: any;<EOL>    try {<EOL>        const pkg: any = require(join(process.cwd(), '<STR_LIT>'));<EOL>        pkg.name.toString();<EOL>        ret = removePkgNameScope(pkg.name);<EOL>    }<EOL>    catch (err: any) {<EOL>        ret = null;<EOL>    }<EOL>","gt":"if (!ret && dir) {"}
{"input":"<s> <EOL>export function chunkProcessor<T>(observableArray: T[], processor: (item: T[]) => void, debounce = <NUM_LIT>, maxChunkSize = <NUM_LIT>): IDisposer {<EOL>    if (!isObservableArray(observableArray))<EOL>        throw new Error(\"<STR_LIT>\");<EOL>    if (!isAction(processor))<EOL>        processor =","gt":"action(\"<STR_LIT>\", processor);"}
{"input":"<s> <EOL>export function chunkProcessor<T>(observableArray: T[], processor: (item: T[]) => void, debounce = <NUM_LIT>, maxChunkSize = <NUM_LIT>): IDisposer {<EOL>    if (!isObservableArray(observableArray))<EOL>        throw new Error(\"<STR_LIT>\");<EOL>    if (!isAction(processor))<EOL>        processor = action(\"<STR_LIT>\", processor);<EOL>    const runner: () => void = (): void => {<EOL>        while (observableArray.length > <NUM_LIT>) {<EOL>            let","gt":"chunkSize: number = maxChunkSize === <NUM_LIT>"}
{"input":"<s> <EOL>function escapeString(str: string): string {<EOL>    return","gt":"str.replace('<STR_LIT>', '<STR_LIT>');"}
{"input":"<s> function sortData(data: StockDataInterface[], order: string[]): StockDataInterface[] {<EOL>    data = data.map((item: StockDataInterface): StockDataInterface => {<EOL>        let index: number = order.indexOf(item.symbol);<EOL>        if (","gt":"index < <NUM_LIT>) {"}
{"input":"<s> function mobileAndTabletcheck(): boolean {<EOL>    var i: boolean = !<NUM_LIT>;<EOL>    return","gt":"function (a) {"}
{"input":"<s> function tokenkind(kind: TokenType): {<EOL>    name: string;<EOL>    kind: TokenType;<EOL>} {<EOL>","gt":"return { name: getTokenName(kind), kind: kind };"}
{"input":"<s> <EOL>export function async(source: Pattern | Pattern[], opts?: IPartialOptions): Promise<EntryItem[]> {<EOL>","gt":"const works: Promise<EntryItem[]>[] = getWorks<Promise<EntryItem[]>>(source, ReaderAsync, opts);"}
{"input":"<s> export function prepare(options?: IPartialOptions): IOptions {<EOL>    const opts: IOptions<EntryItem> & Partial<IOptions<EntryItem>> = Object.assign<IOptions, IPartialOptions | undefined>({<EOL>        cwd: process.cwd(),<EOL>        deep: true,<EOL>","gt":"ignore: [],"}
{"input":"<s> export function prepare(options?: IPartialOptions): IOptions {<EOL>    const opts: IOptions<EntryItem> & Partial<IOptions<EntryItem>> = Object.assign<IOptions, IPartialOptions | undefined>({<EOL>        cwd: process.cwd(),<EOL>        deep: true,<EOL>        ignore: [],<EOL>","gt":"dot: false,"}
{"input":"<s> export function prepare(options?: IPartialOptions): IOptions {<EOL>    const opts: IOptions<EntryItem> & Partial<IOptions<EntryItem>> = Object.assign<IOptions, IPartialOptions | undefined>({<EOL>        cwd: process.cwd(),<EOL>        deep: true,<EOL>        ignore: [],<EOL>        dot: false,<EOL>        stats: false,<EOL>","gt":"onlyFiles: true,"}
{"input":"<s> export function prepare(options?: IPartialOptions): IOptions {<EOL>    const opts: IOptions<EntryItem> & Partial<IOptions<EntryItem>> = Object.assign<IOptions, IPartialOptions | undefined>({<EOL>        cwd: process.cwd(),<EOL>        deep: true,<EOL>        ignore: [],<EOL>        dot: false,<EOL>        stats: false,<EOL>        onlyFiles: true,<EOL>        onlyDirectories: false,<EOL>        followSymlinkedDirectories: true,<EOL>        unique: true,<EOL>        markDirectories: false,<EOL>","gt":"absolute: false,"}
{"input":"<s> export function prepare(options?: IPartialOptions): IOptions {<EOL>    const opts: IOptions<EntryItem> & Partial<IOptions<EntryItem>> = Object.assign<IOptions, IPartialOptions | undefined>({<EOL>        cwd: process.cwd(),<EOL>        deep: true,<EOL>        ignore: [],<EOL>        dot: false,<EOL>        stats: false,<EOL>        onlyFiles: true,<EOL>        onlyDirectories: false,<EOL>        followSymlinkedDirectories: true,<EOL>        unique: true,<EOL>        markDirectories: false,<EOL>        absolute: false,<EOL>        nobrace: false,<EOL>        brace: true,<EOL>        noglobstar: false,<EOL>","gt":"globstar: true,"}
{"input":"<s> export function prepare(options?: IPartialOptions): IOptions {<EOL>    const opts: IOptions<EntryItem> & Partial<IOptions<EntryItem>> = Object.assign<IOptions, IPartialOptions | undefined>({<EOL>        cwd: process.cwd(),<EOL>        deep: true,<EOL>        ignore: [],<EOL>        dot: false,<EOL>        stats: false,<EOL>        onlyFiles: true,<EOL>        onlyDirectories: false,<EOL>        followSymlinkedDirectories: true,<EOL>        unique: true,<EOL>        markDirectories: false,<EOL>        absolute: false,<EOL>        nobrace: false,<EOL>        brace: true,<EOL>        noglobstar: false,<EOL>        globstar: true,<EOL>        noext: false,<EOL>        extension: true,<EOL>        nocase:","gt":"false,"}
{"input":"<s> export function prepare(options?: IPartialOptions): IOptions {<EOL>    const opts: IOptions<EntryItem> & Partial<IOptions<EntryItem>> = Object.assign<IOptions, IPartialOptions | undefined>({<EOL>        cwd: process.cwd(),<EOL>        deep: true,<EOL>        ignore: [],<EOL>        dot: false,<EOL>        stats: false,<EOL>        onlyFiles: true,<EOL>        onlyDirectories: false,<EOL>        followSymlinkedDirectories: true,<EOL>        unique: true,<EOL>        markDirectories: false,<EOL>        absolute: false,<EOL>        nobrace: false,<EOL>        brace: true,<EOL>        noglobstar: false,<EOL>        globstar: true,<EOL>        noext: false,<EOL>        extension: true,<EOL>        nocase: false,<EOL>        case: true,<EOL>        matchBase: false,<EOL>        transform: null<EOL>    }, options);<EOL>    if (opts.onlyDirectories) {<EOL>        opts.onlyFiles = false;<EOL>    }<EOL>    opts.brace = !opts.","gt":"nobrace;"}
{"input":"<s> <EOL>export function getPositivePatterns(patterns: Pattern[]): Pattern[] {<EOL>    return patternUtils.getPositivePatterns(","gt":"patterns);"}
{"input":"<s> <EOL>export function groupPatternsByBaseDirectory(patterns: Pattern[]): PatternsGroup {<EOL>    return patterns.reduce((collection: PatternsGroup, pattern: string): PatternsGroup => {<EOL>        const base: string = patternUtils.getBaseDirectory(pattern);<EOL>        if (base in collection) {<EOL>            collection[base].push(","gt":"pattern);"}
{"input":"<s> function getDeepFilterInstance(options?: IPartialOptions): DeepFilter {<EOL>    const preparedOptions: IOptions = optionsManager.prepare(options);<EOL>","gt":"return new DeepFilter(preparedOptions, {"}
{"input":"<s> export function bityOrderStatusSucceededSwap(payload: interfaces.BityOrderResponse): interfaces.BityOrderStatusSucceededSwapAction {<EOL>    return {<EOL>        type: TypeKeys.","gt":"SWAP_BITY_ORDER_STATUS_SUCCEEDED,"}
{"input":"<s> export function shapeshiftOrderStatusSucceededSwap(payload: interfaces.ShapeshiftStatusResponse): interfaces.ShapeshiftOrderStatusSucceededSwapAction {<EOL>    return {<EOL>        type: TypeKeys.","gt":"SWAP_SHAPESHIFT_ORDER_STATUS_SUCCEEDED,"}
{"input":"<s> export function startPollShapeshiftOrderStatus(): interfaces.StartPollShapeshiftOrderStatusAction {<EOL>","gt":"return {"}
{"input":"<s> <EOL>export function hexEncodeData(value: string | Buffer): string {<EOL>    return","gt":"bufferToHex(toBuffer(value));"}
{"input":"<s> function formatErrors(response: JsonRpcResponse, apiType: string): string | undefined {<EOL>    if (response.error) {<EOL>        <EOL>        <EOL>        <EOL>        <EOL>        const lines: string[] = response.error.message.split('<STR_LIT>');<EOL>        if (lines.length > <NUM_LIT>) {<EOL>            return lines[<NUM_LIT>].split('<STR_LIT>').pop();<EOL>        }<EOL>        else {<EOL>","gt":"return `<STR_LIT>`;"}
{"input":"<s> function updateWalletValues(wallets: DeterministicWalletData[], newWallet: Partial<DeterministicWalletData>): DeterministicWalletData[] {<EOL>    return wallets.map((w: DeterministicWalletData): DeterministicWalletData => {<EOL>        if (w.address === newWallet.address) {<EOL>","gt":"return {"}
{"input":"<s> function setWalletTokens(state: State): State {<EOL>    return {<EOL>        ...","gt":"state,"}
{"input":"<s> export function* setField(payload: SetToFieldAction['<STR_LIT>'] | SetTokenToMetaAction['<STR_LIT>']): Generator<any, void, boolean> {<EOL>    const etherTransaction: boolean = yield select(isEtherTransaction);<EOL>    if (etherTransaction) {<EOL>        yield","gt":"put(setToField(payload));"}
{"input":"<s> export function* updateBalances(): SagaIterator {<EOL>    const updateAccount: any = yield fork(updateAccountBalance);<EOL>    const updateToken: any = yield fork(","gt":"updateTokenBalances);"}
{"input":"<s> export function getNodeOptions(state: AppState): (NodeOption | CustomNodeOption)[] {<EOL>    return [...getStaticNodeOptions(","gt":"state), ...getCustomNodeOptions(state)];"}
{"input":"<s> export function getWalletConfig(state: AppState): WalletConfig | null | undefined {<EOL>","gt":"return state.wallet.config;"}
{"input":"<s> export function ensV3Url(name: string): string {<EOL>","gt":"return `<STR_LIT>`;"}
{"input":"<s> function promiseFromChildProcess(command: string): Promise<any> {<EOL>    return new Promise((resolve: (value: any) => void, reject: (reason?: any) => void): any => {<EOL>        return","gt":"exec(command, (err: any, stdout: any): void => {"}
{"input":"<s> export function main(): void {<EOL>    t.describe('<STR_LIT>', (): void => {<EOL>        t.be(testModuleConfig);<EOL>        t.it('<STR_LIT>', t.async((): void => {<EOL>            TestBed.compileComponents()<EOL>                .then((): void => {<EOL>                let fixture:","gt":"any = TestBed.createComponent(TestComponent);"}
{"input":"<s> export function main(): void {<EOL>    t.describe('<STR_LIT>', (): void => {<EOL>        t.be(testModuleConfig);<EOL>        t.it('<STR_LIT>', t.async((): void => {<EOL>            TestBed.compileComponents()<EOL>                .then((): void => {<EOL>                let fixture: any = TestBed.createComponent(TestComponent);<EOL>                fixture.detectChanges();<EOL>                let homeInstance: any = fixture.debugElement.children[<NUM_LIT>].componentInstance;<EOL>                let homeDOMEl: any = fixture.debugElement.children[<NUM_LIT>].nativeElement;<EOL>                t.e(homeDOMEl.","gt":"querySelectorAll('<STR_LIT>').length).toEqual(<NUM_LIT>);"}
{"input":"<s> export function main(): void {<EOL>    t.describe('<STR_LIT>', (): void => {<EOL>        t.be(testModuleConfig);<EOL>        t.it('<STR_LIT>', t.async((): void => {<EOL>            TestBed.compileComponents()<EOL>                .then((): void => {<EOL>                let fixture: any = TestBed.createComponent(TestComponent);<EOL>                fixture.detectChanges();<EOL>                let homeInstance: any = fixture.debugElement.children[<NUM_LIT>].componentInstance;<EOL>                let homeDOMEl: any = fixture.debugElement.children[<NUM_LIT>].nativeElement;<EOL>                t.e(homeDOMEl.querySelectorAll('<STR_LIT>').length).toEqual(<NUM_LIT>);<EOL>                homeInstance.newName = '<STR_LIT>';<EOL>                homeInstance.addName();<EOL>                fixture.detectChanges();<EOL>","gt":"t.e(homeDOMEl.querySelectorAll('<STR_LIT>').length).toEqual(<NUM_LIT>);"}
{"input":"<s> <EOL>export function GET_HTTP_PROVIDERS_INJECTOR(additionalProviders?: Array<any>): ReflectiveInjector {<EOL>    if (additionalProviders) {<EOL>","gt":"providers = providers.concat(additionalProviders);"}
{"input":"<s> export function cons(): any {<EOL>    return","gt":"console;"}
{"input":"<s> export function consoleLogTarget(consoleService: ConsoleService): ConsoleTarget {<EOL>    return new","gt":"ConsoleTarget(consoleService, { minLogLevel: LogLevel.Debug });"}
{"input":"<s> <EOL>function getBuildType(): string {<EOL>    let type: any = (argv['<STR_LIT>'] || argv['<STR_LIT>'] || '<STR_LIT>').toLowerCase();<EOL>    let base: string[] = argv['<STR_LIT>'];<EOL>    let prodKeyword: boolean = !!base.filter((o: string): boolean => o.indexOf(BUILD_TYPES.PRODUCTION) >=","gt":"<NUM_LIT>).pop();"}
{"input":"<s> async function createProjectFile(testInjector: IInjector): Promise<string> {<EOL>    const tempFolder: any = temp.mkdirSync(\"<STR_LIT>\");<EOL>    const options: any = testInjector.resolve(\"<STR_LIT>\");<EOL>    options.path = tempFolder;<EOL>","gt":"const projectData: {"}
{"input":"<s> export function onModalFrame(args: EventData): void {<EOL>    const view: View = args.object as View;<EOL>","gt":"const frame: Frame = new Frame();"}
{"input":"<s> function markAsUnread(id: string): void {<EOL>","gt":"loadReadArticles()[id] = false;"}
{"input":"<s> export function pageNavigatingTo(args: observable.EventData): void {<EOL>    var page: pages.Page = <pages.Page>args.object;<EOL>    page.bindingContext =","gt":"dataModel;"}
{"input":"<s> export function doNotShowAndroidKeyboard(args: EventData): void {<EOL>    let searchBar: SearchBar = <SearchBar>args.object;<EOL>    if (","gt":"searchBar.android) {"}
{"input":"<s> export function saveChanges(args: EventData): void {<EOL>    var page: Page = <Page>(<viewModule.View>args.object).page;<EOL>    var dataForm: dataFormModule.RadDataForm = <dataFormModule.RadDataForm>viewModule.getViewById(page, \"<STR_LIT>\");<EOL>    dataForm.commitAll();<EOL>","gt":"if (dataForm.hasValidationErrors()) {"}
{"input":"<s> export function saveChanges(args: EventData): void {<EOL>    var page: Page = <Page>(<viewModule.View>args.object).page;<EOL>    var dataForm: dataFormModule.RadDataForm = <dataFormModule.RadDataForm>viewModule.getViewById(page, \"<STR_LIT>\");<EOL>    dataForm.commitAll();<EOL>    if (dataForm.hasValidationErrors()) {<EOL>        return;<EOL>    }<EOL>    if (model.isNew) {<EOL>        model.reservations.","gt":"push(model.currentReservation);"}
{"input":"<s> export function drawerLoaded(args: any): void {<EOL>    var drawer: any = args.object;<EOL>    drawer.gesturesEnabled = false;<EOL>    if (!drawer.autoCloseAssigned) {<EOL>","gt":"drawer.autoCloseAssigned = true;"}
{"input":"<s> export function drawerLoaded(args: any): void {<EOL>    var drawer: any = args.object;<EOL>    drawer.gesturesEnabled = false;<EOL>    if (!drawer.autoCloseAssigned) {<EOL>        drawer.autoCloseAssigned = true;<EOL>        drawer.page.on(\"<STR_LIT>\", (args: any): void => {<EOL>            drawer.closeDrawer();<EOL>        });<EOL>        if (drawer.ios) {<EOL>            drawer.ios.defaultSideDrawer.style.shadowMode = TKSideDrawerShadowMode.TKSideDrawerShadowModeSideDrawer;<EOL>            drawer.ios.defaultSideDrawer.style.","gt":"dimOpacity = <NUM_LIT>;"}
{"input":"<s> export function openLink(args: observable.EventData): void {<EOL>    navigator.openLink(args.","gt":"object);"}
{"input":"<s> export function fromObjectRecursive(source: any): Observable {<EOL>    let observable:","gt":"ObservableFromObject = new ObservableFromObject();"}
{"input":"<s> export function minFps(): number {<EOL>    return","gt":"_minFps;"}
{"input":"<s> export function reset(): void {<EOL>","gt":"_minFps = <NUM_LIT>;"}
{"input":"<s> export function stop(): void {<EOL>    if (!native) {<EOL>","gt":"return;"}
{"input":"<s> export function Experimental(target: Object, key?: string | symbol, descriptor?: any): any {<EOL>    if (descriptor) {<EOL>        var originalMethod: any = descriptor.value;<EOL>        descriptor.value = function (...args: any[]) {<EOL>","gt":"console.log(`<STR_LIT>`);"}
{"input":"<s> export function Experimental(target: Object, key?: string | symbol, descriptor?: any): any {<EOL>    if (descriptor) {<EOL>        var originalMethod: any = descriptor.value;<EOL>        descriptor.value = function (...args: any[]) {<EOL>            console.log(`<STR_LIT>`);<EOL>            return originalMethod.apply(this, args);<EOL>        };<EOL>        return descriptor;<EOL>    }<EOL>    else {<EOL>        console.log(","gt":"target)} is experimental`<STR_LIT>;"}
{"input":"<s> export function getString(arg: any): Promise<string> {<EOL>    return new Promise<string>((resolve: (value: string | PromiseLike<string>) => void, reject: (reason?: any) => void): void => {<EOL>        httpRequest.request(typeof arg === \"<STR_LIT>\" ? { url: arg, method: \"<STR_LIT>\" } : arg)<EOL>            .then((r: import(\"<STR_LIT>\").HttpResponse): void => {<EOL>","gt":"try {"}
{"input":"<s> function getFileName(path: string): string {<EOL>    let fileName: string = typeof path === \"<STR_LIT>\" ? path.trim() : \"<STR_LIT>\";<EOL>    if (fileName.indexOf(\"<STR_LIT>\") ===","gt":"<NUM_LIT>) {"}
{"input":"<s> function countersProfileFunctionFactory<F extends Function>(fn: F, name: string, type: MemberType = MemberType.Instance): F {<EOL>    profileNames.push(name);<EOL>    return <any>function () {<EOL>        start(name);<EOL>","gt":"try {"}
{"input":"<s> function countersProfileFunctionFactory<F extends Function>(fn: F, name: string, type: MemberType = MemberType.Instance): F {<EOL>    profileNames.push(name);<EOL>    return <any>function () {<EOL>        start(name);<EOL>        try {<EOL>            return fn.apply(this, arguments);<EOL>        }<EOL>        finally {<EOL>            stop(","gt":"name);"}
{"input":"<s> export function start(name: string): void {<EOL>    let info: TimerInfo = timers[name];<EOL>    if (info) {<EOL>        info.currentStart = time();<EOL>        info.runCount++;<EOL>    }<EOL>    else {<EOL>        info = {<EOL>            totalTime: <NUM_LIT>,<EOL>","gt":"count: <NUM_LIT>,"}
{"input":"<s> export function trace(message: string, start: number, end: number): void {<EOL>    log(","gt":"message}  (${start}ms. - ${end}ms.)`<STR_LIT>;"}
{"input":"<s> function createHandlerAndGetId(): number {<EOL>    if (!timeoutHandler) {<EOL>        timeoutHandler = new","gt":"android.os.Handler(android.os.Looper.myLooper());"}
{"input":"<s> export function isEnabled(): boolean {<EOL>","gt":"return enabled;"}
{"input":"<s> export function write(message: any, category: string, type?: number): void {<EOL>    <EOL>    let i: any;<EOL>    if (type === messageType.error) {<EOL>        for (i = <NUM_LIT>; i < _writers.length; i++) {<EOL>            _writers[i].write(message, category, type);<EOL>        }<EOL>        return;<EOL>    }<EOL>    if (!enabled) {<EOL>","gt":"return;"}
{"input":"<s> export function write(message: any, category: string, type?: number): void {<EOL>    <EOL>    let i: any;<EOL>    if (type === messageType.error) {<EOL>        for (i = <NUM_LIT>; i < _writers.length; i++) {<EOL>            _writers[i].write(message, category, type);<EOL>        }<EOL>        return;<EOL>    }<EOL>    if (!enabled) {<EOL>        return;<EOL>    }<EOL>    if (!(category in _categories)) {<EOL>","gt":"return;"}
{"input":"<s> function generateItemId(): number {<EOL>","gt":"actionItemIdGenerator++;"}
{"input":"<s> function getIconVisibility(iconVisibility: string): boolean {<EOL>    switch (iconVisibility) {<EOL>        case \"<STR_LIT>\":<EOL>","gt":"return true;"}
{"input":"<s> export function loadPage(moduleNamePath: string, fileName: string, context?: any): View {<EOL>    const","gt":"componentModule: ComponentModule = loadInternal(fileName, context, moduleNamePath);"}
{"input":"<s> <EOL><EOL>export function isEventOrGesture(name: string, view: ViewBase): boolean {<EOL>    if (typeof name === \"<STR_LIT>\") {<EOL>        let","gt":"eventOrGestureName: string = getEventOrGestureName(name);"}
{"input":"<s> export function _getProperties(): Property<any, any>[] {<EOL>    return getPropertiesFromMap(symbolPropertyMap)","gt":"as Property<any, any>[];"}
{"input":"<s> export function getSetProperties(view: ViewBase): [<EOL>    string,<EOL>    any<EOL>][] {<EOL>    const result: any[] = [];<EOL>    Object.getOwnPropertyNames(view).forEach((prop: string): void => {<EOL>        result.push([prop, view[prop]]);<EOL>    });<EOL>    let symbols: symbol[] = Object.getOwnPropertySymbols(","gt":"view);"}
{"input":"<s> export function getSetProperties(view: ViewBase): [<EOL>    string,<EOL>    any<EOL>][] {<EOL>    const result: any[] = [];<EOL>    Object.getOwnPropertyNames(view).forEach((prop: string): void => {<EOL>        result.push([prop, view[prop]]);<EOL>    });<EOL>    let symbols: symbol[] = Object.getOwnPropertySymbols(view);<EOL>    for (let symbol: symbol of symbols) {<EOL>        const property: any = symbolPropertyMap[symbol];<EOL>        if (!property) {<EOL>            continue;<EOL>        }<EOL>","gt":"const value: any = view[property.key];"}
{"input":"<s> export function confirm(arg: any): Promise<boolean> {<EOL>    return new Promise<boolean>((resolve: (value: boolean | PromiseLike<boolean>) => void, reject: (reason?: any) => void): void => {<EOL>        try {<EOL>            const options: any = !isDialogOptions(arg) ? { title: CONFIRM, okButtonText: OK, cancelButtonText: CANCEL, message: arg + \"<STR_LIT>\" } : arg;<EOL>            const alert: android.app.AlertDialog.Builder = createAlertDialog(","gt":"options);"}
{"input":"<s> export function confirm(arg: any): Promise<boolean> {<EOL>    return new Promise<boolean>((resolve: (value: boolean | PromiseLike<boolean>) => void, reject: (reason?: any) => void): void => {<EOL>        try {<EOL>            const options: any = !isDialogOptions(arg) ? { title: CONFIRM, okButtonText: OK, cancelButtonText: CANCEL, message: arg + \"<STR_LIT>\" } : arg;<EOL>            const alert: android.app.AlertDialog.Builder = createAlertDialog(options);<EOL>            addButtonsToAlertDialog(alert, options, function (result) { resolve(result); });<EOL>            showDialog(alert);<EOL>        }<EOL>        catch (ex: any) {<EOL>","gt":"reject(ex);"}
{"input":"<s> function isString(value): value is string {<EOL>    return typeof","gt":"value === \"<STR_LIT>\";"}
{"input":"<s> function getDialogResult(buttons: allertButtons, index: number): boolean {<EOL>    let hasCancel: number = buttons & allertButtons.cancel;<EOL>    let hasNeutral: number = buttons & allertButtons.neutral;<EOL>    let hasOk: number = buttons & allertButtons.ok;<EOL>    if (hasCancel && hasNeutral && hasOk) {<EOL>","gt":"return index === <NUM_LIT> ? false : index === <NUM_LIT> ? true : undefined;"}
{"input":"<s> function getDialogResult(buttons: allertButtons, index: number): boolean {<EOL>    let hasCancel: number = buttons & allertButtons.cancel;<EOL>    let hasNeutral: number = buttons & allertButtons.neutral;<EOL>    let hasOk: number = buttons & allertButtons.ok;<EOL>    if (hasCancel && hasNeutral && hasOk) {<EOL>        return index === <NUM_LIT> ? false : index === <NUM_LIT> ? true : undefined;<EOL>    }<EOL>","gt":"else if (buttons & hasNeutral && hasOk) {"}
{"input":"<s> function getDialogResult(buttons: allertButtons, index: number): boolean {<EOL>    let hasCancel: number = buttons & allertButtons.cancel;<EOL>    let hasNeutral: number = buttons & allertButtons.neutral;<EOL>    let hasOk: number = buttons & allertButtons.ok;<EOL>    if (hasCancel && hasNeutral && hasOk) {<EOL>        return index === <NUM_LIT> ? false : index === <NUM_LIT> ? true : undefined;<EOL>    }<EOL>    else if (buttons & hasNeutral && hasOk) {<EOL>        return index === <NUM_LIT> ? undefined : true;<EOL>    }<EOL>    else if (hasCancel && hasOk) {<EOL>        return index !== <NUM_LIT>;<EOL>    }<EOL>    else if (hasCancel && hasNeutral) {<EOL>        return index === <NUM_LIT> ? false : undefined;<EOL>    }<EOL>    else if (hasCancel) {<EOL>","gt":"return false;"}
{"input":"<s> export function _getAnimatedEntries(frameId: number): Set<BackstackEntry> {<EOL>    return waitingQueue.","gt":"get(frameId);"}
{"input":"<s> function setupNewFragmentFadeTransition(navTransition: NavigationTransition, entry: ExpandedEntry): void {<EOL>    setupCurrentFragmentFadeTransition(navTransition, entry);<EOL>    const fadeInEnter: android.transition.Fade = new android.","gt":"transition.Fade(android.transition.Fade.IN);"}
{"input":"<s> export function stack(): Array<FrameBase> {<EOL>    return","gt":"frameStack;"}
{"input":"<s> function clearNonUniformBorders(nativeView: NativeView): void {<EOL>    if (nativeView.borderLayer) {<EOL>        nativeView.borderLayer.removeFromSuperlayer();<EOL>    }<EOL>    if (","gt":"nativeView.hasBorderMask) {"}
{"input":"<s> function clearNonUniformBorders(nativeView: NativeView): void {<EOL>    if (nativeView.borderLayer) {<EOL>        nativeView.borderLayer.removeFromSuperlayer();<EOL>    }<EOL>    if (nativeView.hasBorderMask) {<EOL>        nativeView.layer.mask = nativeView.borderOriginalMask;<EOL>        nativeView.hasBorderMask = false;<EOL>        nativeView.","gt":"borderOriginalMask = null;"}
{"input":"<s> function clearNonUniformBorders(nativeView: NativeView): void {<EOL>    if (nativeView.borderLayer) {<EOL>        nativeView.borderLayer.removeFromSuperlayer();<EOL>    }<EOL>    if (nativeView.hasBorderMask) {<EOL>        nativeView.layer.mask = nativeView.borderOriginalMask;<EOL>        nativeView.hasBorderMask = false;<EOL>        nativeView.borderOriginalMask = null;<EOL>    }<EOL>    if (nativeView.topBorderLayer) {<EOL>        nativeView.topBorderLayer.removeFromSuperlayer();<EOL>    }<EOL>    if (nativeView.rightBorderLayer) {<EOL>        nativeView.rightBorderLayer.removeFromSuperlayer();<EOL>    }<EOL>    if (nativeView.bottomBorderLayer) {<EOL>","gt":"nativeView.bottomBorderLayer.removeFromSuperlayer();"}
{"input":"<s> function getDrawParams(this: void, image: UIImage, background: BackgroundDefinition, width: number, height: number): BackgroundDrawParams {<EOL>    if (!image) {<EOL>","gt":"return null;"}
{"input":"<s> function getDrawParams(this: void, image: UIImage, background: BackgroundDefinition, width: number, height: number): BackgroundDrawParams {<EOL>    if (!image) {<EOL>        return null;<EOL>    }<EOL>","gt":"const res: BackgroundDrawParams = {"}
{"input":"<s> function getDrawParams(this: void, image: UIImage, background: BackgroundDefinition, width: number, height: number): BackgroundDrawParams {<EOL>    if (!image) {<EOL>        return null;<EOL>    }<EOL>    const res: BackgroundDrawParams = {<EOL>        repeatX: true,<EOL>        repeatY: true,<EOL>        posX: <NUM_LIT>,<EOL>        posY: <NUM_LIT>,<EOL>    };<EOL>    <EOL>    if (background.repeat) {<EOL>        switch (background.repeat.toLowerCase()) {<EOL>","gt":"case \"<STR_LIT>\":"}
{"input":"<s> function getDrawParams(this: void, image: UIImage, background: BackgroundDefinition, width: number, height: number): BackgroundDrawParams {<EOL>    if (!image) {<EOL>        return null;<EOL>    }<EOL>    const res: BackgroundDrawParams = {<EOL>        repeatX: true,<EOL>        repeatY: true,<EOL>        posX: <NUM_LIT>,<EOL>        posY: <NUM_LIT>,<EOL>    };<EOL>    <EOL>    if (background.repeat) {<EOL>        switch (background.repeat.toLowerCase()) {<EOL>            case \"<STR_LIT>\":<EOL>                res.repeatX = false;<EOL>                res.repeatY = false;<EOL>                break;<EOL>            case \"<STR_LIT>\":<EOL>                res.repeatY =","gt":"false;"}
{"input":"<s> function getDrawParams(this: void, image: UIImage, background: BackgroundDefinition, width: number, height: number): BackgroundDrawParams {<EOL>    if (!image) {<EOL>        return null;<EOL>    }<EOL>    const res: BackgroundDrawParams = {<EOL>        repeatX: true,<EOL>        repeatY: true,<EOL>        posX: <NUM_LIT>,<EOL>        posY: <NUM_LIT>,<EOL>    };<EOL>    <EOL>    if (background.repeat) {<EOL>        switch (background.repeat.toLowerCase()) {<EOL>            case \"<STR_LIT>\":<EOL>                res.repeatX = false;<EOL>                res.repeatY = false;<EOL>                break;<EOL>            case \"<STR_LIT>\":<EOL>                res.repeatY = false;<EOL>                break;<EOL>","gt":"case \"<STR_LIT>\":"}
{"input":"<s> function getDrawParams(this: void, image: UIImage, background: BackgroundDefinition, width: number, height: number): BackgroundDrawParams {<EOL>    if (!image) {<EOL>        return null;<EOL>    }<EOL>    const res: BackgroundDrawParams = {<EOL>        repeatX: true,<EOL>        repeatY: true,<EOL>        posX: <NUM_LIT>,<EOL>        posY: <NUM_LIT>,<EOL>    };<EOL>    <EOL>    if (background.repeat) {<EOL>        switch (background.repeat.toLowerCase()) {<EOL>            case \"<STR_LIT>\":<EOL>                res.repeatX = false;<EOL>                res.repeatY = false;<EOL>                break;<EOL>            case \"<STR_LIT>\":<EOL>                res.repeatY = false;<EOL>                break;<EOL>            case \"<STR_LIT>\":<EOL>                res.repeatX = false;<EOL>                break;<EOL>        }<EOL>    }<EOL>    const imageSize: CGSize = image.size;<EOL>    let imageWidth: number = imageSize.width;<EOL>    let imageHeight: number = imageSize.height;<EOL>    <EOL>    const size: string = background.","gt":"size;"}
{"input":"<s> function getDrawParams(this: void, image: UIImage, background: BackgroundDefinition, width: number, height: number): BackgroundDrawParams {<EOL>    if (!image) {<EOL>        return null;<EOL>    }<EOL>    const res: BackgroundDrawParams = {<EOL>        repeatX: true,<EOL>        repeatY: true,<EOL>        posX: <NUM_LIT>,<EOL>        posY: <NUM_LIT>,<EOL>    };<EOL>    <EOL>    if (background.repeat) {<EOL>        switch (background.repeat.toLowerCase()) {<EOL>            case \"<STR_LIT>\":<EOL>                res.repeatX = false;<EOL>                res.repeatY = false;<EOL>                break;<EOL>            case \"<STR_LIT>\":<EOL>                res.repeatY = false;<EOL>                break;<EOL>            case \"<STR_LIT>\":<EOL>                res.repeatX = false;<EOL>                break;<EOL>        }<EOL>    }<EOL>    const imageSize: CGSize = image.size;<EOL>    let imageWidth: number = imageSize.width;<EOL>    let imageHeight: number = imageSize.height;<EOL>    <EOL>    const size: string = background.size;<EOL>    if (size) {<EOL>        const values:","gt":"CSSValue[] = cssParse(size);"}
{"input":"<s> function getDrawParams(this: void, image: UIImage, background: BackgroundDefinition, width: number, height: number): BackgroundDrawParams {<EOL>    if (!image) {<EOL>        return null;<EOL>    }<EOL>    const res: BackgroundDrawParams = {<EOL>        repeatX: true,<EOL>        repeatY: true,<EOL>        posX: <NUM_LIT>,<EOL>        posY: <NUM_LIT>,<EOL>    };<EOL>    <EOL>    if (background.repeat) {<EOL>        switch (background.repeat.toLowerCase()) {<EOL>            case \"<STR_LIT>\":<EOL>                res.repeatX = false;<EOL>                res.repeatY = false;<EOL>                break;<EOL>            case \"<STR_LIT>\":<EOL>                res.repeatY = false;<EOL>                break;<EOL>            case \"<STR_LIT>\":<EOL>                res.repeatX = false;<EOL>                break;<EOL>        }<EOL>    }<EOL>    const imageSize: CGSize = image.size;<EOL>    let imageWidth: number = imageSize.width;<EOL>    let imageHeight: number = imageSize.height;<EOL>    <EOL>    const size: string = background.size;<EOL>    if (size) {<EOL>        const values: CSSValue[] = cssParse(size);<EOL>        if (values.length === <NUM_LIT>) {<EOL>            const vx: CSSValue = values[<NUM_LIT>];<EOL>            const vy: CSSValue = values[<NUM_LIT>];<EOL>            if (vx.unit === \"<STR_LIT>\" && vy.unit === \"<STR_LIT>\") {<EOL>                imageWidth = width * vx.value / <NUM_LIT>;<EOL>                imageHeight = height * vy.value / <NUM_LIT>;<EOL>                res.sizeX = imageWidth;<EOL>                res.sizeY = imageHeight;<EOL>            }<EOL>            else if (vx.type === \"<STR_LIT>\" && vy.type === \"<STR_LIT>\" &&<EOL>                ((vx.unit ===","gt":"\"<STR_LIT>\" && vy.unit === \"<STR_LIT>\") || (vx.unit === \"<STR_LIT>\" && vy.unit === \"<STR_LIT>\"))) {"}
{"input":"<s> function getDrawParams(this: void, image: UIImage, background: BackgroundDefinition, width: number, height: number): BackgroundDrawParams {<EOL>    if (!image) {<EOL>        return null;<EOL>    }<EOL>    const res: BackgroundDrawParams = {<EOL>        repeatX: true,<EOL>        repeatY: true,<EOL>        posX: <NUM_LIT>,<EOL>        posY: <NUM_LIT>,<EOL>    };<EOL>    <EOL>    if (background.repeat) {<EOL>        switch (background.repeat.toLowerCase()) {<EOL>            case \"<STR_LIT>\":<EOL>                res.repeatX = false;<EOL>                res.repeatY = false;<EOL>                break;<EOL>            case \"<STR_LIT>\":<EOL>                res.repeatY = false;<EOL>                break;<EOL>            case \"<STR_LIT>\":<EOL>                res.repeatX = false;<EOL>                break;<EOL>        }<EOL>    }<EOL>    const imageSize: CGSize = image.size;<EOL>    let imageWidth: number = imageSize.width;<EOL>    let imageHeight: number = imageSize.height;<EOL>    <EOL>    const size: string = background.size;<EOL>    if (size) {<EOL>        const values: CSSValue[] = cssParse(size);<EOL>        if (values.length === <NUM_LIT>) {<EOL>            const vx: CSSValue = values[<NUM_LIT>];<EOL>            const vy: CSSValue = values[<NUM_LIT>];<EOL>            if (vx.unit === \"<STR_LIT>\" && vy.unit === \"<STR_LIT>\") {<EOL>                imageWidth = width * vx.value / <NUM_LIT>;<EOL>                imageHeight = height * vy.value / <NUM_LIT>;<EOL>                res.sizeX = imageWidth;<EOL>                res.sizeY = imageHeight;<EOL>            }<EOL>            else if (vx.type === \"<STR_LIT>\" && vy.type === \"<STR_LIT>\" &&<EOL>                ((vx.unit === \"<STR_LIT>\" && vy.unit === \"<STR_LIT>\") || (vx.unit === \"<STR_LIT>\" && vy.unit === \"<STR_LIT>\"))) {<EOL>                imageWidth = vx.value;<EOL>                imageHeight = vy.value;<EOL>                res.sizeX = imageWidth;<EOL>                res.sizeY = imageHeight;<EOL>            }<EOL>        }<EOL>        else if (values.length === <NUM_LIT> && values[<NUM_LIT>].type === \"<STR_LIT>\") {<EOL>            let scale: number = <NUM_LIT>;<EOL>            if (values[<NUM_LIT>].string === \"<STR_LIT>\") {<EOL>                scale = Math.max(width / imageWidth, height / imageHeight);<EOL>            }<EOL>            else","gt":"if (values[<NUM_LIT>].string === \"<STR_LIT>\") {"}
{"input":"<s> function getDrawParams(this: void, image: UIImage, background: BackgroundDefinition, width: number, height: number): BackgroundDrawParams {<EOL>    if (!image) {<EOL>        return null;<EOL>    }<EOL>    const res: BackgroundDrawParams = {<EOL>        repeatX: true,<EOL>        repeatY: true,<EOL>        posX: <NUM_LIT>,<EOL>        posY: <NUM_LIT>,<EOL>    };<EOL>    <EOL>    if (background.repeat) {<EOL>        switch (background.repeat.toLowerCase()) {<EOL>            case \"<STR_LIT>\":<EOL>                res.repeatX = false;<EOL>                res.repeatY = false;<EOL>                break;<EOL>            case \"<STR_LIT>\":<EOL>                res.repeatY = false;<EOL>                break;<EOL>            case \"<STR_LIT>\":<EOL>                res.repeatX = false;<EOL>                break;<EOL>        }<EOL>    }<EOL>    const imageSize: CGSize = image.size;<EOL>    let imageWidth: number = imageSize.width;<EOL>    let imageHeight: number = imageSize.height;<EOL>    <EOL>    const size: string = background.size;<EOL>    if (size) {<EOL>        const values: CSSValue[] = cssParse(size);<EOL>        if (values.length === <NUM_LIT>) {<EOL>            const vx: CSSValue = values[<NUM_LIT>];<EOL>            const vy: CSSValue = values[<NUM_LIT>];<EOL>            if (vx.unit === \"<STR_LIT>\" && vy.unit === \"<STR_LIT>\") {<EOL>                imageWidth = width * vx.value / <NUM_LIT>;<EOL>                imageHeight = height * vy.value / <NUM_LIT>;<EOL>                res.sizeX = imageWidth;<EOL>                res.sizeY = imageHeight;<EOL>            }<EOL>            else if (vx.type === \"<STR_LIT>\" && vy.type === \"<STR_LIT>\" &&<EOL>                ((vx.unit === \"<STR_LIT>\" && vy.unit === \"<STR_LIT>\") || (vx.unit === \"<STR_LIT>\" && vy.unit === \"<STR_LIT>\"))) {<EOL>                imageWidth = vx.value;<EOL>                imageHeight = vy.value;<EOL>                res.sizeX = imageWidth;<EOL>                res.sizeY = imageHeight;<EOL>            }<EOL>        }<EOL>        else if (values.length === <NUM_LIT> && values[<NUM_LIT>].type === \"<STR_LIT>\") {<EOL>            let scale: number = <NUM_LIT>;<EOL>            if (values[<NUM_LIT>].string === \"<STR_LIT>\") {<EOL>                scale = Math.max(width / imageWidth, height / imageHeight);<EOL>            }<EOL>            else if (values[<NUM_LIT>].string === \"<STR_LIT>\") {<EOL>                scale = Math.min(width / imageWidth, height / imageHeight);<EOL>            }<EOL>            if (scale > <NUM_LIT>) {<EOL>                imageWidth *= scale;<EOL>                imageHeight *= scale;<EOL>                res.","gt":"sizeX = imageWidth;"}
{"input":"<s> function getDrawParams(this: void, image: UIImage, background: BackgroundDefinition, width: number, height: number): BackgroundDrawParams {<EOL>    if (!image) {<EOL>        return null;<EOL>    }<EOL>    const res: BackgroundDrawParams = {<EOL>        repeatX: true,<EOL>        repeatY: true,<EOL>        posX: <NUM_LIT>,<EOL>        posY: <NUM_LIT>,<EOL>    };<EOL>    <EOL>    if (background.repeat) {<EOL>        switch (background.repeat.toLowerCase()) {<EOL>            case \"<STR_LIT>\":<EOL>                res.repeatX = false;<EOL>                res.repeatY = false;<EOL>                break;<EOL>            case \"<STR_LIT>\":<EOL>                res.repeatY = false;<EOL>                break;<EOL>            case \"<STR_LIT>\":<EOL>                res.repeatX = false;<EOL>                break;<EOL>        }<EOL>    }<EOL>    const imageSize: CGSize = image.size;<EOL>    let imageWidth: number = imageSize.width;<EOL>    let imageHeight: number = imageSize.height;<EOL>    <EOL>    const size: string = background.size;<EOL>    if (size) {<EOL>        const values: CSSValue[] = cssParse(size);<EOL>        if (values.length === <NUM_LIT>) {<EOL>            const vx: CSSValue = values[<NUM_LIT>];<EOL>            const vy: CSSValue = values[<NUM_LIT>];<EOL>            if (vx.unit === \"<STR_LIT>\" && vy.unit === \"<STR_LIT>\") {<EOL>                imageWidth = width * vx.value / <NUM_LIT>;<EOL>                imageHeight = height * vy.value / <NUM_LIT>;<EOL>                res.sizeX = imageWidth;<EOL>                res.sizeY = imageHeight;<EOL>            }<EOL>            else if (vx.type === \"<STR_LIT>\" && vy.type === \"<STR_LIT>\" &&<EOL>                ((vx.unit === \"<STR_LIT>\" && vy.unit === \"<STR_LIT>\") || (vx.unit === \"<STR_LIT>\" && vy.unit === \"<STR_LIT>\"))) {<EOL>                imageWidth = vx.value;<EOL>                imageHeight = vy.value;<EOL>                res.sizeX = imageWidth;<EOL>                res.sizeY = imageHeight;<EOL>            }<EOL>        }<EOL>        else if (values.length === <NUM_LIT> && values[<NUM_LIT>].type === \"<STR_LIT>\") {<EOL>            let scale: number = <NUM_LIT>;<EOL>            if (values[<NUM_LIT>].string === \"<STR_LIT>\") {<EOL>                scale = Math.max(width / imageWidth, height / imageHeight);<EOL>            }<EOL>            else if (values[<NUM_LIT>].string === \"<STR_LIT>\") {<EOL>                scale = Math.min(width / imageWidth, height / imageHeight);<EOL>            }<EOL>            if (scale > <NUM_LIT>) {<EOL>                imageWidth *= scale;<EOL>                imageHeight *= scale;<EOL>                res.sizeX = imageWidth;<EOL>                res.sizeY =","gt":"imageHeight;"}
{"input":"<s> function getDrawParams(this: void, image: UIImage, background: BackgroundDefinition, width: number, height: number): BackgroundDrawParams {<EOL>    if (!image) {<EOL>        return null;<EOL>    }<EOL>    const res: BackgroundDrawParams = {<EOL>        repeatX: true,<EOL>        repeatY: true,<EOL>        posX: <NUM_LIT>,<EOL>        posY: <NUM_LIT>,<EOL>    };<EOL>    <EOL>    if (background.repeat) {<EOL>        switch (background.repeat.toLowerCase()) {<EOL>            case \"<STR_LIT>\":<EOL>                res.repeatX = false;<EOL>                res.repeatY = false;<EOL>                break;<EOL>            case \"<STR_LIT>\":<EOL>                res.repeatY = false;<EOL>                break;<EOL>            case \"<STR_LIT>\":<EOL>                res.repeatX = false;<EOL>                break;<EOL>        }<EOL>    }<EOL>    const imageSize: CGSize = image.size;<EOL>    let imageWidth: number = imageSize.width;<EOL>    let imageHeight: number = imageSize.height;<EOL>    <EOL>    const size: string = background.size;<EOL>    if (size) {<EOL>        const values: CSSValue[] = cssParse(size);<EOL>        if (values.length === <NUM_LIT>) {<EOL>            const vx: CSSValue = values[<NUM_LIT>];<EOL>            const vy: CSSValue = values[<NUM_LIT>];<EOL>            if (vx.unit === \"<STR_LIT>\" && vy.unit === \"<STR_LIT>\") {<EOL>                imageWidth = width * vx.value / <NUM_LIT>;<EOL>                imageHeight = height * vy.value / <NUM_LIT>;<EOL>                res.sizeX = imageWidth;<EOL>                res.sizeY = imageHeight;<EOL>            }<EOL>            else if (vx.type === \"<STR_LIT>\" && vy.type === \"<STR_LIT>\" &&<EOL>                ((vx.unit === \"<STR_LIT>\" && vy.unit === \"<STR_LIT>\") || (vx.unit === \"<STR_LIT>\" && vy.unit === \"<STR_LIT>\"))) {<EOL>                imageWidth = vx.value;<EOL>                imageHeight = vy.value;<EOL>                res.sizeX = imageWidth;<EOL>                res.sizeY = imageHeight;<EOL>            }<EOL>        }<EOL>        else if (values.length === <NUM_LIT> && values[<NUM_LIT>].type === \"<STR_LIT>\") {<EOL>            let scale: number = <NUM_LIT>;<EOL>            if (values[<NUM_LIT>].string === \"<STR_LIT>\") {<EOL>                scale = Math.max(width / imageWidth, height / imageHeight);<EOL>            }<EOL>            else if (values[<NUM_LIT>].string === \"<STR_LIT>\") {<EOL>                scale = Math.min(width / imageWidth, height / imageHeight);<EOL>            }<EOL>            if (scale > <NUM_LIT>) {<EOL>                imageWidth *= scale;<EOL>                imageHeight *= scale;<EOL>                res.sizeX = imageWidth;<EOL>                res.sizeY = imageHeight;<EOL>            }<EOL>        }<EOL>    }<EOL>    <EOL>    const position: string = background.position;<EOL>    if (position) {<EOL>        const v: {<EOL>            x: CSSValue;<EOL>            y: CSSValue;<EOL>        } = parsePosition(position);<EOL>        if (v) {<EOL>            const spaceX: number = width - imageWidth;<EOL>            const spaceY: number = height - imageHeight;<EOL>            if (v.x.unit === \"<STR_LIT>\" && v.y.unit === \"<STR_LIT>\") {<EOL>                res.","gt":"posX = spaceX * v.x.value / <NUM_LIT>;"}
{"input":"<s> function getDrawParams(this: void, image: UIImage, background: BackgroundDefinition, width: number, height: number): BackgroundDrawParams {<EOL>    if (!image) {<EOL>        return null;<EOL>    }<EOL>    const res: BackgroundDrawParams = {<EOL>        repeatX: true,<EOL>        repeatY: true,<EOL>        posX: <NUM_LIT>,<EOL>        posY: <NUM_LIT>,<EOL>    };<EOL>    <EOL>    if (background.repeat) {<EOL>        switch (background.repeat.toLowerCase()) {<EOL>            case \"<STR_LIT>\":<EOL>                res.repeatX = false;<EOL>                res.repeatY = false;<EOL>                break;<EOL>            case \"<STR_LIT>\":<EOL>                res.repeatY = false;<EOL>                break;<EOL>            case \"<STR_LIT>\":<EOL>                res.repeatX = false;<EOL>                break;<EOL>        }<EOL>    }<EOL>    const imageSize: CGSize = image.size;<EOL>    let imageWidth: number = imageSize.width;<EOL>    let imageHeight: number = imageSize.height;<EOL>    <EOL>    const size: string = background.size;<EOL>    if (size) {<EOL>        const values: CSSValue[] = cssParse(size);<EOL>        if (values.length === <NUM_LIT>) {<EOL>            const vx: CSSValue = values[<NUM_LIT>];<EOL>            const vy: CSSValue = values[<NUM_LIT>];<EOL>            if (vx.unit === \"<STR_LIT>\" && vy.unit === \"<STR_LIT>\") {<EOL>                imageWidth = width * vx.value / <NUM_LIT>;<EOL>                imageHeight = height * vy.value / <NUM_LIT>;<EOL>                res.sizeX = imageWidth;<EOL>                res.sizeY = imageHeight;<EOL>            }<EOL>            else if (vx.type === \"<STR_LIT>\" && vy.type === \"<STR_LIT>\" &&<EOL>                ((vx.unit === \"<STR_LIT>\" && vy.unit === \"<STR_LIT>\") || (vx.unit === \"<STR_LIT>\" && vy.unit === \"<STR_LIT>\"))) {<EOL>                imageWidth = vx.value;<EOL>                imageHeight = vy.value;<EOL>                res.sizeX = imageWidth;<EOL>                res.sizeY = imageHeight;<EOL>            }<EOL>        }<EOL>        else if (values.length === <NUM_LIT> && values[<NUM_LIT>].type === \"<STR_LIT>\") {<EOL>            let scale: number = <NUM_LIT>;<EOL>            if (values[<NUM_LIT>].string === \"<STR_LIT>\") {<EOL>                scale = Math.max(width / imageWidth, height / imageHeight);<EOL>            }<EOL>            else if (values[<NUM_LIT>].string === \"<STR_LIT>\") {<EOL>                scale = Math.min(width / imageWidth, height / imageHeight);<EOL>            }<EOL>            if (scale > <NUM_LIT>) {<EOL>                imageWidth *= scale;<EOL>                imageHeight *= scale;<EOL>                res.sizeX = imageWidth;<EOL>                res.sizeY = imageHeight;<EOL>            }<EOL>        }<EOL>    }<EOL>    <EOL>    const position: string = background.position;<EOL>    if (position) {<EOL>        const v: {<EOL>            x: CSSValue;<EOL>            y: CSSValue;<EOL>        } = parsePosition(position);<EOL>        if (v) {<EOL>            const spaceX: number = width - imageWidth;<EOL>            const spaceY: number = height - imageHeight;<EOL>            if (v.x.unit === \"<STR_LIT>\" && v.y.unit === \"<STR_LIT>\") {<EOL>                res.posX = spaceX * v.x.value / <NUM_LIT>;<EOL>                res.posY = spaceY * v.y.value / <NUM_LIT>;<EOL>            }<EOL>            else if (v.x.type === \"<STR_LIT>\" && v.y.type === \"<STR_LIT>\" &&<EOL>                ((v.x.unit === \"<STR_LIT>\" && v.y.unit === \"<STR_LIT>\") || (v.x.unit === \"<STR_LIT>\" && v.y.unit === \"<STR_LIT>\"))) {<EOL>","gt":"res.posX = v.x.value;"}
{"input":"<s> function getDrawParams(this: void, image: UIImage, background: BackgroundDefinition, width: number, height: number): BackgroundDrawParams {<EOL>    if (!image) {<EOL>        return null;<EOL>    }<EOL>    const res: BackgroundDrawParams = {<EOL>        repeatX: true,<EOL>        repeatY: true,<EOL>        posX: <NUM_LIT>,<EOL>        posY: <NUM_LIT>,<EOL>    };<EOL>    <EOL>    if (background.repeat) {<EOL>        switch (background.repeat.toLowerCase()) {<EOL>            case \"<STR_LIT>\":<EOL>                res.repeatX = false;<EOL>                res.repeatY = false;<EOL>                break;<EOL>            case \"<STR_LIT>\":<EOL>                res.repeatY = false;<EOL>                break;<EOL>            case \"<STR_LIT>\":<EOL>                res.repeatX = false;<EOL>                break;<EOL>        }<EOL>    }<EOL>    const imageSize: CGSize = image.size;<EOL>    let imageWidth: number = imageSize.width;<EOL>    let imageHeight: number = imageSize.height;<EOL>    <EOL>    const size: string = background.size;<EOL>    if (size) {<EOL>        const values: CSSValue[] = cssParse(size);<EOL>        if (values.length === <NUM_LIT>) {<EOL>            const vx: CSSValue = values[<NUM_LIT>];<EOL>            const vy: CSSValue = values[<NUM_LIT>];<EOL>            if (vx.unit === \"<STR_LIT>\" && vy.unit === \"<STR_LIT>\") {<EOL>                imageWidth = width * vx.value / <NUM_LIT>;<EOL>                imageHeight = height * vy.value / <NUM_LIT>;<EOL>                res.sizeX = imageWidth;<EOL>                res.sizeY = imageHeight;<EOL>            }<EOL>            else if (vx.type === \"<STR_LIT>\" && vy.type === \"<STR_LIT>\" &&<EOL>                ((vx.unit === \"<STR_LIT>\" && vy.unit === \"<STR_LIT>\") || (vx.unit === \"<STR_LIT>\" && vy.unit === \"<STR_LIT>\"))) {<EOL>                imageWidth = vx.value;<EOL>                imageHeight = vy.value;<EOL>                res.sizeX = imageWidth;<EOL>                res.sizeY = imageHeight;<EOL>            }<EOL>        }<EOL>        else if (values.length === <NUM_LIT> && values[<NUM_LIT>].type === \"<STR_LIT>\") {<EOL>            let scale: number = <NUM_LIT>;<EOL>            if (values[<NUM_LIT>].string === \"<STR_LIT>\") {<EOL>                scale = Math.max(width / imageWidth, height / imageHeight);<EOL>            }<EOL>            else if (values[<NUM_LIT>].string === \"<STR_LIT>\") {<EOL>                scale = Math.min(width / imageWidth, height / imageHeight);<EOL>            }<EOL>            if (scale > <NUM_LIT>) {<EOL>                imageWidth *= scale;<EOL>                imageHeight *= scale;<EOL>                res.sizeX = imageWidth;<EOL>                res.sizeY = imageHeight;<EOL>            }<EOL>        }<EOL>    }<EOL>    <EOL>    const position: string = background.position;<EOL>    if (position) {<EOL>        const v: {<EOL>            x: CSSValue;<EOL>            y: CSSValue;<EOL>        } = parsePosition(position);<EOL>        if (v) {<EOL>            const spaceX: number = width - imageWidth;<EOL>            const spaceY: number = height - imageHeight;<EOL>            if (v.x.unit === \"<STR_LIT>\" && v.y.unit === \"<STR_LIT>\") {<EOL>                res.posX = spaceX * v.x.value / <NUM_LIT>;<EOL>                res.posY = spaceY * v.y.value / <NUM_LIT>;<EOL>            }<EOL>            else if (v.x.type === \"<STR_LIT>\" && v.y.type === \"<STR_LIT>\" &&<EOL>                ((v.x.unit === \"<STR_LIT>\" && v.y.unit === \"<STR_LIT>\") || (v.x.unit === \"<STR_LIT>\" && v.y.unit === \"<STR_LIT>\"))) {<EOL>                res.posX = v.x.value;<EOL>                res.posY =","gt":"v.y.value;"}
{"input":"<s> function getDrawParams(this: void, image: UIImage, background: BackgroundDefinition, width: number, height: number): BackgroundDrawParams {<EOL>    if (!image) {<EOL>        return null;<EOL>    }<EOL>    const res: BackgroundDrawParams = {<EOL>        repeatX: true,<EOL>        repeatY: true,<EOL>        posX: <NUM_LIT>,<EOL>        posY: <NUM_LIT>,<EOL>    };<EOL>    <EOL>    if (background.repeat) {<EOL>        switch (background.repeat.toLowerCase()) {<EOL>            case \"<STR_LIT>\":<EOL>                res.repeatX = false;<EOL>                res.repeatY = false;<EOL>                break;<EOL>            case \"<STR_LIT>\":<EOL>                res.repeatY = false;<EOL>                break;<EOL>            case \"<STR_LIT>\":<EOL>                res.repeatX = false;<EOL>                break;<EOL>        }<EOL>    }<EOL>    const imageSize: CGSize = image.size;<EOL>    let imageWidth: number = imageSize.width;<EOL>    let imageHeight: number = imageSize.height;<EOL>    <EOL>    const size: string = background.size;<EOL>    if (size) {<EOL>        const values: CSSValue[] = cssParse(size);<EOL>        if (values.length === <NUM_LIT>) {<EOL>            const vx: CSSValue = values[<NUM_LIT>];<EOL>            const vy: CSSValue = values[<NUM_LIT>];<EOL>            if (vx.unit === \"<STR_LIT>\" && vy.unit === \"<STR_LIT>\") {<EOL>                imageWidth = width * vx.value / <NUM_LIT>;<EOL>                imageHeight = height * vy.value / <NUM_LIT>;<EOL>                res.sizeX = imageWidth;<EOL>                res.sizeY = imageHeight;<EOL>            }<EOL>            else if (vx.type === \"<STR_LIT>\" && vy.type === \"<STR_LIT>\" &&<EOL>                ((vx.unit === \"<STR_LIT>\" && vy.unit === \"<STR_LIT>\") || (vx.unit === \"<STR_LIT>\" && vy.unit === \"<STR_LIT>\"))) {<EOL>                imageWidth = vx.value;<EOL>                imageHeight = vy.value;<EOL>                res.sizeX = imageWidth;<EOL>                res.sizeY = imageHeight;<EOL>            }<EOL>        }<EOL>        else if (values.length === <NUM_LIT> && values[<NUM_LIT>].type === \"<STR_LIT>\") {<EOL>            let scale: number = <NUM_LIT>;<EOL>            if (values[<NUM_LIT>].string === \"<STR_LIT>\") {<EOL>                scale = Math.max(width / imageWidth, height / imageHeight);<EOL>            }<EOL>            else if (values[<NUM_LIT>].string === \"<STR_LIT>\") {<EOL>                scale = Math.min(width / imageWidth, height / imageHeight);<EOL>            }<EOL>            if (scale > <NUM_LIT>) {<EOL>                imageWidth *= scale;<EOL>                imageHeight *= scale;<EOL>                res.sizeX = imageWidth;<EOL>                res.sizeY = imageHeight;<EOL>            }<EOL>        }<EOL>    }<EOL>    <EOL>    const position: string = background.position;<EOL>    if (position) {<EOL>        const v: {<EOL>            x: CSSValue;<EOL>            y: CSSValue;<EOL>        } = parsePosition(position);<EOL>        if (v) {<EOL>            const spaceX: number = width - imageWidth;<EOL>            const spaceY: number = height - imageHeight;<EOL>            if (v.x.unit === \"<STR_LIT>\" && v.y.unit === \"<STR_LIT>\") {<EOL>                res.posX = spaceX * v.x.value / <NUM_LIT>;<EOL>                res.posY = spaceY * v.y.value / <NUM_LIT>;<EOL>            }<EOL>            else if (v.x.type === \"<STR_LIT>\" && v.y.type === \"<STR_LIT>\" &&<EOL>                ((v.x.unit === \"<STR_LIT>\" && v.y.unit === \"<STR_LIT>\") || (v.x.unit === \"<STR_LIT>\" && v.y.unit === \"<STR_LIT>\"))) {<EOL>                res.posX = v.x.value;<EOL>                res.posY = v.y.value;<EOL>            }<EOL>            else if (v.x.type === \"<STR_LIT>\" && v.y.type === \"<STR_LIT>\") {<EOL>                if (v.x.string.toLowerCase() === \"<STR_LIT>\") {<EOL>                    res.posX = spaceX /","gt":"<NUM_LIT>;"}
{"input":"<s> function getDrawParams(this: void, image: UIImage, background: BackgroundDefinition, width: number, height: number): BackgroundDrawParams {<EOL>    if (!image) {<EOL>        return null;<EOL>    }<EOL>    const res: BackgroundDrawParams = {<EOL>        repeatX: true,<EOL>        repeatY: true,<EOL>        posX: <NUM_LIT>,<EOL>        posY: <NUM_LIT>,<EOL>    };<EOL>    <EOL>    if (background.repeat) {<EOL>        switch (background.repeat.toLowerCase()) {<EOL>            case \"<STR_LIT>\":<EOL>                res.repeatX = false;<EOL>                res.repeatY = false;<EOL>                break;<EOL>            case \"<STR_LIT>\":<EOL>                res.repeatY = false;<EOL>                break;<EOL>            case \"<STR_LIT>\":<EOL>                res.repeatX = false;<EOL>                break;<EOL>        }<EOL>    }<EOL>    const imageSize: CGSize = image.size;<EOL>    let imageWidth: number = imageSize.width;<EOL>    let imageHeight: number = imageSize.height;<EOL>    <EOL>    const size: string = background.size;<EOL>    if (size) {<EOL>        const values: CSSValue[] = cssParse(size);<EOL>        if (values.length === <NUM_LIT>) {<EOL>            const vx: CSSValue = values[<NUM_LIT>];<EOL>            const vy: CSSValue = values[<NUM_LIT>];<EOL>            if (vx.unit === \"<STR_LIT>\" && vy.unit === \"<STR_LIT>\") {<EOL>                imageWidth = width * vx.value / <NUM_LIT>;<EOL>                imageHeight = height * vy.value / <NUM_LIT>;<EOL>                res.sizeX = imageWidth;<EOL>                res.sizeY = imageHeight;<EOL>            }<EOL>            else if (vx.type === \"<STR_LIT>\" && vy.type === \"<STR_LIT>\" &&<EOL>                ((vx.unit === \"<STR_LIT>\" && vy.unit === \"<STR_LIT>\") || (vx.unit === \"<STR_LIT>\" && vy.unit === \"<STR_LIT>\"))) {<EOL>                imageWidth = vx.value;<EOL>                imageHeight = vy.value;<EOL>                res.sizeX = imageWidth;<EOL>                res.sizeY = imageHeight;<EOL>            }<EOL>        }<EOL>        else if (values.length === <NUM_LIT> && values[<NUM_LIT>].type === \"<STR_LIT>\") {<EOL>            let scale: number = <NUM_LIT>;<EOL>            if (values[<NUM_LIT>].string === \"<STR_LIT>\") {<EOL>                scale = Math.max(width / imageWidth, height / imageHeight);<EOL>            }<EOL>            else if (values[<NUM_LIT>].string === \"<STR_LIT>\") {<EOL>                scale = Math.min(width / imageWidth, height / imageHeight);<EOL>            }<EOL>            if (scale > <NUM_LIT>) {<EOL>                imageWidth *= scale;<EOL>                imageHeight *= scale;<EOL>                res.sizeX = imageWidth;<EOL>                res.sizeY = imageHeight;<EOL>            }<EOL>        }<EOL>    }<EOL>    <EOL>    const position: string = background.position;<EOL>    if (position) {<EOL>        const v: {<EOL>            x: CSSValue;<EOL>            y: CSSValue;<EOL>        } = parsePosition(position);<EOL>        if (v) {<EOL>            const spaceX: number = width - imageWidth;<EOL>            const spaceY: number = height - imageHeight;<EOL>            if (v.x.unit === \"<STR_LIT>\" && v.y.unit === \"<STR_LIT>\") {<EOL>                res.posX = spaceX * v.x.value / <NUM_LIT>;<EOL>                res.posY = spaceY * v.y.value / <NUM_LIT>;<EOL>            }<EOL>            else if (v.x.type === \"<STR_LIT>\" && v.y.type === \"<STR_LIT>\" &&<EOL>                ((v.x.unit === \"<STR_LIT>\" && v.y.unit === \"<STR_LIT>\") || (v.x.unit === \"<STR_LIT>\" && v.y.unit === \"<STR_LIT>\"))) {<EOL>                res.posX = v.x.value;<EOL>                res.posY = v.y.value;<EOL>            }<EOL>            else if (v.x.type === \"<STR_LIT>\" && v.y.type === \"<STR_LIT>\") {<EOL>                if (v.x.string.toLowerCase() === \"<STR_LIT>\") {<EOL>                    res.posX = spaceX / <NUM_LIT>;<EOL>                }<EOL>                else if (","gt":"v.x.string.toLowerCase() === \"<STR_LIT>\") {"}
{"input":"<s> function getDrawParams(this: void, image: UIImage, background: BackgroundDefinition, width: number, height: number): BackgroundDrawParams {<EOL>    if (!image) {<EOL>        return null;<EOL>    }<EOL>    const res: BackgroundDrawParams = {<EOL>        repeatX: true,<EOL>        repeatY: true,<EOL>        posX: <NUM_LIT>,<EOL>        posY: <NUM_LIT>,<EOL>    };<EOL>    <EOL>    if (background.repeat) {<EOL>        switch (background.repeat.toLowerCase()) {<EOL>            case \"<STR_LIT>\":<EOL>                res.repeatX = false;<EOL>                res.repeatY = false;<EOL>                break;<EOL>            case \"<STR_LIT>\":<EOL>                res.repeatY = false;<EOL>                break;<EOL>            case \"<STR_LIT>\":<EOL>                res.repeatX = false;<EOL>                break;<EOL>        }<EOL>    }<EOL>    const imageSize: CGSize = image.size;<EOL>    let imageWidth: number = imageSize.width;<EOL>    let imageHeight: number = imageSize.height;<EOL>    <EOL>    const size: string = background.size;<EOL>    if (size) {<EOL>        const values: CSSValue[] = cssParse(size);<EOL>        if (values.length === <NUM_LIT>) {<EOL>            const vx: CSSValue = values[<NUM_LIT>];<EOL>            const vy: CSSValue = values[<NUM_LIT>];<EOL>            if (vx.unit === \"<STR_LIT>\" && vy.unit === \"<STR_LIT>\") {<EOL>                imageWidth = width * vx.value / <NUM_LIT>;<EOL>                imageHeight = height * vy.value / <NUM_LIT>;<EOL>                res.sizeX = imageWidth;<EOL>                res.sizeY = imageHeight;<EOL>            }<EOL>            else if (vx.type === \"<STR_LIT>\" && vy.type === \"<STR_LIT>\" &&<EOL>                ((vx.unit === \"<STR_LIT>\" && vy.unit === \"<STR_LIT>\") || (vx.unit === \"<STR_LIT>\" && vy.unit === \"<STR_LIT>\"))) {<EOL>                imageWidth = vx.value;<EOL>                imageHeight = vy.value;<EOL>                res.sizeX = imageWidth;<EOL>                res.sizeY = imageHeight;<EOL>            }<EOL>        }<EOL>        else if (values.length === <NUM_LIT> && values[<NUM_LIT>].type === \"<STR_LIT>\") {<EOL>            let scale: number = <NUM_LIT>;<EOL>            if (values[<NUM_LIT>].string === \"<STR_LIT>\") {<EOL>                scale = Math.max(width / imageWidth, height / imageHeight);<EOL>            }<EOL>            else if (values[<NUM_LIT>].string === \"<STR_LIT>\") {<EOL>                scale = Math.min(width / imageWidth, height / imageHeight);<EOL>            }<EOL>            if (scale > <NUM_LIT>) {<EOL>                imageWidth *= scale;<EOL>                imageHeight *= scale;<EOL>                res.sizeX = imageWidth;<EOL>                res.sizeY = imageHeight;<EOL>            }<EOL>        }<EOL>    }<EOL>    <EOL>    const position: string = background.position;<EOL>    if (position) {<EOL>        const v: {<EOL>            x: CSSValue;<EOL>            y: CSSValue;<EOL>        } = parsePosition(position);<EOL>        if (v) {<EOL>            const spaceX: number = width - imageWidth;<EOL>            const spaceY: number = height - imageHeight;<EOL>            if (v.x.unit === \"<STR_LIT>\" && v.y.unit === \"<STR_LIT>\") {<EOL>                res.posX = spaceX * v.x.value / <NUM_LIT>;<EOL>                res.posY = spaceY * v.y.value / <NUM_LIT>;<EOL>            }<EOL>            else if (v.x.type === \"<STR_LIT>\" && v.y.type === \"<STR_LIT>\" &&<EOL>                ((v.x.unit === \"<STR_LIT>\" && v.y.unit === \"<STR_LIT>\") || (v.x.unit === \"<STR_LIT>\" && v.y.unit === \"<STR_LIT>\"))) {<EOL>                res.posX = v.x.value;<EOL>                res.posY = v.y.value;<EOL>            }<EOL>            else if (v.x.type === \"<STR_LIT>\" && v.y.type === \"<STR_LIT>\") {<EOL>                if (v.x.string.toLowerCase() === \"<STR_LIT>\") {<EOL>                    res.posX = spaceX / <NUM_LIT>;<EOL>                }<EOL>                else if (v.x.string.toLowerCase() === \"<STR_LIT>\") {<EOL>                    res.posX =","gt":"spaceX;"}
{"input":"<s> function createSimpleSelectorFromAst(ast: parser.SimpleSelector): SimpleSelector {<EOL>    switch (ast.type) {<EOL>        case \"<STR_LIT>\": return new UniversalSelector();<EOL>        case \"<STR_LIT>\": return new IdSelector(","gt":"ast.identifier);"}
{"input":"<s> function getFontFamilyRespectingGenericFonts(fontFamily: string): string {<EOL>    if (!fontFamily) {<EOL>        return fontFamily;<EOL>    }<EOL>    switch (","gt":"fontFamily.toLowerCase()) {"}
{"input":"<s> function getFontFamilyRespectingGenericFonts(fontFamily: string): string {<EOL>    if (!fontFamily) {<EOL>        return fontFamily;<EOL>    }<EOL>    switch (fontFamily.toLowerCase()) {<EOL>        case genericFontFamilies.serif:<EOL>            return DEFAULT_SERIF;<EOL>        case genericFontFamilies.monospace:<EOL>            return DEFAULT_MONOSPACE;<EOL>","gt":"default:"}
{"input":"<s> function registerCustomFonts(): void {<EOL>    const appDir: string = fs.knownFolders.currentApp().path;<EOL>    const fontsDir: string = fs.path.join(appDir,","gt":"\"<STR_LIT>\");"}
{"input":"<s> function getCapitalizedString(str: string): string {<EOL>    let words: string[] = str.split(\"<STR_LIT>\");<EOL>    let newWords: any[] = [];<EOL>    for (","gt":"let i: number = <NUM_LIT>, length: number = words.length; i < length; i++) {"}
{"input":"<s> function getMinutes(hour: number): number {<EOL>    return","gt":"hour * <NUM_LIT>;"}
{"input":"<s> export function GC(): void {<EOL>","gt":"gc();"}
{"input":"<s> export function copyRuntime(path: string): void {<EOL>    copySync(join(","gt":"__dirname, \"<STR_LIT>\"), path);"}
{"input":"<s> export async function deployContract(contractName: string): Promise<ContractInstance> {<EOL>    return new Promise<ContractInstance>((resolve: (value: ContractInstance | PromiseLike<ContractInstance>) => void, reject: (reason?: any) => void): void => {<EOL>        const dirPath: string = join(__dirname, \"<STR_LIT>\");<EOL>        const fileName: string = `<STR_LIT>`;<EOL>        const abi: any = JSON.parse(readFileSync(join(dirPath, fileName + \"<STR_LIT>\"), \"<STR_LIT>\"));<EOL>        const bin: string = readFileSync(join(dirPath, fileName + \"<STR_LIT>\"), \"<STR_LIT>\");<EOL>","gt":"const code: string = \"<STR_LIT>\" + bin;"}
{"input":"<s> export async function deployContract(contractName: string): Promise<ContractInstance> {<EOL>    return new Promise<ContractInstance>((resolve: (value: ContractInstance | PromiseLike<ContractInstance>) => void, reject: (reason?: any) => void): void => {<EOL>        const dirPath: string = join(__dirname, \"<STR_LIT>\");<EOL>        const fileName: string = `<STR_LIT>`;<EOL>        const abi: any = JSON.parse(readFileSync(join(dirPath, fileName + \"<STR_LIT>\"), \"<STR_LIT>\"));<EOL>        const bin: string = readFileSync(join(dirPath, fileName + \"<STR_LIT>\"), \"<STR_LIT>\");<EOL>        const code: string = \"<STR_LIT>\" + bin;<EOL>        const contract: import(\"<STR_LIT>\").Contract<any> = web3.eth.contract(abi);<EOL>        (contract as any).new({ from: accounts[<NUM_LIT>], data: code, gas: GAS_LIMIT_STANDARD }, (err: Error, contract: any): void => {<EOL>            <EOL>            <EOL>            if (err) {<EOL>                reject(err);<EOL>            }<EOL>            else if (contract.","gt":"address) {"}
{"input":"<s> function extractLogLevel(options: NexeOptions): string {<EOL>    if (options.loglevel)<EOL>        return options.loglevel;<EOL>    if (options.","gt":"silent)"}
{"input":"<s> function dequote(input: string): string {<EOL>    input = input.trim();<EOL>    const singleQuote: boolean = input.startsWith(\"<STR_LIT>\") && input.endsWith(\"<STR_LIT>\");<EOL>    const doubleQuote: boolean = input.","gt":"startsWith('<STR_LIT>') && input.endsWith('<STR_LIT>');"}
{"input":"<s> function getAriaState(compiled: any): boolean[] {<EOL>    const stars: HTMLElement[] = getStars(","gt":"compiled, '<STR_LIT>');"}
{"input":"<s> function getStar(compiled: any, num: number): HTMLElement {<EOL>    return getStars(","gt":"compiled)[num - <NUM_LIT>];"}
{"input":"<s> function getState(element: DebugElement | HTMLElement): boolean[] {<EOL>    const stars: HTMLElement[] = getStars(element instanceof","gt":"DebugElement ? element.nativeElement : element);"}
{"input":"<s> export function isService(annotation: any): annotation is InjectableMetadata {<EOL>    return annotation instanceof","gt":"InjectableMetadata;"}
{"input":"<s> export function isPromise(obj: any): boolean {<EOL>    return obj instanceof (<any>","gt":"_global).Promise;"}
{"input":"<s> export function reducer(state: any, action: any): any {<EOL>    if (environment.production) {<EOL>        return","gt":"productionReducer(state, action);"}
{"input":"<s> export function mapAsync<T>(list: T[], mapFn: (v: T, i: number) => Promise<any>): Promise<any[]> {<EOL>    return Promise.all(list.map(","gt":"mapFn));"}
{"input":"<s> <EOL>export async function minifyUmdBundles(config: Config): Promise<void> {<EOL>    const uglifyArgs: string[] = ['<STR_LIT>', '<STR_LIT>', '<STR_LIT>'];<EOL>    await mapAsync(util.getAllPackages(config), async (pkg: string): Promise<string | undefined> => {<EOL>        const topLevelName: string = util.getTopLevelName(pkg);<EOL>        if (!util.shouldBundle(config, topLevelName)) {<EOL>","gt":"return;"}
{"input":"<s> <EOL>export async function minifyUmdBundles(config: Config): Promise<void> {<EOL>    const uglifyArgs: string[] = ['<STR_LIT>', '<STR_LIT>', '<STR_LIT>'];<EOL>    await mapAsync(util.getAllPackages(config), async (pkg: string): Promise<string | undefined> => {<EOL>        const topLevelName: string = util.getTopLevelName(pkg);<EOL>        if (!util.shouldBundle(config, topLevelName)) {<EOL>            return;<EOL>        }<EOL>        const destinationName: string = util.getDestinationName(pkg);<EOL>        const file: string = `<STR_LIT>`;<EOL>","gt":"const out: string = `<STR_LIT>`;"}
{"input":"<s> <EOL>export async function minifyUmdBundles(config: Config): Promise<void> {<EOL>    const uglifyArgs: string[] = ['<STR_LIT>', '<STR_LIT>', '<STR_LIT>'];<EOL>    await mapAsync(util.getAllPackages(config), async (pkg: string): Promise<string | undefined> => {<EOL>        const topLevelName: string = util.getTopLevelName(pkg);<EOL>        if (!util.shouldBundle(config, topLevelName)) {<EOL>            return;<EOL>        }<EOL>        const destinationName: string = util.getDestinationName(pkg);<EOL>        const file: string = `<STR_LIT>`;<EOL>        const out: string = `<STR_LIT>`;<EOL>        return util.exec('<STR_LIT>', [<EOL>            file,<EOL>            ...uglifyArgs,<EOL>","gt":"out}`<STR_LIT>,"}
{"input":"<s> export function getTopLevelPackages(config: Config): string[] {<EOL>    return config.packages.map((packageDescription: import(\"<STR_LIT>\").PackageDescription): string =>","gt":"packageDescription.name);"}
{"input":"<s> export function reducer(state = initialState, action: BookActions | CollectionActions): State {<EOL>    switch (action.type) {<EOL>        case BookActionTypes.SearchComplete:<EOL>        case CollectionActionTypes.LoadSuccess: {<EOL>            <EOL>","gt":"return adapter.addMany(action.payload, {"}
{"input":"<s> export function reducer(state = initialState, action: BookActions | CollectionActions): State {<EOL>    switch (action.type) {<EOL>        case BookActionTypes.SearchComplete:<EOL>        case CollectionActionTypes.LoadSuccess: {<EOL>            <EOL>            return adapter.addMany(action.payload, {<EOL>                ...state,<EOL>                selectedBookId: state.selectedBookId,<EOL>            });<EOL>        }<EOL>        case BookActionTypes.Load: {<EOL>            <EOL>            return adapter.addOne(action.payload, {<EOL>                ...state,<EOL>                selectedBookId:","gt":"state.selectedBookId,"}
{"input":"<s> export function reducer(state = initialState, action: BookActions | CollectionActions): State {<EOL>    switch (action.type) {<EOL>        case BookActionTypes.SearchComplete:<EOL>        case CollectionActionTypes.LoadSuccess: {<EOL>            <EOL>            return adapter.addMany(action.payload, {<EOL>                ...state,<EOL>                selectedBookId: state.selectedBookId,<EOL>            });<EOL>        }<EOL>        case BookActionTypes.Load: {<EOL>            <EOL>            return adapter.addOne(action.payload, {<EOL>                ...state,<EOL>                selectedBookId: state.selectedBookId,<EOL>            });<EOL>        }<EOL>        case BookActionTypes.Select: {<EOL>            return {<EOL>                ...state,<EOL>","gt":"selectedBookId: action.payload,"}
{"input":"<s> export function routerReducer<T = RouterStateSnapshot>(state: RouterReducerState<T>, action: RouterAction<any, T>): RouterReducerState<T> {<EOL>    switch (action.type) {<EOL>        case ROUTER_NAVIGATION:<EOL>        case ROUTER_ERROR:<EOL>        case","gt":"ROUTER_CANCEL:"}
{"input":"<s> export function routerReducer<T = RouterStateSnapshot>(state: RouterReducerState<T>, action: RouterAction<any, T>): RouterReducerState<T> {<EOL>    switch (action.type) {<EOL>        case ROUTER_NAVIGATION:<EOL>        case ROUTER_ERROR:<EOL>        case ROUTER_CANCEL:<EOL>            return {<EOL>                state: action.payload.routerState,<EOL>                navigationId: action.payload.event.id,<EOL>            };<EOL>","gt":"default:"}
{"input":"<s> export function provideRouterConnector(): {<EOL>    provide: any;<EOL>    deps: any[];<EOL>    useFactory: typeof setupRouterStore;<EOL>    multi: boolean;<EOL>} {<EOL>    return {<EOL>","gt":"provide: APP_BOOTSTRAP_LISTENER,"}
{"input":"<s> export function _createOptions(_options): StoreDevtoolsConfig {<EOL>    const DEFAULT_OPTIONS: StoreDevtoolsConfig = { monitor: noMonitor };<EOL>    let options: any = typeof _options === '<STR_LIT>' ? _options() : _options;<EOL>    options = Object.assign({},","gt":"DEFAULT_OPTIONS, options);"}
{"input":"<s> export function _createReduxDevtoolsExtension(): any {<EOL>    const legacyExtensionKey: string = '<STR_LIT>';<EOL>    const extensionKey: string = '<STR_LIT>';<EOL>    if (typeof window === '<STR_LIT>' && typeof window[legacyExtensionKey] !== '<STR_LIT>') {<EOL>        return window[","gt":"legacyExtensionKey];"}
{"input":"<s> export function _createReduxDevtoolsExtension(): any {<EOL>    const legacyExtensionKey: string = '<STR_LIT>';<EOL>    const extensionKey: string = '<STR_LIT>';<EOL>    if (typeof window === '<STR_LIT>' && typeof window[legacyExtensionKey] !== '<STR_LIT>') {<EOL>        return window[legacyExtensionKey];<EOL>    }<EOL>    else if (typeof window === '<STR_LIT>' && typeof window[extensionKey] !== '<STR_LIT>') {<EOL>        return window[extensionKey];<EOL>    }<EOL>","gt":"else {"}
{"input":"<s> <EOL>function recomputeStates(computedStates: any, minInvalidatedStateIndex: any, reducer: any, committedState: any, actionsById: any, stagedActionIds: any, skippedActionIds: any): any {<EOL>    <EOL>    <EOL>    if (minInvalidatedStateIndex >= computedStates.length &&<EOL>","gt":"computedStates.length === stagedActionIds.length) {"}
{"input":"<s> <EOL>function recomputeStates(computedStates: any, minInvalidatedStateIndex: any, reducer: any, committedState: any, actionsById: any, stagedActionIds: any, skippedActionIds: any): any {<EOL>    <EOL>    <EOL>    if (minInvalidatedStateIndex >= computedStates.length &&<EOL>        computedStates.length === stagedActionIds.length) {<EOL>        return computedStates;<EOL>    }<EOL>    const","gt":"nextComputedStates: any = computedStates.slice(<NUM_LIT>, minInvalidatedStateIndex);"}
{"input":"<s> <EOL>function recomputeStates(computedStates: any, minInvalidatedStateIndex: any, reducer: any, committedState: any, actionsById: any, stagedActionIds: any, skippedActionIds: any): any {<EOL>    <EOL>    <EOL>    if (minInvalidatedStateIndex >= computedStates.length &&<EOL>        computedStates.length === stagedActionIds.length) {<EOL>        return computedStates;<EOL>    }<EOL>    const nextComputedStates: any = computedStates.slice(<NUM_LIT>, minInvalidatedStateIndex);<EOL>    for (let i: any = minInvalidatedStateIndex; i < stagedActionIds.length; i++) {<EOL>        const actionId: any = stagedActionIds[i];<EOL>        const action: any = actionsById[actionId].action;<EOL>        const","gt":"previousEntry: any = nextComputedStates[i - <NUM_LIT>];"}
{"input":"<s> <EOL>function recomputeStates(computedStates: any, minInvalidatedStateIndex: any, reducer: any, committedState: any, actionsById: any, stagedActionIds: any, skippedActionIds: any): any {<EOL>    <EOL>    <EOL>    if (minInvalidatedStateIndex >= computedStates.length &&<EOL>        computedStates.length === stagedActionIds.length) {<EOL>        return computedStates;<EOL>    }<EOL>    const nextComputedStates: any = computedStates.slice(<NUM_LIT>, minInvalidatedStateIndex);<EOL>    for (let i: any = minInvalidatedStateIndex; i < stagedActionIds.length; i++) {<EOL>        const actionId: any = stagedActionIds[i];<EOL>        const action: any = actionsById[actionId].action;<EOL>        const previousEntry: any = nextComputedStates[i - <NUM_LIT>];<EOL>        const previousState: any = previousEntry ? previousEntry.state : committedState;<EOL>        const previousError: any = previousEntry ? previousEntry.error : undefined;<EOL>        const shouldSkip: boolean = skippedActionIds.indexOf(actionId) > -<NUM_LIT>;<EOL>        const entry: any = shouldSkip ?<EOL>","gt":"previousEntry :"}
{"input":"<s> export function bootstrapFactory(appRef: ApplicationRef, transferState: TransferState, request: express.Request, cache: CacheService): () => Subscription {<EOL>    return (): any => appRef.isStable<EOL>        .pipe(filter((stable: any): any => stable), first())<EOL>        .subscribe((): void => {<EOL>","gt":"transferState.set<any>(REQ_KEY, {"}
{"input":"<s> function add(...customEvents: string[]): void {<EOL>    customEvents.forEach((","gt":"event: string): Set<string> => events.add(event));"}
{"input":"<s> <EOL>export function extract(s: string): string {<EOL>    return","gt":"s;"}
{"input":"<s> function querySelector(s: any): any {<EOL>    return document.","gt":"querySelector(s);"}
{"input":"<s> export function controlLengthValidator(length: number): (control: FormControl) => {<EOL>    [key: string]: any;<EOL>} {<EOL>    return (control: FormControl): {<EOL>        [key: string]: any;<EOL>    } => {<EOL>        if (control.value && control.value.length !==","gt":"length) {"}
{"input":"<s> export function controlLengthValidator(length: number): (control: FormControl) => {<EOL>    [key: string]: any;<EOL>} {<EOL>    return (control: FormControl): {<EOL>        [key: string]: any;<EOL>    } => {<EOL>        if (control.value && control.value.length !== length) {<EOL>            return { validLength: { valid: false } };<EOL>        }<EOL>        else {<EOL>","gt":"return null;"}
{"input":"<s> <EOL>export function assertNoErrors(res: IResponse): IResponse {<EOL>    for (let i: number = <NUM_LIT>; i < res.results.length; i += <NUM_LIT>) {<EOL>        const { error } = res.results[i];<EOL>","gt":"if (error) {"}
{"input":"<s> function copyNodeModule(path: string, name: string): void {<EOL>    execSync(","gt":"}/node_modules/${name}`<STR_LIT>;"}
{"input":"<s> function updateMain(angularJsImport: string, options: Schema): Rule {<EOL>    return (host: Tree): Tree => {<EOL>        const { mainPath, moduleClassName, moduleSpec, bootstrapComponentClassName, bootstrapComponentFileName } = readBootstrapInfo(host, options.app);<EOL>","gt":"host.overwrite(mainPath,"}
{"input":"<s> export function addEntryComponents(source: ts.SourceFile, modulePath: string, symbolName: string): Change[] {<EOL>    return _addSymbolToNgModuleMetadata(source,","gt":"modulePath, '<STR_LIT>', symbolName);"}
{"input":"<s> export function readCliConfigFile(): any {<EOL>","gt":"return JSON.parse(fs.readFileSync('<STR_LIT>', '<STR_LIT>'));"}
{"input":"<s> export function wrapIntoFormat(fn: Function): any {<EOL>    return (host: Tree, context: SchematicContext): any => {<EOL>        context.addTask(new","gt":"FormatFiles());"}
{"input":"<s> function getPatternsFromApps(affectedFiles: string[]): string[] {<EOL>    const roots: string[] = getProjectRoots(getTouchedProjects(affectedFiles));<EOL>    if (roots.length === <NUM_LIT>) {<EOL>        return [];<EOL>    }<EOL>    else if (roots.length === <NUM_LIT>) {<EOL>        return [`<STR_LIT>`];<EOL>    }<EOL>","gt":"else {"}
{"input":"<s> function prettierPath(): any {<EOL>    const basePath: any = path.dirname(resolve.sync('<STR_LIT>', { basedir:","gt":"__dirname }));"}
{"input":"<s> export function localDataFactory(): () => LocalData {<EOL>","gt":"return (): LocalData => {"}
{"input":"<s> function _randWord(array: string[]): string {<EOL>    let index:","gt":"number = Math.floor(Math.random() * array.length);"}
{"input":"<s> function continuousPulseStepTwo(): IRawStyle {<EOL>    return {<EOL>        opacity:","gt":"'<STR_LIT>',"}
{"input":"<s> function _darken(hsl: {<EOL>    h: number;<EOL>    s: number;<EOL>    l: number;<EOL>}, factor: number): {<EOL>    h: number;<EOL>    s: number;<EOL>    l: number;<EOL>} {<EOL>    return {<EOL>","gt":"h: hsl.h,"}
{"input":"<s> <EOL>function getStartDateOfWeek(date: Date, firstDayOfWeek: DayOfWeek): Date {<EOL>    let daysOffset: number = firstDayOfWeek - date.getDay();<EOL>    if (","gt":"daysOffset > <NUM_LIT>) {"}
{"input":"<s> <EOL>export function getNextElement(rootElement: HTMLElement, currentElement: HTMLElement | null, checkNode?: boolean, suppressParentTraversal?: boolean, suppressChildTraversal?: boolean, includeElementsInFocusZones?: boolean, allowFocusRoot?: boolean): HTMLElement | null {<EOL>    if (!currentElement ||<EOL>        (currentElement === rootElement && suppressChildTraversal && !allowFocusRoot)) {<EOL>        return null;<EOL>    }<EOL>    let isCurrentElementVisible: boolean = isElementVisible(currentElement);<EOL>    <EOL>    if (checkNode && isCurrentElementVisible && isElementTabbable(currentElement)) {<EOL>        return currentElement;<EOL>    }<EOL>    <EOL>    if (!suppressChildTraversal && isCurrentElementVisible &&<EOL>        (includeElementsInFocusZones || !(isElementFocusZone(currentElement) ||","gt":"isElementFocusSubZone(currentElement)))) {"}
{"input":"<s> <EOL>export function getNextElement(rootElement: HTMLElement, currentElement: HTMLElement | null, checkNode?: boolean, suppressParentTraversal?: boolean, suppressChildTraversal?: boolean, includeElementsInFocusZones?: boolean, allowFocusRoot?: boolean): HTMLElement | null {<EOL>    if (!currentElement ||<EOL>        (currentElement === rootElement && suppressChildTraversal && !allowFocusRoot)) {<EOL>        return null;<EOL>    }<EOL>    let isCurrentElementVisible: boolean = isElementVisible(currentElement);<EOL>    <EOL>    if (checkNode && isCurrentElementVisible && isElementTabbable(currentElement)) {<EOL>        return currentElement;<EOL>    }<EOL>    <EOL>    if (!suppressChildTraversal && isCurrentElementVisible &&<EOL>        (includeElementsInFocusZones || !(isElementFocusZone(currentElement) || isElementFocusSubZone(currentElement)))) {<EOL>        const childMatch: HTMLElement | null = getNextElement(rootElement, currentElement.firstElementChild as HTMLElement, true, true, false, includeElementsInFocusZones, allowFocusRoot);<EOL>        if (childMatch) {<EOL>            return childMatch;<EOL>        }<EOL>    }<EOL>    if (currentElement === rootElement) {<EOL>        return null;<EOL>    }<EOL>    <EOL>    const siblingMatch: HTMLElement | null = getNextElement(rootElement, currentElement.nextElementSibling as HTMLElement, true, true, false, includeElementsInFocusZones,","gt":"allowFocusRoot);"}
{"input":"<s> <EOL>export function setMemoizeWeakMap(weakMap: any): void {<EOL>    _weakMap =","gt":"weakMap;"}
{"input":"<s> function truncateStringReverse(str: string, maxLength: number = <NUM_LIT>): any {<EOL>    const reversedString: any = toArray(","gt":"str).reverse().join('<STR_LIT>');"}
{"input":"<s> function updateState(self: any, state: any): void {<EOL>    each(Omni.viewModelStatefulProperties, (x: any): void => {<EOL>        if (","gt":"has(state, x)) {"}
{"input":"<s> export function sum<T>(arr: T[], selector: (item: T) => number): number {<EOL>    return arr.","gt":"reduce((prev: number, curr: T): number => prev + selector(curr), <NUM_LIT>);"}
{"input":"<s> export async function activate(thisExtension: vscode.Extension<any>, context: vscode.ExtensionContext, reporter: TelemetryReporter, logger: Logger, channel: vscode.OutputChannel): Promise<void> {<EOL>    _debugUtil = new CoreClrDebugUtil(context.extensionPath, logger);<EOL>    _logger = logger;<EOL>    if (!CoreClrDebugUtil.existsSync(_debugUtil.","gt":"debugAdapterDir())) {"}
{"input":"<s> export async function activate(thisExtension: vscode.Extension<any>, context: vscode.ExtensionContext, reporter: TelemetryReporter, logger: Logger, channel: vscode.OutputChannel): Promise<void> {<EOL>    _debugUtil = new CoreClrDebugUtil(context.extensionPath, logger);<EOL>    _logger = logger;<EOL>    if (!CoreClrDebugUtil.existsSync(_debugUtil.debugAdapterDir())) {<EOL>        let platformInformation: PlatformInformation;<EOL>        try {<EOL>            platformInformation = await PlatformInformation.","gt":"GetCurrent();"}
{"input":"<s> export async function activate(thisExtension: vscode.Extension<any>, context: vscode.ExtensionContext, reporter: TelemetryReporter, logger: Logger, channel: vscode.OutputChannel): Promise<void> {<EOL>    _debugUtil = new CoreClrDebugUtil(context.extensionPath, logger);<EOL>    _logger = logger;<EOL>    if (!CoreClrDebugUtil.existsSync(_debugUtil.debugAdapterDir())) {<EOL>        let platformInformation: PlatformInformation;<EOL>        try {<EOL>            platformInformation = await PlatformInformation.GetCurrent();<EOL>        }<EOL>        catch (err: any) {<EOL>            <EOL>            logger.appendLine(","gt":"\"<STR_LIT>\");"}
{"input":"<s> export async function activate(thisExtension: vscode.Extension<any>, context: vscode.ExtensionContext, reporter: TelemetryReporter, logger: Logger, channel: vscode.OutputChannel): Promise<void> {<EOL>    _debugUtil = new CoreClrDebugUtil(context.extensionPath, logger);<EOL>    _logger = logger;<EOL>    if (!CoreClrDebugUtil.existsSync(_debugUtil.debugAdapterDir())) {<EOL>        let platformInformation: PlatformInformation;<EOL>        try {<EOL>            platformInformation = await PlatformInformation.GetCurrent();<EOL>        }<EOL>        catch (err: any) {<EOL>            <EOL>            logger.appendLine(\"<STR_LIT>\");<EOL>            showInstallErrorMessage(channel);<EOL>        }<EOL>        if (","gt":"platformInformation) {"}
{"input":"<s> export async function activate(thisExtension: vscode.Extension<any>, context: vscode.ExtensionContext, reporter: TelemetryReporter, logger: Logger, channel: vscode.OutputChannel): Promise<void> {<EOL>    _debugUtil = new CoreClrDebugUtil(context.extensionPath, logger);<EOL>    _logger = logger;<EOL>    if (!CoreClrDebugUtil.existsSync(_debugUtil.debugAdapterDir())) {<EOL>        let platformInformation: PlatformInformation;<EOL>        try {<EOL>            platformInformation = await PlatformInformation.GetCurrent();<EOL>        }<EOL>        catch (err: any) {<EOL>            <EOL>            logger.appendLine(\"<STR_LIT>\");<EOL>            showInstallErrorMessage(channel);<EOL>        }<EOL>        if (platformInformation) {<EOL>            if (platformInformation.architecture !== \"<STR_LIT>\") {<EOL>                if (platformInformation.isWindows() && platformInformation.architecture === \"<STR_LIT>\") {<EOL>                    logger.appendLine(`<STR_LIT>`);<EOL>                }<EOL>                else {<EOL>                    logger.appendLine(`<STR_LIT>`);<EOL>                }<EOL>            }<EOL>            else {<EOL>","gt":"logger.appendLine(\"<STR_LIT>\");"}
{"input":"<s> async function completeDebuggerInstall(logger: Logger, channel: vscode.OutputChannel): Promise<boolean> {<EOL>    return _debugUtil.checkDotNetCli()<EOL>        .then((dotnetInfo: DotnetInfo): boolean => {<EOL>        if (os.platform() === \"<STR_LIT>\" && !CoreClrDebugUtil.isMacOSSupported()) {<EOL>            logger.appendLine(\"<STR_LIT>\");<EOL>            channel.show();<EOL>            return","gt":"false;"}
{"input":"<s> async function completeDebuggerInstall(logger: Logger, channel: vscode.OutputChannel): Promise<boolean> {<EOL>    return _debugUtil.checkDotNetCli()<EOL>        .then((dotnetInfo: DotnetInfo): boolean => {<EOL>        if (os.platform() === \"<STR_LIT>\" && !CoreClrDebugUtil.isMacOSSupported()) {<EOL>            logger.appendLine(\"<STR_LIT>\");<EOL>            channel.show();<EOL>            return false;<EOL>        }<EOL>        <EOL>        CoreClrDebugUtil.writeEmptyFile(_debugUtil.installCompleteFilePath());<EOL>        vscode.window.setStatusBarMessage('<STR_LIT>', <NUM_LIT>);<EOL>","gt":"return true;"}
{"input":"<s> async function completeDebuggerInstall(logger: Logger, channel: vscode.OutputChannel): Promise<boolean> {<EOL>    return _debugUtil.checkDotNetCli()<EOL>        .then((dotnetInfo: DotnetInfo): boolean => {<EOL>        if (os.platform() === \"<STR_LIT>\" && !CoreClrDebugUtil.isMacOSSupported()) {<EOL>            logger.appendLine(\"<STR_LIT>\");<EOL>            channel.show();<EOL>            return false;<EOL>        }<EOL>        <EOL>        CoreClrDebugUtil.writeEmptyFile(_debugUtil.installCompleteFilePath());<EOL>        vscode.window.setStatusBarMessage('<STR_LIT>', <NUM_LIT>);<EOL>        return true;<EOL>    }, (err: any): boolean => {<EOL>        <EOL>        <EOL>        showDotnetToolsWarning(","gt":"err.ErrorMessage || _debugUtil.defaultDotNetCliErrorMessage());"}
{"input":"<s> <EOL><EOL><EOL>function GetSysNativePathIfNeeded(): Promise<any> {<EOL>    return PlatformInformation.GetCurrent().then((platformInfo: PlatformInformation): any => {<EOL>        let env: any = process.env;<EOL>        if (platformInfo.isWindows() && platformInfo.","gt":"architecture === \"<STR_LIT>\") {"}
{"input":"<s> export function findExecutableProjectJsonProjects(projects: DotNetProject[], configurationName: string): DotNetProject[] {<EOL>    let result: DotNetProject[] = [];<EOL>    projects.forEach((project: DotNetProject): void => {<EOL>        project.Configurations.forEach((configuration: DotNetConfiguration): void => {<EOL>            if (configuration.Name === configurationName && configuration.EmitEntryPoint ===","gt":"true) {"}
{"input":"<s> export function serializeAppConfig(config: AppConfig): object {<EOL>    return {<EOL>        appId: config.appId.serialize(),<EOL>        subdomain: config.subdomain,<EOL>","gt":"httpUseOneSignalCom: config.httpUseOneSignalCom,"}
{"input":"<s> export function serializeAppConfig(config: AppConfig): object {<EOL>    return {<EOL>        appId: config.appId.serialize(),<EOL>        subdomain: config.subdomain,<EOL>        httpUseOneSignalCom: config.httpUseOneSignalCom,<EOL>        cookieSyncEnabled: config.cookieSyncEnabled,<EOL>        safariWebId: config.safariWebId,<EOL>        vapidPublicKey: config.vapidPublicKey,<EOL>        emailAuthRequired:","gt":"config.emailAuthRequired,"}
{"input":"<s> export function logMethodCall(methodName: string, ...args: any[]): any {<EOL>    return log.debug(","gt":"join('<STR_LIT>')})`<STR_LIT>;"}
{"input":"<s> <EOL>export function trimUndefined(object: any): any {<EOL>    for (var property: string in object) {<EOL>        if (object.hasOwnProperty(property)) {<EOL>            if (object[","gt":"property] === undefined) {"}
{"input":"<s> export function setConfigValue<K extends keyof IConfigurationValues>(k: K, v: IConfigurationValues[K]): ISetConfigurationValue<K> {<EOL>    return {<EOL>        type: \"<STR_LIT>\",<EOL>","gt":"payload: {"}
{"input":"<s> <EOL>export function nodeRequire(moduleName: string): any {<EOL>    return window[\"<STR_LIT>\"](","gt":"moduleName);"}
{"input":"<s> function updateMenu(browserWindow: any, loadInit: any): void {<EOL>    const menu: any = buildMenu(browserWindow, loadInit);<EOL>    if (process.platform === \"<STR_LIT>\") {<EOL>        <EOL>","gt":"Menu.setApplicationMenu(menu);"}
{"input":"<s> <EOL><EOL>export function initialize(): void {<EOL>    tracer =","gt":"new Tracer();"}
{"input":"<s> function parseSortSpecifier(sortSpecifier: SortSpecifier | string): SortSpecifier {<EOL>    if (isObject(sortSpecifier)) {<EOL>        let s: SortSpecifier = sortSpecifier as SortSpecifier;<EOL>        s.kind = s.kind || '<STR_LIT>';<EOL>        s.","gt":"order = s.order || '<STR_LIT>';"}
{"input":"<s> function parseSortSpecifier(sortSpecifier: SortSpecifier | string): SortSpecifier {<EOL>    if (isObject(sortSpecifier)) {<EOL>        let s: SortSpecifier = sortSpecifier as SortSpecifier;<EOL>        s.kind = s.kind || '<STR_LIT>';<EOL>        s.order = s.order || '<STR_LIT>';<EOL>        return s;<EOL>    }<EOL>    else if (typeof sortSpecifier === '<STR_LIT>') {<EOL>        return","gt":"parseSortSpecifierString(sortSpecifier);"}
{"input":"<s> function parseSortSpecifierString(sortSpecifier: string): AttributeSortSpecifier {<EOL>    let attribute: any;<EOL>    let order: any;<EOL>    if (sortSpecifier[<NUM_LIT>] === '<STR_LIT>') {<EOL>        attribute = sortSpecifier.slice(<NUM_LIT>);<EOL>        order =","gt":"'<STR_LIT>';"}
{"input":"<s> function parseSortSpecifierString(sortSpecifier: string): AttributeSortSpecifier {<EOL>    let attribute: any;<EOL>    let order: any;<EOL>    if (sortSpecifier[<NUM_LIT>] === '<STR_LIT>') {<EOL>        attribute = sortSpecifier.slice(<NUM_LIT>);<EOL>        order = '<STR_LIT>';<EOL>    }<EOL>    else {<EOL>        attribute = sortSpecifier;<EOL>","gt":"order = '<STR_LIT>';"}
{"input":"<s> function parseSortSpecifierString(sortSpecifier: string): AttributeSortSpecifier {<EOL>    let attribute: any;<EOL>    let order: any;<EOL>    if (sortSpecifier[<NUM_LIT>] === '<STR_LIT>') {<EOL>        attribute = sortSpecifier.slice(<NUM_LIT>);<EOL>        order = '<STR_LIT>';<EOL>    }<EOL>    else {<EOL>        attribute = sortSpecifier;<EOL>        order = '<STR_LIT>';<EOL>    }<EOL>    return {<EOL>","gt":"kind: '<STR_LIT>',"}
{"input":"<s> <EOL>function get(key: any, map: any): any {<EOL>    return tryGetHash(undefined, map._config.hash(","gt":"key), key, map);"}
{"input":"<s> <EOL>function remove(key: any, map: any): any {<EOL>    return removeHash(map._config.","gt":"hash(key), key, map);"}
{"input":"<s> function values(map: any): HAMTMapIterator<unknown> {<EOL>    return visit(map,","gt":"buildValues);"}
{"input":"<s> <EOL>export function capitalize(str: string): string {<EOL>    return str.charAt(<NUM_LIT>).","gt":"toUpperCase() + str.slice(<NUM_LIT>);"}
{"input":"<s> export function extractThumbUrl(media: any): string {<EOL>    return extractThumbnail(getSnippet(","gt":"media));"}
{"input":"<s> export function updateTriggeredFlag(scroll: any, scrollState: IScrollState, triggered: boolean, isScrollingDown: boolean): void {<EOL>    if (isScrollingDown) {<EOL>        scrollState.","gt":"triggered.down = scroll;"}
{"input":"<s> function setPremove(state: State, orig: cg.Key, dest: cg.Key, meta: cg.SetPremoveMetadata): void {<EOL>","gt":"unsetPredrop(state);"}
{"input":"<s> export function toggleOrientation(state: State): void {<EOL>    state.orientation = opposite(state.orientation);<EOL>    state.animation.","gt":"current ="}
{"input":"<s> function renderCircle(brush: DrawBrush, pos: cg.Pos, current: boolean, bounds: ClientRect): SVGElement {<EOL>    const o: cg.NumberPair = pos2px(pos, bounds), widths: [<EOL>        number,<EOL>        number<EOL>    ] = circleWidth(bounds), radius: number = (bounds.width +","gt":"bounds.height) / <NUM_LIT>;"}
{"input":"<s> function renderCircle(brush: DrawBrush, pos: cg.Pos, current: boolean, bounds: ClientRect): SVGElement {<EOL>    const o: cg.NumberPair = pos2px(pos, bounds), widths: [<EOL>        number,<EOL>        number<EOL>    ] = circleWidth(bounds), radius: number = (bounds.width + bounds.height) / <NUM_LIT>;<EOL>    return setAttributes(createElement('<STR_LIT>'), {<EOL>        stroke: brush.color,<EOL>        '<STR_LIT>': widths[current ? <NUM_LIT> : <NUM_LIT>],<EOL>        fill: '<STR_LIT>',<EOL>        opacity: opacity(brush, current),<EOL>","gt":"cx: o[<NUM_LIT>],"}
{"input":"<s> function renderShape(state: State, { shape, current, hash }: Shape, brushes: DrawBrushes, arrowDests: ArrowDests, bounds: ClientRect): SVGElement {<EOL>    let el: SVGElement;<EOL>    if (shape.piece)<EOL>        el = renderPiece(state.drawable.pieces.baseUrl, orient(key2pos(shape.orig), state.orientation), shape.piece, bounds);<EOL>    else {<EOL>        const orig:","gt":"cg.Pos = orient(key2pos(shape.orig), state.orientation);"}
{"input":"<s> function renderShape(state: State, { shape, current, hash }: Shape, brushes: DrawBrushes, arrowDests: ArrowDests, bounds: ClientRect): SVGElement {<EOL>    let el: SVGElement;<EOL>    if (shape.piece)<EOL>        el = renderPiece(state.drawable.pieces.baseUrl, orient(key2pos(shape.orig), state.orientation), shape.piece, bounds);<EOL>    else {<EOL>        const orig: cg.Pos = orient(key2pos(shape.orig), state.orientation);<EOL>        if (shape.orig && shape.dest) {<EOL>            let brush: DrawBrush = brushes[shape.brush];<EOL>            if (shape.modifiers)<EOL>","gt":"brush = makeCustomBrush(brush, shape.modifiers);"}
{"input":"<s> function renderShape(state: State, { shape, current, hash }: Shape, brushes: DrawBrushes, arrowDests: ArrowDests, bounds: ClientRect): SVGElement {<EOL>    let el: SVGElement;<EOL>    if (shape.piece)<EOL>        el = renderPiece(state.drawable.pieces.baseUrl, orient(key2pos(shape.orig), state.orientation), shape.piece, bounds);<EOL>    else {<EOL>        const orig: cg.Pos = orient(key2pos(shape.orig), state.orientation);<EOL>        if (shape.orig && shape.dest) {<EOL>            let brush: DrawBrush = brushes[shape.brush];<EOL>            if (shape.modifiers)<EOL>                brush = makeCustomBrush(brush, shape.modifiers);<EOL>            el = renderArrow(brush, orig, orient(key2pos(shape.dest), state.orientation), current, arrowDests[shape.dest] > <NUM_LIT>, bounds);<EOL>        }<EOL>        else<EOL>            el = renderCircle(brushes[shape.","gt":"brush], orig, current, bounds);"}
{"input":"<s> function renderCoords(elems: any[], className: string): HTMLElement {<EOL>    const el: HTMLElement = createEl('<STR_LIT>', className);<EOL>    let f: HTMLElement;<EOL>    for (","gt":"let i: string in elems) {"}
{"input":"<s> <EOL>export function ipv6Address(ip?: string): {<EOL>    data: {<EOL>        generate: string;<EOL>        matcher: {<EOL>            json_class: string;<EOL>            o: number;<EOL>            s: string;<EOL>        };<EOL>    };<EOL>    json_class: string;<EOL>} {<EOL>    return term({<EOL>        generate: ip ||","gt":"\"<STR_LIT>\","}
{"input":"<s> <EOL>export function iso8601Date(date?: string): {<EOL>    data: {<EOL>        generate: string;<EOL>        matcher: {<EOL>            json_class: string;<EOL>            o: number;<EOL>            s: string;<EOL>        };<EOL>    };<EOL>    json_class: string;<EOL>} {<EOL>    return term({<EOL>","gt":"generate: date || \"<STR_LIT>\","}
{"input":"<s> export function trainingLog(message: string): void {<EOL>","gt":"messageElement.innerText = `<STR_LIT>`;"}
{"input":"<s> function convertZScale(z: number): number {<EOL>    return (","gt":"<NUM_LIT> - z);"}
{"input":"<s> function runHTML(): void {<EOL>","gt":"iframeElement.contentWindow.postMessage(JSON.stringify({ '<STR_LIT>': htmlEditor.getValue() }), '<STR_LIT>');"}
{"input":"<s> export function assertDayHidden(day: ReactWrapper<any, any>, expectHidden: boolean = true): void {<EOL>","gt":"assert.equal(isDayHidden(day), expectHidden);"}
{"input":"<s> export function expectCellLoading(cell: Element, cellType: CellType, loading: boolean = true): void {<EOL>    if (loading) {<EOL>        expect(cell.classList.contains(CoreClasses.LOADING)).to.be.true;<EOL>        expect(cell.querySelector(`<STR_LIT>`)).to.not.be.null;<EOL>        if (cellType !== CellType.BODY_CELL) {<EOL>            const headerNameText: Element = cellType === CellType.COLUMN_HEADER<EOL>                ? cell.","gt":"querySelector(`<STR_LIT>`)"}
{"input":"<s> <EOL>export function multiTime(): (d: any) => any {<EOL>    <EOL>    <EOL>    const candidateFormats: IPredicatedFormat[] = [<EOL>        {<EOL>","gt":"specifier: \"<STR_LIT>\","}
{"input":"<s> <EOL>export function multiTime(): (d: any) => any {<EOL>    <EOL>    <EOL>    const candidateFormats: IPredicatedFormat[] = [<EOL>        {<EOL>            specifier: \"<STR_LIT>\",<EOL>            predicate: (d: Date): boolean => d.getMilliseconds() !== <NUM_LIT>,<EOL>        },<EOL>        {<EOL>            specifier: \"<STR_LIT>\",<EOL>            predicate: (d: Date): boolean => d.getSeconds() !== <NUM_LIT>,<EOL>        },<EOL>        {<EOL>            specifier: \"<STR_LIT>\",<EOL>            predicate: (d: Date): boolean => d.getMinutes() !== <NUM_LIT>,<EOL>        },<EOL>        {<EOL>","gt":"specifier: \"<STR_LIT>\","}
{"input":"<s> <EOL>export function multiTime(): (d: any) => any {<EOL>    <EOL>    <EOL>    const candidateFormats: IPredicatedFormat[] = [<EOL>        {<EOL>            specifier: \"<STR_LIT>\",<EOL>            predicate: (d: Date): boolean => d.getMilliseconds() !== <NUM_LIT>,<EOL>        },<EOL>        {<EOL>            specifier: \"<STR_LIT>\",<EOL>            predicate: (d: Date): boolean => d.getSeconds() !== <NUM_LIT>,<EOL>        },<EOL>        {<EOL>            specifier: \"<STR_LIT>\",<EOL>            predicate: (d: Date): boolean => d.getMinutes() !== <NUM_LIT>,<EOL>        },<EOL>        {<EOL>            specifier: \"<STR_LIT>\",<EOL>            predicate: (d: Date): boolean => d.getHours() !== <NUM_LIT>,<EOL>        },<EOL>        {<EOL>","gt":"specifier: \"<STR_LIT>\","}
{"input":"<s> <EOL>export function multiTime(): (d: any) => any {<EOL>    <EOL>    <EOL>    const candidateFormats: IPredicatedFormat[] = [<EOL>        {<EOL>            specifier: \"<STR_LIT>\",<EOL>            predicate: (d: Date): boolean => d.getMilliseconds() !== <NUM_LIT>,<EOL>        },<EOL>        {<EOL>            specifier: \"<STR_LIT>\",<EOL>            predicate: (d: Date): boolean => d.getSeconds() !== <NUM_LIT>,<EOL>        },<EOL>        {<EOL>            specifier: \"<STR_LIT>\",<EOL>            predicate: (d: Date): boolean => d.getMinutes() !== <NUM_LIT>,<EOL>        },<EOL>        {<EOL>            specifier: \"<STR_LIT>\",<EOL>            predicate: (d: Date): boolean => d.getHours() !== <NUM_LIT>,<EOL>        },<EOL>        {<EOL>            specifier: \"<STR_LIT>\",<EOL>            predicate: (d: Date): boolean => d.getDay() !== <NUM_LIT> && d.getDate() !== <NUM_LIT>,<EOL>        },<EOL>        {<EOL>            specifier: \"<STR_LIT>\",<EOL>            predicate: (d: Date): boolean => d.getDate() !== <NUM_LIT>,<EOL>        },<EOL>        {<EOL>            specifier: \"<STR_LIT>\",<EOL>            predicate: (d: Date): boolean =>","gt":"d.getMonth() !== <NUM_LIT>,"}
{"input":"<s> <EOL>export function time(specifier: string, useUTC: boolean = DEFAULT_USE_UTC): Formatter {<EOL>    if (useUTC) {<EOL>        return d3.utcFormat(","gt":"specifier);"}
{"input":"<s> export function square(): SymbolFactory {<EOL>    return (","gt":"symbolSize: number): any => {"}
{"input":"<s> export function resolveAttributes(projector: AttributeToAppliedProjector, attrKeys: string[], datum: any, index: number): Record<string, any> {<EOL>    const attrs: Record<string, any> = {};<EOL>    for (const attrKey: string of attrKeys) {<EOL>        if (projector.","gt":"hasOwnProperty(attrKey)) {"}
{"input":"<s> function squareOverlapsBounds(width: number, height: number, x: number, y: number, size: number): boolean {<EOL>","gt":"return (x + size >= <NUM_LIT> && x - size <= width &&"}
{"input":"<s> export function signRef(a: any): ReferenceSignature {<EOL>    return","gt":"new ReferenceSignature(a);"}
{"input":"<s> <EOL>export function integerTickGenerator(): ITickGenerator<number> {<EOL>    return function (s: QuantitativeScale<number>) {<EOL>        const defaultTicks:","gt":"number[] = s.defaultTicks();"}
{"input":"<s> function attrsObject$1(transition: any, map: any): any {<EOL>    for (const","gt":"name: string in map)"}
{"input":"<s> export function entityBounds(element: Element): IEntityBounds {<EOL>    if (element instanceof SVGElement) {<EOL>        return elementBBox(d3.select(element));<EOL>    }<EOL>    else if (","gt":"element instanceof HTMLElement) {"}
{"input":"<s> export function entityBounds(element: Element): IEntityBounds {<EOL>    if (element instanceof SVGElement) {<EOL>        return elementBBox(d3.select(element));<EOL>    }<EOL>    else if (element instanceof HTMLElement) {<EOL>        const rect: DOMRect = element.getBoundingClientRect();<EOL>        return { x: rect.left, y: rect.top, width: rect.width, height: rect.height };<EOL>    }<EOL>","gt":"else {"}
{"input":"<s> <EOL>function _parseRange(input: number | Range): Range {<EOL>    if (typeof (input) === \"<STR_LIT>\") {<EOL>        const value: number = <number>input;<EOL>        return {","gt":"min: value, max: value };"}
{"input":"<s> <EOL>export function inRange(x: number, a: number, b: number): boolean {<EOL>    return (nativeMath.min(a, b) <= x && x <= nativeMath.","gt":"max(a, b));"}
{"input":"<s> function hasKeyProp(attributes: ts.JsxAttributes): boolean {<EOL>    return","gt":"attributes.properties"}
{"input":"<s> function buildDocumentationDataFile(documentation: IDocumentation, metadataJson: any[]): void {<EOL>","gt":"const dataJson: string = JSON.stringify(metadataJson, undefined, <NUM_LIT>);"}
{"input":"<s> function isRule(ruleName: string): boolean {<EOL>    let result: boolean = cache.get(ruleName);<EOL>    if (result ===","gt":"undefined) {"}
{"input":"<s> function everyRule(): string[] {<EOL>    return fs.readdirSync(srcRulesDir)<EOL>        .filter((","gt":"file: any): boolean => /Rule.ts$/.test(file))"}
{"input":"<s> <EOL>export function HttpLoaderFactory(http: Http): any {<EOL>    return new","gt":"TranslateHttpLoader(http, '<STR_LIT>', '<STR_LIT>');"}
{"input":"<s> <EOL>export function testIterator<T>(factory: IteratorFactory<T>): void {<EOL>    describe('<STR_LIT>', (): void => {<EOL>        it('<STR_LIT>', (): void => {<EOL>            let [it] = factory();<EOL>            expect(it.iter()).to.equal(it);<EOL>        });<EOL>    });<EOL>    describe('<STR_LIT>', (): void => {<EOL>        it(","gt":"'<STR_LIT>', (): void => {"}
{"input":"<s> <EOL>export function testIterator<T>(factory: IteratorFactory<T>): void {<EOL>    describe('<STR_LIT>', (): void => {<EOL>        it('<STR_LIT>', (): void => {<EOL>            let [it] = factory();<EOL>            expect(it.iter()).to.equal(it);<EOL>        });<EOL>    });<EOL>    describe('<STR_LIT>', (): void => {<EOL>        it('<STR_LIT>', (): void => {<EOL>            let [it, results] = factory();<EOL>            let it2: any = it.clone();<EOL>            expect(it).to.not.equal(it2);<EOL>            expect(toArray(it)).to.deep.equal(results);<EOL>            expect(toArray(it2)).to.","gt":"deep.equal(results);"}
{"input":"<s> <EOL>export function testIterator<T>(factory: IteratorFactory<T>): void {<EOL>    describe('<STR_LIT>', (): void => {<EOL>        it('<STR_LIT>', (): void => {<EOL>            let [it] = factory();<EOL>            expect(it.iter()).to.equal(it);<EOL>        });<EOL>    });<EOL>    describe('<STR_LIT>', (): void => {<EOL>        it('<STR_LIT>', (): void => {<EOL>            let [it, results] = factory();<EOL>            let it2: any = it.clone();<EOL>            expect(it).to.not.equal(it2);<EOL>            expect(toArray(it)).to.deep.equal(results);<EOL>            expect(toArray(it2)).to.deep.equal(results);<EOL>        });<EOL>    });<EOL>    describe('<STR_LIT>', (): void => {<EOL>        it('<STR_LIT>', (): void => {<EOL>            let value: T | undefined;<EOL>            let [","gt":"it, results] = factory();"}
{"input":"<s> function doneCb(status: number): void {<EOL>    process.exit(","gt":"status);"}
{"input":"<s> <EOL>export default function getGlobalRequire(): Function {<EOL>    const reqVar: any = eval('<STR_LIT>');<EOL>    return reqVar ? reqVar :","gt":"function (moduleName: string): any {"}
{"input":"<s> <EOL>export function arraycopyNoCheck(src: JVMTypes.JVMArray<any>, srcPos: number, dest: JVMTypes.JVMArray<any>, destPos: number, length: number): void {<EOL>    var j: number = destPos;<EOL>    var end: number = srcPos +","gt":"length;"}
{"input":"<s> <EOL>async function createServer(app: express.Application, options: ServerOptions): Promise<http.Server> {<EOL>    const opt: any = { spdy: { protocols: [options.protocol] } };<EOL>    if (isHttps(options.protocol)) {<EOL>        const keys: import(\"<STR_LIT>\").KeyAndCert = await getTLSCertificate(options.keyPath, options.certPath);<EOL>        opt.","gt":"key = keys.key;"}
{"input":"<s> <EOL>async function createServer(app: express.Application, options: ServerOptions): Promise<http.Server> {<EOL>    const opt: any = { spdy: { protocols: [options.protocol] } };<EOL>    if (isHttps(options.protocol)) {<EOL>        const keys: import(\"<STR_LIT>\").KeyAndCert = await getTLSCertificate(options.keyPath, options.certPath);<EOL>        opt.key = keys.key;<EOL>        opt.cert = keys.cert;<EOL>    }<EOL>    else {<EOL>        opt.spdy.plain = true;<EOL>","gt":"opt.spdy.ssl = false;"}
{"input":"<s> export async function run(_env: any, args: string[], output: NodeJS.WritableStream): Promise<void> {<EOL>    await wrapResult(output, _run(","gt":"args, output));"}
{"input":"<s> <EOL>export async function parseArgs(context: Context, args: string[]): Promise<void> {<EOL>    const parser: any = nomnom();<EOL>    parser.script('<STR_LIT>');<EOL>    parser.options(<any>ARG_CONFIG);<EOL>    const plugins: Plugin[] = await context.","gt":"plugins();"}
{"input":"<s> <EOL>export async function parseArgs(context: Context, args: string[]): Promise<void> {<EOL>    const parser: any = nomnom();<EOL>    parser.script('<STR_LIT>');<EOL>    parser.options(<any>ARG_CONFIG);<EOL>    const plugins: Plugin[] = await context.plugins();<EOL>    plugins.forEach(_configurePluginOptions.bind(null, parser));<EOL>    const options: any = <any>_expandOptionPaths(normalize(parser.parse(args)));<EOL>    if (options._ && options._.length > <NUM_LIT>) {<EOL>","gt":"options.suites = options._;"}
{"input":"<s> export function init(gulp: Gulp, dependencies?: string[]): void {<EOL>    if (!dependencies) {<EOL>        dependencies = [];<EOL>    }<EOL>    <EOL>","gt":"gulp.task('<STR_LIT>', ['<STR_LIT>']);"}
{"input":"<s> <EOL>export async function setupOverrides(context: Context): Promise<void> {<EOL>    if (context.","gt":"options.registerHooks) {"}
{"input":"<s> function runIntegrationSuiteForDir(dirname: string, options: config.Config, skip: boolean): void {<EOL>    runsIntegrationSuite(dirname, options, skip, function (testResults) {<EOL>        const golden: Golden = JSON.parse(fs.readFileSync(path.join(integrationDir, dirname, '<STR_LIT>'), '<STR_LIT>'));<EOL>        let variantsGolden: VariantsGolden;<EOL>        if (isVariantsGolden(golden)) {<EOL>            variantsGolden =","gt":"golden;"}
{"input":"<s> function runIntegrationSuiteForDir(dirname: string, options: config.Config, skip: boolean): void {<EOL>    runsIntegrationSuite(dirname, options, skip, function (testResults) {<EOL>        const golden: Golden = JSON.parse(fs.readFileSync(path.join(integrationDir, dirname, '<STR_LIT>'), '<STR_LIT>'));<EOL>        let variantsGolden: VariantsGolden;<EOL>        if (isVariantsGolden(golden)) {<EOL>            variantsGolden = golden;<EOL>        }<EOL>        else {<EOL>","gt":"variantsGolden = { variants: { '<STR_LIT>': golden } };"}
{"input":"<s> <EOL>export function setUsedModule(module: string, version: string, bundled: boolean): void {<EOL>    prettierInformation =","gt":"'<STR_LIT>' : '<STR_LIT>'}`<STR_LIT>;"}
{"input":"<s> function toggleStatusBarItem(editor: TextEditor | undefined): void {<EOL>    if (editor !== undefined) {<EOL>        <EOL>        <EOL>        <EOL>        <EOL>        if (['<STR_LIT>', '<STR_LIT>'].some((part: string): boolean => editor.document.uri.scheme === part)) {<EOL>            return;<EOL>        }<EOL>        const score: any = languages.match(allEnabledLanguages(),","gt":"editor.document);"}
{"input":"<s> function toggleStatusBarItem(editor: TextEditor | undefined): void {<EOL>    if (editor !== undefined) {<EOL>        <EOL>        <EOL>        <EOL>        <EOL>        if (['<STR_LIT>', '<STR_LIT>'].some((part: string): boolean => editor.document.uri.scheme === part)) {<EOL>            return;<EOL>        }<EOL>        const score: any = languages.match(allEnabledLanguages(), editor.document);<EOL>        if (score > <NUM_LIT>) {<EOL>            statusBarItem.show();<EOL>        }<EOL>","gt":"else {"}
{"input":"<s> <EOL>function selectorsCreator(wf: WorkspaceFolder): {<EOL>    languageSelector: DocumentFilter[];<EOL>    rangeLanguageSelector: DocumentFilter[];<EOL>} {<EOL>    const allLanguages: string[] = allEnabledLanguages();<EOL>    const allRangeLanguages: string[] = allJSLanguages();<EOL>    const { disableLanguages } = getConfig(wf.uri);<EOL>    const relativePattern: any = new RelativePattern(","gt":"wf, '<STR_LIT>');"}
{"input":"<s> function distributeGraph(model: any): any {<EOL>    let nodes: any = mapElements(model);<EOL>    let edges: any = mapEdges(model);<EOL>    let graph: any = new dagre.graphlib.Graph();<EOL>    graph.setGraph({});<EOL>    graph.setDefaultEdgeLabel(function () {<EOL>","gt":"return {};"}
{"input":"<s> <EOL>export function execTask(binPath: string, args: string[], options: ExecTaskOptions = {}): (done: (err?: string) => void) => void {<EOL>    return (done: (err?: string) => void): void => {<EOL>        const childProcess: any = child_process.spawn(binPath, args);<EOL>        if (!options.silent) {<EOL>            childProcess.stdout.on('<STR_LIT>', (data: string): void => {<EOL>","gt":"process.stdout.write(data);"}
{"input":"<s> <EOL>export function execTask(binPath: string, args: string[], options: ExecTaskOptions = {}): (done: (err?: string) => void) => void {<EOL>    return (done: (err?: string) => void): void => {<EOL>        const childProcess: any = child_process.spawn(binPath, args);<EOL>        if (!options.silent) {<EOL>            childProcess.stdout.on('<STR_LIT>', (data: string): void => {<EOL>                process.stdout.write(data);<EOL>            });<EOL>            childProcess.stderr.on('<STR_LIT>', (data: string): void => {<EOL>                process.stderr.","gt":"write(data);"}
{"input":"<s> <EOL>export function execTask(binPath: string, args: string[], options: ExecTaskOptions = {}): (done: (err?: string) => void) => void {<EOL>    return (done: (err?: string) => void): void => {<EOL>        const childProcess: any = child_process.spawn(binPath, args);<EOL>        if (!options.silent) {<EOL>            childProcess.stdout.on('<STR_LIT>', (data: string): void => {<EOL>                process.stdout.write(data);<EOL>            });<EOL>            childProcess.stderr.on('<STR_LIT>', (data: string): void => {<EOL>                process.stderr.write(data);<EOL>            });<EOL>        }<EOL>        childProcess.on('<STR_LIT>', (code: number): void => {<EOL>            if (code != <NUM_LIT>) {<EOL>                if (options.errMessage ===","gt":"undefined) {"}
{"input":"<s> <EOL>export function serverTask(livereload: boolean = true): () => void {<EOL>    return (): void => {<EOL>        gulpConnect.server({<EOL>","gt":"root: '<STR_LIT>',"}
{"input":"<s> export function userReducer(state = initialState, action: UserActions): UserState {<EOL>    switch (action.type) {<EOL>        case UserActionTypes.EditUser: {<EOL>            return {<EOL>                ...","gt":"state,"}
{"input":"<s> export function userReducer(state = initialState, action: UserActions): UserState {<EOL>    switch (action.type) {<EOL>        case UserActionTypes.EditUser: {<EOL>            return {<EOL>                ...state,<EOL>                user: action.payload<EOL>            };<EOL>        }<EOL>        default: {<EOL>            return","gt":"state;"}
{"input":"<s> export function Deal(value: string): string {<EOL>    let title: string = value;<EOL>    for (","gt":"let rp: regReplace of regs) {"}
{"input":"<s> async function getFileList(para?): Promise<FileAndFormat[]> {<EOL>    let _files: FileAndFormat[] = [];<EOL>    if (!vscode.workspace.workspaceFolders) {<EOL>","gt":"return [];"}
{"input":"<s> async function getFileList(para?): Promise<FileAndFormat[]> {<EOL>    let _files: FileAndFormat[] = [];<EOL>    if (!vscode.workspace.workspaceFolders) {<EOL>        return [];<EOL>    }<EOL>    if (!para) {<EOL>        for (let folder: any of vscode.workspace.workspaceFolders) {<EOL>            _files.push(...await getFileList(folder.","gt":"uri));"}
{"input":"<s> async function getFileList(para?): Promise<FileAndFormat[]> {<EOL>    let _files: FileAndFormat[] = [];<EOL>    if (!vscode.workspace.workspaceFolders) {<EOL>        return [];<EOL>    }<EOL>    if (!para) {<EOL>        for (let folder: any of vscode.workspace.workspaceFolders) {<EOL>            _files.push(...await getFileList(folder.uri));<EOL>        }<EOL>    }<EOL>    else if (para instanceof Array) {<EOL>        for (let u: any of","gt":"para.filter((p: any): boolean => p instanceof vscode.Uri)) {"}
{"input":"<s> async function getFileList(para?): Promise<FileAndFormat[]> {<EOL>    let _files: FileAndFormat[] = [];<EOL>    if (!vscode.workspace.workspaceFolders) {<EOL>        return [];<EOL>    }<EOL>    if (!para) {<EOL>        for (let folder: any of vscode.workspace.workspaceFolders) {<EOL>            _files.push(...await getFileList(folder.uri));<EOL>        }<EOL>    }<EOL>    else if (para instanceof Array) {<EOL>        for (let u: any of para.filter((p: any): boolean => p instanceof vscode.Uri)) {<EOL>            _files.push(...await getFileList(u));<EOL>        }<EOL>    }<EOL>    else if (para instanceof vscode.Uri) {<EOL>        if (fs.statSync(para.fsPath).isDirectory()) {<EOL>            let exts: string = config.fileExtensions(para);<EOL>            let folder: any = vscode.workspace.getWorkspaceFolder(para);<EOL>            let","gt":"relPath: any = path.relative(folder.uri.fsPath, para.fsPath);"}
{"input":"<s> function getIndex(v: Value, tag: Tag): number {<EOL>    if (valueTag(v) !== tag) {<EOL>","gt":"throw \"<STR_LIT>\";"}
{"input":"<s> function elmNameStyle(original: string, upper: boolean): string {<EOL>    const words: import(\"<STR_LIT>\").WordInName[] = splitIntoWords(","gt":"original);"}
{"input":"<s> export function camelCase(str: string): string {<EOL>","gt":"return decapitalize(pascalCase(str));"}
{"input":"<s> function triviallyStructurallyCompatible(x: Type, y: Type): boolean {<EOL>    if (x.typeRef.getIndex() === y.typeRef.getIndex())<EOL>","gt":"return true;"}
{"input":"<s> function callAndReportFailure<T>(message: string, f: () => T): T | never {<EOL>    try {<EOL>        return","gt":"f();"}
{"input":"<s> export function resolvePathToJestBin(root: string, pathToJest: string): any {<EOL>    let jest: string = pathToJest;<EOL>    if (!path.isAbsolute(jest)) {<EOL>        jest = path.join(root,","gt":"jest);"}
{"input":"<s> export function resolvePathToJestBin(root: string, pathToJest: string): any {<EOL>    let jest: string = pathToJest;<EOL>    if (!path.isAbsolute(jest)) {<EOL>        jest = path.join(root, jest);<EOL>    }<EOL>    const basename:","gt":"any = path.basename(jest);"}
{"input":"<s> export function resolvePathToJestBin(root: string, pathToJest: string): any {<EOL>    let jest: string = pathToJest;<EOL>    if (!path.isAbsolute(jest)) {<EOL>        jest = path.join(root, jest);<EOL>    }<EOL>    const basename: any = path.basename(jest);<EOL>    switch (basename) {<EOL>","gt":"case \"<STR_LIT>\": {"}
{"input":"<s> export function resolvePathToJestBin(root: string, pathToJest: string): any {<EOL>    let jest: string = pathToJest;<EOL>    if (!path.isAbsolute(jest)) {<EOL>        jest = path.join(root, jest);<EOL>    }<EOL>    const basename: any = path.basename(jest);<EOL>    switch (basename) {<EOL>        case \"<STR_LIT>\": {<EOL>            return jest;<EOL>        }<EOL>        case \"<STR_LIT>\": {<EOL>            <EOL>            const line: any = fs.readFileSync(jest, \"<STR_LIT>\").split(\"<STR_LIT>\")[<NUM_LIT>];<EOL>            const match: RegExpExecArray = /^\\s*\"[^\"]+\"\\s+\"%~dp0\\\\([^\"]+)\"/.exec(line);<EOL>            return path.join(path.dirname(jest), match[<NUM_LIT>]);<EOL>        }<EOL>        case \"<STR_LIT>\": {<EOL>            <EOL>            const lines: any = fs.readFileSync(jest, \"<STR_LIT>\").split(\"<STR_LIT>\");<EOL>            switch (lines[","gt":"<NUM_LIT>]) {"}
{"input":"<s> export function resolvePathToJestBin(root: string, pathToJest: string): any {<EOL>    let jest: string = pathToJest;<EOL>    if (!path.isAbsolute(jest)) {<EOL>        jest = path.join(root, jest);<EOL>    }<EOL>    const basename: any = path.basename(jest);<EOL>    switch (basename) {<EOL>        case \"<STR_LIT>\": {<EOL>            return jest;<EOL>        }<EOL>        case \"<STR_LIT>\": {<EOL>            <EOL>            const line: any = fs.readFileSync(jest, \"<STR_LIT>\").split(\"<STR_LIT>\")[<NUM_LIT>];<EOL>            const match: RegExpExecArray = /^\\s*\"[^\"]+\"\\s+\"%~dp0\\\\([^\"]+)\"/.exec(line);<EOL>            return path.join(path.dirname(jest), match[<NUM_LIT>]);<EOL>        }<EOL>        case \"<STR_LIT>\": {<EOL>            <EOL>            const lines: any = fs.readFileSync(jest, \"<STR_LIT>\").split(\"<STR_LIT>\");<EOL>            switch (lines[<NUM_LIT>]) {<EOL>                case \"<STR_LIT>\": {<EOL>                    return jest;<EOL>                }<EOL>                case \"<STR_LIT>\": {<EOL>                    const line: any = lines[<NUM_LIT>];<EOL>                    const match: RegExpExecArray = /^\\s*\"[^\"]+\"\\s+\"$basedir\\/([^\"]+)\"/.exec(line);<EOL>                    if (match) {<EOL>                        return path.join(path.","gt":"dirname(jest), match[<NUM_LIT>]);"}
{"input":"<s> export function getMajesticConfig(rootPath: any): any {<EOL>    const packageJsonObj:","gt":"any = __non_webpack_require__(pathToPackageJSON(rootPath));"}
{"input":"<s> function concatTokens(left: Token[], right: Token[]): Token[] {<EOL>    return left.","gt":"concat(right);"}
{"input":"<s> export function ss3(char: string): string {<EOL>","gt":"return `<STR_LIT>`;"}
{"input":"<s> export function a1TransclusionDirective(): {<EOL>    restrict: string;<EOL>    transclude: boolean;<EOL>    scope: {};<EOL>    bindToController: {};<EOL>    controller: typeof A1Transclusion;<EOL>    controllerAs: string;<EOL>    template: string;<EOL>} {<EOL>    return {<EOL>        restrict: '<STR_LIT>',<EOL>","gt":"transclude: true,"}
{"input":"<s> export function allowanonymous(params?: JsonIgnore): any {<EOL>    params = params || <any>{};<EOL>    return function (target: Object, propertyKey: string) {<EOL>        MetaUtils.","gt":"addMetaData(target, {"}
{"input":"<s> export function inject(injectType?: any): (target: Object | Function, propertyKey: string, parameterIndex?: number) => void {<EOL>    function getInjectType(target: any, propertyKey: any, parameterIndex: any, decoratorType: DecoratorType): any {<EOL>        if (injectType) {<EOL>            return","gt":"injectType;"}
{"input":"<s> export function inject(injectType?: any): (target: Object | Function, propertyKey: string, parameterIndex?: number) => void {<EOL>    function getInjectType(target: any, propertyKey: any, parameterIndex: any, decoratorType: DecoratorType): any {<EOL>        if (injectType) {<EOL>            return injectType;<EOL>        }<EOL>        let type: any;<EOL>        if (decoratorType === DecoratorType.PARAM) {<EOL>            var paramTypes:","gt":"Array<any> = Utils.getDesignParamType(target, propertyKey, parameterIndex);"}
{"input":"<s> export function inject(injectType?: any): (target: Object | Function, propertyKey: string, parameterIndex?: number) => void {<EOL>    function getInjectType(target: any, propertyKey: any, parameterIndex: any, decoratorType: DecoratorType): any {<EOL>        if (injectType) {<EOL>            return injectType;<EOL>        }<EOL>        let type: any;<EOL>        if (decoratorType === DecoratorType.PARAM) {<EOL>            var paramTypes: Array<any> = Utils.getDesignParamType(target, propertyKey, parameterIndex);<EOL>            type = paramTypes && paramTypes.length && parameterIndex < paramTypes.length<EOL>                ? paramTypes[","gt":"parameterIndex]"}
{"input":"<s> export function inject(injectType?: any): (target: Object | Function, propertyKey: string, parameterIndex?: number) => void {<EOL>    function getInjectType(target: any, propertyKey: any, parameterIndex: any, decoratorType: DecoratorType): any {<EOL>        if (injectType) {<EOL>            return injectType;<EOL>        }<EOL>        let type: any;<EOL>        if (decoratorType === DecoratorType.PARAM) {<EOL>            var paramTypes: Array<any> = Utils.getDesignParamType(target, propertyKey, parameterIndex);<EOL>            type = paramTypes && paramTypes.length && parameterIndex < paramTypes.length<EOL>                ? paramTypes[parameterIndex]<EOL>                : null;<EOL>        }<EOL>        else if (decoratorType === DecoratorType.PROPERTY) {<EOL>            type = Utils.getDesignType(target, propertyKey);<EOL>        }<EOL>","gt":"else {"}
{"input":"<s> export function inject(injectType?: any): (target: Object | Function, propertyKey: string, parameterIndex?: number) => void {<EOL>    function getInjectType(target: any, propertyKey: any, parameterIndex: any, decoratorType: DecoratorType): any {<EOL>        if (injectType) {<EOL>            return injectType;<EOL>        }<EOL>        let type: any;<EOL>        if (decoratorType === DecoratorType.PARAM) {<EOL>            var paramTypes: Array<any> = Utils.getDesignParamType(target, propertyKey, parameterIndex);<EOL>            type = paramTypes && paramTypes.length && parameterIndex < paramTypes.length<EOL>                ? paramTypes[parameterIndex]<EOL>                : null;<EOL>        }<EOL>        else if (decoratorType === DecoratorType.PROPERTY) {<EOL>            type = Utils.getDesignType(target, propertyKey);<EOL>        }<EOL>        else {<EOL>            winstonLog.logError(`<STR_LIT>`);<EOL>            throw '<STR_LIT>';<EOL>        }<EOL>        if (!type) {<EOL>            winstonLog.logError(`<STR_LIT>`);<EOL>            console.log(target);<EOL>            throw","gt":"'<STR_LIT>';"}
{"input":"<s> export function inject(injectType?: any): (target: Object | Function, propertyKey: string, parameterIndex?: number) => void {<EOL>    function getInjectType(target: any, propertyKey: any, parameterIndex: any, decoratorType: DecoratorType): any {<EOL>        if (injectType) {<EOL>            return injectType;<EOL>        }<EOL>        let type: any;<EOL>        if (decoratorType === DecoratorType.PARAM) {<EOL>            var paramTypes: Array<any> = Utils.getDesignParamType(target, propertyKey, parameterIndex);<EOL>            type = paramTypes && paramTypes.length && parameterIndex < paramTypes.length<EOL>                ? paramTypes[parameterIndex]<EOL>                : null;<EOL>        }<EOL>        else if (decoratorType === DecoratorType.PROPERTY) {<EOL>            type = Utils.getDesignType(target, propertyKey);<EOL>        }<EOL>        else {<EOL>            winstonLog.logError(`<STR_LIT>`);<EOL>            throw '<STR_LIT>';<EOL>        }<EOL>        if (!type) {<EOL>            winstonLog.logError(`<STR_LIT>`);<EOL>            console.log(target);<EOL>            throw '<STR_LIT>';<EOL>        }<EOL>        return type;<EOL>    }<EOL>    return function (target: Object | Function, propertyKey: string, parameterIndex?: number) {<EOL>        <EOL>        if (arguments.length === <NUM_LIT>) {<EOL>            MetaUtils.addMetaData(target, {<EOL>                decorator: Decorators.INJECT,<EOL>","gt":"decoratorType: DecoratorType.PARAM,"}
{"input":"<s> export function inject(injectType?: any): (target: Object | Function, propertyKey: string, parameterIndex?: number) => void {<EOL>    function getInjectType(target: any, propertyKey: any, parameterIndex: any, decoratorType: DecoratorType): any {<EOL>        if (injectType) {<EOL>            return injectType;<EOL>        }<EOL>        let type: any;<EOL>        if (decoratorType === DecoratorType.PARAM) {<EOL>            var paramTypes: Array<any> = Utils.getDesignParamType(target, propertyKey, parameterIndex);<EOL>            type = paramTypes && paramTypes.length && parameterIndex < paramTypes.length<EOL>                ? paramTypes[parameterIndex]<EOL>                : null;<EOL>        }<EOL>        else if (decoratorType === DecoratorType.PROPERTY) {<EOL>            type = Utils.getDesignType(target, propertyKey);<EOL>        }<EOL>        else {<EOL>            winstonLog.logError(`<STR_LIT>`);<EOL>            throw '<STR_LIT>';<EOL>        }<EOL>        if (!type) {<EOL>            winstonLog.logError(`<STR_LIT>`);<EOL>            console.log(target);<EOL>            throw '<STR_LIT>';<EOL>        }<EOL>        return type;<EOL>    }<EOL>    return function (target: Object | Function, propertyKey: string, parameterIndex?: number) {<EOL>        <EOL>        if (arguments.length === <NUM_LIT>) {<EOL>            MetaUtils.addMetaData(target, {<EOL>                decorator: Decorators.INJECT,<EOL>                decoratorType: DecoratorType.PARAM,<EOL>                params: { type: getInjectType(target, propertyKey, parameterIndex, DecoratorType.PARAM) },<EOL>                propertyKey: propertyKey,<EOL>                paramIndex: parameterIndex<EOL>            });<EOL>            return;<EOL>        }<EOL>        <EOL>        else {<EOL>            injectType = getInjectType(target,","gt":"propertyKey, parameterIndex, DecoratorType.PROPERTY);"}
{"input":"<s> export function inject(injectType?: any): (target: Object | Function, propertyKey: string, parameterIndex?: number) => void {<EOL>    function getInjectType(target: any, propertyKey: any, parameterIndex: any, decoratorType: DecoratorType): any {<EOL>        if (injectType) {<EOL>            return injectType;<EOL>        }<EOL>        let type: any;<EOL>        if (decoratorType === DecoratorType.PARAM) {<EOL>            var paramTypes: Array<any> = Utils.getDesignParamType(target, propertyKey, parameterIndex);<EOL>            type = paramTypes && paramTypes.length && parameterIndex < paramTypes.length<EOL>                ? paramTypes[parameterIndex]<EOL>                : null;<EOL>        }<EOL>        else if (decoratorType === DecoratorType.PROPERTY) {<EOL>            type = Utils.getDesignType(target, propertyKey);<EOL>        }<EOL>        else {<EOL>            winstonLog.logError(`<STR_LIT>`);<EOL>            throw '<STR_LIT>';<EOL>        }<EOL>        if (!type) {<EOL>            winstonLog.logError(`<STR_LIT>`);<EOL>            console.log(target);<EOL>            throw '<STR_LIT>';<EOL>        }<EOL>        return type;<EOL>    }<EOL>    return function (target: Object | Function, propertyKey: string, parameterIndex?: number) {<EOL>        <EOL>        if (arguments.length === <NUM_LIT>) {<EOL>            MetaUtils.addMetaData(target, {<EOL>                decorator: Decorators.INJECT,<EOL>                decoratorType: DecoratorType.PARAM,<EOL>                params: { type: getInjectType(target, propertyKey, parameterIndex, DecoratorType.PARAM) },<EOL>                propertyKey: propertyKey,<EOL>                paramIndex: parameterIndex<EOL>            });<EOL>            return;<EOL>        }<EOL>        <EOL>        else {<EOL>            injectType = getInjectType(target, propertyKey, parameterIndex, DecoratorType.PROPERTY);<EOL>            let injectedProp: any = null;<EOL>            <EOL>            var getter: () => any = function () {<EOL>","gt":"if (!injectedProp) {"}
{"input":"<s> export function inject(injectType?: any): (target: Object | Function, propertyKey: string, parameterIndex?: number) => void {<EOL>    function getInjectType(target: any, propertyKey: any, parameterIndex: any, decoratorType: DecoratorType): any {<EOL>        if (injectType) {<EOL>            return injectType;<EOL>        }<EOL>        let type: any;<EOL>        if (decoratorType === DecoratorType.PARAM) {<EOL>            var paramTypes: Array<any> = Utils.getDesignParamType(target, propertyKey, parameterIndex);<EOL>            type = paramTypes && paramTypes.length && parameterIndex < paramTypes.length<EOL>                ? paramTypes[parameterIndex]<EOL>                : null;<EOL>        }<EOL>        else if (decoratorType === DecoratorType.PROPERTY) {<EOL>            type = Utils.getDesignType(target, propertyKey);<EOL>        }<EOL>        else {<EOL>            winstonLog.logError(`<STR_LIT>`);<EOL>            throw '<STR_LIT>';<EOL>        }<EOL>        if (!type) {<EOL>            winstonLog.logError(`<STR_LIT>`);<EOL>            console.log(target);<EOL>            throw '<STR_LIT>';<EOL>        }<EOL>        return type;<EOL>    }<EOL>    return function (target: Object | Function, propertyKey: string, parameterIndex?: number) {<EOL>        <EOL>        if (arguments.length === <NUM_LIT>) {<EOL>            MetaUtils.addMetaData(target, {<EOL>                decorator: Decorators.INJECT,<EOL>                decoratorType: DecoratorType.PARAM,<EOL>                params: { type: getInjectType(target, propertyKey, parameterIndex, DecoratorType.PARAM) },<EOL>                propertyKey: propertyKey,<EOL>                paramIndex: parameterIndex<EOL>            });<EOL>            return;<EOL>        }<EOL>        <EOL>        else {<EOL>            injectType = getInjectType(target, propertyKey, parameterIndex, DecoratorType.PROPERTY);<EOL>            let injectedProp: any = null;<EOL>            <EOL>            var getter: () => any = function () {<EOL>                if (!injectedProp) {<EOL>                    injectedProp = Container.resolve(injectType);<EOL>                    <EOL>                    <EOL>                    <EOL>                }<EOL>                return injectedProp;<EOL>            };<EOL>            var setter: (value: any) => void = function (value) {<EOL>                injectedProp = value;<EOL>            };<EOL>            <EOL>","gt":"if (!(delete target[propertyKey])) {"}
{"input":"<s> export function inject(injectType?: any): (target: Object | Function, propertyKey: string, parameterIndex?: number) => void {<EOL>    function getInjectType(target: any, propertyKey: any, parameterIndex: any, decoratorType: DecoratorType): any {<EOL>        if (injectType) {<EOL>            return injectType;<EOL>        }<EOL>        let type: any;<EOL>        if (decoratorType === DecoratorType.PARAM) {<EOL>            var paramTypes: Array<any> = Utils.getDesignParamType(target, propertyKey, parameterIndex);<EOL>            type = paramTypes && paramTypes.length && parameterIndex < paramTypes.length<EOL>                ? paramTypes[parameterIndex]<EOL>                : null;<EOL>        }<EOL>        else if (decoratorType === DecoratorType.PROPERTY) {<EOL>            type = Utils.getDesignType(target, propertyKey);<EOL>        }<EOL>        else {<EOL>            winstonLog.logError(`<STR_LIT>`);<EOL>            throw '<STR_LIT>';<EOL>        }<EOL>        if (!type) {<EOL>            winstonLog.logError(`<STR_LIT>`);<EOL>            console.log(target);<EOL>            throw '<STR_LIT>';<EOL>        }<EOL>        return type;<EOL>    }<EOL>    return function (target: Object | Function, propertyKey: string, parameterIndex?: number) {<EOL>        <EOL>        if (arguments.length === <NUM_LIT>) {<EOL>            MetaUtils.addMetaData(target, {<EOL>                decorator: Decorators.INJECT,<EOL>                decoratorType: DecoratorType.PARAM,<EOL>                params: { type: getInjectType(target, propertyKey, parameterIndex, DecoratorType.PARAM) },<EOL>                propertyKey: propertyKey,<EOL>                paramIndex: parameterIndex<EOL>            });<EOL>            return;<EOL>        }<EOL>        <EOL>        else {<EOL>            injectType = getInjectType(target, propertyKey, parameterIndex, DecoratorType.PROPERTY);<EOL>            let injectedProp: any = null;<EOL>            <EOL>            var getter: () => any = function () {<EOL>                if (!injectedProp) {<EOL>                    injectedProp = Container.resolve(injectType);<EOL>                    <EOL>                    <EOL>                    <EOL>                }<EOL>                return injectedProp;<EOL>            };<EOL>            var setter: (value: any) => void = function (value) {<EOL>                injectedProp = value;<EOL>            };<EOL>            <EOL>            if (!(delete target[propertyKey])) {<EOL>                winstonLog.logError(`<STR_LIT>`);<EOL>                throw \"<STR_LIT>\";<EOL>            }<EOL>            <EOL>            Object.defineProperty(target, propertyKey, {<EOL>","gt":"get: getter,"}
{"input":"<s> export function inject(injectType?: any): (target: Object | Function, propertyKey: string, parameterIndex?: number) => void {<EOL>    function getInjectType(target: any, propertyKey: any, parameterIndex: any, decoratorType: DecoratorType): any {<EOL>        if (injectType) {<EOL>            return injectType;<EOL>        }<EOL>        let type: any;<EOL>        if (decoratorType === DecoratorType.PARAM) {<EOL>            var paramTypes: Array<any> = Utils.getDesignParamType(target, propertyKey, parameterIndex);<EOL>            type = paramTypes && paramTypes.length && parameterIndex < paramTypes.length<EOL>                ? paramTypes[parameterIndex]<EOL>                : null;<EOL>        }<EOL>        else if (decoratorType === DecoratorType.PROPERTY) {<EOL>            type = Utils.getDesignType(target, propertyKey);<EOL>        }<EOL>        else {<EOL>            winstonLog.logError(`<STR_LIT>`);<EOL>            throw '<STR_LIT>';<EOL>        }<EOL>        if (!type) {<EOL>            winstonLog.logError(`<STR_LIT>`);<EOL>            console.log(target);<EOL>            throw '<STR_LIT>';<EOL>        }<EOL>        return type;<EOL>    }<EOL>    return function (target: Object | Function, propertyKey: string, parameterIndex?: number) {<EOL>        <EOL>        if (arguments.length === <NUM_LIT>) {<EOL>            MetaUtils.addMetaData(target, {<EOL>                decorator: Decorators.INJECT,<EOL>                decoratorType: DecoratorType.PARAM,<EOL>                params: { type: getInjectType(target, propertyKey, parameterIndex, DecoratorType.PARAM) },<EOL>                propertyKey: propertyKey,<EOL>                paramIndex: parameterIndex<EOL>            });<EOL>            return;<EOL>        }<EOL>        <EOL>        else {<EOL>            injectType = getInjectType(target, propertyKey, parameterIndex, DecoratorType.PROPERTY);<EOL>            let injectedProp: any = null;<EOL>            <EOL>            var getter: () => any = function () {<EOL>                if (!injectedProp) {<EOL>                    injectedProp = Container.resolve(injectType);<EOL>                    <EOL>                    <EOL>                    <EOL>                }<EOL>                return injectedProp;<EOL>            };<EOL>            var setter: (value: any) => void = function (value) {<EOL>                injectedProp = value;<EOL>            };<EOL>            <EOL>            if (!(delete target[propertyKey])) {<EOL>                winstonLog.logError(`<STR_LIT>`);<EOL>                throw \"<STR_LIT>\";<EOL>            }<EOL>            <EOL>            Object.defineProperty(target, propertyKey, {<EOL>                get: getter,<EOL>                set: setter,<EOL>","gt":"enumerable:"}
{"input":"<s> export function inject(injectType?: any): (target: Object | Function, propertyKey: string, parameterIndex?: number) => void {<EOL>    function getInjectType(target: any, propertyKey: any, parameterIndex: any, decoratorType: DecoratorType): any {<EOL>        if (injectType) {<EOL>            return injectType;<EOL>        }<EOL>        let type: any;<EOL>        if (decoratorType === DecoratorType.PARAM) {<EOL>            var paramTypes: Array<any> = Utils.getDesignParamType(target, propertyKey, parameterIndex);<EOL>            type = paramTypes && paramTypes.length && parameterIndex < paramTypes.length<EOL>                ? paramTypes[parameterIndex]<EOL>                : null;<EOL>        }<EOL>        else if (decoratorType === DecoratorType.PROPERTY) {<EOL>            type = Utils.getDesignType(target, propertyKey);<EOL>        }<EOL>        else {<EOL>            winstonLog.logError(`<STR_LIT>`);<EOL>            throw '<STR_LIT>';<EOL>        }<EOL>        if (!type) {<EOL>            winstonLog.logError(`<STR_LIT>`);<EOL>            console.log(target);<EOL>            throw '<STR_LIT>';<EOL>        }<EOL>        return type;<EOL>    }<EOL>    return function (target: Object | Function, propertyKey: string, parameterIndex?: number) {<EOL>        <EOL>        if (arguments.length === <NUM_LIT>) {<EOL>            MetaUtils.addMetaData(target, {<EOL>                decorator: Decorators.INJECT,<EOL>                decoratorType: DecoratorType.PARAM,<EOL>                params: { type: getInjectType(target, propertyKey, parameterIndex, DecoratorType.PARAM) },<EOL>                propertyKey: propertyKey,<EOL>                paramIndex: parameterIndex<EOL>            });<EOL>            return;<EOL>        }<EOL>        <EOL>        else {<EOL>            injectType = getInjectType(target, propertyKey, parameterIndex, DecoratorType.PROPERTY);<EOL>            let injectedProp: any = null;<EOL>            <EOL>            var getter: () => any = function () {<EOL>                if (!injectedProp) {<EOL>                    injectedProp = Container.resolve(injectType);<EOL>                    <EOL>                    <EOL>                    <EOL>                }<EOL>                return injectedProp;<EOL>            };<EOL>            var setter: (value: any) => void = function (value) {<EOL>                injectedProp = value;<EOL>            };<EOL>            <EOL>            if (!(delete target[propertyKey])) {<EOL>                winstonLog.logError(`<STR_LIT>`);<EOL>                throw \"<STR_LIT>\";<EOL>            }<EOL>            <EOL>            Object.defineProperty(target, propertyKey, {<EOL>                get: getter,<EOL>                set: setter,<EOL>                enumerable:","gt":"true,"}
{"input":"<s> export function getDbSpecifcModel(schemaName: any, schema: any): any {<EOL>    var database: any = PrincipalContext.get(CoreUtils.resources.userDatabase);<EOL>    if (database && allConnections[database]) {<EOL>        return allConnections[database].","gt":"model(schemaName, schema);"}
{"input":"<s> export function document(params: {<EOL>    name: string;<EOL>    strict?: Strict;<EOL>    dynamicName?: boolean;<EOL>}): (target: Object) => void {<EOL>    params = params || <any>{};<EOL>    return function (target: Object) {<EOL>        console.log(\"<STR_LIT>\" + params.name);<EOL>        if (_dcoumentDecoratorCache[params.name]) {<EOL>","gt":"return;"}
{"input":"<s> export function document(params: {<EOL>    name: string;<EOL>    strict?: Strict;<EOL>    dynamicName?: boolean;<EOL>}): (target: Object) => void {<EOL>    params = params || <any>{};<EOL>    return function (target: Object) {<EOL>        console.log(\"<STR_LIT>\" + params.name);<EOL>        if (_dcoumentDecoratorCache[params.name]) {<EOL>            return;<EOL>        }<EOL>        _dcoumentDecoratorCache[params.name] = params;<EOL>        <EOL>        MetaUtils.addMetaData(((<any>target).","gt":"prototype || target), {"}
{"input":"<s> export function document(params: {<EOL>    name: string;<EOL>    strict?: Strict;<EOL>    dynamicName?: boolean;<EOL>}): (target: Object) => void {<EOL>    params = params || <any>{};<EOL>    return function (target: Object) {<EOL>        console.log(\"<STR_LIT>\" + params.name);<EOL>        if (_dcoumentDecoratorCache[params.name]) {<EOL>            return;<EOL>        }<EOL>        _dcoumentDecoratorCache[params.name] = params;<EOL>        <EOL>        MetaUtils.addMetaData(((<any>target).prototype || target), {<EOL>            decorator: Decorators.DOCUMENT,<EOL>            decoratorType: DecoratorType.CLASS,<EOL>","gt":"modelType: DecoratorType.MODEL,"}
{"input":"<s> <EOL>export function bulkPut(model: Mongoose.Model<any>, objArr: Array<any>, batchSize?: number, donotLoadChilds?: boolean): Q.Promise<any> {<EOL>    if (!objArr || !objArr.length)<EOL>        return Q.when([]);<EOL>    <EOL>    mongooseHelper.updateWriteCount();<EOL>    var asyncCalls: any[] = [];<EOL>    var length: number = objArr.","gt":"length;"}
{"input":"<s> <EOL>export function bulkPut(model: Mongoose.Model<any>, objArr: Array<any>, batchSize?: number, donotLoadChilds?: boolean): Q.Promise<any> {<EOL>    if (!objArr || !objArr.length)<EOL>        return Q.when([]);<EOL>    <EOL>    mongooseHelper.updateWriteCount();<EOL>    var asyncCalls: any[] = [];<EOL>    var length: number = objArr.length;<EOL>    var ids: any[] = objArr.map((x: any): any => x._id);<EOL>    var bulk: any = model.collection.initializeUnorderedBulkOp();<EOL>    var asyncCalls:","gt":"any[] = [];"}
{"input":"<s> <EOL>export function bulkPut(model: Mongoose.Model<any>, objArr: Array<any>, batchSize?: number, donotLoadChilds?: boolean): Q.Promise<any> {<EOL>    if (!objArr || !objArr.length)<EOL>        return Q.when([]);<EOL>    <EOL>    mongooseHelper.updateWriteCount();<EOL>    var asyncCalls: any[] = [];<EOL>    var length: number = objArr.length;<EOL>    var ids: any[] = objArr.map((x: any): any => x._id);<EOL>    var bulk: any = model.collection.initializeUnorderedBulkOp();<EOL>    var asyncCalls: any[] = [];<EOL>    if (!batchSize) {<EOL>        asyncCalls.push(executeBulkPut(model, objArr, donotLoadChilds));<EOL>    }<EOL>    else {<EOL>        for (let curCount: number = <NUM_LIT>; curCount < objArr.length; curCount += batchSize) {<EOL>            asyncCalls.","gt":"push(executeBulkPut(model, objArr.slice(curCount, curCount + batchSize), donotLoadChilds));"}
{"input":"<s> <EOL>export function del(model: Mongoose.Model<any>, id: any): Q.Promise<any> {<EOL>    <EOL>    let newModel: Mongoose.Model<any> = mongooseHelper.getChangedModelForDynamicSchema(model, id);<EOL>    return <any>newModel.findByIdAndRemove(mongooseHelper.setShardCondition(model, { '<STR_LIT>': id })).lean().then((response: any): any => {<EOL>        return mongooseHelper.deleteCascade(model, [response]).then((x: any): any => {<EOL>            return mongooseHelper.deleteEmbeddedFromParent(model, EntityChange.delete, [response])<EOL>                .","gt":"then((res: any): {"}
{"input":"<s> <EOL>export function del(model: Mongoose.Model<any>, id: any): Q.Promise<any> {<EOL>    <EOL>    let newModel: Mongoose.Model<any> = mongooseHelper.getChangedModelForDynamicSchema(model, id);<EOL>    return <any>newModel.findByIdAndRemove(mongooseHelper.setShardCondition(model, { '<STR_LIT>': id })).lean().then((response: any): any => {<EOL>        return mongooseHelper.deleteCascade(model, [response]).then((x: any): any => {<EOL>            return mongooseHelper.deleteEmbeddedFromParent(model, EntityChange.delete, [response])<EOL>                .then((res: any): {<EOL>                delete: string;<EOL>            } => {<EOL>                <EOL>","gt":"return ({ delete: '<STR_LIT>' });"}
{"input":"<s> <EOL>export function findOne(model: Mongoose.Model<any>, id, donotLoadChilds?: boolean): Q.Promise<any> {<EOL>    <EOL>    let newModel: Mongoose.Model<any> = mongooseHelper.getChangedModelForDynamicSchema(model, id);<EOL>    return <any>newModel.findOne(mongooseHelper.setShardCondition(model, { '<STR_LIT>': id })).lean().then((result: any): any => {<EOL>        return mongooseHelper.embeddedChildren1(model, [","gt":"result], false, donotLoadChilds)"}
{"input":"<s> <EOL>export function findOne(model: Mongoose.Model<any>, id, donotLoadChilds?: boolean): Q.Promise<any> {<EOL>    <EOL>    let newModel: Mongoose.Model<any> = mongooseHelper.getChangedModelForDynamicSchema(model, id);<EOL>    return <any>newModel.findOne(mongooseHelper.setShardCondition(model, { '<STR_LIT>': id })).lean().then((result: any): any => {<EOL>        return mongooseHelper.embeddedChildren1(model, [result], false, donotLoadChilds)<EOL>            .then((r: any): any => {<EOL>            <EOL>            return result;<EOL>        });<EOL>    }).catch((error: any): any => {<EOL>","gt":"winstonLog.logError(`<STR_LIT>`);"}
{"input":"<s> <EOL>export function post(model: Mongoose.Model<any>, obj: any): Q.Promise<any> {<EOL>    <EOL>    mongooseHelper.updateWriteCount();<EOL>    let clonedObj: any = mongooseHelper.removeTransientProperties(model, obj);<EOL>    clonedObj[ConstantKeys.TempId] = clonedObj._id ? clonedObj._id : Utils.autogenerateIds(","gt":"model);"}
{"input":"<s> <EOL>export function post(model: Mongoose.Model<any>, obj: any): Q.Promise<any> {<EOL>    <EOL>    mongooseHelper.updateWriteCount();<EOL>    let clonedObj: any = mongooseHelper.removeTransientProperties(model, obj);<EOL>    clonedObj[ConstantKeys.TempId] = clonedObj._id ? clonedObj._id : Utils.autogenerateIds(model);<EOL>","gt":"return mongooseHelper.addChildModelToParent(model, [clonedObj])"}
{"input":"<s> <EOL>export function post(model: Mongoose.Model<any>, obj: any): Q.Promise<any> {<EOL>    <EOL>    mongooseHelper.updateWriteCount();<EOL>    let clonedObj: any = mongooseHelper.removeTransientProperties(model, obj);<EOL>    clonedObj[ConstantKeys.TempId] = clonedObj._id ? clonedObj._id : Utils.autogenerateIds(model);<EOL>    return mongooseHelper.addChildModelToParent(model, [clonedObj])<EOL>        .then((result: any): any => {<EOL>        <EOL>        <EOL>        <EOL>        <EOL>        <EOL>        <EOL>        <EOL>        if (clonedObj[ConstantKeys.TempId]) {<EOL>            clonedObj._id = clonedObj[ConstantKeys.TempId];<EOL>            delete clonedObj[ConstantKeys.TempId];<EOL>        }<EOL>        mongooseHelper.setUniqueIdFromShard(clonedObj);<EOL>        mongooseHelper.setShardCondition(model, clonedObj);<EOL>        <EOL>        if (_arrayPropListSchema[model.modelName]) {<EOL>            _arrayPropListSchema[model.modelName].","gt":"forEach((prop: any): void => {"}
{"input":"<s> <EOL>export function post(model: Mongoose.Model<any>, obj: any): Q.Promise<any> {<EOL>    <EOL>    mongooseHelper.updateWriteCount();<EOL>    let clonedObj: any = mongooseHelper.removeTransientProperties(model, obj);<EOL>    clonedObj[ConstantKeys.TempId] = clonedObj._id ? clonedObj._id : Utils.autogenerateIds(model);<EOL>    return mongooseHelper.addChildModelToParent(model, [clonedObj])<EOL>        .then((result: any): any => {<EOL>        <EOL>        <EOL>        <EOL>        <EOL>        <EOL>        <EOL>        <EOL>        if (clonedObj[ConstantKeys.TempId]) {<EOL>            clonedObj._id = clonedObj[ConstantKeys.TempId];<EOL>            delete clonedObj[ConstantKeys.TempId];<EOL>        }<EOL>        mongooseHelper.setUniqueIdFromShard(clonedObj);<EOL>        mongooseHelper.setShardCondition(model, clonedObj);<EOL>        <EOL>        if (_arrayPropListSchema[model.modelName]) {<EOL>            _arrayPropListSchema[model.modelName].forEach((prop: any): void => {<EOL>                if (!clonedObj[prop]) {<EOL>                    clonedObj[prop] = [];<EOL>                }<EOL>            });<EOL>        }<EOL>        let newModel: any = mongooseHelper.getNewModelFromObject(model, clonedObj);<EOL>        return Q.nbind(newModel.create, newModel)(clonedObj).then((result: any): any => {<EOL>            let resObj: any = Utils.toObject(result);<EOL>","gt":"Object.assign(obj, resObj);"}
{"input":"<s> <EOL>export function put(model: Mongoose.Model<any>, id: any, obj: any): Q.Promise<any> {<EOL>    <EOL>    <EOL>    return bulkPut(model, [obj]).then((res: Array<any>): any => {<EOL>        if (res.length) {<EOL>            <EOL>            Object.assign(obj, res[<NUM_LIT>]);<EOL>            <EOL>            return obj;<EOL>        }<EOL>        <EOL>        return [];<EOL>    }).","gt":"catch((error: any): any => {"}
{"input":"<s> export function column(params?: {<EOL>    name: string;<EOL>    type?: any;<EOL>    allowNull?: boolean;<EOL>    primaryKey?: boolean;<EOL>    unique?: boolean;<EOL>    validate?: any;<EOL>    autogenerated?: boolean;<EOL>    searchIndex?: boolean;<EOL>    autoIncrement?: boolean;<EOL>}): (target: Object, propertyKey: string) => void {<EOL>    return function (target: Object, propertyKey: string) {<EOL>        console.log('<STR_LIT>', propertyKey, '<STR_LIT>', target);<EOL>","gt":"MetaUtils.addMetaData(target, {"}
{"input":"<s> export function AddAllFakeFunctions(): void {<EOL>    database[ModelNames.course] = [];<EOL>    _mongooseModel[ModelNames.course] = Mongoose.model(ModelNames.course, new Mongoose.Schema(course.prototype.schema()));<EOL>    _databaseCalls[ModelNames.course] =","gt":"new courseRepository();"}
{"input":"<s> function bindActions<E extends Stream, I, S>(actions: Actions<void>, intent$: Subject<E, I>, self: XcomponentClass<E, I, S> | Xcomponent<E, I, S>): Actions<void> {<EOL>    let _actions: Actions<void> = {<EOL>        fromEvent(e: Event) {<EOL>            return intent$.next(e);<EOL>        },<EOL>        fromPromise(p: Promise<I>) {<EOL>            return","gt":"p.then((x: I): any => intent$.next(x));"}
{"input":"<s> function bindActions<E extends Stream, I, S>(actions: Actions<void>, intent$: Subject<E, I>, self: XcomponentClass<E, I, S> | Xcomponent<E, I, S>): Actions<void> {<EOL>    let _actions: Actions<void> = {<EOL>        fromEvent(e: Event) {<EOL>            return intent$.next(e);<EOL>        },<EOL>        fromPromise(p: Promise<I>) {<EOL>            return p.then((x: I): any => intent$.next(x));<EOL>        },<EOL>        terminate(a: I) {<EOL>            if (process.env.NODE_ENV == '<STR_LIT>')<EOL>                console.error('<STR_LIT>');<EOL>            return intent$.","gt":"complete(a);"}
{"input":"<s> function bindActions<E extends Stream, I, S>(actions: Actions<void>, intent$: Subject<E, I>, self: XcomponentClass<E, I, S> | Xcomponent<E, I, S>): Actions<void> {<EOL>    let _actions: Actions<void> = {<EOL>        fromEvent(e: Event) {<EOL>            return intent$.next(e);<EOL>        },<EOL>        fromPromise(p: Promise<I>) {<EOL>            return p.then((x: I): any => intent$.next(x));<EOL>        },<EOL>        terminate(a: I) {<EOL>            if (process.env.NODE_ENV == '<STR_LIT>')<EOL>                console.error('<STR_LIT>');<EOL>            return intent$.complete(a);<EOL>        }<EOL>    };<EOL>    for (let a: string in actions) {<EOL>","gt":"_actions[a] = (...args: any[]): any => {"}
{"input":"<s> function isSFC(Component: React.ComponentClass<any> | React.SFC<any>): Component is React.SFC<any> {<EOL>    return (","gt":"typeof Component == '<STR_LIT>');"}
{"input":"<s> function getRandom(): number {<EOL>    let min: number = <NUM_LIT>, max:","gt":"number = Math.pow(<NUM_LIT>, <NUM_LIT>) - <NUM_LIT>;"}
{"input":"<s> async function* tick(t: (x: number) => void | Promise<void>): AsyncGenerator<number, void, unknown> {<EOL>    let i: number = <NUM_LIT>;<EOL>","gt":"while (<NUM_LIT>) {"}
{"input":"<s> export function debounce(func: any, wait: any, immediate: boolean = false): () => void {<EOL>    var timeout: any;<EOL>    return function () {<EOL>        var context: any = this, args: IArguments = arguments;<EOL>        var later: () => void = function () {<EOL>            timeout =","gt":"null;"}
{"input":"<s> export function debounce(func: any, wait: any, immediate: boolean = false): () => void {<EOL>    var timeout: any;<EOL>    return function () {<EOL>        var context: any = this, args: IArguments = arguments;<EOL>        var later: () => void = function () {<EOL>            timeout = null;<EOL>            if (!immediate)<EOL>                func.apply(context, args);<EOL>        };<EOL>        var callNow: boolean = immediate && !timeout;<EOL>        clearTimeout(timeout);<EOL>","gt":"timeout = setTimeout(later, wait);"}
{"input":"<s> export function isTextLike(contentType: string): boolean {<EOL>","gt":"return contentType.search(/text\\/plain/i) !== -<NUM_LIT>;"}
{"input":"<s> <EOL>export function getChildDebugElementByType(parent: any, type: any): any {<EOL>    return parent.","gt":"query(By.directive(type));"}
{"input":"<s> function setIncompleteClasspathSeverity(severity: string): void {<EOL>    const","gt":"config: WorkspaceConfiguration = getJavaConfiguration();"}
{"input":"<s> function checkJavaRuntime(): Promise<string> {<EOL>    return new Promise((resolve: (value: string | PromiseLike<string>) => void, reject: (reason?: any) => void): void => {<EOL>        let source: string;<EOL>        let","gt":"javaHome: string = readJavaConfig();"}
{"input":"<s> function checkJavaRuntime(): Promise<string> {<EOL>    return new Promise((resolve: (value: string | PromiseLike<string>) => void, reject: (reason?: any) => void): void => {<EOL>        let source: string;<EOL>        let javaHome: string = readJavaConfig();<EOL>        if (javaHome) {<EOL>            source = '<STR_LIT>';<EOL>        }<EOL>","gt":"else {"}
{"input":"<s> function checkJavaRuntime(): Promise<string> {<EOL>    return new Promise((resolve: (value: string | PromiseLike<string>) => void, reject: (reason?: any) => void): void => {<EOL>        let source: string;<EOL>        let javaHome: string = readJavaConfig();<EOL>        if (javaHome) {<EOL>            source = '<STR_LIT>';<EOL>        }<EOL>        else {<EOL>            javaHome = process.env['<STR_LIT>'];<EOL>            if (javaHome) {<EOL>                source = '<STR_LIT>';<EOL>            }<EOL>","gt":"else {"}
{"input":"<s> function checkJavaRuntime(): Promise<string> {<EOL>    return new Promise((resolve: (value: string | PromiseLike<string>) => void, reject: (reason?: any) => void): void => {<EOL>        let source: string;<EOL>        let javaHome: string = readJavaConfig();<EOL>        if (javaHome) {<EOL>            source = '<STR_LIT>';<EOL>        }<EOL>        else {<EOL>            javaHome = process.env['<STR_LIT>'];<EOL>            if (javaHome) {<EOL>                source = '<STR_LIT>';<EOL>            }<EOL>            else {<EOL>                javaHome = process.env['<STR_LIT>'];<EOL>                source = '<STR_LIT>';<EOL>            }<EOL>        }<EOL>        if (javaHome) {<EOL>            javaHome = expandHomeDir(javaHome);<EOL>            if (!pathExists.sync(javaHome)) {<EOL>                openJDKDownload(","gt":"reject, source + '<STR_LIT>');"}
{"input":"<s> function checkJavaRuntime(): Promise<string> {<EOL>    return new Promise((resolve: (value: string | PromiseLike<string>) => void, reject: (reason?: any) => void): void => {<EOL>        let source: string;<EOL>        let javaHome: string = readJavaConfig();<EOL>        if (javaHome) {<EOL>            source = '<STR_LIT>';<EOL>        }<EOL>        else {<EOL>            javaHome = process.env['<STR_LIT>'];<EOL>            if (javaHome) {<EOL>                source = '<STR_LIT>';<EOL>            }<EOL>            else {<EOL>                javaHome = process.env['<STR_LIT>'];<EOL>                source = '<STR_LIT>';<EOL>            }<EOL>        }<EOL>        if (javaHome) {<EOL>            javaHome = expandHomeDir(javaHome);<EOL>            if (!pathExists.sync(javaHome)) {<EOL>                openJDKDownload(reject, source + '<STR_LIT>');<EOL>            }<EOL>            if (!pathExists.sync(path.resolve(javaHome, '<STR_LIT>', JAVAC_FILENAME))) {<EOL>                openJDKDownload(reject, source + '<STR_LIT>');<EOL>            }<EOL>            return resolve(javaHome);<EOL>        }<EOL>        <EOL>        findJavaHome(function (","gt":"err, home) {"}
{"input":"<s> function reducer2(state: any, action: any): void {<EOL>    if (isCustomAction(action)) {<EOL>        let a: number = action.payload.a;<EOL>    }<EOL>    else if (isCustomAction2(","gt":"action)) {"}
{"input":"<s> function reducer2(state: any, action: any): void {<EOL>    if (isCustomAction(action)) {<EOL>        let a: number = action.payload.a;<EOL>    }<EOL>    else if (isCustomAction2(action)) {<EOL>        let a: number = action.payload.a;<EOL>        let b: string = action.meta.b;<EOL>    }<EOL>    else if (isCustomAction3(","gt":"action)) {"}
{"input":"<s> function load(): void {<EOL>    init();<EOL>    const itemBox: any = document.getElementById('<STR_LIT>');<EOL>    const","gt":"citekeyBox: any = document.getElementById('<STR_LIT>');"}
{"input":"<s> function showDyingDialog(title: string, detail: string): void {<EOL>    dialog.showMessageBox({<EOL>        type: '<STR_LIT>',<EOL>        message:","gt":"title,"}
{"input":"<s> export function send(channel: IpcChannelFromRenderer, ...args: any[]): void {<EOL>    log.","gt":"info('<STR_LIT>', channel, args);"}
{"input":"<s> function reloadPreview(): void {<EOL>    if (document.getElementById('<STR_LIT>') !== null) {<EOL>        renderMarkdownPreview(watching_path);<EOL>    }<EOL>    else","gt":"if (document.getElementById('<STR_LIT>') !== null) {"}
{"input":"<s> function parseFlags(tx: any): any {<EOL>    const settings: any = {};<EOL>    if (tx.TransactionType !== '<STR_LIT>') {<EOL>        return","gt":"settings;"}
{"input":"<s> function parseFlags(tx: any): any {<EOL>    const settings: any = {};<EOL>    if (tx.TransactionType !== '<STR_LIT>') {<EOL>        return settings;<EOL>    }<EOL>    const node: any = getAccountRootModifiedNode(tx);<EOL>    const oldFlags: any = _.get(","gt":"node.PreviousFields, '<STR_LIT>');"}
{"input":"<s> function parseFlags(tx: any): any {<EOL>    const settings: any = {};<EOL>    if (tx.TransactionType !== '<STR_LIT>') {<EOL>        return settings;<EOL>    }<EOL>    const node: any = getAccountRootModifiedNode(tx);<EOL>    const oldFlags: any = _.get(node.PreviousFields, '<STR_LIT>');<EOL>    const newFlags: any = _.get(node.FinalFields, '<STR_LIT>');<EOL>    if (oldFlags !== undefined && newFlags !== undefined) {<EOL>        const changedFlags: number = oldFlags ^ newFlags;<EOL>","gt":"const setFlags: number = newFlags & changedFlags;"}
{"input":"<s> function parseFlags(tx: any): any {<EOL>    const settings: any = {};<EOL>    if (tx.TransactionType !== '<STR_LIT>') {<EOL>        return settings;<EOL>    }<EOL>    const node: any = getAccountRootModifiedNode(tx);<EOL>    const oldFlags: any = _.get(node.PreviousFields, '<STR_LIT>');<EOL>    const newFlags: any = _.get(node.FinalFields, '<STR_LIT>');<EOL>    if (oldFlags !== undefined && newFlags !== undefined) {<EOL>        const changedFlags: number = oldFlags ^ newFlags;<EOL>        const setFlags: number = newFlags & changedFlags;<EOL>        const clearedFlags: number = oldFlags & changedFlags;<EOL>        _.forEach(AccountFlags, (flagValue: any, flagName: any): void => {<EOL>            if (setFlags & flagValue) {<EOL>                settings[flagName] =","gt":"true;"}
{"input":"<s> function parseFlags(tx: any): any {<EOL>    const settings: any = {};<EOL>    if (tx.TransactionType !== '<STR_LIT>') {<EOL>        return settings;<EOL>    }<EOL>    const node: any = getAccountRootModifiedNode(tx);<EOL>    const oldFlags: any = _.get(node.PreviousFields, '<STR_LIT>');<EOL>    const newFlags: any = _.get(node.FinalFields, '<STR_LIT>');<EOL>    if (oldFlags !== undefined && newFlags !== undefined) {<EOL>        const changedFlags: number = oldFlags ^ newFlags;<EOL>        const setFlags: number = newFlags & changedFlags;<EOL>        const clearedFlags: number = oldFlags & changedFlags;<EOL>        _.forEach(AccountFlags, (flagValue: any, flagName: any): void => {<EOL>            if (setFlags & flagValue) {<EOL>                settings[flagName] = true;<EOL>            }<EOL>            else if (clearedFlags & flagValue) {<EOL>                settings[flagName] =","gt":"false;"}
{"input":"<s> function parseFlags(tx: any): any {<EOL>    const settings: any = {};<EOL>    if (tx.TransactionType !== '<STR_LIT>') {<EOL>        return settings;<EOL>    }<EOL>    const node: any = getAccountRootModifiedNode(tx);<EOL>    const oldFlags: any = _.get(node.PreviousFields, '<STR_LIT>');<EOL>    const newFlags: any = _.get(node.FinalFields, '<STR_LIT>');<EOL>    if (oldFlags !== undefined && newFlags !== undefined) {<EOL>        const changedFlags: number = oldFlags ^ newFlags;<EOL>        const setFlags: number = newFlags & changedFlags;<EOL>        const clearedFlags: number = oldFlags & changedFlags;<EOL>        _.forEach(AccountFlags, (flagValue: any, flagName: any): void => {<EOL>            if (setFlags & flagValue) {<EOL>                settings[flagName] = true;<EOL>            }<EOL>            else if (clearedFlags & flagValue) {<EOL>                settings[flagName] = false;<EOL>            }<EOL>        });<EOL>    }<EOL>    <EOL>    <EOL>    <EOL>    const oldField: any = _.get(node.PreviousFields, '<STR_LIT>');<EOL>    const newField: any = _.get(","gt":"node.FinalFields, '<STR_LIT>');"}
{"input":"<s> function removeEmptyCounterparty(amount: any): void {<EOL>","gt":"if (amount.counterparty === '<STR_LIT>') {"}
{"input":"<s> function formatSettings(response: any): any {<EOL>    const data: any = response.account_data;<EOL>    const parsedFlags: {} = parseFlags(","gt":"data.Flags);"}
{"input":"<s> function transactionFilter(address: string, filters: TransactionsOptions, tx: TransactionType): boolean {<EOL>    if (filters.excludeFailures && tx.outcome.result !== '<STR_LIT>') {<EOL>        return false;<EOL>    }<EOL>    if (filters.types && !_.includes(filters.types, tx.type)) {<EOL>","gt":"return false;"}
{"input":"<s> function transactionFilter(address: string, filters: TransactionsOptions, tx: TransactionType): boolean {<EOL>    if (filters.excludeFailures && tx.outcome.result !== '<STR_LIT>') {<EOL>        return false;<EOL>    }<EOL>    if (filters.types && !_.includes(filters.types, tx.type)) {<EOL>        return false;<EOL>    }<EOL>    if (filters.initiated === true && tx.address !== address) {<EOL>        return false;<EOL>    }<EOL>    if (filters.initiated === false && tx.address === address) {<EOL>        return false;<EOL>    }<EOL>","gt":"if (filters.counterparty && !counterpartyFilter(filters, tx)) {"}
{"input":"<s> function ensureLedgerVersion(options: any): Promise<Object> {<EOL>    if (Boolean(options) && options.ledgerVersion !== undefined &&<EOL>        options.","gt":"ledgerVersion !== null) {"}
{"input":"<s> function generateAddressAPI(options?: Object): Object {<EOL>    validate.generateAddress({ options });<EOL>    try {<EOL>        return","gt":"generateAddress(options);"}
{"input":"<s> function convertMemo(memo: Memo): {<EOL>    Memo: ApiMemo;<EOL>} {<EOL>    return {<EOL>        Memo: common.removeUndefined({<EOL>            MemoData: memo.data ? convertStringToHex(memo.data) :","gt":"undefined,"}
{"input":"<s> <EOL>export function containsEs6Syntax(value: string): boolean {<EOL>    <EOL>    const","gt":"ES6_SYNTAX_REGEX: RegExp = /(^class | class )|(^const | const )|(^let | let )|(^async | async )|(^await | await )|(^yield | yield )|(=>)|function\\*|\\`/gm;"}
{"input":"<s> <EOL>export function Language(): PropertyDecorator {<EOL>    function DecoratorFactory(target: any, propertyKey?: string): void {<EOL>        let subscription: ISubscription;<EOL>        const targetNgOnInit: Function = target.","gt":"ngOnInit;"}
{"input":"<s> <EOL>export function Language(): PropertyDecorator {<EOL>    function DecoratorFactory(target: any, propertyKey?: string): void {<EOL>        let subscription: ISubscription;<EOL>        const targetNgOnInit: Function = target.ngOnInit;<EOL>        function ngOnInit(this: any): void {<EOL>            const translation: TranslationService = InjectorRef.get(TranslationService);<EOL>            if (typeof propertyKey !== \"<STR_LIT>\") {<EOL>                <EOL>                subscription = translation.translationChanged().subscribe((language: string): void => {<EOL>                    this[propertyKey] = language;<EOL>                });<EOL>            }<EOL>            if (targetNgOnInit) {<EOL>                targetNgOnInit.apply(this);<EOL>            }<EOL>        }<EOL>        target.ngOnInit = ngOnInit;<EOL>        const targetNgOnDestroy: Function = target.ngOnDestroy;<EOL>        function ngOnDestroy(this: any): void {<EOL>            if (typeof subscription !==","gt":"\"<STR_LIT>\") {"}
{"input":"<s> <EOL>export function Language(): PropertyDecorator {<EOL>    function DecoratorFactory(target: any, propertyKey?: string): void {<EOL>        let subscription: ISubscription;<EOL>        const targetNgOnInit: Function = target.ngOnInit;<EOL>        function ngOnInit(this: any): void {<EOL>            const translation: TranslationService = InjectorRef.get(TranslationService);<EOL>            if (typeof propertyKey !== \"<STR_LIT>\") {<EOL>                <EOL>                subscription = translation.translationChanged().subscribe((language: string): void => {<EOL>                    this[propertyKey] = language;<EOL>                });<EOL>            }<EOL>            if (targetNgOnInit) {<EOL>                targetNgOnInit.apply(this);<EOL>            }<EOL>        }<EOL>        target.ngOnInit = ngOnInit;<EOL>        const targetNgOnDestroy: Function = target.ngOnDestroy;<EOL>        function ngOnDestroy(this: any): void {<EOL>            if (typeof subscription !== \"<STR_LIT>\") {<EOL>                subscription.unsubscribe();<EOL>            }<EOL>            if (targetNgOnDestroy) {<EOL>                targetNgOnDestroy.apply(this);<EOL>            }<EOL>        }<EOL>        target.","gt":"ngOnDestroy = ngOnDestroy;"}
{"input":"<s> <EOL>export function l10nValidateNumber(digits: string, MIN_VALUE: number = Number.MIN_VALUE, MAX_VALUE: number = Number.MAX_VALUE): ValidatorFn {<EOL>    const locale: LocaleService = InjectorRef.get(LocaleService);<EOL>    const localeValidation: LocaleValidation = InjectorRef.get(LocaleValidation);<EOL>    let defaultLocale: string;<EOL>    let","gt":"NUMBER_REGEXP: RegExp;"}
{"input":"<s> <EOL>export function l10nValidateNumber(digits: string, MIN_VALUE: number = Number.MIN_VALUE, MAX_VALUE: number = Number.MAX_VALUE): ValidatorFn {<EOL>    const locale: LocaleService = InjectorRef.get(LocaleService);<EOL>    const localeValidation: LocaleValidation = InjectorRef.get(LocaleValidation);<EOL>    let defaultLocale: string;<EOL>    let NUMBER_REGEXP: RegExp;<EOL>    return (","gt":"formControl: FormControl): ValidationErrors | null => {"}
{"input":"<s> <EOL>export function l10nValidateNumber(digits: string, MIN_VALUE: number = Number.MIN_VALUE, MAX_VALUE: number = Number.MAX_VALUE): ValidatorFn {<EOL>    const locale: LocaleService = InjectorRef.get(LocaleService);<EOL>    const localeValidation: LocaleValidation = InjectorRef.get(LocaleValidation);<EOL>    let defaultLocale: string;<EOL>    let NUMBER_REGEXP: RegExp;<EOL>    return (formControl: FormControl): ValidationErrors | null => {<EOL>        if (formControl.value == null || formControl.value == \"<STR_LIT>\")<EOL>","gt":"return null;"}
{"input":"<s> <EOL>export function l10nValidateNumber(digits: string, MIN_VALUE: number = Number.MIN_VALUE, MAX_VALUE: number = Number.MAX_VALUE): ValidatorFn {<EOL>    const locale: LocaleService = InjectorRef.get(LocaleService);<EOL>    const localeValidation: LocaleValidation = InjectorRef.get(LocaleValidation);<EOL>    let defaultLocale: string;<EOL>    let NUMBER_REGEXP: RegExp;<EOL>    return (formControl: FormControl): ValidationErrors | null => {<EOL>        if (formControl.value == null || formControl.value == \"<STR_LIT>\")<EOL>            return null;<EOL>        if (defaultLocale != locale.getDefaultLocale()) {<EOL>            NUMBER_REGEXP = localeValidation.getRegExp(digits);<EOL>            defaultLocale = locale.getDefaultLocale();<EOL>        }<EOL>        if (NUMBER_REGEXP.test(formControl.","gt":"value)) {"}
{"input":"<s> <EOL>export function l10nValidateNumber(digits: string, MIN_VALUE: number = Number.MIN_VALUE, MAX_VALUE: number = Number.MAX_VALUE): ValidatorFn {<EOL>    const locale: LocaleService = InjectorRef.get(LocaleService);<EOL>    const localeValidation: LocaleValidation = InjectorRef.get(LocaleValidation);<EOL>    let defaultLocale: string;<EOL>    let NUMBER_REGEXP: RegExp;<EOL>    return (formControl: FormControl): ValidationErrors | null => {<EOL>        if (formControl.value == null || formControl.value == \"<STR_LIT>\")<EOL>            return null;<EOL>        if (defaultLocale != locale.getDefaultLocale()) {<EOL>            NUMBER_REGEXP = localeValidation.getRegExp(digits);<EOL>            defaultLocale = locale.getDefaultLocale();<EOL>        }<EOL>        if (NUMBER_REGEXP.test(formControl.value)) {<EOL>            const parsedValue: number | null = localeValidation.parseNumber(formControl.value);<EOL>            if (parsedValue != null && parsedValue < MIN_VALUE) {<EOL>                return {<EOL>","gt":"minValue: {"}
{"input":"<s> <EOL>export function l10nValidateNumber(digits: string, MIN_VALUE: number = Number.MIN_VALUE, MAX_VALUE: number = Number.MAX_VALUE): ValidatorFn {<EOL>    const locale: LocaleService = InjectorRef.get(LocaleService);<EOL>    const localeValidation: LocaleValidation = InjectorRef.get(LocaleValidation);<EOL>    let defaultLocale: string;<EOL>    let NUMBER_REGEXP: RegExp;<EOL>    return (formControl: FormControl): ValidationErrors | null => {<EOL>        if (formControl.value == null || formControl.value == \"<STR_LIT>\")<EOL>            return null;<EOL>        if (defaultLocale != locale.getDefaultLocale()) {<EOL>            NUMBER_REGEXP = localeValidation.getRegExp(digits);<EOL>            defaultLocale = locale.getDefaultLocale();<EOL>        }<EOL>        if (NUMBER_REGEXP.test(formControl.value)) {<EOL>            const parsedValue: number | null = localeValidation.parseNumber(formControl.value);<EOL>            if (parsedValue != null && parsedValue < MIN_VALUE) {<EOL>                return {<EOL>                    minValue: {<EOL>                        valid: false<EOL>                    }<EOL>                };<EOL>            }<EOL>            else if (parsedValue != null && parsedValue > MAX_VALUE) {<EOL>                return {<EOL>                    maxValue: {<EOL>                        valid: false<EOL>                    }<EOL>                };<EOL>            }<EOL>","gt":"return null;"}
{"input":"<s> <EOL>export function CookiesParams(expression?: string | any, useType?: any): Function {<EOL>    return ParamRegistry.decorate(","gt":"CookiesFilter, { expression, useType });"}
{"input":"<s> <EOL>export function isDate(target: any): boolean {<EOL>    return target === Date ||","gt":"target instanceof Date;"}
{"input":"<s> <EOL>export function inject(targets: any[], func: Function): (done: Function) => void {<EOL>    loadInjector();<EOL>    return (done: Function): void => {<EOL>        let isDoneInjected: boolean = false;<EOL>        const args: unknown[] = targets.map((target: any): unknown => {<EOL>            if (target === Done) {<EOL>                isDoneInjected =","gt":"true;"}
{"input":"<s> <EOL>export function inject(targets: any[], func: Function): (done: Function) => void {<EOL>    loadInjector();<EOL>    return (done: Function): void => {<EOL>        let isDoneInjected: boolean = false;<EOL>        const args: unknown[] = targets.map((target: any): unknown => {<EOL>            if (target === Done) {<EOL>                isDoneInjected = true;<EOL>                return done;<EOL>            }<EOL>            <EOL>","gt":"if (!InjectorService.has(target)) {"}
{"input":"<s> function visitOp(n: N, c: Ctx, depth: number): any {<EOL>    <EOL>    switch (n.t) {<EOL>        case t.","gt":"instr: {"}
{"input":"<s> function visitOp(n: N, c: Ctx, depth: number): any {<EOL>    <EOL>    switch (n.t) {<EOL>        case t.instr: {<EOL>            if (n.v == <NUM_LIT> || n.v == <NUM_LIT> ) {<EOL>                depth--;<EOL>            }<EOL>","gt":"return c.writeln(depth, opcodes.get(n.v));"}
{"input":"<s> function visitOp(n: N, c: Ctx, depth: number): any {<EOL>    <EOL>    switch (n.t) {<EOL>        case t.instr: {<EOL>            if (n.v == <NUM_LIT> || n.v == <NUM_LIT> ) {<EOL>                depth--;<EOL>            }<EOL>            return c.writeln(depth, opcodes.get(n.v));<EOL>        }<EOL>        case t.instr_imm1: {<EOL>            return c.writeln(depth, opcodes.get(n.v) + '<STR_LIT>' + fmtimm((n as AnyOp).imm as N));<EOL>        }<EOL>","gt":"case t.instr_pre: {"}
{"input":"<s> function visitOp(n: N, c: Ctx, depth: number): any {<EOL>    <EOL>    switch (n.t) {<EOL>        case t.instr: {<EOL>            if (n.v == <NUM_LIT> || n.v == <NUM_LIT> ) {<EOL>                depth--;<EOL>            }<EOL>            return c.writeln(depth, opcodes.get(n.v));<EOL>        }<EOL>        case t.instr_imm1: {<EOL>            return c.writeln(depth, opcodes.get(n.v) + '<STR_LIT>' + fmtimm((n as AnyOp).imm as N));<EOL>        }<EOL>        case t.instr_pre: {<EOL>            visitOps((n as AnyOp).pre as N[], c, depth);<EOL>            return c.writeln(depth, opcodes.get(n.v));<EOL>        }<EOL>        case t.instr_pre1: {<EOL>            visitOp((n as AnyOp).pre as N, c, depth);<EOL>            return c.writeln(depth, opcodes.get(n.v));<EOL>        }<EOL>","gt":"case t.instr_imm1_post: {"}
{"input":"<s> function visitOp(n: N, c: Ctx, depth: number): any {<EOL>    <EOL>    switch (n.t) {<EOL>        case t.instr: {<EOL>            if (n.v == <NUM_LIT> || n.v == <NUM_LIT> ) {<EOL>                depth--;<EOL>            }<EOL>            return c.writeln(depth, opcodes.get(n.v));<EOL>        }<EOL>        case t.instr_imm1: {<EOL>            return c.writeln(depth, opcodes.get(n.v) + '<STR_LIT>' + fmtimm((n as AnyOp).imm as N));<EOL>        }<EOL>        case t.instr_pre: {<EOL>            visitOps((n as AnyOp).pre as N[], c, depth);<EOL>            return c.writeln(depth, opcodes.get(n.v));<EOL>        }<EOL>        case t.instr_pre1: {<EOL>            visitOp((n as AnyOp).pre as N, c, depth);<EOL>            return c.writeln(depth, opcodes.get(n.v));<EOL>        }<EOL>        case t.instr_imm1_post: {<EOL>            c.writeln(depth, opcodes.get(n.v) + '<STR_LIT>' + fmtimm((n as AnyOp).imm as N));<EOL>            return visitOps((n as AnyOp).post as N[], c, depth + <NUM_LIT>);<EOL>        }<EOL>        case t.instr_pre_imm: {<EOL>            visitOps((n as AnyOp).pre as N[], c, depth);<EOL>            return c.writeln(depth, opcodes.get(n.v) + fmtimmv((n as AnyOp).imm as N[]));<EOL>        }<EOL>","gt":"case t.instr_pre_imm_post: {"}
{"input":"<s> <EOL><EOL>export function concatMapTo<T, I, R>(this: Observable<T>, innerObservable: Observable<I>, resultSelector?: (outerValue: T, innerValue: I, outerIndex: number, innerIndex: number) => R): Observable<R> {<EOL>    return","gt":"this.lift(new MergeMapToOperator(innerObservable, resultSelector, <NUM_LIT>));"}
{"input":"<s> <EOL><EOL>export function distinctUntilChanged<T, K>(this: Observable<T>, compare?: (x: K, y: K) => boolean, keySelector?: (x: T) => K): Observable<T> {<EOL>","gt":"return this.lift(new DistinctUntilChangedOperator<T, K>(compare, keySelector));"}
{"input":"<s> <EOL><EOL>export function _do<T>(this: Observable<T>, nextOrObserver?: PartialObserver<T> | ((x: T) => void), error?: (e: any) => void, complete?: () => void): Observable<T> {<EOL>    return this.lift(","gt":"new DoOperator(nextOrObserver, error, complete));"}
{"input":"<s> <EOL>export function partition<T>(this: Observable<T>, predicate: (value: T) => boolean, thisArg?: any): [<EOL>    Observable<T>,<EOL>    Observable<T><EOL>] {<EOL>    return [<EOL>","gt":"filter.call(this, predicate, thisArg),"}
{"input":"<s> <EOL><EOL>export function switchMapTo<T, I, R>(this: Observable<T>, innerObservable: Observable<I>, resultSelector?: (outerValue: T, innerValue: I, outerIndex: number, innerIndex: number) => R): Observable<I | R> {<EOL>","gt":"return this.lift(new SwitchMapToOperator(innerObservable, resultSelector));"}
{"input":"<s> <EOL>export function timestamp<T>(this: Observable<T>, scheduler: IScheduler = async): Observable<Timestamp<T>> {<EOL>    return","gt":"this.lift(new TimestampOperator(scheduler));"}
{"input":"<s> async function swActivate(): Promise<void> {<EOL>    const keys: string[] = await caches.keys();<EOL>    let deletes: any[] = [];<EOL>    for (var key: string of","gt":"keys) {"}
{"input":"<s> async function swInstall(): Promise<void> {<EOL>    const rs: Response = await fetch('<STR_LIT>');<EOL>","gt":"const body: string = await rs.text();"}
{"input":"<s> function onTouchMove(e: TouchEvent | PointerEvent): void {<EOL>    if (appState.pickerOpen) {<EOL>","gt":"return;"}
{"input":"<s> export function Info(): Injectify.info {<EOL>    <EOL>    let project: string = ws.url.split('<STR_LIT>')[<NUM_LIT>];<EOL>    if (injectify.debug)<EOL>        project = project.substring(<NUM_LIT>);<EOL>    <EOL>    let url: string[] = ws.url.split('<STR_LIT>');<EOL>    let protocol: string = `<STR_LIT>`;<EOL>    let server: string = protocol + url[","gt":"<NUM_LIT>];"}
{"input":"<s> export function Info(): Injectify.info {<EOL>    <EOL>    let project: string = ws.url.split('<STR_LIT>')[<NUM_LIT>];<EOL>    if (injectify.debug)<EOL>        project = project.substring(<NUM_LIT>);<EOL>    <EOL>    let url: string[] = ws.url.split('<STR_LIT>');<EOL>    let protocol: string = `<STR_LIT>`;<EOL>    let server: string = protocol + url[<NUM_LIT>];<EOL>    return {<EOL>        '<STR_LIT>': atob(project),<EOL>        '<STR_LIT>': {<EOL>            '<STR_LIT>': ws.url,<EOL>            '<STR_LIT>':","gt":"server"}
{"input":"<s> export function Info(): Injectify.info {<EOL>    <EOL>    let project: string = ws.url.split('<STR_LIT>')[<NUM_LIT>];<EOL>    if (injectify.debug)<EOL>        project = project.substring(<NUM_LIT>);<EOL>    <EOL>    let url: string[] = ws.url.split('<STR_LIT>');<EOL>    let protocol: string = `<STR_LIT>`;<EOL>    let server: string = protocol + url[<NUM_LIT>];<EOL>    return {<EOL>        '<STR_LIT>': atob(project),<EOL>        '<STR_LIT>': {<EOL>            '<STR_LIT>': ws.url,<EOL>            '<STR_LIT>': server<EOL>        },<EOL>        '<STR_LIT>': client.id,<EOL>        '<STR_LIT>': client.platform,<EOL>        '<STR_LIT>': injectify.duration,<EOL>        '<STR_LIT>': injectify.debug,<EOL>        '<STR_LIT>':","gt":"client.os,"}
{"input":"<s> <EOL>export function generateParserModule(options: {<EOL>    name: string;<EOL>    rules: Rule[];<EOL>}): string {<EOL>    return genUmdModule({ name: options.name, rules: options.","gt":"rules });"}
{"input":"<s> export function getProductionOverriddenForClass(className: string): HashTable<boolean> {<EOL>    return","gt":"getFromNestedHashTable(className, CLASS_TO_PRODUCTION_OVERRIDEN);"}
{"input":"<s> export function addTerminalToCst(node: CstNode, token: IToken, tokenTypeName: string): void {<EOL>    if (node.children[tokenTypeName] === undefined) {<EOL>","gt":"node.children[tokenTypeName] = [token];"}
{"input":"<s> function buildManySepProd(prodRange: IProdRange, allRanges: IProdRange[]): RepetitionWithSeparator {<EOL>    return buildRepetitionWithSep(prodRange, allRanges,","gt":"RepetitionWithSeparator, manyWithSeparatorRegEx);"}
{"input":"<s> export function createAtLeastOneSepRanges(text: string): IProdRange[] {<EOL>","gt":"return createOperatorProdRangeParenthesis(text, ProdType.AT_LEAST_ONE_SEP, atLeastOneWithSeparatorRegExGlobal);"}
{"input":"<s> function createOperatorProdRangeInternal(text: string, prodType: ProdType, pattern: RegExp, findTerminatorOffSet: (startAt: number, text: string) => number): IProdRange[] {<EOL>    let operatorRanges: IProdRange[] = [];<EOL>    let matched: RegExpExecArray;<EOL>    while ((matched = pattern.exec(text))) {<EOL>        let start: number = matched.index;<EOL>        <EOL>        let stop: number = findTerminatorOffSet(start + matched[<NUM_LIT>].length, text);<EOL>        let currRange: Range = new Range(start, stop);<EOL>        let currText: string = text.substr(start, stop - start + <NUM_LIT>);<EOL>","gt":"operatorRanges.push({"}
{"input":"<s> function createOperatorProdRangeInternal(text: string, prodType: ProdType, pattern: RegExp, findTerminatorOffSet: (startAt: number, text: string) => number): IProdRange[] {<EOL>    let operatorRanges: IProdRange[] = [];<EOL>    let matched: RegExpExecArray;<EOL>    while ((matched = pattern.exec(text))) {<EOL>        let start: number = matched.index;<EOL>        <EOL>        let stop: number = findTerminatorOffSet(start + matched[<NUM_LIT>].length, text);<EOL>        let currRange: Range = new Range(start, stop);<EOL>        let currText: string = text.substr(start, stop - start + <NUM_LIT>);<EOL>        operatorRanges.push({<EOL>            range: currRange,<EOL>            text: currText,<EOL>","gt":"type: prodType"}
{"input":"<s> function createRefOrTerminalProdRangeInternal(text: string, prodType: ProdType, pattern: RegExp): IProdRange[] {<EOL>    let prodRanges: IProdRange[] = [];<EOL>    let matched: RegExpExecArray;<EOL>    while ((matched = pattern.exec(text))) {<EOL>        let start: number = matched.index;<EOL>","gt":"let stop: number = pattern.lastIndex;"}
{"input":"<s> function createRefOrTerminalProdRangeInternal(text: string, prodType: ProdType, pattern: RegExp): IProdRange[] {<EOL>    let prodRanges: IProdRange[] = [];<EOL>    let matched: RegExpExecArray;<EOL>    while ((matched = pattern.exec(text))) {<EOL>        let start: number = matched.index;<EOL>        let stop: number = pattern.lastIndex;<EOL>        let currRange: Range = new Range(start, stop);<EOL>        let currText: string = matched[<NUM_LIT>];<EOL>        prodRanges.push({<EOL>            range: currRange,<EOL>            text: currText,<EOL>            type:","gt":"prodType"}
{"input":"<s> export function hasExtendingTokensTypesProperty(tokType: TokenType): boolean {<EOL>    return has(tokType,","gt":"\"<STR_LIT>\");"}
{"input":"<s> export function tokenStructuredMatcher(tokInstance: any, tokConstructor: any): boolean {<EOL>    const instanceType: any = tokInstance.tokenTypeIdx;<EOL>    if (instanceType === tokConstructor.tokenTypeIdx) {<EOL>","gt":"return true;"}
{"input":"<s> function objectBoxStyle(size: BoxSizeObject): SizeStyle {<EOL>    let width: string = '<STR_LIT>';<EOL>    let height: string = '<STR_LIT>';<EOL>    if (size.vertical) {<EOL>        height = size.vertical === '<STR_LIT>'<EOL>            ?","gt":"'<STR_LIT>'"}
{"input":"<s> function objectBoxStyle(size: BoxSizeObject): SizeStyle {<EOL>    let width: string = '<STR_LIT>';<EOL>    let height: string = '<STR_LIT>';<EOL>    if (size.vertical) {<EOL>        height = size.vertical === '<STR_LIT>'<EOL>            ? '<STR_LIT>'<EOL>            : `<STR_LIT>`;<EOL>    }<EOL>    if (size.horizontal) {<EOL>        width =","gt":"size.horizontal === '<STR_LIT>'"}
{"input":"<s> function objectBoxStyle(size: BoxSizeObject): SizeStyle {<EOL>    let width: string = '<STR_LIT>';<EOL>    let height: string = '<STR_LIT>';<EOL>    if (size.vertical) {<EOL>        height = size.vertical === '<STR_LIT>'<EOL>            ? '<STR_LIT>'<EOL>            : `<STR_LIT>`;<EOL>    }<EOL>    if (size.horizontal) {<EOL>        width = size.horizontal === '<STR_LIT>'<EOL>            ? '<STR_LIT>'<EOL>            : `<STR_LIT>`;<EOL>    }<EOL>","gt":"return {"}
{"input":"<s> async function textViewerCommandExecutor(textViewer: TextViewer, commandId: string, commandArguments?: object): Promise<any> {<EOL>    const selectedTabSize: any = await textViewer.getTab().showNumberInput({<EOL>        title: \"<STR_LIT>\",<EOL>        value:","gt":"textViewer.getTabSize(),"}
{"input":"<s> function getConfig(): Config {<EOL>    return","gt":"config;"}
{"input":"<s> function pathToUrl(path: string): string {<EOL>    if (process.platform === \"<STR_LIT>\") {<EOL>","gt":"return path.replace(/\\\\/g, \"<STR_LIT>\");"}
{"input":"<s> function readDefaultUserShell(userName: string): string {<EOL>    if (process.platform === \"<STR_LIT>\") {<EOL>        return readDefaultUserShellFromOpenDirectory(","gt":"userName);"}
{"input":"<s> <EOL>function replaceInSelection(cm: CodeMirror.Editor, searchExp: RegExp, replacement: string): void {<EOL>    const selectionsText: any = cm.getDoc().getSelections();<EOL>","gt":"const replacements: any = selectionsText.map((str: any): any => {"}
{"input":"<s> function readEmulatorScreenString(emulator: Emulator): string {<EOL>    let result: string = lineToString(emulator.lineAtRow(<NUM_LIT>));<EOL>    let row: number = <NUM_LIT>;<EOL>    while (true) {<EOL>        const line: Line = emulator.","gt":"lineAtRow(row);"}
{"input":"<s> function readEmulatorScreenString(emulator: Emulator): string {<EOL>    let result: string = lineToString(emulator.lineAtRow(<NUM_LIT>));<EOL>    let row: number = <NUM_LIT>;<EOL>    while (true) {<EOL>        const line: Line = emulator.lineAtRow(row);<EOL>        if (line == null) {<EOL>            break;<EOL>        }<EOL>        result += '<STR_LIT>' + lineToString(line);<EOL>","gt":"row++;"}
{"input":"<s> <EOL>export function to2DigitHex(value: number): string {<EOL>    const h:","gt":"string = value.toString(<NUM_LIT>);"}
{"input":"<s> function handleCommandPaletteRequest(ev: CustomEvent): void {<EOL>    const path: Node[] = ev.composedPath();<EOL>    const requestCommandableStack: Commandable[] = <any>path.filter((el: Node): boolean => isCommandable(el));<EOL>    doLater((): void => {<EOL>        const commandableStack:","gt":"Commandable[] = [...requestCommandableStack, { executeCommand, getCommandPaletteEntries }];"}
{"input":"<s> function handleCommandPaletteRequest(ev: CustomEvent): void {<EOL>    const path: Node[] = ev.composedPath();<EOL>    const requestCommandableStack: Commandable[] = <any>path.filter((el: Node): boolean => isCommandable(el));<EOL>    doLater((): void => {<EOL>        const commandableStack: Commandable[] = [...requestCommandableStack, { executeCommand, getCommandPaletteEntries }];<EOL>        const firstCommandable:","gt":"Commandable = commandableStack[<NUM_LIT>];"}
{"input":"<s> function handleCommandPaletteRequest(ev: CustomEvent): void {<EOL>    const path: Node[] = ev.composedPath();<EOL>    const requestCommandableStack: Commandable[] = <any>path.filter((el: Node): boolean => isCommandable(el));<EOL>    doLater((): void => {<EOL>        const commandableStack: Commandable[] = [...requestCommandableStack, { executeCommand, getCommandPaletteEntries }];<EOL>        const firstCommandable: Commandable = commandableStack[<NUM_LIT>];<EOL>        if (firstCommandable instanceof HTMLElement) {<EOL>            commandPaletteRequestSource = firstCommandable;<EOL>        }<EOL>        commandPaletteRequestEntries = _.flatten(commandableStack.map((commandable: Commandable): CommandEntry[] => {<EOL>            let result: CommandEntry[] = commandable.getCommandPaletteEntries(commandableStack);<EOL>            if (commandable instanceof EtTerminal) {<EOL>                result = [...result, ...extensionManager.getExtensionBridge().getWorkspaceTerminalCommands(commandable)];<EOL>            }<EOL>            else if (commandable instanceof TextViewer) {<EOL>                result = [...result, ...extensionManager.getExtensionBridge().getWorkspaceTextViewerCommands(commandable)];<EOL>            }<EOL>","gt":"return result;"}
{"input":"<s> function handleCommandPaletteRequest(ev: CustomEvent): void {<EOL>    const path: Node[] = ev.composedPath();<EOL>    const requestCommandableStack: Commandable[] = <any>path.filter((el: Node): boolean => isCommandable(el));<EOL>    doLater((): void => {<EOL>        const commandableStack: Commandable[] = [...requestCommandableStack, { executeCommand, getCommandPaletteEntries }];<EOL>        const firstCommandable: Commandable = commandableStack[<NUM_LIT>];<EOL>        if (firstCommandable instanceof HTMLElement) {<EOL>            commandPaletteRequestSource = firstCommandable;<EOL>        }<EOL>        commandPaletteRequestEntries = _.flatten(commandableStack.map((commandable: Commandable): CommandEntry[] => {<EOL>            let result: CommandEntry[] = commandable.getCommandPaletteEntries(commandableStack);<EOL>            if (commandable instanceof EtTerminal) {<EOL>                result = [...result, ...extensionManager.getExtensionBridge().getWorkspaceTerminalCommands(commandable)];<EOL>            }<EOL>            else if (commandable instanceof TextViewer) {<EOL>                result = [...result, ...extensionManager.getExtensionBridge().getWorkspaceTextViewerCommands(commandable)];<EOL>            }<EOL>            return result;<EOL>        }));<EOL>        const paletteEntries: CommandMenuItem[] = commandPaletteRequestEntries.map((entry, index): CommandMenuItem => {<EOL>            return {<EOL>                id: \"<STR_LIT>\" +","gt":"index,"}
{"input":"<s> function handleCommandPaletteRequest(ev: CustomEvent): void {<EOL>    const path: Node[] = ev.composedPath();<EOL>    const requestCommandableStack: Commandable[] = <any>path.filter((el: Node): boolean => isCommandable(el));<EOL>    doLater((): void => {<EOL>        const commandableStack: Commandable[] = [...requestCommandableStack, { executeCommand, getCommandPaletteEntries }];<EOL>        const firstCommandable: Commandable = commandableStack[<NUM_LIT>];<EOL>        if (firstCommandable instanceof HTMLElement) {<EOL>            commandPaletteRequestSource = firstCommandable;<EOL>        }<EOL>        commandPaletteRequestEntries = _.flatten(commandableStack.map((commandable: Commandable): CommandEntry[] => {<EOL>            let result: CommandEntry[] = commandable.getCommandPaletteEntries(commandableStack);<EOL>            if (commandable instanceof EtTerminal) {<EOL>                result = [...result, ...extensionManager.getExtensionBridge().getWorkspaceTerminalCommands(commandable)];<EOL>            }<EOL>            else if (commandable instanceof TextViewer) {<EOL>                result = [...result, ...extensionManager.getExtensionBridge().getWorkspaceTextViewerCommands(commandable)];<EOL>            }<EOL>            return result;<EOL>        }));<EOL>        const paletteEntries: CommandMenuItem[] = commandPaletteRequestEntries.map((entry, index): CommandMenuItem => {<EOL>            return {<EOL>                id: \"<STR_LIT>\" + index,<EOL>                group: entry.group,<EOL>                iconLeft: entry.iconLeft,<EOL>                iconRight: entry.iconRight,<EOL>                label: entry.label,<EOL>                shortcut: entry.shortcut<EOL>            };<EOL>        });<EOL>        const shortcut: string = keyBindingManager.getKeyBindingContexts().context(\"<STR_LIT>\").mapCommandToKeyBinding(\"<STR_LIT>\");<EOL>        commandPalette.titleSecondary = shortcut !== null ? shortcut : \"<STR_LIT>\";<EOL>","gt":"commandPalette.setEntries(paletteEntries);"}
{"input":"<s> function handleCommandPaletteRequest(ev: CustomEvent): void {<EOL>    const path: Node[] = ev.composedPath();<EOL>    const requestCommandableStack: Commandable[] = <any>path.filter((el: Node): boolean => isCommandable(el));<EOL>    doLater((): void => {<EOL>        const commandableStack: Commandable[] = [...requestCommandableStack, { executeCommand, getCommandPaletteEntries }];<EOL>        const firstCommandable: Commandable = commandableStack[<NUM_LIT>];<EOL>        if (firstCommandable instanceof HTMLElement) {<EOL>            commandPaletteRequestSource = firstCommandable;<EOL>        }<EOL>        commandPaletteRequestEntries = _.flatten(commandableStack.map((commandable: Commandable): CommandEntry[] => {<EOL>            let result: CommandEntry[] = commandable.getCommandPaletteEntries(commandableStack);<EOL>            if (commandable instanceof EtTerminal) {<EOL>                result = [...result, ...extensionManager.getExtensionBridge().getWorkspaceTerminalCommands(commandable)];<EOL>            }<EOL>            else if (commandable instanceof TextViewer) {<EOL>                result = [...result, ...extensionManager.getExtensionBridge().getWorkspaceTextViewerCommands(commandable)];<EOL>            }<EOL>            return result;<EOL>        }));<EOL>        const paletteEntries: CommandMenuItem[] = commandPaletteRequestEntries.map((entry, index): CommandMenuItem => {<EOL>            return {<EOL>                id: \"<STR_LIT>\" + index,<EOL>                group: entry.group,<EOL>                iconLeft: entry.iconLeft,<EOL>                iconRight: entry.iconRight,<EOL>                label: entry.label,<EOL>                shortcut: entry.shortcut<EOL>            };<EOL>        });<EOL>        const shortcut: string = keyBindingManager.getKeyBindingContexts().context(\"<STR_LIT>\").mapCommandToKeyBinding(\"<STR_LIT>\");<EOL>        commandPalette.titleSecondary = shortcut !== null ? shortcut : \"<STR_LIT>\";<EOL>        commandPalette.setEntries(paletteEntries);<EOL>        const contextElement: Commandable = requestCommandableStack[requestCommandableStack.length - <NUM_LIT>];<EOL>        if (SupportsDialogStack.isSupportsDialogStack(contextElement)) {<EOL>            commandPaletteDisposable =","gt":"contextElement.showDialog(commandPalette);"}
{"input":"<s> function handleDevToolsStatus(msg: Messages.Message): void {<EOL>    const devToolsStatusMessage: Messages.DevToolsStatusMessage = <Messages.DevToolsStatusMessage>msg;<EOL>    const developerToolMenu: CheckboxMenuItem = <CheckboxMenuItem>document.getElementById(","gt":"\"<STR_LIT>\");"}
{"input":"<s> function elementSupportsFocus(content: Element | Focusable): content is Focusable {<EOL>    return content instanceof EtTerminal || content instanceof EmptyPaneMenu || content instanceof","gt":"EtViewerTab;"}
{"input":"<s> function findPathToTabWidget(infoNode: RootInfoNode, tabWidget: TabWidget): InfoNode[] {<EOL>    if (infoNode.type === \"<STR_LIT>\") {<EOL>        for (const kid: SplitterInfoNode | TabWidgetInfoNode of infoNode.children) {<EOL>            const path: InfoNode[] = findPathToTabWidget(kid, tabWidget);<EOL>            if (path != null) {<EOL>                return [","gt":"infoNode, ...path];"}
{"input":"<s> function findPathToTabWidget(infoNode: RootInfoNode, tabWidget: TabWidget): InfoNode[] {<EOL>    if (infoNode.type === \"<STR_LIT>\") {<EOL>        for (const kid: SplitterInfoNode | TabWidgetInfoNode of infoNode.children) {<EOL>            const path: InfoNode[] = findPathToTabWidget(kid, tabWidget);<EOL>            if (path != null) {<EOL>                return [infoNode, ...path];<EOL>            }<EOL>        }<EOL>        return null;<EOL>    }<EOL>    else {<EOL>        if (infoNode.tabWidget === tabWidget) {<EOL>            return [","gt":"infoNode];"}
{"input":"<s> function getCssText(): string {<EOL>    return","gt":"cssText;"}
{"input":"<s> function px(value: any): number {<EOL>    if (value === null || value === undefined || value === \"<STR_LIT>\") {<EOL>","gt":"return <NUM_LIT>;"}
{"input":"<s> export function test3Scrollables(test: nodeunit.Test): void {<EOL>    const vsa: VirtualScrollArea.VirtualScrollArea = new VirtualScrollArea.VirtualScrollArea();<EOL>    const scrollbar: SuperScrollbar = SetupScrollbar(vsa);<EOL>    const","gt":"container: HTMLElement = SetUpScrollContainer(vsa, <NUM_LIT>);"}
{"input":"<s> export function test3Scrollables(test: nodeunit.Test): void {<EOL>    const vsa: VirtualScrollArea.VirtualScrollArea = new VirtualScrollArea.VirtualScrollArea();<EOL>    const scrollbar: SuperScrollbar = SetupScrollbar(vsa);<EOL>    const container: HTMLElement = SetUpScrollContainer(vsa, <NUM_LIT>);<EOL>    const scrollable1: VirtualScrollableWithExtra = SetupScrollable(vsa, <NUM_LIT>, <NUM_LIT>, <NUM_LIT>);<EOL>    const scrollable2: VirtualScrollableWithExtra = SetupScrollable(","gt":"vsa, <NUM_LIT>, <NUM_LIT>, <NUM_LIT>);"}
{"input":"<s> export function test3Scrollables(test: nodeunit.Test): void {<EOL>    const vsa: VirtualScrollArea.VirtualScrollArea = new VirtualScrollArea.VirtualScrollArea();<EOL>    const scrollbar: SuperScrollbar = SetupScrollbar(vsa);<EOL>    const container: HTMLElement = SetUpScrollContainer(vsa, <NUM_LIT>);<EOL>    const scrollable1: VirtualScrollableWithExtra = SetupScrollable(vsa, <NUM_LIT>, <NUM_LIT>, <NUM_LIT>);<EOL>    const scrollable2: VirtualScrollableWithExtra = SetupScrollable(vsa, <NUM_LIT>, <NUM_LIT>, <NUM_LIT>);<EOL>    const scrollable3: VirtualScrollableWithExtra = SetupScrollable(vsa, <NUM_LIT>, <NUM_LIT>, <NUM_LIT>);<EOL>    vsa.updateContainerHeight(","gt":"container.getBoundingClientRect().height);"}
{"input":"<s> export function test3Scrollables(test: nodeunit.Test): void {<EOL>    const vsa: VirtualScrollArea.VirtualScrollArea = new VirtualScrollArea.VirtualScrollArea();<EOL>    const scrollbar: SuperScrollbar = SetupScrollbar(vsa);<EOL>    const container: HTMLElement = SetUpScrollContainer(vsa, <NUM_LIT>);<EOL>    const scrollable1: VirtualScrollableWithExtra = SetupScrollable(vsa, <NUM_LIT>, <NUM_LIT>, <NUM_LIT>);<EOL>    const scrollable2: VirtualScrollableWithExtra = SetupScrollable(vsa, <NUM_LIT>, <NUM_LIT>, <NUM_LIT>);<EOL>    const scrollable3: VirtualScrollableWithExtra = SetupScrollable(vsa, <NUM_LIT>, <NUM_LIT>, <NUM_LIT>);<EOL>    vsa.updateContainerHeight(container.getBoundingClientRect().height);<EOL>    test.equal(scrollbar.getPosition(), <NUM_LIT>);<EOL>    test.equal(scrollbar.getLength(), <NUM_LIT>);<EOL>    test.equal(scrollable1.getScrollOffset(), <NUM_LIT>);<EOL>","gt":"vsa.scrollTo(<NUM_LIT>);"}
{"input":"<s> export function test3Scrollables(test: nodeunit.Test): void {<EOL>    const vsa: VirtualScrollArea.VirtualScrollArea = new VirtualScrollArea.VirtualScrollArea();<EOL>    const scrollbar: SuperScrollbar = SetupScrollbar(vsa);<EOL>    const container: HTMLElement = SetUpScrollContainer(vsa, <NUM_LIT>);<EOL>    const scrollable1: VirtualScrollableWithExtra = SetupScrollable(vsa, <NUM_LIT>, <NUM_LIT>, <NUM_LIT>);<EOL>    const scrollable2: VirtualScrollableWithExtra = SetupScrollable(vsa, <NUM_LIT>, <NUM_LIT>, <NUM_LIT>);<EOL>    const scrollable3: VirtualScrollableWithExtra = SetupScrollable(vsa, <NUM_LIT>, <NUM_LIT>, <NUM_LIT>);<EOL>    vsa.updateContainerHeight(container.getBoundingClientRect().height);<EOL>    test.equal(scrollbar.getPosition(), <NUM_LIT>);<EOL>    test.equal(scrollbar.getLength(), <NUM_LIT>);<EOL>    test.equal(scrollable1.getScrollOffset(), <NUM_LIT>);<EOL>    vsa.scrollTo(<NUM_LIT>);<EOL>    test.equal(scrollbar.getPosition(), <NUM_LIT>);<EOL>    test.equal(container.scrollTop, <NUM_LIT>);<EOL>    test.equal(scrollable1.getScrollOffset(), <NUM_LIT>);<EOL>    test.equal(","gt":"scrollable2.getScrollOffset(), <NUM_LIT>);"}
{"input":"<s> export function test3Scrollables(test: nodeunit.Test): void {<EOL>    const vsa: VirtualScrollArea.VirtualScrollArea = new VirtualScrollArea.VirtualScrollArea();<EOL>    const scrollbar: SuperScrollbar = SetupScrollbar(vsa);<EOL>    const container: HTMLElement = SetUpScrollContainer(vsa, <NUM_LIT>);<EOL>    const scrollable1: VirtualScrollableWithExtra = SetupScrollable(vsa, <NUM_LIT>, <NUM_LIT>, <NUM_LIT>);<EOL>    const scrollable2: VirtualScrollableWithExtra = SetupScrollable(vsa, <NUM_LIT>, <NUM_LIT>, <NUM_LIT>);<EOL>    const scrollable3: VirtualScrollableWithExtra = SetupScrollable(vsa, <NUM_LIT>, <NUM_LIT>, <NUM_LIT>);<EOL>    vsa.updateContainerHeight(container.getBoundingClientRect().height);<EOL>    test.equal(scrollbar.getPosition(), <NUM_LIT>);<EOL>    test.equal(scrollbar.getLength(), <NUM_LIT>);<EOL>    test.equal(scrollable1.getScrollOffset(), <NUM_LIT>);<EOL>    vsa.scrollTo(<NUM_LIT>);<EOL>    test.equal(scrollbar.getPosition(), <NUM_LIT>);<EOL>    test.equal(container.scrollTop, <NUM_LIT>);<EOL>    test.equal(scrollable1.getScrollOffset(), <NUM_LIT>);<EOL>    test.equal(scrollable2.getScrollOffset(), <NUM_LIT>);<EOL>    test.equal(scrollable3.getScrollOffset(), <NUM_LIT>);<EOL>    vsa.scrollTo(<NUM_LIT>);<EOL>    test.equal(scrollbar.getPosition(), <NUM_LIT>);<EOL>    test.equal(container.","gt":"scrollTop, <NUM_LIT>);"}
{"input":"<s> export function test3Scrollables(test: nodeunit.Test): void {<EOL>    const vsa: VirtualScrollArea.VirtualScrollArea = new VirtualScrollArea.VirtualScrollArea();<EOL>    const scrollbar: SuperScrollbar = SetupScrollbar(vsa);<EOL>    const container: HTMLElement = SetUpScrollContainer(vsa, <NUM_LIT>);<EOL>    const scrollable1: VirtualScrollableWithExtra = SetupScrollable(vsa, <NUM_LIT>, <NUM_LIT>, <NUM_LIT>);<EOL>    const scrollable2: VirtualScrollableWithExtra = SetupScrollable(vsa, <NUM_LIT>, <NUM_LIT>, <NUM_LIT>);<EOL>    const scrollable3: VirtualScrollableWithExtra = SetupScrollable(vsa, <NUM_LIT>, <NUM_LIT>, <NUM_LIT>);<EOL>    vsa.updateContainerHeight(container.getBoundingClientRect().height);<EOL>    test.equal(scrollbar.getPosition(), <NUM_LIT>);<EOL>    test.equal(scrollbar.getLength(), <NUM_LIT>);<EOL>    test.equal(scrollable1.getScrollOffset(), <NUM_LIT>);<EOL>    vsa.scrollTo(<NUM_LIT>);<EOL>    test.equal(scrollbar.getPosition(), <NUM_LIT>);<EOL>    test.equal(container.scrollTop, <NUM_LIT>);<EOL>    test.equal(scrollable1.getScrollOffset(), <NUM_LIT>);<EOL>    test.equal(scrollable2.getScrollOffset(), <NUM_LIT>);<EOL>    test.equal(scrollable3.getScrollOffset(), <NUM_LIT>);<EOL>    vsa.scrollTo(<NUM_LIT>);<EOL>    test.equal(scrollbar.getPosition(), <NUM_LIT>);<EOL>    test.equal(container.scrollTop, <NUM_LIT>);<EOL>    test.equal(scrollable1.getScrollOffset(), <NUM_LIT>);<EOL>    test.equal(scrollable2.getScrollOffset(), <NUM_LIT>);<EOL>    test.equal(scrollable3.getScrollOffset(), <NUM_LIT>);<EOL>    vsa.scrollTo(<NUM_LIT>);<EOL>    test.equal(scrollbar.getPosition(), <NUM_LIT>);<EOL>    test.equal(container.scrollTop, <NUM_LIT>);<EOL>    test.equal(scrollable1.getScrollOffset(), <NUM_LIT>);<EOL>    test.equal(","gt":"scrollable2.getScrollOffset(), <NUM_LIT>);"}
{"input":"<s> export function createBulkFileSync(metadata: Metadata, size: number): {<EOL>    identifier: BulkFileIdentifier;<EOL>    url: string;<EOL>} {<EOL>    const msg: Messages.BulkFileCreateMessage = { type: Messages.MessageType.BULK_FILE_CREATE, metadata, size };<EOL>    const event: any = <any>","gt":"ipc.sendSync(Messages.CHANNEL_NAME, msg);"}
{"input":"<s> <EOL><EOL>export function toUrl(resourceName: string): string {<EOL>    let","gt":"mainPath: any = __dirname;"}
{"input":"<s> export function mergeHeaders(target: Headers, source: any): void {<EOL>    if (typeof source !== \"<STR_LIT>\" && source !== null) {<EOL>","gt":"const temp: any = <any>new Request(\"<STR_LIT>\", { headers: source });"}
{"input":"<s> <EOL>export function pipe<T>(context: RequestContext<T>): Promise<T> {<EOL>    return next(context)<EOL>        .then((ctx: RequestContext<T>): Promise<T> => returnResult(ctx))<EOL>        .catch((e: Error): never => {<EOL>        Logger.","gt":"log({"}
{"input":"<s> function isCaptureQualifier(qualifier: Qualifier): boolean {<EOL>    return qualifier.type ===","gt":"'<STR_LIT>'"}
{"input":"<s> <EOL>function reportDiagnostics(diagnostics: ts.Diagnostic[], baseDir?: string): void {<EOL>    if (diagnostics && diagnostics.length && diagnostics[<NUM_LIT>]) {<EOL>        console.error(formatDiagnostics(diagnostics,","gt":"baseDir));"}
{"input":"<s> <EOL>export function setAssignMethod<T>(obj: T, propertyName: string, writeOnce: boolean = false): void {<EOL>    validateMethodName.call(obj, propertyName);<EOL>    const key: string = privateKey(propertyName);<EOL>    objectDefinePropertyValue(","gt":"obj, propertyName, (value: any): T => {"}
{"input":"<s> function setVCRef(key: string, vcRef: ViewContainerRef): void {<EOL>    if (!vcRefCollection.hasOwnProperty(key)) {<EOL>","gt":"vcRefCollection[key] = [];"}
{"input":"<s> export function getClosestToken(color: RGBA, type?: '<STR_LIT>' | '<STR_LIT>', layerType?: string): Token | undefined {<EOL>    let lowestDistance: number = Number.POSITIVE_INFINITY;<EOL>    let currentDistance: number;<EOL>    let closestToken: Token | undefined;<EOL>    const cacheKey:","gt":"string = `<STR_LIT>`;"}
{"input":"<s> export function getClosestToken(color: RGBA, type?: '<STR_LIT>' | '<STR_LIT>', layerType?: string): Token | undefined {<EOL>    let lowestDistance: number = Number.POSITIVE_INFINITY;<EOL>    let currentDistance: number;<EOL>    let closestToken: Token | undefined;<EOL>    const cacheKey: string = `<STR_LIT>`;<EOL>    const cachedToken: Token = closestTokenCache[cacheKey];<EOL>    if (cachedToken) {<EOL>","gt":"return cachedToken;"}
{"input":"<s> export function getClosestToken(color: RGBA, type?: '<STR_LIT>' | '<STR_LIT>', layerType?: string): Token | undefined {<EOL>    let lowestDistance: number = Number.POSITIVE_INFINITY;<EOL>    let currentDistance: number;<EOL>    let closestToken: Token | undefined;<EOL>    const cacheKey: string = `<STR_LIT>`;<EOL>    const cachedToken: Token = closestTokenCache[cacheKey];<EOL>    if (cachedToken) {<EOL>        return cachedToken;<EOL>    }<EOL>    const relevantTokens: Token[] = getRelevantTokens(type, layerType);<EOL>    relevantTokens.forEach((token: Token): void => {<EOL>        currentDistance =","gt":"rgbaDistance(color, token.value);"}
{"input":"<s> export function alphaForDraggerY(y: number, sliderHeight: number): number {<EOL>    const offsetY:","gt":"number = clamp(y, <NUM_LIT>, sliderHeight);"}
{"input":"<s> export function alphaForOffset(offset: number, sliderHeight: number): number {<EOL>    const selectionHeight:","gt":"number = offset - VERTICAL_PADDING;"}
{"input":"<s> <EOL>export function getStaticCustomProperties(tokens: Tokens): any {<EOL>    return Object.entries(tokens)<EOL>        .filter(([tokenGroup]) =>","gt":"tokenGroup !== '<STR_LIT>')"}
{"input":"<s> <EOL><EOL>export function ScrollLock(_: ScrollLockProps): any {<EOL>    const scrollLockManager: any = useScrollLockManager();<EOL>    useEffect((): () => void => {<EOL>","gt":"scrollLockManager.registerScrollLock();"}
{"input":"<s> export function closestParentMatch(element: HTMLElement, matcher: string): HTMLElement {<EOL>    let parent: HTMLElement = element.parentElement;<EOL>    while (parent) {<EOL>        if (","gt":"parent.matches(matcher))"}
{"input":"<s> export function dateIsSelected(day: Date | null, range: Range): boolean {<EOL>    if (day == null) {<EOL>        return","gt":"false;"}
{"input":"<s> export function findFirstFocusableNode(element: HTMLElement, onlyDescendants = true): HTMLElement | null {<EOL>    if (!onlyDescendants && matches(element, FOCUSABLE_SELECTOR)) {<EOL>        return","gt":"element;"}
{"input":"<s> export function useContainerScroll(): any {<EOL>    const scrolledContainerRef:","gt":"any = useContext(ScrollContext);"}
{"input":"<s> function horizontallyOverlaps(rect1: Rect, rect2: Rect): boolean {<EOL>    const rect1Left: number = rect1.left;<EOL>    const rect1Right: number = rect1.left +","gt":"rect1.width;"}
{"input":"<s> function createDiv(): HTMLDivElement {<EOL>    return","gt":"document.createElement('<STR_LIT>');"}
{"input":"<s> <EOL>export function getKeyframeNames(motionTokenGroup: TokenGroup): string[] {<EOL>    return Object.","gt":"keys(motionTokenGroup)"}
{"input":"<s> <EOL>export function qat(something: Foo): Foo {<EOL>    return","gt":"something;"}
{"input":"<s> function getRootLength(path: string): number {<EOL>    if (path.charCodeAt(<NUM_LIT>) === CharacterCodes.slash) {<EOL>        if (path.charCodeAt(<NUM_LIT>) !== CharacterCodes.slash)<EOL>            return <NUM_LIT>;<EOL>        const p1: number = path.indexOf('<STR_LIT>', <NUM_LIT>);<EOL>        if (p1 < <NUM_LIT>)<EOL>","gt":"return <NUM_LIT>;"}
{"input":"<s> function getRootLength(path: string): number {<EOL>    if (path.charCodeAt(<NUM_LIT>) === CharacterCodes.slash) {<EOL>        if (path.charCodeAt(<NUM_LIT>) !== CharacterCodes.slash)<EOL>            return <NUM_LIT>;<EOL>        const p1: number = path.indexOf('<STR_LIT>', <NUM_LIT>);<EOL>        if (p1 < <NUM_LIT>)<EOL>            return <NUM_LIT>;<EOL>        const p2: number = path.indexOf('<STR_LIT>', p1 + <NUM_LIT>);<EOL>        if (p2 < <NUM_LIT>)<EOL>","gt":"return p1 + <NUM_LIT>;"}
{"input":"<s> function getRootLength(path: string): number {<EOL>    if (path.charCodeAt(<NUM_LIT>) === CharacterCodes.slash) {<EOL>        if (path.charCodeAt(<NUM_LIT>) !== CharacterCodes.slash)<EOL>            return <NUM_LIT>;<EOL>        const p1: number = path.indexOf('<STR_LIT>', <NUM_LIT>);<EOL>        if (p1 < <NUM_LIT>)<EOL>            return <NUM_LIT>;<EOL>        const p2: number = path.indexOf('<STR_LIT>', p1 + <NUM_LIT>);<EOL>        if (p2 < <NUM_LIT>)<EOL>            return p1 + <NUM_LIT>;<EOL>        return p2 + <NUM_LIT>;<EOL>    }<EOL>    if (path.","gt":"charCodeAt(<NUM_LIT>) === CharacterCodes.colon) {"}
{"input":"<s> function getRootLength(path: string): number {<EOL>    if (path.charCodeAt(<NUM_LIT>) === CharacterCodes.slash) {<EOL>        if (path.charCodeAt(<NUM_LIT>) !== CharacterCodes.slash)<EOL>            return <NUM_LIT>;<EOL>        const p1: number = path.indexOf('<STR_LIT>', <NUM_LIT>);<EOL>        if (p1 < <NUM_LIT>)<EOL>            return <NUM_LIT>;<EOL>        const p2: number = path.indexOf('<STR_LIT>', p1 + <NUM_LIT>);<EOL>        if (p2 < <NUM_LIT>)<EOL>            return p1 + <NUM_LIT>;<EOL>        return p2 + <NUM_LIT>;<EOL>    }<EOL>    if (path.charCodeAt(<NUM_LIT>) === CharacterCodes.colon) {<EOL>        if (path.charCodeAt(<NUM_LIT>) === CharacterCodes.slash)<EOL>            return <NUM_LIT>;<EOL>        return <NUM_LIT>;<EOL>    }<EOL>    <EOL>    <EOL>    <EOL>    <EOL>    <EOL>    if (path.lastIndexOf(","gt":"'<STR_LIT>', <NUM_LIT>) === <NUM_LIT>) {"}
{"input":"<s> <EOL>export function isSymbolDescriptorMatch(query: Partial<SymbolDescriptor>, symbol: SymbolDescriptor): boolean {<EOL>    for (const key: string of Object.keys(query)) {<EOL>        if (!(query as any)[key]) {<EOL>            continue;<EOL>        }<EOL>","gt":"if (key === '<STR_LIT>') {"}
{"input":"<s> <EOL>export function isSymbolDescriptorMatch(query: Partial<SymbolDescriptor>, symbol: SymbolDescriptor): boolean {<EOL>    for (const key: string of Object.keys(query)) {<EOL>        if (!(query as any)[key]) {<EOL>            continue;<EOL>        }<EOL>        if (key === '<STR_LIT>') {<EOL>            if (!symbol.package || !isPackageDescriptorMatch(query.package!, symbol.package)) {<EOL>                return false;<EOL>            }<EOL>","gt":"continue;"}
{"input":"<s> <EOL>export function isSymbolDescriptorMatch(query: Partial<SymbolDescriptor>, symbol: SymbolDescriptor): boolean {<EOL>    for (const key: string of Object.keys(query)) {<EOL>        if (!(query as any)[key]) {<EOL>            continue;<EOL>        }<EOL>        if (key === '<STR_LIT>') {<EOL>            if (!symbol.package || !isPackageDescriptorMatch(query.package!, symbol.package)) {<EOL>                return false;<EOL>            }<EOL>            continue;<EOL>        }<EOL>        if ((query as any)[key] !== (symbol as any)[key]) {<EOL>            return","gt":"false;"}
{"input":"<s> <EOL>export function fadeOut(el: HTMLElement, dur: number, complete?: () => void): void {<EOL>    fade(el, <NUM_LIT>, <NUM_LIT>,","gt":"dur, complete);"}
{"input":"<s> <EOL>function initBladeShapeVerts(shape: Float32Array, numBlades: number, offset: Float32Array): void {<EOL>    let noise: number = <NUM_LIT>;<EOL>    for (let i: number = <NUM_LIT>; i < numBlades; ++i) {<EOL>        noise = Math.abs(simplex(offset[i * <NUM_LIT> + <NUM_LIT>] * <NUM_LIT>, offset[i * <NUM_LIT> + <NUM_LIT>] * <NUM_LIT>));<EOL>        noise =","gt":"noise * noise * noise;"}
{"input":"<s> <EOL>function initBladeShapeVerts(shape: Float32Array, numBlades: number, offset: Float32Array): void {<EOL>    let noise: number = <NUM_LIT>;<EOL>    for (let i: number = <NUM_LIT>; i < numBlades; ++i) {<EOL>        noise = Math.abs(simplex(offset[i * <NUM_LIT> + <NUM_LIT>] * <NUM_LIT>, offset[i * <NUM_LIT> + <NUM_LIT>] * <NUM_LIT>));<EOL>        noise = noise * noise * noise;<EOL>        noise *= <NUM_LIT>;<EOL>        shape[i * <NUM_LIT> + <NUM_LIT>] = BLADE_WIDTH + Math.random() * BLADE_WIDTH * <NUM_LIT>; <EOL>        shape[i * <NUM_LIT> + <NUM_LIT>] = BLADE_HEIGHT_MIN + Math.pow(Math.random(), <NUM_LIT>) * (BLADE_HEIGHT_MAX - BLADE_HEIGHT_MIN) + <EOL>            noise;<EOL>        shape[i * <NUM_LIT> + <NUM_LIT>] = <NUM_LIT> + Math.random() *","gt":"<NUM_LIT>;"}
{"input":"<s> export function getKeyState(code: number): boolean {<EOL>    return","gt":"keyStates[code];"}
{"input":"<s> export function update(t: Terrain, x: number, y: number): void {<EOL>    const ix: number = Math.floor(x / t.cellSize);<EOL>    const iy: number = Math.floor(y / t.cellSize);<EOL>    const ox: number = ix * t.cellSize;<EOL>    const oy: number = iy *","gt":"t.cellSize;"}
{"input":"<s> export function update(t: Terrain, x: number, y: number): void {<EOL>    const ix: number = Math.floor(x / t.cellSize);<EOL>    const iy: number = Math.floor(y / t.cellSize);<EOL>    const ox: number = ix * t.cellSize;<EOL>    const oy: number = iy * t.cellSize;<EOL>    const mat: THREE.RawShaderMaterial = t.mesh.material as THREE.RawShaderMaterial;<EOL>    let p: number[] = mat.uniforms['<STR_LIT>'].value as number[];<EOL>    p[<NUM_LIT>] = ox;<EOL>    p[<NUM_LIT>] = oy;<EOL>    p = mat.","gt":"uniforms['<STR_LIT>'].value;"}
{"input":"<s> <EOL><EOL>export function $e(id: string): HTMLElement {<EOL>    return","gt":"document.getElementById(id) as HTMLElement;"}
{"input":"<s> export function isPureMode(): boolean {<EOL>    return storage.","gt":"getItem(PUREMODE, '<STR_LIT>') === '<STR_LIT>';"}
{"input":"<s> export function setPureMode(val: boolean): void {<EOL>","gt":"storage.setItem(PUREMODE, val ? '<STR_LIT>' : '<STR_LIT>');"}
{"input":"<s> export function sendMessage<T>(type: string, data: any): Promise<T> {<EOL>    return new Promise<T>((res: (value: T | PromiseLike<T>) => void, rej: (reason?: any) => void): void => {<EOL>        let curId: number = ++lastCbId;<EOL>        let timeoutId: number = window.setTimeout((): void => {<EOL>            delete msgCallbacks[curId];<EOL>            rej(new Error('<STR_LIT>'));<EOL>        },","gt":"<NUM_LIT>);"}
{"input":"<s> export function sendMessage<T>(type: string, data: any): Promise<T> {<EOL>    return new Promise<T>((res: (value: T | PromiseLike<T>) => void, rej: (reason?: any) => void): void => {<EOL>        let curId: number = ++lastCbId;<EOL>        let timeoutId: number = window.setTimeout((): void => {<EOL>            delete msgCallbacks[curId];<EOL>            rej(new Error('<STR_LIT>'));<EOL>        }, <NUM_LIT>);<EOL>        msgCallbacks[curId] = (result: any): void => {<EOL>            delete msgCallbacks[curId];<EOL>            window.clearTimeout(timeoutId);<EOL>","gt":"res(result);"}
{"input":"<s> export function sendMessage<T>(type: string, data: any): Promise<T> {<EOL>    return new Promise<T>((res: (value: T | PromiseLike<T>) => void, rej: (reason?: any) => void): void => {<EOL>        let curId: number = ++lastCbId;<EOL>        let timeoutId: number = window.setTimeout((): void => {<EOL>            delete msgCallbacks[curId];<EOL>            rej(new Error('<STR_LIT>'));<EOL>        }, <NUM_LIT>);<EOL>        msgCallbacks[curId] = (result: any): void => {<EOL>            delete msgCallbacks[curId];<EOL>            window.clearTimeout(timeoutId);<EOL>            res(result);<EOL>        };<EOL>        window.postMessage({<EOL>            type:","gt":"type,"}
{"input":"<s> <EOL>function nls(): Stream {<EOL>    var input: import(\"<STR_LIT>\").ThroughStream = through();<EOL>    var output: import(\"<STR_LIT>\").ThroughStream = input.pipe(through(function (f: FileSourceMap) {<EOL>        if (!f.sourceMap) {<EOL>","gt":"return this.emit('<STR_LIT>', new Error(`<STR_LIT>`));"}
{"input":"<s> <EOL>function nls(): Stream {<EOL>    var input: import(\"<STR_LIT>\").ThroughStream = through();<EOL>    var output: import(\"<STR_LIT>\").ThroughStream = input.pipe(through(function (f: FileSourceMap) {<EOL>        if (!f.sourceMap) {<EOL>            return this.emit('<STR_LIT>', new Error(`<STR_LIT>`));<EOL>        }<EOL>        let source: string = f.sourceMap.sources[<NUM_LIT>];<EOL>","gt":"if (!source) {"}
{"input":"<s> <EOL>function nls(): Stream {<EOL>    var input: import(\"<STR_LIT>\").ThroughStream = through();<EOL>    var output: import(\"<STR_LIT>\").ThroughStream = input.pipe(through(function (f: FileSourceMap) {<EOL>        if (!f.sourceMap) {<EOL>            return this.emit('<STR_LIT>', new Error(`<STR_LIT>`));<EOL>        }<EOL>        let source: string = f.sourceMap.sources[<NUM_LIT>];<EOL>        if (!source) {<EOL>            return this.emit('<STR_LIT>', new Error(`<STR_LIT>`));<EOL>        }<EOL>        const root: string = f.sourceMap.sourceRoot;<EOL>        if (","gt":"root) {"}
{"input":"<s> <EOL>function nls(): Stream {<EOL>    var input: import(\"<STR_LIT>\").ThroughStream = through();<EOL>    var output: import(\"<STR_LIT>\").ThroughStream = input.pipe(through(function (f: FileSourceMap) {<EOL>        if (!f.sourceMap) {<EOL>            return this.emit('<STR_LIT>', new Error(`<STR_LIT>`));<EOL>        }<EOL>        let source: string = f.sourceMap.sources[<NUM_LIT>];<EOL>        if (!source) {<EOL>            return this.emit('<STR_LIT>', new Error(`<STR_LIT>`));<EOL>        }<EOL>        const root: string = f.sourceMap.sourceRoot;<EOL>        if (root) {<EOL>            source = path.join(root, source);<EOL>        }<EOL>        const typescript: string = f.sourceMap.sourcesContent[<NUM_LIT>];<EOL>        if (!typescript) {<EOL>            return this.emit('<STR_LIT>', new Error(","gt":"relative} does not have the original content in the source map.`<STR_LIT>;"}
{"input":"<s> function isPropertyAssignment(node: ts.Node): node is ts.PropertyAssignment {<EOL>    return node &&","gt":"node.kind === ts.SyntaxKind.PropertyAssignment;"}
{"input":"<s> export function activateColorDecorations(decoratorProvider: (uri: string) => Thenable<Range[]>, supportedLanguages: {<EOL>    [id: string]: boolean;<EOL>}): Disposable {<EOL>    let disposables: Disposable[] = [];<EOL>    let colorsDecorationType: vscode.TextEditorDecorationType = window.createTextEditorDecorationType(decorationType);<EOL>","gt":"disposables.push(colorsDecorationType);"}
{"input":"<s> export function activateColorDecorations(decoratorProvider: (uri: string) => Thenable<Range[]>, supportedLanguages: {<EOL>    [id: string]: boolean;<EOL>}): Disposable {<EOL>    let disposables: Disposable[] = [];<EOL>    let colorsDecorationType: vscode.TextEditorDecorationType = window.createTextEditorDecorationType(decorationType);<EOL>    disposables.push(colorsDecorationType);<EOL>    let pendingUpdateRequests: {<EOL>        [key: string]: NodeJS.Timer;<EOL>    } = {};<EOL>    <EOL>    window.visibleTextEditors.forEach((editor: TextEditor): void => {<EOL>","gt":"if (editor.document) {"}
{"input":"<s> export function activateColorDecorations(decoratorProvider: (uri: string) => Thenable<Range[]>, supportedLanguages: {<EOL>    [id: string]: boolean;<EOL>}): Disposable {<EOL>    let disposables: Disposable[] = [];<EOL>    let colorsDecorationType: vscode.TextEditorDecorationType = window.createTextEditorDecorationType(decorationType);<EOL>    disposables.push(colorsDecorationType);<EOL>    let pendingUpdateRequests: {<EOL>        [key: string]: NodeJS.Timer;<EOL>    } = {};<EOL>    <EOL>    window.visibleTextEditors.forEach((editor: TextEditor): void => {<EOL>        if (editor.document) {<EOL>            triggerUpdateDecorations(editor.document);<EOL>        }<EOL>    });<EOL>    <EOL>    window.onDidChangeActiveTextEditor((","gt":"editor: TextEditor): void => {"}
{"input":"<s> export function activateColorDecorations(decoratorProvider: (uri: string) => Thenable<Range[]>, supportedLanguages: {<EOL>    [id: string]: boolean;<EOL>}): Disposable {<EOL>    let disposables: Disposable[] = [];<EOL>    let colorsDecorationType: vscode.TextEditorDecorationType = window.createTextEditorDecorationType(decorationType);<EOL>    disposables.push(colorsDecorationType);<EOL>    let pendingUpdateRequests: {<EOL>        [key: string]: NodeJS.Timer;<EOL>    } = {};<EOL>    <EOL>    window.visibleTextEditors.forEach((editor: TextEditor): void => {<EOL>        if (editor.document) {<EOL>            triggerUpdateDecorations(editor.document);<EOL>        }<EOL>    });<EOL>    <EOL>    window.onDidChangeActiveTextEditor((editor: TextEditor): void => {<EOL>        if (editor) {<EOL>            triggerUpdateDecorations(editor.document);<EOL>        }<EOL>    }, null, disposables);<EOL>    workspace.onDidChangeTextDocument((event: vscode.TextDocumentChangeEvent): void => triggerUpdateDecorations(event.document), null, disposables);<EOL>    workspace.onDidOpenTextDocument(triggerUpdateDecorations, null, disposables);<EOL>    workspace.","gt":"onDidCloseTextDocument(triggerUpdateDecorations, null, disposables);"}
{"input":"<s> export function activateColorDecorations(decoratorProvider: (uri: string) => Thenable<Range[]>, supportedLanguages: {<EOL>    [id: string]: boolean;<EOL>}): Disposable {<EOL>    let disposables: Disposable[] = [];<EOL>    let colorsDecorationType: vscode.TextEditorDecorationType = window.createTextEditorDecorationType(decorationType);<EOL>    disposables.push(colorsDecorationType);<EOL>    let pendingUpdateRequests: {<EOL>        [key: string]: NodeJS.Timer;<EOL>    } = {};<EOL>    <EOL>    window.visibleTextEditors.forEach((editor: TextEditor): void => {<EOL>        if (editor.document) {<EOL>            triggerUpdateDecorations(editor.document);<EOL>        }<EOL>    });<EOL>    <EOL>    window.onDidChangeActiveTextEditor((editor: TextEditor): void => {<EOL>        if (editor) {<EOL>            triggerUpdateDecorations(editor.document);<EOL>        }<EOL>    }, null, disposables);<EOL>    workspace.onDidChangeTextDocument((event: vscode.TextDocumentChangeEvent): void => triggerUpdateDecorations(event.document), null, disposables);<EOL>    workspace.onDidOpenTextDocument(triggerUpdateDecorations, null, disposables);<EOL>    workspace.onDidCloseTextDocument(triggerUpdateDecorations, null, disposables);<EOL>    function triggerUpdateDecorations(document: TextDocument): void {<EOL>        let triggerUpdate: boolean = supportedLanguages[document.languageId];<EOL>        let uri: string = document.uri.toString();<EOL>        let timeout: NodeJS.Timer = pendingUpdateRequests[uri];<EOL>        if (typeof timeout !== '<STR_LIT>') {<EOL>            clearTimeout(timeout);<EOL>            triggerUpdate =","gt":"true;"}
{"input":"<s> export function activateColorDecorations(decoratorProvider: (uri: string) => Thenable<Range[]>, supportedLanguages: {<EOL>    [id: string]: boolean;<EOL>}): Disposable {<EOL>    let disposables: Disposable[] = [];<EOL>    let colorsDecorationType: vscode.TextEditorDecorationType = window.createTextEditorDecorationType(decorationType);<EOL>    disposables.push(colorsDecorationType);<EOL>    let pendingUpdateRequests: {<EOL>        [key: string]: NodeJS.Timer;<EOL>    } = {};<EOL>    <EOL>    window.visibleTextEditors.forEach((editor: TextEditor): void => {<EOL>        if (editor.document) {<EOL>            triggerUpdateDecorations(editor.document);<EOL>        }<EOL>    });<EOL>    <EOL>    window.onDidChangeActiveTextEditor((editor: TextEditor): void => {<EOL>        if (editor) {<EOL>            triggerUpdateDecorations(editor.document);<EOL>        }<EOL>    }, null, disposables);<EOL>    workspace.onDidChangeTextDocument((event: vscode.TextDocumentChangeEvent): void => triggerUpdateDecorations(event.document), null, disposables);<EOL>    workspace.onDidOpenTextDocument(triggerUpdateDecorations, null, disposables);<EOL>    workspace.onDidCloseTextDocument(triggerUpdateDecorations, null, disposables);<EOL>    function triggerUpdateDecorations(document: TextDocument): void {<EOL>        let triggerUpdate: boolean = supportedLanguages[document.languageId];<EOL>        let uri: string = document.uri.toString();<EOL>        let timeout: NodeJS.Timer = pendingUpdateRequests[uri];<EOL>        if (typeof timeout !== '<STR_LIT>') {<EOL>            clearTimeout(timeout);<EOL>            triggerUpdate = true; <EOL>        }<EOL>        if (triggerUpdate) {<EOL>            pendingUpdateRequests[uri] = setTimeout((): void => {<EOL>                updateDecorations(uri);<EOL>                delete pendingUpdateRequests[uri];<EOL>            }, <NUM_LIT>);<EOL>        }<EOL>    }<EOL>    function updateDecorations(uri: string): void {<EOL>        window.visibleTextEditors.forEach((editor: TextEditor): void => {<EOL>            let document: TextDocument = editor.document;<EOL>            if (document && document.uri.","gt":"toString() === uri) {"}
{"input":"<s> export function activateColorDecorations(decoratorProvider: (uri: string) => Thenable<Range[]>, supportedLanguages: {<EOL>    [id: string]: boolean;<EOL>}): Disposable {<EOL>    let disposables: Disposable[] = [];<EOL>    let colorsDecorationType: vscode.TextEditorDecorationType = window.createTextEditorDecorationType(decorationType);<EOL>    disposables.push(colorsDecorationType);<EOL>    let pendingUpdateRequests: {<EOL>        [key: string]: NodeJS.Timer;<EOL>    } = {};<EOL>    <EOL>    window.visibleTextEditors.forEach((editor: TextEditor): void => {<EOL>        if (editor.document) {<EOL>            triggerUpdateDecorations(editor.document);<EOL>        }<EOL>    });<EOL>    <EOL>    window.onDidChangeActiveTextEditor((editor: TextEditor): void => {<EOL>        if (editor) {<EOL>            triggerUpdateDecorations(editor.document);<EOL>        }<EOL>    }, null, disposables);<EOL>    workspace.onDidChangeTextDocument((event: vscode.TextDocumentChangeEvent): void => triggerUpdateDecorations(event.document), null, disposables);<EOL>    workspace.onDidOpenTextDocument(triggerUpdateDecorations, null, disposables);<EOL>    workspace.onDidCloseTextDocument(triggerUpdateDecorations, null, disposables);<EOL>    function triggerUpdateDecorations(document: TextDocument): void {<EOL>        let triggerUpdate: boolean = supportedLanguages[document.languageId];<EOL>        let uri: string = document.uri.toString();<EOL>        let timeout: NodeJS.Timer = pendingUpdateRequests[uri];<EOL>        if (typeof timeout !== '<STR_LIT>') {<EOL>            clearTimeout(timeout);<EOL>            triggerUpdate = true; <EOL>        }<EOL>        if (triggerUpdate) {<EOL>            pendingUpdateRequests[uri] = setTimeout((): void => {<EOL>                updateDecorations(uri);<EOL>                delete pendingUpdateRequests[uri];<EOL>            }, <NUM_LIT>);<EOL>        }<EOL>    }<EOL>    function updateDecorations(uri: string): void {<EOL>        window.visibleTextEditors.forEach((editor: TextEditor): void => {<EOL>            let document: TextDocument = editor.document;<EOL>            if (document && document.uri.toString() === uri) {<EOL>                updateDecorationForEditor(editor);<EOL>            }<EOL>        });<EOL>    }<EOL>    function updateDecorationForEditor(editor: TextEditor): void {<EOL>        let document: TextDocument = editor.document;<EOL>        if (supportedLanguages[document.languageId]) {<EOL>            decoratorProvider(document.uri.toString()).then((ranges: Range[]): void => {<EOL>                let decorations: DecorationOptions[] = ranges.map((range: Range): DecorationOptions => {<EOL>                    let color: string = document.getText(","gt":"range);"}
{"input":"<s> export function activateColorDecorations(decoratorProvider: (uri: string) => Thenable<Range[]>, supportedLanguages: {<EOL>    [id: string]: boolean;<EOL>}): Disposable {<EOL>    let disposables: Disposable[] = [];<EOL>    let colorsDecorationType: vscode.TextEditorDecorationType = window.createTextEditorDecorationType(decorationType);<EOL>    disposables.push(colorsDecorationType);<EOL>    let pendingUpdateRequests: {<EOL>        [key: string]: NodeJS.Timer;<EOL>    } = {};<EOL>    <EOL>    window.visibleTextEditors.forEach((editor: TextEditor): void => {<EOL>        if (editor.document) {<EOL>            triggerUpdateDecorations(editor.document);<EOL>        }<EOL>    });<EOL>    <EOL>    window.onDidChangeActiveTextEditor((editor: TextEditor): void => {<EOL>        if (editor) {<EOL>            triggerUpdateDecorations(editor.document);<EOL>        }<EOL>    }, null, disposables);<EOL>    workspace.onDidChangeTextDocument((event: vscode.TextDocumentChangeEvent): void => triggerUpdateDecorations(event.document), null, disposables);<EOL>    workspace.onDidOpenTextDocument(triggerUpdateDecorations, null, disposables);<EOL>    workspace.onDidCloseTextDocument(triggerUpdateDecorations, null, disposables);<EOL>    function triggerUpdateDecorations(document: TextDocument): void {<EOL>        let triggerUpdate: boolean = supportedLanguages[document.languageId];<EOL>        let uri: string = document.uri.toString();<EOL>        let timeout: NodeJS.Timer = pendingUpdateRequests[uri];<EOL>        if (typeof timeout !== '<STR_LIT>') {<EOL>            clearTimeout(timeout);<EOL>            triggerUpdate = true; <EOL>        }<EOL>        if (triggerUpdate) {<EOL>            pendingUpdateRequests[uri] = setTimeout((): void => {<EOL>                updateDecorations(uri);<EOL>                delete pendingUpdateRequests[uri];<EOL>            }, <NUM_LIT>);<EOL>        }<EOL>    }<EOL>    function updateDecorations(uri: string): void {<EOL>        window.visibleTextEditors.forEach((editor: TextEditor): void => {<EOL>            let document: TextDocument = editor.document;<EOL>            if (document && document.uri.toString() === uri) {<EOL>                updateDecorationForEditor(editor);<EOL>            }<EOL>        });<EOL>    }<EOL>    function updateDecorationForEditor(editor: TextEditor): void {<EOL>        let document: TextDocument = editor.document;<EOL>        if (supportedLanguages[document.languageId]) {<EOL>            decoratorProvider(document.uri.toString()).then((ranges: Range[]): void => {<EOL>                let decorations: DecorationOptions[] = ranges.map((range: Range): DecorationOptions => {<EOL>                    let color: string = document.getText(range);<EOL>                    return <DecorationOptions>{<EOL>                        range: range,<EOL>                        renderOptions: {<EOL>                            before: {<EOL>                                backgroundColor:","gt":"color"}
{"input":"<s> <EOL>function encodeURIComponent2(str: string): string {<EOL>    return encodeURIComponent(str).","gt":"replace(/[!'()*]/g, _encode);"}
{"input":"<s> function showPreview(uri?: Uri, sideBySide: boolean = false): Thenable<unknown> {<EOL>    let resource: vscode.Uri = uri;<EOL>    if (!(resource instanceof Uri)) {<EOL>        if (vscode.window.activeTextEditor) {<EOL>            <EOL>            resource = vscode.window.activeTextEditor.document.uri;<EOL>        }<EOL>    }<EOL>    if (!(resource instanceof Uri)) {<EOL>        if (!vscode.window.activeTextEditor) {<EOL>            <EOL>            return vscode.commands.executeCommand('<STR_LIT>');<EOL>        }<EOL>        <EOL>        return;<EOL>    }<EOL>    let thenable: Thenable<unknown> = vscode.commands.executeCommand('<STR_LIT>', getMarkdownUri(resource), getViewColumn(sideBySide),","gt":"path.basename(resource.fsPath)}'<STR_LIT>;"}
{"input":"<s> function textSpan2Range(value: Proto.TextSpan): Range {<EOL>    return new Range(value.start.line - <NUM_LIT>, value.","gt":"start.offset - <NUM_LIT>, value.end.line - <NUM_LIT>, value.end.offset - <NUM_LIT>);"}
{"input":"<s> function generatePatchedEnv(env: any, stdInPipeName: string, stdOutPipeName: string, stdErrPipeName: string): any {<EOL>    <EOL>    var newEnv: any = {};<EOL>    for (var key: string in env) {<EOL>","gt":"newEnv[key] = env[key];"}
{"input":"<s> function generatePatchedEnv(env: any, stdInPipeName: string, stdOutPipeName: string, stdErrPipeName: string): any {<EOL>    <EOL>    var newEnv: any = {};<EOL>    for (var key: string in env) {<EOL>        newEnv[key] = env[key];<EOL>    }<EOL>    newEnv['<STR_LIT>'] = stdInPipeName;<EOL>    newEnv['<STR_LIT>'] = stdOutPipeName;<EOL>    newEnv['<STR_LIT>'] =","gt":"stdErrPipeName;"}
{"input":"<s> export function array<T>(value: any): value is T[] {<EOL>    return","gt":"Array.isArray(value);"}
{"input":"<s> export function undefined(value: any): boolean {<EOL>    return typeof","gt":"value === '<STR_LIT>';"}
{"input":"<s> function bar(): void {<EOL>    var a: number = <NUM_LIT>;<EOL>    a = <NUM_LIT>;<EOL>    a = <NUM_LIT>;<EOL>    a = <NUM_LIT>;<EOL>    a = <NUM_LIT>;<EOL>    a =","gt":"<NUM_LIT>;"}
{"input":"<s> function bar(): void {<EOL>    var a: number = <NUM_LIT>;<EOL>    a = <NUM_LIT>;<EOL>    a = <NUM_LIT>;<EOL>    a = <NUM_LIT>;<EOL>    a = <NUM_LIT>;<EOL>    a = <NUM_LIT>;<EOL>    a = <NUM_LIT>;<EOL>    a = <NUM_LIT>;<EOL>    a =","gt":"<NUM_LIT>;"}
{"input":"<s> function bar(): void {<EOL>    var a: number = <NUM_LIT>;<EOL>    a = <NUM_LIT>;<EOL>    a = <NUM_LIT>;<EOL>    a = <NUM_LIT>;<EOL>    a = <NUM_LIT>;<EOL>    a = <NUM_LIT>;<EOL>    a = <NUM_LIT>;<EOL>    a = <NUM_LIT>;<EOL>    a = <NUM_LIT>;<EOL>    a = <NUM_LIT>;<EOL>    a = <NUM_LIT>;<EOL>    a =","gt":"<NUM_LIT>;"}
{"input":"<s> function bar(): void {<EOL>    var a: number = <NUM_LIT>;<EOL>    a = <NUM_LIT>;<EOL>    a = <NUM_LIT>;<EOL>    a = <NUM_LIT>;<EOL>    a = <NUM_LIT>;<EOL>    a = <NUM_LIT>;<EOL>    a = <NUM_LIT>;<EOL>    a = <NUM_LIT>;<EOL>    a = <NUM_LIT>;<EOL>    a = <NUM_LIT>;<EOL>    a = <NUM_LIT>;<EOL>    a = <NUM_LIT>;<EOL>    a = <NUM_LIT>;<EOL>    a = <NUM_LIT>;<EOL>","gt":"a = <NUM_LIT>;"}
{"input":"<s> function bar(): void {<EOL>    var a: number = <NUM_LIT>;<EOL>    a = <NUM_LIT>;<EOL>    a = <NUM_LIT>;<EOL>    a = <NUM_LIT>;<EOL>    a = <NUM_LIT>;<EOL>    a = <NUM_LIT>;<EOL>    a = <NUM_LIT>;<EOL>    a = <NUM_LIT>;<EOL>    a = <NUM_LIT>;<EOL>    a = <NUM_LIT>;<EOL>    a = <NUM_LIT>;<EOL>    a = <NUM_LIT>;<EOL>    a = <NUM_LIT>;<EOL>    a = <NUM_LIT>;<EOL>    a = <NUM_LIT>;<EOL>    a = <NUM_LIT>;<EOL>    a = <NUM_LIT>;<EOL>    a = <NUM_LIT>;<EOL>    a = <NUM_LIT>;<EOL>    a = <NUM_LIT>;<EOL>    a = <NUM_LIT>;<EOL>","gt":"a = <NUM_LIT>;"}
{"input":"<s> <EOL>function positionToOffset(str: string, desiredLine: number, desiredCol: number): number {<EOL>    if (desiredLine === <NUM_LIT>) {<EOL>        return desiredCol - <NUM_LIT>;<EOL>    }<EOL>    let line:","gt":"number = <NUM_LIT>, lastNewLineOffset: number = -<NUM_LIT>;"}
{"input":"<s> <EOL>function positionToOffset(str: string, desiredLine: number, desiredCol: number): number {<EOL>    if (desiredLine === <NUM_LIT>) {<EOL>        return desiredCol - <NUM_LIT>;<EOL>    }<EOL>    let line: number = <NUM_LIT>, lastNewLineOffset: number = -<NUM_LIT>;<EOL>    do {<EOL>        if (desiredLine === line) {<EOL>            return lastNewLineOffset + <NUM_LIT> + desiredCol - <NUM_LIT>;<EOL>        }<EOL>        lastNewLineOffset = str.indexOf('<STR_LIT>', lastNewLineOffset + <NUM_LIT>);<EOL>","gt":"line++;"}
{"input":"<s> function isObjectLiteral(node: ts.Node): node is ts.ObjectLiteralExpression {<EOL>    return","gt":"node && node.kind === ts.SyntaxKind.ObjectLiteralExpression;"}
{"input":"<s> export function setZoomLevel(zoomLevel: number): void {<EOL>    ZoomManager.INSTANCE.setZoomLevel(","gt":"zoomLevel);"}
{"input":"<s> <EOL><EOL>export function getTotalWidth(element: HTMLElement): number {<EOL>    let margin:","gt":"number = sizeUtils.getMarginLeft(element) + sizeUtils.getMarginRight(element);"}
{"input":"<s> export function isInDOM(node: Node): boolean {<EOL>    while (node) {<EOL>        if (node === document.body) {<EOL>            return","gt":"true;"}
{"input":"<s> function formatTagType(char: string): FormatType {<EOL>    switch (char) {<EOL>        case '<STR_LIT>':<EOL>            return FormatType.Bold;<EOL>        case","gt":"'<STR_LIT>':"}
{"input":"<s> function formatTagType(char: string): FormatType {<EOL>    switch (char) {<EOL>        case '<STR_LIT>':<EOL>            return FormatType.Bold;<EOL>        case '<STR_LIT>':<EOL>            return FormatType.Italics;<EOL>        case '<STR_LIT>':<EOL>            return FormatType.Action;<EOL>        case '<STR_LIT>':<EOL>            return FormatType.ActionClose;<EOL>","gt":"default:"}
{"input":"<s> function insertMessage(target: Builder, msg: string): void {<EOL>    if (!ariaContainer) {<EOL>        <EOL>","gt":"return;"}
{"input":"<s> export function lookupOrInsert<T>(from: any, stringOrNumber: any, alternate: any): T {<EOL>    const key: string = String(stringOrNumber);<EOL>    if (contains(from, key)) {<EOL>        return from[key];<EOL>    }<EOL>    else {<EOL>        if (typeof alternate === '<STR_LIT>') {<EOL>            alternate = alternate();<EOL>        }<EOL>        from[key] =","gt":"alternate;"}
{"input":"<s> <EOL>function hex2rgba(hex: string): RGBA {<EOL>    function parseHex(str: string): number {<EOL>        return parseInt('<STR_LIT>' + str);<EOL>    }<EOL>","gt":"if (hex.charAt(<NUM_LIT>) === '<STR_LIT>' && hex.length >= <NUM_LIT>) {"}
{"input":"<s> <EOL>function hex2rgba(hex: string): RGBA {<EOL>    function parseHex(str: string): number {<EOL>        return parseInt('<STR_LIT>' + str);<EOL>    }<EOL>    if (hex.charAt(<NUM_LIT>) === '<STR_LIT>' && hex.length >= <NUM_LIT>) {<EOL>        let r: number = parseHex(hex.substr(<NUM_LIT>, <NUM_LIT>));<EOL>        let g: number = parseHex(hex.substr(<NUM_LIT>, <NUM_LIT>));<EOL>        let b: number = parseHex(hex.substr(<NUM_LIT>, <NUM_LIT>));<EOL>        let a: number = hex.length === <NUM_LIT> ? parseHex(hex.substr(<NUM_LIT>, <NUM_LIT>)) / <NUM_LIT> : <NUM_LIT>;<EOL>        return { r,","gt":"g, b, a };"}
{"input":"<s> <EOL>export function canceled(): Error {<EOL>","gt":"let error: Error = new Error(canceledName);"}
{"input":"<s> function nextWord(word: string, start: number): number {<EOL>    for (let i: number = start; i < word.length; i++) {<EOL>        let c: number = word.charCodeAt(i);<EOL>        if (","gt":"isWhitespace(c) || (i > <NUM_LIT> && isWhitespace(word.charCodeAt(i - <NUM_LIT>)))) {"}
{"input":"<s> function isDigit(ch: number): boolean {<EOL>    return ch >= CharacterCodes.","gt":"_0 && ch <= CharacterCodes._9;"}
{"input":"<s> export function countToArray(fromOrTo: number, to?: number): number[] {<EOL>    var result: number[] = [];<EOL>    var fn: (i: number) => number = (i: number): number => result.push(i);<EOL>    if (","gt":"types.isUndefined(to)) {"}
{"input":"<s> export function singlePagePager<T>(elements: T[]): IPager<T> {<EOL>    return {<EOL>","gt":"firstPage: elements,"}
{"input":"<s> function _isNormal(path: string, win: boolean): boolean {<EOL>","gt":"return win"}
{"input":"<s> export function resolveCommandOptions(options: CommandOptions, variables: ISystemVariables): CommandOptions {<EOL>    let result: CommandOptions = Objects.clone(options);<EOL>    if (result.cwd) {<EOL>","gt":"result.cwd = variables.resolve(result.cwd);"}
{"input":"<s> <EOL>export function commonPrefixLength(a: string, b: string): number {<EOL>    let i: number, len: number = Math.min(a.length, b.length);<EOL>    for (i = <NUM_LIT>; i < len; i++) {<EOL>","gt":"if (a.charCodeAt(i) !== b.charCodeAt(i)) {"}
{"input":"<s> export function removeAnsiEscapeCodes(str: string): string {<EOL>    if (str) {<EOL>        str = str.replace(EL, '<STR_LIT>');<EOL>        str = str.replace(LF,","gt":"'<STR_LIT>');"}
{"input":"<s> function Sequence(sequences: {<EOL>    (...param: any[]): void;<EOL>}[]): void {<EOL>    <EOL>    <EOL>    let","gt":"errorHandler: (...param: any[]) => void = sequences.splice(<NUM_LIT>, <NUM_LIT>)[<NUM_LIT>];"}
{"input":"<s> function Sequence(sequences: {<EOL>    (...param: any[]): void;<EOL>}[]): void {<EOL>    <EOL>    <EOL>    let errorHandler: (...param: any[]) => void = sequences.splice(<NUM_LIT>, <NUM_LIT>)[<NUM_LIT>]; <EOL>    let sequenceResult: any = null;<EOL>    loop(sequences, (sequence: (...param: any[]) => void, clb: (error: Error, result: unknown) => void): void => {<EOL>        let sequenceFunction: (error: any, result: any) => void = function (error: any, result: any): void {<EOL>            <EOL>            if (error === true || error === false) {<EOL>                result = error;<EOL>                error = null;<EOL>            }<EOL>            <EOL>            if (error) {<EOL>","gt":"clb(error, null);"}
{"input":"<s> export function writeFileAndFlush(path: string, data: any, encoding: string = '<STR_LIT>'): Promise {<EOL>    return nfcall(extfs.writeFileAndFlush, path, data,","gt":"encoding);"}
{"input":"<s> function hasNoContent(context: IRequestContext): boolean {<EOL>    return context.","gt":"res.statusCode === <NUM_LIT>;"}
{"input":"<s> function removeFromParent(element: HTMLElement): void {<EOL>    try {<EOL>        element.parentElement.removeChild(","gt":"element);"}
{"input":"<s> function assertTree(input: string, expected: any): void {<EOL>    var errors: ParseError[] = [];<EOL>    var actual: Node = parseTree(input, errors);<EOL>    assert.equal(errors.length, <NUM_LIT>);<EOL>    let checkParent: (node: Node) => void = (node: Node): void => {<EOL>","gt":"if (node.children) {"}
{"input":"<s> function assertUrl(raw: string, scheme: string, domain: string, port: string, path: string, queryString: string, fragmentId: string): void {<EOL>    <EOL>    var uri: URI = URI.parse(raw);<EOL>    assert.","gt":"equal(uri.scheme, scheme);"}
{"input":"<s> function quit(accessor: ServicesAccessor, arg?: any): void {<EOL>    const logService: ILogService = accessor.get(ILogService);<EOL>    let exitCode: number = <NUM_LIT>;<EOL>    if (typeof arg === '<STR_LIT>') {<EOL>        logService.log(arg);<EOL>    }<EOL>    else {<EOL>        exitCode = <NUM_LIT>; <EOL>        if (arg.stack) {<EOL>            console.error(arg.","gt":"stack);"}
{"input":"<s> function quit(accessor: ServicesAccessor, arg?: any): void {<EOL>    const logService: ILogService = accessor.get(ILogService);<EOL>    let exitCode: number = <NUM_LIT>;<EOL>    if (typeof arg === '<STR_LIT>') {<EOL>        logService.log(arg);<EOL>    }<EOL>    else {<EOL>        exitCode = <NUM_LIT>; <EOL>        if (arg.stack) {<EOL>            console.error(arg.stack);<EOL>        }<EOL>        else {<EOL>","gt":"console.error('<STR_LIT>' + arg.toString());"}
{"input":"<s> <EOL>export function create(domElement: HTMLElement, options?: IEditorConstructionOptions, services?: IEditorOverrideServices): IStandaloneCodeEditor {<EOL>    startup.initStaticServicesIfNecessary();<EOL>    services = shallowClone(services);<EOL>    var editorService: SimpleEditorService = null;<EOL>    if (!services || !services.editorService) {<EOL>        editorService = new SimpleEditorService();<EOL>","gt":"services.editorService = editorService;"}
{"input":"<s> <EOL>export function create(domElement: HTMLElement, options?: IEditorConstructionOptions, services?: IEditorOverrideServices): IStandaloneCodeEditor {<EOL>    startup.initStaticServicesIfNecessary();<EOL>    services = shallowClone(services);<EOL>    var editorService: SimpleEditorService = null;<EOL>    if (!services || !services.editorService) {<EOL>        editorService = new SimpleEditorService();<EOL>        services.editorService = editorService;<EOL>    }<EOL>    if (!services.openerService) {<EOL>        services.openerService = new OpenerService(editorService, services.commandService);<EOL>    }<EOL>","gt":"var t: {"}
{"input":"<s> <EOL>export function create(domElement: HTMLElement, options?: IEditorConstructionOptions, services?: IEditorOverrideServices): IStandaloneCodeEditor {<EOL>    startup.initStaticServicesIfNecessary();<EOL>    services = shallowClone(services);<EOL>    var editorService: SimpleEditorService = null;<EOL>    if (!services || !services.editorService) {<EOL>        editorService = new SimpleEditorService();<EOL>        services.editorService = editorService;<EOL>    }<EOL>    if (!services.openerService) {<EOL>        services.openerService = new OpenerService(editorService, services.commandService);<EOL>    }<EOL>    var t: {<EOL>        ctx: IEditorOverrideServices;<EOL>        toDispose: IDisposable[];<EOL>    } = prepareServices(domElement, services);<EOL>    var","gt":"result: StandaloneEditor = t.ctx.instantiationService.createInstance(StandaloneEditor, domElement, options, t.toDispose);"}
{"input":"<s> <EOL>export function setupServices(services: IEditorOverrideServices): IEditorOverrideServices {<EOL>","gt":"return startup.setupServices(services);"}
{"input":"<s> <EOL>export function createMonacoLanguagesAPI(): typeof monaco.languages {<EOL>    return {<EOL>        register: register,<EOL>        getLanguages: getLanguages,<EOL>        onLanguage: onLanguage,<EOL>        <EOL>        setLanguageConfiguration:","gt":"setLanguageConfiguration,"}
{"input":"<s> <EOL>export function createMonacoLanguagesAPI(): typeof monaco.languages {<EOL>    return {<EOL>        register: register,<EOL>        getLanguages: getLanguages,<EOL>        onLanguage: onLanguage,<EOL>        <EOL>        setLanguageConfiguration: setLanguageConfiguration,<EOL>        setTokensProvider: setTokensProvider,<EOL>        setMonarchTokensProvider: setMonarchTokensProvider,<EOL>        registerReferenceProvider:","gt":"registerReferenceProvider,"}
{"input":"<s> <EOL>export function createMonacoLanguagesAPI(): typeof monaco.languages {<EOL>    return {<EOL>        register: register,<EOL>        getLanguages: getLanguages,<EOL>        onLanguage: onLanguage,<EOL>        <EOL>        setLanguageConfiguration: setLanguageConfiguration,<EOL>        setTokensProvider: setTokensProvider,<EOL>        setMonarchTokensProvider: setMonarchTokensProvider,<EOL>        registerReferenceProvider: registerReferenceProvider,<EOL>        registerRenameProvider: registerRenameProvider,<EOL>        registerCompletionItemProvider: registerCompletionItemProvider,<EOL>","gt":"registerSignatureHelpProvider: registerSignatureHelpProvider,"}
{"input":"<s> <EOL>export function createMonacoLanguagesAPI(): typeof monaco.languages {<EOL>    return {<EOL>        register: register,<EOL>        getLanguages: getLanguages,<EOL>        onLanguage: onLanguage,<EOL>        <EOL>        setLanguageConfiguration: setLanguageConfiguration,<EOL>        setTokensProvider: setTokensProvider,<EOL>        setMonarchTokensProvider: setMonarchTokensProvider,<EOL>        registerReferenceProvider: registerReferenceProvider,<EOL>        registerRenameProvider: registerRenameProvider,<EOL>        registerCompletionItemProvider: registerCompletionItemProvider,<EOL>        registerSignatureHelpProvider: registerSignatureHelpProvider,<EOL>        registerHoverProvider: registerHoverProvider,<EOL>        registerDocumentSymbolProvider: registerDocumentSymbolProvider,<EOL>","gt":"registerDocumentHighlightProvider: registerDocumentHighlightProvider,"}
{"input":"<s> <EOL>export function createMonacoLanguagesAPI(): typeof monaco.languages {<EOL>    return {<EOL>        register: register,<EOL>        getLanguages: getLanguages,<EOL>        onLanguage: onLanguage,<EOL>        <EOL>        setLanguageConfiguration: setLanguageConfiguration,<EOL>        setTokensProvider: setTokensProvider,<EOL>        setMonarchTokensProvider: setMonarchTokensProvider,<EOL>        registerReferenceProvider: registerReferenceProvider,<EOL>        registerRenameProvider: registerRenameProvider,<EOL>        registerCompletionItemProvider: registerCompletionItemProvider,<EOL>        registerSignatureHelpProvider: registerSignatureHelpProvider,<EOL>        registerHoverProvider: registerHoverProvider,<EOL>        registerDocumentSymbolProvider: registerDocumentSymbolProvider,<EOL>        registerDocumentHighlightProvider: registerDocumentHighlightProvider,<EOL>        registerDefinitionProvider: registerDefinitionProvider,<EOL>        registerCodeLensProvider: registerCodeLensProvider,<EOL>        registerCodeActionProvider: registerCodeActionProvider,<EOL>        registerDocumentFormattingEditProvider: registerDocumentFormattingEditProvider,<EOL>        registerDocumentRangeFormattingEditProvider: registerDocumentRangeFormattingEditProvider,<EOL>        registerOnTypeFormattingEditProvider:","gt":"registerOnTypeFormattingEditProvider,"}
{"input":"<s> function shallowClone<T>(obj: T): T {<EOL>    let r: T = <any>{};<EOL>    if (obj) {<EOL>","gt":"let keys: string[] = Object.keys(obj);"}
{"input":"<s> function cursorBlinkingStyleFromString(cursorBlinkingStyle: string): editorCommon.TextEditorCursorBlinkingStyle {<EOL>    switch (cursorBlinkingStyle) {<EOL>        case '<STR_LIT>':<EOL>            return editorCommon.TextEditorCursorBlinkingStyle.Blink;<EOL>        case '<STR_LIT>':<EOL>","gt":"return editorCommon.TextEditorCursorBlinkingStyle.Smooth;"}
{"input":"<s> function cursorBlinkingStyleFromString(cursorBlinkingStyle: string): editorCommon.TextEditorCursorBlinkingStyle {<EOL>    switch (cursorBlinkingStyle) {<EOL>        case '<STR_LIT>':<EOL>            return editorCommon.TextEditorCursorBlinkingStyle.Blink;<EOL>        case '<STR_LIT>':<EOL>            return editorCommon.TextEditorCursorBlinkingStyle.Smooth;<EOL>        case '<STR_LIT>':<EOL>            return editorCommon.TextEditorCursorBlinkingStyle.Phase;<EOL>        case '<STR_LIT>':<EOL>            return editorCommon.TextEditorCursorBlinkingStyle.Expand;<EOL>        case '<STR_LIT>': <EOL>","gt":"case '<STR_LIT>':"}
{"input":"<s> function cursorStyleFromString(cursorStyle: string): editorCommon.TextEditorCursorStyle {<EOL>    if (cursorStyle === '<STR_LIT>') {<EOL>        return editorCommon.TextEditorCursorStyle.Line;<EOL>    }<EOL>    else if (cursorStyle ===","gt":"'<STR_LIT>') {"}
{"input":"<s> function cursorStyleFromString(cursorStyle: string): editorCommon.TextEditorCursorStyle {<EOL>    if (cursorStyle === '<STR_LIT>') {<EOL>        return editorCommon.TextEditorCursorStyle.Line;<EOL>    }<EOL>    else if (cursorStyle === '<STR_LIT>') {<EOL>        return editorCommon.TextEditorCursorStyle.Block;<EOL>    }<EOL>    else if (cursorStyle === '<STR_LIT>') {<EOL>","gt":"return editorCommon.TextEditorCursorStyle.Underline;"}
{"input":"<s> <EOL>export function isCommonDiffEditor(thing: any): thing is ICommonDiffEditor {<EOL>    if (thing && typeof (<ICommonDiffEditor>thing).getEditorType === '<STR_LIT>') {<EOL>        return (<ICommonDiffEditor>thing).getEditorType() === EditorType.","gt":"ICodeEditor;"}
{"input":"<s> <EOL>function computePlusOneIndentLevel(line: string, tabSize: number): number {<EOL>    let indent: number = <NUM_LIT>;<EOL>    let i: number = <NUM_LIT>;<EOL>    let len: number = line.length;<EOL>    while (","gt":"i < len) {"}
{"input":"<s> <EOL>function computePlusOneIndentLevel(line: string, tabSize: number): number {<EOL>    let indent: number = <NUM_LIT>;<EOL>    let i: number = <NUM_LIT>;<EOL>    let len: number = line.length;<EOL>    while (i < len) {<EOL>        let chCode: number = line.charCodeAt(i);<EOL>        if (chCode === <NUM_LIT> ) {<EOL>","gt":"indent++;"}
{"input":"<s> function toLineTokensFromDeflated(tokens: number[], textLength: number): number[] {<EOL>    if (textLength === <NUM_LIT>) {<EOL>        return null;<EOL>    }<EOL>","gt":"if (!tokens || tokens.length === <NUM_LIT>) {"}
{"input":"<s> <EOL>export function sanitize(s: string): string {<EOL>    return s.","gt":"replace(/[&<>'\"_]/g, '<STR_LIT>');"}
{"input":"<s> <EOL><EOL>export function throwError(lexer: ILexerMin, msg: string): void {<EOL>    throw new Error(","gt":"languageId}: ${msg}`<STR_LIT>;"}
{"input":"<s> export function nullTokenize(modeId: string, buffer: string, state: IState, deltaOffset: number = <NUM_LIT>, stopAtOffset?: number): ILineTokens {<EOL>    let tokens: Token[] = [new Token(deltaOffset, '<STR_LIT>')];<EOL>    let modeTransitions: ModeTransition[] = [new ModeTransition(deltaOffset, modeId)];<EOL>","gt":"return {"}
{"input":"<s> function isQuickFix(quickfix: any): quickfix is IQuickFix2 {<EOL>","gt":"return quickfix"}
{"input":"<s> export function getCodeActions(model: IReadOnlyModel, range: Range): TPromise<IQuickFix2[]> {<EOL>    const quickFixes: IQuickFix2[] = [];<EOL>    let ids: IdGenerator = new IdGenerator('<STR_LIT>');<EOL>    const promises: TPromise<void>[] = CodeActionProviderRegistry.all(model).map((support: CodeActionProvider): TPromise<void> => {<EOL>        return asWinJsPromise((token: import(\"<STR_LIT>\").CancellationToken): CodeAction[] | Thenable<CodeAction[]> => {<EOL>            return support.provideCodeActions(model, range,","gt":"token);"}
{"input":"<s> export function getCodeActions(model: IReadOnlyModel, range: Range): TPromise<IQuickFix2[]> {<EOL>    const quickFixes: IQuickFix2[] = [];<EOL>    let ids: IdGenerator = new IdGenerator('<STR_LIT>');<EOL>    const promises: TPromise<void>[] = CodeActionProviderRegistry.all(model).map((support: CodeActionProvider): TPromise<void> => {<EOL>        return asWinJsPromise((token: import(\"<STR_LIT>\").CancellationToken): CodeAction[] | Thenable<CodeAction[]> => {<EOL>            return support.provideCodeActions(model, range, token);<EOL>        }).then((result: CodeAction[]): void => {<EOL>            if (!Array.","gt":"isArray(result)) {"}
{"input":"<s> export function getCodeActions(model: IReadOnlyModel, range: Range): TPromise<IQuickFix2[]> {<EOL>    const quickFixes: IQuickFix2[] = [];<EOL>    let ids: IdGenerator = new IdGenerator('<STR_LIT>');<EOL>    const promises: TPromise<void>[] = CodeActionProviderRegistry.all(model).map((support: CodeActionProvider): TPromise<void> => {<EOL>        return asWinJsPromise((token: import(\"<STR_LIT>\").CancellationToken): CodeAction[] | Thenable<CodeAction[]> => {<EOL>            return support.provideCodeActions(model, range, token);<EOL>        }).then((result: CodeAction[]): void => {<EOL>            if (!Array.isArray(result)) {<EOL>                return;<EOL>            }<EOL>            for (let fix: CodeAction of result) {<EOL>                quickFixes.push({<EOL>","gt":"command: fix.command,"}
{"input":"<s> function matchesColor(text: string): string {<EOL>    return text && text.","gt":"match(colorRegExp) ? text : null;"}
{"input":"<s> function deleteWordRight(cursor: Cursor): void {<EOL>","gt":"cursorCommand(cursor, H.DeleteWordRight);"}
{"input":"<s> function getRandomInt(min: number, max: number): number {<EOL>    return Math.floor(Math.random() * (max -","gt":"min + <NUM_LIT>)) + min;"}
{"input":"<s> function equalRange(left: any, right: any): void {<EOL>    if (left.startLineNumber !== right.startLineNumber) {<EOL>        assert.ok(false, '<STR_LIT>' + left.startLineNumber + '<STR_LIT>' + right.startLineNumber);<EOL>    }<EOL>    else if (left.","gt":"endLineNumber !== right.endLineNumber) {"}
{"input":"<s> function equalRange(left: any, right: any): void {<EOL>    if (left.startLineNumber !== right.startLineNumber) {<EOL>        assert.ok(false, '<STR_LIT>' + left.startLineNumber + '<STR_LIT>' + right.startLineNumber);<EOL>    }<EOL>    else if (left.endLineNumber !== right.endLineNumber) {<EOL>        assert.ok(false, '<STR_LIT>' + left.endLineNumber + '<STR_LIT>' + right.endLineNumber);<EOL>    }<EOL>    else if (left.startColumn !== right.startColumn) {<EOL>        assert.ok(false, '<STR_LIT>' + left.startColumn + '<STR_LIT>' + right.startColumn);<EOL>    }<EOL>","gt":"else if (left.endColumn !== right.endColumn) {"}
{"input":"<s> export function executeTests(tokenizationSupport: modes.ITokenizationSupport, tests: ITestItem[][]): void {<EOL>    for (var i: number = <NUM_LIT>, len: number = tests.length; i < len; i++) {<EOL>        assert.ok(true,","gt":"'<STR_LIT>' + i);"}
{"input":"<s> export function testModelBuilder(chunks: string[], opts: ITextModelCreationOptions = TextModel.DEFAULT_CREATION_OPTIONS): string {<EOL>    let expectedRawText: IRawText = TextModel.toRawText(chunks.join('<STR_LIT>'), opts);<EOL>    let expectedHash: string = computeHash(expectedRawText);<EOL>    let builder: ModelBuilder = new ModelBuilder();<EOL>    for (let i: number = <NUM_LIT>,","gt":"len: number = chunks.length; i < len; i++) {"}
{"input":"<s> export function testModelBuilder(chunks: string[], opts: ITextModelCreationOptions = TextModel.DEFAULT_CREATION_OPTIONS): string {<EOL>    let expectedRawText: IRawText = TextModel.toRawText(chunks.join('<STR_LIT>'), opts);<EOL>    let expectedHash: string = computeHash(expectedRawText);<EOL>    let builder: ModelBuilder = new ModelBuilder();<EOL>    for (let i: number = <NUM_LIT>, len: number = chunks.length; i < len; i++) {<EOL>        builder.acceptChunk(chunks[i]);<EOL>    }<EOL>    let actual: import(\"<STR_LIT>\").ModelBuilderResult = builder.finish(opts);<EOL>    assert.deepEqual({<EOL>        rawText: expectedRawText,<EOL>        hash:","gt":"expectedHash"}
{"input":"<s> function isInterestingToken(tokenType: string): boolean {<EOL>    switch (tokenType) {<EOL>        case DELIM_START:<EOL>        case","gt":"DELIM_END:"}
{"input":"<s> function getDefaultValue(type: string | string[]): any {<EOL>    const t: string = Array.isArray(type) ? (<string[]>type)[<NUM_LIT>] : <string>type;<EOL>    switch (t) {<EOL>        case '<STR_LIT>':<EOL>            return false;<EOL>","gt":"case '<STR_LIT>':"}
{"input":"<s> function getDefaultValue(type: string | string[]): any {<EOL>    const t: string = Array.isArray(type) ? (<string[]>type)[<NUM_LIT>] : <string>type;<EOL>    switch (t) {<EOL>        case '<STR_LIT>':<EOL>            return false;<EOL>        case '<STR_LIT>':<EOL>        case '<STR_LIT>':<EOL>            return <NUM_LIT>;<EOL>        case '<STR_LIT>':<EOL>            return","gt":"'<STR_LIT>';"}
{"input":"<s> function getDefaultValue(type: string | string[]): any {<EOL>    const t: string = Array.isArray(type) ? (<string[]>type)[<NUM_LIT>] : <string>type;<EOL>    switch (t) {<EOL>        case '<STR_LIT>':<EOL>            return false;<EOL>        case '<STR_LIT>':<EOL>        case '<STR_LIT>':<EOL>            return <NUM_LIT>;<EOL>        case '<STR_LIT>':<EOL>            return '<STR_LIT>';<EOL>        case '<STR_LIT>':<EOL>            return [];<EOL>        case '<STR_LIT>':<EOL>","gt":"return {};"}
{"input":"<s> export function setNode(root: any, key: string, value: any): void {<EOL>    const segments: string[] = key.split('<STR_LIT>');<EOL>    const last: string = segments.pop();<EOL>    let curr: any = root;<EOL>    segments.forEach((s: string): void => {<EOL>        let obj: any = curr[s];<EOL>","gt":"switch (typeof obj) {"}
{"input":"<s> export function setNode(root: any, key: string, value: any): void {<EOL>    const segments: string[] = key.split('<STR_LIT>');<EOL>    const last: string = segments.pop();<EOL>    let curr: any = root;<EOL>    segments.forEach((s: string): void => {<EOL>        let obj: any = curr[s];<EOL>        switch (typeof obj) {<EOL>            case '<STR_LIT>':<EOL>                obj = curr[s] = Object.create(null);<EOL>                break;<EOL>","gt":"case '<STR_LIT>':"}
{"input":"<s> export function setNode(root: any, key: string, value: any): void {<EOL>    const segments: string[] = key.split('<STR_LIT>');<EOL>    const last: string = segments.pop();<EOL>    let curr: any = root;<EOL>    segments.forEach((s: string): void => {<EOL>        let obj: any = curr[s];<EOL>        switch (typeof obj) {<EOL>            case '<STR_LIT>':<EOL>                obj = curr[s] = Object.create(null);<EOL>                break;<EOL>            case '<STR_LIT>':<EOL>                break;<EOL>            default:<EOL>                console.","gt":"log('<STR_LIT>' + key + '<STR_LIT>' + s + '<STR_LIT>' + JSON.stringify(obj));"}
{"input":"<s> export function parseVersion(version: string): IParsedVersion {<EOL>    if (!isValidVersionStr(version)) {<EOL>        return null;<EOL>    }<EOL>    version = version.trim();<EOL>","gt":"if (version === '<STR_LIT>') {"}
{"input":"<s> export function parseVersion(version: string): IParsedVersion {<EOL>    if (!isValidVersionStr(version)) {<EOL>        return null;<EOL>    }<EOL>    version = version.trim();<EOL>    if (version === '<STR_LIT>') {<EOL>        return {<EOL>            hasCaret: false,<EOL>            majorBase: <NUM_LIT>,<EOL>            majorMustEqual:","gt":"false,"}
{"input":"<s> export function parseVersion(version: string): IParsedVersion {<EOL>    if (!isValidVersionStr(version)) {<EOL>        return null;<EOL>    }<EOL>    version = version.trim();<EOL>    if (version === '<STR_LIT>') {<EOL>        return {<EOL>            hasCaret: false,<EOL>            majorBase: <NUM_LIT>,<EOL>            majorMustEqual: false,<EOL>            minorBase: <NUM_LIT>,<EOL>            minorMustEqual: false,<EOL>            patchBase:","gt":"<NUM_LIT>,"}
{"input":"<s> export function parseVersion(version: string): IParsedVersion {<EOL>    if (!isValidVersionStr(version)) {<EOL>        return null;<EOL>    }<EOL>    version = version.trim();<EOL>    if (version === '<STR_LIT>') {<EOL>        return {<EOL>            hasCaret: false,<EOL>            majorBase: <NUM_LIT>,<EOL>            majorMustEqual: false,<EOL>            minorBase: <NUM_LIT>,<EOL>            minorMustEqual: false,<EOL>            patchBase: <NUM_LIT>,<EOL>            patchMustEqual: false,<EOL>            preRelease:","gt":"null"}
{"input":"<s> export function parseVersion(version: string): IParsedVersion {<EOL>    if (!isValidVersionStr(version)) {<EOL>        return null;<EOL>    }<EOL>    version = version.trim();<EOL>    if (version === '<STR_LIT>') {<EOL>        return {<EOL>            hasCaret: false,<EOL>            majorBase: <NUM_LIT>,<EOL>            majorMustEqual: false,<EOL>            minorBase: <NUM_LIT>,<EOL>            minorMustEqual: false,<EOL>            patchBase: <NUM_LIT>,<EOL>            patchMustEqual: false,<EOL>            preRelease: null<EOL>        };<EOL>    }<EOL>    let m: RegExpMatchArray = version.match(VERSION_REGEXP);<EOL>    return {<EOL>        hasCaret: !!m[<NUM_LIT>],<EOL>        majorBase: m[<NUM_LIT>] === '<STR_LIT>' ? <NUM_LIT> : parseInt(m[<NUM_LIT>], <NUM_LIT>),<EOL>","gt":"majorMustEqual: (m[<NUM_LIT>] === '<STR_LIT>' ? false : true),"}
{"input":"<s> export function registerSingleton<T>(id: ServiceIdentifier<T>, ctor: IConstructorSignature0<T>): void {<EOL>    _registry.","gt":"push({ id, descriptor: new SyncDescriptor<T>(ctor) });"}
{"input":"<s> function randomMarkerData(): IMarkerData {<EOL>    return {<EOL>        severity: <NUM_LIT>,<EOL>        message: Math.random().toString(","gt":"<NUM_LIT>),"}
{"input":"<s> function getOrCreateMachineId(storageService: IStorageService): TPromise<string> {<EOL>    const key: string = '<STR_LIT>';<EOL>    let result: string = storageService.get(key);<EOL>","gt":"if (result) {"}
{"input":"<s> function setWordDefinitionFor(modeId: string, wordDefinition: RegExp): void {<EOL>    _modeId2WordDefinition[","gt":"modeId] = wordDefinition;"}
{"input":"<s> export function fromHover(hover: vscode.Hover): modes.Hover {<EOL>    return <modes.Hover>{<EOL>        range:","gt":"fromRange(hover.range),"}
{"input":"<s> export function fromViewColumn(column?: vscode.ViewColumn): EditorPosition {<EOL>    let editorColumn: EditorPosition = EditorPosition.LEFT;<EOL>    if (typeof column !== '<STR_LIT>') {<EOL>        <EOL>    }<EOL>    else if (column === <number>types.ViewColumn.Two) {<EOL>        editorColumn = EditorPosition.CENTER;<EOL>    }<EOL>    else if (column === <number>types.ViewColumn.Three) {<EOL>        editorColumn =","gt":"EditorPosition.RIGHT;"}
{"input":"<s> function moveActiveEditorToGroup(args: ActiveEditorMoveArguments, activeEditor: IEditor, accessor: ServicesAccessor): void {<EOL>    let newPosition: Position = activeEditor.position;<EOL>    switch (args.to) {<EOL>        case ActiveEditorMovePositioning.LEFT:<EOL>            newPosition = newPosition - <NUM_LIT>;<EOL>","gt":"break;"}
{"input":"<s> function moveActiveEditorToGroup(args: ActiveEditorMoveArguments, activeEditor: IEditor, accessor: ServicesAccessor): void {<EOL>    let newPosition: Position = activeEditor.position;<EOL>    switch (args.to) {<EOL>        case ActiveEditorMovePositioning.LEFT:<EOL>            newPosition = newPosition - <NUM_LIT>;<EOL>            break;<EOL>        case ActiveEditorMovePositioning.RIGHT:<EOL>            newPosition = newPosition + <NUM_LIT>;<EOL>","gt":"break;"}
{"input":"<s> function moveActiveEditorToGroup(args: ActiveEditorMoveArguments, activeEditor: IEditor, accessor: ServicesAccessor): void {<EOL>    let newPosition: Position = activeEditor.position;<EOL>    switch (args.to) {<EOL>        case ActiveEditorMovePositioning.LEFT:<EOL>            newPosition = newPosition - <NUM_LIT>;<EOL>            break;<EOL>        case ActiveEditorMovePositioning.RIGHT:<EOL>            newPosition = newPosition + <NUM_LIT>;<EOL>            break;<EOL>        case ActiveEditorMovePositioning.FIRST:<EOL>            newPosition = Position.LEFT;<EOL>            break;<EOL>        case ActiveEditorMovePositioning.LAST:<EOL>","gt":"newPosition = Position.RIGHT;"}
{"input":"<s> function moveActiveEditorToGroup(args: ActiveEditorMoveArguments, activeEditor: IEditor, accessor: ServicesAccessor): void {<EOL>    let newPosition: Position = activeEditor.position;<EOL>    switch (args.to) {<EOL>        case ActiveEditorMovePositioning.LEFT:<EOL>            newPosition = newPosition - <NUM_LIT>;<EOL>            break;<EOL>        case ActiveEditorMovePositioning.RIGHT:<EOL>            newPosition = newPosition + <NUM_LIT>;<EOL>            break;<EOL>        case ActiveEditorMovePositioning.FIRST:<EOL>            newPosition = Position.LEFT;<EOL>            break;<EOL>        case ActiveEditorMovePositioning.LAST:<EOL>            newPosition = Position.RIGHT;<EOL>            break;<EOL>        case ActiveEditorMovePositioning.CENTER:<EOL>            newPosition = Position.CENTER;<EOL>            break;<EOL>        case","gt":"ActiveEditorMovePositioning.POSITION:"}
{"input":"<s> function registerDiffEditorCommands(): void {<EOL>    KeybindingsRegistry.registerCommandAndKeybindingRule({<EOL>        id: '<STR_LIT>',<EOL>        weight: KeybindingsRegistry.WEIGHT.workbenchContrib(),<EOL>","gt":"when: TextCompareEditorVisible,"}
{"input":"<s> function registerDiffEditorCommands(): void {<EOL>    KeybindingsRegistry.registerCommandAndKeybindingRule({<EOL>        id: '<STR_LIT>',<EOL>        weight: KeybindingsRegistry.WEIGHT.workbenchContrib(),<EOL>        when: TextCompareEditorVisible,<EOL>","gt":"primary: null,"}
{"input":"<s> function registerDiffEditorCommands(): void {<EOL>    KeybindingsRegistry.registerCommandAndKeybindingRule({<EOL>        id: '<STR_LIT>',<EOL>        weight: KeybindingsRegistry.WEIGHT.workbenchContrib(),<EOL>        when: TextCompareEditorVisible,<EOL>        primary: null,<EOL>        handler: (accessor: ServicesAccessor): void => navigateInDiffEditor(accessor, true)<EOL>    });<EOL>    KeybindingsRegistry.","gt":"registerCommandAndKeybindingRule({"}
{"input":"<s> function registerDiffEditorCommands(): void {<EOL>    KeybindingsRegistry.registerCommandAndKeybindingRule({<EOL>        id: '<STR_LIT>',<EOL>        weight: KeybindingsRegistry.WEIGHT.workbenchContrib(),<EOL>        when: TextCompareEditorVisible,<EOL>        primary: null,<EOL>        handler: (accessor: ServicesAccessor): void => navigateInDiffEditor(accessor, true)<EOL>    });<EOL>    KeybindingsRegistry.registerCommandAndKeybindingRule({<EOL>        id: '<STR_LIT>',<EOL>        weight: KeybindingsRegistry.WEIGHT.workbenchContrib(),<EOL>        when:","gt":"TextCompareEditorVisible,"}
{"input":"<s> function registerDiffEditorCommands(): void {<EOL>    KeybindingsRegistry.registerCommandAndKeybindingRule({<EOL>        id: '<STR_LIT>',<EOL>        weight: KeybindingsRegistry.WEIGHT.workbenchContrib(),<EOL>        when: TextCompareEditorVisible,<EOL>        primary: null,<EOL>        handler: (accessor: ServicesAccessor): void => navigateInDiffEditor(accessor, true)<EOL>    });<EOL>    KeybindingsRegistry.registerCommandAndKeybindingRule({<EOL>        id: '<STR_LIT>',<EOL>        weight: KeybindingsRegistry.WEIGHT.workbenchContrib(),<EOL>        when: TextCompareEditorVisible,<EOL>        primary: null,<EOL>        handler: (accessor: ServicesAccessor): void => navigateInDiffEditor(accessor, false)<EOL>    });<EOL>    function navigateInDiffEditor(accessor: ServicesAccessor, next: boolean): void {<EOL>        let editorService: IWorkbenchEditorService = accessor.get(IWorkbenchEditorService);<EOL>        const candidates: IEditor[] = [editorService.getActiveEditor(), ...editorService.getVisibleEditors()].","gt":"filter((e: IEditor): boolean => e instanceof TextDiffEditor);"}
{"input":"<s> function registerDiffEditorCommands(): void {<EOL>    KeybindingsRegistry.registerCommandAndKeybindingRule({<EOL>        id: '<STR_LIT>',<EOL>        weight: KeybindingsRegistry.WEIGHT.workbenchContrib(),<EOL>        when: TextCompareEditorVisible,<EOL>        primary: null,<EOL>        handler: (accessor: ServicesAccessor): void => navigateInDiffEditor(accessor, true)<EOL>    });<EOL>    KeybindingsRegistry.registerCommandAndKeybindingRule({<EOL>        id: '<STR_LIT>',<EOL>        weight: KeybindingsRegistry.WEIGHT.workbenchContrib(),<EOL>        when: TextCompareEditorVisible,<EOL>        primary: null,<EOL>        handler: (accessor: ServicesAccessor): void => navigateInDiffEditor(accessor, false)<EOL>    });<EOL>    function navigateInDiffEditor(accessor: ServicesAccessor, next: boolean): void {<EOL>        let editorService: IWorkbenchEditorService = accessor.get(IWorkbenchEditorService);<EOL>        const candidates: IEditor[] = [editorService.getActiveEditor(), ...editorService.getVisibleEditors()].filter((e: IEditor): boolean => e instanceof TextDiffEditor);<EOL>        if (candidates.length > <NUM_LIT>) {<EOL>            next ? (<TextDiffEditor>candidates[<NUM_LIT>]).getDiffNavigator().next() : (<TextDiffEditor>candidates[<NUM_LIT>]).getDiffNavigator().previous();<EOL>        }<EOL>    }<EOL>    KeybindingsRegistry.registerCommandAndKeybindingRule({<EOL>        id: '<STR_LIT>',<EOL>        weight: KeybindingsRegistry.WEIGHT.workbenchContrib(<NUM_LIT>),<EOL>        handler(accessor: ServicesAccessor) {<EOL>            console.log(`<STR_LIT>`);<EOL>        },<EOL>        when: undefined,<EOL>        primary:","gt":"undefined"}
{"input":"<s> function getCodeEditor(editorWidget: IEditor): ICommonCodeEditor {<EOL>    if (editorWidget) {<EOL>        if (editorWidget.getEditorType() === EditorType.IDiffEditor) {<EOL>            return (<IDiffEditor>editorWidget).","gt":"getModifiedEditor();"}
{"input":"<s> function navigateKeybinding(shift: boolean): IKeybindings {<EOL>    if (shift) {<EOL>        return {<EOL>            primary: KeyMod.CtrlCmd | KeyMod.Shift | KeyCode.KEY_P,<EOL>            secondary: [KeyMod.CtrlCmd | KeyMod.Shift | KeyCode.KEY_E, KeyMod.","gt":"CtrlCmd | KeyMod.Shift | KeyCode.Tab],"}
{"input":"<s> function navigateKeybinding(shift: boolean): IKeybindings {<EOL>    if (shift) {<EOL>        return {<EOL>            primary: KeyMod.CtrlCmd | KeyMod.Shift | KeyCode.KEY_P,<EOL>            secondary: [KeyMod.CtrlCmd | KeyMod.Shift | KeyCode.KEY_E, KeyMod.CtrlCmd | KeyMod.Shift | KeyCode.Tab],<EOL>            mac: {<EOL>                primary: KeyMod.CtrlCmd | KeyMod.Shift | KeyCode.KEY_P,<EOL>                secondary: [KeyMod.WinCtrl | KeyMod.","gt":"Shift | KeyCode.Tab]"}
{"input":"<s> function navigateKeybinding(shift: boolean): IKeybindings {<EOL>    if (shift) {<EOL>        return {<EOL>            primary: KeyMod.CtrlCmd | KeyMod.Shift | KeyCode.KEY_P,<EOL>            secondary: [KeyMod.CtrlCmd | KeyMod.Shift | KeyCode.KEY_E, KeyMod.CtrlCmd | KeyMod.Shift | KeyCode.Tab],<EOL>            mac: {<EOL>                primary: KeyMod.CtrlCmd | KeyMod.Shift | KeyCode.KEY_P,<EOL>                secondary: [KeyMod.WinCtrl | KeyMod.Shift | KeyCode.Tab]<EOL>            }<EOL>        };<EOL>    }<EOL>","gt":"else {"}
{"input":"<s> function navigateKeybinding(shift: boolean): IKeybindings {<EOL>    if (shift) {<EOL>        return {<EOL>            primary: KeyMod.CtrlCmd | KeyMod.Shift | KeyCode.KEY_P,<EOL>            secondary: [KeyMod.CtrlCmd | KeyMod.Shift | KeyCode.KEY_E, KeyMod.CtrlCmd | KeyMod.Shift | KeyCode.Tab],<EOL>            mac: {<EOL>                primary: KeyMod.CtrlCmd | KeyMod.Shift | KeyCode.KEY_P,<EOL>                secondary: [KeyMod.WinCtrl | KeyMod.Shift | KeyCode.Tab]<EOL>            }<EOL>        };<EOL>    }<EOL>    else {<EOL>        return {<EOL>            primary: KeyMod.CtrlCmd | KeyCode.KEY_P,<EOL>            secondary: [KeyMod.CtrlCmd | KeyCode.KEY_E, KeyMod.CtrlCmd | KeyCode.Tab],<EOL>            mac: {<EOL>","gt":"primary: KeyMod.CtrlCmd | KeyCode.KEY_P,"}
{"input":"<s> function getKeyValue(key: string): string {<EOL>    let value: string = window.localStorage.getItem(key);<EOL>    if (!value) {<EOL>        var name: string = key + \"<STR_LIT>\";<EOL>        var ca: string[] = document.cookie.split('<STR_LIT>');<EOL>        for (var i: number = <NUM_LIT>;","gt":"i < ca.length; i++) {"}
{"input":"<s> export function formatPII(value: string, excludePII: boolean, args: {<EOL>    [key: string]: string;<EOL>}): string {<EOL>    return value.replace(_formatPIIRegexp, function (match, group) {<EOL>        if (excludePII && group.length > <NUM_LIT> && group[<NUM_LIT>] !== '<STR_LIT>') {<EOL>            return","gt":"match;"}
{"input":"<s> function toReadablePath(path: string): string {<EOL>    if (!platform.isWindows) {<EOL>","gt":"return path;"}
{"input":"<s> function findSpecificGit(path: string): TPromise<IGit> {<EOL>    return new TPromise<IGit>((c: import(\"<STR_LIT>\").TValueCallback<IGit>, e: (err: any) => void): void => {<EOL>        const buffers: Buffer[] = [];<EOL>        const child:","gt":"import(\"<STR_LIT>\").ChildProcess = spawn(path, ['<STR_LIT>']);"}
{"input":"<s> function fatal(err: any): void {<EOL>    console.","gt":"error(err);"}
{"input":"<s> export function newConfigFile(value: string): IConfigFile {<EOL>    try {<EOL>        const root: any = Object.create(null);<EOL>        const contents: any = json.parse(value) || {};<EOL>        for (let key: string in contents) {<EOL>","gt":"model.setNode(root, key, contents[key]);"}
{"input":"<s> export function newConfigFile(value: string): IConfigFile {<EOL>    try {<EOL>        const root: any = Object.create(null);<EOL>        const contents: any = json.parse(value) || {};<EOL>        for (let key: string in contents) {<EOL>            model.setNode(root, key, contents[key]);<EOL>        }<EOL>        return {<EOL>            contents: root<EOL>        };<EOL>    }<EOL>    catch (e: any) {<EOL>        return {<EOL>","gt":"contents: {},"}
{"input":"<s> function _processThemeObject(themeId: string, themeDocument: IThemeDocument): string {<EOL>    let cssRules: string[] = [];<EOL>    let themeSettings: IThemeSetting[] = themeDocument.settings;<EOL>    if (Array.","gt":"isArray(themeSettings)) {"}
{"input":"<s> function toResource(path: any): URI {<EOL>    return","gt":"URI.file(paths.join('<STR_LIT>', path));"}
{"input":"<s> <EOL>export function uniqueConstraint(constraintName: string | Array<string>, fields?: string | Array<string>): (target: Object) => void {<EOL>    return (","gt":"target: Object): void => {"}
{"input":"<s> function getMapping(wetland: any, entity: any): any {<EOL>    return wetland.getEntityManager().","gt":"getMapping(entity);"}
{"input":"<s> function testUsers(manager: Scope, bypassLifecyclehooks: boolean): Promise<any> {<EOL>    let usersFromFile: any = require(path.join(fixturesDir, getType(bypassLifecyclehooks), '<STR_LIT>'));<EOL>    return manager.getRepository(User)<EOL>        .find(null, { populate: ['<STR_LIT>'] })<EOL>        .","gt":"then((users: User[]): void => {"}
{"input":"<s> export function createJsonHttp(xhrBackend: XHRBackend, requestOptions: RequestOptions): JsonHttp {<EOL>","gt":"const ngHttp: any = new Http(xhrBackend, requestOptions);"}
{"input":"<s> export default function Item(sources: Sources): Sinks {<EOL>    const state$: any = sources.onion.state$;<EOL>    const vdom$: any = state$.map((state: any): any => li('<STR_LIT>', [<EOL>        span('<STR_LIT>', `<STR_LIT>`),<EOL>        span(","gt":"'<STR_LIT>', '<STR_LIT>'),"}
{"input":"<s> export default function Item(sources: Sources): Sinks {<EOL>    const state$: any = sources.onion.state$;<EOL>    const vdom$: any = state$.map((state: any): any => li('<STR_LIT>', [<EOL>        span('<STR_LIT>', `<STR_LIT>`),<EOL>        span('<STR_LIT>', '<STR_LIT>'),<EOL>        button('<STR_LIT>', '<STR_LIT>'),<EOL>        button('<STR_LIT>', '<STR_LIT>'),<EOL>        span('<STR_LIT>',","gt":"state.count}`<STR_LIT>,"}
{"input":"<s> export default function Item(sources: Sources): Sinks {<EOL>    const state$: any = sources.onion.state$;<EOL>    const vdom$: any = state$.map((state: any): any => li('<STR_LIT>', [<EOL>        span('<STR_LIT>', `<STR_LIT>`),<EOL>        span('<STR_LIT>', '<STR_LIT>'),<EOL>        button('<STR_LIT>', '<STR_LIT>'),<EOL>        button('<STR_LIT>', '<STR_LIT>'),<EOL>        span('<STR_LIT>', `<STR_LIT>`),<EOL>    ]));<EOL>    const removeReducer$: any = sources.DOM<EOL>        .select('<STR_LIT>').events('<STR_LIT>')<EOL>        .mapTo(function removeReducer(prevState: State): State {<EOL>","gt":"return void <NUM_LIT>;"}
{"input":"<s> export function joinNetwork(dat: any): Observable<any> {<EOL>    return Observable.","gt":"bindNodeCallback<any>(dat.joinNetwork.bind(dat))();"}
{"input":"<s> function connectedPub(peer: SSBPeer): boolean {<EOL>    return peer.","gt":"state === '<STR_LIT>';"}
{"input":"<s> function isAddAttribute(diff: Diff): diff is AddAttributeDiff {<EOL>    return diff.","gt":"action === '<STR_LIT>';"}
{"input":"<s> function splitReplaceDiff(diff: Diff): Array<Diff> {<EOL>    if (diff.action !== '<STR_LIT>') {<EOL>        return [diff];<EOL>    }<EOL>    if (!isWildcardComment(diff.oldValue)) {<EOL>        return [diff];<EOL>    }<EOL>    const removeDiff: RemoveElementDiff = {<EOL>        action: '<STR_LIT>',<EOL>        route: diff.route,<EOL>        element:","gt":"diff.oldValue,"}
{"input":"<s> function splitReplaceDiff(diff: Diff): Array<Diff> {<EOL>    if (diff.action !== '<STR_LIT>') {<EOL>        return [diff];<EOL>    }<EOL>    if (!isWildcardComment(diff.oldValue)) {<EOL>        return [diff];<EOL>    }<EOL>    const removeDiff: RemoveElementDiff = {<EOL>        action: '<STR_LIT>',<EOL>        route: diff.route,<EOL>        element: diff.oldValue,<EOL>    };<EOL>    const addDiff: AddElementDiff = {<EOL>        action:","gt":"'<STR_LIT>',"}
{"input":"<s> function isNotNull(x: Measurements | null): x is Measurements {<EOL>    return x !==","gt":"null;"}
{"input":"<s> export function dialogDriver(request$: Stream<Request>): Stream<Response> {<EOL>    const response$: any = xs.create<Response>();<EOL>    request$.addListener({<EOL>        next: (request: any): void => {<EOL>            const","gt":"category: any = request.category;"}
{"input":"<s> export function dialogDriver(request$: Stream<Request>): Stream<Response> {<EOL>    const response$: any = xs.create<Response>();<EOL>    request$.addListener({<EOL>        next: (request: any): void => {<EOL>            const category: any = request.category;<EOL>            const dialog: any = new DialogAndroid();<EOL>            dialog.set({<EOL>                ...","gt":"request,"}
{"input":"<s> export function dialogDriver(request$: Stream<Request>): Stream<Response> {<EOL>    const response$: any = xs.create<Response>();<EOL>    request$.addListener({<EOL>        next: (request: any): void => {<EOL>            const category: any = request.category;<EOL>            const dialog: any = new DialogAndroid();<EOL>            dialog.set({<EOL>                ...request,<EOL>                onPositive: (): void => {<EOL>                    response$.shamefullySendNext({ category, type: '<STR_LIT>' });<EOL>                },<EOL>                onNegative: (): void => {<EOL>                    response$.shamefullySendNext({ category, type:","gt":"'<STR_LIT>' });"}
{"input":"<s> export function isContactMsg(msg: Msg<any>): msg is Msg<ContactContent> {<EOL>    return msg.value.content &&","gt":"msg.value.content.type === '<STR_LIT>';"}
{"input":"<s> function cp<T>(a: Array<T>): Array<T> {<EOL>    const l: number = a.length;<EOL>","gt":"const b: any[] = Array(l);"}
{"input":"<s> export function getModule(name: string): Dictionary<SyntaxTree.FileBlockFunction> {<EOL>","gt":"return modules.get(name);"}
{"input":"<s> export function rect(): Specification.Mark {<EOL>    return compile(`<STR_LIT>`)[","gt":"\"<STR_LIT>\"];"}
{"input":"<s> export function cloneDate(d: any): Date {<EOL>    return new Date(d.","gt":"getTime());"}
{"input":"<s> <EOL>export function AfterAll(n: number): LodashDecorator {<EOL>    return","gt":"decorator(n);"}
{"input":"<s> <EOL>export function Delay(wait: number, ...args: any[]): LodashMethodDecorator {<EOL>    return decorator(","gt":"wait, ...args);"}
{"input":"<s> <EOL>export function Flow(...fns: ResolvableFunction[]): LodashDecorator {<EOL>    return","gt":"decorator(...fns);"}
{"input":"<s> <EOL>export function assignProperty<T, U>(to: T, from: U, prop: string): void {<EOL>    const descriptor: PropertyDescriptor | undefined = Object.getOwnPropertyDescriptor(to, prop);<EOL>    if (!descriptor || descriptor.configurable) {<EOL>        const srcDescriptor: PropertyDescriptor | undefined = Object.getOwnPropertyDescriptor(from, prop);<EOL>        if (","gt":"isObject(srcDescriptor)) {"}
{"input":"<s> <EOL>export function assignProperty<T, U>(to: T, from: U, prop: string): void {<EOL>    const descriptor: PropertyDescriptor | undefined = Object.getOwnPropertyDescriptor(to, prop);<EOL>    if (!descriptor || descriptor.configurable) {<EOL>        const srcDescriptor: PropertyDescriptor | undefined = Object.getOwnPropertyDescriptor(from, prop);<EOL>        if (isObject(srcDescriptor)) {<EOL>            Object.defineProperty(to, prop, srcDescriptor);<EOL>        }<EOL>        else {<EOL>            (to as any)[","gt":"prop] = (from as any)[prop];"}
{"input":"<s> <EOL>export function bind(fn: Function, context: any): Function {<EOL>    return copyMetadata(fn.","gt":"bind(context), fn);"}
{"input":"<s> <EOL>export function resolveFunction(method?: string | Function, context?: any, target?: any, throwNotFound: boolean = true): any {<EOL>    if (isFunction(method)) {<EOL>        return method;<EOL>    }<EOL>    else if (isString(method)) {<EOL>        if (context &&","gt":"isFunction(context[method])) {"}
{"input":"<s> <EOL>async function authenticateRequest(getStrategy: Getter<Strategy>, request: ParsedRequest, setCurrentUser: Setter<UserProfile>): Promise<UserProfile | undefined> {<EOL>    const strategy: any = await getStrategy();<EOL>    if (!strategy) {<EOL>        <EOL>","gt":"return undefined;"}
{"input":"<s> <EOL>async function authenticateRequest(getStrategy: Getter<Strategy>, request: ParsedRequest, setCurrentUser: Setter<UserProfile>): Promise<UserProfile | undefined> {<EOL>    const strategy: any = await getStrategy();<EOL>    if (!strategy) {<EOL>        <EOL>        return undefined;<EOL>    }<EOL>    if (!strategy.authenticate) {<EOL>        return Promise.reject(new Error('<STR_LIT>'));<EOL>    }<EOL>    const strategyAdapter: StrategyAdapter = new StrategyAdapter(strategy);<EOL>    const user: UserProfile = await","gt":"strategyAdapter.authenticate(request);"}
{"input":"<s> <EOL>function isBinding(element: ResolutionElement | undefined): element is BindingElement {<EOL>    return element != null && element.","gt":"type === '<STR_LIT>';"}
{"input":"<s> <EOL>export function instantiateClass<T>(ctor: Constructor<T>, ctx: Context, session?: ResolutionSession, <EOL><EOL>nonInjectedArgs?: any[]): ValueOrPromise<T> {<EOL>    <EOL>    if (debug.enabled) {<EOL>        debug('<STR_LIT>',","gt":"getTargetName(ctor));"}
{"input":"<s> <EOL>export function instantiateClass<T>(ctor: Constructor<T>, ctx: Context, session?: ResolutionSession, <EOL><EOL>nonInjectedArgs?: any[]): ValueOrPromise<T> {<EOL>    <EOL>    if (debug.enabled) {<EOL>        debug('<STR_LIT>', getTargetName(ctor));<EOL>        if (nonInjectedArgs && nonInjectedArgs.length) {<EOL>            debug(","gt":"'<STR_LIT>', nonInjectedArgs);"}
{"input":"<s> <EOL>export function instantiateClass<T>(ctor: Constructor<T>, ctx: Context, session?: ResolutionSession, <EOL><EOL>nonInjectedArgs?: any[]): ValueOrPromise<T> {<EOL>    <EOL>    if (debug.enabled) {<EOL>        debug('<STR_LIT>', getTargetName(ctor));<EOL>        if (nonInjectedArgs && nonInjectedArgs.length) {<EOL>            debug('<STR_LIT>', nonInjectedArgs);<EOL>        }<EOL>    }<EOL>    const argsOrPromise: ValueOrPromise<any[]> = resolveInjectedArguments(ctor, '<STR_LIT>', ctx, session);<EOL>    const propertiesOrPromise: ValueOrPromise<MapObject<any>> = resolveInjectedProperties(ctor, ctx, session);<EOL>    let inst: ValueOrPromise<T>;<EOL>    if (","gt":"isPromise(argsOrPromise)) {"}
{"input":"<s> <EOL>export function instantiateClass<T>(ctor: Constructor<T>, ctx: Context, session?: ResolutionSession, <EOL><EOL>nonInjectedArgs?: any[]): ValueOrPromise<T> {<EOL>    <EOL>    if (debug.enabled) {<EOL>        debug('<STR_LIT>', getTargetName(ctor));<EOL>        if (nonInjectedArgs && nonInjectedArgs.length) {<EOL>            debug('<STR_LIT>', nonInjectedArgs);<EOL>        }<EOL>    }<EOL>    const argsOrPromise: ValueOrPromise<any[]> = resolveInjectedArguments(ctor, '<STR_LIT>', ctx, session);<EOL>    const propertiesOrPromise: ValueOrPromise<MapObject<any>> = resolveInjectedProperties(ctor, ctx, session);<EOL>    let inst: ValueOrPromise<T>;<EOL>    if (isPromise(argsOrPromise)) {<EOL>        <EOL>        inst = argsOrPromise.then((args: any[]): T => {<EOL>            <EOL>            if (debug.enabled) {<EOL>                debug('<STR_LIT>', ctor.name, args);<EOL>            }<EOL>            return","gt":"new ctor(...args);"}
{"input":"<s> <EOL>export function instantiateClass<T>(ctor: Constructor<T>, ctx: Context, session?: ResolutionSession, <EOL><EOL>nonInjectedArgs?: any[]): ValueOrPromise<T> {<EOL>    <EOL>    if (debug.enabled) {<EOL>        debug('<STR_LIT>', getTargetName(ctor));<EOL>        if (nonInjectedArgs && nonInjectedArgs.length) {<EOL>            debug('<STR_LIT>', nonInjectedArgs);<EOL>        }<EOL>    }<EOL>    const argsOrPromise: ValueOrPromise<any[]> = resolveInjectedArguments(ctor, '<STR_LIT>', ctx, session);<EOL>    const propertiesOrPromise: ValueOrPromise<MapObject<any>> = resolveInjectedProperties(ctor, ctx, session);<EOL>    let inst: ValueOrPromise<T>;<EOL>    if (isPromise(argsOrPromise)) {<EOL>        <EOL>        inst = argsOrPromise.then((args: any[]): T => {<EOL>            <EOL>            if (debug.enabled) {<EOL>                debug('<STR_LIT>', ctor.name, args);<EOL>            }<EOL>            return new ctor(...args);<EOL>        });<EOL>    }<EOL>    else {<EOL>        <EOL>        if (debug.enabled) {<EOL>            debug(","gt":"'<STR_LIT>', ctor.name, argsOrPromise);"}
{"input":"<s> <EOL>export function instantiateClass<T>(ctor: Constructor<T>, ctx: Context, session?: ResolutionSession, <EOL><EOL>nonInjectedArgs?: any[]): ValueOrPromise<T> {<EOL>    <EOL>    if (debug.enabled) {<EOL>        debug('<STR_LIT>', getTargetName(ctor));<EOL>        if (nonInjectedArgs && nonInjectedArgs.length) {<EOL>            debug('<STR_LIT>', nonInjectedArgs);<EOL>        }<EOL>    }<EOL>    const argsOrPromise: ValueOrPromise<any[]> = resolveInjectedArguments(ctor, '<STR_LIT>', ctx, session);<EOL>    const propertiesOrPromise: ValueOrPromise<MapObject<any>> = resolveInjectedProperties(ctor, ctx, session);<EOL>    let inst: ValueOrPromise<T>;<EOL>    if (isPromise(argsOrPromise)) {<EOL>        <EOL>        inst = argsOrPromise.then((args: any[]): T => {<EOL>            <EOL>            if (debug.enabled) {<EOL>                debug('<STR_LIT>', ctor.name, args);<EOL>            }<EOL>            return new ctor(...args);<EOL>        });<EOL>    }<EOL>    else {<EOL>        <EOL>        if (debug.enabled) {<EOL>            debug('<STR_LIT>', ctor.name, argsOrPromise);<EOL>        }<EOL>        <EOL>        inst = new ctor(...argsOrPromise);<EOL>    }<EOL>    if (isPromise(propertiesOrPromise)) {<EOL>        return propertiesOrPromise.then((props: MapObject<any>): (T & MapObject<any>) | Promise<T & MapObject<any>> => {<EOL>            <EOL>            if (","gt":"debug.enabled) {"}
{"input":"<s> <EOL>export function instantiateClass<T>(ctor: Constructor<T>, ctx: Context, session?: ResolutionSession, <EOL><EOL>nonInjectedArgs?: any[]): ValueOrPromise<T> {<EOL>    <EOL>    if (debug.enabled) {<EOL>        debug('<STR_LIT>', getTargetName(ctor));<EOL>        if (nonInjectedArgs && nonInjectedArgs.length) {<EOL>            debug('<STR_LIT>', nonInjectedArgs);<EOL>        }<EOL>    }<EOL>    const argsOrPromise: ValueOrPromise<any[]> = resolveInjectedArguments(ctor, '<STR_LIT>', ctx, session);<EOL>    const propertiesOrPromise: ValueOrPromise<MapObject<any>> = resolveInjectedProperties(ctor, ctx, session);<EOL>    let inst: ValueOrPromise<T>;<EOL>    if (isPromise(argsOrPromise)) {<EOL>        <EOL>        inst = argsOrPromise.then((args: any[]): T => {<EOL>            <EOL>            if (debug.enabled) {<EOL>                debug('<STR_LIT>', ctor.name, args);<EOL>            }<EOL>            return new ctor(...args);<EOL>        });<EOL>    }<EOL>    else {<EOL>        <EOL>        if (debug.enabled) {<EOL>            debug('<STR_LIT>', ctor.name, argsOrPromise);<EOL>        }<EOL>        <EOL>        inst = new ctor(...argsOrPromise);<EOL>    }<EOL>    if (isPromise(propertiesOrPromise)) {<EOL>        return propertiesOrPromise.then((props: MapObject<any>): (T & MapObject<any>) | Promise<T & MapObject<any>> => {<EOL>            <EOL>            if (debug.enabled) {<EOL>                debug('<STR_LIT>', ctor.name, props);<EOL>            }<EOL>            if (isPromise(inst)) {<EOL>                <EOL>                return inst.then((obj: T): T & MapObject<any> => Object.assign(obj, props));<EOL>            }<EOL>            else {<EOL>                <EOL>                return Object.assign(inst, props);<EOL>            }<EOL>        });<EOL>    }<EOL>    else {<EOL>        if (isPromise(inst)) {<EOL>            <EOL>","gt":"if (debug.enabled) {"}
{"input":"<s> <EOL>export function createEmptyApiSpec(): OpenApiSpec {<EOL>    return {<EOL>        swagger: '<STR_LIT>',<EOL>","gt":"basePath: '<STR_LIT>',"}
{"input":"<s> <EOL><EOL>function ensurePromise<T>(p: juggler.PromiseOrVoid<T>): Promise<T> {<EOL>    if (p && isPromise(p)) {<EOL>","gt":"return p;"}
{"input":"<s> <EOL>export function writeErrorToResponse(response: Response, error: Error): void {<EOL>    const e: HttpError = <HttpError>error;<EOL>    const statusCode: any = (response.statusCode = e.statusCode || e.status || <NUM_LIT>);<EOL>    if (e.headers) {<EOL>        <EOL>        for (const","gt":"h: string in e.headers) {"}
{"input":"<s> <EOL>export function writeErrorToResponse(response: Response, error: Error): void {<EOL>    const e: HttpError = <HttpError>error;<EOL>    const statusCode: any = (response.statusCode = e.statusCode || e.status || <NUM_LIT>);<EOL>    if (e.headers) {<EOL>        <EOL>        for (const h: string in e.headers) {<EOL>            response.setHeader(h, e.headers[h]);<EOL>        }<EOL>    }<EOL>    <EOL>    const errObj: Partial<HttpError> = {<EOL>","gt":"statusCode,"}
{"input":"<s> <EOL>export function createClientForHandler(handler: (req: http.ServerRequest, res: http.ServerResponse) => void): Client {<EOL>","gt":"const server: any = http.createServer(handler);"}
{"input":"<s> export default function getPaths(callback: (err: LocalizedError, corePath?: string, dataPath?: string) => void): void {<EOL>    let dataPath: string;<EOL>    let corePath: any = argv[\"<STR_LIT>\"] != null ? path.resolve(argv[\"<STR_LIT>\"]) : null;<EOL>    if (corePath != null) {<EOL>","gt":"dataPath = corePath;"}
{"input":"<s> export default function getPaths(callback: (err: LocalizedError, corePath?: string, dataPath?: string) => void): void {<EOL>    let dataPath: string;<EOL>    let corePath: any = argv[\"<STR_LIT>\"] != null ? path.resolve(argv[\"<STR_LIT>\"]) : null;<EOL>    if (corePath != null) {<EOL>        dataPath = corePath;<EOL>        process.nextTick((): void => { callback(null, corePath, dataPath); });<EOL>","gt":"return;"}
{"input":"<s> export default function getPaths(callback: (err: LocalizedError, corePath?: string, dataPath?: string) => void): void {<EOL>    let dataPath: string;<EOL>    let corePath: any = argv[\"<STR_LIT>\"] != null ? path.resolve(argv[\"<STR_LIT>\"]) : null;<EOL>    if (corePath != null) {<EOL>        dataPath = corePath;<EOL>        process.nextTick((): void => { callback(null, corePath, dataPath); });<EOL>        return;<EOL>    }<EOL>    try {<EOL>        dataPath = path.join(","gt":"electron.app.getPath(\"<STR_LIT>\"), \"<STR_LIT>\");"}
{"input":"<s> export default function getPaths(callback: (err: LocalizedError, corePath?: string, dataPath?: string) => void): void {<EOL>    let dataPath: string;<EOL>    let corePath: any = argv[\"<STR_LIT>\"] != null ? path.resolve(argv[\"<STR_LIT>\"]) : null;<EOL>    if (corePath != null) {<EOL>        dataPath = corePath;<EOL>        process.nextTick((): void => { callback(null, corePath, dataPath); });<EOL>        return;<EOL>    }<EOL>    try {<EOL>        dataPath = path.join(electron.app.getPath(\"<STR_LIT>\"), \"<STR_LIT>\");<EOL>    }<EOL>    catch (err: any) {<EOL>        process.nextTick((): void => { callback(new LocalizedError(\"<STR_LIT>\", { details: err.message })); });<EOL>        return;<EOL>    }<EOL>    console.","gt":"log(dataPath);"}
{"input":"<s> export default function getPaths(callback: (err: LocalizedError, corePath?: string, dataPath?: string) => void): void {<EOL>    let dataPath: string;<EOL>    let corePath: any = argv[\"<STR_LIT>\"] != null ? path.resolve(argv[\"<STR_LIT>\"]) : null;<EOL>    if (corePath != null) {<EOL>        dataPath = corePath;<EOL>        process.nextTick((): void => { callback(null, corePath, dataPath); });<EOL>        return;<EOL>    }<EOL>    try {<EOL>        dataPath = path.join(electron.app.getPath(\"<STR_LIT>\"), \"<STR_LIT>\");<EOL>    }<EOL>    catch (err: any) {<EOL>        process.nextTick((): void => { callback(new LocalizedError(\"<STR_LIT>\", { details: err.message })); });<EOL>        return;<EOL>    }<EOL>    console.log(dataPath);<EOL>    if (!fs.existsSync(dataPath)) {<EOL>        <EOL>        <EOL>        let oldDataPath: string;<EOL>        switch (","gt":"process.platform) {"}
{"input":"<s> export default function getPaths(callback: (err: LocalizedError, corePath?: string, dataPath?: string) => void): void {<EOL>    let dataPath: string;<EOL>    let corePath: any = argv[\"<STR_LIT>\"] != null ? path.resolve(argv[\"<STR_LIT>\"]) : null;<EOL>    if (corePath != null) {<EOL>        dataPath = corePath;<EOL>        process.nextTick((): void => { callback(null, corePath, dataPath); });<EOL>        return;<EOL>    }<EOL>    try {<EOL>        dataPath = path.join(electron.app.getPath(\"<STR_LIT>\"), \"<STR_LIT>\");<EOL>    }<EOL>    catch (err: any) {<EOL>        process.nextTick((): void => { callback(new LocalizedError(\"<STR_LIT>\", { details: err.message })); });<EOL>        return;<EOL>    }<EOL>    console.log(dataPath);<EOL>    if (!fs.existsSync(dataPath)) {<EOL>        <EOL>        <EOL>        let oldDataPath: string;<EOL>        switch (process.platform) {<EOL>            case \"<STR_LIT>\":<EOL>                if (process.env.APPDATA != null)<EOL>                    oldDataPath = path.join(process.env.APPDATA, \"<STR_LIT>\");<EOL>                break;<EOL>            case \"<STR_LIT>\":<EOL>                if (","gt":"process.env.HOME != null)"}
{"input":"<s> export default function getPaths(callback: (err: LocalizedError, corePath?: string, dataPath?: string) => void): void {<EOL>    let dataPath: string;<EOL>    let corePath: any = argv[\"<STR_LIT>\"] != null ? path.resolve(argv[\"<STR_LIT>\"]) : null;<EOL>    if (corePath != null) {<EOL>        dataPath = corePath;<EOL>        process.nextTick((): void => { callback(null, corePath, dataPath); });<EOL>        return;<EOL>    }<EOL>    try {<EOL>        dataPath = path.join(electron.app.getPath(\"<STR_LIT>\"), \"<STR_LIT>\");<EOL>    }<EOL>    catch (err: any) {<EOL>        process.nextTick((): void => { callback(new LocalizedError(\"<STR_LIT>\", { details: err.message })); });<EOL>        return;<EOL>    }<EOL>    console.log(dataPath);<EOL>    if (!fs.existsSync(dataPath)) {<EOL>        <EOL>        <EOL>        let oldDataPath: string;<EOL>        switch (process.platform) {<EOL>            case \"<STR_LIT>\":<EOL>                if (process.env.APPDATA != null)<EOL>                    oldDataPath = path.join(process.env.APPDATA, \"<STR_LIT>\");<EOL>                break;<EOL>            case \"<STR_LIT>\":<EOL>                if (process.env.HOME != null)<EOL>                    oldDataPath = path.join(process.env.HOME, \"<STR_LIT>\", \"<STR_LIT>\");<EOL>                break;<EOL>            default:<EOL>                if (process.env.XDG_DATA_HOME != null)<EOL>                    oldDataPath = path.join(process.env.XDG_DATA_HOME, \"<STR_LIT>\");<EOL>                else if (process.env.HOME != null)<EOL>                    oldDataPath = path.join(process.env.HOME, \"<STR_LIT>\", \"<STR_LIT>\");<EOL>        }<EOL>        if (oldDataPath != null && fs.existsSync(oldDataPath)) {<EOL>","gt":"console.log(`<STR_LIT>`);"}
{"input":"<s> export default function getPaths(callback: (err: LocalizedError, corePath?: string, dataPath?: string) => void): void {<EOL>    let dataPath: string;<EOL>    let corePath: any = argv[\"<STR_LIT>\"] != null ? path.resolve(argv[\"<STR_LIT>\"]) : null;<EOL>    if (corePath != null) {<EOL>        dataPath = corePath;<EOL>        process.nextTick((): void => { callback(null, corePath, dataPath); });<EOL>        return;<EOL>    }<EOL>    try {<EOL>        dataPath = path.join(electron.app.getPath(\"<STR_LIT>\"), \"<STR_LIT>\");<EOL>    }<EOL>    catch (err: any) {<EOL>        process.nextTick((): void => { callback(new LocalizedError(\"<STR_LIT>\", { details: err.message })); });<EOL>        return;<EOL>    }<EOL>    console.log(dataPath);<EOL>    if (!fs.existsSync(dataPath)) {<EOL>        <EOL>        <EOL>        let oldDataPath: string;<EOL>        switch (process.platform) {<EOL>            case \"<STR_LIT>\":<EOL>                if (process.env.APPDATA != null)<EOL>                    oldDataPath = path.join(process.env.APPDATA, \"<STR_LIT>\");<EOL>                break;<EOL>            case \"<STR_LIT>\":<EOL>                if (process.env.HOME != null)<EOL>                    oldDataPath = path.join(process.env.HOME, \"<STR_LIT>\", \"<STR_LIT>\");<EOL>                break;<EOL>            default:<EOL>                if (process.env.XDG_DATA_HOME != null)<EOL>                    oldDataPath = path.join(process.env.XDG_DATA_HOME, \"<STR_LIT>\");<EOL>                else if (process.env.HOME != null)<EOL>                    oldDataPath = path.join(process.env.HOME, \"<STR_LIT>\", \"<STR_LIT>\");<EOL>        }<EOL>        if (oldDataPath != null && fs.existsSync(oldDataPath)) {<EOL>            console.log(`<STR_LIT>`);<EOL>            fs.renameSync(oldDataPath, dataPath);<EOL>        }<EOL>    }<EOL>    corePath = path.join(dataPath, \"<STR_LIT>\");<EOL>    fs.mkdir(dataPath, (err: any): void => {<EOL>        if (err !=","gt":"null && err.code !== \"<STR_LIT>\") {"}
{"input":"<s> export function onPresenceUpdated(): void {<EOL>    if (settings.presence !== \"<STR_LIT>\") {<EOL>        if (socket == null)<EOL>            connect();<EOL>","gt":"else {"}
{"input":"<s> export function onPresenceUpdated(): void {<EOL>    if (settings.presence !== \"<STR_LIT>\") {<EOL>        if (socket == null)<EOL>            connect();<EOL>        else {<EOL>            <EOL>            <EOL>            irc.write(`<STR_LIT>`);<EOL>        }<EOL>    }<EOL>","gt":"else {"}
{"input":"<s> export function setStatus(text: string): void {<EOL>","gt":"statusElt.textContent = text;"}
{"input":"<s> export function load(contextNames: string[], callback: () => void): void {<EOL>    async.each(contextNames, loadContext.bind(null, languageCode, contexts), (): void => {<EOL>        if (languageCode === \"<STR_LIT>\") {<EOL>","gt":"callback();"}
{"input":"<s> function onDisconnected(): void {<EOL>    SupClient.Dialogs.cancelDialogIfAny();<EOL>    data.projects = null;<EOL>","gt":"ui.projectsTreeView.clearSelection();"}
{"input":"<s> function onClickToggleNotifications(event: any): void {<EOL>    let notificationsDisabled: boolean = (localStorage.getItem(\"<STR_LIT>\") != null) ? true : false;<EOL>    notificationsDisabled = !notificationsDisabled;<EOL>    if (!notificationsDisabled) {<EOL>        localStorage.removeItem(","gt":"\"<STR_LIT>\");"}
{"input":"<s> function onClickToggleNotifications(event: any): void {<EOL>    let notificationsDisabled: boolean = (localStorage.getItem(\"<STR_LIT>\") != null) ? true : false;<EOL>    notificationsDisabled = !notificationsDisabled;<EOL>    if (!notificationsDisabled) {<EOL>        localStorage.removeItem(\"<STR_LIT>\");<EOL>        event.target.classList.remove(\"<STR_LIT>\");<EOL>        event.target.title = SupClient.i18n.t(\"<STR_LIT>\");<EOL>    }<EOL>    else {<EOL>        localStorage.setItem(\"<STR_LIT>\", \"<STR_LIT>\");<EOL>        event.target.classList.","gt":"add(\"<STR_LIT>\");"}
{"input":"<s> function onSetEntryProperty(id: string, key: string, value: any): void {<EOL>    entries.client_setProperty(id, key, value);<EOL>    const entryElt: any = entriesTreeView.widget.treeRoot.querySelector(`<STR_LIT>`);<EOL>    switch (key) {<EOL>        case \"<STR_LIT>\":<EOL>            entryElt.","gt":"querySelector(\"<STR_LIT>\").textContent = value;"}
{"input":"<s> function onSetManifestProperty(key: string, value: any): void {<EOL>    manifest.client_setProperty(key, value);<EOL>    switch (key) {<EOL>","gt":"case \"<STR_LIT>\":"}
{"input":"<s> function destroyRunWindow(): void {<EOL>    runWindowDestroyTimeout = null;<EOL>","gt":"if (runWindow != null) {"}
{"input":"<s> function initPlugin(systemFolderName: string, systemId: string, pluginName: string): void {<EOL>    const pluginSlug: string = pluginName.replace(/\\//g, \"<STR_LIT>\").replace(/[A-Z]/g, (x: string): string => `<STR_LIT>`);<EOL>    const packageJSON: string = JSON.stringify({<EOL>        name: `<STR_LIT>`,<EOL>        description: `<STR_LIT>`,<EOL>","gt":"scripts: {"}
{"input":"<s> function initPlugin(systemFolderName: string, systemId: string, pluginName: string): void {<EOL>    const pluginSlug: string = pluginName.replace(/\\//g, \"<STR_LIT>\").replace(/[A-Z]/g, (x: string): string => `<STR_LIT>`);<EOL>    const packageJSON: string = JSON.stringify({<EOL>        name: `<STR_LIT>`,<EOL>        description: `<STR_LIT>`,<EOL>        scripts: {<EOL>            \"<STR_LIT>\": \"<STR_LIT>\"<EOL>        }<EOL>    }, null, <NUM_LIT>) + \"<STR_LIT>\";<EOL>    const pluginPath: string =","gt":"}/${systemFolderName}/plugins/${pluginName}`<STR_LIT>;"}
{"input":"<s> function initPlugin(systemFolderName: string, systemId: string, pluginName: string): void {<EOL>    const pluginSlug: string = pluginName.replace(/\\//g, \"<STR_LIT>\").replace(/[A-Z]/g, (x: string): string => `<STR_LIT>`);<EOL>    const packageJSON: string = JSON.stringify({<EOL>        name: `<STR_LIT>`,<EOL>        description: `<STR_LIT>`,<EOL>        scripts: {<EOL>            \"<STR_LIT>\": \"<STR_LIT>\"<EOL>        }<EOL>    }, null, <NUM_LIT>) + \"<STR_LIT>\";<EOL>    const pluginPath: string = `<STR_LIT>`;<EOL>    mkdirp.sync(pluginPath);<EOL>    fs.writeFileSync(`<STR_LIT>`, packageJSON);<EOL>    const tsconfigJSON: string = JSON.","gt":"stringify({"}
{"input":"<s> function initPlugin(systemFolderName: string, systemId: string, pluginName: string): void {<EOL>    const pluginSlug: string = pluginName.replace(/\\//g, \"<STR_LIT>\").replace(/[A-Z]/g, (x: string): string => `<STR_LIT>`);<EOL>    const packageJSON: string = JSON.stringify({<EOL>        name: `<STR_LIT>`,<EOL>        description: `<STR_LIT>`,<EOL>        scripts: {<EOL>            \"<STR_LIT>\": \"<STR_LIT>\"<EOL>        }<EOL>    }, null, <NUM_LIT>) + \"<STR_LIT>\";<EOL>    const pluginPath: string = `<STR_LIT>`;<EOL>    mkdirp.sync(pluginPath);<EOL>    fs.writeFileSync(`<STR_LIT>`, packageJSON);<EOL>    const tsconfigJSON: string = JSON.stringify({<EOL>        \"<STR_LIT>\": {<EOL>            \"<STR_LIT>\": \"<STR_LIT>\",<EOL>","gt":"\"<STR_LIT>\": \"<STR_LIT>\","}
{"input":"<s> function initPlugin(systemFolderName: string, systemId: string, pluginName: string): void {<EOL>    const pluginSlug: string = pluginName.replace(/\\//g, \"<STR_LIT>\").replace(/[A-Z]/g, (x: string): string => `<STR_LIT>`);<EOL>    const packageJSON: string = JSON.stringify({<EOL>        name: `<STR_LIT>`,<EOL>        description: `<STR_LIT>`,<EOL>        scripts: {<EOL>            \"<STR_LIT>\": \"<STR_LIT>\"<EOL>        }<EOL>    }, null, <NUM_LIT>) + \"<STR_LIT>\";<EOL>    const pluginPath: string = `<STR_LIT>`;<EOL>    mkdirp.sync(pluginPath);<EOL>    fs.writeFileSync(`<STR_LIT>`, packageJSON);<EOL>    const tsconfigJSON: string = JSON.stringify({<EOL>        \"<STR_LIT>\": {<EOL>            \"<STR_LIT>\": \"<STR_LIT>\",<EOL>            \"<STR_LIT>\": \"<STR_LIT>\",<EOL>            \"<STR_LIT>\": true,<EOL>            \"<STR_LIT>\": [\"<STR_LIT>\"]<EOL>        },<EOL>        \"<STR_LIT>\": [<EOL>","gt":"\"<STR_LIT>\","}
{"input":"<s> function onKeyDown(event: KeyboardEvent): void {<EOL>    <EOL>    if (event.keyCode === <NUM_LIT>) {<EOL>","gt":"sendHotkey(\"<STR_LIT>\");"}
{"input":"<s> function onKeyDown(event: KeyboardEvent): void {<EOL>    <EOL>    if (event.keyCode === <NUM_LIT>) {<EOL>        sendHotkey(\"<STR_LIT>\");<EOL>        return;<EOL>    }<EOL>    <EOL>    if (event.keyCode === <NUM_LIT>)<EOL>        isBackspaceDown = true;<EOL>    if ((dialogs.BaseDialog as any).","gt":"activeDialog != null)"}
{"input":"<s> function onKeyDown(event: KeyboardEvent): void {<EOL>    <EOL>    if (event.keyCode === <NUM_LIT>) {<EOL>        sendHotkey(\"<STR_LIT>\");<EOL>        return;<EOL>    }<EOL>    <EOL>    if (event.keyCode === <NUM_LIT>)<EOL>        isBackspaceDown = true;<EOL>    if ((dialogs.BaseDialog as any).activeDialog != null)<EOL>        return;<EOL>    const ctrlOrCmd: boolean = event.ctrlKey || event.metaKey;<EOL>    <EOL>    if (event.","gt":"keyCode === <NUM_LIT> && ctrlOrCmd) {"}
{"input":"<s> function onKeyDown(event: KeyboardEvent): void {<EOL>    <EOL>    if (event.keyCode === <NUM_LIT>) {<EOL>        sendHotkey(\"<STR_LIT>\");<EOL>        return;<EOL>    }<EOL>    <EOL>    if (event.keyCode === <NUM_LIT>)<EOL>        isBackspaceDown = true;<EOL>    if ((dialogs.BaseDialog as any).activeDialog != null)<EOL>        return;<EOL>    const ctrlOrCmd: boolean = event.ctrlKey || event.metaKey;<EOL>    <EOL>    if (event.keyCode === <NUM_LIT> && ctrlOrCmd) {<EOL>        event.","gt":"preventDefault();"}
{"input":"<s> function onKeyDown(event: KeyboardEvent): void {<EOL>    <EOL>    if (event.keyCode === <NUM_LIT>) {<EOL>        sendHotkey(\"<STR_LIT>\");<EOL>        return;<EOL>    }<EOL>    <EOL>    if (event.keyCode === <NUM_LIT>)<EOL>        isBackspaceDown = true;<EOL>    if ((dialogs.BaseDialog as any).activeDialog != null)<EOL>        return;<EOL>    const ctrlOrCmd: boolean = event.ctrlKey || event.metaKey;<EOL>    <EOL>    if (event.keyCode === <NUM_LIT> && ctrlOrCmd) {<EOL>        event.preventDefault();<EOL>        if (event.shiftKey)<EOL>            sendHotkey(\"<STR_LIT>\");<EOL>        else<EOL>            sendHotkey(\"<STR_LIT>\");<EOL>        return;<EOL>    }<EOL>    <EOL>    if ((event.keyCode === <NUM_LIT> || event.keyCode === <NUM_LIT>) && ctrlOrCmd) {<EOL>        event.preventDefault();<EOL>        sendHotkey(\"<STR_LIT>\");<EOL>        return;<EOL>    }<EOL>    <EOL>    if (event.","gt":"keyCode === <NUM_LIT> && ctrlOrCmd) {"}
{"input":"<s> function onKeyDown(event: KeyboardEvent): void {<EOL>    <EOL>    if (event.keyCode === <NUM_LIT>) {<EOL>        sendHotkey(\"<STR_LIT>\");<EOL>        return;<EOL>    }<EOL>    <EOL>    if (event.keyCode === <NUM_LIT>)<EOL>        isBackspaceDown = true;<EOL>    if ((dialogs.BaseDialog as any).activeDialog != null)<EOL>        return;<EOL>    const ctrlOrCmd: boolean = event.ctrlKey || event.metaKey;<EOL>    <EOL>    if (event.keyCode === <NUM_LIT> && ctrlOrCmd) {<EOL>        event.preventDefault();<EOL>        if (event.shiftKey)<EOL>            sendHotkey(\"<STR_LIT>\");<EOL>        else<EOL>            sendHotkey(\"<STR_LIT>\");<EOL>        return;<EOL>    }<EOL>    <EOL>    if ((event.keyCode === <NUM_LIT> || event.keyCode === <NUM_LIT>) && ctrlOrCmd) {<EOL>        event.preventDefault();<EOL>        sendHotkey(\"<STR_LIT>\");<EOL>        return;<EOL>    }<EOL>    <EOL>    if (event.keyCode === <NUM_LIT> && ctrlOrCmd) {<EOL>        event.preventDefault();<EOL>        sendHotkey(\"<STR_LIT>\");<EOL>        return;<EOL>    }<EOL>    <EOL>    if (event.keyCode === <NUM_LIT> && event.ctrlKey) {<EOL>        event.preventDefault();<EOL>","gt":"if (event.shiftKey)"}
{"input":"<s> function onKeyDown(event: KeyboardEvent): void {<EOL>    <EOL>    if (event.keyCode === <NUM_LIT>) {<EOL>        sendHotkey(\"<STR_LIT>\");<EOL>        return;<EOL>    }<EOL>    <EOL>    if (event.keyCode === <NUM_LIT>)<EOL>        isBackspaceDown = true;<EOL>    if ((dialogs.BaseDialog as any).activeDialog != null)<EOL>        return;<EOL>    const ctrlOrCmd: boolean = event.ctrlKey || event.metaKey;<EOL>    <EOL>    if (event.keyCode === <NUM_LIT> && ctrlOrCmd) {<EOL>        event.preventDefault();<EOL>        if (event.shiftKey)<EOL>            sendHotkey(\"<STR_LIT>\");<EOL>        else<EOL>            sendHotkey(\"<STR_LIT>\");<EOL>        return;<EOL>    }<EOL>    <EOL>    if ((event.keyCode === <NUM_LIT> || event.keyCode === <NUM_LIT>) && ctrlOrCmd) {<EOL>        event.preventDefault();<EOL>        sendHotkey(\"<STR_LIT>\");<EOL>        return;<EOL>    }<EOL>    <EOL>    if (event.keyCode === <NUM_LIT> && ctrlOrCmd) {<EOL>        event.preventDefault();<EOL>        sendHotkey(\"<STR_LIT>\");<EOL>        return;<EOL>    }<EOL>    <EOL>    if (event.keyCode === <NUM_LIT> && event.ctrlKey) {<EOL>        event.preventDefault();<EOL>        if (event.shiftKey)<EOL>            sendHotkey(\"<STR_LIT>\");<EOL>        else<EOL>            sendHotkey(\"<STR_LIT>\");<EOL>","gt":"return;"}
{"input":"<s> function onKeyDown(event: KeyboardEvent): void {<EOL>    <EOL>    if (event.keyCode === <NUM_LIT>) {<EOL>        sendHotkey(\"<STR_LIT>\");<EOL>        return;<EOL>    }<EOL>    <EOL>    if (event.keyCode === <NUM_LIT>)<EOL>        isBackspaceDown = true;<EOL>    if ((dialogs.BaseDialog as any).activeDialog != null)<EOL>        return;<EOL>    const ctrlOrCmd: boolean = event.ctrlKey || event.metaKey;<EOL>    <EOL>    if (event.keyCode === <NUM_LIT> && ctrlOrCmd) {<EOL>        event.preventDefault();<EOL>        if (event.shiftKey)<EOL>            sendHotkey(\"<STR_LIT>\");<EOL>        else<EOL>            sendHotkey(\"<STR_LIT>\");<EOL>        return;<EOL>    }<EOL>    <EOL>    if ((event.keyCode === <NUM_LIT> || event.keyCode === <NUM_LIT>) && ctrlOrCmd) {<EOL>        event.preventDefault();<EOL>        sendHotkey(\"<STR_LIT>\");<EOL>        return;<EOL>    }<EOL>    <EOL>    if (event.keyCode === <NUM_LIT> && ctrlOrCmd) {<EOL>        event.preventDefault();<EOL>        sendHotkey(\"<STR_LIT>\");<EOL>        return;<EOL>    }<EOL>    <EOL>    if (event.keyCode === <NUM_LIT> && event.ctrlKey) {<EOL>        event.preventDefault();<EOL>        if (event.shiftKey)<EOL>            sendHotkey(\"<STR_LIT>\");<EOL>        else<EOL>            sendHotkey(\"<STR_LIT>\");<EOL>        return;<EOL>    }<EOL>    <EOL>    if (event.keyCode === <NUM_LIT>) {<EOL>        event.preventDefault();<EOL>        if (helpCallback != null)<EOL>            helpCallback();<EOL>        return;<EOL>    }<EOL>    <EOL>    if (event.keyCode === <NUM_LIT> || (event.keyCode === <NUM_LIT> && event.","gt":"metaKey)) {"}
{"input":"<s> function onKeyDown(event: KeyboardEvent): void {<EOL>    <EOL>    if (event.keyCode === <NUM_LIT>) {<EOL>        sendHotkey(\"<STR_LIT>\");<EOL>        return;<EOL>    }<EOL>    <EOL>    if (event.keyCode === <NUM_LIT>)<EOL>        isBackspaceDown = true;<EOL>    if ((dialogs.BaseDialog as any).activeDialog != null)<EOL>        return;<EOL>    const ctrlOrCmd: boolean = event.ctrlKey || event.metaKey;<EOL>    <EOL>    if (event.keyCode === <NUM_LIT> && ctrlOrCmd) {<EOL>        event.preventDefault();<EOL>        if (event.shiftKey)<EOL>            sendHotkey(\"<STR_LIT>\");<EOL>        else<EOL>            sendHotkey(\"<STR_LIT>\");<EOL>        return;<EOL>    }<EOL>    <EOL>    if ((event.keyCode === <NUM_LIT> || event.keyCode === <NUM_LIT>) && ctrlOrCmd) {<EOL>        event.preventDefault();<EOL>        sendHotkey(\"<STR_LIT>\");<EOL>        return;<EOL>    }<EOL>    <EOL>    if (event.keyCode === <NUM_LIT> && ctrlOrCmd) {<EOL>        event.preventDefault();<EOL>        sendHotkey(\"<STR_LIT>\");<EOL>        return;<EOL>    }<EOL>    <EOL>    if (event.keyCode === <NUM_LIT> && event.ctrlKey) {<EOL>        event.preventDefault();<EOL>        if (event.shiftKey)<EOL>            sendHotkey(\"<STR_LIT>\");<EOL>        else<EOL>            sendHotkey(\"<STR_LIT>\");<EOL>        return;<EOL>    }<EOL>    <EOL>    if (event.keyCode === <NUM_LIT>) {<EOL>        event.preventDefault();<EOL>        if (helpCallback != null)<EOL>            helpCallback();<EOL>        return;<EOL>    }<EOL>    <EOL>    if (event.keyCode === <NUM_LIT> || (event.keyCode === <NUM_LIT> && event.metaKey)) {<EOL>        event.preventDefault();<EOL>        sendHotkey(\"<STR_LIT>\");<EOL>        return;<EOL>    }<EOL>    <EOL>    if (event.keyCode === <NUM_LIT> || (event.keyCode === <NUM_LIT> && event.metaKey && event.","gt":"shiftKey)) {"}
{"input":"<s> export function getTreeViewInsertionPoint(treeView: TreeView): {<EOL>    parentId: string;<EOL>    index: number;<EOL>} {<EOL>    let selectedElt: any = treeView.selectedNodes[<NUM_LIT>];<EOL>    let parentId: string;<EOL>    let index: number;<EOL>    if (","gt":"selectedElt != null) {"}
{"input":"<s> export function getTreeViewInsertionPoint(treeView: TreeView): {<EOL>    parentId: string;<EOL>    index: number;<EOL>} {<EOL>    let selectedElt: any = treeView.selectedNodes[<NUM_LIT>];<EOL>    let parentId: string;<EOL>    let index: number;<EOL>    if (selectedElt != null) {<EOL>        if (selectedElt.classList.contains(\"<STR_LIT>\")) {<EOL>            parentId = selectedElt.dataset[\"<STR_LIT>\"];<EOL>        }<EOL>        else {<EOL>            if (selectedElt.parentElement.classList.contains(\"<STR_LIT>\")) {<EOL>                parentId = selectedElt.parentElement.previousElementSibling != null ? (selectedElt.parentElement.previousElementSibling as HTMLElement).dataset[\"<STR_LIT>\"] : null;<EOL>            }<EOL>            index = <NUM_LIT>;<EOL>            while (selectedElt.previousElementSibling != null) {<EOL>                selectedElt = selectedElt.previousElementSibling as HTMLLIElement;<EOL>                if (selectedElt.tagName === \"<STR_LIT>\")<EOL>","gt":"index++;"}
{"input":"<s> export default function readFile(file: File, type: string, callback: (err: Error, data?: any) => void): void {<EOL>    const reader: FileReader = new FileReader;<EOL>    reader.onload = (event: ProgressEvent<FileReader>): void => {<EOL>        let data: any;<EOL>        if (type === \"<STR_LIT>\") {<EOL>            try {<EOL>","gt":"data = JSON.parse((event.target as FileReader).result);"}
{"input":"<s> export default function readFile(file: File, type: string, callback: (err: Error, data?: any) => void): void {<EOL>    const reader: FileReader = new FileReader;<EOL>    reader.onload = (event: ProgressEvent<FileReader>): void => {<EOL>        let data: any;<EOL>        if (type === \"<STR_LIT>\") {<EOL>            try {<EOL>                data = JSON.parse((event.target as FileReader).result);<EOL>            }<EOL>            catch (err: any) {<EOL>","gt":"callback(err, null);"}
{"input":"<s> export default function readFile(file: File, type: string, callback: (err: Error, data?: any) => void): void {<EOL>    const reader: FileReader = new FileReader;<EOL>    reader.onload = (event: ProgressEvent<FileReader>): void => {<EOL>        let data: any;<EOL>        if (type === \"<STR_LIT>\") {<EOL>            try {<EOL>                data = JSON.parse((event.target as FileReader).result);<EOL>            }<EOL>            catch (err: any) {<EOL>                callback(err, null);<EOL>                return;<EOL>            }<EOL>        }<EOL>        else {<EOL>            data = (event.target as FileReader).result;<EOL>        }<EOL>        callback(null, data);<EOL>    };<EOL>    switch (type) {<EOL>        case \"<STR_LIT>\":<EOL>        case \"<STR_LIT>\":<EOL>            reader.readAsText(file);<EOL>","gt":"break;"}
{"input":"<s> function onAssetReceived(): void {<EOL>    <EOL>    ui.nodesTreeView.clearSelection();<EOL>    ui.nodesTreeView.treeRoot.innerHTML = \"<STR_LIT>\";<EOL>    function walk(node: Node, parentNode: Node,","gt":"parentElt: HTMLLIElement): void {"}
{"input":"<s> function onAssetReceived(): void {<EOL>    <EOL>    ui.nodesTreeView.clearSelection();<EOL>    ui.nodesTreeView.treeRoot.innerHTML = \"<STR_LIT>\";<EOL>    function walk(node: Node, parentNode: Node, parentElt: HTMLLIElement): void {<EOL>        const liElt: HTMLLIElement = createNodeElement(node);<EOL>        ui.nodesTreeView.append(liElt, \"<STR_LIT>\", parentElt);<EOL>        if (node.children != null &&","gt":"node.children.length > <NUM_LIT>) {"}
{"input":"<s> function onAssetReceived(): void {<EOL>    <EOL>    ui.nodesTreeView.clearSelection();<EOL>    ui.nodesTreeView.treeRoot.innerHTML = \"<STR_LIT>\";<EOL>    function walk(node: Node, parentNode: Node, parentElt: HTMLLIElement): void {<EOL>        const liElt: HTMLLIElement = createNodeElement(node);<EOL>        ui.nodesTreeView.append(liElt, \"<STR_LIT>\", parentElt);<EOL>        if (node.children != null && node.children.length > <NUM_LIT>) {<EOL>            liElt.classList.add(\"<STR_LIT>\");<EOL>            for (const child: Node of node.children)<EOL>                walk(child, node, liElt);<EOL>        }<EOL>    }<EOL>    for (const node: Node of data.cubicModelUpdater.cubicModelAsset.nodes.pub)<EOL>        walk(node, null, null);<EOL>    const pub: import(\"<STR_LIT>\").CubicModelAssetPub = data.cubicModelUpdater.cubicModelAsset.pub;<EOL>    ui.pixelsPerUnitInput.value = pub.pixelsPerUnit.","gt":"toString();"}
{"input":"<s> function onTransformModeClick(event: UIEvent): void {<EOL>    const target: HTMLInputElement = <HTMLInputElement>event.target;<EOL>    if (target.tagName !== \"<STR_LIT>\")<EOL>        return;<EOL>    if (target.id === \"<STR_LIT>\") {<EOL>        engine.transformHandleComponent.setSpace(target.checked ? \"<STR_LIT>\" : \"<STR_LIT>\");<EOL>    }<EOL>    else {<EOL>        const transformSpaceCheckbox: HTMLInputElement = <HTMLInputElement>document.getElementById(\"<STR_LIT>\");<EOL>        transformSpaceCheckbox.disabled = target.value === \"<STR_LIT>\";<EOL>        engine.","gt":"transformHandleComponent.setMode(target.value);"}
{"input":"<s> function onTransformModeClick(event: UIEvent): void {<EOL>    const target: HTMLInputElement = <HTMLInputElement>event.target;<EOL>    if (target.tagName !== \"<STR_LIT>\")<EOL>        return;<EOL>    if (target.id === \"<STR_LIT>\") {<EOL>        engine.transformHandleComponent.setSpace(target.checked ? \"<STR_LIT>\" : \"<STR_LIT>\");<EOL>    }<EOL>    else {<EOL>        const transformSpaceCheckbox: HTMLInputElement = <HTMLInputElement>document.getElementById(\"<STR_LIT>\");<EOL>        transformSpaceCheckbox.disabled = target.value === \"<STR_LIT>\";<EOL>        engine.transformHandleComponent.setMode(target.value);<EOL>        if (target.value === \"<STR_LIT>\") {<EOL>            ui.translateMode = target.dataset[\"<STR_LIT>\"];<EOL>            const linkShapeToPivot: boolean = (<HTMLInputElement>document.getElementById(\"<STR_LIT>\")).checked;<EOL>            if (ui.translateMode ===","gt":"\"<STR_LIT>\" && linkShapeToPivot)"}
{"input":"<s> export function lateStart(player: SupRuntime.Player, callback: Function): void {<EOL>    const sceneId: any = player.resources.gameSettings.startupSceneId;<EOL>    if (sceneId != null) {<EOL>        const","gt":"outerAsset: any = player.getOuterAsset(sceneId);"}
{"input":"<s> export function importComponent(entry: SupCore.Data.EntryNode, projectClient: SupClient.ProjectClient, nodeId: string, callback: (err: string, nodeId: string) => any): void {<EOL>    projectClient.editAsset(SupClient.query.asset, \"<STR_LIT>\", nodeId, \"<STR_LIT>\", null, (","gt":"componentId: string): void => {"}
{"input":"<s> function onChangeActive(): void {<EOL>    const stopRendering: boolean = !hasStarted || !isTabActive;<EOL>    if (stopRendering) {<EOL>        if (animationFrame != null) {<EOL>","gt":"cancelAnimationFrame(animationFrame);"}
{"input":"<s> function onChangeActive(): void {<EOL>    const stopRendering: boolean = !hasStarted || !isTabActive;<EOL>    if (stopRendering) {<EOL>        if (animationFrame != null) {<EOL>            cancelAnimationFrame(animationFrame);<EOL>            animationFrame = null;<EOL>        }<EOL>    }<EOL>    else if (","gt":"animationFrame == null) {"}
{"input":"<s> function tick(timestamp: number = <NUM_LIT>): void {<EOL>    accumulatedTime += timestamp - lastTimestamp;<EOL>    lastTimestamp = timestamp;<EOL>    const { updates, timeLeft } = engine.gameInstance.","gt":"tick(accumulatedTime, update);"}
{"input":"<s> export function setupAttribute(attribute: AttributePub): void {<EOL>    const rowElt: HTMLTableRowElement = document.createElement(\"<STR_LIT>\");<EOL>    rowElt.dataset[\"<STR_LIT>\"] = attribute.id;<EOL>","gt":"ui.attributesList.insertBefore(rowElt, ui.attributesList.lastChild);"}
{"input":"<s> export function setupAttribute(attribute: AttributePub): void {<EOL>    const rowElt: HTMLTableRowElement = document.createElement(\"<STR_LIT>\");<EOL>    rowElt.dataset[\"<STR_LIT>\"] = attribute.id;<EOL>    ui.attributesList.insertBefore(rowElt, ui.attributesList.lastChild);<EOL>    const nameElt: HTMLTableCellElement = document.createElement(\"<STR_LIT>\");<EOL>    const nameInputElt: HTMLInputElement = document.createElement(\"<STR_LIT>\");<EOL>    nameInputElt.classList.","gt":"add(\"<STR_LIT>\");"}
{"input":"<s> export function setupAttribute(attribute: AttributePub): void {<EOL>    const rowElt: HTMLTableRowElement = document.createElement(\"<STR_LIT>\");<EOL>    rowElt.dataset[\"<STR_LIT>\"] = attribute.id;<EOL>    ui.attributesList.insertBefore(rowElt, ui.attributesList.lastChild);<EOL>    const nameElt: HTMLTableCellElement = document.createElement(\"<STR_LIT>\");<EOL>    const nameInputElt: HTMLInputElement = document.createElement(\"<STR_LIT>\");<EOL>    nameInputElt.classList.add(\"<STR_LIT>\");<EOL>    nameInputElt.addEventListener(\"<STR_LIT>\", (event: any): void => {<EOL>        if (event.target.value === \"<STR_LIT>\")<EOL>            data.projectClient.editAsset(SupClient.query.asset, \"<STR_LIT>\", rowElt.dataset[\"<STR_LIT>\"]);<EOL>        else<EOL>            data.projectClient.editAsset(SupClient.query.asset, \"<STR_LIT>\", rowElt.dataset[\"<STR_LIT>\"], \"<STR_LIT>\", event.target.value);<EOL>    });<EOL>    nameInputElt.value = attribute.","gt":"name;"}
{"input":"<s> export function setupAttribute(attribute: AttributePub): void {<EOL>    const rowElt: HTMLTableRowElement = document.createElement(\"<STR_LIT>\");<EOL>    rowElt.dataset[\"<STR_LIT>\"] = attribute.id;<EOL>    ui.attributesList.insertBefore(rowElt, ui.attributesList.lastChild);<EOL>    const nameElt: HTMLTableCellElement = document.createElement(\"<STR_LIT>\");<EOL>    const nameInputElt: HTMLInputElement = document.createElement(\"<STR_LIT>\");<EOL>    nameInputElt.classList.add(\"<STR_LIT>\");<EOL>    nameInputElt.addEventListener(\"<STR_LIT>\", (event: any): void => {<EOL>        if (event.target.value === \"<STR_LIT>\")<EOL>            data.projectClient.editAsset(SupClient.query.asset, \"<STR_LIT>\", rowElt.dataset[\"<STR_LIT>\"]);<EOL>        else<EOL>            data.projectClient.editAsset(SupClient.query.asset, \"<STR_LIT>\", rowElt.dataset[\"<STR_LIT>\"], \"<STR_LIT>\", event.target.value);<EOL>    });<EOL>    nameInputElt.value = attribute.name;<EOL>    nameElt.appendChild(nameInputElt);<EOL>    rowElt.appendChild(nameElt);<EOL>    const typeElt: HTMLTableCellElement = document.createElement(\"<STR_LIT>\");<EOL>    const","gt":"selectTypeElt: HTMLSelectElement = document.createElement(\"<STR_LIT>\");"}
{"input":"<s> export function setupAttribute(attribute: AttributePub): void {<EOL>    const rowElt: HTMLTableRowElement = document.createElement(\"<STR_LIT>\");<EOL>    rowElt.dataset[\"<STR_LIT>\"] = attribute.id;<EOL>    ui.attributesList.insertBefore(rowElt, ui.attributesList.lastChild);<EOL>    const nameElt: HTMLTableCellElement = document.createElement(\"<STR_LIT>\");<EOL>    const nameInputElt: HTMLInputElement = document.createElement(\"<STR_LIT>\");<EOL>    nameInputElt.classList.add(\"<STR_LIT>\");<EOL>    nameInputElt.addEventListener(\"<STR_LIT>\", (event: any): void => {<EOL>        if (event.target.value === \"<STR_LIT>\")<EOL>            data.projectClient.editAsset(SupClient.query.asset, \"<STR_LIT>\", rowElt.dataset[\"<STR_LIT>\"]);<EOL>        else<EOL>            data.projectClient.editAsset(SupClient.query.asset, \"<STR_LIT>\", rowElt.dataset[\"<STR_LIT>\"], \"<STR_LIT>\", event.target.value);<EOL>    });<EOL>    nameInputElt.value = attribute.name;<EOL>    nameElt.appendChild(nameInputElt);<EOL>    rowElt.appendChild(nameElt);<EOL>    const typeElt: HTMLTableCellElement = document.createElement(\"<STR_LIT>\");<EOL>    const selectTypeElt: HTMLSelectElement = document.createElement(\"<STR_LIT>\");<EOL>    for (const type: string of Attributes.schema[\"<STR_LIT>\"].items as string[]) {<EOL>        const optionElt: HTMLOptionElement = document.createElement(\"<STR_LIT>\");<EOL>        optionElt.textContent = type;<EOL>        selectTypeElt.appendChild(optionElt);<EOL>    }<EOL>    selectTypeElt.classList.","gt":"add(\"<STR_LIT>\");"}
{"input":"<s> function setupProperty(path: string, value: any): void {<EOL>    switch (path) {<EOL>        case","gt":"\"<STR_LIT>\":"}
{"input":"<s> function clearInfoPopup(): void {<EOL>    if (ui.infoElement.parentElement != null)<EOL>        ui.","gt":"infoElement.parentElement.removeChild(ui.infoElement);"}
{"input":"<s> <EOL>export function matcher(pattern: any, topLevel: boolean = true): any {<EOL>    if (pattern instanceof Array) {<EOL>        return ArrayMatcher(pattern, topLevel);<EOL>    }<EOL>    else if (pattern instanceof RegExp) {<EOL>","gt":"return RegExpMatcher(pattern);"}
{"input":"<s> export async function uploadBuildArtifacts(gistId: string, gistCloneUrl: string, artifactDirs: string[], buildLog: string, token: string): Promise<any> {<EOL>    let targetDir: any = getGistTempdir(gistId);<EOL>    <EOL>    await","gt":"addFilesToGist(gistCloneUrl, targetDir, buildLog, token);"}
{"input":"<s> export function fetchAllOpenPRs(nwo: string): Promise<any[]> {<EOL>    return githubPaginate(apiUrl(`<STR_LIT>`), undefined,","gt":"<NUM_LIT> * <NUM_LIT>);"}
{"input":"<s> export async function fetchAllRefsWithInfo(nwo: string): Promise<any[]> {<EOL>    let openPRs: any[] = (await fetchAllOpenPRs(nwo));<EOL>    let refList: string[] = openPRs.map((x: any): any => x.head.ref);<EOL>    let refToPR: any = openPRs.reduce((acc: any, x: any): any => {<EOL>        acc[x.","gt":"head.ref] = x;"}
{"input":"<s> export async function fetchAllRefsWithInfo(nwo: string): Promise<any[]> {<EOL>    let openPRs: any[] = (await fetchAllOpenPRs(nwo));<EOL>    let refList: string[] = openPRs.map((x: any): any => x.head.ref);<EOL>    let refToPR: any = openPRs.reduce((acc: any, x: any): any => {<EOL>        acc[x.head.ref] = x;<EOL>        return acc;<EOL>    }, {});<EOL>    let theMap: Map<string, any> = await asyncMap(refList, async (ref: string): Promise<any> => {<EOL>        let repoName: any = refToPR[ref].head.","gt":"repo.full_name;"}
{"input":"<s> export async function fetchAllRefsWithInfo(nwo: string): Promise<any[]> {<EOL>    let openPRs: any[] = (await fetchAllOpenPRs(nwo));<EOL>    let refList: string[] = openPRs.map((x: any): any => x.head.ref);<EOL>    let refToPR: any = openPRs.reduce((acc: any, x: any): any => {<EOL>        acc[x.head.ref] = x;<EOL>        return acc;<EOL>    }, {});<EOL>    let theMap: Map<string, any> = await asyncMap(refList, async (ref: string): Promise<any> => {<EOL>        let repoName: any = refToPR[ref].head.repo.full_name;<EOL>        let shaHint: any = refToPR[ref].head.sha;<EOL>        try {<EOL>            let ret: any = await fetchSingleRef(repoName, ref, shaHint);<EOL>            return ret;<EOL>        }<EOL>        catch (e: any) {<EOL>            d(`<STR_LIT>`);<EOL>            return null;<EOL>        }<EOL>    });<EOL>    let refs: any[] = Array.from(theMap.values());<EOL>    <EOL>    let repoInfo: any = await fetchRepoInfo(nwo);<EOL>    let defaultBranch: any = repoInfo.default_branch;<EOL>    let","gt":"result: any = await fetchSingleRef(nwo, defaultBranch);"}
{"input":"<s> export async function fetchAllRefsWithInfo(nwo: string): Promise<any[]> {<EOL>    let openPRs: any[] = (await fetchAllOpenPRs(nwo));<EOL>    let refList: string[] = openPRs.map((x: any): any => x.head.ref);<EOL>    let refToPR: any = openPRs.reduce((acc: any, x: any): any => {<EOL>        acc[x.head.ref] = x;<EOL>        return acc;<EOL>    }, {});<EOL>    let theMap: Map<string, any> = await asyncMap(refList, async (ref: string): Promise<any> => {<EOL>        let repoName: any = refToPR[ref].head.repo.full_name;<EOL>        let shaHint: any = refToPR[ref].head.sha;<EOL>        try {<EOL>            let ret: any = await fetchSingleRef(repoName, ref, shaHint);<EOL>            return ret;<EOL>        }<EOL>        catch (e: any) {<EOL>            d(`<STR_LIT>`);<EOL>            return null;<EOL>        }<EOL>    });<EOL>    let refs: any[] = Array.from(theMap.values());<EOL>    <EOL>    let repoInfo: any = await fetchRepoInfo(nwo);<EOL>    let defaultBranch: any = repoInfo.default_branch;<EOL>    let result: any = await fetchSingleRef(nwo, defaultBranch);<EOL>    refs.push(result);<EOL>    <EOL>    refs = refs.filter((x: any): boolean => x !== null);<EOL>    let commitInfo: Map<any, any> = await asyncMap(refs.map((ref: any): any => ref.object.url), async (x: any): Promise<any> => {<EOL>        try {<EOL>            return (await cachedGitHub(x)).result;<EOL>        }<EOL>        catch (e: any) {<EOL>            d(","gt":"x} but failed: ${e.message}`<STR_LIT>;"}
{"input":"<s> function sum(params: any[]): any {<EOL>    var res: number = <NUM_LIT>;<EOL>    for (var i: number = <NUM_LIT>; i < params.","gt":"length; i++) {"}
{"input":"<s> function read_json(file: string): any {<EOL>    return JSON.parse(fs.readFileSync(file,","gt":"'<STR_LIT>'));"}
{"input":"<s> export function getDatabase(connection: string): Database {<EOL>    switch (getSQLVersion(connection)) {<EOL>        case SQLVersion.MYSQL:<EOL>","gt":"return new MysqlDatabase(connection);"}
{"input":"<s> <EOL>export function count(countFrom: any, countTo: any, countDecimals: any, countDuration: any, callback: any): number {<EOL>    const startVal: number = Number(countFrom);<EOL>    const endVal: number = Number(countTo);<EOL>    const countDown: boolean = (startVal > endVal);<EOL>    const decimals: number = Math.","gt":"max(<NUM_LIT>, countDecimals);"}
{"input":"<s> <EOL>export function count(countFrom: any, countTo: any, countDecimals: any, countDuration: any, callback: any): number {<EOL>    const startVal: number = Number(countFrom);<EOL>    const endVal: number = Number(countTo);<EOL>    const countDown: boolean = (startVal > endVal);<EOL>    const decimals: number = Math.max(<NUM_LIT>, countDecimals);<EOL>    const","gt":"dec: number = Math.pow(<NUM_LIT>, decimals);"}
{"input":"<s> <EOL>export function count(countFrom: any, countTo: any, countDecimals: any, countDuration: any, callback: any): number {<EOL>    const startVal: number = Number(countFrom);<EOL>    const endVal: number = Number(countTo);<EOL>    const countDown: boolean = (startVal > endVal);<EOL>    const decimals: number = Math.max(<NUM_LIT>, countDecimals);<EOL>    const dec: number = Math.pow(<NUM_LIT>, decimals);<EOL>    const duration: number = Number(countDuration) * <NUM_LIT>;<EOL>    let","gt":"startTime: any;"}
{"input":"<s> <EOL>export function count(countFrom: any, countTo: any, countDecimals: any, countDuration: any, callback: any): number {<EOL>    const startVal: number = Number(countFrom);<EOL>    const endVal: number = Number(countTo);<EOL>    const countDown: boolean = (startVal > endVal);<EOL>    const decimals: number = Math.max(<NUM_LIT>, countDecimals);<EOL>    const dec: number = Math.pow(<NUM_LIT>, decimals);<EOL>    const duration: number = Number(countDuration) * <NUM_LIT>;<EOL>    let startTime: any;<EOL>    function runCount(timestamp: any): any {<EOL>        let frameVal: any;<EOL>        const progress: number = timestamp - startTime;<EOL>        if (countDown) {<EOL>            frameVal = startVal - easeOutExpo(","gt":"progress, <NUM_LIT>, startVal - endVal, duration);"}
{"input":"<s> <EOL>export function count(countFrom: any, countTo: any, countDecimals: any, countDuration: any, callback: any): number {<EOL>    const startVal: number = Number(countFrom);<EOL>    const endVal: number = Number(countTo);<EOL>    const countDown: boolean = (startVal > endVal);<EOL>    const decimals: number = Math.max(<NUM_LIT>, countDecimals);<EOL>    const dec: number = Math.pow(<NUM_LIT>, decimals);<EOL>    const duration: number = Number(countDuration) * <NUM_LIT>;<EOL>    let startTime: any;<EOL>    function runCount(timestamp: any): any {<EOL>        let frameVal: any;<EOL>        const progress: number = timestamp - startTime;<EOL>        if (countDown) {<EOL>            frameVal = startVal - easeOutExpo(progress, <NUM_LIT>, startVal - endVal, duration);<EOL>        }<EOL>        else {<EOL>            frameVal = easeOutExpo(progress, startVal, endVal - startVal, duration);<EOL>        }<EOL>        if (countDown) {<EOL>            frameVal = (frameVal < endVal) ? endVal : frameVal;<EOL>        }<EOL>        else {<EOL>            frameVal = (","gt":"frameVal > endVal) ? endVal : frameVal;"}
{"input":"<s> <EOL>export function count(countFrom: any, countTo: any, countDecimals: any, countDuration: any, callback: any): number {<EOL>    const startVal: number = Number(countFrom);<EOL>    const endVal: number = Number(countTo);<EOL>    const countDown: boolean = (startVal > endVal);<EOL>    const decimals: number = Math.max(<NUM_LIT>, countDecimals);<EOL>    const dec: number = Math.pow(<NUM_LIT>, decimals);<EOL>    const duration: number = Number(countDuration) * <NUM_LIT>;<EOL>    let startTime: any;<EOL>    function runCount(timestamp: any): any {<EOL>        let frameVal: any;<EOL>        const progress: number = timestamp - startTime;<EOL>        if (countDown) {<EOL>            frameVal = startVal - easeOutExpo(progress, <NUM_LIT>, startVal - endVal, duration);<EOL>        }<EOL>        else {<EOL>            frameVal = easeOutExpo(progress, startVal, endVal - startVal, duration);<EOL>        }<EOL>        if (countDown) {<EOL>            frameVal = (frameVal < endVal) ? endVal : frameVal;<EOL>        }<EOL>        else {<EOL>            frameVal = (frameVal > endVal) ? endVal : frameVal;<EOL>        }<EOL>        frameVal = Math.round(frameVal * dec) / dec;<EOL>        const tick: boolean = progress < duration;<EOL>        callback({<EOL>            value: frameVal,<EOL>            progress,<EOL>            timestamp,<EOL>","gt":"finished: !tick"}
{"input":"<s> <EOL>export function id(): string {<EOL>    let newId: string = ('<STR_LIT>' + (Math.random() * Math.pow(<NUM_LIT>, <NUM_LIT>) << <NUM_LIT>).toString(<NUM_LIT>)).slice(-<NUM_LIT>);<EOL>    <EOL>    newId =","gt":"newId}`<STR_LIT>;"}
{"input":"<s> <EOL>export function deCamelCase(str: string): string {<EOL>","gt":"return str"}
{"input":"<s> function setupExpress(app: any): void {<EOL>    <EOL>    if (level === '<STR_LIT>') {<EOL>        app.use(expressWinston.errorLogger({<EOL>            transports: [<EOL>                new winston.transports.","gt":"Console({"}
{"input":"<s> function setupExpress(app: any): void {<EOL>    <EOL>    if (level === '<STR_LIT>') {<EOL>        app.use(expressWinston.errorLogger({<EOL>            transports: [<EOL>                new winston.transports.Console({<EOL>                    json: true,<EOL>","gt":"colorize: true"}
{"input":"<s> function setupExpress(app: any): void {<EOL>    <EOL>    if (level === '<STR_LIT>') {<EOL>        app.use(expressWinston.errorLogger({<EOL>            transports: [<EOL>                new winston.transports.Console({<EOL>                    json: true,<EOL>                    colorize: true<EOL>                })<EOL>            ]<EOL>        }));<EOL>    }<EOL>    <EOL>    if (level === '<STR_LIT>') {<EOL>        app.use(expressWinston.logger({<EOL>            transports: [<EOL>                new winston.transports.Console({<EOL>                    json:","gt":"true,"}
{"input":"<s> function setupSwaggerSecurity(middleware: any): any {<EOL>    return middleware.swaggerSecurity({<EOL>        jwt_token: (req: any, authOrSecDef: any, scopes: any, callback: any): void => {<EOL>            passport.authenticate('<STR_LIT>', { session: false }, (err: any, user: any, info: any): any => {<EOL>                if (","gt":"err)"}
{"input":"<s> function setupSwaggerSecurity(middleware: any): any {<EOL>    return middleware.swaggerSecurity({<EOL>        jwt_token: (req: any, authOrSecDef: any, scopes: any, callback: any): void => {<EOL>            passport.authenticate('<STR_LIT>', { session: false }, (err: any, user: any, info: any): any => {<EOL>                if (err)<EOL>                    callback(new Error('<STR_LIT>'));<EOL>                if (!user)<EOL>                    callback(new Error('<STR_LIT>'));<EOL>                req.user = user;<EOL>                return callback();<EOL>            })(req, null,","gt":"callback);"}
{"input":"<s> function mapRelation(rel: any, modelName: string, relName: string): void {<EOL>    types[modelName].fields[relName] = {<EOL>        relation: true,<EOL>","gt":"embed: rel.embed,"}
{"input":"<s> function pluralModelName(model: any): string {<EOL>    return '<STR_LIT>' +","gt":"_.upperFirst(model.pluralModelName);"}
{"input":"<s> <EOL>export function pushIf<T>(arr: T[], item: T): boolean {<EOL>","gt":"return arr.indexOf(item) < <NUM_LIT> && arr.push(item) > <NUM_LIT>;"}
{"input":"<s> export function selectTest(): void {<EOL>    assert.deepEqual(array.select([<EOL>        { \"<STR_LIT>\": \"<STR_LIT>\", \"<STR_LIT>\": <NUM_LIT> },<EOL>        { \"<STR_LIT>\": \"<STR_LIT>\", \"<STR_LIT>\": <NUM_LIT> },<EOL>        { \"<STR_LIT>\": \"<STR_LIT>\", \"<STR_LIT>\": <NUM_LIT> },<EOL>        { \"<STR_LIT>\": \"<STR_LIT>\",","gt":"\"<STR_LIT>\": <NUM_LIT> }"}
{"input":"<s> export function selectTest(): void {<EOL>    assert.deepEqual(array.select([<EOL>        { \"<STR_LIT>\": \"<STR_LIT>\", \"<STR_LIT>\": <NUM_LIT> },<EOL>        { \"<STR_LIT>\": \"<STR_LIT>\", \"<STR_LIT>\": <NUM_LIT> },<EOL>        { \"<STR_LIT>\": \"<STR_LIT>\", \"<STR_LIT>\": <NUM_LIT> },<EOL>        { \"<STR_LIT>\": \"<STR_LIT>\", \"<STR_LIT>\": <NUM_LIT> }<EOL>    ], (item: {<EOL>        user: string;<EOL>        age: number;<EOL>    }): string => item.user), [\"<STR_LIT>\", \"<STR_LIT>\", \"<STR_LIT>\",","gt":"\"<STR_LIT>\"]);"}
{"input":"<s> export function selectTest(): void {<EOL>    assert.deepEqual(array.select([<EOL>        { \"<STR_LIT>\": \"<STR_LIT>\", \"<STR_LIT>\": <NUM_LIT> },<EOL>        { \"<STR_LIT>\": \"<STR_LIT>\", \"<STR_LIT>\": <NUM_LIT> },<EOL>        { \"<STR_LIT>\": \"<STR_LIT>\", \"<STR_LIT>\": <NUM_LIT> },<EOL>        { \"<STR_LIT>\": \"<STR_LIT>\", \"<STR_LIT>\": <NUM_LIT> }<EOL>    ], (item: {<EOL>        user: string;<EOL>        age: number;<EOL>    }): string => item.user), [\"<STR_LIT>\", \"<STR_LIT>\", \"<STR_LIT>\", \"<STR_LIT>\"]);<EOL>    assert.deepEqual(array.select([<EOL>        { \"<STR_LIT>\": \"<STR_LIT>\", \"<STR_LIT>\": <NUM_LIT> },<EOL>        { \"<STR_LIT>\": \"<STR_LIT>\",","gt":"\"<STR_LIT>\": <NUM_LIT> },"}
{"input":"<s> export function mulTest(): void {<EOL>    assert.strictEqual(bigInteger.mul(\"<STR_LIT>\",","gt":"\"<STR_LIT>\"), \"<STR_LIT>\");"}
{"input":"<s> <EOL>export function isIp(value: string): boolean {<EOL>","gt":"return /^(?:localhost|::1|(?:[01]?\\d?\\d|2[0-4]\\d|25[0-5])(\\.(?:[01]?\\d?\\d|2[0-4]\\d|25[0-5])){3})$/.test(value);"}
{"input":"<s> export function isChineseIdTest(): void {<EOL>    assert.strictEqual(check.isChineseId(\"<STR_LIT>\"),","gt":"true);"}
{"input":"<s> <EOL>export function lighten<T extends Color>(color: T, value: number): void {<EOL>","gt":"const hsl: void = toHSL(color);"}
{"input":"<s> export function getTimezoneTest(): void {<EOL>    assert.","gt":"strictEqual(date.getTimezone(new Date(\"<STR_LIT>\")), \"<STR_LIT>\");"}
{"input":"<s> export function decodeGB2312Test(): void {<EOL>    assert.strictEqual(","gt":"gb2312.decodeGB2312(\"<STR_LIT>\"), \"<STR_LIT>\");"}
{"input":"<s> <EOL>export function getIntegerLength(num: number): number {<EOL>","gt":"return num === <NUM_LIT> ? <NUM_LIT> : Math.floor(Math.log(num) / Math.log(<NUM_LIT>)) + <NUM_LIT>;"}
{"input":"<s> <EOL>export function isInteger(num: number): boolean {<EOL>    return Math.floor(num) ===","gt":"num;"}
{"input":"<s> <EOL>export function addSetter<T extends any>(obj: T, key: keyof T, callback: Function): void {<EOL>    let originalData: any;<EOL>    Object.defineProperty(obj, key, {<EOL>        get() {<EOL>            return","gt":"originalData;"}
{"input":"<s> <EOL>export function addSetter<T extends any>(obj: T, key: keyof T, callback: Function): void {<EOL>    let originalData: any;<EOL>    Object.defineProperty(obj, key, {<EOL>        get() {<EOL>            return originalData;<EOL>        },<EOL>        set(value) {<EOL>            originalData = value;<EOL>","gt":"callback();"}
{"input":"<s> <EOL>export function insertBefore<T extends any>(obj: T, newKey: string, newValue: any, refKey?: keyof T): void {<EOL>    let tmpObj: any;<EOL>    for (const key: Extract<keyof T, string> in obj) {<EOL>        if (key === refKey) {<EOL>            tmpObj = {};<EOL>        }<EOL>        if (tmpObj) {<EOL>            tmpObj[key] = obj[key];<EOL>            delete obj[key];<EOL>        }<EOL>    }<EOL>","gt":"obj[newKey] = newValue;"}
{"input":"<s> export function addCallbackTest(): void {<EOL>    class A {<EOL>        func = null;<EOL>    }<EOL>    let c: number = <NUM_LIT>;<EOL>","gt":"const a: A = new A();"}
{"input":"<s> export function addCallbackTest(): void {<EOL>    class A {<EOL>        func = null;<EOL>    }<EOL>    let c: number = <NUM_LIT>;<EOL>    const a: A = new A();<EOL>    object.addCallback(a, \"<STR_LIT>\", (): void => {<EOL>        assert.equal(++c, <NUM_LIT>);<EOL>    });<EOL>    object.addCallback(","gt":"a, \"<STR_LIT>\", (): boolean => {"}
{"input":"<s> export function addCallbackTest(): void {<EOL>    class A {<EOL>        func = null;<EOL>    }<EOL>    let c: number = <NUM_LIT>;<EOL>    const a: A = new A();<EOL>    object.addCallback(a, \"<STR_LIT>\", (): void => {<EOL>        assert.equal(++c, <NUM_LIT>);<EOL>    });<EOL>    object.addCallback(a, \"<STR_LIT>\", (): boolean => {<EOL>        assert.equal(++c, <NUM_LIT>);<EOL>        return false;<EOL>    });<EOL>    object.","gt":"addCallback(a, \"<STR_LIT>\", (): void => {"}
{"input":"<s> export function diffTest(): void {<EOL>    assert.deepEqual(object.diff({ a: <NUM_LIT>, c: <NUM_LIT> }, { b: <NUM_LIT>, c: <NUM_LIT> }), { left: [","gt":"\"<STR_LIT>\"], right: [\"<STR_LIT>\"], both: [\"<STR_LIT>\"] });"}
{"input":"<s> export function findIndexTest(): void {<EOL>    assert.strictEqual([<NUM_LIT>, <NUM_LIT>].findIndex(function (item) {","gt":"return item > <NUM_LIT>; }), <NUM_LIT>);"}
{"input":"<s> export function forEachTest(): void {<EOL>","gt":"let all: string = \"<STR_LIT>\";"}
{"input":"<s> <EOL>export function bounce(x: number): number | undefined {<EOL>    for (let i: number = <NUM_LIT>, j: number = <NUM_LIT>; <NUM_LIT>; i += j, j /= <NUM_LIT>) {<EOL>","gt":"if (x >= (<NUM_LIT> - <NUM_LIT> * i) / <NUM_LIT>) {"}
{"input":"<s> <EOL>export function sinusoidal(x: number): number {<EOL>    return <NUM_LIT> - Math.sin((","gt":"<NUM_LIT> - x) * Math.PI / <NUM_LIT>);"}
{"input":"<s> export function urlTest(): void {<EOL>    assert.strictEqual(Url.format(Url.parse(","gt":"\"<STR_LIT>\")), \"<STR_LIT>\");"}
{"input":"<s> <EOL>export function encodeUTF8(value: string): string {<EOL>    let result: string = \"<STR_LIT>\";<EOL>    for (let i: number = <NUM_LIT>; i < value.length;","gt":"i++) {"}
{"input":"<s> export function getSubcookieAndSetSubcookieTest(): void {<EOL>    cookieMore.setSubcookie(\"<STR_LIT>\", \"<STR_LIT>\", \"<STR_LIT>\");<EOL>    assert.equal(cookieMore.getSubcookie(\"<STR_LIT>\", \"<STR_LIT>\"),","gt":"\"<STR_LIT>\");"}
{"input":"<s> <EOL>export default function noContextMenu(elem: HTMLElement): void {<EOL>    elem.addEventListener(\"<STR_LIT>\", (","gt":"e: MouseEvent): void => e.preventDefault());"}
{"input":"<s> <EOL>function preload(url: string): void {<EOL>    new","gt":"Image().src = url;"}
{"input":"<s> <EOL>export default function toggleFullScreen(elem: HTMLElement = document.documentElement): boolean | undefined {<EOL>    if (document.fullscreenElement || (document as any).mozFullScreenElement || document.webkitFullscreenElement || (document as any).msFullscreenElement) {<EOL>        const func: () => Promise<void> = document.exitFullscreen || (document as any).msExitFullscreen || (document as any).mozCancelFullScreen || document.webkitExitFullscreen;<EOL>        if (func) {<EOL>            func.call(document);<EOL>","gt":"return false;"}
{"input":"<s> <EOL>export default function toggleFullScreen(elem: HTMLElement = document.documentElement): boolean | undefined {<EOL>    if (document.fullscreenElement || (document as any).mozFullScreenElement || document.webkitFullscreenElement || (document as any).msFullscreenElement) {<EOL>        const func: () => Promise<void> = document.exitFullscreen || (document as any).msExitFullscreen || (document as any).mozCancelFullScreen || document.webkitExitFullscreen;<EOL>        if (func) {<EOL>            func.call(document);<EOL>            return false;<EOL>        }<EOL>    }<EOL>    else {<EOL>        const func: (options?: FullscreenOptions | undefined) => Promise<void> = elem.requestFullscreen || (elem as any).msRequestFullscreen || (elem as any).mozRequestFullScreen || elem.webkitRequestFullscreen;<EOL>        if (func) {<EOL>","gt":"func.call(elem, (Element as any).ALLOW_KEYBOARD_INPUT);"}
{"input":"<s> export function recallChatMessageFetch(this: SDKFetch, activityId: ActivityId): Observable<ActivitySchema> {<EOL>    return","gt":"this.put<ActivitySchema>(`<STR_LIT>`);"}
{"input":"<s> export function getFileFetch(this: SDKFetch, fileId: FileId, query?: any): Observable<FileSchema> {<EOL>    return this.get<FileSchema>(","gt":"fileId}`<STR_LIT>;"}
{"input":"<s> <EOL>export function parseHeaders(rawHeader: string): any {<EOL>    const head: any = Object.create(null);<EOL>    const pairs: string[] = rawHeader.trim().split('<STR_LIT>');<EOL>    pairs.","gt":"forEach((header: string): void => {"}
{"input":"<s> export function mock<T>(sdk: SDK): (m: T, schedule?: number | Promise<any> | undefined) => void {<EOL>    const mockFetch: MockFetch = new MockFetch;<EOL>    const methods: string[] = ['<STR_LIT>', '<STR_LIT>', '<STR_LIT>', '<STR_LIT>'];<EOL>    return (m: T, schedule?: number | Promise<any>): void => {<EOL>","gt":"methods.forEach((method: string): void => {"}
{"input":"<s> function blue(str: string): string {<EOL>    return","gt":"'<STR_LIT>' + str + '<STR_LIT>';"}
{"input":"<s> function watch(paths: string[]): any {<EOL>    return Observable.from(paths)<EOL>        .map((p: any): any => path.join(process.cwd(), p))<EOL>        .flatMap((path: any): any => Observable.create((","gt":"observer: Observer<string>): () => any => {"}
{"input":"<s> export function reduceMatrix(matrix: number[][], factor: number): number[][] {<EOL>    if (matrix.length !== matrix[<NUM_LIT>].length) {<EOL>        throw new Error(\"<STR_LIT>\");<EOL>    }<EOL>    if (matrix.length % factor !== <NUM_LIT>) {<EOL>        throw new","gt":"Error(\"<STR_LIT>\" +"}
{"input":"<s> export function reduceMatrix(matrix: number[][], factor: number): number[][] {<EOL>    if (matrix.length !== matrix[<NUM_LIT>].length) {<EOL>        throw new Error(\"<STR_LIT>\");<EOL>    }<EOL>    if (matrix.length % factor !== <NUM_LIT>) {<EOL>        throw new Error(\"<STR_LIT>\" +<EOL>            \"<STR_LIT>\");<EOL>    }<EOL>    let","gt":"result: number[][] = new Array(matrix.length / factor);"}
{"input":"<s> <EOL>export function getOutputNode(network: Node[][]): Node {<EOL>    return network[network.length -","gt":"<NUM_LIT>][<NUM_LIT>];"}
{"input":"<s> function route(nodes: any, groups: any, margin: number, groupMargin: number): GridRouter<any> {<EOL>    nodes.forEach((d: any): void => {<EOL>        d.routerNode = <any>{<EOL>            name: d.name,<EOL>            bounds:","gt":"d.bounds.inflate(-margin)"}
{"input":"<s> function route(nodes: any, groups: any, margin: number, groupMargin: number): GridRouter<any> {<EOL>    nodes.forEach((d: any): void => {<EOL>        d.routerNode = <any>{<EOL>            name: d.name,<EOL>            bounds: d.bounds.inflate(-margin)<EOL>        };<EOL>    });<EOL>    groups.forEach((","gt":"d: any): void => {"}
{"input":"<s> function route(nodes: any, groups: any, margin: number, groupMargin: number): GridRouter<any> {<EOL>    nodes.forEach((d: any): void => {<EOL>        d.routerNode = <any>{<EOL>            name: d.name,<EOL>            bounds: d.bounds.inflate(-margin)<EOL>        };<EOL>    });<EOL>    groups.forEach((d: any): void => {<EOL>        d.routerNode = <any>{<EOL>            bounds: d.bounds.inflate(-groupMargin),<EOL>            children: (typeof d.groups !== '<STR_LIT>' ? d.groups.map((c: any): any => nodes.length + c.id) : [])<EOL>                .concat(typeof d.leaves !== '<STR_LIT>' ? d.leaves.map((c: any): any => c.index) : [])<EOL>        };<EOL>    });<EOL>    let gridRouterNodes: any = nodes.concat(groups).map((d: any, i: any): any => {<EOL>        d.routerNode.id = i;<EOL>","gt":"return d.routerNode;"}
{"input":"<s> export function generateXConstraints(rs: Rectangle[], vars: Variable[]): Constraint[] {<EOL>","gt":"return generateConstraints(rs, vars, xRect, <NUM_LIT>);"}
{"input":"<s> function readJsonFile(path: string): any {<EOL>    return JSON.","gt":"parse(fs.readFileSync(path, { encoding: '<STR_LIT>' }));"}
{"input":"<s> export function addEventListener<K extends keyof HTMLElementEventMap>(element: HTMLElement, type: K, listener: EventListenerOrEventListenerObject<K>, useCapture?: boolean): Disposable {<EOL>    element.addEventListener(type, listener,","gt":"useCapture);"}
{"input":"<s> export function isCancelled(err: Error | undefined): boolean {<EOL>    return !!err &&","gt":"err.message === cancelledMessage;"}
{"input":"<s> export function openJsonRpcSocket(options: IServerOptions, onOpen: (socket: IWebSocket) => void): void {<EOL>    openSocket(options, (socket: ws): void => {<EOL>        const webSocket: IWebSocket = toIWebSocket(","gt":"socket);"}
{"input":"<s> export async function assertInstallation(expectation: {<EOL>    installed?: string[];<EOL>    uninstalled?: string[];<EOL>}): Promise<void> {<EOL>    const waitForWillInstall: Promise<InstallationParam> = new Promise<InstallationParam>((resolve: (value: InstallationParam | PromiseLike<InstallationParam>) => void): import(\"<STR_LIT>\").Disposable => appProject.onWillInstall(resolve));<EOL>    const waitForDidInstall: Promise<InstallationResult> = new Promise<InstallationResult>((resolve: (value: InstallationResult | PromiseLike<InstallationResult>) => void): import(\"<STR_LIT>\").Disposable => appProject.onDidInstall(resolve));<EOL>    await waitForWillInstall;<EOL>    const result: InstallationResult = await waitForDidInstall;<EOL>    if (expectation.","gt":"installed) {"}
{"input":"<s> export function bindNodeExtensionServer(bind: interfaces.Bind, args?: ApplicationProjectArgs): void {<EOL>    if (args) {<EOL>        bind(NpmClientOptions).toConstantValue(args);<EOL>        bind(ApplicationProjectOptions).toConstantValue(args);<EOL>    }<EOL>","gt":"else {"}
{"input":"<s> export function bindNodeExtensionServer(bind: interfaces.Bind, args?: ApplicationProjectArgs): void {<EOL>    if (args) {<EOL>        bind(NpmClientOptions).toConstantValue(args);<EOL>        bind(ApplicationProjectOptions).toConstantValue(args);<EOL>    }<EOL>    else {<EOL>        bind(ApplicationProjectCliContribution).toSelf().inSingletonScope();<EOL>        bind(CliContribution).toDynamicValue((ctx: any): any => ctx.container.get(ApplicationProjectCliContribution)).inSingletonScope();<EOL>        bind(NpmClientOptions).toDynamicValue((ctx: any): any => ctx.container.get(ApplicationProjectCliContribution).args).inSingletonScope();<EOL>","gt":"bind(ApplicationProjectOptions).toDynamicValue((ctx: any): any => ctx.container.get(ApplicationProjectCliContribution).args).inSingletonScope();"}
{"input":"<s> export function bindNodeExtensionServer(bind: interfaces.Bind, args?: ApplicationProjectArgs): void {<EOL>    if (args) {<EOL>        bind(NpmClientOptions).toConstantValue(args);<EOL>        bind(ApplicationProjectOptions).toConstantValue(args);<EOL>    }<EOL>    else {<EOL>        bind(ApplicationProjectCliContribution).toSelf().inSingletonScope();<EOL>        bind(CliContribution).toDynamicValue((ctx: any): any => ctx.container.get(ApplicationProjectCliContribution)).inSingletonScope();<EOL>        bind(NpmClientOptions).toDynamicValue((ctx: any): any => ctx.container.get(ApplicationProjectCliContribution).args).inSingletonScope();<EOL>        bind(ApplicationProjectOptions).toDynamicValue((ctx: any): any => ctx.container.get(ApplicationProjectCliContribution).args).inSingletonScope();<EOL>    }<EOL>    bind(NpmClient).toSelf().inSingletonScope();<EOL>    bind(ApplicationProject).toSelf().","gt":"inSingletonScope();"}
{"input":"<s> export function bindGitDecorationsPreferences(bind: interfaces.Bind): void {<EOL>    bind(GitDecorationsPreferences).toDynamicValue((ctx: any): GitDecorationsPreferences => {<EOL>        const","gt":"preferences: any = ctx.container.get<PreferenceService>(PreferenceService);"}
{"input":"<s> export function loadMonaco(vsRequire: any): Promise<void> {<EOL>    return new Promise<void>((resolve: (value: void | PromiseLike<void>) => void): void => {<EOL>        vsRequire([\"<STR_LIT>\"], (): void => {<EOL>            vsRequire([<EOL>","gt":"'<STR_LIT>',"}
{"input":"<s> export function loadMonaco(vsRequire: any): Promise<void> {<EOL>    return new Promise<void>((resolve: (value: void | PromiseLike<void>) => void): void => {<EOL>        vsRequire([\"<STR_LIT>\"], (): void => {<EOL>            vsRequire([<EOL>                '<STR_LIT>',<EOL>","gt":"'<STR_LIT>',"}
{"input":"<s> export function loadMonaco(vsRequire: any): Promise<void> {<EOL>    return new Promise<void>((resolve: (value: void | PromiseLike<void>) => void): void => {<EOL>        vsRequire([\"<STR_LIT>\"], (): void => {<EOL>            vsRequire([<EOL>                '<STR_LIT>',<EOL>                '<STR_LIT>',<EOL>                '<STR_LIT>',<EOL>                '<STR_LIT>',<EOL>                '<STR_LIT>',<EOL>                '<STR_LIT>',<EOL>                '<STR_LIT>',<EOL>                '<STR_LIT>',<EOL>                '<STR_LIT>',<EOL>                '<STR_LIT>',<EOL>                '<STR_LIT>',<EOL>                '<STR_LIT>',<EOL>                '<STR_LIT>',<EOL>                '<STR_LIT>',<EOL>                '<STR_LIT>',<EOL>                '<STR_LIT>',<EOL>                '<STR_LIT>',<EOL>                '<STR_LIT>',<EOL>                '<STR_LIT>',<EOL>                '<STR_LIT>',<EOL>                '<STR_LIT>'<EOL>            ], (basic: any, css: any, html: any, json: any, commands: any, actions: any, registry: any, resolver: any, resolvedKeybinding: any, keyCodes: any, editorCommonExtensions: any, simpleServices: any, standaloneServices: any, quickOpen: any, quickOpenWidget: any, quickOpenModel: any, filters: any, styler: any, platform: any, modes: any, cancellation: any): void => {<EOL>                const global: any = self;<EOL>                global.monaco.commands = commands;<EOL>                global.monaco.actions = actions;<EOL>                global.monaco.keybindings = Object.assign({}, registry, resolver, resolvedKeybinding, keyCodes);<EOL>                global.monaco.services = Object.assign({}, simpleServices, standaloneServices);<EOL>                global.monaco.quickOpen = Object.assign({},","gt":"quickOpen, quickOpenWidget, quickOpenModel);"}
{"input":"<s> export function loadMonaco(vsRequire: any): Promise<void> {<EOL>    return new Promise<void>((resolve: (value: void | PromiseLike<void>) => void): void => {<EOL>        vsRequire([\"<STR_LIT>\"], (): void => {<EOL>            vsRequire([<EOL>                '<STR_LIT>',<EOL>                '<STR_LIT>',<EOL>                '<STR_LIT>',<EOL>                '<STR_LIT>',<EOL>                '<STR_LIT>',<EOL>                '<STR_LIT>',<EOL>                '<STR_LIT>',<EOL>                '<STR_LIT>',<EOL>                '<STR_LIT>',<EOL>                '<STR_LIT>',<EOL>                '<STR_LIT>',<EOL>                '<STR_LIT>',<EOL>                '<STR_LIT>',<EOL>                '<STR_LIT>',<EOL>                '<STR_LIT>',<EOL>                '<STR_LIT>',<EOL>                '<STR_LIT>',<EOL>                '<STR_LIT>',<EOL>                '<STR_LIT>',<EOL>                '<STR_LIT>',<EOL>                '<STR_LIT>'<EOL>            ], (basic: any, css: any, html: any, json: any, commands: any, actions: any, registry: any, resolver: any, resolvedKeybinding: any, keyCodes: any, editorCommonExtensions: any, simpleServices: any, standaloneServices: any, quickOpen: any, quickOpenWidget: any, quickOpenModel: any, filters: any, styler: any, platform: any, modes: any, cancellation: any): void => {<EOL>                const global: any = self;<EOL>                global.monaco.commands = commands;<EOL>                global.monaco.actions = actions;<EOL>                global.monaco.keybindings = Object.assign({}, registry, resolver, resolvedKeybinding, keyCodes);<EOL>                global.monaco.services = Object.assign({}, simpleServices, standaloneServices);<EOL>                global.monaco.quickOpen = Object.assign({}, quickOpen, quickOpenWidget, quickOpenModel);<EOL>                global.monaco.filters = filters;<EOL>                global.monaco.theme = styler;<EOL>                global.monaco.","gt":"platform = platform;"}
{"input":"<s> <EOL>export function loadVsRequire(context: any): Promise<any> {<EOL>    <EOL>    <EOL>    const originalRequire: any = context.require;<EOL>","gt":"return new Promise<any>((resolve: (value: any) => void): void => {"}
{"input":"<s> <EOL>export function loadVsRequire(context: any): Promise<any> {<EOL>    <EOL>    <EOL>    const originalRequire: any = context.require;<EOL>    return new Promise<any>((resolve: (value: any) => void): void => {<EOL>        window.onload = (): void => {<EOL>            const vsLoader: HTMLScriptElement = document.createElement('<STR_LIT>');<EOL>","gt":"vsLoader.type = '<STR_LIT>';"}
{"input":"<s> <EOL>export function loadVsRequire(context: any): Promise<any> {<EOL>    <EOL>    <EOL>    const originalRequire: any = context.require;<EOL>    return new Promise<any>((resolve: (value: any) => void): void => {<EOL>        window.onload = (): void => {<EOL>            const vsLoader: HTMLScriptElement = document.createElement('<STR_LIT>');<EOL>            vsLoader.type = '<STR_LIT>';<EOL>            vsLoader.src = '<STR_LIT>';<EOL>            vsLoader.charset = '<STR_LIT>';<EOL>            vsLoader.addEventListener('<STR_LIT>', (): void => {<EOL>                <EOL>                const amdRequire: any = context.require;<EOL>                if (originalRequire) {<EOL>                    context.require = originalRequire;<EOL>                }<EOL>","gt":"resolve(amdRequire);"}
{"input":"<s> export function registerJavaScript(): void {<EOL>    monaco.languages.register({<EOL>        id: JAVASCRIPT_LANGUAGE_ID,<EOL>        extensions: ['<STR_LIT>', '<STR_LIT>'],<EOL>        aliases: [","gt":"JAVASCRIPT_LANGUAGE_NAME, '<STR_LIT>', '<STR_LIT>'],"}
{"input":"<s> export function registerJavaScript(): void {<EOL>    monaco.languages.register({<EOL>        id: JAVASCRIPT_LANGUAGE_ID,<EOL>        extensions: ['<STR_LIT>', '<STR_LIT>'],<EOL>        aliases: [JAVASCRIPT_LANGUAGE_NAME, '<STR_LIT>', '<STR_LIT>'],<EOL>        mimetypes: ['<STR_LIT>']<EOL>    });<EOL>    monaco.languages.onLanguage(JAVASCRIPT_LANGUAGE_ID, (): void => {<EOL>        monaco.languages.setLanguageConfiguration(JAVASCRIPT_LANGUAGE_ID,","gt":"genericEditConfiguration);"}
{"input":"<s> function createExecutor(config?: Partial<Config>): _Browser {<EOL>    const executor: _Browser = new Browser(config);<EOL>    executor.","gt":"registerLoader((_config: {"}
{"input":"<s> <EOL><EOL>export function u8aToHex(array: Uint8Array): string {<EOL>    const results: string[] = [];<EOL>","gt":"array.forEach((arrayByte: number): void => {"}
{"input":"<s> export function addDocumentListener(ev: string, handler: EventListener, passive: boolean = true): void {<EOL>    document.addEventListener(","gt":"ev, handler, supportsPassive ? { passive: passive } : false);"}
{"input":"<s> function average(array: Array<number>): number {<EOL>    if (array.length === <NUM_LIT>) {<EOL>        return","gt":"<NUM_LIT>;"}
{"input":"<s> <EOL>function isScrollable(el: HTMLElement): boolean {<EOL>    const cs: CSSStyleDeclaration = getComputedStyle(el);<EOL>    if (el.scrollHeight > el.clientHeight && (cs.overflowY === \"<STR_LIT>\" || cs.overflowY === \"<STR_LIT>\")) {<EOL>","gt":"return true;"}
{"input":"<s> export function expectSubscriptions(): any {<EOL>    if (!window.rxTestScheduler) {<EOL>        throw","gt":"'<STR_LIT>';"}
{"input":"<s> function unquote(s: string): string {<EOL>    if (s[<NUM_LIT>] === '<STR_LIT>' && s[s.length - <NUM_LIT>] === '<STR_LIT>') {<EOL>        return","gt":"JSON.parse(s);"}
{"input":"<s> function testFlatCacheObject(): void {<EOL>    <EOL>    createCachedSelector(fooSelector, combinerSelector)(fooSelector, {<EOL>        cacheObject: new FlatCacheObject()<EOL>    });<EOL>    <EOL>    const cacheObject: FlatCacheObject = new FlatCacheObject();<EOL>    cacheObject.set('<STR_LIT>', (): void => { });<EOL>    cacheObject.set(<NUM_LIT>, (): void => { });<EOL>    const result1: any = cacheObject.get('<STR_LIT>');<EOL>    const","gt":"result2: any = cacheObject.get(<NUM_LIT>);"}
{"input":"<s> <EOL>export function ArrayMaxSize(max: number, validationOptions?: ValidationOptions): (object: Object, propertyName: string) => void {<EOL>    return function (object: Object, propertyName: string) {<EOL>        const args: ValidationMetadataArgs = {<EOL>            type: ValidationTypes.ARRAY_MAX_SIZE,<EOL>            target:","gt":"object.constructor,"}
{"input":"<s> <EOL>export function IsAlphanumeric(validationOptions?: ValidationOptions): (object: Object, propertyName: string) => void {<EOL>    return function (object: Object, propertyName: string) {<EOL>        const args: ValidationMetadataArgs = {<EOL>","gt":"type: ValidationTypes.IS_ALPHANUMERIC,"}
{"input":"<s> <EOL>export function useContainer(iocContainer: {<EOL>    get(someClass: any): any;<EOL>}, options?: UseContainerOptions): void {<EOL>    userContainer =","gt":"iocContainer;"}
{"input":"<s> <EOL>export function UploadedFile(name: string, options?: UploadOptions): Function {<EOL>    return function (object: Object, methodName: string, index: number) {<EOL>        getMetadataArgsStorage().params.push({<EOL>            type: \"<STR_LIT>\",<EOL>            object:","gt":"object,"}
{"input":"<s> <EOL>export function UploadedFile(name: string, options?: UploadOptions): Function {<EOL>    return function (object: Object, methodName: string, index: number) {<EOL>        getMetadataArgsStorage().params.push({<EOL>            type: \"<STR_LIT>\",<EOL>            object: object,<EOL>            method: methodName,<EOL>            index: index,<EOL>            name: name,<EOL>            parse: false,<EOL>            required: options ? options.required : undefined,<EOL>            extraOptions: options ?","gt":"options.options : undefined"}
{"input":"<s> <EOL>export function createExecutor<T extends BaseDriver>(driver: T, options: RoutingControllersOptions = {}): void {<EOL>    <EOL>    let controllerClasses: Function[];<EOL>    if (options && options.controllers &&","gt":"options.controllers.length) {"}
{"input":"<s> <EOL>export function createExecutor<T extends BaseDriver>(driver: T, options: RoutingControllersOptions = {}): void {<EOL>    <EOL>    let controllerClasses: Function[];<EOL>    if (options && options.controllers && options.controllers.length) {<EOL>        controllerClasses = (options.controllers as any[]).filter((controller: any): boolean => controller instanceof Function);<EOL>        const controllerDirs: any[] = (options.controllers as any[]).filter((controller: any): boolean => typeof controller === \"<STR_LIT>\");<EOL>        controllerClasses.","gt":"push(...importClassesFromDirectories(controllerDirs));"}
{"input":"<s> <EOL>export function createExecutor<T extends BaseDriver>(driver: T, options: RoutingControllersOptions = {}): void {<EOL>    <EOL>    let controllerClasses: Function[];<EOL>    if (options && options.controllers && options.controllers.length) {<EOL>        controllerClasses = (options.controllers as any[]).filter((controller: any): boolean => controller instanceof Function);<EOL>        const controllerDirs: any[] = (options.controllers as any[]).filter((controller: any): boolean => typeof controller === \"<STR_LIT>\");<EOL>        controllerClasses.push(...importClassesFromDirectories(controllerDirs));<EOL>    }<EOL>    let","gt":"middlewareClasses: Function[];"}
{"input":"<s> <EOL>export function createExecutor<T extends BaseDriver>(driver: T, options: RoutingControllersOptions = {}): void {<EOL>    <EOL>    let controllerClasses: Function[];<EOL>    if (options && options.controllers && options.controllers.length) {<EOL>        controllerClasses = (options.controllers as any[]).filter((controller: any): boolean => controller instanceof Function);<EOL>        const controllerDirs: any[] = (options.controllers as any[]).filter((controller: any): boolean => typeof controller === \"<STR_LIT>\");<EOL>        controllerClasses.push(...importClassesFromDirectories(controllerDirs));<EOL>    }<EOL>    let middlewareClasses: Function[];<EOL>    if (options && options.middlewares && options.middlewares.length) {<EOL>        middlewareClasses = (options.middlewares as any[]).filter((controller: any): boolean => controller instanceof Function);<EOL>        const middlewareDirs: any[] = (options.middlewares as any[]).filter((controller: any): boolean => typeof controller === \"<STR_LIT>\");<EOL>","gt":"middlewareClasses.push(...importClassesFromDirectories(middlewareDirs));"}
{"input":"<s> <EOL>export function createExecutor<T extends BaseDriver>(driver: T, options: RoutingControllersOptions = {}): void {<EOL>    <EOL>    let controllerClasses: Function[];<EOL>    if (options && options.controllers && options.controllers.length) {<EOL>        controllerClasses = (options.controllers as any[]).filter((controller: any): boolean => controller instanceof Function);<EOL>        const controllerDirs: any[] = (options.controllers as any[]).filter((controller: any): boolean => typeof controller === \"<STR_LIT>\");<EOL>        controllerClasses.push(...importClassesFromDirectories(controllerDirs));<EOL>    }<EOL>    let middlewareClasses: Function[];<EOL>    if (options && options.middlewares && options.middlewares.length) {<EOL>        middlewareClasses = (options.middlewares as any[]).filter((controller: any): boolean => controller instanceof Function);<EOL>        const middlewareDirs: any[] = (options.middlewares as any[]).filter((controller: any): boolean => typeof controller === \"<STR_LIT>\");<EOL>        middlewareClasses.push(...importClassesFromDirectories(middlewareDirs));<EOL>    }<EOL>    let interceptorClasses: Function[];<EOL>    if (options && options.interceptors && options.interceptors.length) {<EOL>        interceptorClasses = (options.interceptors as any[]).filter((controller: any): boolean => controller instanceof Function);<EOL>        const interceptorDirs: any[] = (options.interceptors as any[]).filter((controller: any): boolean => typeof controller === \"<STR_LIT>\");<EOL>        interceptorClasses.push(...importClassesFromDirectories(interceptorDirs));<EOL>    }<EOL>","gt":"if (options && options.development !== undefined) {"}
{"input":"<s> <EOL>export function createExecutor<T extends BaseDriver>(driver: T, options: RoutingControllersOptions = {}): void {<EOL>    <EOL>    let controllerClasses: Function[];<EOL>    if (options && options.controllers && options.controllers.length) {<EOL>        controllerClasses = (options.controllers as any[]).filter((controller: any): boolean => controller instanceof Function);<EOL>        const controllerDirs: any[] = (options.controllers as any[]).filter((controller: any): boolean => typeof controller === \"<STR_LIT>\");<EOL>        controllerClasses.push(...importClassesFromDirectories(controllerDirs));<EOL>    }<EOL>    let middlewareClasses: Function[];<EOL>    if (options && options.middlewares && options.middlewares.length) {<EOL>        middlewareClasses = (options.middlewares as any[]).filter((controller: any): boolean => controller instanceof Function);<EOL>        const middlewareDirs: any[] = (options.middlewares as any[]).filter((controller: any): boolean => typeof controller === \"<STR_LIT>\");<EOL>        middlewareClasses.push(...importClassesFromDirectories(middlewareDirs));<EOL>    }<EOL>    let interceptorClasses: Function[];<EOL>    if (options && options.interceptors && options.interceptors.length) {<EOL>        interceptorClasses = (options.interceptors as any[]).filter((controller: any): boolean => controller instanceof Function);<EOL>        const interceptorDirs: any[] = (options.interceptors as any[]).filter((controller: any): boolean => typeof controller === \"<STR_LIT>\");<EOL>        interceptorClasses.push(...importClassesFromDirectories(interceptorDirs));<EOL>    }<EOL>    if (options && options.development !== undefined) {<EOL>        driver.developmentMode = options.development;<EOL>    }<EOL>    else {<EOL>        driver.developmentMode = process.env.NODE_ENV !== \"<STR_LIT>\";<EOL>    }<EOL>","gt":"if (options.defaultErrorHandler !== undefined) {"}
{"input":"<s> <EOL>export function createExecutor<T extends BaseDriver>(driver: T, options: RoutingControllersOptions = {}): void {<EOL>    <EOL>    let controllerClasses: Function[];<EOL>    if (options && options.controllers && options.controllers.length) {<EOL>        controllerClasses = (options.controllers as any[]).filter((controller: any): boolean => controller instanceof Function);<EOL>        const controllerDirs: any[] = (options.controllers as any[]).filter((controller: any): boolean => typeof controller === \"<STR_LIT>\");<EOL>        controllerClasses.push(...importClassesFromDirectories(controllerDirs));<EOL>    }<EOL>    let middlewareClasses: Function[];<EOL>    if (options && options.middlewares && options.middlewares.length) {<EOL>        middlewareClasses = (options.middlewares as any[]).filter((controller: any): boolean => controller instanceof Function);<EOL>        const middlewareDirs: any[] = (options.middlewares as any[]).filter((controller: any): boolean => typeof controller === \"<STR_LIT>\");<EOL>        middlewareClasses.push(...importClassesFromDirectories(middlewareDirs));<EOL>    }<EOL>    let interceptorClasses: Function[];<EOL>    if (options && options.interceptors && options.interceptors.length) {<EOL>        interceptorClasses = (options.interceptors as any[]).filter((controller: any): boolean => controller instanceof Function);<EOL>        const interceptorDirs: any[] = (options.interceptors as any[]).filter((controller: any): boolean => typeof controller === \"<STR_LIT>\");<EOL>        interceptorClasses.push(...importClassesFromDirectories(interceptorDirs));<EOL>    }<EOL>    if (options && options.development !== undefined) {<EOL>        driver.developmentMode = options.development;<EOL>    }<EOL>    else {<EOL>        driver.developmentMode = process.env.NODE_ENV !== \"<STR_LIT>\";<EOL>    }<EOL>    if (options.defaultErrorHandler !== undefined) {<EOL>        driver.isDefaultErrorHandlingEnabled = options.defaultErrorHandler;<EOL>    }<EOL>    else {<EOL>        driver.isDefaultErrorHandlingEnabled = true;<EOL>    }<EOL>    if (options.classTransformer !== undefined) {<EOL>        driver.useClassTransformer =","gt":"options.classTransformer;"}
{"input":"<s> <EOL>export function createExecutor<T extends BaseDriver>(driver: T, options: RoutingControllersOptions = {}): void {<EOL>    <EOL>    let controllerClasses: Function[];<EOL>    if (options && options.controllers && options.controllers.length) {<EOL>        controllerClasses = (options.controllers as any[]).filter((controller: any): boolean => controller instanceof Function);<EOL>        const controllerDirs: any[] = (options.controllers as any[]).filter((controller: any): boolean => typeof controller === \"<STR_LIT>\");<EOL>        controllerClasses.push(...importClassesFromDirectories(controllerDirs));<EOL>    }<EOL>    let middlewareClasses: Function[];<EOL>    if (options && options.middlewares && options.middlewares.length) {<EOL>        middlewareClasses = (options.middlewares as any[]).filter((controller: any): boolean => controller instanceof Function);<EOL>        const middlewareDirs: any[] = (options.middlewares as any[]).filter((controller: any): boolean => typeof controller === \"<STR_LIT>\");<EOL>        middlewareClasses.push(...importClassesFromDirectories(middlewareDirs));<EOL>    }<EOL>    let interceptorClasses: Function[];<EOL>    if (options && options.interceptors && options.interceptors.length) {<EOL>        interceptorClasses = (options.interceptors as any[]).filter((controller: any): boolean => controller instanceof Function);<EOL>        const interceptorDirs: any[] = (options.interceptors as any[]).filter((controller: any): boolean => typeof controller === \"<STR_LIT>\");<EOL>        interceptorClasses.push(...importClassesFromDirectories(interceptorDirs));<EOL>    }<EOL>    if (options && options.development !== undefined) {<EOL>        driver.developmentMode = options.development;<EOL>    }<EOL>    else {<EOL>        driver.developmentMode = process.env.NODE_ENV !== \"<STR_LIT>\";<EOL>    }<EOL>    if (options.defaultErrorHandler !== undefined) {<EOL>        driver.isDefaultErrorHandlingEnabled = options.defaultErrorHandler;<EOL>    }<EOL>    else {<EOL>        driver.isDefaultErrorHandlingEnabled = true;<EOL>    }<EOL>    if (options.classTransformer !== undefined) {<EOL>        driver.useClassTransformer = options.classTransformer;<EOL>    }<EOL>    else {<EOL>        driver.useClassTransformer = true;<EOL>    }<EOL>","gt":"if (options.validation !== undefined) {"}
{"input":"<s> <EOL>export function createExecutor<T extends BaseDriver>(driver: T, options: RoutingControllersOptions = {}): void {<EOL>    <EOL>    let controllerClasses: Function[];<EOL>    if (options && options.controllers && options.controllers.length) {<EOL>        controllerClasses = (options.controllers as any[]).filter((controller: any): boolean => controller instanceof Function);<EOL>        const controllerDirs: any[] = (options.controllers as any[]).filter((controller: any): boolean => typeof controller === \"<STR_LIT>\");<EOL>        controllerClasses.push(...importClassesFromDirectories(controllerDirs));<EOL>    }<EOL>    let middlewareClasses: Function[];<EOL>    if (options && options.middlewares && options.middlewares.length) {<EOL>        middlewareClasses = (options.middlewares as any[]).filter((controller: any): boolean => controller instanceof Function);<EOL>        const middlewareDirs: any[] = (options.middlewares as any[]).filter((controller: any): boolean => typeof controller === \"<STR_LIT>\");<EOL>        middlewareClasses.push(...importClassesFromDirectories(middlewareDirs));<EOL>    }<EOL>    let interceptorClasses: Function[];<EOL>    if (options && options.interceptors && options.interceptors.length) {<EOL>        interceptorClasses = (options.interceptors as any[]).filter((controller: any): boolean => controller instanceof Function);<EOL>        const interceptorDirs: any[] = (options.interceptors as any[]).filter((controller: any): boolean => typeof controller === \"<STR_LIT>\");<EOL>        interceptorClasses.push(...importClassesFromDirectories(interceptorDirs));<EOL>    }<EOL>    if (options && options.development !== undefined) {<EOL>        driver.developmentMode = options.development;<EOL>    }<EOL>    else {<EOL>        driver.developmentMode = process.env.NODE_ENV !== \"<STR_LIT>\";<EOL>    }<EOL>    if (options.defaultErrorHandler !== undefined) {<EOL>        driver.isDefaultErrorHandlingEnabled = options.defaultErrorHandler;<EOL>    }<EOL>    else {<EOL>        driver.isDefaultErrorHandlingEnabled = true;<EOL>    }<EOL>    if (options.classTransformer !== undefined) {<EOL>        driver.useClassTransformer = options.classTransformer;<EOL>    }<EOL>    else {<EOL>        driver.useClassTransformer = true;<EOL>    }<EOL>    if (options.validation !== undefined) {<EOL>        driver.enableValidation = !!options.validation;<EOL>        if (options.validation instanceof Object)<EOL>            driver.validationOptions = options.validation as ValidationOptions;<EOL>    }<EOL>    else {<EOL>        driver.enableValidation = true;<EOL>    }<EOL>    driver.classToPlainTransformOptions = options.classToPlainTransformOptions;<EOL>    driver.plainToClassTransformOptions = options.","gt":"plainToClassTransformOptions;"}
{"input":"<s> <EOL>export function createExecutor<T extends BaseDriver>(driver: T, options: RoutingControllersOptions = {}): void {<EOL>    <EOL>    let controllerClasses: Function[];<EOL>    if (options && options.controllers && options.controllers.length) {<EOL>        controllerClasses = (options.controllers as any[]).filter((controller: any): boolean => controller instanceof Function);<EOL>        const controllerDirs: any[] = (options.controllers as any[]).filter((controller: any): boolean => typeof controller === \"<STR_LIT>\");<EOL>        controllerClasses.push(...importClassesFromDirectories(controllerDirs));<EOL>    }<EOL>    let middlewareClasses: Function[];<EOL>    if (options && options.middlewares && options.middlewares.length) {<EOL>        middlewareClasses = (options.middlewares as any[]).filter((controller: any): boolean => controller instanceof Function);<EOL>        const middlewareDirs: any[] = (options.middlewares as any[]).filter((controller: any): boolean => typeof controller === \"<STR_LIT>\");<EOL>        middlewareClasses.push(...importClassesFromDirectories(middlewareDirs));<EOL>    }<EOL>    let interceptorClasses: Function[];<EOL>    if (options && options.interceptors && options.interceptors.length) {<EOL>        interceptorClasses = (options.interceptors as any[]).filter((controller: any): boolean => controller instanceof Function);<EOL>        const interceptorDirs: any[] = (options.interceptors as any[]).filter((controller: any): boolean => typeof controller === \"<STR_LIT>\");<EOL>        interceptorClasses.push(...importClassesFromDirectories(interceptorDirs));<EOL>    }<EOL>    if (options && options.development !== undefined) {<EOL>        driver.developmentMode = options.development;<EOL>    }<EOL>    else {<EOL>        driver.developmentMode = process.env.NODE_ENV !== \"<STR_LIT>\";<EOL>    }<EOL>    if (options.defaultErrorHandler !== undefined) {<EOL>        driver.isDefaultErrorHandlingEnabled = options.defaultErrorHandler;<EOL>    }<EOL>    else {<EOL>        driver.isDefaultErrorHandlingEnabled = true;<EOL>    }<EOL>    if (options.classTransformer !== undefined) {<EOL>        driver.useClassTransformer = options.classTransformer;<EOL>    }<EOL>    else {<EOL>        driver.useClassTransformer = true;<EOL>    }<EOL>    if (options.validation !== undefined) {<EOL>        driver.enableValidation = !!options.validation;<EOL>        if (options.validation instanceof Object)<EOL>            driver.validationOptions = options.validation as ValidationOptions;<EOL>    }<EOL>    else {<EOL>        driver.enableValidation = true;<EOL>    }<EOL>    driver.classToPlainTransformOptions = options.classToPlainTransformOptions;<EOL>    driver.plainToClassTransformOptions = options.plainToClassTransformOptions;<EOL>    if (options.errorOverridingMap !== undefined)<EOL>        driver.errorOverridingMap = options.errorOverridingMap;<EOL>    if (options.routePrefix !== undefined)<EOL>        driver.routePrefix = options.routePrefix;<EOL>    if (options.currentUserChecker !== undefined)<EOL>        driver.","gt":"currentUserChecker = options.currentUserChecker;"}
{"input":"<s> <EOL>export function createExecutor<T extends BaseDriver>(driver: T, options: RoutingControllersOptions = {}): void {<EOL>    <EOL>    let controllerClasses: Function[];<EOL>    if (options && options.controllers && options.controllers.length) {<EOL>        controllerClasses = (options.controllers as any[]).filter((controller: any): boolean => controller instanceof Function);<EOL>        const controllerDirs: any[] = (options.controllers as any[]).filter((controller: any): boolean => typeof controller === \"<STR_LIT>\");<EOL>        controllerClasses.push(...importClassesFromDirectories(controllerDirs));<EOL>    }<EOL>    let middlewareClasses: Function[];<EOL>    if (options && options.middlewares && options.middlewares.length) {<EOL>        middlewareClasses = (options.middlewares as any[]).filter((controller: any): boolean => controller instanceof Function);<EOL>        const middlewareDirs: any[] = (options.middlewares as any[]).filter((controller: any): boolean => typeof controller === \"<STR_LIT>\");<EOL>        middlewareClasses.push(...importClassesFromDirectories(middlewareDirs));<EOL>    }<EOL>    let interceptorClasses: Function[];<EOL>    if (options && options.interceptors && options.interceptors.length) {<EOL>        interceptorClasses = (options.interceptors as any[]).filter((controller: any): boolean => controller instanceof Function);<EOL>        const interceptorDirs: any[] = (options.interceptors as any[]).filter((controller: any): boolean => typeof controller === \"<STR_LIT>\");<EOL>        interceptorClasses.push(...importClassesFromDirectories(interceptorDirs));<EOL>    }<EOL>    if (options && options.development !== undefined) {<EOL>        driver.developmentMode = options.development;<EOL>    }<EOL>    else {<EOL>        driver.developmentMode = process.env.NODE_ENV !== \"<STR_LIT>\";<EOL>    }<EOL>    if (options.defaultErrorHandler !== undefined) {<EOL>        driver.isDefaultErrorHandlingEnabled = options.defaultErrorHandler;<EOL>    }<EOL>    else {<EOL>        driver.isDefaultErrorHandlingEnabled = true;<EOL>    }<EOL>    if (options.classTransformer !== undefined) {<EOL>        driver.useClassTransformer = options.classTransformer;<EOL>    }<EOL>    else {<EOL>        driver.useClassTransformer = true;<EOL>    }<EOL>    if (options.validation !== undefined) {<EOL>        driver.enableValidation = !!options.validation;<EOL>        if (options.validation instanceof Object)<EOL>            driver.validationOptions = options.validation as ValidationOptions;<EOL>    }<EOL>    else {<EOL>        driver.enableValidation = true;<EOL>    }<EOL>    driver.classToPlainTransformOptions = options.classToPlainTransformOptions;<EOL>    driver.plainToClassTransformOptions = options.plainToClassTransformOptions;<EOL>    if (options.errorOverridingMap !== undefined)<EOL>        driver.errorOverridingMap = options.errorOverridingMap;<EOL>    if (options.routePrefix !== undefined)<EOL>        driver.routePrefix = options.routePrefix;<EOL>    if (options.currentUserChecker !== undefined)<EOL>        driver.currentUserChecker = options.currentUserChecker;<EOL>    if (options.authorizationChecker !== undefined)<EOL>        driver.authorizationChecker = options.authorizationChecker;<EOL>    driver.cors =","gt":"options.cors;"}
{"input":"<s> <EOL>function getCompilerDigest(obj: object): any {<EOL>    return crypto.createHash('<STR_LIT>').update(JSON.","gt":"stringify(obj), '<STR_LIT>').digest('<STR_LIT>');"}
{"input":"<s> <EOL>export function parse(value: string | undefined): object | undefined {<EOL>    return typeof","gt":"value === '<STR_LIT>' ? JSON.parse(value) : undefined;"}
{"input":"<s> function isCommandLine(args: ArgvOrCommandLine): args is string {<EOL>    return typeof args ===","gt":"'<STR_LIT>';"}
{"input":"<s> function getArray(key: keyof Language, obj1: any, obj2: any): string[] {<EOL>    return _.union<string>(obj1[key] || [],","gt":"obj2[key] || []).sort();"}
{"input":"<s> export function replaceType(originalContents: string, typeName: string, newTypeBody: string): string {<EOL>    return originalContents.","gt":"replace(new RegExp(`<STR_LIT>`, \"<STR_LIT>\"), `<STR_LIT>`);"}
{"input":"<s> function fakeDate(defaultDate: string | number): void {<EOL>    global.Date = (arg: any): Date => new _Date(","gt":"typeof arg !== '<STR_LIT>' ? arg : defaultDate);"}
{"input":"<s> function hashPriority(priority: number | string): string {<EOL>    if (typeof priority === '<STR_LIT>') {<EOL>        return","gt":"priority)}`<STR_LIT>;"}
{"input":"<s> <EOL><EOL>export function isReservedWord(s: string): boolean {<EOL>    var keywords: string[] = ['<STR_LIT>', '<STR_LIT>', '<STR_LIT>',<EOL>        '<STR_LIT>', '<STR_LIT>', '<STR_LIT>'];<EOL>    for (var k: string in","gt":"keywords) {"}
{"input":"<s> <EOL><EOL>export function arrayBufferToBuffer(ab: ArrayBuffer): Buffer {<EOL>    return new Buffer(","gt":"ab);"}
{"input":"<s> function getRandomInt(min: number, max: number): number {<EOL>    return Math.floor(Math.random() * (max - min +","gt":"<NUM_LIT>)) + min;"}
{"input":"<s> function firstChildOf(internalTreeDebugElement: DebugElement): DebugElement {<EOL>    return internalTreeDebugElement.","gt":"query(By.directive(TreeInternalComponent));"}
{"input":"<s> function setMonth(fixture: TestFixture, month: Partial<DaysCalendarViewModel>): void {<EOL>    fixture.componentInstance.month = month","gt":"as DaysCalendarViewModel;"}
{"input":"<s> export function apiMove(state: State, orig: Key, dest: Key): boolean {<EOL>    return","gt":"baseMove(state, orig, dest);"}
{"input":"<s> export function canDrop(state: State, orig: Key, dest: Key): boolean {<EOL>    const piece: Piece = state.pieces[","gt":"orig];"}
{"input":"<s> export function canMove(state: State, orig: Key, dest: Key): boolean {<EOL>    return orig !==","gt":"dest && isMovable(state, orig) && (state.movable.free || (state.movable.dests !== null && util.containsX(state.movable.dests[orig], dest)));"}
{"input":"<s> function stoppedPlaying(name: string): void {<EOL>    setPlaying(name,","gt":"false);"}
{"input":"<s> export function berserkableBy(data: OnlineGameData): boolean | undefined {<EOL>    return data.tournament &&<EOL>        data.tournament.","gt":"berserkable &&"}
{"input":"<s> export function isOpponentTurn(data: GameData): boolean {<EOL>    return isPlayerPlaying(data) && data.game.player !== data.","gt":"player.color;"}
{"input":"<s> export function playable(data: GameData | AnalyseData): boolean {<EOL>    return","gt":"data.game.source !== '<STR_LIT>' && data.game.status.id < gameStatus.ids.aborted;"}
{"input":"<s> export function publicUrl(data: GameData): string {<EOL>    return '<STR_LIT>' + data.game.","gt":"id;"}
{"input":"<s> export function takebackable(data: OnlineGameData): boolean {<EOL>    return !!(","gt":"playable(data) && data.takebackable && !data.tournament && playedTurns(data) > <NUM_LIT> && !data.player.proposingTakeback && !data.opponent.proposingTakeback);"}
{"input":"<s> export function isMoveRequest(r: MoveRequest | DropRequest): r is MoveRequest {<EOL>    return (<MoveRequest>r).u !==","gt":"undefined;"}
{"input":"<s> function setQueryParams(params: StringMap): void {<EOL>    const","gt":"path: string = get().replace(/\\?.+$/, '<STR_LIT>');"}
{"input":"<s> function isSession(data: Session | LobbyData): data is Session {<EOL>","gt":"return (<Session>data).id !== undefined;"}
{"input":"<s> function withStorage<T>(f: (s: Storage) => T | void): T | void | null {<EOL>    <EOL>","gt":"try {"}
{"input":"<s> function skill(level: number): number {<EOL>    return Math.round((level - <NUM_LIT>) * (","gt":"maxSkill / <NUM_LIT>));"}
{"input":"<s> export function requestComputerAnalysis(gameId: string): Promise<string> {<EOL>    return fetchText(","gt":"gameId}/request-analysis`, {"}
{"input":"<s> function cpWinningChances(cp: number): number {<EOL>    return","gt":"rawWinningChances(Math.min(Math.max(-<NUM_LIT>, cp), <NUM_LIT>));"}
{"input":"<s> function clockContent(centis: number): Mithril.BaseNode {<EOL>    if (centis === undefined)<EOL>        return h('<STR_LIT>', ['<STR_LIT>']);<EOL>    const date: Date = new Date(centis * <NUM_LIT>), millis: number = date.getUTCMilliseconds(), sep: string = '<STR_LIT>', baseStr: string = pad2(date.getUTCMinutes()) + sep + pad2(date.getUTCSeconds());<EOL>","gt":"if (centis >= <NUM_LIT>)"}
{"input":"<s> function clockContent(centis: number): Mithril.BaseNode {<EOL>    if (centis === undefined)<EOL>        return h('<STR_LIT>', ['<STR_LIT>']);<EOL>    const date: Date = new Date(centis * <NUM_LIT>), millis: number = date.getUTCMilliseconds(), sep: string = '<STR_LIT>', baseStr: string = pad2(date.getUTCMinutes()) + sep + pad2(date.getUTCSeconds());<EOL>    if (centis >= <NUM_LIT>)<EOL>        return h('<STR_LIT>', [Math.floor(centis / <NUM_LIT>) + sep + baseStr]);<EOL>    const tenthsStr: string = Math.floor(millis / <NUM_LIT>).toString();<EOL>    return h('<STR_LIT>', [<EOL>","gt":"baseStr,"}
{"input":"<s> function renderClock(color: Color, centis: number, current: boolean): Mithril.BaseNode {<EOL>    return","gt":"h('<STR_LIT>', {"}
{"input":"<s> export default function renderGameAnalysis(ctrl: AnalyseCtrl): Mithril.BaseNode {<EOL>    const isPortrait: boolean = helper.isPortrait();<EOL>    const vd: helper.ViewportDim = helper.","gt":"viewportDim();"}
{"input":"<s> export function renderMove(ctx: Ctx, node: Tree.Node): Mithril.BaseNode[] {<EOL>    const ev: any = getBestEval({ client: node.ceval, server: node.eval }) || {};<EOL>","gt":"return [h('<STR_LIT>', fixCrazySan(node.san!))]"}
{"input":"<s> function castlingButton(ctrl: Editor, c: string[]): Mithril.Vnode<any, any> {<EOL>    const cur: Mithril.Stream<boolean> = ctrl.data.editor.castles[c[<NUM_LIT>]];<EOL>","gt":"return h('<STR_LIT>', {"}
{"input":"<s> export function getLI(e: Event): HTMLElement {<EOL>    const target: HTMLElement = (e.target","gt":"as HTMLElement);"}
{"input":"<s> export function slidesOutRight(callback: (fromBB?: string) => void, elID: string): () => Promise<HTMLElement> {<EOL>    return function (fromBB?: string) {<EOL>","gt":"const el: HTMLElement | null = document.getElementById(elID);"}
{"input":"<s> export function respond(id: string, response: string): Promise<ComposeResponse> {<EOL>    return fetchJSON('<STR_LIT>' + id, {<EOL>","gt":"method: '<STR_LIT>',"}
{"input":"<s> export function thread(id: string): Promise<ThreadData> {<EOL>","gt":"return fetchJSON('<STR_LIT>' + id, {}, true);"}
{"input":"<s> function sendResponse(form: HTMLFormElement): void {<EOL>    const id: string = (form[<NUM_LIT>] as HTMLInputElement).value;<EOL>    const response: string = (form[<NUM_LIT>] as HTMLTextAreaElement).value;<EOL>    if (!response)<EOL>        return;<EOL>    xhr.","gt":"respond(id, response)"}
{"input":"<s> function sendResponse(form: HTMLFormElement): void {<EOL>    const id: string = (form[<NUM_LIT>] as HTMLInputElement).value;<EOL>    const response: string = (form[<NUM_LIT>] as HTMLTextAreaElement).value;<EOL>    if (!response)<EOL>        return;<EOL>    xhr.respond(id, response)<EOL>        .then((data: import(\"<STR_LIT>\").ComposeResponse): void => {<EOL>        if (data.ok) {<EOL>            router.set('<STR_LIT>' + id);<EOL>        }<EOL>        else {<EOL>","gt":"redraw();"}
{"input":"<s> function stopAndClose(fromBB?: string): void {<EOL>    if (","gt":"fromBB !== '<STR_LIT>' && isOpenAndSeeking)"}
{"input":"<s> function open(): void {<EOL>    if (xhr.cachedPools.length === <NUM_LIT>) {<EOL>        xhr.lobby(false).","gt":"then(redraw);"}
{"input":"<s> function reload(ground: Chessground, data: OfflineGameData, sit: GameSituation): void {<EOL>    ground.","gt":"reconfigure(makeConfig(data, sit));"}
{"input":"<s> export function chatView(ctrl: Chat): Mithril.Vnode<any, any> | null {<EOL>    if (!ctrl.showing)<EOL>        return null;<EOL>    const player: import(\"<STR_LIT>\").OnlinePlayer = ctrl.root.data.player;<EOL>    let","gt":"header: string = (!ctrl.root.data.opponent.user || ctrl.root.data.player.spectator) ? i18n('<STR_LIT>') : ctrl.root.data.opponent.user.username;"}
{"input":"<s> export function chatView(ctrl: Chat): Mithril.Vnode<any, any> | null {<EOL>    if (!ctrl.showing)<EOL>        return null;<EOL>    const player: import(\"<STR_LIT>\").OnlinePlayer = ctrl.root.data.player;<EOL>    let header: string = (!ctrl.root.data.opponent.user || ctrl.root.data.player.spectator) ? i18n('<STR_LIT>') : ctrl.root.data.opponent.user.username;<EOL>    const watchers: import(\"<STR_LIT>\").GameWatchers | undefined = ctrl.root.data.watchers;<EOL>    if (ctrl.root.data.player.spectator && watchers && watchers.nb >= <NUM_LIT>) {<EOL>        header = i18n(","gt":"'<STR_LIT>') + '<STR_LIT>' + watchers.nb;"}
{"input":"<s> export function chatView(ctrl: Chat): Mithril.Vnode<any, any> | null {<EOL>    if (!ctrl.showing)<EOL>        return null;<EOL>    const player: import(\"<STR_LIT>\").OnlinePlayer = ctrl.root.data.player;<EOL>    let header: string = (!ctrl.root.data.opponent.user || ctrl.root.data.player.spectator) ? i18n('<STR_LIT>') : ctrl.root.data.opponent.user.username;<EOL>    const watchers: import(\"<STR_LIT>\").GameWatchers | undefined = ctrl.root.data.watchers;<EOL>    if (ctrl.root.data.player.spectator && watchers && watchers.nb >= <NUM_LIT>) {<EOL>        header = i18n('<STR_LIT>') + '<STR_LIT>' + watchers.nb;<EOL>    }<EOL>    return h('<STR_LIT>', { oncreate: helper.slidesInUp }, [<EOL>        h(","gt":"'<STR_LIT>', ["}
{"input":"<s> export function chatView(ctrl: Chat): Mithril.Vnode<any, any> | null {<EOL>    if (!ctrl.showing)<EOL>        return null;<EOL>    const player: import(\"<STR_LIT>\").OnlinePlayer = ctrl.root.data.player;<EOL>    let header: string = (!ctrl.root.data.opponent.user || ctrl.root.data.player.spectator) ? i18n('<STR_LIT>') : ctrl.root.data.opponent.user.username;<EOL>    const watchers: import(\"<STR_LIT>\").GameWatchers | undefined = ctrl.root.data.watchers;<EOL>    if (ctrl.root.data.player.spectator && watchers && watchers.nb >= <NUM_LIT>) {<EOL>        header = i18n('<STR_LIT>') + '<STR_LIT>' + watchers.nb;<EOL>    }<EOL>    return h('<STR_LIT>', { oncreate: helper.slidesInUp }, [<EOL>        h('<STR_LIT>', [<EOL>            h('<STR_LIT>', {<EOL>                oncreate: helper.ontap(helper.slidesOutDown(ctrl.close, '<STR_LIT>'))<EOL>            }, closeIcon),<EOL>            h('<STR_LIT>', header)<EOL>        ]),<EOL>        h(","gt":"'<STR_LIT>', ["}
{"input":"<s> export function chatView(ctrl: Chat): Mithril.Vnode<any, any> | null {<EOL>    if (!ctrl.showing)<EOL>        return null;<EOL>    const player: import(\"<STR_LIT>\").OnlinePlayer = ctrl.root.data.player;<EOL>    let header: string = (!ctrl.root.data.opponent.user || ctrl.root.data.player.spectator) ? i18n('<STR_LIT>') : ctrl.root.data.opponent.user.username;<EOL>    const watchers: import(\"<STR_LIT>\").GameWatchers | undefined = ctrl.root.data.watchers;<EOL>    if (ctrl.root.data.player.spectator && watchers && watchers.nb >= <NUM_LIT>) {<EOL>        header = i18n('<STR_LIT>') + '<STR_LIT>' + watchers.nb;<EOL>    }<EOL>    return h('<STR_LIT>', { oncreate: helper.slidesInUp }, [<EOL>        h('<STR_LIT>', [<EOL>            h('<STR_LIT>', {<EOL>                oncreate: helper.ontap(helper.slidesOutDown(ctrl.close, '<STR_LIT>'))<EOL>            }, closeIcon),<EOL>            h('<STR_LIT>', header)<EOL>        ]),<EOL>        h('<STR_LIT>', [<EOL>            h('<STR_LIT>', {<EOL>                oncreate: ({ dom }: Mithril.DOMNode): void => scrollChatToBottom(dom as HTMLElement),<EOL>                onupdate: ({ dom }: Mithril.DOMNode): void => scrollChatToBottom(dom as HTMLElement)<EOL>            }, [<EOL>                h('<STR_LIT>', ctrl.selectLines().map((msg: ChatMsg, i: number, all: ChatMsg[]): Mithril.Vnode<any, any> => {<EOL>                    if (ctrl.root.data.player.spectator)<EOL>                        return spectatorChatRender(msg, i, all);<EOL>                    else<EOL>                        return playerChatRender(player, msg,","gt":"i,"}
{"input":"<s> export function chatView(ctrl: Chat): Mithril.Vnode<any, any> | null {<EOL>    if (!ctrl.showing)<EOL>        return null;<EOL>    const player: import(\"<STR_LIT>\").OnlinePlayer = ctrl.root.data.player;<EOL>    let header: string = (!ctrl.root.data.opponent.user || ctrl.root.data.player.spectator) ? i18n('<STR_LIT>') : ctrl.root.data.opponent.user.username;<EOL>    const watchers: import(\"<STR_LIT>\").GameWatchers | undefined = ctrl.root.data.watchers;<EOL>    if (ctrl.root.data.player.spectator && watchers && watchers.nb >= <NUM_LIT>) {<EOL>        header = i18n('<STR_LIT>') + '<STR_LIT>' + watchers.nb;<EOL>    }<EOL>    return h('<STR_LIT>', { oncreate: helper.slidesInUp }, [<EOL>        h('<STR_LIT>', [<EOL>            h('<STR_LIT>', {<EOL>                oncreate: helper.ontap(helper.slidesOutDown(ctrl.close, '<STR_LIT>'))<EOL>            }, closeIcon),<EOL>            h('<STR_LIT>', header)<EOL>        ]),<EOL>        h('<STR_LIT>', [<EOL>            h('<STR_LIT>', {<EOL>                oncreate: ({ dom }: Mithril.DOMNode): void => scrollChatToBottom(dom as HTMLElement),<EOL>                onupdate: ({ dom }: Mithril.DOMNode): void => scrollChatToBottom(dom as HTMLElement)<EOL>            }, [<EOL>                h('<STR_LIT>', ctrl.selectLines().map((msg: ChatMsg, i: number, all: ChatMsg[]): Mithril.Vnode<any, any> => {<EOL>                    if (ctrl.root.data.player.spectator)<EOL>                        return spectatorChatRender(msg, i, all);<EOL>                    else<EOL>                        return playerChatRender(player, msg, i,","gt":"all);"}
{"input":"<s> export function chatView(ctrl: Chat): Mithril.Vnode<any, any> | null {<EOL>    if (!ctrl.showing)<EOL>        return null;<EOL>    const player: import(\"<STR_LIT>\").OnlinePlayer = ctrl.root.data.player;<EOL>    let header: string = (!ctrl.root.data.opponent.user || ctrl.root.data.player.spectator) ? i18n('<STR_LIT>') : ctrl.root.data.opponent.user.username;<EOL>    const watchers: import(\"<STR_LIT>\").GameWatchers | undefined = ctrl.root.data.watchers;<EOL>    if (ctrl.root.data.player.spectator && watchers && watchers.nb >= <NUM_LIT>) {<EOL>        header = i18n('<STR_LIT>') + '<STR_LIT>' + watchers.nb;<EOL>    }<EOL>    return h('<STR_LIT>', { oncreate: helper.slidesInUp }, [<EOL>        h('<STR_LIT>', [<EOL>            h('<STR_LIT>', {<EOL>                oncreate: helper.ontap(helper.slidesOutDown(ctrl.close, '<STR_LIT>'))<EOL>            }, closeIcon),<EOL>            h('<STR_LIT>', header)<EOL>        ]),<EOL>        h('<STR_LIT>', [<EOL>            h('<STR_LIT>', {<EOL>                oncreate: ({ dom }: Mithril.DOMNode): void => scrollChatToBottom(dom as HTMLElement),<EOL>                onupdate: ({ dom }: Mithril.DOMNode): void => scrollChatToBottom(dom as HTMLElement)<EOL>            }, [<EOL>                h('<STR_LIT>', ctrl.selectLines().map((msg: ChatMsg, i: number, all: ChatMsg[]): Mithril.Vnode<any, any> => {<EOL>                    if (ctrl.root.data.player.spectator)<EOL>                        return spectatorChatRender(msg, i, all);<EOL>                    else<EOL>                        return playerChatRender(player, msg, i, all);<EOL>                }))<EOL>            ]),<EOL>            h('<STR_LIT>', {<EOL>                onsubmit: (e: Event): void => {<EOL>                    e.preventDefault();<EOL>                    const target: HTMLFormElement = (e.target as HTMLFormElement);<EOL>                    const ta: Element = target[<NUM_LIT>];<EOL>                    ta.focus();<EOL>","gt":"const msg: any = ta.value.trim();"}
{"input":"<s> export function chatView(ctrl: Chat): Mithril.Vnode<any, any> | null {<EOL>    if (!ctrl.showing)<EOL>        return null;<EOL>    const player: import(\"<STR_LIT>\").OnlinePlayer = ctrl.root.data.player;<EOL>    let header: string = (!ctrl.root.data.opponent.user || ctrl.root.data.player.spectator) ? i18n('<STR_LIT>') : ctrl.root.data.opponent.user.username;<EOL>    const watchers: import(\"<STR_LIT>\").GameWatchers | undefined = ctrl.root.data.watchers;<EOL>    if (ctrl.root.data.player.spectator && watchers && watchers.nb >= <NUM_LIT>) {<EOL>        header = i18n('<STR_LIT>') + '<STR_LIT>' + watchers.nb;<EOL>    }<EOL>    return h('<STR_LIT>', { oncreate: helper.slidesInUp }, [<EOL>        h('<STR_LIT>', [<EOL>            h('<STR_LIT>', {<EOL>                oncreate: helper.ontap(helper.slidesOutDown(ctrl.close, '<STR_LIT>'))<EOL>            }, closeIcon),<EOL>            h('<STR_LIT>', header)<EOL>        ]),<EOL>        h('<STR_LIT>', [<EOL>            h('<STR_LIT>', {<EOL>                oncreate: ({ dom }: Mithril.DOMNode): void => scrollChatToBottom(dom as HTMLElement),<EOL>                onupdate: ({ dom }: Mithril.DOMNode): void => scrollChatToBottom(dom as HTMLElement)<EOL>            }, [<EOL>                h('<STR_LIT>', ctrl.selectLines().map((msg: ChatMsg, i: number, all: ChatMsg[]): Mithril.Vnode<any, any> => {<EOL>                    if (ctrl.root.data.player.spectator)<EOL>                        return spectatorChatRender(msg, i, all);<EOL>                    else<EOL>                        return playerChatRender(player, msg, i, all);<EOL>                }))<EOL>            ]),<EOL>            h('<STR_LIT>', {<EOL>                onsubmit: (e: Event): void => {<EOL>                    e.preventDefault();<EOL>                    const target: HTMLFormElement = (e.target as HTMLFormElement);<EOL>                    const ta: Element = target[<NUM_LIT>];<EOL>                    ta.focus();<EOL>                    const msg: any = ta.value.trim();<EOL>                    if (!validateMsg(msg))<EOL>                        return;<EOL>                    ctrl.inputValue = '<STR_LIT>';<EOL>                    ta.setAttribute('<STR_LIT>', '<STR_LIT>');<EOL>                    ta.style.paddingTop = '<STR_LIT>';<EOL>                    socket.send('<STR_LIT>', msg);<EOL>                    const sendButton: HTMLElement | null = document.getElementById('<STR_LIT>');<EOL>                    if (sendButton) {<EOL>                        sendButton.classList.","gt":"add('<STR_LIT>');"}
{"input":"<s> export function chatView(ctrl: Chat): Mithril.Vnode<any, any> | null {<EOL>    if (!ctrl.showing)<EOL>        return null;<EOL>    const player: import(\"<STR_LIT>\").OnlinePlayer = ctrl.root.data.player;<EOL>    let header: string = (!ctrl.root.data.opponent.user || ctrl.root.data.player.spectator) ? i18n('<STR_LIT>') : ctrl.root.data.opponent.user.username;<EOL>    const watchers: import(\"<STR_LIT>\").GameWatchers | undefined = ctrl.root.data.watchers;<EOL>    if (ctrl.root.data.player.spectator && watchers && watchers.nb >= <NUM_LIT>) {<EOL>        header = i18n('<STR_LIT>') + '<STR_LIT>' + watchers.nb;<EOL>    }<EOL>    return h('<STR_LIT>', { oncreate: helper.slidesInUp }, [<EOL>        h('<STR_LIT>', [<EOL>            h('<STR_LIT>', {<EOL>                oncreate: helper.ontap(helper.slidesOutDown(ctrl.close, '<STR_LIT>'))<EOL>            }, closeIcon),<EOL>            h('<STR_LIT>', header)<EOL>        ]),<EOL>        h('<STR_LIT>', [<EOL>            h('<STR_LIT>', {<EOL>                oncreate: ({ dom }: Mithril.DOMNode): void => scrollChatToBottom(dom as HTMLElement),<EOL>                onupdate: ({ dom }: Mithril.DOMNode): void => scrollChatToBottom(dom as HTMLElement)<EOL>            }, [<EOL>                h('<STR_LIT>', ctrl.selectLines().map((msg: ChatMsg, i: number, all: ChatMsg[]): Mithril.Vnode<any, any> => {<EOL>                    if (ctrl.root.data.player.spectator)<EOL>                        return spectatorChatRender(msg, i, all);<EOL>                    else<EOL>                        return playerChatRender(player, msg, i, all);<EOL>                }))<EOL>            ]),<EOL>            h('<STR_LIT>', {<EOL>                onsubmit: (e: Event): void => {<EOL>                    e.preventDefault();<EOL>                    const target: HTMLFormElement = (e.target as HTMLFormElement);<EOL>                    const ta: Element = target[<NUM_LIT>];<EOL>                    ta.focus();<EOL>                    const msg: any = ta.value.trim();<EOL>                    if (!validateMsg(msg))<EOL>                        return;<EOL>                    ctrl.inputValue = '<STR_LIT>';<EOL>                    ta.setAttribute('<STR_LIT>', '<STR_LIT>');<EOL>                    ta.style.paddingTop = '<STR_LIT>';<EOL>                    socket.send('<STR_LIT>', msg);<EOL>                    const sendButton: HTMLElement | null = document.getElementById('<STR_LIT>');<EOL>                    if (sendButton) {<EOL>                        sendButton.classList.add('<STR_LIT>');<EOL>                    }<EOL>                }<EOL>            }, [<EOL>                h('<STR_LIT>', {<EOL>                    placeholder: ctrl.canTalk(ctrl.root.data) ? i18n('<STR_LIT>') : '<STR_LIT>',<EOL>                    disabled: !ctrl.canTalk(","gt":"ctrl.root.data),"}
{"input":"<s> export function chatView(ctrl: Chat): Mithril.Vnode<any, any> | null {<EOL>    if (!ctrl.showing)<EOL>        return null;<EOL>    const player: import(\"<STR_LIT>\").OnlinePlayer = ctrl.root.data.player;<EOL>    let header: string = (!ctrl.root.data.opponent.user || ctrl.root.data.player.spectator) ? i18n('<STR_LIT>') : ctrl.root.data.opponent.user.username;<EOL>    const watchers: import(\"<STR_LIT>\").GameWatchers | undefined = ctrl.root.data.watchers;<EOL>    if (ctrl.root.data.player.spectator && watchers && watchers.nb >= <NUM_LIT>) {<EOL>        header = i18n('<STR_LIT>') + '<STR_LIT>' + watchers.nb;<EOL>    }<EOL>    return h('<STR_LIT>', { oncreate: helper.slidesInUp }, [<EOL>        h('<STR_LIT>', [<EOL>            h('<STR_LIT>', {<EOL>                oncreate: helper.ontap(helper.slidesOutDown(ctrl.close, '<STR_LIT>'))<EOL>            }, closeIcon),<EOL>            h('<STR_LIT>', header)<EOL>        ]),<EOL>        h('<STR_LIT>', [<EOL>            h('<STR_LIT>', {<EOL>                oncreate: ({ dom }: Mithril.DOMNode): void => scrollChatToBottom(dom as HTMLElement),<EOL>                onupdate: ({ dom }: Mithril.DOMNode): void => scrollChatToBottom(dom as HTMLElement)<EOL>            }, [<EOL>                h('<STR_LIT>', ctrl.selectLines().map((msg: ChatMsg, i: number, all: ChatMsg[]): Mithril.Vnode<any, any> => {<EOL>                    if (ctrl.root.data.player.spectator)<EOL>                        return spectatorChatRender(msg, i, all);<EOL>                    else<EOL>                        return playerChatRender(player, msg, i, all);<EOL>                }))<EOL>            ]),<EOL>            h('<STR_LIT>', {<EOL>                onsubmit: (e: Event): void => {<EOL>                    e.preventDefault();<EOL>                    const target: HTMLFormElement = (e.target as HTMLFormElement);<EOL>                    const ta: Element = target[<NUM_LIT>];<EOL>                    ta.focus();<EOL>                    const msg: any = ta.value.trim();<EOL>                    if (!validateMsg(msg))<EOL>                        return;<EOL>                    ctrl.inputValue = '<STR_LIT>';<EOL>                    ta.setAttribute('<STR_LIT>', '<STR_LIT>');<EOL>                    ta.style.paddingTop = '<STR_LIT>';<EOL>                    socket.send('<STR_LIT>', msg);<EOL>                    const sendButton: HTMLElement | null = document.getElementById('<STR_LIT>');<EOL>                    if (sendButton) {<EOL>                        sendButton.classList.add('<STR_LIT>');<EOL>                    }<EOL>                }<EOL>            }, [<EOL>                h('<STR_LIT>', {<EOL>                    placeholder: ctrl.canTalk(ctrl.root.data) ? i18n('<STR_LIT>') : '<STR_LIT>',<EOL>                    disabled: !ctrl.canTalk(ctrl.root.data),<EOL>                    rows: <NUM_LIT>,<EOL>                    maxlength: <NUM_LIT>,<EOL>                    value:","gt":"ctrl.inputValue,"}
{"input":"<s> export function chatView(ctrl: Chat): Mithril.Vnode<any, any> | null {<EOL>    if (!ctrl.showing)<EOL>        return null;<EOL>    const player: import(\"<STR_LIT>\").OnlinePlayer = ctrl.root.data.player;<EOL>    let header: string = (!ctrl.root.data.opponent.user || ctrl.root.data.player.spectator) ? i18n('<STR_LIT>') : ctrl.root.data.opponent.user.username;<EOL>    const watchers: import(\"<STR_LIT>\").GameWatchers | undefined = ctrl.root.data.watchers;<EOL>    if (ctrl.root.data.player.spectator && watchers && watchers.nb >= <NUM_LIT>) {<EOL>        header = i18n('<STR_LIT>') + '<STR_LIT>' + watchers.nb;<EOL>    }<EOL>    return h('<STR_LIT>', { oncreate: helper.slidesInUp }, [<EOL>        h('<STR_LIT>', [<EOL>            h('<STR_LIT>', {<EOL>                oncreate: helper.ontap(helper.slidesOutDown(ctrl.close, '<STR_LIT>'))<EOL>            }, closeIcon),<EOL>            h('<STR_LIT>', header)<EOL>        ]),<EOL>        h('<STR_LIT>', [<EOL>            h('<STR_LIT>', {<EOL>                oncreate: ({ dom }: Mithril.DOMNode): void => scrollChatToBottom(dom as HTMLElement),<EOL>                onupdate: ({ dom }: Mithril.DOMNode): void => scrollChatToBottom(dom as HTMLElement)<EOL>            }, [<EOL>                h('<STR_LIT>', ctrl.selectLines().map((msg: ChatMsg, i: number, all: ChatMsg[]): Mithril.Vnode<any, any> => {<EOL>                    if (ctrl.root.data.player.spectator)<EOL>                        return spectatorChatRender(msg, i, all);<EOL>                    else<EOL>                        return playerChatRender(player, msg, i, all);<EOL>                }))<EOL>            ]),<EOL>            h('<STR_LIT>', {<EOL>                onsubmit: (e: Event): void => {<EOL>                    e.preventDefault();<EOL>                    const target: HTMLFormElement = (e.target as HTMLFormElement);<EOL>                    const ta: Element = target[<NUM_LIT>];<EOL>                    ta.focus();<EOL>                    const msg: any = ta.value.trim();<EOL>                    if (!validateMsg(msg))<EOL>                        return;<EOL>                    ctrl.inputValue = '<STR_LIT>';<EOL>                    ta.setAttribute('<STR_LIT>', '<STR_LIT>');<EOL>                    ta.style.paddingTop = '<STR_LIT>';<EOL>                    socket.send('<STR_LIT>', msg);<EOL>                    const sendButton: HTMLElement | null = document.getElementById('<STR_LIT>');<EOL>                    if (sendButton) {<EOL>                        sendButton.classList.add('<STR_LIT>');<EOL>                    }<EOL>                }<EOL>            }, [<EOL>                h('<STR_LIT>', {<EOL>                    placeholder: ctrl.canTalk(ctrl.root.data) ? i18n('<STR_LIT>') : '<STR_LIT>',<EOL>                    disabled: !ctrl.canTalk(ctrl.root.data),<EOL>                    rows: <NUM_LIT>,<EOL>                    maxlength: <NUM_LIT>,<EOL>                    value: ctrl.inputValue,<EOL>                    style: { lineHeight: '<STR_LIT>', margin: '<STR_LIT>', paddingTop: '<STR_LIT>' },<EOL>                    oninput(e: Event) {<EOL>                        const ta: HTMLTextAreaElement = (e.target as HTMLTextAreaElement);<EOL>                        if (ta.value.length > <NUM_LIT>)<EOL>                            ta.value = ta.value.substr(<NUM_LIT>, <NUM_LIT>);<EOL>                        ctrl.inputValue = ta.value;<EOL>                        const style: CSSStyleDeclaration = window.getComputedStyle(ta);<EOL>                        const taLineHeight: number = parseInt(style.lineHeight || '<STR_LIT>', <NUM_LIT>);<EOL>                        const taHeight: number = calculateContentHeight(","gt":"ta, taLineHeight);"}
{"input":"<s> export function chatView(ctrl: Chat): Mithril.Vnode<any, any> | null {<EOL>    if (!ctrl.showing)<EOL>        return null;<EOL>    const player: import(\"<STR_LIT>\").OnlinePlayer = ctrl.root.data.player;<EOL>    let header: string = (!ctrl.root.data.opponent.user || ctrl.root.data.player.spectator) ? i18n('<STR_LIT>') : ctrl.root.data.opponent.user.username;<EOL>    const watchers: import(\"<STR_LIT>\").GameWatchers | undefined = ctrl.root.data.watchers;<EOL>    if (ctrl.root.data.player.spectator && watchers && watchers.nb >= <NUM_LIT>) {<EOL>        header = i18n('<STR_LIT>') + '<STR_LIT>' + watchers.nb;<EOL>    }<EOL>    return h('<STR_LIT>', { oncreate: helper.slidesInUp }, [<EOL>        h('<STR_LIT>', [<EOL>            h('<STR_LIT>', {<EOL>                oncreate: helper.ontap(helper.slidesOutDown(ctrl.close, '<STR_LIT>'))<EOL>            }, closeIcon),<EOL>            h('<STR_LIT>', header)<EOL>        ]),<EOL>        h('<STR_LIT>', [<EOL>            h('<STR_LIT>', {<EOL>                oncreate: ({ dom }: Mithril.DOMNode): void => scrollChatToBottom(dom as HTMLElement),<EOL>                onupdate: ({ dom }: Mithril.DOMNode): void => scrollChatToBottom(dom as HTMLElement)<EOL>            }, [<EOL>                h('<STR_LIT>', ctrl.selectLines().map((msg: ChatMsg, i: number, all: ChatMsg[]): Mithril.Vnode<any, any> => {<EOL>                    if (ctrl.root.data.player.spectator)<EOL>                        return spectatorChatRender(msg, i, all);<EOL>                    else<EOL>                        return playerChatRender(player, msg, i, all);<EOL>                }))<EOL>            ]),<EOL>            h('<STR_LIT>', {<EOL>                onsubmit: (e: Event): void => {<EOL>                    e.preventDefault();<EOL>                    const target: HTMLFormElement = (e.target as HTMLFormElement);<EOL>                    const ta: Element = target[<NUM_LIT>];<EOL>                    ta.focus();<EOL>                    const msg: any = ta.value.trim();<EOL>                    if (!validateMsg(msg))<EOL>                        return;<EOL>                    ctrl.inputValue = '<STR_LIT>';<EOL>                    ta.setAttribute('<STR_LIT>', '<STR_LIT>');<EOL>                    ta.style.paddingTop = '<STR_LIT>';<EOL>                    socket.send('<STR_LIT>', msg);<EOL>                    const sendButton: HTMLElement | null = document.getElementById('<STR_LIT>');<EOL>                    if (sendButton) {<EOL>                        sendButton.classList.add('<STR_LIT>');<EOL>                    }<EOL>                }<EOL>            }, [<EOL>                h('<STR_LIT>', {<EOL>                    placeholder: ctrl.canTalk(ctrl.root.data) ? i18n('<STR_LIT>') : '<STR_LIT>',<EOL>                    disabled: !ctrl.canTalk(ctrl.root.data),<EOL>                    rows: <NUM_LIT>,<EOL>                    maxlength: <NUM_LIT>,<EOL>                    value: ctrl.inputValue,<EOL>                    style: { lineHeight: '<STR_LIT>', margin: '<STR_LIT>', paddingTop: '<STR_LIT>' },<EOL>                    oninput(e: Event) {<EOL>                        const ta: HTMLTextAreaElement = (e.target as HTMLTextAreaElement);<EOL>                        if (ta.value.length > <NUM_LIT>)<EOL>                            ta.value = ta.value.substr(<NUM_LIT>, <NUM_LIT>);<EOL>                        ctrl.inputValue = ta.value;<EOL>                        const style: CSSStyleDeclaration = window.getComputedStyle(ta);<EOL>                        const taLineHeight: number = parseInt(style.lineHeight || '<STR_LIT>', <NUM_LIT>);<EOL>                        const taHeight: number = calculateContentHeight(ta, taLineHeight);<EOL>                        const computedNbLines: number = Math.ceil(taHeight / taLineHeight);<EOL>                        const nbLines: number = computedNbLines <= <NUM_LIT> ? <NUM_LIT> :<EOL>                            computedNbLines > <NUM_LIT> ? <NUM_LIT> : computedNbLines - <NUM_LIT>;<EOL>                        ta.setAttribute('<STR_LIT>', String(nbLines));<EOL>                        if (nbLines === <NUM_LIT>)<EOL>                            ta.style.","gt":"paddingTop ="}
{"input":"<s> export function chatView(ctrl: Chat): Mithril.Vnode<any, any> | null {<EOL>    if (!ctrl.showing)<EOL>        return null;<EOL>    const player: import(\"<STR_LIT>\").OnlinePlayer = ctrl.root.data.player;<EOL>    let header: string = (!ctrl.root.data.opponent.user || ctrl.root.data.player.spectator) ? i18n('<STR_LIT>') : ctrl.root.data.opponent.user.username;<EOL>    const watchers: import(\"<STR_LIT>\").GameWatchers | undefined = ctrl.root.data.watchers;<EOL>    if (ctrl.root.data.player.spectator && watchers && watchers.nb >= <NUM_LIT>) {<EOL>        header = i18n('<STR_LIT>') + '<STR_LIT>' + watchers.nb;<EOL>    }<EOL>    return h('<STR_LIT>', { oncreate: helper.slidesInUp }, [<EOL>        h('<STR_LIT>', [<EOL>            h('<STR_LIT>', {<EOL>                oncreate: helper.ontap(helper.slidesOutDown(ctrl.close, '<STR_LIT>'))<EOL>            }, closeIcon),<EOL>            h('<STR_LIT>', header)<EOL>        ]),<EOL>        h('<STR_LIT>', [<EOL>            h('<STR_LIT>', {<EOL>                oncreate: ({ dom }: Mithril.DOMNode): void => scrollChatToBottom(dom as HTMLElement),<EOL>                onupdate: ({ dom }: Mithril.DOMNode): void => scrollChatToBottom(dom as HTMLElement)<EOL>            }, [<EOL>                h('<STR_LIT>', ctrl.selectLines().map((msg: ChatMsg, i: number, all: ChatMsg[]): Mithril.Vnode<any, any> => {<EOL>                    if (ctrl.root.data.player.spectator)<EOL>                        return spectatorChatRender(msg, i, all);<EOL>                    else<EOL>                        return playerChatRender(player, msg, i, all);<EOL>                }))<EOL>            ]),<EOL>            h('<STR_LIT>', {<EOL>                onsubmit: (e: Event): void => {<EOL>                    e.preventDefault();<EOL>                    const target: HTMLFormElement = (e.target as HTMLFormElement);<EOL>                    const ta: Element = target[<NUM_LIT>];<EOL>                    ta.focus();<EOL>                    const msg: any = ta.value.trim();<EOL>                    if (!validateMsg(msg))<EOL>                        return;<EOL>                    ctrl.inputValue = '<STR_LIT>';<EOL>                    ta.setAttribute('<STR_LIT>', '<STR_LIT>');<EOL>                    ta.style.paddingTop = '<STR_LIT>';<EOL>                    socket.send('<STR_LIT>', msg);<EOL>                    const sendButton: HTMLElement | null = document.getElementById('<STR_LIT>');<EOL>                    if (sendButton) {<EOL>                        sendButton.classList.add('<STR_LIT>');<EOL>                    }<EOL>                }<EOL>            }, [<EOL>                h('<STR_LIT>', {<EOL>                    placeholder: ctrl.canTalk(ctrl.root.data) ? i18n('<STR_LIT>') : '<STR_LIT>',<EOL>                    disabled: !ctrl.canTalk(ctrl.root.data),<EOL>                    rows: <NUM_LIT>,<EOL>                    maxlength: <NUM_LIT>,<EOL>                    value: ctrl.inputValue,<EOL>                    style: { lineHeight: '<STR_LIT>', margin: '<STR_LIT>', paddingTop: '<STR_LIT>' },<EOL>                    oninput(e: Event) {<EOL>                        const ta: HTMLTextAreaElement = (e.target as HTMLTextAreaElement);<EOL>                        if (ta.value.length > <NUM_LIT>)<EOL>                            ta.value = ta.value.substr(<NUM_LIT>, <NUM_LIT>);<EOL>                        ctrl.inputValue = ta.value;<EOL>                        const style: CSSStyleDeclaration = window.getComputedStyle(ta);<EOL>                        const taLineHeight: number = parseInt(style.lineHeight || '<STR_LIT>', <NUM_LIT>);<EOL>                        const taHeight: number = calculateContentHeight(ta, taLineHeight);<EOL>                        const computedNbLines: number = Math.ceil(taHeight / taLineHeight);<EOL>                        const nbLines: number = computedNbLines <= <NUM_LIT> ? <NUM_LIT> :<EOL>                            computedNbLines > <NUM_LIT> ? <NUM_LIT> : computedNbLines - <NUM_LIT>;<EOL>                        ta.setAttribute('<STR_LIT>', String(nbLines));<EOL>                        if (nbLines === <NUM_LIT>)<EOL>                            ta.style.paddingTop =","gt":"'<STR_LIT>';"}
{"input":"<s> export function chatView(ctrl: Chat): Mithril.Vnode<any, any> | null {<EOL>    if (!ctrl.showing)<EOL>        return null;<EOL>    const player: import(\"<STR_LIT>\").OnlinePlayer = ctrl.root.data.player;<EOL>    let header: string = (!ctrl.root.data.opponent.user || ctrl.root.data.player.spectator) ? i18n('<STR_LIT>') : ctrl.root.data.opponent.user.username;<EOL>    const watchers: import(\"<STR_LIT>\").GameWatchers | undefined = ctrl.root.data.watchers;<EOL>    if (ctrl.root.data.player.spectator && watchers && watchers.nb >= <NUM_LIT>) {<EOL>        header = i18n('<STR_LIT>') + '<STR_LIT>' + watchers.nb;<EOL>    }<EOL>    return h('<STR_LIT>', { oncreate: helper.slidesInUp }, [<EOL>        h('<STR_LIT>', [<EOL>            h('<STR_LIT>', {<EOL>                oncreate: helper.ontap(helper.slidesOutDown(ctrl.close, '<STR_LIT>'))<EOL>            }, closeIcon),<EOL>            h('<STR_LIT>', header)<EOL>        ]),<EOL>        h('<STR_LIT>', [<EOL>            h('<STR_LIT>', {<EOL>                oncreate: ({ dom }: Mithril.DOMNode): void => scrollChatToBottom(dom as HTMLElement),<EOL>                onupdate: ({ dom }: Mithril.DOMNode): void => scrollChatToBottom(dom as HTMLElement)<EOL>            }, [<EOL>                h('<STR_LIT>', ctrl.selectLines().map((msg: ChatMsg, i: number, all: ChatMsg[]): Mithril.Vnode<any, any> => {<EOL>                    if (ctrl.root.data.player.spectator)<EOL>                        return spectatorChatRender(msg, i, all);<EOL>                    else<EOL>                        return playerChatRender(player, msg, i, all);<EOL>                }))<EOL>            ]),<EOL>            h('<STR_LIT>', {<EOL>                onsubmit: (e: Event): void => {<EOL>                    e.preventDefault();<EOL>                    const target: HTMLFormElement = (e.target as HTMLFormElement);<EOL>                    const ta: Element = target[<NUM_LIT>];<EOL>                    ta.focus();<EOL>                    const msg: any = ta.value.trim();<EOL>                    if (!validateMsg(msg))<EOL>                        return;<EOL>                    ctrl.inputValue = '<STR_LIT>';<EOL>                    ta.setAttribute('<STR_LIT>', '<STR_LIT>');<EOL>                    ta.style.paddingTop = '<STR_LIT>';<EOL>                    socket.send('<STR_LIT>', msg);<EOL>                    const sendButton: HTMLElement | null = document.getElementById('<STR_LIT>');<EOL>                    if (sendButton) {<EOL>                        sendButton.classList.add('<STR_LIT>');<EOL>                    }<EOL>                }<EOL>            }, [<EOL>                h('<STR_LIT>', {<EOL>                    placeholder: ctrl.canTalk(ctrl.root.data) ? i18n('<STR_LIT>') : '<STR_LIT>',<EOL>                    disabled: !ctrl.canTalk(ctrl.root.data),<EOL>                    rows: <NUM_LIT>,<EOL>                    maxlength: <NUM_LIT>,<EOL>                    value: ctrl.inputValue,<EOL>                    style: { lineHeight: '<STR_LIT>', margin: '<STR_LIT>', paddingTop: '<STR_LIT>' },<EOL>                    oninput(e: Event) {<EOL>                        const ta: HTMLTextAreaElement = (e.target as HTMLTextAreaElement);<EOL>                        if (ta.value.length > <NUM_LIT>)<EOL>                            ta.value = ta.value.substr(<NUM_LIT>, <NUM_LIT>);<EOL>                        ctrl.inputValue = ta.value;<EOL>                        const style: CSSStyleDeclaration = window.getComputedStyle(ta);<EOL>                        const taLineHeight: number = parseInt(style.lineHeight || '<STR_LIT>', <NUM_LIT>);<EOL>                        const taHeight: number = calculateContentHeight(ta, taLineHeight);<EOL>                        const computedNbLines: number = Math.ceil(taHeight / taLineHeight);<EOL>                        const nbLines: number = computedNbLines <= <NUM_LIT> ? <NUM_LIT> :<EOL>                            computedNbLines > <NUM_LIT> ? <NUM_LIT> : computedNbLines - <NUM_LIT>;<EOL>                        ta.setAttribute('<STR_LIT>', String(nbLines));<EOL>                        if (nbLines === <NUM_LIT>)<EOL>                            ta.style.paddingTop = '<STR_LIT>';<EOL>                        else<EOL>                            ta.style.paddingTop = '<STR_LIT>';<EOL>                        const sendButton: HTMLElement | null = document.getElementById('<STR_LIT>');<EOL>","gt":"if (sendButton) {"}
{"input":"<s> export function chatView(ctrl: Chat): Mithril.Vnode<any, any> | null {<EOL>    if (!ctrl.showing)<EOL>        return null;<EOL>    const player: import(\"<STR_LIT>\").OnlinePlayer = ctrl.root.data.player;<EOL>    let header: string = (!ctrl.root.data.opponent.user || ctrl.root.data.player.spectator) ? i18n('<STR_LIT>') : ctrl.root.data.opponent.user.username;<EOL>    const watchers: import(\"<STR_LIT>\").GameWatchers | undefined = ctrl.root.data.watchers;<EOL>    if (ctrl.root.data.player.spectator && watchers && watchers.nb >= <NUM_LIT>) {<EOL>        header = i18n('<STR_LIT>') + '<STR_LIT>' + watchers.nb;<EOL>    }<EOL>    return h('<STR_LIT>', { oncreate: helper.slidesInUp }, [<EOL>        h('<STR_LIT>', [<EOL>            h('<STR_LIT>', {<EOL>                oncreate: helper.ontap(helper.slidesOutDown(ctrl.close, '<STR_LIT>'))<EOL>            }, closeIcon),<EOL>            h('<STR_LIT>', header)<EOL>        ]),<EOL>        h('<STR_LIT>', [<EOL>            h('<STR_LIT>', {<EOL>                oncreate: ({ dom }: Mithril.DOMNode): void => scrollChatToBottom(dom as HTMLElement),<EOL>                onupdate: ({ dom }: Mithril.DOMNode): void => scrollChatToBottom(dom as HTMLElement)<EOL>            }, [<EOL>                h('<STR_LIT>', ctrl.selectLines().map((msg: ChatMsg, i: number, all: ChatMsg[]): Mithril.Vnode<any, any> => {<EOL>                    if (ctrl.root.data.player.spectator)<EOL>                        return spectatorChatRender(msg, i, all);<EOL>                    else<EOL>                        return playerChatRender(player, msg, i, all);<EOL>                }))<EOL>            ]),<EOL>            h('<STR_LIT>', {<EOL>                onsubmit: (e: Event): void => {<EOL>                    e.preventDefault();<EOL>                    const target: HTMLFormElement = (e.target as HTMLFormElement);<EOL>                    const ta: Element = target[<NUM_LIT>];<EOL>                    ta.focus();<EOL>                    const msg: any = ta.value.trim();<EOL>                    if (!validateMsg(msg))<EOL>                        return;<EOL>                    ctrl.inputValue = '<STR_LIT>';<EOL>                    ta.setAttribute('<STR_LIT>', '<STR_LIT>');<EOL>                    ta.style.paddingTop = '<STR_LIT>';<EOL>                    socket.send('<STR_LIT>', msg);<EOL>                    const sendButton: HTMLElement | null = document.getElementById('<STR_LIT>');<EOL>                    if (sendButton) {<EOL>                        sendButton.classList.add('<STR_LIT>');<EOL>                    }<EOL>                }<EOL>            }, [<EOL>                h('<STR_LIT>', {<EOL>                    placeholder: ctrl.canTalk(ctrl.root.data) ? i18n('<STR_LIT>') : '<STR_LIT>',<EOL>                    disabled: !ctrl.canTalk(ctrl.root.data),<EOL>                    rows: <NUM_LIT>,<EOL>                    maxlength: <NUM_LIT>,<EOL>                    value: ctrl.inputValue,<EOL>                    style: { lineHeight: '<STR_LIT>', margin: '<STR_LIT>', paddingTop: '<STR_LIT>' },<EOL>                    oninput(e: Event) {<EOL>                        const ta: HTMLTextAreaElement = (e.target as HTMLTextAreaElement);<EOL>                        if (ta.value.length > <NUM_LIT>)<EOL>                            ta.value = ta.value.substr(<NUM_LIT>, <NUM_LIT>);<EOL>                        ctrl.inputValue = ta.value;<EOL>                        const style: CSSStyleDeclaration = window.getComputedStyle(ta);<EOL>                        const taLineHeight: number = parseInt(style.lineHeight || '<STR_LIT>', <NUM_LIT>);<EOL>                        const taHeight: number = calculateContentHeight(ta, taLineHeight);<EOL>                        const computedNbLines: number = Math.ceil(taHeight / taLineHeight);<EOL>                        const nbLines: number = computedNbLines <= <NUM_LIT> ? <NUM_LIT> :<EOL>                            computedNbLines > <NUM_LIT> ? <NUM_LIT> : computedNbLines - <NUM_LIT>;<EOL>                        ta.setAttribute('<STR_LIT>', String(nbLines));<EOL>                        if (nbLines === <NUM_LIT>)<EOL>                            ta.style.paddingTop = '<STR_LIT>';<EOL>                        else<EOL>                            ta.style.paddingTop = '<STR_LIT>';<EOL>                        const sendButton: HTMLElement | null = document.getElementById('<STR_LIT>');<EOL>                        if (sendButton) {<EOL>","gt":"if (validateMsg(ctrl.inputValue))"}
{"input":"<s> export function chatView(ctrl: Chat): Mithril.Vnode<any, any> | null {<EOL>    if (!ctrl.showing)<EOL>        return null;<EOL>    const player: import(\"<STR_LIT>\").OnlinePlayer = ctrl.root.data.player;<EOL>    let header: string = (!ctrl.root.data.opponent.user || ctrl.root.data.player.spectator) ? i18n('<STR_LIT>') : ctrl.root.data.opponent.user.username;<EOL>    const watchers: import(\"<STR_LIT>\").GameWatchers | undefined = ctrl.root.data.watchers;<EOL>    if (ctrl.root.data.player.spectator && watchers && watchers.nb >= <NUM_LIT>) {<EOL>        header = i18n('<STR_LIT>') + '<STR_LIT>' + watchers.nb;<EOL>    }<EOL>    return h('<STR_LIT>', { oncreate: helper.slidesInUp }, [<EOL>        h('<STR_LIT>', [<EOL>            h('<STR_LIT>', {<EOL>                oncreate: helper.ontap(helper.slidesOutDown(ctrl.close, '<STR_LIT>'))<EOL>            }, closeIcon),<EOL>            h('<STR_LIT>', header)<EOL>        ]),<EOL>        h('<STR_LIT>', [<EOL>            h('<STR_LIT>', {<EOL>                oncreate: ({ dom }: Mithril.DOMNode): void => scrollChatToBottom(dom as HTMLElement),<EOL>                onupdate: ({ dom }: Mithril.DOMNode): void => scrollChatToBottom(dom as HTMLElement)<EOL>            }, [<EOL>                h('<STR_LIT>', ctrl.selectLines().map((msg: ChatMsg, i: number, all: ChatMsg[]): Mithril.Vnode<any, any> => {<EOL>                    if (ctrl.root.data.player.spectator)<EOL>                        return spectatorChatRender(msg, i, all);<EOL>                    else<EOL>                        return playerChatRender(player, msg, i, all);<EOL>                }))<EOL>            ]),<EOL>            h('<STR_LIT>', {<EOL>                onsubmit: (e: Event): void => {<EOL>                    e.preventDefault();<EOL>                    const target: HTMLFormElement = (e.target as HTMLFormElement);<EOL>                    const ta: Element = target[<NUM_LIT>];<EOL>                    ta.focus();<EOL>                    const msg: any = ta.value.trim();<EOL>                    if (!validateMsg(msg))<EOL>                        return;<EOL>                    ctrl.inputValue = '<STR_LIT>';<EOL>                    ta.setAttribute('<STR_LIT>', '<STR_LIT>');<EOL>                    ta.style.paddingTop = '<STR_LIT>';<EOL>                    socket.send('<STR_LIT>', msg);<EOL>                    const sendButton: HTMLElement | null = document.getElementById('<STR_LIT>');<EOL>                    if (sendButton) {<EOL>                        sendButton.classList.add('<STR_LIT>');<EOL>                    }<EOL>                }<EOL>            }, [<EOL>                h('<STR_LIT>', {<EOL>                    placeholder: ctrl.canTalk(ctrl.root.data) ? i18n('<STR_LIT>') : '<STR_LIT>',<EOL>                    disabled: !ctrl.canTalk(ctrl.root.data),<EOL>                    rows: <NUM_LIT>,<EOL>                    maxlength: <NUM_LIT>,<EOL>                    value: ctrl.inputValue,<EOL>                    style: { lineHeight: '<STR_LIT>', margin: '<STR_LIT>', paddingTop: '<STR_LIT>' },<EOL>                    oninput(e: Event) {<EOL>                        const ta: HTMLTextAreaElement = (e.target as HTMLTextAreaElement);<EOL>                        if (ta.value.length > <NUM_LIT>)<EOL>                            ta.value = ta.value.substr(<NUM_LIT>, <NUM_LIT>);<EOL>                        ctrl.inputValue = ta.value;<EOL>                        const style: CSSStyleDeclaration = window.getComputedStyle(ta);<EOL>                        const taLineHeight: number = parseInt(style.lineHeight || '<STR_LIT>', <NUM_LIT>);<EOL>                        const taHeight: number = calculateContentHeight(ta, taLineHeight);<EOL>                        const computedNbLines: number = Math.ceil(taHeight / taLineHeight);<EOL>                        const nbLines: number = computedNbLines <= <NUM_LIT> ? <NUM_LIT> :<EOL>                            computedNbLines > <NUM_LIT> ? <NUM_LIT> : computedNbLines - <NUM_LIT>;<EOL>                        ta.setAttribute('<STR_LIT>', String(nbLines));<EOL>                        if (nbLines === <NUM_LIT>)<EOL>                            ta.style.paddingTop = '<STR_LIT>';<EOL>                        else<EOL>                            ta.style.paddingTop = '<STR_LIT>';<EOL>                        const sendButton: HTMLElement | null = document.getElementById('<STR_LIT>');<EOL>                        if (sendButton) {<EOL>                            if (validateMsg(ctrl.inputValue))<EOL>                                sendButton.classList.remove('<STR_LIT>');<EOL>","gt":"else"}
{"input":"<s> export function syncNote(gameId: string, notes: string): Promise<string> {<EOL>    return fetchText(`<STR_LIT>`, {<EOL>        method: '<STR_LIT>',<EOL>        headers: {<EOL>","gt":"'<STR_LIT>': '<STR_LIT>',"}
{"input":"<s> export function syncNote(gameId: string, notes: string): Promise<string> {<EOL>    return fetchText(`<STR_LIT>`, {<EOL>        method: '<STR_LIT>',<EOL>        headers: {<EOL>            '<STR_LIT>': '<STR_LIT>',<EOL>            '<STR_LIT>': '<STR_LIT>'<EOL>        },<EOL>        body: serializeQueryParameters({ text: notes })<EOL>    }, false)<EOL>        .catch((err: any): never => {<EOL>        window.plugins.toast.","gt":"show(i18n('<STR_LIT>'), '<STR_LIT>', '<STR_LIT>');"}
{"input":"<s> function open(): void {<EOL>    router.backbutton.stack.push(helper.","gt":"slidesOutDown(close, '<STR_LIT>'));"}
{"input":"<s> export default function makeConfig(ctrl: TrainingCtrl, userMove: (orig: Key, dest: Key) => void): cg.InitConfig {<EOL>    return {<EOL>        batchRAF: batchRequestAnimationFrame,<EOL>        fen:","gt":"ctrl.data.puzzle.fen,"}
{"input":"<s> export default function makeConfig(ctrl: TrainingCtrl, userMove: (orig: Key, dest: Key) => void): cg.InitConfig {<EOL>    return {<EOL>        batchRAF: batchRequestAnimationFrame,<EOL>        fen: ctrl.data.puzzle.fen,<EOL>        orientation: ctrl.data.puzzle.color,<EOL>        coordinates: settings.game.coords(),<EOL>        turnColor: ctrl.node.ply % <NUM_LIT> === <NUM_LIT> ?","gt":"'<STR_LIT>' : '<STR_LIT>',"}
{"input":"<s> export default function makeConfig(ctrl: TrainingCtrl, userMove: (orig: Key, dest: Key) => void): cg.InitConfig {<EOL>    return {<EOL>        batchRAF: batchRequestAnimationFrame,<EOL>        fen: ctrl.data.puzzle.fen,<EOL>        orientation: ctrl.data.puzzle.color,<EOL>        coordinates: settings.game.coords(),<EOL>        turnColor: ctrl.node.ply % <NUM_LIT> === <NUM_LIT> ? '<STR_LIT>' : '<STR_LIT>',<EOL>        highlight: {<EOL>            lastMove: settings.game.highlights(),<EOL>            check: settings.game.highlights()<EOL>        },<EOL>        movable: {<EOL>            free: false,<EOL>","gt":"color: ctrl.data.puzzle.color,"}
{"input":"<s> export default function makeConfig(ctrl: TrainingCtrl, userMove: (orig: Key, dest: Key) => void): cg.InitConfig {<EOL>    return {<EOL>        batchRAF: batchRequestAnimationFrame,<EOL>        fen: ctrl.data.puzzle.fen,<EOL>        orientation: ctrl.data.puzzle.color,<EOL>        coordinates: settings.game.coords(),<EOL>        turnColor: ctrl.node.ply % <NUM_LIT> === <NUM_LIT> ? '<STR_LIT>' : '<STR_LIT>',<EOL>        highlight: {<EOL>            lastMove: settings.game.highlights(),<EOL>            check: settings.game.highlights()<EOL>        },<EOL>        movable: {<EOL>            free: false,<EOL>            color: ctrl.data.puzzle.color,<EOL>            showDests: settings.game.pieceDestinations()<EOL>        },<EOL>        events: {<EOL>","gt":"move: userMove"}
{"input":"<s> <EOL>export function nbRemainingPuzzles(database: Database, user: Session): Promise<number> {<EOL>    return database.fetch(","gt":"user.id)"}
{"input":"<s> export function readDests(lines?: DestsMap | string): DestsMap | null {<EOL>    if (lines === undefined)<EOL>        return null;<EOL>    if (isDestMap(lines))<EOL>        return","gt":"lines;"}
{"input":"<s> export function readDests(lines?: DestsMap | string): DestsMap | null {<EOL>    if (lines === undefined)<EOL>        return null;<EOL>    if (isDestMap(lines))<EOL>        return lines;<EOL>    const dests: DestsMap = {};<EOL>    if (lines && isString(lines))<EOL>        lines.split('<STR_LIT>').forEach((line: string): void => {<EOL>            dests[piotr2key[line[<NUM_LIT>]]] = line.split('<STR_LIT>').slice(<NUM_LIT>).map((","gt":"c: string): string => piotr2key[c]);"}
{"input":"<s> function linkReplace(match: string, before: string, url: string): string {<EOL>    if (url.indexOf('<STR_LIT>') !== -<NUM_LIT>)<EOL>","gt":"return match;"}
{"input":"<s> export function hasNetwork(): boolean {<EOL>    return window.navigator.connection.type !== Connection.","gt":"NONE;"}
{"input":"<s> export function lichessAssetSrc(path: string): string {<EOL>    return","gt":"apiEndPoint}/assets/${path}`<STR_LIT>;"}
{"input":"<s> function idleTimer(delay: number, onIdle: () => void, onWakeUp: () => void): () => void {<EOL>    const events: string[] = ['<STR_LIT>'];<EOL>    let listening: boolean = false;<EOL>    let active: boolean = true;<EOL>    let lastSeenActive:","gt":"number = Date.now();"}
{"input":"<s> function idleTimer(delay: number, onIdle: () => void, onWakeUp: () => void): () => void {<EOL>    const events: string[] = ['<STR_LIT>'];<EOL>    let listening: boolean = false;<EOL>    let active: boolean = true;<EOL>    let lastSeenActive: number = Date.now();<EOL>    let intervalID: number;<EOL>    const","gt":"onActivity: () => void = (): void => {"}
{"input":"<s> function idleTimer(delay: number, onIdle: () => void, onWakeUp: () => void): () => void {<EOL>    const events: string[] = ['<STR_LIT>'];<EOL>    let listening: boolean = false;<EOL>    let active: boolean = true;<EOL>    let lastSeenActive: number = Date.now();<EOL>    let intervalID: number;<EOL>    const onActivity: () => void = (): void => {<EOL>        if (!active) {<EOL>            <EOL>            onWakeUp();<EOL>        }<EOL>        active = true;<EOL>        lastSeenActive = Date.now();<EOL>        stopListening();<EOL>    };<EOL>    const startListening: () => void = (): void => {<EOL>        if (!listening) {<EOL>            events.forEach((e: string): void => {<EOL>                document.addEventListener(","gt":"e, onActivity);"}
{"input":"<s> function idleTimer(delay: number, onIdle: () => void, onWakeUp: () => void): () => void {<EOL>    const events: string[] = ['<STR_LIT>'];<EOL>    let listening: boolean = false;<EOL>    let active: boolean = true;<EOL>    let lastSeenActive: number = Date.now();<EOL>    let intervalID: number;<EOL>    const onActivity: () => void = (): void => {<EOL>        if (!active) {<EOL>            <EOL>            onWakeUp();<EOL>        }<EOL>        active = true;<EOL>        lastSeenActive = Date.now();<EOL>        stopListening();<EOL>    };<EOL>    const startListening: () => void = (): void => {<EOL>        if (!listening) {<EOL>            events.forEach((e: string): void => {<EOL>                document.addEventListener(e, onActivity);<EOL>            });<EOL>            listening = true;<EOL>        }<EOL>    };<EOL>    const stopListening: () => void = (): void => {<EOL>","gt":"if (listening) {"}
{"input":"<s> function idleTimer(delay: number, onIdle: () => void, onWakeUp: () => void): () => void {<EOL>    const events: string[] = ['<STR_LIT>'];<EOL>    let listening: boolean = false;<EOL>    let active: boolean = true;<EOL>    let lastSeenActive: number = Date.now();<EOL>    let intervalID: number;<EOL>    const onActivity: () => void = (): void => {<EOL>        if (!active) {<EOL>            <EOL>            onWakeUp();<EOL>        }<EOL>        active = true;<EOL>        lastSeenActive = Date.now();<EOL>        stopListening();<EOL>    };<EOL>    const startListening: () => void = (): void => {<EOL>        if (!listening) {<EOL>            events.forEach((e: string): void => {<EOL>                document.addEventListener(e, onActivity);<EOL>            });<EOL>            listening = true;<EOL>        }<EOL>    };<EOL>    const stopListening: () => void = (): void => {<EOL>        if (listening) {<EOL>            events.forEach((e: string): void => {<EOL>                document.removeEventListener(e, onActivity);<EOL>            });<EOL>            listening = false;<EOL>        }<EOL>    };<EOL>    const cancel: () => void = (): void => {<EOL>        clearInterval(","gt":"intervalID);"}
{"input":"<s> function idleTimer(delay: number, onIdle: () => void, onWakeUp: () => void): () => void {<EOL>    const events: string[] = ['<STR_LIT>'];<EOL>    let listening: boolean = false;<EOL>    let active: boolean = true;<EOL>    let lastSeenActive: number = Date.now();<EOL>    let intervalID: number;<EOL>    const onActivity: () => void = (): void => {<EOL>        if (!active) {<EOL>            <EOL>            onWakeUp();<EOL>        }<EOL>        active = true;<EOL>        lastSeenActive = Date.now();<EOL>        stopListening();<EOL>    };<EOL>    const startListening: () => void = (): void => {<EOL>        if (!listening) {<EOL>            events.forEach((e: string): void => {<EOL>                document.addEventListener(e, onActivity);<EOL>            });<EOL>            listening = true;<EOL>        }<EOL>    };<EOL>    const stopListening: () => void = (): void => {<EOL>        if (listening) {<EOL>            events.forEach((e: string): void => {<EOL>                document.removeEventListener(e, onActivity);<EOL>            });<EOL>            listening = false;<EOL>        }<EOL>    };<EOL>    const cancel: () => void = (): void => {<EOL>        clearInterval(intervalID);<EOL>        stopListening();<EOL>    };<EOL>    intervalID = setInterval((): void => {<EOL>","gt":"if (active && Date.now() - lastSeenActive > delay) {"}
{"input":"<s> export default function getDefaultConfig(resourceName: string): Config {<EOL>    return {<EOL>","gt":"key: \"<STR_LIT>\","}
{"input":"<s> function getValid(): {<EOL>    id: number;<EOL>    name: string;<EOL>} {<EOL>    return {<EOL>        id:","gt":"<NUM_LIT>,"}
{"input":"<s> export default function makeScope(config: Config, reducerName: ReducerName): string {<EOL>    return","gt":"config.resourceName + \"<STR_LIT>\" + reducerName;"}
{"input":"<s> function generateRandomNum(): string {<EOL>    return (","gt":"Math.floor(new Date().getTime() + Math.random() * <NUM_LIT>)).toString();"}
{"input":"<s> function retain(obj: any, attr: string[]): any {<EOL>    const newObj: any = Object.create(null);<EOL>    for (const item: string in obj) {<EOL>        if (obj.hasOwnProperty(item)) {<EOL>            const arrAttr:","gt":"string[] = Array.isArray(attr) ? attr : [attr];"}
{"input":"<s> function generateRandomNum(): string {<EOL>    return (Math.","gt":"floor(new Date().getTime() + Math.random() * <NUM_LIT>)).toString();"}
{"input":"<s> function setPolarCoord(chart: any, coord: any): any {<EOL>    let newCoord: {} = {};<EOL>    if (coord.radius && (coord.radius < <NUM_LIT> || coord.radius > <NUM_LIT>) ||<EOL>        coord.innerRadius && (coord.innerRadius < <NUM_LIT> || coord.innerRadius > <NUM_LIT>)) {<EOL>        throw new Error(","gt":"'<STR_LIT>');"}
{"input":"<s> function setPolarCoord(chart: any, coord: any): any {<EOL>    let newCoord: {} = {};<EOL>    if (coord.radius && (coord.radius < <NUM_LIT> || coord.radius > <NUM_LIT>) ||<EOL>        coord.innerRadius && (coord.innerRadius < <NUM_LIT> || coord.innerRadius > <NUM_LIT>)) {<EOL>        throw new Error('<STR_LIT>');<EOL>    }<EOL>","gt":"if (coord.radius) {"}
{"input":"<s> function setPolarCoord(chart: any, coord: any): any {<EOL>    let newCoord: {} = {};<EOL>    if (coord.radius && (coord.radius < <NUM_LIT> || coord.radius > <NUM_LIT>) ||<EOL>        coord.innerRadius && (coord.innerRadius < <NUM_LIT> || coord.innerRadius > <NUM_LIT>)) {<EOL>        throw new Error('<STR_LIT>');<EOL>    }<EOL>    if (coord.radius) {<EOL>        newCoord = { ...newCoord, radius: coord.radius };<EOL>    }<EOL>    if (coord.innerRadius) {<EOL>        newCoord = { ...newCoord,","gt":"innerRadius: coord.innerRadius };"}
{"input":"<s> function setPolarCoord(chart: any, coord: any): any {<EOL>    let newCoord: {} = {};<EOL>    if (coord.radius && (coord.radius < <NUM_LIT> || coord.radius > <NUM_LIT>) ||<EOL>        coord.innerRadius && (coord.innerRadius < <NUM_LIT> || coord.innerRadius > <NUM_LIT>)) {<EOL>        throw new Error('<STR_LIT>');<EOL>    }<EOL>    if (coord.radius) {<EOL>        newCoord = { ...newCoord, radius: coord.radius };<EOL>    }<EOL>    if (coord.innerRadius) {<EOL>        newCoord = { ...newCoord, innerRadius: coord.innerRadius };<EOL>    }<EOL>    if (coord.startAngle || coord.endAngle) {<EOL>        if (coord.startAngle && (coord.startAngle < -<NUM_LIT> || coord.startAngle > <NUM_LIT>)) {<EOL>            throw new Error('<STR_LIT>');<EOL>        }<EOL>        else {<EOL>            newCoord = {<EOL>                ...newCoord,<EOL>                startAngle: degreeToRadian(coord.startAngle),<EOL>            };<EOL>        }<EOL>        if (coord.endAngle && (coord.endAngle < -<NUM_LIT> || coord.endAngle > <NUM_LIT>)) {<EOL>            throw new Error('<STR_LIT>');<EOL>        }<EOL>        else {<EOL>            newCoord = {<EOL>                ...newCoord,<EOL>                endAngle: degreeToRadian(coord.endAngle),<EOL>            };<EOL>        }<EOL>    }<EOL>    const polarCoord: any = chart.coord(coord.type, { ...newCoord });<EOL>    switch (coord.direction) {<EOL>        case '<STR_LIT>':<EOL>            polarCoord.transpose();<EOL>            break;<EOL>","gt":"case '<STR_LIT>':"}
{"input":"<s> function setPolarCoord(chart: any, coord: any): any {<EOL>    let newCoord: {} = {};<EOL>    if (coord.radius && (coord.radius < <NUM_LIT> || coord.radius > <NUM_LIT>) ||<EOL>        coord.innerRadius && (coord.innerRadius < <NUM_LIT> || coord.innerRadius > <NUM_LIT>)) {<EOL>        throw new Error('<STR_LIT>');<EOL>    }<EOL>    if (coord.radius) {<EOL>        newCoord = { ...newCoord, radius: coord.radius };<EOL>    }<EOL>    if (coord.innerRadius) {<EOL>        newCoord = { ...newCoord, innerRadius: coord.innerRadius };<EOL>    }<EOL>    if (coord.startAngle || coord.endAngle) {<EOL>        if (coord.startAngle && (coord.startAngle < -<NUM_LIT> || coord.startAngle > <NUM_LIT>)) {<EOL>            throw new Error('<STR_LIT>');<EOL>        }<EOL>        else {<EOL>            newCoord = {<EOL>                ...newCoord,<EOL>                startAngle: degreeToRadian(coord.startAngle),<EOL>            };<EOL>        }<EOL>        if (coord.endAngle && (coord.endAngle < -<NUM_LIT> || coord.endAngle > <NUM_LIT>)) {<EOL>            throw new Error('<STR_LIT>');<EOL>        }<EOL>        else {<EOL>            newCoord = {<EOL>                ...newCoord,<EOL>                endAngle: degreeToRadian(coord.endAngle),<EOL>            };<EOL>        }<EOL>    }<EOL>    const polarCoord: any = chart.coord(coord.type, { ...newCoord });<EOL>    switch (coord.direction) {<EOL>        case '<STR_LIT>':<EOL>            polarCoord.transpose();<EOL>            break;<EOL>        case '<STR_LIT>':<EOL>            polarCoord.reflect('<STR_LIT>');<EOL>            break;<EOL>        case '<STR_LIT>':<EOL>            polarCoord.reflect(","gt":"'<STR_LIT>');"}
{"input":"<s> function setSeriesAdjust(chart: any, currSeries: ISeries): any {<EOL>    const adjust: string | string[] | object[] = currSeries.adjust;<EOL>","gt":"if (!_.isNil(adjust)) {"}
{"input":"<s> export function weatherReducer(state: IWeather, action: Actions): IWeather {<EOL>    switch (action.type) {<EOL>        case WEATHER_GET:<EOL>            return Object.assign({}, state, {<EOL>","gt":"isFetching: true,"}
{"input":"<s> export function weatherReducer(state: IWeather, action: Actions): IWeather {<EOL>    switch (action.type) {<EOL>        case WEATHER_GET:<EOL>            return Object.assign({}, state, {<EOL>                isFetching: true,<EOL>                airQualityError:","gt":"false,"}
{"input":"<s> export function weatherReducer(state: IWeather, action: Actions): IWeather {<EOL>    switch (action.type) {<EOL>        case WEATHER_GET:<EOL>            return Object.assign({}, state, {<EOL>                isFetching: true,<EOL>                airQualityError: false,<EOL>                dataError: false,<EOL>                forecastError:","gt":"false"}
{"input":"<s> export function weatherReducer(state: IWeather, action: Actions): IWeather {<EOL>    switch (action.type) {<EOL>        case WEATHER_GET:<EOL>            return Object.assign({}, state, {<EOL>                isFetching: true,<EOL>                airQualityError: false,<EOL>                dataError: false,<EOL>                forecastError: false<EOL>            });<EOL>        case AIR_QUALITY_GET_SUCCESS:<EOL>            return Object.assign({}, state, {<EOL>                airQuality: action.payload<EOL>            });<EOL>","gt":"case AIR_QUALITY_GET_FAIL:"}
{"input":"<s> export function weatherReducer(state: IWeather, action: Actions): IWeather {<EOL>    switch (action.type) {<EOL>        case WEATHER_GET:<EOL>            return Object.assign({}, state, {<EOL>                isFetching: true,<EOL>                airQualityError: false,<EOL>                dataError: false,<EOL>                forecastError: false<EOL>            });<EOL>        case AIR_QUALITY_GET_SUCCESS:<EOL>            return Object.assign({}, state, {<EOL>                airQuality: action.payload<EOL>            });<EOL>        case AIR_QUALITY_GET_FAIL:<EOL>            return Object.assign({}, state, {<EOL>                airQualityError: true<EOL>            });<EOL>","gt":"case WEATHER_GET_SUCCESS:"}
{"input":"<s> export function weatherReducer(state: IWeather, action: Actions): IWeather {<EOL>    switch (action.type) {<EOL>        case WEATHER_GET:<EOL>            return Object.assign({}, state, {<EOL>                isFetching: true,<EOL>                airQualityError: false,<EOL>                dataError: false,<EOL>                forecastError: false<EOL>            });<EOL>        case AIR_QUALITY_GET_SUCCESS:<EOL>            return Object.assign({}, state, {<EOL>                airQuality: action.payload<EOL>            });<EOL>        case AIR_QUALITY_GET_FAIL:<EOL>            return Object.assign({}, state, {<EOL>                airQualityError: true<EOL>            });<EOL>        case WEATHER_GET_SUCCESS:<EOL>            return Object.assign({}, state, {<EOL>                data: action.payload<EOL>            });<EOL>        case WEATHER_GET_FAIL:<EOL>            return Object.","gt":"assign({}, state, {"}
{"input":"<s> export function weatherReducer(state: IWeather, action: Actions): IWeather {<EOL>    switch (action.type) {<EOL>        case WEATHER_GET:<EOL>            return Object.assign({}, state, {<EOL>                isFetching: true,<EOL>                airQualityError: false,<EOL>                dataError: false,<EOL>                forecastError: false<EOL>            });<EOL>        case AIR_QUALITY_GET_SUCCESS:<EOL>            return Object.assign({}, state, {<EOL>                airQuality: action.payload<EOL>            });<EOL>        case AIR_QUALITY_GET_FAIL:<EOL>            return Object.assign({}, state, {<EOL>                airQualityError: true<EOL>            });<EOL>        case WEATHER_GET_SUCCESS:<EOL>            return Object.assign({}, state, {<EOL>                data: action.payload<EOL>            });<EOL>        case WEATHER_GET_FAIL:<EOL>            return Object.assign({}, state, {<EOL>                dataError: true<EOL>            });<EOL>        case WEATHER_DATA_GET_SUCCESS:<EOL>            return Object.assign({}, state, {<EOL>                forecast: action.payload,<EOL>                isFetching: false<EOL>            });<EOL>        case WEATHER_DATA_GET_FAIL:<EOL>            return Object.","gt":"assign({}, state, {"}
{"input":"<s> export default function (): void {<EOL>    describe(\"<STR_LIT>\", (): void => {<EOL>        let buttonInGroupService: ButtonInGroupService;<EOL>        beforeEach((): void => {<EOL>            buttonInGroupService = new ButtonInGroupService();<EOL>        });<EOL>","gt":"it(\"<STR_LIT>\", (): void => {"}
{"input":"<s> export default function (): void {<EOL>    describe(\"<STR_LIT>\", (): void => {<EOL>        let buttonInGroupService: ButtonInGroupService;<EOL>        beforeEach((): void => {<EOL>            buttonInGroupService = new ButtonInGroupService();<EOL>        });<EOL>        it(\"<STR_LIT>\", (): void => {<EOL>            let testButton: any;<EOL>            buttonInGroupService.changes.subscribe((button: any): void => {<EOL>                testButton = button;<EOL>            });<EOL>            const mockButton: ClrButton = new ClrButton(null);<EOL>            mockButton.inMenu = true;<EOL>            buttonInGroupService.","gt":"updateButtonGroup(mockButton);"}
{"input":"<s> export default function (): void {<EOL>    describe(\"<STR_LIT>\", function () {<EOL>        beforeEach(function (this: UserContext) {<EOL>            this.domAdapter =","gt":"new DomAdapter();"}
{"input":"<s> export default function (): void {<EOL>    describe(\"<STR_LIT>\", function () {<EOL>        beforeEach(function (this: UserContext) {<EOL>            this.domAdapter = new DomAdapter();<EOL>            this.element = document.createElement(\"<STR_LIT>\");<EOL>            this.element.appendChild(document.","gt":"createTextNode(\"<STR_LIT>\"));"}
{"input":"<s> export default function (): void {<EOL>    describe(\"<STR_LIT>\", function () {<EOL>        beforeEach(function (this: UserContext) {<EOL>            this.domAdapter = new DomAdapter();<EOL>            this.element = document.createElement(\"<STR_LIT>\");<EOL>            this.element.appendChild(document.createTextNode(\"<STR_LIT>\"));<EOL>            document.body.appendChild(this.element);<EOL>        });<EOL>        afterEach(function (this: UserContext) {<EOL>            document.body.removeChild(this.element);<EOL>        });<EOL>","gt":"it(\"<STR_LIT>\", function (this: UserContext) {"}
{"input":"<s> export default function (): void {<EOL>    describe(\"<STR_LIT>\", function () {<EOL>        beforeEach(function (this: UserContext) {<EOL>            this.domAdapter = new DomAdapter();<EOL>            this.element = document.createElement(\"<STR_LIT>\");<EOL>            this.element.appendChild(document.createTextNode(\"<STR_LIT>\"));<EOL>            document.body.appendChild(this.element);<EOL>        });<EOL>        afterEach(function (this: UserContext) {<EOL>            document.body.removeChild(this.element);<EOL>        });<EOL>        it(\"<STR_LIT>\", function (this: UserContext) {<EOL>            const child: HTMLDivElement = document.createElement(\"<STR_LIT>\");<EOL>            child.style.width = \"<STR_LIT>\";<EOL>            child.style.height = \"<STR_LIT>\";<EOL>            this.element.appendChild(child);<EOL>            expect(this.domAdapter.scrollWidth(this.element)).toBe(<NUM_LIT>);<EOL>        });<EOL>        it(\"<STR_LIT>\", function (this: UserContext) {<EOL>            expect(this.domAdapter.scrollBarWidth(this.element)).toBe(<NUM_LIT>);<EOL>            this.element.style.overflow = \"<STR_LIT>\";<EOL>            <EOL>            <EOL>            if (/PhantomJS/.test(","gt":"window.navigator.userAgent)) {"}
{"input":"<s> export default function (): void {<EOL>    describe(\"<STR_LIT>\", function () {<EOL>        beforeEach(function (this: UserContext) {<EOL>            this.domAdapter = new DomAdapter();<EOL>            this.element = document.createElement(\"<STR_LIT>\");<EOL>            this.element.appendChild(document.createTextNode(\"<STR_LIT>\"));<EOL>            document.body.appendChild(this.element);<EOL>        });<EOL>        afterEach(function (this: UserContext) {<EOL>            document.body.removeChild(this.element);<EOL>        });<EOL>        it(\"<STR_LIT>\", function (this: UserContext) {<EOL>            const child: HTMLDivElement = document.createElement(\"<STR_LIT>\");<EOL>            child.style.width = \"<STR_LIT>\";<EOL>            child.style.height = \"<STR_LIT>\";<EOL>            this.element.appendChild(child);<EOL>            expect(this.domAdapter.scrollWidth(this.element)).toBe(<NUM_LIT>);<EOL>        });<EOL>        it(\"<STR_LIT>\", function (this: UserContext) {<EOL>            expect(this.domAdapter.scrollBarWidth(this.element)).toBe(<NUM_LIT>);<EOL>            this.element.style.overflow = \"<STR_LIT>\";<EOL>            <EOL>            <EOL>            if (/PhantomJS/.test(window.navigator.userAgent)) {<EOL>                expect(this.domAdapter.scrollBarWidth(this.element)).toBeGreaterThan(<NUM_LIT>);<EOL>            }<EOL>        });<EOL>        it(\"<STR_LIT>\", function (this: UserContext) {<EOL>            const child: HTMLDivElement = document.createElement(\"<STR_LIT>\");<EOL>            child.style.width = \"<STR_LIT>\";<EOL>","gt":"child.style.height = \"<STR_LIT>\";"}
{"input":"<s> export default function (): void {<EOL>    describe(\"<STR_LIT>\", function () {<EOL>        beforeEach(function (this: UserContext) {<EOL>            this.domAdapter = new DomAdapter();<EOL>            this.element = document.createElement(\"<STR_LIT>\");<EOL>            this.element.appendChild(document.createTextNode(\"<STR_LIT>\"));<EOL>            document.body.appendChild(this.element);<EOL>        });<EOL>        afterEach(function (this: UserContext) {<EOL>            document.body.removeChild(this.element);<EOL>        });<EOL>        it(\"<STR_LIT>\", function (this: UserContext) {<EOL>            const child: HTMLDivElement = document.createElement(\"<STR_LIT>\");<EOL>            child.style.width = \"<STR_LIT>\";<EOL>            child.style.height = \"<STR_LIT>\";<EOL>            this.element.appendChild(child);<EOL>            expect(this.domAdapter.scrollWidth(this.element)).toBe(<NUM_LIT>);<EOL>        });<EOL>        it(\"<STR_LIT>\", function (this: UserContext) {<EOL>            expect(this.domAdapter.scrollBarWidth(this.element)).toBe(<NUM_LIT>);<EOL>            this.element.style.overflow = \"<STR_LIT>\";<EOL>            <EOL>            <EOL>            if (/PhantomJS/.test(window.navigator.userAgent)) {<EOL>                expect(this.domAdapter.scrollBarWidth(this.element)).toBeGreaterThan(<NUM_LIT>);<EOL>            }<EOL>        });<EOL>        it(\"<STR_LIT>\", function (this: UserContext) {<EOL>            const child: HTMLDivElement = document.createElement(\"<STR_LIT>\");<EOL>            child.style.width = \"<STR_LIT>\";<EOL>            child.style.height = \"<STR_LIT>\";<EOL>            this.element.replaceChild(child, this.element.firstChild);<EOL>            expect(this.domAdapter.computedHeight(this.element)).toBe(<NUM_LIT>);<EOL>        });<EOL>        describe(\"<STR_LIT>\", function () {<EOL>            it(\"<STR_LIT>\", function (this: UserContext) {<EOL>                expect(this.domAdapter.userDefinedWidth(this.element)).toBe(<NUM_LIT>);<EOL>                this.element.style.width = \"<STR_LIT>\";<EOL>                expect(this.domAdapter.userDefinedWidth(this.element)).toBe(<NUM_LIT>);<EOL>            });<EOL>            it(\"<STR_LIT>\", function (this: UserContext) {<EOL>                expect(this.domAdapter.userDefinedWidth(this.element)).toBe(","gt":"<NUM_LIT>);"}
{"input":"<s> export default function (): void {<EOL>    describe(\"<STR_LIT>\", function () {<EOL>        beforeEach(function (this: UserContext) {<EOL>            this.domAdapter = new DomAdapter();<EOL>            this.element = document.createElement(\"<STR_LIT>\");<EOL>            this.element.appendChild(document.createTextNode(\"<STR_LIT>\"));<EOL>            document.body.appendChild(this.element);<EOL>        });<EOL>        afterEach(function (this: UserContext) {<EOL>            document.body.removeChild(this.element);<EOL>        });<EOL>        it(\"<STR_LIT>\", function (this: UserContext) {<EOL>            const child: HTMLDivElement = document.createElement(\"<STR_LIT>\");<EOL>            child.style.width = \"<STR_LIT>\";<EOL>            child.style.height = \"<STR_LIT>\";<EOL>            this.element.appendChild(child);<EOL>            expect(this.domAdapter.scrollWidth(this.element)).toBe(<NUM_LIT>);<EOL>        });<EOL>        it(\"<STR_LIT>\", function (this: UserContext) {<EOL>            expect(this.domAdapter.scrollBarWidth(this.element)).toBe(<NUM_LIT>);<EOL>            this.element.style.overflow = \"<STR_LIT>\";<EOL>            <EOL>            <EOL>            if (/PhantomJS/.test(window.navigator.userAgent)) {<EOL>                expect(this.domAdapter.scrollBarWidth(this.element)).toBeGreaterThan(<NUM_LIT>);<EOL>            }<EOL>        });<EOL>        it(\"<STR_LIT>\", function (this: UserContext) {<EOL>            const child: HTMLDivElement = document.createElement(\"<STR_LIT>\");<EOL>            child.style.width = \"<STR_LIT>\";<EOL>            child.style.height = \"<STR_LIT>\";<EOL>            this.element.replaceChild(child, this.element.firstChild);<EOL>            expect(this.domAdapter.computedHeight(this.element)).toBe(<NUM_LIT>);<EOL>        });<EOL>        describe(\"<STR_LIT>\", function () {<EOL>            it(\"<STR_LIT>\", function (this: UserContext) {<EOL>                expect(this.domAdapter.userDefinedWidth(this.element)).toBe(<NUM_LIT>);<EOL>                this.element.style.width = \"<STR_LIT>\";<EOL>                expect(this.domAdapter.userDefinedWidth(this.element)).toBe(<NUM_LIT>);<EOL>            });<EOL>            it(\"<STR_LIT>\", function (this: UserContext) {<EOL>                expect(this.domAdapter.userDefinedWidth(this.element)).toBe(<NUM_LIT>);<EOL>                const style: HTMLStyleElement = document.createElement(\"<STR_LIT>\");<EOL>                style.appendChild(document.createTextNode(\"<STR_LIT>\"));<EOL>                document.body.appendChild(style);<EOL>                this.element.classList.add(\"<STR_LIT>\");<EOL>","gt":"expect(this.domAdapter.userDefinedWidth(this.element)).toBe(<NUM_LIT>);"}
{"input":"<s> export default function (): void {<EOL>    describe(\"<STR_LIT>\", function () {<EOL>        beforeEach(function (this: UserContext) {<EOL>            this.domAdapter = new DomAdapter();<EOL>            this.element = document.createElement(\"<STR_LIT>\");<EOL>            this.element.appendChild(document.createTextNode(\"<STR_LIT>\"));<EOL>            document.body.appendChild(this.element);<EOL>        });<EOL>        afterEach(function (this: UserContext) {<EOL>            document.body.removeChild(this.element);<EOL>        });<EOL>        it(\"<STR_LIT>\", function (this: UserContext) {<EOL>            const child: HTMLDivElement = document.createElement(\"<STR_LIT>\");<EOL>            child.style.width = \"<STR_LIT>\";<EOL>            child.style.height = \"<STR_LIT>\";<EOL>            this.element.appendChild(child);<EOL>            expect(this.domAdapter.scrollWidth(this.element)).toBe(<NUM_LIT>);<EOL>        });<EOL>        it(\"<STR_LIT>\", function (this: UserContext) {<EOL>            expect(this.domAdapter.scrollBarWidth(this.element)).toBe(<NUM_LIT>);<EOL>            this.element.style.overflow = \"<STR_LIT>\";<EOL>            <EOL>            <EOL>            if (/PhantomJS/.test(window.navigator.userAgent)) {<EOL>                expect(this.domAdapter.scrollBarWidth(this.element)).toBeGreaterThan(<NUM_LIT>);<EOL>            }<EOL>        });<EOL>        it(\"<STR_LIT>\", function (this: UserContext) {<EOL>            const child: HTMLDivElement = document.createElement(\"<STR_LIT>\");<EOL>            child.style.width = \"<STR_LIT>\";<EOL>            child.style.height = \"<STR_LIT>\";<EOL>            this.element.replaceChild(child, this.element.firstChild);<EOL>            expect(this.domAdapter.computedHeight(this.element)).toBe(<NUM_LIT>);<EOL>        });<EOL>        describe(\"<STR_LIT>\", function () {<EOL>            it(\"<STR_LIT>\", function (this: UserContext) {<EOL>                expect(this.domAdapter.userDefinedWidth(this.element)).toBe(<NUM_LIT>);<EOL>                this.element.style.width = \"<STR_LIT>\";<EOL>                expect(this.domAdapter.userDefinedWidth(this.element)).toBe(<NUM_LIT>);<EOL>            });<EOL>            it(\"<STR_LIT>\", function (this: UserContext) {<EOL>                expect(this.domAdapter.userDefinedWidth(this.element)).toBe(<NUM_LIT>);<EOL>                const style: HTMLStyleElement = document.createElement(\"<STR_LIT>\");<EOL>                style.appendChild(document.createTextNode(\"<STR_LIT>\"));<EOL>                document.body.appendChild(style);<EOL>                this.element.classList.add(\"<STR_LIT>\");<EOL>                expect(this.domAdapter.userDefinedWidth(this.element)).toBe(<NUM_LIT>);<EOL>                document.body.removeChild(style);<EOL>            });<EOL>            it(\"<STR_LIT>\",","gt":"function (this: UserContext) {"}
{"input":"<s> export default function (): void {<EOL>    describe(\"<STR_LIT>\", function () {<EOL>        let context: TestContext<ClrDropdownMenu, SimpleTest>;<EOL>        beforeEach(function () {<EOL>            context = this.create(ClrDropdownMenu, SimpleTest, [IfOpenService]);<EOL>            context.getClarityProvider(IfOpenService).open =","gt":"true;"}
{"input":"<s> export default function (): void {<EOL>    describe(\"<STR_LIT>\", function () {<EOL>        let context: TestContext<ClrDropdownMenu, SimpleTest>;<EOL>        beforeEach(function () {<EOL>            context = this.create(ClrDropdownMenu, SimpleTest, [IfOpenService]);<EOL>            context.getClarityProvider(IfOpenService).open = true;<EOL>            context.detectChanges();<EOL>        });<EOL>        it(\"<STR_LIT>\", function () {<EOL>            expect(context.","gt":"clarityElement.textContent.trim()).toMatch(\"<STR_LIT>\");"}
{"input":"<s> export default function (): void {<EOL>    describe(\"<STR_LIT>\", function () {<EOL>        let context: TestContext<ClrDropdownMenu, SimpleTest>;<EOL>        beforeEach(function () {<EOL>            context = this.create(ClrDropdownMenu, SimpleTest, [IfOpenService]);<EOL>            context.getClarityProvider(IfOpenService).open = true;<EOL>            context.detectChanges();<EOL>        });<EOL>        it(\"<STR_LIT>\", function () {<EOL>            expect(context.clarityElement.textContent.trim()).toMatch(\"<STR_LIT>\");<EOL>        });<EOL>        it(\"<STR_LIT>\", (): void => {<EOL>            expect(","gt":"context.testElement.querySelector(\"<STR_LIT>\")).not.toBeNull();"}
{"input":"<s> export default function (): void {<EOL>    describe(\"<STR_LIT>\", function () {<EOL>        let context: TestContext<ClrDropdownMenu, SimpleTest>;<EOL>        beforeEach(function () {<EOL>            context = this.create(ClrDropdownMenu, SimpleTest, [IfOpenService]);<EOL>            context.getClarityProvider(IfOpenService).open = true;<EOL>            context.detectChanges();<EOL>        });<EOL>        it(\"<STR_LIT>\", function () {<EOL>            expect(context.clarityElement.textContent.trim()).toMatch(\"<STR_LIT>\");<EOL>        });<EOL>        it(\"<STR_LIT>\", (): void => {<EOL>            expect(context.testElement.querySelector(\"<STR_LIT>\")).not.toBeNull();<EOL>        });<EOL>        it(\"<STR_LIT>\", (): void => {<EOL>            <EOL>            expect((<any>context.clarityDirective).anchorPoint).toEqual(Point.BOTTOM_LEFT);<EOL>            expect((<any>context.clarityDirective).popoverPoint).toEqual(Point.LEFT_TOP);<EOL>            context.clarityDirective.position = \"<STR_LIT>\";<EOL>            context.detectChanges();<EOL>            expect((<any>context.clarityDirective).anchorPoint).toEqual(Point.BOTTOM_RIGHT);<EOL>            expect((<any>context.clarityDirective).popoverPoint).toEqual(","gt":"Point.RIGHT_TOP);"}
{"input":"<s> export default function (): void {<EOL>    describe(\"<STR_LIT>\", function () {<EOL>        let ifActiveService: IfActiveService;<EOL>        beforeEach(function () {<EOL>            ifActiveService =","gt":"new IfActiveService();"}
{"input":"<s> export default function (): void {<EOL>    describe(\"<STR_LIT>\", function () {<EOL>        let ifActiveService: IfActiveService;<EOL>        beforeEach(function () {<EOL>            ifActiveService = new IfActiveService();<EOL>        });<EOL>        describe(\"<STR_LIT>\",","gt":"function () {"}
{"input":"<s> export default function (): void {<EOL>    describe(\"<STR_LIT>\", function () {<EOL>        let ifActiveService: IfActiveService;<EOL>        beforeEach(function () {<EOL>            ifActiveService = new IfActiveService();<EOL>        });<EOL>        describe(\"<STR_LIT>\", function () {<EOL>            it(\"<STR_LIT>\", function () {<EOL>                let nbChanges:","gt":"number = <NUM_LIT>;"}
{"input":"<s> export default function (): void {<EOL>    describe(\"<STR_LIT>\", function () {<EOL>        let ifActiveService: IfActiveService;<EOL>        beforeEach(function () {<EOL>            ifActiveService = new IfActiveService();<EOL>        });<EOL>        describe(\"<STR_LIT>\", function () {<EOL>            it(\"<STR_LIT>\", function () {<EOL>                let nbChanges: number = <NUM_LIT>;<EOL>                let currentChange: number;<EOL>                <EOL>                ifActiveService.currentChange.subscribe((change: number): void => {<EOL>                    nbChanges++;<EOL>","gt":"currentChange = change;"}
{"input":"<s> export default function (): void {<EOL>    describe(\"<STR_LIT>\", function () {<EOL>        let ifActiveService: IfActiveService;<EOL>        beforeEach(function () {<EOL>            ifActiveService = new IfActiveService();<EOL>        });<EOL>        describe(\"<STR_LIT>\", function () {<EOL>            it(\"<STR_LIT>\", function () {<EOL>                let nbChanges: number = <NUM_LIT>;<EOL>                let currentChange: number;<EOL>                <EOL>                ifActiveService.currentChange.subscribe((change: number): void => {<EOL>                    nbChanges++;<EOL>                    currentChange = change;<EOL>                });<EOL>                <EOL>                expect(ifActiveService).toBeDefined();<EOL>                expect(nbChanges).toEqual(<NUM_LIT>);<EOL>                expect(","gt":"currentChange).not.toBeDefined();"}
{"input":"<s> export default function (): void {<EOL>    describe(\"<STR_LIT>\", function () {<EOL>        let ifActiveService: IfActiveService;<EOL>        beforeEach(function () {<EOL>            ifActiveService = new IfActiveService();<EOL>        });<EOL>        describe(\"<STR_LIT>\", function () {<EOL>            it(\"<STR_LIT>\", function () {<EOL>                let nbChanges: number = <NUM_LIT>;<EOL>                let currentChange: number;<EOL>                <EOL>                ifActiveService.currentChange.subscribe((change: number): void => {<EOL>                    nbChanges++;<EOL>                    currentChange = change;<EOL>                });<EOL>                <EOL>                expect(ifActiveService).toBeDefined();<EOL>                expect(nbChanges).toEqual(<NUM_LIT>);<EOL>                expect(currentChange).not.toBeDefined();<EOL>                <EOL>                ifActiveService.current = <NUM_LIT>;<EOL>                expect(nbChanges).toEqual(<NUM_LIT>);<EOL>                expect(currentChange).toEqual(","gt":"<NUM_LIT>);"}
{"input":"<s> export default function (): void {<EOL>    describe(\"<STR_LIT>\", function () {<EOL>        let ifActiveService: IfActiveService;<EOL>        beforeEach(function () {<EOL>            ifActiveService = new IfActiveService();<EOL>        });<EOL>        describe(\"<STR_LIT>\", function () {<EOL>            it(\"<STR_LIT>\", function () {<EOL>                let nbChanges: number = <NUM_LIT>;<EOL>                let currentChange: number;<EOL>                <EOL>                ifActiveService.currentChange.subscribe((change: number): void => {<EOL>                    nbChanges++;<EOL>                    currentChange = change;<EOL>                });<EOL>                <EOL>                expect(ifActiveService).toBeDefined();<EOL>                expect(nbChanges).toEqual(<NUM_LIT>);<EOL>                expect(currentChange).not.toBeDefined();<EOL>                <EOL>                ifActiveService.current = <NUM_LIT>;<EOL>                expect(nbChanges).toEqual(<NUM_LIT>);<EOL>                expect(currentChange).toEqual(<NUM_LIT>);<EOL>                <EOL>                ifActiveService.current = <NUM_LIT>;<EOL>                expect(nbChanges).toEqual(<NUM_LIT>);<EOL>                expect(currentChange).toEqual(<NUM_LIT>);<EOL>            });<EOL>            it(\"<STR_LIT>\", function () {<EOL>                expect(ifActiveService.current).not.toBeDefined();<EOL>                ifActiveService.current = <NUM_LIT>;<EOL>                expect(ifActiveService.current).toEqual(","gt":"<NUM_LIT>);"}
{"input":"<s> export default function (): void {<EOL>    describe(\"<STR_LIT>\", function () {<EOL>        let ifActiveService: IfActiveService;<EOL>        beforeEach(function () {<EOL>            ifActiveService = new IfActiveService();<EOL>        });<EOL>        describe(\"<STR_LIT>\", function () {<EOL>            it(\"<STR_LIT>\", function () {<EOL>                let nbChanges: number = <NUM_LIT>;<EOL>                let currentChange: number;<EOL>                <EOL>                ifActiveService.currentChange.subscribe((change: number): void => {<EOL>                    nbChanges++;<EOL>                    currentChange = change;<EOL>                });<EOL>                <EOL>                expect(ifActiveService).toBeDefined();<EOL>                expect(nbChanges).toEqual(<NUM_LIT>);<EOL>                expect(currentChange).not.toBeDefined();<EOL>                <EOL>                ifActiveService.current = <NUM_LIT>;<EOL>                expect(nbChanges).toEqual(<NUM_LIT>);<EOL>                expect(currentChange).toEqual(<NUM_LIT>);<EOL>                <EOL>                ifActiveService.current = <NUM_LIT>;<EOL>                expect(nbChanges).toEqual(<NUM_LIT>);<EOL>                expect(currentChange).toEqual(<NUM_LIT>);<EOL>            });<EOL>            it(\"<STR_LIT>\", function () {<EOL>                expect(ifActiveService.current).not.toBeDefined();<EOL>                ifActiveService.current = <NUM_LIT>;<EOL>                expect(ifActiveService.current).toEqual(<NUM_LIT>);<EOL>            });<EOL>            it(\"<STR_LIT>\", function () {<EOL>                const init: number = <NUM_LIT>;<EOL>                let","gt":"test: any;"}
{"input":"<s> export default function (): void {<EOL>    describe(\"<STR_LIT>\", function () {<EOL>        describe(\"<STR_LIT>\", function () {<EOL>            beforeEach(","gt":"function () {"}
{"input":"<s> export default function (): void {<EOL>    describe(\"<STR_LIT>\", function () {<EOL>        describe(\"<STR_LIT>\", function () {<EOL>            beforeEach(function () {<EOL>                <EOL>                TestBed.configureTestingModule({ declarations: [IfExpanded, SimpleTest, TestCounter], providers: [Expand] });<EOL>                this.fixture = TestBed.","gt":"createComponent(SimpleTest);"}
{"input":"<s> export default function (): void {<EOL>    describe(\"<STR_LIT>\", function () {<EOL>        describe(\"<STR_LIT>\", function () {<EOL>            beforeEach(function () {<EOL>                <EOL>                TestBed.configureTestingModule({ declarations: [IfExpanded, SimpleTest, TestCounter], providers: [Expand] });<EOL>                this.fixture = TestBed.createComponent(SimpleTest);<EOL>                this.fixture.detectChanges();<EOL>                this.","gt":"testComponent = this.fixture.componentInstance;"}
{"input":"<s> export default function (): void {<EOL>    describe(\"<STR_LIT>\", function () {<EOL>        describe(\"<STR_LIT>\", function () {<EOL>            beforeEach(function () {<EOL>                <EOL>                TestBed.configureTestingModule({ declarations: [IfExpanded, SimpleTest, TestCounter], providers: [Expand] });<EOL>                this.fixture = TestBed.createComponent(SimpleTest);<EOL>                this.fixture.detectChanges();<EOL>                this.testComponent = this.fixture.componentInstance;<EOL>                this.testElement = this.fixture.nativeElement;<EOL>                this.clarityDirective = this.fixture.componentInstance.ifExpanded;<EOL>                this.expand = TestBed.get(Expand);<EOL>            });<EOL>            afterEach(","gt":"function () {"}
{"input":"<s> export default function (): void {<EOL>    describe(\"<STR_LIT>\", function () {<EOL>        describe(\"<STR_LIT>\", function () {<EOL>            beforeEach(function () {<EOL>                <EOL>                TestBed.configureTestingModule({ declarations: [IfExpanded, SimpleTest, TestCounter], providers: [Expand] });<EOL>                this.fixture = TestBed.createComponent(SimpleTest);<EOL>                this.fixture.detectChanges();<EOL>                this.testComponent = this.fixture.componentInstance;<EOL>                this.testElement = this.fixture.nativeElement;<EOL>                this.clarityDirective = this.fixture.componentInstance.ifExpanded;<EOL>                this.expand = TestBed.get(Expand);<EOL>            });<EOL>            afterEach(function () {<EOL>                this.fixture.destroy();<EOL>            });<EOL>            it(\"<STR_LIT>\", function () {<EOL>                expect(this.testElement.textContent.trim()).toBe(\"<STR_LIT>\");<EOL>            });<EOL>            it(\"<STR_LIT>\", function () {<EOL>                this.expand.expanded = true;<EOL>                this.","gt":"fixture.detectChanges();"}
{"input":"<s> export default function (): void {<EOL>    describe(\"<STR_LIT>\", function () {<EOL>        describe(\"<STR_LIT>\", function () {<EOL>            beforeEach(function () {<EOL>                <EOL>                TestBed.configureTestingModule({ declarations: [IfExpanded, SimpleTest, TestCounter], providers: [Expand] });<EOL>                this.fixture = TestBed.createComponent(SimpleTest);<EOL>                this.fixture.detectChanges();<EOL>                this.testComponent = this.fixture.componentInstance;<EOL>                this.testElement = this.fixture.nativeElement;<EOL>                this.clarityDirective = this.fixture.componentInstance.ifExpanded;<EOL>                this.expand = TestBed.get(Expand);<EOL>            });<EOL>            afterEach(function () {<EOL>                this.fixture.destroy();<EOL>            });<EOL>            it(\"<STR_LIT>\", function () {<EOL>                expect(this.testElement.textContent.trim()).toBe(\"<STR_LIT>\");<EOL>            });<EOL>            it(\"<STR_LIT>\", function () {<EOL>                this.expand.expanded = true;<EOL>                this.fixture.detectChanges();<EOL>                expect(this.testElement.textContent.trim()).toBe(\"<STR_LIT>\");<EOL>            });<EOL>            it(\"<STR_LIT>\", function () {<EOL>                this.expand.expanded = true;<EOL>                this.fixture.detectChanges();<EOL>                this.expand.expanded = false;<EOL>                this.","gt":"fixture.detectChanges();"}
{"input":"<s> export default function (): void {<EOL>    describe(\"<STR_LIT>\", function () {<EOL>        describe(\"<STR_LIT>\", function () {<EOL>            beforeEach(function () {<EOL>                <EOL>                TestBed.configureTestingModule({ declarations: [IfExpanded, SimpleTest, TestCounter], providers: [Expand] });<EOL>                this.fixture = TestBed.createComponent(SimpleTest);<EOL>                this.fixture.detectChanges();<EOL>                this.testComponent = this.fixture.componentInstance;<EOL>                this.testElement = this.fixture.nativeElement;<EOL>                this.clarityDirective = this.fixture.componentInstance.ifExpanded;<EOL>                this.expand = TestBed.get(Expand);<EOL>            });<EOL>            afterEach(function () {<EOL>                this.fixture.destroy();<EOL>            });<EOL>            it(\"<STR_LIT>\", function () {<EOL>                expect(this.testElement.textContent.trim()).toBe(\"<STR_LIT>\");<EOL>            });<EOL>            it(\"<STR_LIT>\", function () {<EOL>                this.expand.expanded = true;<EOL>                this.fixture.detectChanges();<EOL>                expect(this.testElement.textContent.trim()).toBe(\"<STR_LIT>\");<EOL>            });<EOL>            it(\"<STR_LIT>\", function () {<EOL>                this.expand.expanded = true;<EOL>                this.fixture.detectChanges();<EOL>                this.expand.expanded = false;<EOL>                this.fixture.detectChanges();<EOL>                expect(this.testElement.textContent.trim()).toBe(\"<STR_LIT>\");<EOL>            });<EOL>            it(\"<STR_LIT>\", function () {<EOL>                expect(this.testComponent.counter.total).toBe(<NUM_LIT>);<EOL>            });<EOL>            it(\"<STR_LIT>\", function () {<EOL>                this.expand.expanded = true;<EOL>                this.","gt":"fixture.detectChanges();"}
{"input":"<s> export default function (): void {<EOL>    describe(\"<STR_LIT>\", function () {<EOL>        describe(\"<STR_LIT>\", function () {<EOL>            beforeEach(function () {<EOL>                <EOL>                TestBed.configureTestingModule({ declarations: [IfExpanded, SimpleTest, TestCounter], providers: [Expand] });<EOL>                this.fixture = TestBed.createComponent(SimpleTest);<EOL>                this.fixture.detectChanges();<EOL>                this.testComponent = this.fixture.componentInstance;<EOL>                this.testElement = this.fixture.nativeElement;<EOL>                this.clarityDirective = this.fixture.componentInstance.ifExpanded;<EOL>                this.expand = TestBed.get(Expand);<EOL>            });<EOL>            afterEach(function () {<EOL>                this.fixture.destroy();<EOL>            });<EOL>            it(\"<STR_LIT>\", function () {<EOL>                expect(this.testElement.textContent.trim()).toBe(\"<STR_LIT>\");<EOL>            });<EOL>            it(\"<STR_LIT>\", function () {<EOL>                this.expand.expanded = true;<EOL>                this.fixture.detectChanges();<EOL>                expect(this.testElement.textContent.trim()).toBe(\"<STR_LIT>\");<EOL>            });<EOL>            it(\"<STR_LIT>\", function () {<EOL>                this.expand.expanded = true;<EOL>                this.fixture.detectChanges();<EOL>                this.expand.expanded = false;<EOL>                this.fixture.detectChanges();<EOL>                expect(this.testElement.textContent.trim()).toBe(\"<STR_LIT>\");<EOL>            });<EOL>            it(\"<STR_LIT>\", function () {<EOL>                expect(this.testComponent.counter.total).toBe(<NUM_LIT>);<EOL>            });<EOL>            it(\"<STR_LIT>\", function () {<EOL>                this.expand.expanded = true;<EOL>                this.fixture.detectChanges();<EOL>                expect(this.testElement.textContent.trim()).toBe(\"<STR_LIT>\");<EOL>                this.expand.expanded = false;<EOL>                this.fixture.detectChanges();<EOL>                this.expand.","gt":"expanded = true;"}
{"input":"<s> export default function (): void {<EOL>    describe(\"<STR_LIT>\", function () {<EOL>        describe(\"<STR_LIT>\", function () {<EOL>            beforeEach(function () {<EOL>                <EOL>                TestBed.configureTestingModule({ declarations: [IfExpanded, SimpleTest, TestCounter], providers: [Expand] });<EOL>                this.fixture = TestBed.createComponent(SimpleTest);<EOL>                this.fixture.detectChanges();<EOL>                this.testComponent = this.fixture.componentInstance;<EOL>                this.testElement = this.fixture.nativeElement;<EOL>                this.clarityDirective = this.fixture.componentInstance.ifExpanded;<EOL>                this.expand = TestBed.get(Expand);<EOL>            });<EOL>            afterEach(function () {<EOL>                this.fixture.destroy();<EOL>            });<EOL>            it(\"<STR_LIT>\", function () {<EOL>                expect(this.testElement.textContent.trim()).toBe(\"<STR_LIT>\");<EOL>            });<EOL>            it(\"<STR_LIT>\", function () {<EOL>                this.expand.expanded = true;<EOL>                this.fixture.detectChanges();<EOL>                expect(this.testElement.textContent.trim()).toBe(\"<STR_LIT>\");<EOL>            });<EOL>            it(\"<STR_LIT>\", function () {<EOL>                this.expand.expanded = true;<EOL>                this.fixture.detectChanges();<EOL>                this.expand.expanded = false;<EOL>                this.fixture.detectChanges();<EOL>                expect(this.testElement.textContent.trim()).toBe(\"<STR_LIT>\");<EOL>            });<EOL>            it(\"<STR_LIT>\", function () {<EOL>                expect(this.testComponent.counter.total).toBe(<NUM_LIT>);<EOL>            });<EOL>            it(\"<STR_LIT>\", function () {<EOL>                this.expand.expanded = true;<EOL>                this.fixture.detectChanges();<EOL>                expect(this.testElement.textContent.trim()).toBe(\"<STR_LIT>\");<EOL>                this.expand.expanded = false;<EOL>                this.fixture.detectChanges();<EOL>                this.expand.expanded = true;<EOL>                this.fixture.detectChanges();<EOL>","gt":"expect(this.testElement.textContent.trim()).toBe(\"<STR_LIT>\");"}
{"input":"<s> export default function (): void {<EOL>    describe(\"<STR_LIT>\", function () {<EOL>        describe(\"<STR_LIT>\", function () {<EOL>            beforeEach(function () {<EOL>                <EOL>                TestBed.configureTestingModule({ declarations: [IfExpanded, SimpleTest, TestCounter], providers: [Expand] });<EOL>                this.fixture = TestBed.createComponent(SimpleTest);<EOL>                this.fixture.detectChanges();<EOL>                this.testComponent = this.fixture.componentInstance;<EOL>                this.testElement = this.fixture.nativeElement;<EOL>                this.clarityDirective = this.fixture.componentInstance.ifExpanded;<EOL>                this.expand = TestBed.get(Expand);<EOL>            });<EOL>            afterEach(function () {<EOL>                this.fixture.destroy();<EOL>            });<EOL>            it(\"<STR_LIT>\", function () {<EOL>                expect(this.testElement.textContent.trim()).toBe(\"<STR_LIT>\");<EOL>            });<EOL>            it(\"<STR_LIT>\", function () {<EOL>                this.expand.expanded = true;<EOL>                this.fixture.detectChanges();<EOL>                expect(this.testElement.textContent.trim()).toBe(\"<STR_LIT>\");<EOL>            });<EOL>            it(\"<STR_LIT>\", function () {<EOL>                this.expand.expanded = true;<EOL>                this.fixture.detectChanges();<EOL>                this.expand.expanded = false;<EOL>                this.fixture.detectChanges();<EOL>                expect(this.testElement.textContent.trim()).toBe(\"<STR_LIT>\");<EOL>            });<EOL>            it(\"<STR_LIT>\", function () {<EOL>                expect(this.testComponent.counter.total).toBe(<NUM_LIT>);<EOL>            });<EOL>            it(\"<STR_LIT>\", function () {<EOL>                this.expand.expanded = true;<EOL>                this.fixture.detectChanges();<EOL>                expect(this.testElement.textContent.trim()).toBe(\"<STR_LIT>\");<EOL>                this.expand.expanded = false;<EOL>                this.fixture.detectChanges();<EOL>                this.expand.expanded = true;<EOL>                this.fixture.detectChanges();<EOL>                expect(this.testElement.textContent.trim()).toBe(\"<STR_LIT>\");<EOL>            });<EOL>        });<EOL>        describe(\"<STR_LIT>\", function () {<EOL>            beforeEach(function () {<EOL>                <EOL>                TestBed.configureTestingModule({ declarations: [IfExpanded, NgIfTest], providers: [Expand] });<EOL>                this.fixture = TestBed.","gt":"createComponent(NgIfTest);"}
{"input":"<s> export default function (): void {<EOL>    describe(\"<STR_LIT>\", function () {<EOL>        describe(\"<STR_LIT>\", function () {<EOL>            beforeEach(function () {<EOL>                <EOL>                TestBed.configureTestingModule({ declarations: [IfExpanded, SimpleTest, TestCounter], providers: [Expand] });<EOL>                this.fixture = TestBed.createComponent(SimpleTest);<EOL>                this.fixture.detectChanges();<EOL>                this.testComponent = this.fixture.componentInstance;<EOL>                this.testElement = this.fixture.nativeElement;<EOL>                this.clarityDirective = this.fixture.componentInstance.ifExpanded;<EOL>                this.expand = TestBed.get(Expand);<EOL>            });<EOL>            afterEach(function () {<EOL>                this.fixture.destroy();<EOL>            });<EOL>            it(\"<STR_LIT>\", function () {<EOL>                expect(this.testElement.textContent.trim()).toBe(\"<STR_LIT>\");<EOL>            });<EOL>            it(\"<STR_LIT>\", function () {<EOL>                this.expand.expanded = true;<EOL>                this.fixture.detectChanges();<EOL>                expect(this.testElement.textContent.trim()).toBe(\"<STR_LIT>\");<EOL>            });<EOL>            it(\"<STR_LIT>\", function () {<EOL>                this.expand.expanded = true;<EOL>                this.fixture.detectChanges();<EOL>                this.expand.expanded = false;<EOL>                this.fixture.detectChanges();<EOL>                expect(this.testElement.textContent.trim()).toBe(\"<STR_LIT>\");<EOL>            });<EOL>            it(\"<STR_LIT>\", function () {<EOL>                expect(this.testComponent.counter.total).toBe(<NUM_LIT>);<EOL>            });<EOL>            it(\"<STR_LIT>\", function () {<EOL>                this.expand.expanded = true;<EOL>                this.fixture.detectChanges();<EOL>                expect(this.testElement.textContent.trim()).toBe(\"<STR_LIT>\");<EOL>                this.expand.expanded = false;<EOL>                this.fixture.detectChanges();<EOL>                this.expand.expanded = true;<EOL>                this.fixture.detectChanges();<EOL>                expect(this.testElement.textContent.trim()).toBe(\"<STR_LIT>\");<EOL>            });<EOL>        });<EOL>        describe(\"<STR_LIT>\", function () {<EOL>            beforeEach(function () {<EOL>                <EOL>                TestBed.configureTestingModule({ declarations: [IfExpanded, NgIfTest], providers: [Expand] });<EOL>                this.fixture = TestBed.createComponent(NgIfTest);<EOL>                this.fixture.detectChanges();<EOL>                this.testComponent = this.fixture.componentInstance;<EOL>                this.expand = TestBed.get(Expand);<EOL>            });<EOL>            afterEach(function () {<EOL>                this.fixture.","gt":"destroy();"}
{"input":"<s> export default function (): void {<EOL>    describe(\"<STR_LIT>\", function () {<EOL>        describe(\"<STR_LIT>\", function () {<EOL>            beforeEach(function () {<EOL>                <EOL>                TestBed.configureTestingModule({ declarations: [IfExpanded, SimpleTest, TestCounter], providers: [Expand] });<EOL>                this.fixture = TestBed.createComponent(SimpleTest);<EOL>                this.fixture.detectChanges();<EOL>                this.testComponent = this.fixture.componentInstance;<EOL>                this.testElement = this.fixture.nativeElement;<EOL>                this.clarityDirective = this.fixture.componentInstance.ifExpanded;<EOL>                this.expand = TestBed.get(Expand);<EOL>            });<EOL>            afterEach(function () {<EOL>                this.fixture.destroy();<EOL>            });<EOL>            it(\"<STR_LIT>\", function () {<EOL>                expect(this.testElement.textContent.trim()).toBe(\"<STR_LIT>\");<EOL>            });<EOL>            it(\"<STR_LIT>\", function () {<EOL>                this.expand.expanded = true;<EOL>                this.fixture.detectChanges();<EOL>                expect(this.testElement.textContent.trim()).toBe(\"<STR_LIT>\");<EOL>            });<EOL>            it(\"<STR_LIT>\", function () {<EOL>                this.expand.expanded = true;<EOL>                this.fixture.detectChanges();<EOL>                this.expand.expanded = false;<EOL>                this.fixture.detectChanges();<EOL>                expect(this.testElement.textContent.trim()).toBe(\"<STR_LIT>\");<EOL>            });<EOL>            it(\"<STR_LIT>\", function () {<EOL>                expect(this.testComponent.counter.total).toBe(<NUM_LIT>);<EOL>            });<EOL>            it(\"<STR_LIT>\", function () {<EOL>                this.expand.expanded = true;<EOL>                this.fixture.detectChanges();<EOL>                expect(this.testElement.textContent.trim()).toBe(\"<STR_LIT>\");<EOL>                this.expand.expanded = false;<EOL>                this.fixture.detectChanges();<EOL>                this.expand.expanded = true;<EOL>                this.fixture.detectChanges();<EOL>                expect(this.testElement.textContent.trim()).toBe(\"<STR_LIT>\");<EOL>            });<EOL>        });<EOL>        describe(\"<STR_LIT>\", function () {<EOL>            beforeEach(function () {<EOL>                <EOL>                TestBed.configureTestingModule({ declarations: [IfExpanded, NgIfTest], providers: [Expand] });<EOL>                this.fixture = TestBed.createComponent(NgIfTest);<EOL>                this.fixture.detectChanges();<EOL>                this.testComponent = this.fixture.componentInstance;<EOL>                this.expand = TestBed.get(Expand);<EOL>            });<EOL>            afterEach(function () {<EOL>                this.fixture.destroy();<EOL>            });<EOL>            it(","gt":"\"<STR_LIT>\", function () {"}
{"input":"<s> export default function (): void {<EOL>    describe(\"<STR_LIT>\", function () {<EOL>        describe(\"<STR_LIT>\", function () {<EOL>            beforeEach(function () {<EOL>                <EOL>                TestBed.configureTestingModule({ declarations: [IfExpanded, SimpleTest, TestCounter], providers: [Expand] });<EOL>                this.fixture = TestBed.createComponent(SimpleTest);<EOL>                this.fixture.detectChanges();<EOL>                this.testComponent = this.fixture.componentInstance;<EOL>                this.testElement = this.fixture.nativeElement;<EOL>                this.clarityDirective = this.fixture.componentInstance.ifExpanded;<EOL>                this.expand = TestBed.get(Expand);<EOL>            });<EOL>            afterEach(function () {<EOL>                this.fixture.destroy();<EOL>            });<EOL>            it(\"<STR_LIT>\", function () {<EOL>                expect(this.testElement.textContent.trim()).toBe(\"<STR_LIT>\");<EOL>            });<EOL>            it(\"<STR_LIT>\", function () {<EOL>                this.expand.expanded = true;<EOL>                this.fixture.detectChanges();<EOL>                expect(this.testElement.textContent.trim()).toBe(\"<STR_LIT>\");<EOL>            });<EOL>            it(\"<STR_LIT>\", function () {<EOL>                this.expand.expanded = true;<EOL>                this.fixture.detectChanges();<EOL>                this.expand.expanded = false;<EOL>                this.fixture.detectChanges();<EOL>                expect(this.testElement.textContent.trim()).toBe(\"<STR_LIT>\");<EOL>            });<EOL>            it(\"<STR_LIT>\", function () {<EOL>                expect(this.testComponent.counter.total).toBe(<NUM_LIT>);<EOL>            });<EOL>            it(\"<STR_LIT>\", function () {<EOL>                this.expand.expanded = true;<EOL>                this.fixture.detectChanges();<EOL>                expect(this.testElement.textContent.trim()).toBe(\"<STR_LIT>\");<EOL>                this.expand.expanded = false;<EOL>                this.fixture.detectChanges();<EOL>                this.expand.expanded = true;<EOL>                this.fixture.detectChanges();<EOL>                expect(this.testElement.textContent.trim()).toBe(\"<STR_LIT>\");<EOL>            });<EOL>        });<EOL>        describe(\"<STR_LIT>\", function () {<EOL>            beforeEach(function () {<EOL>                <EOL>                TestBed.configureTestingModule({ declarations: [IfExpanded, NgIfTest], providers: [Expand] });<EOL>                this.fixture = TestBed.createComponent(NgIfTest);<EOL>                this.fixture.detectChanges();<EOL>                this.testComponent = this.fixture.componentInstance;<EOL>                this.expand = TestBed.get(Expand);<EOL>            });<EOL>            afterEach(function () {<EOL>                this.fixture.destroy();<EOL>            });<EOL>            it(\"<STR_LIT>\", function () {<EOL>                expect(","gt":"this.expand.expandable).toBeGreaterThan(<NUM_LIT>);"}
{"input":"<s> export function ratioTopReady(container: HTMLElement, ignore: number = <NUM_LIT>): number {<EOL>","gt":"return (container.scrollTop - ignore) / container.clientHeight;"}
{"input":"<s> function toggleHideExplorerArrowsPresetCommand(): void {<EOL>    togglePreset(models.PresetNames.","gt":"hideExplorerArrows, '<STR_LIT>', true);"}
{"input":"<s> export function fileFormatToString(extension: FileFormat | string): string {<EOL>    return","gt":"'<STR_LIT>' ? extension.trim() : FileFormat[extension]}`<STR_LIT>;"}
{"input":"<s> <EOL>export function parseJSON(text: string): any {<EOL>    try {<EOL>        return","gt":"JSON.parse(text);"}
{"input":"<s> async function handleActiveEditorChange(): Promise<void> {<EOL>    if (configuration.disableExt) {<EOL>        return;<EOL>    }<EOL>    <EOL>    if (Globals.isTesting) {<EOL>        return;<EOL>    }<EOL>    taskQueue.enqueueTask(async (): Promise<void> => {<EOL>        if (vscode.window.activeTextEditor !== undefined) {<EOL>            const","gt":"mh: ModeHandler = await getAndUpdateModeHandler();"}
{"input":"<s> function handleContentChangedFromDisk(document: vscode.TextDocument): void {<EOL>    _.filter(ModeHandlerMap.getAll(), (modeHandler: any): boolean => modeHandler.","gt":"vimState.identity.fileName === document.fileName).forEach((modeHandler: any): void => {"}
{"input":"<s> function searchCurrentWord(position: Position, vimState: VimState, direction: SearchDirection, isExact: boolean): VimState {<EOL>    const currentWord: string | undefined = TextEditor.getWord(position);<EOL>    <EOL>    <EOL>    <EOL>    const searchStartCursorPosition:","gt":"Position = direction === SearchDirection.Backward"}
{"input":"<s> function searchCurrentWord(position: Position, vimState: VimState, direction: SearchDirection, isExact: boolean): VimState {<EOL>    const currentWord: string | undefined = TextEditor.getWord(position);<EOL>    <EOL>    <EOL>    <EOL>    const searchStartCursorPosition: Position = direction === SearchDirection.Backward<EOL>        ? vimState.cursorPosition.getWordLeft(true)<EOL>        : vimState.cursorPosition;<EOL>    return createSearchStateAndMoveToMatch({<EOL>        needle: currentWord,<EOL>        vimState,<EOL>","gt":"direction,"}
{"input":"<s> export function isIMovement(o: IMovement | Position): o is IMovement {<EOL>    return (o","gt":"as IMovement).start !== undefined && (o as IMovement).stop !== undefined;"}
{"input":"<s> export function parseWriteQuitAllCommandArgs(args: string): node.WriteQuitAllCommand {<EOL>    if (!args) {<EOL>        return new node.WriteQuitAllCommand({});<EOL>    }<EOL>    var scannedArgs: node.IWriteQuitAllCommandArguments = {};<EOL>    var scanner: Scanner = new Scanner(args);<EOL>    const","gt":"c: string = scanner.next();"}
{"input":"<s> export function parseWriteQuitAllCommandArgs(args: string): node.WriteQuitAllCommand {<EOL>    if (!args) {<EOL>        return new node.WriteQuitAllCommand({});<EOL>    }<EOL>    var scannedArgs: node.IWriteQuitAllCommandArguments = {};<EOL>    var scanner: Scanner = new Scanner(args);<EOL>    const c: string = scanner.next();<EOL>    if (c === '<STR_LIT>') {<EOL>        scannedArgs.bang = true;<EOL>        scanner.ignore();<EOL>    }<EOL>    else if (c !== '<STR_LIT>') {<EOL>        throw VimError.fromCode(ErrorCode.E488);<EOL>    }<EOL>","gt":"scanner.skipWhiteSpace();"}
{"input":"<s> <EOL>export function flattenAndFilterAst(node: StylusNode, scope: number[] = []): StylusNode[] {<EOL>    if (!node.__type) {<EOL>        return [];<EOL>    }<EOL>    (node as any)['<STR_LIT>'] = scope;<EOL>    let nested: StylusNode[] = [","gt":"node];"}
{"input":"<s> <EOL>export function flattenAndFilterAst(node: StylusNode, scope: number[] = []): StylusNode[] {<EOL>    if (!node.__type) {<EOL>        return [];<EOL>    }<EOL>    (node as any)['<STR_LIT>'] = scope;<EOL>    let nested: StylusNode[] = [node];<EOL>    if (node.nodes) {<EOL>        let i: number = <NUM_LIT>;<EOL>        for (const child: StylusNode of node.nodes) {<EOL>            const newScope: number[] = scope.concat(","gt":"i++);"}
{"input":"<s> <EOL>export function flattenAndFilterAst(node: StylusNode, scope: number[] = []): StylusNode[] {<EOL>    if (!node.__type) {<EOL>        return [];<EOL>    }<EOL>    (node as any)['<STR_LIT>'] = scope;<EOL>    let nested: StylusNode[] = [node];<EOL>    if (node.nodes) {<EOL>        let i: number = <NUM_LIT>;<EOL>        for (const child: StylusNode of node.nodes) {<EOL>            const newScope: number[] = scope.concat(i++);<EOL>            nested = nested.concat(flattenAndFilterAst(child, newScope));<EOL>        }<EOL>    }<EOL>    if (","gt":"node.block) {"}
{"input":"<s> <EOL>function processRawSymbols(rawSymbols: StylusNode[], text: string[]): SymbolInformation[] {<EOL>    return _.compact(rawSymbols.map((symNode: StylusNode): any => {<EOL>        if (isVariableNode(symNode)) {<EOL>            return _variableSymbol(symNode, text);<EOL>        }<EOL>        if (isFunctionNode(symNode)) {<EOL>            return","gt":"_functionSymbol(symNode, text);"}
{"input":"<s> function isBeforeOrEqual(pos1: Position, pos2: Position): boolean {<EOL>    return","gt":"pos1.line < pos2.line || (pos1.line === pos2.line && pos1.character <= pos2.character);"}
{"input":"<s> export function doValidation(document: TextDocument, engine: CLIEngine): Diagnostic[] {<EOL>    const rawText: any = document.getText();<EOL>    <EOL>    if (rawText.replace(/\\s/g, '<STR_LIT>') ===","gt":"'<STR_LIT>') {"}
{"input":"<s> export function getEnabledTagProviders(tagProviderSetting: CompletionConfiguration): IHTMLTagProvider[] {<EOL>    return allTagProviders.","gt":"filter((p: IHTMLTagProvider): boolean => tagProviderSetting[p.getId()] !== false);"}
{"input":"<s> export function hoverDSL(setup: HoverTestSetup): ([value]: TemplateStringsArray) => HoverAsserter {<EOL>    return function test([value]: TemplateStringsArray) {<EOL>        const offset: number = value.indexOf('<STR_LIT>');<EOL>        value = value.substr(<NUM_LIT>, offset) + value.","gt":"substr(offset + <NUM_LIT>);"}
{"input":"<s> <EOL><EOL><EOL><EOL>export function createDataLoader<T>(obj: ObjectType<T>, method?: string, key?: string): DataLoader<any, any> {<EOL>    let repository: any;<EOL>    try {<EOL>        repository = getCustomRepository<Repository<any>>(obj);<EOL>    }<EOL>","gt":"catch (errorRepo: unknown) {"}
{"input":"<s> <EOL><EOL><EOL><EOL>export function createDataLoader<T>(obj: ObjectType<T>, method?: string, key?: string): DataLoader<any, any> {<EOL>    let repository: any;<EOL>    try {<EOL>        repository = getCustomRepository<Repository<any>>(obj);<EOL>    }<EOL>    catch (errorRepo: unknown) {<EOL>        try {<EOL>            repository =","gt":"getRepository(obj);"}
{"input":"<s> <EOL>export function removeSuffix(value: string, suffix: string): string {<EOL>    return value.slice(<NUM_LIT>, value.length - suffix.","gt":"length);"}
{"input":"<s> export function isEmptyObject(obj: any): boolean {<EOL>    return obj &&","gt":"Object.keys(obj).length === <NUM_LIT> && obj.constructor === Object;"}
{"input":"<s> function invokeDeserializeHook(instance: any, json: any, type: any): void {<EOL>","gt":"if (type && typeof (type).OnDeserialized === \"<STR_LIT>\") {"}
{"input":"<s> function toEnd(node: any): any {<EOL>    if (node && node.tokenType !== undefined) {<EOL>        return node.endOffset! +","gt":"<NUM_LIT>;"}
{"input":"<s> function isNumber(thing: any): thing is number {<EOL>    return typeof","gt":"thing === \"<STR_LIT>\";"}
{"input":"<s> export function printPrefix(prefix: Prefix): RawValue[] {<EOL>    return prefix.","gt":"map((v: number): RawValue => GlobalInterner.reverse(v));"}
{"input":"<s> export function processUrlDependencies(meta: StylableMeta, rootContext: string, filter: (url: string, context: string) => boolean = defaultFilter): string[] {<EOL>    const importerDir: any = dirname(meta.source);<EOL>    const urls: string[] = [];<EOL>    const onUrl: (node: UrlNode) => void = (node: UrlNode): void => {<EOL>        const { url } =","gt":"node;"}
{"input":"<s> export function processUrlDependencies(meta: StylableMeta, rootContext: string, filter: (url: string, context: string) => boolean = defaultFilter): string[] {<EOL>    const importerDir: any = dirname(meta.source);<EOL>    const urls: string[] = [];<EOL>    const onUrl: (node: UrlNode) => void = (node: UrlNode): void => {<EOL>        const { url } = node;<EOL>        if (url && isAsset(url) && filter(url, importerDir)) {<EOL>            node.stringType = '<STR_LIT>';<EOL>","gt":"delete node.innerSpacingBefore;"}
{"input":"<s> export function processUrlDependencies(meta: StylableMeta, rootContext: string, filter: (url: string, context: string) => boolean = defaultFilter): string[] {<EOL>    const importerDir: any = dirname(meta.source);<EOL>    const urls: string[] = [];<EOL>    const onUrl: (node: UrlNode) => void = (node: UrlNode): void => {<EOL>        const { url } = node;<EOL>        if (url && isAsset(url) && filter(url, importerDir)) {<EOL>            node.stringType = '<STR_LIT>';<EOL>            delete node.innerSpacingBefore;<EOL>            delete node.innerSpacingAfter;<EOL>            node.url = `<STR_LIT>`;<EOL>            urls.push(makeAbsolute(url, rootContext, importerDir));<EOL>        }<EOL>    };<EOL>    meta.outputAst!.walkDecls((node: any): void => {<EOL>        processDeclarationFunctions(node, (functionNode: any): void => {<EOL>            if (functionNode.type === '<STR_LIT>') {<EOL>                onUrl(","gt":"functionNode);"}
{"input":"<s> function keyframesSymbolMapper([name, as]: [<EOL>    string,<EOL>    string<EOL>]): string {<EOL>    return","gt":"name === as ? `<STR_LIT>` : `<STR_LIT>`;"}
{"input":"<s> function getModuleFormats({ esm, cjs }: {<EOL>    [k: string]: boolean | undefined;<EOL>}): (\"<STR_LIT>\" | \"<STR_LIT>\")[] {<EOL>    const formats: Array<'<STR_LIT>' | '<STR_LIT>'> = [];<EOL>    if (esm) {<EOL>        formats.push(","gt":"'<STR_LIT>');"}
{"input":"<s> export function createDefaultOptions(): BuildOptions {<EOL>    return {<EOL>        outDir: '<STR_LIT>',<EOL>        srcDir: '<STR_LIT>',<EOL>        cjs: true,<EOL>        esm: false,<EOL>        dts:","gt":"false,"}
{"input":"<s> export function createDefaultOptions(): BuildOptions {<EOL>    return {<EOL>        outDir: '<STR_LIT>',<EOL>        srcDir: '<STR_LIT>',<EOL>        cjs: true,<EOL>        esm: false,<EOL>        dts: false,<EOL>        injectCSSRequest: false,<EOL>        optimize: false,<EOL>        minify: false,<EOL>","gt":"useNamespaceReference: false,"}
{"input":"<s> export function createDefaultOptions(): BuildOptions {<EOL>    return {<EOL>        outDir: '<STR_LIT>',<EOL>        srcDir: '<STR_LIT>',<EOL>        cjs: true,<EOL>        esm: false,<EOL>        dts: false,<EOL>        injectCSSRequest: false,<EOL>        optimize: false,<EOL>        minify: false,<EOL>        useNamespaceReference: false,<EOL>        diagnostics: true,<EOL>        outputCSS: false,<EOL>","gt":"includeCSSInJS: false,"}
{"input":"<s> function createSTCBuilderError(message: string): Error {<EOL>    return new Error(","gt":"message}`<STR_LIT>;"}
{"input":"<s> export function unbox<B extends Box<string, unknown>>(boxed: B | string, unboxPrimitives = true, customValues?: CustomTypes, node?: ParsedValue): any {<EOL>    if (typeof boxed === '<STR_LIT>') {<EOL>        return unboxPrimitives ? boxed : boxString(boxed);<EOL>    }<EOL>    else","gt":"if (typeof boxed === '<STR_LIT>' && boxed) {"}
{"input":"<s> export function matchSelectorTarget(sourceSelector: string, targetSelector: string): boolean {<EOL>    const a: SelectorChunk[][] = separateChunks(parseSelector(sourceSelector));<EOL>    const b: SelectorChunk[][] = separateChunks(parseSelector(targetSelector));<EOL>    if (a.length > <NUM_LIT>) {<EOL>        throw new","gt":"Error('<STR_LIT>');"}
{"input":"<s> export function matchSelectorTarget(sourceSelector: string, targetSelector: string): boolean {<EOL>    const a: SelectorChunk[][] = separateChunks(parseSelector(sourceSelector));<EOL>    const b: SelectorChunk[][] = separateChunks(parseSelector(targetSelector));<EOL>    if (a.length > <NUM_LIT>) {<EOL>        throw new Error('<STR_LIT>');<EOL>    }<EOL>    const lastChunkA: SelectorChunk = getLastChunk(a[<NUM_LIT>]);<EOL>    const relevantChunksA: nodeWithPseudo[] = groupClassesAndPseudoElements(filterChunkNodesByType(lastChunkA, ['<STR_LIT>', '<STR_LIT>', '<STR_LIT>']));<EOL>    return b.some((compoundSelector: SelectorChunk[]): boolean => {<EOL>        const lastChunkB: SelectorChunk = getLastChunk(compoundSelector);<EOL>        let relevantChunksB: nodeWithPseudo[] = groupClassesAndPseudoElements(","gt":"filterChunkNodesByType(lastChunkB, ['<STR_LIT>', '<STR_LIT>', '<STR_LIT>']));"}
{"input":"<s> function createUniqID(source: string, varName: string): string {<EOL>    return","gt":"source}: ${varName}`<STR_LIT>;"}
{"input":"<s> function isImportAs(space: ParsedValue, as: ParsedValue): boolean {<EOL>    return space?.type === '<STR_LIT>' && as?.type === '<STR_LIT>' && as?.value ===","gt":"'<STR_LIT>';"}
{"input":"<s> <EOL>export function scopeNestedSelector(scopeSelectorAst: ImmutableSelectorList, nestedSelectorAst: ImmutableSelectorList, rootScopeLevel = false): {<EOL>    selector: string;<EOL>    ast: SelectorList;<EOL>} {<EOL>    const resultSelectors: SelectorList = [];<EOL>","gt":"nestedSelectorAst.forEach((targetAst: any): void => {"}
{"input":"<s> <EOL>export function scopeNestedSelector(scopeSelectorAst: ImmutableSelectorList, nestedSelectorAst: ImmutableSelectorList, rootScopeLevel = false): {<EOL>    selector: string;<EOL>    ast: SelectorList;<EOL>} {<EOL>    const resultSelectors: SelectorList = [];<EOL>    nestedSelectorAst.forEach((targetAst: any): void => {<EOL>        scopeSelectorAst.forEach((scopeAst: any): void => {<EOL>            const outputAst: Selector = cloneDeep(targetAst) as Selector;<EOL>            outputAst.before = scopeAst.before || outputAst.","gt":"before;"}
{"input":"<s> <EOL>export function scopeNestedSelector(scopeSelectorAst: ImmutableSelectorList, nestedSelectorAst: ImmutableSelectorList, rootScopeLevel = false): {<EOL>    selector: string;<EOL>    ast: SelectorList;<EOL>} {<EOL>    const resultSelectors: SelectorList = [];<EOL>    nestedSelectorAst.forEach((targetAst: any): void => {<EOL>        scopeSelectorAst.forEach((scopeAst: any): void => {<EOL>            const outputAst: Selector = cloneDeep(targetAst) as Selector;<EOL>            outputAst.before = scopeAst.before || outputAst.before;<EOL>            let first: any = outputAst.nodes[<NUM_LIT>];<EOL>            <EOL>            walkSelector(outputAst, (node: any): any => {<EOL>                first = node;<EOL>                return","gt":"walkSelector.stopAll;"}
{"input":"<s> <EOL>export function scopeNestedSelector(scopeSelectorAst: ImmutableSelectorList, nestedSelectorAst: ImmutableSelectorList, rootScopeLevel = false): {<EOL>    selector: string;<EOL>    ast: SelectorList;<EOL>} {<EOL>    const resultSelectors: SelectorList = [];<EOL>    nestedSelectorAst.forEach((targetAst: any): void => {<EOL>        scopeSelectorAst.forEach((scopeAst: any): void => {<EOL>            const outputAst: Selector = cloneDeep(targetAst) as Selector;<EOL>            outputAst.before = scopeAst.before || outputAst.before;<EOL>            let first: any = outputAst.nodes[<NUM_LIT>];<EOL>            <EOL>            walkSelector(outputAst, (node: any): any => {<EOL>                first = node;<EOL>                return walkSelector.stopAll;<EOL>            }, { ignoreList: [`<STR_LIT>`] });<EOL>            const parentRef: boolean = first.type === `<STR_LIT>`;<EOL>            const globalSelector: boolean = first.type === `<STR_LIT>` && first.value === `<STR_LIT>`;<EOL>            const startWithScoping: any = rootScopeLevel<EOL>                ? scopeAst.nodes.every((node: any, i: any): boolean => {<EOL>                    return matchTypeAndValue(","gt":"node, outputAst.nodes[i]);"}
{"input":"<s> <EOL>export function scopeNestedSelector(scopeSelectorAst: ImmutableSelectorList, nestedSelectorAst: ImmutableSelectorList, rootScopeLevel = false): {<EOL>    selector: string;<EOL>    ast: SelectorList;<EOL>} {<EOL>    const resultSelectors: SelectorList = [];<EOL>    nestedSelectorAst.forEach((targetAst: any): void => {<EOL>        scopeSelectorAst.forEach((scopeAst: any): void => {<EOL>            const outputAst: Selector = cloneDeep(targetAst) as Selector;<EOL>            outputAst.before = scopeAst.before || outputAst.before;<EOL>            let first: any = outputAst.nodes[<NUM_LIT>];<EOL>            <EOL>            walkSelector(outputAst, (node: any): any => {<EOL>                first = node;<EOL>                return walkSelector.stopAll;<EOL>            }, { ignoreList: [`<STR_LIT>`] });<EOL>            const parentRef: boolean = first.type === `<STR_LIT>`;<EOL>            const globalSelector: boolean = first.type === `<STR_LIT>` && first.value === `<STR_LIT>`;<EOL>            const startWithScoping: any = rootScopeLevel<EOL>                ? scopeAst.nodes.every((node: any, i: any): boolean => {<EOL>                    return matchTypeAndValue(node, outputAst.nodes[i]);<EOL>                })<EOL>                : false;<EOL>            let nestedMixRoot: boolean = false;<EOL>            walkSelector(outputAst, (node: any, i: any, nodes: any): void => {<EOL>                if (node.type ===","gt":"'<STR_LIT>') {"}
{"input":"<s> <EOL>export function scopeNestedSelector(scopeSelectorAst: ImmutableSelectorList, nestedSelectorAst: ImmutableSelectorList, rootScopeLevel = false): {<EOL>    selector: string;<EOL>    ast: SelectorList;<EOL>} {<EOL>    const resultSelectors: SelectorList = [];<EOL>    nestedSelectorAst.forEach((targetAst: any): void => {<EOL>        scopeSelectorAst.forEach((scopeAst: any): void => {<EOL>            const outputAst: Selector = cloneDeep(targetAst) as Selector;<EOL>            outputAst.before = scopeAst.before || outputAst.before;<EOL>            let first: any = outputAst.nodes[<NUM_LIT>];<EOL>            <EOL>            walkSelector(outputAst, (node: any): any => {<EOL>                first = node;<EOL>                return walkSelector.stopAll;<EOL>            }, { ignoreList: [`<STR_LIT>`] });<EOL>            const parentRef: boolean = first.type === `<STR_LIT>`;<EOL>            const globalSelector: boolean = first.type === `<STR_LIT>` && first.value === `<STR_LIT>`;<EOL>            const startWithScoping: any = rootScopeLevel<EOL>                ? scopeAst.nodes.every((node: any, i: any): boolean => {<EOL>                    return matchTypeAndValue(node, outputAst.nodes[i]);<EOL>                })<EOL>                : false;<EOL>            let nestedMixRoot: boolean = false;<EOL>            walkSelector(outputAst, (node: any, i: any, nodes: any): void => {<EOL>                if (node.type === '<STR_LIT>') {<EOL>                    nestedMixRoot = true;<EOL>                    nodes.splice(i, <NUM_LIT>, {<EOL>                        type: `<STR_LIT>`,<EOL>                        nodes: cloneDeep(scopeAst.nodes as SelectorNode[]),<EOL>                        start: node.start,<EOL>                        end: node.end,<EOL>","gt":"after: `<STR_LIT>`,"}
{"input":"<s> <EOL>export function scopeNestedSelector(scopeSelectorAst: ImmutableSelectorList, nestedSelectorAst: ImmutableSelectorList, rootScopeLevel = false): {<EOL>    selector: string;<EOL>    ast: SelectorList;<EOL>} {<EOL>    const resultSelectors: SelectorList = [];<EOL>    nestedSelectorAst.forEach((targetAst: any): void => {<EOL>        scopeSelectorAst.forEach((scopeAst: any): void => {<EOL>            const outputAst: Selector = cloneDeep(targetAst) as Selector;<EOL>            outputAst.before = scopeAst.before || outputAst.before;<EOL>            let first: any = outputAst.nodes[<NUM_LIT>];<EOL>            <EOL>            walkSelector(outputAst, (node: any): any => {<EOL>                first = node;<EOL>                return walkSelector.stopAll;<EOL>            }, { ignoreList: [`<STR_LIT>`] });<EOL>            const parentRef: boolean = first.type === `<STR_LIT>`;<EOL>            const globalSelector: boolean = first.type === `<STR_LIT>` && first.value === `<STR_LIT>`;<EOL>            const startWithScoping: any = rootScopeLevel<EOL>                ? scopeAst.nodes.every((node: any, i: any): boolean => {<EOL>                    return matchTypeAndValue(node, outputAst.nodes[i]);<EOL>                })<EOL>                : false;<EOL>            let nestedMixRoot: boolean = false;<EOL>            walkSelector(outputAst, (node: any, i: any, nodes: any): void => {<EOL>                if (node.type === '<STR_LIT>') {<EOL>                    nestedMixRoot = true;<EOL>                    nodes.splice(i, <NUM_LIT>, {<EOL>                        type: `<STR_LIT>`,<EOL>                        nodes: cloneDeep(scopeAst.nodes as SelectorNode[]),<EOL>                        start: node.start,<EOL>                        end: node.end,<EOL>                        after: `<STR_LIT>`,<EOL>                        before: `<STR_LIT>`,<EOL>                    });<EOL>                }<EOL>            });<EOL>            if (first && !parentRef && !startWithScoping && !globalSelector && !nestedMixRoot) {<EOL>                outputAst.nodes.unshift(...cloneDeep(scopeAst.nodes as SelectorNode[]), {<EOL>                    type: `<STR_LIT>`,<EOL>                    combinator: `<STR_LIT>`,<EOL>                    value: `<STR_LIT>`,<EOL>                    before: `<STR_LIT>`,<EOL>                    after: `<STR_LIT>`,<EOL>                    start: first.start,<EOL>                    end: first.start,<EOL>                    invalid: false,<EOL>                });<EOL>            }<EOL>            resultSelectors.","gt":"push(outputAst);"}
{"input":"<s> export function listOptions(node: any): any[] {<EOL>    return groupValues(node.nodes)<EOL>        .map((nodes: any): any => postcssValueParser.stringify(nodes, (n: any): any => {<EOL>        if (n.type === '<STR_LIT>') {<EOL>","gt":"return null;"}
{"input":"<s> export function listOptions(node: any): any[] {<EOL>    return groupValues(node.nodes)<EOL>        .map((nodes: any): any => postcssValueParser.stringify(nodes, (n: any): any => {<EOL>        if (n.type === '<STR_LIT>') {<EOL>            return null;<EOL>        }<EOL>        else if (n.type === '<STR_LIT>') {<EOL>            return n.value;<EOL>        }<EOL>        else {<EOL>            return","gt":"undefined;"}
{"input":"<s> export function createStateWithParamClassName(stateName: string, namespace: string, param: string): string {<EOL>    const escapedNamespace: any = cssesc(","gt":"namespace, { isIdentifier: true });"}
{"input":"<s> function resolveParam(meta: StylableMeta, resolver: StylableResolver, diagnostics: Diagnostics, rule?: postcss.Rule, nodeContent?: string): string {<EOL>    const defaultStringValue:","gt":"string = '<STR_LIT>';"}
{"input":"<s> function resolveStateValue(meta: StylableMeta, resolver: StylableResolver, diagnostics: Diagnostics, rule: postcss.Rule | undefined, node: PseudoClass, stateDef: StateParsedValue, name: string, namespace: string): void {<EOL>    const inputValue: any = node.nodes && node.nodes.length ? stringifySelector(node.nodes) : `<STR_LIT>`;<EOL>    let actualParam: string = resolveParam(meta, resolver, diagnostics, rule, inputValue ? inputValue : stateDef.defaultValue);<EOL>    if (rule && !inputValue && !stateDef.defaultValue) {<EOL>        diagnostics.warn(rule, stateErrors.NO_STATE_ARGUMENT_GIVEN(name, stateDef.type), {<EOL>            word:","gt":"name,"}
{"input":"<s> function resolveStateValue(meta: StylableMeta, resolver: StylableResolver, diagnostics: Diagnostics, rule: postcss.Rule | undefined, node: PseudoClass, stateDef: StateParsedValue, name: string, namespace: string): void {<EOL>    const inputValue: any = node.nodes && node.nodes.length ? stringifySelector(node.nodes) : `<STR_LIT>`;<EOL>    let actualParam: string = resolveParam(meta, resolver, diagnostics, rule, inputValue ? inputValue : stateDef.defaultValue);<EOL>    if (rule && !inputValue && !stateDef.defaultValue) {<EOL>        diagnostics.warn(rule, stateErrors.NO_STATE_ARGUMENT_GIVEN(name, stateDef.type), {<EOL>            word: name,<EOL>        });<EOL>    }<EOL>","gt":"const validator: import(\"<STR_LIT>\").StateParamType = systemValidators[stateDef.type];"}
{"input":"<s> function resolveStateValue(meta: StylableMeta, resolver: StylableResolver, diagnostics: Diagnostics, rule: postcss.Rule | undefined, node: PseudoClass, stateDef: StateParsedValue, name: string, namespace: string): void {<EOL>    const inputValue: any = node.nodes && node.nodes.length ? stringifySelector(node.nodes) : `<STR_LIT>`;<EOL>    let actualParam: string = resolveParam(meta, resolver, diagnostics, rule, inputValue ? inputValue : stateDef.defaultValue);<EOL>    if (rule && !inputValue && !stateDef.defaultValue) {<EOL>        diagnostics.warn(rule, stateErrors.NO_STATE_ARGUMENT_GIVEN(name, stateDef.type), {<EOL>            word: name,<EOL>        });<EOL>    }<EOL>    const validator: import(\"<STR_LIT>\").StateParamType = systemValidators[stateDef.type];<EOL>    let stateParamOutput: any;<EOL>    try {<EOL>        stateParamOutput = validator.validate(actualParam, stateDef.arguments, resolveParam.","gt":"bind(null, meta, resolver, diagnostics, rule), false, true);"}
{"input":"<s> function resolveStateValue(meta: StylableMeta, resolver: StylableResolver, diagnostics: Diagnostics, rule: postcss.Rule | undefined, node: PseudoClass, stateDef: StateParsedValue, name: string, namespace: string): void {<EOL>    const inputValue: any = node.nodes && node.nodes.length ? stringifySelector(node.nodes) : `<STR_LIT>`;<EOL>    let actualParam: string = resolveParam(meta, resolver, diagnostics, rule, inputValue ? inputValue : stateDef.defaultValue);<EOL>    if (rule && !inputValue && !stateDef.defaultValue) {<EOL>        diagnostics.warn(rule, stateErrors.NO_STATE_ARGUMENT_GIVEN(name, stateDef.type), {<EOL>            word: name,<EOL>        });<EOL>    }<EOL>    const validator: import(\"<STR_LIT>\").StateParamType = systemValidators[stateDef.type];<EOL>    let stateParamOutput: any;<EOL>    try {<EOL>        stateParamOutput = validator.validate(actualParam, stateDef.arguments, resolveParam.bind(null, meta, resolver, diagnostics, rule), false, true);<EOL>    }<EOL>    catch (e: unknown) {<EOL>        <EOL>    }<EOL>    if (stateParamOutput !== undefined) {<EOL>        if (stateParamOutput.res !== actualParam) {<EOL>            actualParam = stateParamOutput.res;<EOL>        }<EOL>        if (rule && stateParamOutput.","gt":"errors) {"}
{"input":"<s> function test(desc: string, src: string, expected: string[], allowComments: boolean = false, expectedWarnings?: string[]): void {<EOL>    it(desc, (): void => {<EOL>        const actualWarnings: string[] = [];<EOL>        const [firstNode] = postcssValueParser(","gt":"src).nodes;"}
{"input":"<s> export function flatMatch(chai: Chai.ChaiStatic, util: Chai.ChaiUtils): void {<EOL>    const { flag } = util;<EOL>    chai.Assertion.","gt":"addMethod('<STR_LIT>', function (obj: Record<string, unknown>, maxDepth = <NUM_LIT>) {"}
{"input":"<s> export function matchRuleAndDeclaration(parent: postcss.Container, selectorIndex: number, selector: string, decl: string, msg?: string): void {<EOL>    const rule: postcss.Rule = parent.nodes[selectorIndex] as postcss.Rule;<EOL>    if (rule.selector !== selector) {<EOL>        throw new Error(","gt":"'<STR_LIT>' : '<STR_LIT>'}selector ${selectorIndex}\\nactual: ${rule.selector}\\nexpected: ${selector}`<STR_LIT>;"}
{"input":"<s> export function configLoadAssets(): {<EOL>    test: RegExp;<EOL>    use: {<EOL>        loader: string;<EOL>        options: {<EOL>            limit: number;<EOL>        };<EOL>    }[];<EOL>}[] {<EOL>    return [<EOL>        {<EOL>            test: /\\.(png|jpg|gif)$/,<EOL>","gt":"use: ["}
{"input":"<s> function findMatchingStylableInstance(initialConfig: StylableConfig, stylableInstances: Map<Stylable, StylableConfig>): any {<EOL>    const entries: [<EOL>        string | number | symbol,<EOL>        unknown<EOL>    ][] = Object.entries(","gt":"initialConfig) as ["}
{"input":"<s> function findMatchingStylableInstance(initialConfig: StylableConfig, stylableInstances: Map<Stylable, StylableConfig>): any {<EOL>    const entries: [<EOL>        string | number | symbol,<EOL>        unknown<EOL>    ][] = Object.entries(initialConfig) as [<EOL>        keyof StylableConfig,<EOL>        unknown<EOL>    ][];<EOL>    for (const [instance, config] of stylableInstances) {<EOL>        if (entries.every(([key, value]) => config[key] === value)) {<EOL>            return","gt":"instance;"}
{"input":"<s> export function lspFormattingOptionsToJsBeautifyOptions(options: FormattingOptions): CSSBeautifyOptions {<EOL>    return {<EOL>        indent_size:","gt":"options.tabSize,"}
{"input":"<s> export function fixAndProcess(src: string, position: ProviderPosition, filePath: string): {<EOL>    processed: {<EOL>        meta: StylableMeta;<EOL>        fakes: postcss.Rule[];<EOL>    };<EOL>    currentLine: string;<EOL>    cursorLineIndex: number;<EOL>} {<EOL>    let cursorLineIndex: number = position.character;<EOL>    const lines: string[] = src.replace(/\\r\\n/g, '<STR_LIT>').split('<STR_LIT>');<EOL>    let currentLine: string = lines[position.","gt":"line];"}
{"input":"<s> export function fixAndProcess(src: string, position: ProviderPosition, filePath: string): {<EOL>    processed: {<EOL>        meta: StylableMeta;<EOL>        fakes: postcss.Rule[];<EOL>    };<EOL>    currentLine: string;<EOL>    cursorLineIndex: number;<EOL>} {<EOL>    let cursorLineIndex: number = position.character;<EOL>    const lines: string[] = src.replace(/\\r\\n/g, '<STR_LIT>').split('<STR_LIT>');<EOL>    let currentLine: string = lines[position.line];<EOL>    let fixedSrc: string = src;<EOL>    if (currentLine.match(lineEndsRegexp)) {<EOL>        let currentLocation: number = <NUM_LIT>;<EOL>        const splitLine: string[] = currentLine.split(","gt":"lineEndsRegexp);"}
{"input":"<s> export function fixAndProcess(src: string, position: ProviderPosition, filePath: string): {<EOL>    processed: {<EOL>        meta: StylableMeta;<EOL>        fakes: postcss.Rule[];<EOL>    };<EOL>    currentLine: string;<EOL>    cursorLineIndex: number;<EOL>} {<EOL>    let cursorLineIndex: number = position.character;<EOL>    const lines: string[] = src.replace(/\\r\\n/g, '<STR_LIT>').split('<STR_LIT>');<EOL>    let currentLine: string = lines[position.line];<EOL>    let fixedSrc: string = src;<EOL>    if (currentLine.match(lineEndsRegexp)) {<EOL>        let currentLocation: number = <NUM_LIT>;<EOL>        const splitLine: string[] = currentLine.split(lineEndsRegexp);<EOL>        for (let i: number = <NUM_LIT>; i < splitLine.length; i += <NUM_LIT>) {<EOL>            currentLocation += splitLine[i].length + <NUM_LIT>;<EOL>            if (currentLocation >= position.character) {<EOL>                currentLine = splitLine[","gt":"i];"}
{"input":"<s> export function fixAndProcess(src: string, position: ProviderPosition, filePath: string): {<EOL>    processed: {<EOL>        meta: StylableMeta;<EOL>        fakes: postcss.Rule[];<EOL>    };<EOL>    currentLine: string;<EOL>    cursorLineIndex: number;<EOL>} {<EOL>    let cursorLineIndex: number = position.character;<EOL>    const lines: string[] = src.replace(/\\r\\n/g, '<STR_LIT>').split('<STR_LIT>');<EOL>    let currentLine: string = lines[position.line];<EOL>    let fixedSrc: string = src;<EOL>    if (currentLine.match(lineEndsRegexp)) {<EOL>        let currentLocation: number = <NUM_LIT>;<EOL>        const splitLine: string[] = currentLine.split(lineEndsRegexp);<EOL>        for (let i: number = <NUM_LIT>; i < splitLine.length; i += <NUM_LIT>) {<EOL>            currentLocation += splitLine[i].length + <NUM_LIT>;<EOL>            if (currentLocation >= position.character) {<EOL>                currentLine = splitLine[i];<EOL>                if (","gt":"isIllegalLine(currentLine)) {"}
{"input":"<s> export function fixAndProcess(src: string, position: ProviderPosition, filePath: string): {<EOL>    processed: {<EOL>        meta: StylableMeta;<EOL>        fakes: postcss.Rule[];<EOL>    };<EOL>    currentLine: string;<EOL>    cursorLineIndex: number;<EOL>} {<EOL>    let cursorLineIndex: number = position.character;<EOL>    const lines: string[] = src.replace(/\\r\\n/g, '<STR_LIT>').split('<STR_LIT>');<EOL>    let currentLine: string = lines[position.line];<EOL>    let fixedSrc: string = src;<EOL>    if (currentLine.match(lineEndsRegexp)) {<EOL>        let currentLocation: number = <NUM_LIT>;<EOL>        const splitLine: string[] = currentLine.split(lineEndsRegexp);<EOL>        for (let i: number = <NUM_LIT>; i < splitLine.length; i += <NUM_LIT>) {<EOL>            currentLocation += splitLine[i].length + <NUM_LIT>;<EOL>            if (currentLocation >= position.character) {<EOL>                currentLine = splitLine[i];<EOL>                if (isIllegalLine(currentLine)) {<EOL>                    splitLine[i] = '<STR_LIT>';<EOL>                    lines.splice(position.line, <NUM_LIT>, splitLine.join('<STR_LIT>'));<EOL>","gt":"fixedSrc = lines.join('<STR_LIT>');"}
{"input":"<s> export function fixAndProcess(src: string, position: ProviderPosition, filePath: string): {<EOL>    processed: {<EOL>        meta: StylableMeta;<EOL>        fakes: postcss.Rule[];<EOL>    };<EOL>    currentLine: string;<EOL>    cursorLineIndex: number;<EOL>} {<EOL>    let cursorLineIndex: number = position.character;<EOL>    const lines: string[] = src.replace(/\\r\\n/g, '<STR_LIT>').split('<STR_LIT>');<EOL>    let currentLine: string = lines[position.line];<EOL>    let fixedSrc: string = src;<EOL>    if (currentLine.match(lineEndsRegexp)) {<EOL>        let currentLocation: number = <NUM_LIT>;<EOL>        const splitLine: string[] = currentLine.split(lineEndsRegexp);<EOL>        for (let i: number = <NUM_LIT>; i < splitLine.length; i += <NUM_LIT>) {<EOL>            currentLocation += splitLine[i].length + <NUM_LIT>;<EOL>            if (currentLocation >= position.character) {<EOL>                currentLine = splitLine[i];<EOL>                if (isIllegalLine(currentLine)) {<EOL>                    splitLine[i] = '<STR_LIT>';<EOL>                    lines.splice(position.line, <NUM_LIT>, splitLine.join('<STR_LIT>'));<EOL>                    fixedSrc = lines.join('<STR_LIT>');<EOL>                }<EOL>                break;<EOL>            }<EOL>            else {<EOL>                cursorLineIndex -= splitLine[i].","gt":"length + <NUM_LIT>;"}
{"input":"<s> export function fixAndProcess(src: string, position: ProviderPosition, filePath: string): {<EOL>    processed: {<EOL>        meta: StylableMeta;<EOL>        fakes: postcss.Rule[];<EOL>    };<EOL>    currentLine: string;<EOL>    cursorLineIndex: number;<EOL>} {<EOL>    let cursorLineIndex: number = position.character;<EOL>    const lines: string[] = src.replace(/\\r\\n/g, '<STR_LIT>').split('<STR_LIT>');<EOL>    let currentLine: string = lines[position.line];<EOL>    let fixedSrc: string = src;<EOL>    if (currentLine.match(lineEndsRegexp)) {<EOL>        let currentLocation: number = <NUM_LIT>;<EOL>        const splitLine: string[] = currentLine.split(lineEndsRegexp);<EOL>        for (let i: number = <NUM_LIT>; i < splitLine.length; i += <NUM_LIT>) {<EOL>            currentLocation += splitLine[i].length + <NUM_LIT>;<EOL>            if (currentLocation >= position.character) {<EOL>                currentLine = splitLine[i];<EOL>                if (isIllegalLine(currentLine)) {<EOL>                    splitLine[i] = '<STR_LIT>';<EOL>                    lines.splice(position.line, <NUM_LIT>, splitLine.join('<STR_LIT>'));<EOL>                    fixedSrc = lines.join('<STR_LIT>');<EOL>                }<EOL>                break;<EOL>            }<EOL>            else {<EOL>                cursorLineIndex -= splitLine[i].length + <NUM_LIT>;<EOL>            }<EOL>        }<EOL>    }<EOL>    else if (isIllegalLine(currentLine)) {<EOL>        lines.splice(position.line, <NUM_LIT>, '<STR_LIT>');<EOL>        fixedSrc = lines.join('<STR_LIT>');<EOL>    }<EOL>","gt":"const processed: {"}
{"input":"<s> export function isSelector(node: postcss.Node): node is postcss.Rule {<EOL>    return hasOwnProperty.call(node,","gt":"'<STR_LIT>');"}
{"input":"<s> function getCSSAndPosition(css: string): {<EOL>    css: string;<EOL>    pos: any;<EOL>} {<EOL>    const pos: any = getCaretPosition(","gt":"css);"}
{"input":"<s> export function getPath(fileName: string): postcss.Node[] {<EOL>    const fullPath: any = path.join(CASES_PATH, fileName);<EOL>","gt":"let src: string = fs.readFileSync(fullPath).toString();"}
{"input":"<s> export function getReferences(fileName: string, pos: ProviderPosition): Location[] {<EOL>    const fullPath: any = path.","gt":"join(CASES_PATH, fileName);"}
{"input":"<s> export function moduleFactoryTestKit(files: IDirectoryContents, options: Partial<Options> = {}): {<EOL>    fs: any;<EOL>    factory: any;<EOL>    evalStylableModule: typeof evalStylableModule;<EOL>} {<EOL>    const fs: any = createMemoryFs(files);<EOL>    const factory: any = stylableModuleFactory({<EOL>        resolveNamespace: (namespace: any): any => namespace,<EOL>        fileSystem:","gt":"fs,"}
{"input":"<s> export function moduleFactoryTestKit(files: IDirectoryContents, options: Partial<Options> = {}): {<EOL>    fs: any;<EOL>    factory: any;<EOL>    evalStylableModule: typeof evalStylableModule;<EOL>} {<EOL>    const fs: any = createMemoryFs(files);<EOL>    const factory: any = stylableModuleFactory({<EOL>        resolveNamespace: (namespace: any): any => namespace,<EOL>        fileSystem: fs,<EOL>        projectRoot: '<STR_LIT>',<EOL>    }, options);<EOL>    return {<EOL>        fs,<EOL>","gt":"factory,"}
{"input":"<s> export function todoFilterReducer(state: (todo: Todo) => Todo = (todo: Todo): Todo => todo, action: Action): (todo: any) => any {<EOL>    switch (action.type) {<EOL>        case VisibilityFilters.SHOW_ALL:<EOL>            return (todo: any): any => todo;<EOL>","gt":"case VisibilityFilters.SHOW_ACTIVE:"}
{"input":"<s> export function todoFilterReducer(state: (todo: Todo) => Todo = (todo: Todo): Todo => todo, action: Action): (todo: any) => any {<EOL>    switch (action.type) {<EOL>        case VisibilityFilters.SHOW_ALL:<EOL>            return (todo: any): any => todo;<EOL>        case VisibilityFilters.SHOW_ACTIVE:<EOL>            return (todo: any): boolean => !todo.completed;<EOL>        case VisibilityFilters.SHOW_COMPLETED:<EOL>            return (todo: any): any => todo.completed;<EOL>","gt":"default:"}
{"input":"<s> export function type<T>(label: T | '<STR_LIT>'): T {<EOL>    if (typeCache[<string>label]) {<EOL>","gt":"throw new Error(`<STR_LIT>`);"}
{"input":"<s> export function hideBorderAndModify(left_border_to_hide_size: number, right_border_to_hide_size: number, changeCharInfo: (char_info: CharInfo) => void): (info: Array<CharInfo>) => void {<EOL>    return function (info: Array<CharInfo>) {<EOL>        info.slice(<NUM_LIT>, left_border_to_hide_size).forEach((char_info: CharInfo): void => {<EOL>            char_info.renderOptions.","gt":"classes[hiddenClass] = true;"}
{"input":"<s> <EOL>export function toggleFullScreen(term: Terminal, fullscreen: boolean): void {<EOL>    let fn: string;<EOL>    if (typeof fullscreen === '<STR_LIT>') {<EOL>        fn = (term.element.classList.contains('<STR_LIT>')) ? '<STR_LIT>' : '<STR_LIT>';<EOL>    }<EOL>    else if (!fullscreen) {<EOL>        fn = '<STR_LIT>';<EOL>    }<EOL>    else {<EOL>        fn =","gt":"'<STR_LIT>';"}
{"input":"<s> function configEquals(a: ICharAtlasConfig, b: ICharAtlasConfig): boolean {<EOL>    for (let i: number = <NUM_LIT>; i < a.colors.ansi.length; i++) {<EOL>        if (a.colors.ansi[i] !== b.colors.ansi[i]) {<EOL>            return false;<EOL>        }<EOL>    }<EOL>    return a.fontFamily === b.fontFamily &&<EOL>        a.fontSize === b.fontSize &&<EOL>        a.fontWeight === b.fontWeight &&<EOL>        a.fontWeightBold === b.fontWeightBold &&<EOL>        a.allowTransparency === b.allowTransparency &&<EOL>        a.scaledCharWidth ===","gt":"b.scaledCharWidth &&"}
{"input":"<s> export function classNames(...args: Array<string | Lookup<any>>): string {<EOL>    var classes: string[] = [];<EOL>    for (var arg: any of args) {<EOL>        if (!arg)<EOL>            continue;<EOL>","gt":"var argType: string = typeof arg;"}
{"input":"<s> export function classNames(...args: Array<string | Lookup<any>>): string {<EOL>    var classes: string[] = [];<EOL>    for (var arg: any of args) {<EOL>        if (!arg)<EOL>            continue;<EOL>        var argType: string = typeof arg;<EOL>        if (argType === '<STR_LIT>') {<EOL>            classes.push(arg as string);<EOL>        }<EOL>        else if (","gt":"argType === '<STR_LIT>') {"}
{"input":"<s> function valueEquals(v1: any, v2: any): boolean {<EOL>    if (v1 === v2)<EOL>        return true;<EOL>","gt":"if (!v1 !== !v2)"}
{"input":"<s> function filterFromLongForm(longForm: LongForm): Expression {<EOL>    var { metricColumn, measures } = longForm;<EOL>    var values: string[] = [];<EOL>    for (var measure: MeasureJS | LongFormMeasure of","gt":"measures) {"}
{"input":"<s> function selectionsEqual(a: any, b: any): any {<EOL>    if (!Boolean(a) === Boolean(b))<EOL>        return false;<EOL>    if (a === b)<EOL>","gt":"return true;"}
{"input":"<s> function selectionsEqual(a: any, b: any): any {<EOL>    if (!Boolean(a) === Boolean(b))<EOL>        return false;<EOL>    if (a === b)<EOL>        return true;<EOL>    if (!a !== !b)<EOL>        return false;<EOL>    if (typeof a !== typeof b)<EOL>        return false;<EOL>    if (typeof","gt":"a === '<STR_LIT>' && typeof b === '<STR_LIT>')"}
{"input":"<s> export function getNumberOfWholeDigits(n: number): number {<EOL>    return Math.max(Math.floor(log10(","gt":"Math.abs(n))), <NUM_LIT>) + <NUM_LIT>;"}
{"input":"<s> function yamlPropAdder(lines: string[], withComments: boolean, options: PropAdderOptions): void {<EOL>    const { object, propName, defaultValue, comment } = options;<EOL>    var value: any = object[propName];<EOL>    if (value == null) {<EOL>        if (withComments &&","gt":"typeof defaultValue !== \"<STR_LIT>\") {"}
{"input":"<s> function yamlPropAdder(lines: string[], withComments: boolean, options: PropAdderOptions): void {<EOL>    const { object, propName, defaultValue, comment } = options;<EOL>    var value: any = object[propName];<EOL>    if (value == null) {<EOL>        if (withComments && typeof defaultValue !== \"<STR_LIT>\") {<EOL>            lines.push('<STR_LIT>', `<STR_LIT>`, `<STR_LIT>`);<EOL>        }<EOL>    }<EOL>    else {<EOL>        if (withComments)<EOL>","gt":"lines.push('<STR_LIT>', `<STR_LIT>`);"}
{"input":"<s> function addRoutes(attach: string, router: Router | Handler): void {<EOL>    app.use(","gt":"attach, router);"}
{"input":"<s> function exitWithError(message: string): void {<EOL>","gt":"console.error(message);"}
{"input":"<s> function exitWithMessage(message: string): void {<EOL>    console.log(message);<EOL>    <EOL>","gt":"try {"}
{"input":"<s> <EOL>function trackAndReplaceWithResolvedValue(tracking: Promise<any>[]): (obj: any, key: any) => void {<EOL>    <EOL>    return (obj: any, key: any): void => {<EOL>        <EOL>        var val: any = obj[key];<EOL>","gt":"if (!val)"}
{"input":"<s> <EOL>function trackAndReplaceWithResolvedValue(tracking: Promise<any>[]): (obj: any, key: any) => void {<EOL>    <EOL>    return (obj: any, key: any): void => {<EOL>        <EOL>        var val: any = obj[key];<EOL>        if (!val)<EOL>            return;<EOL>        <EOL>        if (_.isFunction(val))<EOL>            val = thunkToPromise(","gt":"val);"}
{"input":"<s> <EOL>function trackAndReplaceWithResolvedValue(tracking: Promise<any>[]): (obj: any, key: any) => void {<EOL>    <EOL>    return (obj: any, key: any): void => {<EOL>        <EOL>        var val: any = obj[key];<EOL>        if (!val)<EOL>            return;<EOL>        <EOL>        if (_.isFunction(val))<EOL>            val = thunkToPromise(val);<EOL>        <EOL>        if (_.isFunction(val.then)) {<EOL>            tracking.","gt":"push(val);"}
{"input":"<s> export function* syncMoreComments({ payload }: any): Generator<any, void, unknown> {<EOL>    const comments: unknown = yield select(commentSelector);<EOL>    const commentsState: any = comments[payload];<EOL>    if (commentsState && commentsState.more) {<EOL>        yield put({<EOL>            type: '<STR_LIT>'<EOL>        });<EOL>        const offset: any = commentsState.offset + <NUM_LIT>;<EOL>        const response: api.IComments = yield* ajaxCall(api.getComments, payload, '<STR_LIT>', offset.toString());<EOL>        if (","gt":"response.code === <NUM_LIT>) {"}
{"input":"<s> export function* syncMoreComments({ payload }: any): Generator<any, void, unknown> {<EOL>    const comments: unknown = yield select(commentSelector);<EOL>    const commentsState: any = comments[payload];<EOL>    if (commentsState && commentsState.more) {<EOL>        yield put({<EOL>            type: '<STR_LIT>'<EOL>        });<EOL>        const offset: any = commentsState.offset + <NUM_LIT>;<EOL>        const response: api.IComments = yield* ajaxCall(api.getComments, payload, '<STR_LIT>', offset.toString());<EOL>        if (response.code === <NUM_LIT>) {<EOL>            yield put({<EOL>                type: '<STR_LIT>',<EOL>","gt":"payload: {"}
{"input":"<s> export function* syncMoreComments({ payload }: any): Generator<any, void, unknown> {<EOL>    const comments: unknown = yield select(commentSelector);<EOL>    const commentsState: any = comments[payload];<EOL>    if (commentsState && commentsState.more) {<EOL>        yield put({<EOL>            type: '<STR_LIT>'<EOL>        });<EOL>        const offset: any = commentsState.offset + <NUM_LIT>;<EOL>        const response: api.IComments = yield* ajaxCall(api.getComments, payload, '<STR_LIT>', offset.toString());<EOL>        if (response.code === <NUM_LIT>) {<EOL>            yield put({<EOL>                type: '<STR_LIT>',<EOL>                payload: {<EOL>                    [payload]: {<EOL>                        ...response,<EOL>                        hotComments:","gt":"commentsState.hotComments,"}
{"input":"<s> export function* syncMoreComments({ payload }: any): Generator<any, void, unknown> {<EOL>    const comments: unknown = yield select(commentSelector);<EOL>    const commentsState: any = comments[payload];<EOL>    if (commentsState && commentsState.more) {<EOL>        yield put({<EOL>            type: '<STR_LIT>'<EOL>        });<EOL>        const offset: any = commentsState.offset + <NUM_LIT>;<EOL>        const response: api.IComments = yield* ajaxCall(api.getComments, payload, '<STR_LIT>', offset.toString());<EOL>        if (response.code === <NUM_LIT>) {<EOL>            yield put({<EOL>                type: '<STR_LIT>',<EOL>                payload: {<EOL>                    [payload]: {<EOL>                        ...response,<EOL>                        hotComments: commentsState.hotComments,<EOL>                        comments: commentsState.comments.concat(response.comments),<EOL>                        offset<EOL>                    }<EOL>                }<EOL>            });<EOL>        }<EOL>","gt":"yield put({"}
{"input":"<s> export function refreshResource(action: string, caller: () => Promise<any>, width: number = <NUM_LIT>, limit: string = '<STR_LIT>'): () => Generator<any, void, unknown> {<EOL>    <EOL>    return function* () {<EOL>        yield put({<EOL>            type:","gt":"action}/refresh/start`<STR_LIT>`"}
{"input":"<s> export function refreshResource(action: string, caller: () => Promise<any>, width: number = <NUM_LIT>, limit: string = '<STR_LIT>'): () => Generator<any, void, unknown> {<EOL>    <EOL>    return function* () {<EOL>        yield put({<EOL>            type: `<STR_LIT>`<EOL>        });<EOL>        const response: any = yield* ajaxCall(caller, limit);<EOL>        if (response.code ===","gt":"<NUM_LIT>) {"}
{"input":"<s> export function refreshResource(action: string, caller: () => Promise<any>, width: number = <NUM_LIT>, limit: string = '<STR_LIT>'): () => Generator<any, void, unknown> {<EOL>    <EOL>    return function* () {<EOL>        yield put({<EOL>            type: `<STR_LIT>`<EOL>        });<EOL>        const response: any = yield* ajaxCall(caller, limit);<EOL>        if (response.code === <NUM_LIT>) {<EOL>            yield put({<EOL>                type: `<STR_LIT>`,<EOL>                payload: changeCoverImgUrl(response[action], width),<EOL>","gt":"meta: {"}
{"input":"<s> function aesEncrypt(text: string, secKey: string): string {<EOL>    return CryptoJS.AES.encrypt(text, CryptoJS.enc.Utf8.parse(secKey), { iv: CryptoJS.enc.Utf8.parse(","gt":"'<STR_LIT>') }).toString();"}
{"input":"<s> function checkStatusFilter(response: any): any {<EOL>    if (response.ok) {<EOL>        return response;<EOL>    }<EOL>","gt":"else {"}
{"input":"<s> function checkStatusFilter(response: any): any {<EOL>    if (response.ok) {<EOL>        return response;<EOL>    }<EOL>    else {<EOL>        const error: Error = new Error(response.statusText);<EOL>        error.name = '<STR_LIT>';<EOL>        return {<EOL>","gt":"error"}
{"input":"<s> export function getCsrfFromCookies(): string | null {<EOL>    const csrfReg: RegExpExecArray | null = /csrf=(\\w*)/.","gt":"exec(getCookies());"}
{"input":"<s> function post(uri: string, body: {}): Promise<any> {<EOL>    return fetch(API_BASE_URL + uri, {<EOL>        body: qs.stringify(body),<EOL>        headers: {<EOL>            ...defaultHeaders,<EOL>            '<STR_LIT>':","gt":"getCookies()"}
{"input":"<s> function post(uri: string, body: {}): Promise<any> {<EOL>    return fetch(API_BASE_URL + uri, {<EOL>        body: qs.stringify(body),<EOL>        headers: {<EOL>            ...defaultHeaders,<EOL>            '<STR_LIT>': getCookies()<EOL>        },<EOL>        method: '<STR_LIT>'<EOL>    })<EOL>        .then(","gt":"checkStatusFilter)"}
{"input":"<s> function post(uri: string, body: {}): Promise<any> {<EOL>    return fetch(API_BASE_URL + uri, {<EOL>        body: qs.stringify(body),<EOL>        headers: {<EOL>            ...defaultHeaders,<EOL>            '<STR_LIT>': getCookies()<EOL>        },<EOL>        method: '<STR_LIT>'<EOL>    })<EOL>        .then(checkStatusFilter)<EOL>        .then(setCookiesFilter)<EOL>        .then(parseJSONFilter)<EOL>        .then(","gt":"addUserIdToCookies)"}
